# Comparing `tmp/nanobind-1.9.2-py3-none-any.whl.zip` & `tmp/nanobind-2.0.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,82 +1,86 @@
-Zip file size: 192754 bytes, number of entries: 80
--rw-r--r--  2.0 unx      536 b- defN 24-Feb-23 09:25 nanobind/__init__.py
--rw-r--r--  2.0 unx      839 b- defN 24-Feb-23 09:24 nanobind/__main__.py
--rw-r--r--  2.0 unx    21604 b- defN 24-Feb-23 09:24 nanobind/cmake/darwin-ld-cpython.sym
--rw-r--r--  2.0 unx    24687 b- defN 24-Feb-23 09:24 nanobind/cmake/darwin-ld-pypy.sym
--rw-r--r--  2.0 unx    12296 b- defN 24-Feb-23 09:25 nanobind/cmake/nanobind-config.cmake
--rw-r--r--  2.0 unx    11776 b- defN 24-Feb-23 09:24 nanobind/ext/robin_map/include/tsl/robin_growth_policy.h
--rw-r--r--  2.0 unx    54550 b- defN 24-Feb-23 09:24 nanobind/ext/robin_map/include/tsl/robin_hash.h
--rw-r--r--  2.0 unx    28414 b- defN 24-Feb-23 09:24 nanobind/ext/robin_map/include/tsl/robin_map.h
--rw-r--r--  2.0 unx     1939 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/eval.h
--rw-r--r--  2.0 unx     5601 b- defN 24-Feb-23 09:25 nanobind/include/nanobind/make_iterator.h
--rw-r--r--  2.0 unx     1628 b- defN 24-Feb-23 09:25 nanobind/include/nanobind/nanobind.h
--rw-r--r--  2.0 unx     6228 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/nb_accessor.h
--rw-r--r--  2.0 unx     9513 b- defN 24-Feb-23 09:25 nanobind/include/nanobind/nb_attr.h
--rw-r--r--  2.0 unx     5471 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/nb_call.h
--rw-r--r--  2.0 unx    17851 b- defN 24-Feb-23 09:25 nanobind/include/nanobind/nb_cast.h
--rw-r--r--  2.0 unx    25113 b- defN 24-Feb-23 09:25 nanobind/include/nanobind/nb_class.h
--rw-r--r--  2.0 unx     6232 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/nb_defs.h
--rw-r--r--  2.0 unx     4129 b- defN 24-Feb-23 09:25 nanobind/include/nanobind/nb_descr.h
--rw-r--r--  2.0 unx      666 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/nb_enums.h
--rw-r--r--  2.0 unx     5207 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/nb_error.h
--rw-r--r--  2.0 unx    10802 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/nb_func.h
--rw-r--r--  2.0 unx    21272 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/nb_lib.h
--rw-r--r--  2.0 unx     1413 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/nb_misc.h
--rw-r--r--  2.0 unx     1377 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/nb_python.h
--rw-r--r--  2.0 unx     7314 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/nb_traits.h
--rw-r--r--  2.0 unx     2468 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/nb_tuple.h
--rw-r--r--  2.0 unx    28452 b- defN 24-Feb-23 09:25 nanobind/include/nanobind/nb_types.h
--rw-r--r--  2.0 unx    20322 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/ndarray.h
--rw-r--r--  2.0 unx     7449 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/operators.h
--rw-r--r--  2.0 unx     2975 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/trampoline.h
--rw-r--r--  2.0 unx    17889 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/eigen/dense.h
--rw-r--r--  2.0 unx     6505 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/eigen/sparse.h
--rw-r--r--  2.0 unx     8884 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/intrusive/counter.h
--rw-r--r--  2.0 unx     4874 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/intrusive/counter.inl
--rw-r--r--  2.0 unx     4860 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/intrusive/ref.h
--rw-r--r--  2.0 unx      535 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/stl/array.h
--rw-r--r--  2.0 unx     5939 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/stl/bind_map.h
--rw-r--r--  2.0 unx     7420 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/stl/bind_vector.h
--rw-r--r--  2.0 unx     8673 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/stl/chrono.h
--rw-r--r--  2.0 unx     2154 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/stl/complex.h
--rw-r--r--  2.0 unx     2719 b- defN 24-Feb-23 09:25 nanobind/include/nanobind/stl/filesystem.h
--rw-r--r--  2.0 unx     2477 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/stl/function.h
--rw-r--r--  2.0 unx      527 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/stl/list.h
--rw-r--r--  2.0 unx      596 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/stl/map.h
--rw-r--r--  2.0 unx     2202 b- defN 24-Feb-23 09:25 nanobind/include/nanobind/stl/optional.h
--rw-r--r--  2.0 unx     2770 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/stl/pair.h
--rw-r--r--  2.0 unx      575 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/stl/set.h
--rw-r--r--  2.0 unx     4820 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/stl/shared_ptr.h
--rw-r--r--  2.0 unx     1018 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/stl/string.h
--rw-r--r--  2.0 unx     1062 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/stl/string_view.h
--rw-r--r--  2.0 unx     3307 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/stl/tuple.h
--rw-r--r--  2.0 unx     4389 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/stl/unique_ptr.h
--rw-r--r--  2.0 unx      646 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/stl/unordered_map.h
--rw-r--r--  2.0 unx      652 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/stl/unordered_set.h
--rw-r--r--  2.0 unx     2776 b- defN 24-Feb-23 09:25 nanobind/include/nanobind/stl/variant.h
--rw-r--r--  2.0 unx      537 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/stl/vector.h
--rw-r--r--  2.0 unx    10571 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/stl/detail/chrono.h
--rw-r--r--  2.0 unx     1798 b- defN 24-Feb-23 09:25 nanobind/include/nanobind/stl/detail/nb_array.h
--rw-r--r--  2.0 unx     2904 b- defN 24-Feb-23 09:25 nanobind/include/nanobind/stl/detail/nb_dict.h
--rw-r--r--  2.0 unx     2247 b- defN 24-Feb-23 09:25 nanobind/include/nanobind/stl/detail/nb_list.h
--rw-r--r--  2.0 unx     2033 b- defN 24-Feb-23 09:25 nanobind/include/nanobind/stl/detail/nb_set.h
--rw-r--r--  2.0 unx     3219 b- defN 24-Feb-23 09:24 nanobind/include/nanobind/stl/detail/traits.h
--rw-r--r--  2.0 unx     4239 b- defN 24-Feb-23 09:24 nanobind/src/buffer.h
--rw-r--r--  2.0 unx    30688 b- defN 24-Feb-23 09:24 nanobind/src/common.cpp
--rw-r--r--  2.0 unx     8851 b- defN 24-Feb-23 09:24 nanobind/src/error.cpp
--rw-r--r--  2.0 unx     1009 b- defN 24-Feb-23 09:24 nanobind/src/hash.h
--rw-r--r--  2.0 unx     2318 b- defN 24-Feb-23 09:24 nanobind/src/implicit.cpp
--rw-r--r--  2.0 unx    14686 b- defN 24-Feb-23 09:25 nanobind/src/nb_enum.cpp
--rw-r--r--  2.0 unx    40196 b- defN 24-Feb-23 09:25 nanobind/src/nb_func.cpp
--rw-r--r--  2.0 unx    15914 b- defN 24-Feb-23 09:25 nanobind/src/nb_internals.cpp
--rw-r--r--  2.0 unx    10614 b- defN 24-Feb-23 09:25 nanobind/src/nb_internals.h
--rw-r--r--  2.0 unx    24024 b- defN 24-Feb-23 09:24 nanobind/src/nb_ndarray.cpp
--rw-r--r--  2.0 unx     1905 b- defN 24-Feb-23 09:24 nanobind/src/nb_static_property.cpp
--rw-r--r--  2.0 unx    59202 b- defN 24-Feb-23 09:25 nanobind/src/nb_type.cpp
--rw-r--r--  2.0 unx     5144 b- defN 24-Feb-23 09:24 nanobind/src/trampoline.cpp
--rw-r--r--  2.0 unx     1521 b- defN 24-Feb-23 09:27 nanobind-1.9.2.dist-info/LICENSE
--rw-r--r--  2.0 unx     1406 b- defN 24-Feb-23 09:27 nanobind-1.9.2.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-Feb-23 09:27 nanobind-1.9.2.dist-info/WHEEL
--rw-r--r--  2.0 unx        9 b- defN 24-Feb-23 09:27 nanobind-1.9.2.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     7405 b- defN 24-Feb-23 09:27 nanobind-1.9.2.dist-info/RECORD
-80 files, 698925 bytes uncompressed, 180866 bytes compressed:  74.1%
+Zip file size: 218537 bytes, number of entries: 84
+-rw-r--r--  2.0 unx      536 b- defN 24-May-23 14:29 nanobind/__init__.py
+-rw-r--r--  2.0 unx      855 b- defN 24-May-23 14:27 nanobind/__main__.py
+-rw-r--r--  2.0 unx    50666 b- defN 24-May-23 14:27 nanobind/stubgen.py
+-rw-r--r--  2.0 unx    21656 b- defN 24-May-23 14:27 nanobind/cmake/darwin-ld-cpython.sym
+-rw-r--r--  2.0 unx    24687 b- defN 24-May-23 14:27 nanobind/cmake/darwin-ld-pypy.sym
+-rw-r--r--  2.0 unx    14995 b- defN 24-May-23 14:27 nanobind/cmake/nanobind-config.cmake
+-rw-r--r--  2.0 unx    12181 b- defN 24-May-23 14:27 nanobind/ext/robin_map/include/tsl/robin_growth_policy.h
+-rw-r--r--  2.0 unx    54606 b- defN 24-May-23 14:27 nanobind/ext/robin_map/include/tsl/robin_hash.h
+-rw-r--r--  2.0 unx    28770 b- defN 24-May-23 14:27 nanobind/ext/robin_map/include/tsl/robin_map.h
+-rw-r--r--  2.0 unx     1939 b- defN 24-May-23 14:27 nanobind/include/nanobind/eval.h
+-rw-r--r--  2.0 unx     6738 b- defN 24-May-23 14:27 nanobind/include/nanobind/make_iterator.h
+-rw-r--r--  2.0 unx     1628 b- defN 24-May-23 14:29 nanobind/include/nanobind/nanobind.h
+-rw-r--r--  2.0 unx     6228 b- defN 24-May-23 14:27 nanobind/include/nanobind/nb_accessor.h
+-rw-r--r--  2.0 unx    10641 b- defN 24-May-23 14:27 nanobind/include/nanobind/nb_attr.h
+-rw-r--r--  2.0 unx     5472 b- defN 24-May-23 14:27 nanobind/include/nanobind/nb_call.h
+-rw-r--r--  2.0 unx    25362 b- defN 24-May-23 14:27 nanobind/include/nanobind/nb_cast.h
+-rw-r--r--  2.0 unx    29365 b- defN 24-May-23 14:27 nanobind/include/nanobind/nb_class.h
+-rw-r--r--  2.0 unx     6855 b- defN 24-May-23 14:27 nanobind/include/nanobind/nb_defs.h
+-rw-r--r--  2.0 unx     5130 b- defN 24-May-23 14:27 nanobind/include/nanobind/nb_descr.h
+-rw-r--r--  2.0 unx      666 b- defN 24-May-23 14:27 nanobind/include/nanobind/nb_enums.h
+-rw-r--r--  2.0 unx     5207 b- defN 24-May-23 14:27 nanobind/include/nanobind/nb_error.h
+-rw-r--r--  2.0 unx    15280 b- defN 24-May-23 14:27 nanobind/include/nanobind/nb_func.h
+-rw-r--r--  2.0 unx    22139 b- defN 24-May-23 14:27 nanobind/include/nanobind/nb_lib.h
+-rw-r--r--  2.0 unx     1413 b- defN 24-May-23 14:27 nanobind/include/nanobind/nb_misc.h
+-rw-r--r--  2.0 unx     1377 b- defN 24-May-23 14:27 nanobind/include/nanobind/nb_python.h
+-rw-r--r--  2.0 unx     8923 b- defN 24-May-23 14:27 nanobind/include/nanobind/nb_traits.h
+-rw-r--r--  2.0 unx     2468 b- defN 24-May-23 14:27 nanobind/include/nanobind/nb_tuple.h
+-rw-r--r--  2.0 unx    29798 b- defN 24-May-23 14:27 nanobind/include/nanobind/nb_types.h
+-rw-r--r--  2.0 unx    20407 b- defN 24-May-23 14:27 nanobind/include/nanobind/ndarray.h
+-rw-r--r--  2.0 unx     7449 b- defN 24-May-23 14:27 nanobind/include/nanobind/operators.h
+-rw-r--r--  2.0 unx     2975 b- defN 24-May-23 14:27 nanobind/include/nanobind/trampoline.h
+-rw-r--r--  2.0 unx      753 b- defN 24-May-23 14:27 nanobind/include/nanobind/typing.h
+-rw-r--r--  2.0 unx    18189 b- defN 24-May-23 14:27 nanobind/include/nanobind/eigen/dense.h
+-rw-r--r--  2.0 unx     6657 b- defN 24-May-23 14:27 nanobind/include/nanobind/eigen/sparse.h
+-rw-r--r--  2.0 unx     8884 b- defN 24-May-23 14:27 nanobind/include/nanobind/intrusive/counter.h
+-rw-r--r--  2.0 unx     4874 b- defN 24-May-23 14:27 nanobind/include/nanobind/intrusive/counter.inl
+-rw-r--r--  2.0 unx     4860 b- defN 24-May-23 14:27 nanobind/include/nanobind/intrusive/ref.h
+-rw-r--r--  2.0 unx      535 b- defN 24-May-23 14:27 nanobind/include/nanobind/stl/array.h
+-rw-r--r--  2.0 unx     6234 b- defN 24-May-23 14:27 nanobind/include/nanobind/stl/bind_map.h
+-rw-r--r--  2.0 unx     7564 b- defN 24-May-23 14:27 nanobind/include/nanobind/stl/bind_vector.h
+-rw-r--r--  2.0 unx     8673 b- defN 24-May-23 14:27 nanobind/include/nanobind/stl/chrono.h
+-rw-r--r--  2.0 unx     1968 b- defN 24-May-23 14:27 nanobind/include/nanobind/stl/complex.h
+-rw-r--r--  2.0 unx     2884 b- defN 24-May-23 14:27 nanobind/include/nanobind/stl/filesystem.h
+-rw-r--r--  2.0 unx     2488 b- defN 24-May-23 14:27 nanobind/include/nanobind/stl/function.h
+-rw-r--r--  2.0 unx      527 b- defN 24-May-23 14:27 nanobind/include/nanobind/stl/list.h
+-rw-r--r--  2.0 unx      596 b- defN 24-May-23 14:27 nanobind/include/nanobind/stl/map.h
+-rw-r--r--  2.0 unx     1811 b- defN 24-May-23 14:27 nanobind/include/nanobind/stl/optional.h
+-rw-r--r--  2.0 unx     2925 b- defN 24-May-23 14:27 nanobind/include/nanobind/stl/pair.h
+-rw-r--r--  2.0 unx      575 b- defN 24-May-23 14:27 nanobind/include/nanobind/stl/set.h
+-rw-r--r--  2.0 unx     4820 b- defN 24-May-23 14:27 nanobind/include/nanobind/stl/shared_ptr.h
+-rw-r--r--  2.0 unx     1018 b- defN 24-May-23 14:27 nanobind/include/nanobind/stl/string.h
+-rw-r--r--  2.0 unx     1062 b- defN 24-May-23 14:27 nanobind/include/nanobind/stl/string_view.h
+-rw-r--r--  2.0 unx     3576 b- defN 24-May-23 14:27 nanobind/include/nanobind/stl/tuple.h
+-rw-r--r--  2.0 unx     5747 b- defN 24-May-23 14:27 nanobind/include/nanobind/stl/unique_ptr.h
+-rw-r--r--  2.0 unx      646 b- defN 24-May-23 14:27 nanobind/include/nanobind/stl/unordered_map.h
+-rw-r--r--  2.0 unx      652 b- defN 24-May-23 14:27 nanobind/include/nanobind/stl/unordered_set.h
+-rw-r--r--  2.0 unx     2337 b- defN 24-May-23 14:27 nanobind/include/nanobind/stl/variant.h
+-rw-r--r--  2.0 unx      537 b- defN 24-May-23 14:27 nanobind/include/nanobind/stl/vector.h
+-rw-r--r--  2.0 unx     1023 b- defN 24-May-23 14:27 nanobind/include/nanobind/stl/wstring.h
+-rw-r--r--  2.0 unx    10571 b- defN 24-May-23 14:27 nanobind/include/nanobind/stl/detail/chrono.h
+-rw-r--r--  2.0 unx     1834 b- defN 24-May-23 14:27 nanobind/include/nanobind/stl/detail/nb_array.h
+-rw-r--r--  2.0 unx     2862 b- defN 24-May-23 14:27 nanobind/include/nanobind/stl/detail/nb_dict.h
+-rw-r--r--  2.0 unx     2279 b- defN 24-May-23 14:27 nanobind/include/nanobind/stl/detail/nb_list.h
+-rw-r--r--  2.0 unx     2107 b- defN 24-May-23 14:27 nanobind/include/nanobind/stl/detail/nb_set.h
+-rw-r--r--  2.0 unx     3219 b- defN 24-May-23 14:27 nanobind/include/nanobind/stl/detail/traits.h
+-rw-r--r--  2.0 unx     4239 b- defN 24-May-23 14:27 nanobind/src/buffer.h
+-rw-r--r--  2.0 unx    31127 b- defN 24-May-23 14:27 nanobind/src/common.cpp
+-rw-r--r--  2.0 unx     8851 b- defN 24-May-23 14:27 nanobind/src/error.cpp
+-rw-r--r--  2.0 unx     1009 b- defN 24-May-23 14:27 nanobind/src/hash.h
+-rw-r--r--  2.0 unx     2350 b- defN 24-May-23 14:27 nanobind/src/implicit.cpp
+-rw-r--r--  2.0 unx     3908 b- defN 24-May-23 14:27 nanobind/src/nb_combined.cpp
+-rw-r--r--  2.0 unx     6951 b- defN 24-May-23 14:27 nanobind/src/nb_enum.cpp
+-rw-r--r--  2.0 unx    47581 b- defN 24-May-23 14:27 nanobind/src/nb_func.cpp
+-rw-r--r--  2.0 unx    16440 b- defN 24-May-23 14:27 nanobind/src/nb_internals.cpp
+-rw-r--r--  2.0 unx    11572 b- defN 24-May-23 14:27 nanobind/src/nb_internals.h
+-rw-r--r--  2.0 unx    24240 b- defN 24-May-23 14:27 nanobind/src/nb_ndarray.cpp
+-rw-r--r--  2.0 unx     1905 b- defN 24-May-23 14:27 nanobind/src/nb_static_property.cpp
+-rw-r--r--  2.0 unx    64788 b- defN 24-May-23 14:27 nanobind/src/nb_type.cpp
+-rw-r--r--  2.0 unx     5144 b- defN 24-May-23 14:27 nanobind/src/trampoline.cpp
+-rw-r--r--  2.0 unx     1521 b- defN 24-May-23 14:32 nanobind-2.0.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     1406 b- defN 24-May-23 14:32 nanobind-2.0.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-May-23 14:32 nanobind-2.0.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx        9 b- defN 24-May-23 14:32 nanobind-2.0.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     7753 b- defN 24-May-23 14:32 nanobind-2.0.0.dist-info/RECORD
+84 files, 792585 bytes uncompressed, 206105 bytes compressed:  74.0%
```

## zipnote {}

```diff
@@ -1,13 +1,16 @@
 Filename: nanobind/__init__.py
 Comment: 
 
 Filename: nanobind/__main__.py
 Comment: 
 
+Filename: nanobind/stubgen.py
+Comment: 
+
 Filename: nanobind/cmake/darwin-ld-cpython.sym
 Comment: 
 
 Filename: nanobind/cmake/darwin-ld-pypy.sym
 Comment: 
 
 Filename: nanobind/cmake/nanobind-config.cmake
@@ -84,14 +87,17 @@
 
 Filename: nanobind/include/nanobind/operators.h
 Comment: 
 
 Filename: nanobind/include/nanobind/trampoline.h
 Comment: 
 
+Filename: nanobind/include/nanobind/typing.h
+Comment: 
+
 Filename: nanobind/include/nanobind/eigen/dense.h
 Comment: 
 
 Filename: nanobind/include/nanobind/eigen/sparse.h
 Comment: 
 
 Filename: nanobind/include/nanobind/intrusive/counter.h
@@ -162,14 +168,17 @@
 
 Filename: nanobind/include/nanobind/stl/variant.h
 Comment: 
 
 Filename: nanobind/include/nanobind/stl/vector.h
 Comment: 
 
+Filename: nanobind/include/nanobind/stl/wstring.h
+Comment: 
+
 Filename: nanobind/include/nanobind/stl/detail/chrono.h
 Comment: 
 
 Filename: nanobind/include/nanobind/stl/detail/nb_array.h
 Comment: 
 
 Filename: nanobind/include/nanobind/stl/detail/nb_dict.h
@@ -195,14 +204,17 @@
 
 Filename: nanobind/src/hash.h
 Comment: 
 
 Filename: nanobind/src/implicit.cpp
 Comment: 
 
+Filename: nanobind/src/nb_combined.cpp
+Comment: 
+
 Filename: nanobind/src/nb_enum.cpp
 Comment: 
 
 Filename: nanobind/src/nb_func.cpp
 Comment: 
 
 Filename: nanobind/src/nb_internals.cpp
@@ -219,23 +231,23 @@
 
 Filename: nanobind/src/nb_type.cpp
 Comment: 
 
 Filename: nanobind/src/trampoline.cpp
 Comment: 
 
-Filename: nanobind-1.9.2.dist-info/LICENSE
+Filename: nanobind-2.0.0.dist-info/LICENSE
 Comment: 
 
-Filename: nanobind-1.9.2.dist-info/METADATA
+Filename: nanobind-2.0.0.dist-info/METADATA
 Comment: 
 
-Filename: nanobind-1.9.2.dist-info/WHEEL
+Filename: nanobind-2.0.0.dist-info/WHEEL
 Comment: 
 
-Filename: nanobind-1.9.2.dist-info/top_level.txt
+Filename: nanobind-2.0.0.dist-info/top_level.txt
 Comment: 
 
-Filename: nanobind-1.9.2.dist-info/RECORD
+Filename: nanobind-2.0.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## nanobind/__init__.py

```diff
@@ -8,14 +8,14 @@
     "Return the path to the nanobind include directory"
     return os.path.join(os.path.abspath(os.path.dirname(__file__)), "include")
 
 def cmake_dir() -> str:
     "Return the path to the nanobind CMake module directory."
     return os.path.join(os.path.abspath(os.path.dirname(__file__)), "cmake")
 
-__version__ = "1.9.2"
+__version__ = "2.0.0"
 
 __all__ = (
     "__version__",
     "include_dir",
     "cmake_dir",
 )
```

## nanobind/__main__.py

```diff
@@ -1,10 +1,10 @@
 import argparse
 import sys
-import sysconfig
+import sysconfig  # type: ignore
 
 from . import __version__, include_dir, cmake_dir
 
 
 def main() -> None:
     parser = argparse.ArgumentParser()
     parser.add_argument(
```

## nanobind/cmake/darwin-ld-cpython.sym

```diff
@@ -79,14 +79,16 @@
 -U _PyCodec_RegisterError
 -U _PyCodec_ReplaceErrors
 -U _PyCodec_StreamReader
 -U _PyCodec_StreamWriter
 -U _PyCodec_StrictErrors
 -U _PyCodec_Unregister
 -U _PyCodec_XMLCharRefReplaceErrors
+-U _PyComplex_AsCComplex
+-U _PyComplex_FromCComplex
 -U _PyComplex_FromDoubles
 -U _PyComplex_ImagAsDouble
 -U _PyComplex_RealAsDouble
 -U _PyComplex_Type
 -U _PyDescr_NewClassMethod
 -U _PyDescr_NewGetSet
 -U _PyDescr_NewMember
```

## nanobind/cmake/nanobind-config.cmake

```diff
@@ -9,28 +9,38 @@
 # We always need to know the extension
 if(WIN32)
   set(NB_SUFFIX_EXT ".pyd")
 else()
   set(NB_SUFFIX_EXT "${CMAKE_SHARED_MODULE_SUFFIX}")
 endif()
 
-# This was added in CMake 3.17+, also available earlier in scikit-build-core.
+# Check if FindPython/scikit-build-core defined a SOABI/SOSABI variable
+if(DEFINED SKBUILD_SOABI)
+  set(NB_SOABI "${SKBUILD_SOABI}")
+elseif(DEFINED Python_SOABI)
+  set(NB_SOABI "${Python_SOABI}")
+endif()
+
+if(DEFINED SKBUILD_SOSABI)
+  set(NB_SOSABI "${SKBUILD_SOSABI}")
+elseif(DEFINED Python_SOSABI)
+  set(NB_SOSABI "${Python_SOSABI}")
+endif()
+
 # PyPy sets an invalid SOABI (platform missing), causing older FindPythons to
 # report an incorrect value. Only use it if it looks correct (X-X-X form).
-if(DEFINED Python_SOABI AND "${Python_SOABI}" MATCHES ".+-.+-.+")
-  set(NB_SUFFIX ".${Python_SOABI}${NB_SUFFIX_EXT}")
+if(DEFINED NB_SOABI AND "${NB_SOABI}" MATCHES ".+-.+-.+")
+  set(NB_SUFFIX ".${NB_SOABI}${NB_SUFFIX_EXT}")
 endif()
 
-# Python_SOSABI is guaranteed to be available in CMake 3.26+, and it may
-# also be available as part of backported FindPython in scikit-build-core.
-if(DEFINED Python_SOSABI)
-  if(Python_SOSABI STREQUAL "")
+if(DEFINED NB_SOSABI)
+  if(NB_SOSABI STREQUAL "")
     set(NB_SUFFIX_S "${NB_SUFFIX_EXT}")
   else()
-    set(NB_SUFFIX_S ".${Python_SOSABI}${NB_SUFFIX_EXT}")
+    set(NB_SUFFIX_S ".${NB_SOSABI}${NB_SUFFIX_EXT}")
   endif()
 endif()
 
 # If either suffix is missing, call Python to compute it
 if(NOT DEFINED NB_SUFFIX OR NOT DEFINED NB_SUFFIX_S)
   # Query Python directly to get the right suffix.
   execute_process(
@@ -118,14 +128,15 @@
     ${NB_DIR}/include/nanobind/nb_misc.h
     ${NB_DIR}/include/nanobind/nb_python.h
     ${NB_DIR}/include/nanobind/nb_traits.h
     ${NB_DIR}/include/nanobind/nb_tuple.h
     ${NB_DIR}/include/nanobind/nb_types.h
     ${NB_DIR}/include/nanobind/ndarray.h
     ${NB_DIR}/include/nanobind/trampoline.h
+    ${NB_DIR}/include/nanobind/typing.h
     ${NB_DIR}/include/nanobind/operators.h
     ${NB_DIR}/include/nanobind/stl/array.h
     ${NB_DIR}/include/nanobind/stl/bind_map.h
     ${NB_DIR}/include/nanobind/stl/bind_vector.h
     ${NB_DIR}/include/nanobind/stl/detail
     ${NB_DIR}/include/nanobind/stl/detail/nb_array.h
     ${NB_DIR}/include/nanobind/stl/detail/nb_dict.h
@@ -354,7 +365,84 @@
 
   if (ARG_NB_STATIC AND NOT ARG_MUSL_DYNAMIC_LIBCPP)
     nanobind_musl_static_libcpp(${name})
   endif()
 
   nanobind_set_visibility(${name})
 endfunction()
+
+function (nanobind_add_stub name)
+  cmake_parse_arguments(PARSE_ARGV 1 ARG "VERBOSE;INCLUDE_PRIVATE;EXCLUDE_DOCSTRINGS;INSTALL_TIME;EXCLUDE_FROM_ALL" "MODULE;OUTPUT;MARKER_FILE;COMPONENT;PATTERN_FILE" "PYTHON_PATH;DEPENDS")
+
+  if (EXISTS ${NB_DIR}/src/stubgen.py)
+    set(NB_STUBGEN "${NB_DIR}/src/stubgen.py")
+  elseif (EXISTS ${NB_DIR}/stubgen.py)
+    set(NB_STUBGEN "${NB_DIR}/stubgen.py")
+  else()
+    message(FATAL_ERROR "nanobind_add_stub(): could not locate 'stubgen.py'!")
+  endif()
+
+  if (NOT ARG_VERBOSE)
+    list(APPEND NB_STUBGEN_ARGS -q)
+  else()
+    set(NB_STUBGEN_EXTRA USES_TERMINAL)
+  endif()
+
+  if (ARG_INCLUDE_PRIVATE)
+    list(APPEND NB_STUBGEN_ARGS -P)
+  endif()
+
+  if (ARG_EXCLUDE_DOCSTRINGS)
+    list(APPEND NB_STUBGEN_ARGS -D)
+  endif()
+
+  foreach (TMP IN LISTS ARG_PYTHON_PATH)
+    list(APPEND NB_STUBGEN_ARGS -i "${TMP}")
+  endforeach()
+
+  if (ARG_PATTERN_FILE)
+    list(APPEND NB_STUBGEN_ARGS -p "${ARG_PATTERN_FILE}")
+  endif()
+
+  if (ARG_MARKER_FILE)
+    list(APPEND NB_STUBGEN_ARGS -M "${ARG_MARKER_FILE}")
+    list(APPEND NB_STUBGEN_OUTPUTS "${ARG_MARKER_FILE}")
+  endif()
+
+  if (NOT ARG_MODULE)
+    message(FATAL_ERROR "nanobind_add_stub(): a 'MODULE' argument must be specified!")
+  else()
+    list(APPEND NB_STUBGEN_ARGS -m "${ARG_MODULE}")
+  endif()
+
+  if (NOT ARG_OUTPUT)
+    message(FATAL_ERROR "nanobind_add_stub(): an 'OUTPUT' argument must be specified!")
+  else()
+    list(APPEND NB_STUBGEN_ARGS -o "${ARG_OUTPUT}")
+    list(APPEND NB_STUBGEN_OUTPUTS "${ARG_OUTPUT}")
+  endif()
+
+  set(NB_STUBGEN_CMD "${Python_EXECUTABLE}" "${NB_STUBGEN}" ${NB_STUBGEN_ARGS})
+
+  if (NOT ARG_INSTALL_TIME)
+    add_custom_command(
+      OUTPUT ${NB_STUBGEN_OUTPUTS}
+      COMMAND ${NB_STUBGEN_CMD}
+      WORKING_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}"
+      DEPENDS ${ARG_DEPENDS} "${NB_STUBGEN}" "${ARG_PATTERN_FILE}"
+      ${NB_STUBGEN_EXTRA}
+    )
+    add_custom_target(${name} ALL DEPENDS ${NB_STUBGEN_OUTPUTS})
+  else()
+    set(NB_STUBGEN_EXTRA "")
+    if (ARG_COMPONENT)
+      list(APPEND NB_STUBGEN_EXTRA COMPONENT ${ARG_COMPONENT})
+    endif()
+    if (ARG_EXCLUDE_FROM_ALL)
+      list(APPEND NB_STUBGEN_EXTRA EXCLUDE_FROM_ALL)
+    endif()
+    # \${CMAKE_INSTALL_PREFIX} has same effect as $<INSTALL_PREFIX>
+    # This is for compatibility with CMake < 3.27.
+    # For more info: https://github.com/wjakob/nanobind/issues/420#issuecomment-1971353531
+    install(CODE "set(CMD \"${NB_STUBGEN_CMD}\")\nexecute_process(\n COMMAND \$\{CMD\}\n WORKING_DIRECTORY \"\${CMAKE_INSTALL_PREFIX}\"\n)" ${NB_STUBGEN_EXTRA})
+  endif()
+endfunction()
```

## nanobind/ext/robin_map/include/tsl/robin_growth_policy.h

```diff
@@ -31,14 +31,24 @@
 #include <cstddef>
 #include <cstdint>
 #include <iterator>
 #include <limits>
 #include <ratio>
 #include <stdexcept>
 
+// A change of the major version indicates an API and/or ABI break (change of
+// in-memory layout of the data structure)
+#define TSL_RH_VERSION_MAJOR 1
+// A change of the minor version indicates the addition of a feature without
+// impact on the API/ABI
+#define TSL_RH_VERSION_MINOR 3
+// A change of the patch version indicates a bugfix without additional
+// functionality
+#define TSL_RH_VERSION_PATCH 0
+
 #ifdef TSL_DEBUG
 #define tsl_rh_assert(expr) assert(expr)
 #else
 #define tsl_rh_assert(expr) (static_cast<void>(0))
 #endif
 
 /**
```

## nanobind/ext/robin_map/include/tsl/robin_hash.h

```diff
@@ -83,14 +83,16 @@
   const bool is_same_signedness =
       (std::is_unsigned<T>::value && std::is_unsigned<U>::value) ||
       (std::is_signed<T>::value && std::is_signed<U>::value);
   if (!is_same_signedness && (ret < T{}) != (value < U{})) {
     TSL_RH_THROW_OR_TERMINATE(std::runtime_error, error_message);
   }
 
+  TSL_RH_UNUSED(error_message);
+
   return ret;
 }
 
 template <class T, class Deserializer>
 static T deserialize_value(Deserializer& deserializer) {
   // MSVC < 2017 is not conformant, circumvent the problem by removing the
   // template keyword
@@ -814,14 +816,18 @@
     if (hint != cend() && compare_keys(KeySelect()(*hint), key)) {
       return mutable_iterator(hint);
     }
 
     return try_emplace(std::forward<K>(key), std::forward<Args>(args)...).first;
   }
 
+  void erase_fast(iterator pos) {
+    erase_from_bucket(pos);
+  }
+
   /**
    * Here to avoid `template<class K> size_type erase(const K& key)` being used
    * when we use an `iterator` instead of a `const_iterator`.
    */
   iterator erase(iterator pos) {
     erase_from_bucket(pos);
 
@@ -830,16 +836,14 @@
      * Check if there is a new value in the bucket, if not get the next
      * non-empty.
      */
     if (pos.m_bucket->empty()) {
       ++pos;
     }
 
-    m_try_shrink_on_next_insert = true;
-
     return pos;
   }
 
   iterator erase(const_iterator pos) { return erase(mutable_iterator(pos)); }
 
   iterator erase(const_iterator first, const_iterator last) {
     if (first == last) {
@@ -910,16 +914,14 @@
   }
 
   template <class K>
   size_type erase(const K& key, std::size_t hash) {
     auto it = find(key, hash);
     if (it != end()) {
       erase_from_bucket(it);
-      m_try_shrink_on_next_insert = true;
-
       return 1;
     } else {
       return 0;
     }
   }
 
   void swap(robin_hash& other) {
@@ -1205,14 +1207,15 @@
           new_distance, m_buckets[ibucket].truncated_hash(),
           std::move(m_buckets[ibucket].value()));
       m_buckets[ibucket].clear();
 
       previous_ibucket = ibucket;
       ibucket = next_bucket(ibucket);
     }
+    m_try_shrink_on_next_insert = true;
   }
 
   template <class K, class... Args>
   std::pair<iterator, bool> insert_impl(const K& key,
                                         Args&&... value_type_args) {
     const std::size_t hash = hash_key(key);
```

## nanobind/ext/robin_map/include/tsl/robin_map.h

```diff
@@ -336,14 +336,22 @@
   iterator erase(const_iterator pos) { return m_ht.erase(pos); }
   iterator erase(const_iterator first, const_iterator last) {
     return m_ht.erase(first, last);
   }
   size_type erase(const key_type& key) { return m_ht.erase(key); }
 
   /**
+   * Erase the element at position 'pos'. In contrast to the regular erase()
+   * function, erase_fast() does not return an iterator. This allows it to be
+   * faster especially in hash tables with a low load factor, where finding the
+   * next nonempty bucket would be costly.
+   */
+  void erase_fast(iterator pos) { return m_ht.erase_fast(pos); }
+
+  /**
    * Use the hash value 'precalculated_hash' instead of hashing the key. The
    * hash value should be the same as hash_function()(key). Useful to speed-up
    * the lookup to the value if you already have the hash.
    */
   size_type erase(const key_type& key, std::size_t precalculated_hash) {
     return m_ht.erase(key, precalculated_hash);
   }
```

## nanobind/include/nanobind/make_iterator.h

```diff
@@ -21,38 +21,60 @@
           typename Sentinel, typename ValueType, typename... Extra>
 struct iterator_state {
     Iterator it;
     Sentinel end;
     bool first_or_done;
 };
 
+template <typename T>
+struct remove_rvalue_ref { using type = T; };
+template <typename T>
+struct remove_rvalue_ref<T&&> { using type = T; };
+
 // Note: these helpers take the iterator by non-const reference because some
 // iterators in the wild can't be dereferenced when const.
 template <typename Iterator> struct iterator_access {
     using result_type = decltype(*std::declval<Iterator &>());
     result_type operator()(Iterator &it) const { return *it; }
 };
 
 template <typename Iterator> struct iterator_key_access {
-    using result_type = const decltype((*std::declval<Iterator &>()).first) &;
+    // Note double parens in decltype((...)) to capture the value category
+    // as well. This will be lvalue if the iterator's operator* returned an
+    // lvalue reference, and xvalue if the iterator's operator* returned an
+    // object (or rvalue reference but that's unlikely). decltype of an xvalue
+    // produces T&&, but we want to return a value T from operator() in that
+    // case, in order to avoid creating a Python object that references a
+    // C++ temporary. Thus, pass the result through remove_rvalue_ref.
+    using result_type = typename remove_rvalue_ref<
+        decltype(((*std::declval<Iterator &>()).first))>::type;
     result_type operator()(Iterator &it) const { return (*it).first; }
 };
 
 template <typename Iterator> struct iterator_value_access {
-    using result_type = const decltype((*std::declval<Iterator &>()).second) &;
+    using result_type = typename remove_rvalue_ref<
+        decltype(((*std::declval<Iterator &>()).second))>::type;
     result_type operator()(Iterator &it) const { return (*it).second; }
 };
 
 template <typename Access, rv_policy Policy, typename Iterator,
           typename Sentinel, typename ValueType, typename... Extra>
-iterator make_iterator_impl(handle scope, const char *name,
-                            Iterator &&first, Sentinel &&last,
-                            Extra &&...extra) {
+typed<iterator, ValueType> make_iterator_impl(handle scope, const char *name,
+                                              Iterator &&first, Sentinel &&last,
+                                              Extra &&...extra) {
     using State = iterator_state<Access, Policy, Iterator, Sentinel, ValueType, Extra...>;
 
+    static_assert(
+        !detail::is_base_caster_v<detail::make_caster<ValueType>> ||
+        detail::is_copy_constructible_v<ValueType> ||
+        (Policy != rv_policy::automatic_reference &&
+         Policy != rv_policy::copy),
+        "make_iterator_impl(): the generated __next__ would copy elements, so the "
+        "element type must be copy-constructible");
+
     if (!type<State>().is_valid()) {
         class_<State>(scope, name)
             .def("__iter__", [](handle h) { return h; })
             .def("__next__",
                  [](State &s) -> ValueType {
                      if (!s.first_or_done)
                          ++s.it;
@@ -66,68 +88,68 @@
 
                      return Access()(s.it);
                  },
                  std::forward<Extra>(extra)...,
                  Policy);
     }
 
-    return borrow<iterator>(cast(State{ std::forward<Iterator>(first),
-                                        std::forward<Sentinel>(last), true }));
+    return borrow<typed<iterator, ValueType>>(cast(State{
+        std::forward<Iterator>(first), std::forward<Sentinel>(last), true }));
 }
 
 NAMESPACE_END(detail)
 
 /// Makes a python iterator from a first and past-the-end C++ InputIterator.
-template <rv_policy Policy = rv_policy::reference_internal,
+template <rv_policy Policy = rv_policy::automatic_reference,
           typename Iterator,
           typename Sentinel,
           typename ValueType = typename detail::iterator_access<Iterator>::result_type,
           typename... Extra>
-iterator make_iterator(handle scope, const char *name, Iterator &&first, Sentinel &&last, Extra &&...extra) {
+auto make_iterator(handle scope, const char *name, Iterator &&first, Sentinel &&last, Extra &&...extra) {
     return detail::make_iterator_impl<detail::iterator_access<Iterator>, Policy,
                                       Iterator, Sentinel, ValueType, Extra...>(
         scope, name, std::forward<Iterator>(first),
         std::forward<Sentinel>(last), std::forward<Extra>(extra)...);
 }
 
 /// Makes an iterator over the keys (`.first`) of a iterator over pairs from a
 /// first and past-the-end InputIterator.
-template <rv_policy Policy = rv_policy::reference_internal, typename Iterator,
+template <rv_policy Policy = rv_policy::automatic_reference, typename Iterator,
           typename Sentinel,
           typename KeyType =
               typename detail::iterator_key_access<Iterator>::result_type,
           typename... Extra>
-iterator make_key_iterator(handle scope, const char *name, Iterator &&first,
-                           Sentinel &&last, Extra &&...extra) {
+auto make_key_iterator(handle scope, const char *name, Iterator &&first,
+                       Sentinel &&last, Extra &&...extra) {
     return detail::make_iterator_impl<detail::iterator_key_access<Iterator>,
                                       Policy, Iterator, Sentinel, KeyType,
                                       Extra...>(
         scope, name, std::forward<Iterator>(first),
         std::forward<Sentinel>(last), std::forward<Extra>(extra)...);
 }
 
 /// Makes an iterator over the values (`.second`) of a iterator over pairs from a
 /// first and past-the-end InputIterator.
-template <rv_policy Policy = rv_policy::reference_internal,
+template <rv_policy Policy = rv_policy::automatic_reference,
           typename Iterator,
           typename Sentinel,
           typename ValueType = typename detail::iterator_value_access<Iterator>::result_type,
           typename... Extra>
-iterator make_value_iterator(handle scope, const char *name, Iterator &&first, Sentinel &&last, Extra &&...extra) {
+auto make_value_iterator(handle scope, const char *name, Iterator &&first, Sentinel &&last, Extra &&...extra) {
     return detail::make_iterator_impl<detail::iterator_value_access<Iterator>,
                                       Policy, Iterator, Sentinel, ValueType,
                                       Extra...>(
         scope, name, std::forward<Iterator>(first),
         std::forward<Sentinel>(last), std::forward<Extra>(extra)...);
 }
 
 /// Makes an iterator over values of a container supporting `std::begin()`/`std::end()`
-template <rv_policy Policy = rv_policy::reference_internal,
+template <rv_policy Policy = rv_policy::automatic_reference,
           typename Type,
           typename... Extra>
-iterator make_iterator(handle scope, const char *name, Type &value, Extra &&...extra) {
+auto make_iterator(handle scope, const char *name, Type &value, Extra &&...extra) {
     return make_iterator<Policy>(scope, name, std::begin(value),
                                  std::end(value),
                                  std::forward<Extra>(extra)...);
 }
 
 NAMESPACE_END(NB_NAMESPACE)
```

## nanobind/include/nanobind/nanobind.h

```diff
@@ -17,17 +17,17 @@
 #  pragma warning(push)
 #  pragma warning(disable: 4702) // unreachable code (e.g. when binding a noreturn function)
    // The next two lines disable warnings that are "just noise" according to Stephan T. Lavavej (a MSFT STL maintainer)
 #  pragma warning(disable: 4275) // non dll-interface class 'std::exception' used as base for dll-interface class [..]
 #  pragma warning(disable: 4251) // [..] needs to have a dll-interface to be used by clients of class [..]
 #endif
 
-#define NB_VERSION_MAJOR 1
-#define NB_VERSION_MINOR 9
-#define NB_VERSION_PATCH 2
+#define NB_VERSION_MAJOR 2
+#define NB_VERSION_MINOR 0
+#define NB_VERSION_PATCH 0
 
 // Core C++ headers that nanobind depends on
 #include <cstdint>
 #include <exception>
 #include <stdexcept>
 #include <type_traits>
 #include <typeinfo>
```

## nanobind/include/nanobind/nb_attr.h

```diff
@@ -17,26 +17,31 @@
 struct name {
     const char *value;
     NB_INLINE name(const char *value) : value(value) {}
 };
 
 struct arg_v;
 struct arg {
-    NB_INLINE constexpr explicit arg(const char *name = nullptr) : name(name) {}
+    NB_INLINE constexpr explicit arg(const char *name = nullptr) : name_(name), signature_(nullptr) { }
     template <typename T> NB_INLINE arg_v operator=(T &&value) const;
     NB_INLINE arg &noconvert(bool value = true) {
         convert_ = !value;
         return *this;
     }
     NB_INLINE arg &none(bool value = true) {
         none_ = value;
         return *this;
     }
 
-    const char *name;
+    NB_INLINE arg &sig(const char *value) {
+        signature_ = value;
+        return *this;
+    }
+
+    const char *name_, *signature_;
     uint8_t convert_{ true };
     bool none_{ false };
 };
 
 struct arg_v : arg {
     object value;
     NB_INLINE arg_v(const arg &base, object &&value)
@@ -50,14 +55,16 @@
 struct dynamic_attr {};
 struct is_weak_referenceable {};
 struct is_method {};
 struct is_implicit {};
 struct is_operator {};
 struct is_arithmetic {};
 struct is_final {};
+struct is_generic {};
+struct kw_only {};
 
 template <size_t /* Nurse */, size_t /* Patient */> struct keep_alive {};
 template <typename T> struct supplement {};
 template <typename T> struct intrusive_ptr {
     intrusive_ptr(void (*set_self_py)(T *, PyObject *) noexcept)
         : set_self_py(set_self_py) { }
     void (*set_self_py)(T *, PyObject *) noexcept;
@@ -71,17 +78,17 @@
 struct type_slots_callback {
     using cb_t = void (*)(const detail::type_init_data *t,
                           PyType_Slot *&slots, size_t max_slots) noexcept;
     type_slots_callback(cb_t callback) : callback(callback) { }
     cb_t callback;
 };
 
-struct raw_doc {
+struct sig {
     const char *value;
-    raw_doc(const char *doc) : value(doc) {}
+    sig(const char *value) : value(value) { }
 };
 
 struct is_getter { };
 
 NAMESPACE_BEGIN(literals)
 constexpr arg operator"" _a(const char *name, size_t) { return arg(name); }
 NAMESPACE_END(literals)
@@ -111,22 +118,23 @@
     is_implicit = (1 << 12),
     /// Is this function an arithmetic operator?
     is_operator = (1 << 13),
     /// When the function is GCed, do we need to call func_data_prelim::free_capture?
     has_free = (1 << 14),
     /// Should the func_new() call return a new reference?
     return_ref = (1 << 15),
-    /// Does this overload specify a raw docstring that should take precedence?
-    raw_doc = (1 << 16),
+    /// Does this overload specify a custom function signature (for docstrings, typing)
+    has_signature = (1 << 16),
     /// Does this function have one or more nb::keep_alive() annotations?
     has_keep_alive = (1 << 17)
 };
 
 struct arg_data {
     const char *name;
+    const char *signature;
     PyObject *name_py;
     PyObject *value;
     bool convert;
     bool none;
 };
 
 template <size_t Size> struct func_data_prelim {
@@ -145,16 +153,28 @@
 
     /// C++ types referenced by 'descr'
     const std::type_info **descr_types;
 
     /// Supplementary flags
     uint32_t flags;
 
-    /// Total number of function call arguments
-    uint32_t nargs;
+    /// Total number of parameters accepted by the C++ function; nb::args
+    /// and nb::kwargs parameters are counted as one each. If the
+    /// 'has_args' flag is set, then there is one arg_data structure
+    /// for each of these.
+    uint16_t nargs;
+
+    /// Number of paramters to the C++ function that may be filled from
+    /// Python positional arguments without additional ceremony. nb::args and
+    /// nb::kwargs parameters are not counted in this total, nor are any
+    /// parameters after nb::args or after a nb::kw_only annotation.
+    /// The parameters counted here may be either named (nb::arg("name"))
+    /// or unnamed (nb::arg()). If unnamed, they are effectively positional-only.
+    /// nargs_pos is always <= nargs.
+    uint16_t nargs_pos;
 
     // ------- Extra fields -------
 
     const char *name;
     const char *doc;
     PyObject *scope;
 
@@ -202,17 +222,17 @@
 template <typename F>
 NB_INLINE void func_extra_apply(F &f, const scope &scope, size_t &) {
     f.scope = scope.value;
     f.flags |= (uint32_t) func_flags::has_scope;
 }
 
 template <typename F>
-NB_INLINE void func_extra_apply(F &f, const raw_doc &d, size_t &) {
-    f.flags |= (uint32_t) func_flags::has_doc | (uint32_t) func_flags::raw_doc;
-    f.doc = d.value;
+NB_INLINE void func_extra_apply(F &f, const sig &s, size_t &) {
+    f.flags |= (uint32_t) func_flags::has_signature;
+    f.name = s.value;
 }
 
 template <typename F>
 NB_INLINE void func_extra_apply(F &f, const char *doc, size_t &) {
     f.doc = doc;
     f.flags |= (uint32_t) func_flags::has_doc;
 }
@@ -237,31 +257,39 @@
 
 template <typename F>
 NB_INLINE void func_extra_apply(F &f, rv_policy pol, size_t &) {
     f.flags = (f.flags & ~0b111) | (uint16_t) pol;
 }
 
 template <typename F>
+NB_INLINE void func_extra_apply(F &, std::nullptr_t, size_t &) { }
+
+template <typename F>
 NB_INLINE void func_extra_apply(F &f, const arg &a, size_t &index) {
     arg_data &arg = f.args[index++];
-    arg.name = a.name;
+    arg.name = a.name_;
+    arg.signature = a.signature_;
     arg.value = nullptr;
     arg.convert = a.convert_;
     arg.none = a.none_;
 }
 
 template <typename F>
 NB_INLINE void func_extra_apply(F &f, const arg_v &a, size_t &index) {
     arg_data &arg = f.args[index++];
-    arg.name = a.name;
+    arg.name = a.name_;
+    arg.signature = a.signature_;
     arg.value = a.value.ptr();
     arg.convert = a.convert_;
     arg.none = a.none_;
 }
 
+template <typename F>
+NB_INLINE void func_extra_apply(F &, kw_only, size_t &) {}
+
 template <typename F, typename... Ts>
 NB_INLINE void func_extra_apply(F &, call_guard<Ts...>, size_t &) {}
 
 template <typename F, size_t Nurse, size_t Patient>
 NB_INLINE void func_extra_apply(F &f, nanobind::keep_alive<Nurse, Patient>, size_t &) {
     f.flags |= (uint32_t) func_flags::has_keep_alive;
 }
```

## nanobind/include/nanobind/nb_call.h

```diff
@@ -54,15 +54,15 @@
                          size_t &nkwargs, const size_t kwargs_offset,
                          T &&value) {
     using D = std::decay_t<T>;
 
     if constexpr (std::is_same_v<D, arg_v>) {
         args[kwargs_offset + nkwargs] = value.value.release().ptr();
         NB_TUPLE_SET_ITEM(kwnames, nkwargs++,
-                         PyUnicode_InternFromString(value.name));
+                         PyUnicode_InternFromString(value.name_));
     } else if constexpr (std::is_same_v<D, args_proxy>) {
         for (size_t i = 0, l = len(value); i < l; ++i)
             args[nargs++] = borrow(value[i]).release().ptr();
     } else if constexpr (std::is_same_v<D, kwargs_proxy>) {
         PyObject *key, *entry;
         Py_ssize_t pos = 0;
```

## nanobind/include/nanobind/nb_cast.h

```diff
@@ -7,15 +7,18 @@
     BSD-style license that can be found in the LICENSE file.
 */
 
 #define NB_TYPE_CASTER(Value_, descr)                                          \
     using Value = Value_;                                                      \
     static constexpr auto Name = descr;                                        \
     template <typename T_> using Cast = movable_cast_t<T_>;                    \
-    static handle from_cpp(Value *p, rv_policy policy, cleanup_list *list) {   \
+    template <typename T_> static constexpr bool can_cast() { return true; }   \
+    template <typename T_,                                                     \
+              enable_if_t<std::is_same_v<std::remove_cv_t<T_>, Value>> = 0>    \
+    static handle from_cpp(T_ *p, rv_policy policy, cleanup_list *list) {      \
         if (!p)                                                                \
             return none().release();                                           \
         return from_cpp(*p, policy, list);                                     \
     }                                                                          \
     explicit operator Value*() { return &value; }                              \
     explicit operator Value&() { return (Value &) value; }                     \
     explicit operator Value&&() { return (Value &&) value; }                   \
@@ -32,16 +35,19 @@
 enum cast_flags : uint8_t {
     // Enable implicit conversions (impl. assumes this is 1, don't reorder..)
     convert = (1 << 0),
 
     // Passed to the 'self' argument in a constructor call (__init__)
     construct = (1 << 1),
 
-    // Don't accept 'None' Python objects in the base class caster
-    none_disallowed = (1 << 2),
+    // Indicates that this cast is performed by nb::cast or nb::try_cast.
+    // This implies that objects added to the cleanup list may be
+    // released immediately after the caster's final output value is
+    // obtained, i.e., before it is used.
+    manual = (1 << 2),
 };
 
 /**
  * Type casters expose a member 'Cast<T>' which users of a type caster must
  * query to determine what the caster actually can (and prefers) to produce.
  * The convenience alias ``cast_t<T>`` defined below performs this query for a
  * given type ``T``.
@@ -79,17 +85,61 @@
 /// base type caster (i.e., types bound via ``nanobind::class_<..>``)
 template <typename T>
 using precise_cast_t =
     std::conditional_t<is_pointer_v<T>, intrinsic_t<T> *,
                        std::conditional_t<std::is_rvalue_reference_v<T>,
                                           intrinsic_t<T> &&, intrinsic_t<T> &>>;
 
+/// Many type casters delegate to another caster using the pattern:
+/// ~~~ .cc
+/// bool from_python(handle src, uint8_t flags, cleanup_list *cl) noexcept {
+///     SomeCaster c;
+///     if (!c.from_python(src, flags, cl)) return false;
+///     /* do something with */ c.operator T();
+///     return true;
+/// }
+/// ~~~
+/// This function adjusts the flags to avoid issues where the resulting T object
+/// refers into storage that will dangle after SomeCaster is destroyed, and
+/// causes a static assertion failure if that's not sufficient. Use it like:
+/// ~~~ .cc
+///     if (!c.from_python(src, flags_for_local_caster<T>(flags), cl))
+///         return false;
+/// ~~~
+/// where the template argument T is the type you plan to extract.
+template <typename T>
+NB_INLINE uint8_t flags_for_local_caster(uint8_t flags) noexcept {
+    constexpr bool is_ref = std::is_pointer_v<T> || std::is_reference_v<T>;
+    if constexpr (is_base_caster_v<make_caster<T>>) {
+        if constexpr (is_ref) {
+            /* References/pointers to a type produced by implicit conversions
+               refer to storage owned by the cleanup_list. In a nb::cast() call,
+               that storage will be released before the reference can be used;
+               to prevent dangling, don't allow implicit conversions there. */
+            if (flags & ((uint8_t) cast_flags::manual))
+                flags &= ~((uint8_t) cast_flags::convert);
+        }
+    } else {
+        /* Any pointer produced by a non-base caster will generally point
+           into storage owned by the caster, which won't live long enough.
+           Exception: the 'char' caster produces a result that points to
+           storage owned by the incoming Python 'str' object, so it's OK. */
+        static_assert(!is_ref || std::is_same_v<T, const char*>,
+                      "nanobind generally cannot produce objects that "
+                      "contain interior pointers T* (or references T&) if "
+                      "the pointee T is not handled by nanobind's regular "
+                      "class binding mechanism. For example, you can write "
+                      "a function that accepts int*, or std::vector<int>, "
+                      "but not std::vector<int*>.");
+    }
+    return flags;
+}
+
 template <typename T>
 struct type_caster<T, enable_if_t<std::is_arithmetic_v<T> && !is_std_char_v<T>>> {
-public:
     NB_INLINE bool from_python(handle src, uint8_t flags, cleanup_list *) noexcept {
         if constexpr (std::is_floating_point_v<T>) {
             if constexpr (sizeof(T) == 8)
                 return detail::load_f64(src.ptr(), flags, &value);
             else
                 return detail::load_f32(src.ptr(), flags, &value);
         } else {
@@ -132,22 +182,39 @@
             }
         }
     }
 
     NB_TYPE_CASTER(T, const_name<std::is_integral_v<T>>("int", "float"))
 };
 
+template <typename T>
+struct type_caster<T, enable_if_t<std::is_enum_v<T>>> {
+    NB_INLINE bool from_python(handle src, uint8_t flags, cleanup_list *) noexcept {
+        int64_t result;
+        bool rv = enum_from_python(&typeid(T), src.ptr(), &result, flags);
+        value = (T) result;
+        return rv;
+    }
+
+    NB_INLINE static handle from_cpp(T src, rv_policy, cleanup_list *) noexcept {
+        return enum_from_cpp(&typeid(T), (int64_t) src);
+    }
+
+    NB_TYPE_CASTER(T, const_name<T>())
+};
+
 template <> struct type_caster<void_type> {
     static constexpr auto Name = const_name("None");
 };
 
 template <> struct type_caster<void> {
     template <typename T_> using Cast = void *;
+    template <typename T_> static constexpr bool can_cast() { return true; }
     using Value = void*;
-    static constexpr auto Name = const_name("capsule");
+    static constexpr auto Name = const_name("types.CapsuleType");
     explicit operator void *() { return value; }
     Value value;
 
     bool from_python(handle src, uint8_t, cleanup_list *) noexcept {
         if (src.is_none()) {
             value = nullptr;
             return true;
@@ -229,60 +296,86 @@
         return PyUnicode_FromString(value);
     }
 
     static handle from_cpp(char value, rv_policy, cleanup_list *) noexcept {
         return PyUnicode_FromStringAndSize(&value, 1);
     }
 
+    template <typename T_>
+    NB_INLINE bool can_cast() const noexcept {
+        return std::is_pointer_v<T_> || (value && value[0] && value[1] == '\0');
+    }
+
     explicit operator const char *() { return value; }
 
     explicit operator char() {
-        if (value && value[0] && value[1] == '\0')
+        if (can_cast<char>())
             return value[0];
         else
             throw next_overload();
     }
 };
 
 template <typename T> struct type_caster<pointer_and_handle<T>> {
-    using Caster = detail::make_caster<T>;
+    using Caster = make_caster<T>;
     using T2 = pointer_and_handle<T>;
     NB_TYPE_CASTER(T2, Caster::Name)
 
     bool from_python(handle src, uint8_t flags, cleanup_list *cleanup) noexcept {
         Caster c;
-        if (!c.from_python(src, flags, cleanup))
+        if (!c.from_python(src, flags_for_local_caster<T*>(flags), cleanup) ||
+            !c.template can_cast<T*>())
             return false;
         value.h = src;
         value.p = c.operator T*();
         return true;
     }
 };
 
-template <typename T, typename X> struct type_caster<typed<T, X>> {
-    using Caster = detail::make_caster<T>;
-    using T2 = typed<T, X>;
-    NB_TYPE_CASTER(T2, X::Name)
+template <typename T> struct typed_name {
+      static constexpr auto Name = type_caster<T>::Name;
+};
+
+#if PY_VERSION_HEX < 0x03090000
+#define NB_TYPED_NAME_PYTHON38(type, name)                     \
+    template <> struct typed_name<type> {                      \
+        static constexpr auto Name = detail::const_name(name); \
+    };
+
+NB_TYPED_NAME_PYTHON38(nanobind::tuple, NB_TYPING_TUPLE)
+NB_TYPED_NAME_PYTHON38(list, NB_TYPING_LIST)
+NB_TYPED_NAME_PYTHON38(set, NB_TYPING_SET)
+NB_TYPED_NAME_PYTHON38(dict, NB_TYPING_DICT)
+NB_TYPED_NAME_PYTHON38(type_object, NB_TYPING_TYPE)
+#endif
+
+template <typename T, typename... Ts> struct type_caster<typed<T, Ts...>> {
+    using Caster = make_caster<T>;
+    using Typed = typed<T, Ts...>;
+
+    NB_TYPE_CASTER(Typed, typed_name<intrinsic_t<T>>::Name + const_name("[") +
+                              concat(make_caster<Ts>::Name...) +
+                              const_name("]"))
 
     bool from_python(handle src, uint8_t flags, cleanup_list *cleanup) noexcept {
-        Caster c;
-        if (!c.from_python(src, flags, cleanup))
+        Caster caster;
+        if (!caster.from_python(src, flags_for_local_caster<T>(flags), cleanup) ||
+            !caster.template can_cast<T>())
             return false;
-        value = T2{ (T &&) c.value };
+        value = caster.operator cast_t<T>();
         return true;
     }
 
-    static handle from_cpp(const T2 &src, rv_policy policy,
-                           cleanup_list *cleanup) noexcept {
-        return Caster::from_cpp(src.value, policy, cleanup);
+    static handle from_cpp(const Value &src, rv_policy policy, cleanup_list *cleanup) noexcept {
+        return Caster::from_cpp(src, policy, cleanup);
     }
 };
 
 template <typename T>
-struct type_caster<T, enable_if_t<std::is_base_of_v<detail::api_tag, T>>> {
+struct type_caster<T, enable_if_t<std::is_base_of_v<detail::api_tag, T> && !T::nb_typed>> {
 public:
     NB_TYPE_CASTER(T, T::Name)
 
     type_caster() : value(nullptr, ::nanobind::detail::steal_t()) { }
 
     bool from_python(handle src, uint8_t, cleanup_list *) noexcept {
         if (!isinstance<T>(src))
@@ -292,16 +385,22 @@
             value = borrow<T>(src);
         else
             value = src;
 
         return true;
     }
 
-    static handle from_cpp(const handle &src, rv_policy,
-                           cleanup_list *) noexcept {
+    static handle from_cpp(T&& src, rv_policy, cleanup_list *) noexcept {
+        if constexpr (std::is_base_of_v<object, T>)
+            return src.release();
+        else
+            return src.inc_ref();
+    }
+
+    static handle from_cpp(const T &src, rv_policy, cleanup_list *) noexcept {
         return src.inc_ref();
     }
 };
 
 template <typename T> NB_INLINE rv_policy infer_policy(rv_policy policy) {
     if constexpr (is_pointer_v<T>) {
         if (policy == rv_policy::automatic)
@@ -357,14 +456,19 @@
         } else {
             const std::type_info *type_p =
                 (!has_type_hook && ptr) ? &typeid(*ptr) : nullptr;
             return nb_type_put_p(type, type_p, ptr, policy, cleanup);
         }
     }
 
+    template <typename T_>
+    bool can_cast() const noexcept {
+        return std::is_pointer_v<T_> || (value != nullptr);
+    }
+
     operator Type*() { return value; }
 
     operator Type&() {
         raise_next_overload_if_null(value);
         return *value;
     }
 
@@ -376,61 +480,123 @@
 private:
     Type *value;
 };
 
 template <typename Type, typename SFINAE>
 struct type_caster : type_caster_base<Type> { };
 
-NAMESPACE_END(detail)
+template <bool Convert, typename T>
+T cast_impl(handle h) {
+    using Caster = detail::make_caster<T>;
 
-template <typename T, typename Derived>
-bool try_cast(const detail::api<Derived> &value, T &out, bool convert = true) noexcept {
+    // A returned reference/pointer would usually refer into the type_caster
+    // object, which will be destroyed before the returned value can be used,
+    // so we prohibit it by default, with two exceptions that we know are safe:
+    //
+    // - If we're casting to a bound object type, the returned pointer points
+    //   into storage owned by that object, not the type caster. Note this is
+    //   only safe if we don't allow implicit conversions, because the pointer
+    //   produced after an implicit conversion points into storage owned by
+    //   a temporary object in the cleanup list, and we have to release those
+    //   temporaries before we return.
+    //
+    // - If we're casting to const char*, the caster was provided by nanobind,
+    //   and we know it will only accept Python 'str' objects, producing
+    //   a pointer to storage owned by that object.
+
+    constexpr bool is_ref = std::is_reference_v<T> || std::is_pointer_v<T>;
+    static_assert(
+        !is_ref ||
+            is_base_caster_v<Caster> ||
+            std::is_same_v<const char *, T>,
+        "nanobind::cast(): cannot return a reference to a temporary.");
+
+    Caster caster;
+    bool rv;
+    if constexpr (Convert && !is_ref) {
+        // Release the values in the cleanup list only after we
+        // initialize the return object, since the initialization
+        // might access those temporaries.
+        struct raii_cleanup {
+            cleanup_list list{nullptr};
+            ~raii_cleanup() { list.release(); }
+        } cleanup;
+        rv = caster.from_python(h.ptr(),
+                                ((uint8_t) cast_flags::convert) |
+                                ((uint8_t) cast_flags::manual),
+                                &cleanup.list);
+        if (!rv)
+            detail::raise_cast_error();
+        return caster.operator cast_t<T>();
+    } else {
+        rv = caster.from_python(h.ptr(), (uint8_t) cast_flags::manual, nullptr);
+        if (!rv)
+            detail::raise_cast_error();
+        return caster.operator cast_t<T>();
+    }
+}
+
+template <bool Convert, typename T>
+bool try_cast_impl(handle h, T &out) noexcept {
     using Caster = detail::make_caster<T>;
 
-    static_assert(!std::is_same_v<const char *, T>,
-                  "nanobind::try_cast(): cannot return a reference to a temporary.");
+    // See comments in cast_impl above
+    constexpr bool is_ref = std::is_reference_v<T> || std::is_pointer_v<T>;
+    static_assert(
+        !is_ref ||
+            is_base_caster_v<Caster> ||
+            std::is_same_v<const char *, T>,
+        "nanobind::try_cast(): cannot return a reference to a temporary.");
 
     Caster caster;
-    if (caster.from_python(value.derived().ptr(),
-                           convert ? (uint8_t) detail::cast_flags::convert
-                                   : (uint8_t) 0, nullptr)) {
-        try {
-            out = caster.operator detail::cast_t<T>();
-            return true;
-        } catch (const builtin_exception&) {
-            return false;
+    bool rv;
+    if constexpr (Convert && !is_ref) {
+        cleanup_list cleanup(nullptr);
+        rv = caster.from_python(h.ptr(),
+                                ((uint8_t) cast_flags::convert) |
+                                ((uint8_t) cast_flags::manual),
+                                &cleanup) &&
+             caster.template can_cast<T>();
+        if (rv) {
+            out = caster.operator cast_t<T>();
+        }
+        cleanup.release(); // 'from_python' is 'noexcept', so this always runs
+    } else {
+        rv = caster.from_python(h.ptr(), (uint8_t) cast_flags::manual, nullptr) &&
+             caster.template can_cast<T>();
+        if (rv) {
+            out = caster.operator cast_t<T>();
         }
     }
 
-    return false;
+    return rv;
 }
 
+NAMESPACE_END(detail)
+
 template <typename T, typename Derived>
-T cast(const detail::api<Derived> &value, bool convert = true) {
+NB_INLINE T cast(const detail::api<Derived> &value, bool convert = true) {
     if constexpr (std::is_same_v<T, void>) {
         return;
     } else {
-        using Caster = detail::make_caster<T>;
-
-        static_assert(
-            !(std::is_reference_v<T> || std::is_pointer_v<T>) ||
-                detail::is_base_caster_v<Caster> ||
-                std::is_same_v<const char *, T>,
-            "nanobind::cast(): cannot return a reference to a temporary.");
-
-        Caster caster;
-        if (!caster.from_python(value.derived().ptr(),
-                                convert ? (uint8_t) detail::cast_flags::convert
-                                        : (uint8_t) 0, nullptr))
-            detail::raise_cast_error();
-
-        return caster.operator detail::cast_t<T>();
+        if (convert)
+            return detail::cast_impl<true, T>(value);
+        else
+            return detail::cast_impl<false, T>(value);
     }
 }
 
+template <typename T, typename Derived>
+NB_INLINE bool try_cast(const detail::api<Derived> &value, T &out, bool convert = true) noexcept {
+    if (convert)
+        return detail::try_cast_impl<true, T>(value, out);
+    else
+        return detail::try_cast_impl<false, T>(value, out);
+}
+
 template <typename T>
 object cast(T &&value, rv_policy policy = rv_policy::automatic_reference) {
     handle h = detail::make_caster<T>::from_cpp((detail::forward_t<T>) value,
                                                 policy, nullptr);
     if (!h.is_valid())
         detail::raise_cast_error();
 
@@ -472,14 +638,20 @@
 
 template <typename T> void list::append(T &&value) {
     object o = nanobind::cast((detail::forward_t<T>) value);
     if (PyList_Append(m_ptr, o.ptr()))
         raise_python_error();
 }
 
+template <typename T> void list::insert(Py_ssize_t index, T &&value) {
+    object o = nanobind::cast((detail::forward_t<T>) value);
+    if (PyList_Insert(m_ptr, index, o.ptr()))
+        raise_python_error();
+}
+
 template <typename T> bool dict::contains(T&& key) const {
     object o = nanobind::cast((detail::forward_t<T>) key);
     int rv = PyDict_Contains(m_ptr, o.ptr());
     if (rv == -1)
         raise_python_error();
     return rv == 1;
 }
@@ -488,22 +660,28 @@
     object o = nanobind::cast((detail::forward_t<T>) key);
     int rv = PySet_Contains(m_ptr, o.ptr());
     if (rv == -1)
         raise_python_error();
     return rv == 1;
 }
 
-
 template <typename T> void set::add(T&& key) {
     object o = nanobind::cast((detail::forward_t<T>) key);
     int rv = PySet_Add(m_ptr, o.ptr());
     if (rv == -1)
         raise_python_error();
 }
 
+template <typename T> bool set::discard(T &&value) {
+    object o = nanobind::cast((detail::forward_t<T>) value);
+    int rv = PySet_Discard(m_ptr, o.ptr());
+    if (rv < 0)
+        raise_python_error();
+    return rv == 1;
+}
 
 template <typename T> bool mapping::contains(T&& key) const {
     object o = nanobind::cast((detail::forward_t<T>) key);
     int rv = PyMapping_HasKey(m_ptr, o.ptr());
     if (rv == -1)
         raise_python_error();
     return rv == 1;
```

## nanobind/include/nanobind/nb_class.h

```diff
@@ -48,15 +48,27 @@
     /// Is this a class that inherits from enable_shared_from_this?
     /// If so, type_data::keep_shared_from_this_alive is also set.
     has_shared_from_this     = (1 << 12),
 
     /// Instances of this type can be referenced by 'weakref'
     is_weak_referenceable    = (1 << 13),
 
-    // Five more flag bits available (12 through 18) without needing
+    /// A custom signature override was specified
+    has_signature            = (1 << 14),
+
+    /// The class implements __class_getitem__ similar to typing.Generic
+    is_generic               = (1 << 15),
+
+    /// Is this an arithmetic enumeration?
+    is_arithmetic            = (1 << 16),
+
+    /// Is the number type underlying the enumeration signed?
+    is_signed                = (1 << 17)
+
+    // One more flag bits available (18) without needing
     // a larger reorganization
 };
 
 /// Flags about a type that are only relevant when it is being created.
 /// These are currently stored in type_data::flags alongside the type_flags
 /// for more efficient memory layout, but could move elsewhere if we run
 /// out of flags.
@@ -69,16 +81,15 @@
 
     /// Is the 'base' field of the type_init_data structure set?
     has_base                 = (1 << 21),
 
     /// Is the 'base_py' field of the type_init_data structure set?
     has_base_py              = (1 << 22),
 
-    /// This type provides extra PyType_Slot fields via the 'type_slots'
-    /// and/or 'type_slots_callback' members of type_init_data
+    /// This type provides extra PyType_Slot fields
     has_type_slots           = (1 << 23),
 
     all_init_flags           = (0x1f << 19)
 };
 
 // See internals.h
 struct nb_alias_chain;
@@ -86,21 +97,32 @@
 /// Information about a type that persists throughout its lifetime
 struct type_data {
     uint32_t size;
     uint32_t align : 8;
     uint32_t flags : 24;
     const char *name;
     const std::type_info *type;
-    nb_alias_chain *alias_chain;
     PyTypeObject *type_py;
+    nb_alias_chain *alias_chain;
     void (*destruct)(void *);
     void (*copy)(void *, const void *);
     void (*move)(void *, void *) noexcept;
-    const std::type_info **implicit;
-    bool (**implicit_py)(PyTypeObject *, PyObject *, cleanup_list *) noexcept;
+    union {
+        // Implicit conversions for C++ type bindings
+        struct {
+            const std::type_info **cpp;
+            bool (**py)(PyTypeObject *, PyObject *, cleanup_list *) noexcept;
+        } implicit;
+
+        // Forward and reverse mappings for enumerations
+        struct {
+            void *fwd;
+            void *rev;
+        } enum_tbl;
+    };
     void (*set_self_py)(void *, PyObject *) noexcept;
     bool (*keep_shared_from_this_alive)(PyObject *) noexcept;
 #if defined(Py_LIMITED_API)
     size_t dictoffset;
     size_t weaklistoffset;
 #endif
 };
@@ -108,100 +130,93 @@
 /// Information about a type that is only relevant when it is being created
 struct type_init_data : type_data {
     PyObject *scope;
     const std::type_info *base;
     PyTypeObject *base_py;
     const char *doc;
     const PyType_Slot *type_slots;
-    void (*type_slots_callback)(const type_init_data *d, PyType_Slot *&slots, size_t max_slots);
     size_t supplement;
 };
 
 NB_INLINE void type_extra_apply(type_init_data &t, const handle &h) {
     t.flags |= (uint32_t) type_init_flags::has_base_py;
     t.base_py = (PyTypeObject *) h.ptr();
 }
 
 NB_INLINE void type_extra_apply(type_init_data &t, const char *doc) {
     t.flags |= (uint32_t) type_init_flags::has_doc;
     t.doc = doc;
 }
 
 NB_INLINE void type_extra_apply(type_init_data &t, type_slots c) {
-    if ((t.flags & (uint32_t) type_init_flags::has_type_slots) == 0) {
-        t.flags |= (uint32_t) type_init_flags::has_type_slots;
-        t.type_slots_callback = nullptr;
-    }
+    t.flags |= (uint32_t) type_init_flags::has_type_slots;
     t.type_slots = c.value;
 }
 
-NB_INLINE void type_extra_apply(type_init_data &t, type_slots_callback c) {
-    if ((t.flags & (uint32_t) type_init_flags::has_type_slots) == 0) {
-        t.flags |= (uint32_t) type_init_flags::has_type_slots;
-        t.type_slots = nullptr;
-    }
-    t.type_slots_callback = c.callback;
-}
-
 template <typename T>
 NB_INLINE void type_extra_apply(type_init_data &t, intrusive_ptr<T> ip) {
     t.flags |= (uint32_t) type_flags::intrusive_ptr;
     t.set_self_py = (void (*)(void *, PyObject *) noexcept) ip.set_self_py;
 }
 
 NB_INLINE void type_extra_apply(type_init_data &t, is_final) {
     t.flags |= (uint32_t) type_flags::is_final;
 }
 
 NB_INLINE void type_extra_apply(type_init_data &t, dynamic_attr) {
     t.flags |= (uint32_t) type_flags::has_dynamic_attr;
 }
 
-NB_INLINE void type_extra_apply(type_data & t, is_weak_referenceable) {
+NB_INLINE void type_extra_apply(type_init_data & t, is_weak_referenceable) {
     t.flags |= (uint32_t) type_flags::is_weak_referenceable;
 }
 
+NB_INLINE void type_extra_apply(type_init_data & t, is_generic) {
+    t.flags |= (uint32_t) type_flags::is_generic;
+}
+
+NB_INLINE void type_extra_apply(type_init_data & t, const sig &s) {
+    t.flags |= (uint32_t) type_flags::has_signature;
+    t.name = s.value;
+}
+
 template <typename T>
 NB_INLINE void type_extra_apply(type_init_data &t, supplement<T>) {
     static_assert(std::is_trivially_default_constructible_v<T>,
                   "The supplement must be a POD (plain old data) type");
     static_assert(alignof(T) <= alignof(void *),
                   "The alignment requirement of the supplement is too high.");
     t.flags |= (uint32_t) type_init_flags::has_supplement | (uint32_t) type_flags::is_final;
     t.supplement = sizeof(T);
 }
 
-/// Information about an enum, stored as its type_data::supplement
-struct enum_supplement {
-    bool is_signed = false;
-    PyObject* entries = nullptr;
-    PyObject* scope = nullptr;
+struct enum_init_data {
+    const std::type_info *type;
+    PyObject *scope;
+    const char *name;
+    const char *docstr;
+    uint32_t flags;
 };
 
-/// Information needed to create an enum
-struct enum_init_data : type_init_data {
-    bool is_signed = false;
-    bool is_arithmetic = false;
-};
+NB_INLINE void enum_extra_apply(enum_init_data &e, is_arithmetic) {
+    e.flags |= (uint32_t) type_flags::is_arithmetic;
+}
 
-NB_INLINE void type_extra_apply(enum_init_data &ed, is_arithmetic) {
-    ed.is_arithmetic = true;
+NB_INLINE void enum_extra_apply(enum_init_data &e, const char *doc) {
+    e.docstr = doc;
 }
 
-// Enums can't have base classes or supplements or be intrusive, and
-// are always final. They can't use type_slots_callback because that is
-// used by the enum mechanism internally, but can provide additional
-// slots using type_slots.
-void type_extra_apply(enum_init_data &, const handle &) = delete;
 template <typename T>
-void type_extra_apply(enum_init_data &, intrusive_ptr<T>) = delete;
-template <typename T>
-void type_extra_apply(enum_init_data &, supplement<T>) = delete;
-void type_extra_apply(enum_init_data &, is_final) = delete;
-void type_extra_apply(enum_init_data &, type_slots_callback) = delete;
+NB_INLINE void enum_extra_apply(enum_init_data &, T) {
+    static_assert(
+        std::is_void_v<T>,
+        "Invalid enum binding annotation. The implementation of "
+        "enums changed nanobind 2.0.0: only nb::is_arithmetic and "
+        "docstrings can be passed since this change.");
+}
 
 template <typename T> void wrap_copy(void *dst, const void *src) {
     new ((T *) dst) T(*(const T *) src);
 }
 
 template <typename T> void wrap_move(void *dst, void *src) noexcept {
     new ((T *) dst) T(std::move(*(T *) src));
@@ -354,14 +369,91 @@
                         src, detail::cast_flags::convert, cleanup);
                 },
                 &typeid(Type));
         }
     }
 };
 
+namespace detail {
+    // This is 'inline' so we can define it in a header and not pay
+    // for it if unused, and also 'noinline' so we don't generate
+    // multiple copies and produce code bloat.
+    NB_NOINLINE inline void wrap_base_new(handle cls, bool do_wrap) {
+        if (PyCFunction_Check(cls.attr("__new__").ptr())) {
+            if (do_wrap) {
+                cpp_function_def(
+                    [](handle type) {
+                        if (!type_check(type))
+                            detail::raise_cast_error();
+                        return inst_alloc(type);
+                    },
+                    scope(cls), name("__new__"));
+            }
+        } else {
+            if (!do_wrap) {
+                // We already defined the wrapper, so this zero-arg overload
+                // would be unreachable. Raise an error rather than hiding it.
+                raise("nanobind: %s must define its zero-argument __new__ "
+                      "before any other overloads", type_name(cls).c_str());
+            }
+        }
+    }
+}
+
+template <typename Func, typename Sig = detail::function_signature_t<Func>>
+struct new_;
+
+template <typename Func, typename Return, typename... Args>
+struct new_<Func, Return(Args...)> {
+    std::remove_reference_t<Func> func;
+
+    new_(Func &&f) : func((detail::forward_t<Func>) f) {}
+
+    template <typename Class, typename... Extra>
+    NB_INLINE void execute(Class &cl, const Extra&... extra) {
+        // If this is the first __new__ overload we're defining, then wrap
+        // nanobind's built-in __new__ so we overload with it instead of
+        // replacing it; this is important for pickle support.
+        // We can't do this if the user-provided __new__ takes no
+        // arguments, because it would make an ambiguous overload set.
+        detail::wrap_base_new(cl, sizeof...(Args) != 0);
+        cl.def_static(
+            "__new__",
+            [func = (detail::forward_t<Func>) func](handle, Args... args) {
+                return func((detail::forward_t<Args>) args...);
+            },
+            extra...);
+        cl.def("__init__", [](handle, Args...) {}, extra...);
+    }
+};
+template <typename Func> new_(Func&& f) -> new_<Func>;
+
+template <typename T> struct for_setter {
+    T value;
+    for_setter(const T &value) : value(value) { }
+};
+
+template <typename T> struct for_getter {
+    T value;
+    for_getter(const T &value) : value(value) { }
+};
+
+template <typename T> for_getter(T) -> for_getter<std::decay_t<T>>;
+template <typename T> for_setter(T) -> for_setter<std::decay_t<T>>;
+
+namespace detail {
+    template <typename T> auto filter_getter(const T &v) { return v; }
+    template <typename T> auto filter_getter(const for_getter<T> &v) { return v.value; }
+    template <typename T> std::nullptr_t filter_getter(const for_setter<T> &) { return nullptr; }
+
+    template <typename T> auto filter_setter(const T &v) { return v; }
+    template <typename T> auto filter_setter(const for_setter<T> &v) { return v.value; }
+    template <typename T> std::nullptr_t filter_setter(const for_getter<T> &) { return nullptr; }
+}
+
 template <typename T, typename... Ts>
 class class_ : public object {
 public:
     NB_OBJECT_DEFAULT(class_, object, "type", PyType_Check);
     using Type = T;
     using Base  = typename detail::extract<T, detail::is_base,  Ts...>::type;
     using Alias = typename detail::extract<T, detail::is_alias, Ts...>::type;
@@ -446,28 +538,34 @@
         (detail::type_extra_apply(d, extra), ...);
 
         m_ptr = detail::nb_type_new(&d);
     }
 
     template <typename Func, typename... Extra>
     NB_INLINE class_ &def(const char *name_, Func &&f, const Extra &... extra) {
-        cpp_function_def((detail::forward_t<Func>) f, scope(*this), name(name_),
-                         is_method(), extra...);
+        cpp_function_def<T>((detail::forward_t<Func>) f, scope(*this),
+                            name(name_), is_method(), extra...);
         return *this;
     }
 
     template <typename... Args, typename... Extra>
-    NB_INLINE class_ &def(init<Args...> &&init, const Extra &... extra) {
-        init.execute(*this, extra...);
+    NB_INLINE class_ &def(init<Args...> &&arg, const Extra &... extra) {
+        arg.execute(*this, extra...);
         return *this;
     }
 
     template <typename Arg, typename... Extra>
-    NB_INLINE class_ &def(init_implicit<Arg> &&init, const Extra &... extra) {
-        init.execute(*this, extra...);
+    NB_INLINE class_ &def(init_implicit<Arg> &&arg, const Extra &... extra) {
+        arg.execute(*this, extra...);
+        return *this;
+    }
+
+    template <typename Func, typename... Extra>
+    NB_INLINE class_ &def(new_<Func> &&arg, const Extra &... extra) {
+        arg.execute(*this, extra...);
         return *this;
     }
 
     template <typename Func, typename... Extra>
     NB_INLINE class_ &def_static(const char *name_, Func &&f,
                                  const Extra &... extra) {
         static_assert(
@@ -480,39 +578,41 @@
 
     template <typename Getter, typename Setter, typename... Extra>
     NB_INLINE class_ &def_prop_rw(const char *name_, Getter &&getter,
                                   Setter &&setter, const Extra &...extra) {
         object get_p, set_p;
 
         if constexpr (!std::is_same_v<Getter, std::nullptr_t>)
-            get_p = cpp_function((detail::forward_t<Getter>) getter,
-                                 scope(*this), is_method(), is_getter(),
-                                 rv_policy::reference_internal, extra...);
+            get_p = cpp_function<T>((detail::forward_t<Getter>) getter,
+                                    is_method(), is_getter(),
+                                    rv_policy::reference_internal,
+                                    detail::filter_getter(extra)...);
 
         if constexpr (!std::is_same_v<Setter, std::nullptr_t>)
-            set_p = cpp_function((detail::forward_t<Setter>) setter,
-                                 scope(*this), is_method(), extra...);
+            set_p = cpp_function<T>((detail::forward_t<Setter>) setter,
+                                    is_method(), detail::filter_setter(extra)...);
 
         detail::property_install(m_ptr, name_, get_p.ptr(), set_p.ptr());
         return *this;
     }
 
     template <typename Getter, typename Setter, typename... Extra>
     NB_INLINE class_ &def_prop_rw_static(const char *name_, Getter &&getter,
                                          Setter &&setter,
                                          const Extra &...extra) {
         object get_p, set_p;
 
         if constexpr (!std::is_same_v<Getter, std::nullptr_t>)
             get_p = cpp_function((detail::forward_t<Getter>) getter, is_getter(),
-                                 scope(*this), rv_policy::reference, extra...);
+                                 rv_policy::reference,
+                                 detail::filter_getter(extra)...);
 
         if constexpr (!std::is_same_v<Setter, std::nullptr_t>)
             set_p = cpp_function((detail::forward_t<Setter>) setter,
-                                 scope(*this), extra...);
+                                 detail::filter_setter(extra)...);
 
         detail::property_install_static(m_ptr, name_, get_p.ptr(), set_p.ptr());
         return *this;
     }
 
     template <typename Getter, typename... Extra>
     NB_INLINE class_ &def_prop_ro(const char *name_, Getter &&getter,
@@ -526,15 +626,16 @@
                                          const Extra &...extra) {
         return def_prop_rw_static(name_, getter, nullptr, extra...);
     }
 
     template <typename C, typename D, typename... Extra>
     NB_INLINE class_ &def_rw(const char *name, D C::*p,
                              const Extra &...extra) {
-        static_assert(std::is_base_of_v<C, T>,
+        // Unions never satisfy is_base_of, thus the is_same alternative
+        static_assert(std::is_base_of_v<C, T> || std::is_same_v<C, T>,
                       "def_rw() requires a (base) class member!");
 
         using Q =
             std::conditional_t<detail::is_base_caster_v<detail::make_caster<D>>,
                                const D &, D &&>;
 
         def_prop_rw(name,
@@ -558,15 +659,16 @@
 
         return *this;
     }
 
     template <typename C, typename D, typename... Extra>
     NB_INLINE class_ &def_ro(const char *name, D C::*p,
                              const Extra &...extra) {
-        static_assert(std::is_base_of_v<C, T>,
+        // Unions never satisfy is_base_of, thus the is_same alternative
+        static_assert(std::is_base_of_v<C, T> || std::is_same_v<C, T>,
                       "def_ro() requires a (base) class member!");
 
         def_prop_ro(name,
             [p](const T &c) -> const D & { return c.*p; }, extra...);
 
         return *this;
     }
@@ -589,56 +691,74 @@
     template <detail::op_id id, detail::op_type ot, typename L, typename R, typename... Extra>
     class_ & def_cast(const detail::op_<id, ot, L, R> &op, const Extra&... extra) {
         op.execute_cast(*this, extra...);
         return *this;
     }
 };
 
-template <typename T> class enum_ : public class_<T> {
+template <typename T> class enum_ : public object {
 public:
     static_assert(std::is_enum_v<T>, "nanobind::enum_<> requires an enumeration type!");
 
     using Base = class_<T>;
+    using Underlying = std::underlying_type_t<T>;
 
     template <typename... Extra>
-    NB_INLINE enum_(handle scope, const char *name, const Extra &...extra) {
-        detail::enum_init_data d;
+    NB_INLINE enum_(handle scope, const char *name, const Extra &... extra) {
+        detail::enum_init_data ed { };
+        ed.type = &typeid(T);
+        ed.scope = scope.ptr();
+        ed.name = name;
+        ed.flags = std::is_signed_v<Underlying>
+                       ? (uint32_t) detail::type_flags::is_signed
+                       : 0;
+        (detail::enum_extra_apply(ed, extra), ...);
+        m_ptr = detail::enum_create(&ed);
+    }
 
-        static_assert(std::is_trivially_copyable_v<T>);
-        d.flags = ((uint32_t) detail::type_init_flags::has_supplement |
-                   (uint32_t) detail::type_init_flags::has_type_slots |
-                   (uint32_t) detail::type_flags::is_copy_constructible |
-                   (uint32_t) detail::type_flags::is_move_constructible |
-                   (uint32_t) detail::type_flags::is_destructible |
-                   (uint32_t) detail::type_flags::is_final);
-        d.align = (uint8_t) alignof(T);
-        d.size = (uint32_t) sizeof(T);
-        d.name = name;
-        d.type = &typeid(T);
-        d.supplement = sizeof(detail::enum_supplement);
-        d.scope = scope.ptr();
-        d.type_slots = nullptr;
-        d.type_slots_callback = detail::nb_enum_prepare;
-        d.is_signed = std::is_signed_v<std::underlying_type_t<T>>;
+    NB_INLINE enum_ &value(const char *name, T value, const char *doc = nullptr) {
+        detail::enum_append(m_ptr, name, (int64_t) value, doc);
+        return *this;
+    }
 
-        (detail::type_extra_apply(d, extra), ...);
+    NB_INLINE enum_ &export_values() { detail::enum_export(m_ptr); return *this; }
 
-        Base::m_ptr = detail::nb_type_new(&d);
 
-        detail::enum_supplement &supp = type_supplement<detail::enum_supplement>(*this);
-        supp.is_signed = d.is_signed;
-        supp.scope = d.scope;
+    template <typename Func, typename... Extra>
+    NB_INLINE enum_ &def(const char *name_, Func &&f, const Extra &... extra) {
+        cpp_function_def<T>((detail::forward_t<Func>) f, scope(*this),
+                            name(name_), is_method(), extra...);
+        return *this;
     }
 
-    NB_INLINE enum_ &value(const char *name, T value, const char *doc = nullptr) {
-        detail::nb_enum_put(Base::m_ptr, name, &value, doc);
+    template <typename Getter, typename Setter, typename... Extra>
+    NB_INLINE enum_ &def_prop_rw(const char *name_, Getter &&getter,
+                                 Setter &&setter, const Extra &...extra) {
+        object get_p, set_p;
+
+        if constexpr (!std::is_same_v<Getter, std::nullptr_t>)
+            get_p = cpp_function<T>((detail::forward_t<Getter>) getter,
+                                    is_method(), is_getter(),
+                                    rv_policy::reference_internal,
+                                    detail::filter_getter(extra)...);
+
+        if constexpr (!std::is_same_v<Setter, std::nullptr_t>)
+            set_p = cpp_function<T>((detail::forward_t<Setter>) setter,
+                                    is_method(), detail::filter_setter(extra)...);
+
+        detail::property_install(m_ptr, name_, get_p.ptr(), set_p.ptr());
         return *this;
     }
 
-    NB_INLINE enum_ &export_values() { detail::nb_enum_export(Base::m_ptr); return *this; }
+
+    template <typename Getter, typename... Extra>
+    NB_INLINE enum_ &def_prop_ro(const char *name_, Getter &&getter,
+                                 const Extra &...extra) {
+        return def_prop_rw(name_, getter, nullptr, extra...);
+    }
 };
 
 template <typename Source, typename Target> void implicitly_convertible() {
     using Caster = detail::make_caster<Source>;
 
     if constexpr (detail::is_base_caster_v<Caster>) {
         detail::implicitly_convertible(&typeid(Source), &typeid(Target));
```

## nanobind/include/nanobind/nb_defs.h

```diff
@@ -19,32 +19,32 @@
 #endif
 
 #if !defined(NAMESPACE_END)
 #  define NAMESPACE_END(name) }
 #endif
 
 #if defined(_WIN32)
-#  define NB_EXPORT        __declspec(dllexport)
-#  define NB_IMPORT        __declspec(dllimport)
-#  define NB_INLINE        __forceinline
+#  define NB_EXPORT          __declspec(dllexport)
+#  define NB_IMPORT          __declspec(dllimport)
+#  define NB_INLINE          __forceinline
+#  define NB_NOINLINE        __declspec(noinline)
 #  define NB_INLINE_LAMBDA
-#  define NB_NOINLINE      __declspec(noinline)
 #else
-#  define NB_EXPORT        __attribute__ ((visibility("default")))
-#  define NB_IMPORT        NB_EXPORT
-#  define NB_INLINE        inline __attribute__((always_inline))
-#  define NB_NOINLINE      __attribute__((noinline))
-#if defined(__clang__)
+#  define NB_EXPORT          __attribute__ ((visibility("default")))
+#  define NB_IMPORT          NB_EXPORT
+#  define NB_INLINE          inline __attribute__((always_inline))
+#  define NB_NOINLINE        __attribute__((noinline))
+#  if defined(__clang__)
 #    define NB_INLINE_LAMBDA __attribute__((always_inline))
-#else
+#  else
 #    define NB_INLINE_LAMBDA
-#endif
+#  endif
 #endif
 
-#if defined(__GNUC__)
+#if defined(__GNUC__) && !defined(_WIN32)
 #  define NB_NAMESPACE nanobind __attribute__((visibility("hidden")))
 #else
 #  define NB_NAMESPACE nanobind
 #endif
 
 #if defined(__GNUC__)
 #  define NB_UNLIKELY(x) __builtin_expect(bool(x), 0)
@@ -60,15 +60,15 @@
 #  else
 #    define NB_CORE NB_IMPORT
 #  endif
 #else
 #  define NB_CORE
 #endif
 
-#if !defined(NB_SHARED) && defined(__GNUC__)
+#if !defined(NB_SHARED) && defined(__GNUC__) && !defined(_WIN32)
 #  define NB_EXPORT_SHARED __attribute__ ((visibility("hidden")))
 #else
 #  define NB_EXPORT_SHARED
 #endif
 
 #if defined(__cpp_lib_char8_t) && __cpp_lib_char8_t >= 201811L
 #  define NB_HAS_U8STRING
@@ -89,25 +89,39 @@
 #  define NB_VECTORCALL_NARGS PyVectorcall_NARGS
 #else
 #  define NB_VECTORCALL_ARGUMENTS_OFFSET ((size_t) 1 << (8 * sizeof(size_t) - 1))
 #  define NB_VECTORCALL_NARGS(n) ((n) & ~NB_VECTORCALL_ARGUMENTS_OFFSET)
 #endif
 
 #if PY_VERSION_HEX < 0x03090000
-#  define NB_TYPING_DICT "Dict"
-#  define NB_TYPING_LIST "List"
-#  define NB_TYPING_SET "Set"
-#  define NB_TYPING_TUPLE "Tuple"
-#  define NB_TYPING_TYPE "Type"
-#else
-#  define NB_TYPING_DICT "dict"
-#  define NB_TYPING_LIST "list"
-#  define NB_TYPING_SET "set"
+#  define NB_TYPING_ABC   "typing."
+#  define NB_TYPING_TUPLE "typing.Tuple"
+#  define NB_TYPING_LIST  "typing.List"
+#  define NB_TYPING_DICT  "typing.Dict"
+#  define NB_TYPING_SET   "typing.Set"
+#  define NB_TYPING_TYPE  "typing.Type"
+#else
+#  define NB_TYPING_ABC   "collections.abc."
 #  define NB_TYPING_TUPLE "tuple"
-#  define NB_TYPING_TYPE "type"
+#  define NB_TYPING_LIST  "list"
+#  define NB_TYPING_DICT  "dict"
+#  define NB_TYPING_SET   "set"
+#  define NB_TYPING_TYPE  "type"
+#endif
+
+#define NB_TYPING_SEQUENCE     NB_TYPING_ABC "Sequence"
+#define NB_TYPING_MAPPING      NB_TYPING_ABC "Mapping"
+#define NB_TYPING_CALLABLE     NB_TYPING_ABC "Callable"
+#define NB_TYPING_ITERATOR     NB_TYPING_ABC "Iterator"
+#define NB_TYPING_ITERABLE     NB_TYPING_ABC "Iterable"
+
+#if PY_VERSION_HEX < 0x03090000
+#  define NB_TYPING_ABSTRACT_SET "typing.AbstractSet"
+#else
+#  define NB_TYPING_ABSTRACT_SET "collections.abc.Set"
 #endif
 
 #if defined(Py_LIMITED_API)
 #  if PY_VERSION_HEX < 0x030C0000 || defined(PYPY_VERSION)
 #    error "nanobind can target Python's limited API, but this requires CPython >= 3.12"
 #  endif
 #  define NB_TUPLE_GET_SIZE PyTuple_Size
```

## nanobind/include/nanobind/nb_descr.h

```diff
@@ -73,14 +73,41 @@
 
     if constexpr (B)
         return d1;
     else
         return d2;
 }
 
+// Use a different name based on whether the parameter is used as input or output
+template <size_t N1, size_t N2>
+constexpr auto io_name(char const (&text1)[N1], char const (&text2)[N2]) {
+    return const_name('@') + const_name(text1) + const_name('@') +
+           const_name(text2) + const_name('@');
+}
+
+#if PY_VERSION_HEX < 0x030A0000
+template <typename T> constexpr auto optional_name(const T &v) {
+    return const_name("typing.Optional[") + v + const_name("]");
+}
+template <typename... Ts> constexpr auto union_name(const Ts&... vs) {
+    return const_name("typing.Union[") + concat(vs...) + const_name("]");
+}
+#else
+template <typename T> constexpr auto optional_name(const T &v) {
+    return v + const_name(" | None");
+}
+template <typename T> constexpr auto union_name(const T &v) {
+    return v;
+}
+template <typename T1, typename T2, typename... Ts>
+constexpr auto union_name(const T1 &v1, const T2 &v2, const Ts &...vs) {
+    return v1 + const_name(" | ") + union_name(v2, vs...);
+}
+#endif
+
 template <size_t Size>
 auto constexpr const_name() -> std::remove_cv_t<decltype(int_to_str<Size / 10, Size % 10>::digits)> {
     return int_to_str<Size / 10, Size % 10>::digits;
 }
 
 template <typename Type> constexpr descr<1, Type> const_name() { return {'%'}; }
```

## nanobind/include/nanobind/nb_func.h

```diff
@@ -22,14 +22,23 @@
     size_t size_after = cleanup->size();
     if (size_after != size_before)
         args[index] = (*cleanup)[size_after - 1];
 
     return true;
 }
 
+// Return the number of nb::arg and nb::arg_v types in the first I types Ts.
+// Invoke with std::make_index_sequence<sizeof...(Ts)>() to provide
+// an index pack 'Is' that parallels the types pack Ts.
+template <size_t I, typename... Ts, size_t... Is>
+constexpr size_t count_args_before_index(std::index_sequence<Is...>) {
+    static_assert(sizeof...(Is) == sizeof...(Ts));
+    return ((Is < I && (std::is_same_v<arg, Ts> || std::is_same_v<arg_v, Ts>)) + ... + 0);
+}
+
 template <bool ReturnRef, bool CheckGuard, typename Func, typename Return,
           typename... Args, size_t... Is, typename... Extra>
 NB_INLINE PyObject *func_create(Func &&func, Return (*)(Args...),
                                 std::index_sequence<Is...> is,
                                 const Extra &...extra) {
     using Info = func_extra_info<Extra...>;
 
@@ -41,39 +50,84 @@
                 return func((forward_t<Args>) args...);
             },
             (Return(*)(Args...)) nullptr, is, extra...);
     }
 
     (void) is;
 
-    // Detect locations of nb::args / nb::kwargs (if exists)
+    // Detect locations of nb::args / nb::kwargs (if they exist).
+    // Find the first and last occurrence of each; we'll later make sure these
+    // match, in order to guarantee there's only one instance.
     static constexpr size_t
         args_pos_1 = index_1_v<std::is_same_v<intrinsic_t<Args>, args>...>,
         args_pos_n = index_n_v<std::is_same_v<intrinsic_t<Args>, args>...>,
         kwargs_pos_1 = index_1_v<std::is_same_v<intrinsic_t<Args>, kwargs>...>,
         kwargs_pos_n = index_n_v<std::is_same_v<intrinsic_t<Args>, kwargs>...>,
         nargs = sizeof...(Args);
 
     // Determine the number of nb::arg/nb::arg_v annotations
     constexpr size_t nargs_provided =
         ((std::is_same_v<arg, Extra> + std::is_same_v<arg_v, Extra>) + ... + 0);
     constexpr bool is_method_det =
         (std::is_same_v<is_method, Extra> + ... + 0) != 0;
     constexpr bool is_getter_det =
         (std::is_same_v<is_getter, Extra> + ... + 0) != 0;
+    constexpr bool has_arg_annotations = nargs_provided > 0 && !is_getter_det;
+
+    // Detect location of nb::kw_only annotation, if supplied. As with args/kwargs
+    // we find the first and last location and later verify they match each other.
+    // Note this is an index in Extra... while args/kwargs_pos_* are indices in
+    // Args... .
+    constexpr size_t
+        kwonly_pos_1 = index_1_v<std::is_same_v<kw_only, Extra>...>,
+        kwonly_pos_n = index_n_v<std::is_same_v<kw_only, Extra>...>;
+    // Arguments after nb::args are implicitly keyword-only even if there is no
+    // nb::kw_only annotation
+    constexpr bool explicit_kw_only = kwonly_pos_1 != sizeof...(Extra);
+    constexpr bool implicit_kw_only = args_pos_1 + 1 < kwargs_pos_1;
 
     // A few compile-time consistency checks
     static_assert(args_pos_1 == args_pos_n && kwargs_pos_1 == kwargs_pos_n,
         "Repeated use of nb::kwargs or nb::args in the function signature!");
-    static_assert(nargs_provided == 0 || nargs_provided + is_method_det == nargs || is_getter_det,
+    static_assert(!has_arg_annotations || nargs_provided + is_method_det == nargs,
         "The number of nb::arg annotations must match the argument count!");
     static_assert(kwargs_pos_1 == nargs || kwargs_pos_1 + 1 == nargs,
         "nb::kwargs must be the last element of the function signature!");
-    static_assert(args_pos_1 == nargs || args_pos_1 + 1 == kwargs_pos_1,
-        "nb::args must follow positional arguments and precede nb::kwargs!");
+    static_assert(args_pos_1 == nargs || args_pos_1 < kwargs_pos_1,
+        "nb::args must precede nb::kwargs if both are present!");
+    static_assert(has_arg_annotations || (!implicit_kw_only && !explicit_kw_only),
+        "Keyword-only arguments must have names!");
+
+    // Find the index in Args... of the first keyword-only parameter. Since
+    // the 'self' parameter doesn't get a nb::arg annotation, we must adjust
+    // by 1 for methods. Note that nargs_before_kw_only is only used if
+    // a kw_only annotation exists (i.e., if explicit_kw_only is true);
+    // the conditional is just to save the compiler some effort otherwise.
+    constexpr size_t nargs_before_kw_only =
+        explicit_kw_only
+            ? is_method_det + count_args_before_index<kwonly_pos_1, Extra...>(
+                  std::make_index_sequence<sizeof...(Extra)>())
+            : nargs;
+
+    if constexpr (explicit_kw_only) {
+        static_assert(kwonly_pos_1 == kwonly_pos_n,
+            "Repeated use of nb::kw_only annotation!");
+
+        // If both kw_only and *args are specified, kw_only must be
+        // immediately after the nb::arg for *args.
+        static_assert(args_pos_1 == nargs || nargs_before_kw_only == args_pos_1 + 1,
+            "Arguments after nb::args are implicitly keyword-only; any "
+            "nb::kw_only() annotation must be positioned to reflect that!");
+
+        // If both kw_only and **kwargs are specified, kw_only must be
+        // before the nb::arg for **kwargs.
+        static_assert(nargs_before_kw_only < kwargs_pos_1,
+            "Variadic nb::kwargs are implicitly keyword-only; any "
+            "nb::kw_only() annotation must be positioned to reflect that!");
+    }
 
     // Collect function signature information for the docstring
     using cast_out = make_caster<
         std::conditional_t<std::is_void_v<Return>, void_type, Return>>;
 
     // Compile-time function signature
     static constexpr auto descr =
@@ -92,16 +146,15 @@
     };
 
     // The following temporary record will describe the function in detail
     func_data_prelim<nargs_provided> f;
     f.flags = (args_pos_1   < nargs ? (uint32_t) func_flags::has_var_args   : 0) |
               (kwargs_pos_1 < nargs ? (uint32_t) func_flags::has_var_kwargs : 0) |
               (ReturnRef            ? (uint32_t) func_flags::return_ref     : 0) |
-              (nargs_provided &&
-               !is_getter_det       ? (uint32_t) func_flags::has_args       : 0);
+              (has_arg_annotations  ? (uint32_t) func_flags::has_args       : 0);
 
     /* Store captured function inside 'func_data_prelim' if there is space. Issues
        with aliasing are resolved via separate compilation of libnanobind. */
     if constexpr (sizeof(capture) <= sizeof(f.capture)) {
         capture *cap = (capture *) f.capture;
         new (cap) capture{ (forward_t<Func>) func };
 
@@ -162,96 +215,124 @@
         return result;
     };
 
     f.descr = descr.text;
     f.descr_types = descr_types;
     f.nargs = nargs;
 
+    // Set nargs_pos to the number of C++ function parameters (Args...) that
+    // can be filled from Python positional arguments in a one-to-one fashion.
+    // This ends at:
+    // - the location of the variadic *args parameter, if present; otherwise
+    // - the location of the first keyword-only parameter, if any; otherwise
+    // - the location of the variadic **kwargs parameter, if present; otherwise
+    // - the end of the parameter list
+    // It's correct to give *args priority over kw_only because we verified
+    // above that kw_only comes afterward if both are present. It's correct
+    // to give kw_only priority over **kwargs because we verified above that
+    // kw_only comes before if both are present.
+    f.nargs_pos =   args_pos_1 < nargs ? args_pos_1 :
+                      explicit_kw_only ? nargs_before_kw_only :
+                  kwargs_pos_1 < nargs ? kwargs_pos_1 : nargs;
+
     // Fill remaining fields of 'f'
     size_t arg_index = 0;
     (void) arg_index;
     (func_extra_apply(f, extra, arg_index), ...);
 
     return nb_func_new((const void *) &f);
 }
 
 NAMESPACE_END(detail)
 
-template <typename Return, typename... Args, typename... Extra>
+// The initial template parameter to cpp_function/cpp_function_def is
+// used by class_ to ensure that member pointers are treated as members
+// of the class being defined; other users can safely leave it at its
+// default of void.
+
+template <typename = void, typename Return, typename... Args, typename... Extra>
 NB_INLINE object cpp_function(Return (*f)(Args...), const Extra&... extra) {
     return steal(detail::func_create<true, true>(
         f, f, std::make_index_sequence<sizeof...(Args)>(), extra...));
 }
 
-template <typename Return, typename... Args, typename... Extra>
+template <typename = void, typename Return, typename... Args, typename... Extra>
 NB_INLINE void cpp_function_def(Return (*f)(Args...), const Extra&... extra) {
     detail::func_create<false, true>(
         f, f, std::make_index_sequence<sizeof...(Args)>(), extra...);
 }
 
 /// Construct a cpp_function from a lambda function (pot. with internal state)
 template <
-    typename Func, typename... Extra,
+    typename = void, typename Func, typename... Extra,
     detail::enable_if_t<detail::is_lambda_v<std::remove_reference_t<Func>>> = 0>
 NB_INLINE object cpp_function(Func &&f, const Extra &...extra) {
     using am = detail::analyze_method<decltype(&std::remove_reference_t<Func>::operator())>;
     return steal(detail::func_create<true, true>(
         (detail::forward_t<Func>) f, (typename am::func *) nullptr,
         std::make_index_sequence<am::argc>(), extra...));
 }
 
 template <
-    typename Func, typename... Extra,
+    typename = void, typename Func, typename... Extra,
     detail::enable_if_t<detail::is_lambda_v<std::remove_reference_t<Func>>> = 0>
 NB_INLINE void cpp_function_def(Func &&f, const Extra &...extra) {
     using am = detail::analyze_method<decltype(&std::remove_reference_t<Func>::operator())>;
     detail::func_create<false, true>(
         (detail::forward_t<Func>) f, (typename am::func *) nullptr,
         std::make_index_sequence<am::argc>(), extra...);
 }
 
 /// Construct a cpp_function from a class method (non-const)
-template <typename Return, typename Class, typename... Args, typename... Extra>
+template <typename Target = void,
+          typename Return, typename Class, typename... Args, typename... Extra>
 NB_INLINE object cpp_function(Return (Class::*f)(Args...), const Extra &...extra) {
+    using T = std::conditional_t<std::is_void_v<Target>, Class, Target>;
     return steal(detail::func_create<true, true>(
-        [f](Class *c, Args... args) NB_INLINE_LAMBDA -> Return {
+        [f](T *c, Args... args) NB_INLINE_LAMBDA -> Return {
             return (c->*f)((detail::forward_t<Args>) args...);
         },
-        (Return(*)(Class *, Args...)) nullptr,
+        (Return(*)(T *, Args...)) nullptr,
         std::make_index_sequence<sizeof...(Args) + 1>(), extra...));
 }
 
-template <typename Return, typename Class, typename... Args, typename... Extra>
+template <typename Target = void,
+          typename Return, typename Class, typename... Args, typename... Extra>
 NB_INLINE void cpp_function_def(Return (Class::*f)(Args...), const Extra &...extra) {
+    using T = std::conditional_t<std::is_void_v<Target>, Class, Target>;
     detail::func_create<false, true>(
-        [f](Class *c, Args... args) NB_INLINE_LAMBDA -> Return {
+        [f](T *c, Args... args) NB_INLINE_LAMBDA -> Return {
             return (c->*f)((detail::forward_t<Args>) args...);
         },
-        (Return(*)(Class *, Args...)) nullptr,
+        (Return(*)(T *, Args...)) nullptr,
         std::make_index_sequence<sizeof...(Args) + 1>(), extra...);
 }
 
 /// Construct a cpp_function from a class method (const)
-template <typename Return, typename Class, typename... Args, typename... Extra>
+template <typename Target = void,
+          typename Return, typename Class, typename... Args, typename... Extra>
 NB_INLINE object cpp_function(Return (Class::*f)(Args...) const, const Extra &...extra) {
+    using T = std::conditional_t<std::is_void_v<Target>, Class, Target>;
     return steal(detail::func_create<true, true>(
-        [f](const Class *c, Args... args) NB_INLINE_LAMBDA -> Return {
+        [f](const T *c, Args... args) NB_INLINE_LAMBDA -> Return {
             return (c->*f)((detail::forward_t<Args>) args...);
         },
-        (Return(*)(const Class *, Args...)) nullptr,
+        (Return(*)(const T *, Args...)) nullptr,
         std::make_index_sequence<sizeof...(Args) + 1>(), extra...));
 }
 
-template <typename Return, typename Class, typename... Args, typename... Extra>
+template <typename Target = void,
+          typename Return, typename Class, typename... Args, typename... Extra>
 NB_INLINE void cpp_function_def(Return (Class::*f)(Args...) const, const Extra &...extra) {
+    using T = std::conditional_t<std::is_void_v<Target>, Class, Target>;
     detail::func_create<false, true>(
-        [f](const Class *c, Args... args) NB_INLINE_LAMBDA -> Return {
+        [f](const T *c, Args... args) NB_INLINE_LAMBDA -> Return {
             return (c->*f)((detail::forward_t<Args>) args...);
         },
-        (Return(*)(const Class *, Args...)) nullptr,
+        (Return(*)(const T *, Args...)) nullptr,
         std::make_index_sequence<sizeof...(Args) + 1>(), extra...);
 }
 
 template <typename Func, typename... Extra>
 module_ &module_::def(const char *name_, Func &&f, const Extra &...extra) {
     cpp_function_def((detail::forward_t<Func>) f, scope(*this),
                      name(name_), extra...);
```

## nanobind/include/nanobind/nb_lib.h

```diff
@@ -5,22 +5,23 @@
 
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 
-// Forward declarations for types in dlpack.h (1)
+// Forward declarations for types in ndarray.h (1)
 namespace dlpack { struct dltensor; struct dtype; }
 
 NAMESPACE_BEGIN(detail)
 
-// Forward declarations for types in dlpack.h (2)
+// Forward declarations for types in ndarray.h (2)
 struct ndarray_handle;
 struct ndarray_req;
+enum class ndarray_framework : int;
 
 /**
  * Helper class to clean temporaries created by function dispatch.
  * The first element serves a special role: it stores the 'self'
  * object of method calls (for rv_policy::reference_internal).
  */
 struct NB_CORE cleanup_list {
@@ -124,16 +125,16 @@
 
 /// Convert a Python object into a Python byte string
 NB_CORE PyObject *bytes_from_obj(PyObject *o);
 
 /// Convert an UTF8 null-terminated C string into a Python byte string
 NB_CORE PyObject *bytes_from_cstr(const char *c);
 
-/// Convert an UTF8 C string + size into a Python byte string
-NB_CORE PyObject *bytes_from_cstr_and_size(const char *c, size_t n);
+/// Convert a memory region into a Python byte string
+NB_CORE PyObject *bytes_from_cstr_and_size(const void *c, size_t n);
 
 // ========================================================================
 
 /// Convert a Python object into a Python boolean object
 NB_CORE PyObject *bool_from_obj(PyObject *o);
 
 /// Convert a Python object into a Python integer object
@@ -146,14 +147,17 @@
 
 /// Convert a Python object into a Python list
 NB_CORE PyObject *list_from_obj(PyObject *o);
 
 /// Convert a Python object into a Python tuple
 NB_CORE PyObject *tuple_from_obj(PyObject *o);
 
+/// Convert a Python object into a Python set
+NB_CORE PyObject *set_from_obj(PyObject *o);
+
 // ========================================================================
 
 /// Get an object attribute or raise an exception
 NB_CORE PyObject *getattr(PyObject *obj, const char *key);
 NB_CORE PyObject *getattr(PyObject *obj, PyObject *key);
 
 /// Get an object attribute or return a default value (never raises)
@@ -290,16 +294,21 @@
 
 // Special version of 'nb_type_put_unique' for polymorphic classes
 NB_CORE PyObject *nb_type_put_unique_p(const std::type_info *cpp_type,
                                        const std::type_info *cpp_type_p,
                                        void *value, cleanup_list *cleanup,
                                        bool cpp_delete) noexcept;
 
-/// Try to reliquish ownership from Python object to a unique_ptr
-NB_CORE void nb_type_relinquish_ownership(PyObject *o, bool cpp_delete);
+/// Try to reliquish ownership from Python object to a unique_ptr;
+/// return true if successful, false if not. (Failure is only
+/// possible if `cpp_delete` is true.)
+NB_CORE bool nb_type_relinquish_ownership(PyObject *o, bool cpp_delete) noexcept;
+
+/// Reverse the effects of nb_type_relinquish_ownership().
+NB_CORE void nb_type_restore_ownership(PyObject *o, bool cpp_delete) noexcept;
 
 /// Get a pointer to a user-defined 'extra' value associated with the nb_type t.
 NB_CORE void *nb_type_supplement(PyObject *t) noexcept;
 
 /// Check if the given python object represents a nanobind type
 NB_CORE bool nb_type_check(PyObject *t) noexcept;
 
@@ -402,30 +411,41 @@
 NB_CORE void implicitly_convertible(bool (*predicate)(PyTypeObject *,
                                                       PyObject *,
                                                       cleanup_list *),
                                     const std::type_info *dst) noexcept;
 
 // ========================================================================
 
-/// Fill in slots for an enum type being built
-NB_CORE void nb_enum_prepare(const type_init_data *t,
-                             PyType_Slot *&slots, size_t max_slots) noexcept;
-
-/// Add an entry to an enumeration
-NB_CORE void nb_enum_put(PyObject *type, const char *name, const void *value,
-                         const char *doc) noexcept;
+struct enum_init_data;
+
+/// Create a new enumeration type
+NB_CORE PyObject *enum_create(enum_init_data *) noexcept;
+
+/// Append an entry to an enumeration
+NB_CORE void enum_append(PyObject *tp, const char *name,
+                         int64_t value, const char *doc) noexcept;
+
+// Query an enumeration's Python object -> integer value map
+NB_CORE bool enum_from_python(const std::type_info *, PyObject *, int64_t *,
+                              uint8_t flags) noexcept;
+
+// Query an enumeration's integer value -> Python object map
+NB_CORE PyObject *enum_from_cpp(const std::type_info *, int64_t) noexcept;
 
 /// Export enum entries to the parent scope
-NB_CORE void nb_enum_export(PyObject *type);
+NB_CORE void enum_export(PyObject *tp);
 
 // ========================================================================
 
 /// Try to import a Python extension module, raises an exception upon failure
 NB_CORE PyObject *module_import(const char *name);
 
+/// Try to import a Python extension module, raises an exception upon failure
+NB_CORE PyObject *module_import(PyObject *name);
+
 /// Create a new extension module with the given name
 NB_CORE PyObject *module_new(const char *name, PyModuleDef *def) noexcept;
 
 /// Create a submodule of an existing module
 NB_CORE PyObject *module_new_submodule(PyObject *base, const char *name,
                                        const char *doc) noexcept;
 
@@ -448,18 +468,18 @@
 /// to the underlying DLTensor
 NB_CORE dlpack::dltensor *ndarray_inc_ref(ndarray_handle *) noexcept;
 
 /// Decrease the reference count of the given ndarray object
 NB_CORE void ndarray_dec_ref(ndarray_handle *) noexcept;
 
 /// Wrap a ndarray_handle* into a PyCapsule
-NB_CORE PyObject *ndarray_wrap(ndarray_handle *, int framework,
+NB_CORE PyObject *ndarray_wrap(ndarray_handle *, ndarray_framework framework,
                                rv_policy policy, cleanup_list *cleanup) noexcept;
 
-/// Check if an object is a known ndarray type (NumPy, PyTorch, Tensorflow, JAX)
+/// Check if an object represents an ndarray
 NB_CORE bool ndarray_check(PyObject *o) noexcept;
 
 // ========================================================================
 
 /// Print to stdout using Python
 NB_CORE void print(PyObject *file, PyObject *str, PyObject *end);
 
@@ -507,14 +527,18 @@
 
 NB_CORE void slice_compute(PyObject *slice, Py_ssize_t size,
                            Py_ssize_t &start, Py_ssize_t &stop,
                            Py_ssize_t &step, size_t &slice_length);
 
 // ========================================================================
 
+NB_CORE bool issubclass(PyObject *a, PyObject *b);
+
+// ========================================================================
+
 NB_CORE PyObject *repr_list(PyObject *o);
 NB_CORE PyObject *repr_map(PyObject *o);
 
 NB_CORE bool is_alive() noexcept;
 
 #if NB_TYPE_GET_SLOT_IMPL
 NB_CORE void *type_get_slot(PyTypeObject *t, int slot_id);
```

## nanobind/include/nanobind/nb_traits.h

```diff
@@ -4,14 +4,16 @@
     Copyright (c) 2022 Wenzel Jakob
 
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
+using ssize_t = std::make_signed_t<size_t>;
+
 NAMESPACE_BEGIN(detail)
 
 struct void_type { };
 
 template <bool... Bs> struct index_1;
 template <bool... Bs> struct index_n;
 
@@ -49,15 +51,15 @@
 template <typename T, typename U>
 using forwarded_type = std::conditional_t<std::is_lvalue_reference_v<T>,
                                           std::remove_reference_t<U> &,
                                           std::remove_reference_t<U> &&>;
 
 /// Forwards a value U as rvalue or lvalue according to whether T is rvalue or lvalue; typically
 /// used for forwarding a container's elements.
-template <typename T, typename U> NB_INLINE forwarded_type<T, U> forward_like(U &&u) {
+template <typename T, typename U> NB_INLINE forwarded_type<T, U> forward_like_(U &&u) {
     return (forwarded_type<T, U>) u;
 }
 
 template <typename T>
 constexpr bool is_std_char_v =
     std::is_same_v<T, char>
 #if defined(NB_HAS_U8STRING)
@@ -95,14 +97,28 @@
 
 template <typename Cls, typename Ret, typename... Args>
 struct analyze_method<Ret (Cls::*)(Args...) const noexcept> {
     using func = Ret(Args...);
     static constexpr size_t argc = sizeof...(Args);
 };
 
+template <typename F>
+struct strip_function_object {
+    using type = typename analyze_method<decltype(&F::operator())>::func;
+};
+
+// Extracts the function signature from a function, function pointer or lambda.
+template <typename Function, typename F = std::remove_reference_t<Function>>
+using function_signature_t = std::conditional_t<
+    std::is_function_v<F>, F,
+    typename std::conditional_t<
+        std::is_pointer_v<F> || std::is_member_pointer_v<F>,
+        std::remove_pointer<F>,
+        strip_function_object<F>>::type>;
+
 template <typename T>
 using forward_t = std::conditional_t<std::is_lvalue_reference_v<T>, T, T &&>;
 
 template <typename...> inline constexpr bool false_v = false;
 
 template <typename... Args> struct overload_cast_impl {
     template <typename Return>
@@ -153,14 +169,36 @@
 
 template <typename T> using is_class_caster_test = std::enable_if_t<T::IsClass>;
 
 /// Generalized version of the is_base_caster_v test that also accepts unique_ptr/shared_ptr
 template <typename Caster>
 constexpr bool is_class_caster_v = detail::detector<void, is_class_caster_test, Caster>::value;
 
+// Primary template
+template<typename T, typename SFINAE = void>
+struct is_complex : std::false_type {};
+
+// Specialization if `T` is complex, i.e., `T` has a member type `value_type`,
+// member functions `real()` and `imag()` that return such, and the size of
+// `T` is twice that of `value_type`.
+template<typename T>
+struct is_complex<T, std::enable_if_t<std::is_same_v<
+                                          decltype(std::declval<T>().real()),
+                                          typename T::value_type>
+                                   && std::is_same_v<
+                                          decltype(std::declval<T>().imag()),
+                                          typename T::value_type>
+                                   && (sizeof(T) ==
+                                       2 * sizeof(typename T::value_type))>>
+    : std::true_type {};
+
+/// True if the type `T` is a complete type representing a complex number.
+template<typename T>
+inline constexpr bool is_complex_v = is_complex<T>::value;
+
 NAMESPACE_END(detail)
 
 template <typename... Args>
 static constexpr detail::overload_cast_impl<Args...> overload_cast = {};
 static constexpr auto const_ = std::true_type{};
 
 template <template<typename> class Op, typename Arg>
```

## nanobind/include/nanobind/nb_types.h

```diff
@@ -87,15 +87,17 @@
 template <typename Impl> class accessor;
 struct str_attr; struct obj_attr;
 struct str_item; struct obj_item; struct num_item;
 struct num_item_list; struct num_item_tuple;
 class args_proxy; class kwargs_proxy;
 struct borrow_t { };
 struct steal_t { };
-class api_tag { };
+struct api_tag {
+    constexpr static bool nb_typed = false;
+};
 class dict_iterator;
 struct fast_iterator;
 
 // Standard operations provided by every nanobind object
 template <typename Derived> class api : public api_tag {
 public:
     Derived &derived() { return static_cast<Derived &>(*this); }
@@ -308,33 +310,35 @@
 
 inline void delattr(handle h, handle key) {
     detail::delattr(h.ptr(), key.ptr());
 }
 
 class module_ : public object {
 public:
-    NB_OBJECT(module_, object, "module", PyModule_CheckExact);
+    NB_OBJECT(module_, object, "types.ModuleType", PyModule_CheckExact);
 
     template <typename Func, typename... Extra>
     module_ &def(const char *name_, Func &&f, const Extra &...extra);
 
-    /// Import and return a module or throws `python_error`.
     static NB_INLINE module_ import_(const char *name) {
         return steal<module_>(detail::module_import(name));
     }
 
-    /// Import and return a module or throws `python_error`.
+    static NB_INLINE module_ import_(handle name) {
+        return steal<module_>(detail::module_import(name.ptr()));
+    }
+
     NB_INLINE module_ def_submodule(const char *name,
                                     const char *doc = nullptr) {
         return steal<module_>(detail::module_new_submodule(m_ptr, name, doc));
     }
 };
 
 class capsule : public object {
-    NB_OBJECT_DEFAULT(capsule, object, "capsule", PyCapsule_CheckExact)
+    NB_OBJECT_DEFAULT(capsule, object, "types.CapsuleType", PyCapsule_CheckExact)
 
     capsule(const void *ptr, void (*cleanup)(void *) noexcept = nullptr) {
         m_ptr = detail::capsule_new(ptr, nullptr, cleanup);
     }
 
     capsule(const void *ptr, const char *name,
             void (*cleanup)(void *) noexcept = nullptr) {
@@ -425,19 +429,21 @@
 
     explicit bytes(handle h)
         : object(detail::bytes_from_obj(h.ptr()), detail::steal_t{}) { }
 
     explicit bytes(const char *s)
         : object(detail::bytes_from_cstr(s), detail::steal_t{}) { }
 
-    explicit bytes(const char *s, size_t n)
+    explicit bytes(const void *s, size_t n)
         : object(detail::bytes_from_cstr_and_size(s, n), detail::steal_t{}) { }
 
     const char *c_str() const { return PyBytes_AsString(m_ptr); }
 
+    const void *data() const { return (const void *) PyBytes_AsString(m_ptr); }
+
     size_t size() const { return (size_t) PyBytes_Size(m_ptr); }
 };
 
 class tuple : public object {
     NB_OBJECT(tuple, object, "tuple", PyTuple_Check)
     tuple() : object(PyTuple_New(0), detail::steal_t()) { }
     explicit tuple(handle h)
@@ -460,18 +466,39 @@
     NB_OBJECT(list, object, "list", PyList_Check)
     list() : object(PyList_New(0), detail::steal_t()) { }
     explicit list(handle h)
         : object(detail::list_from_obj(h.ptr()), detail::steal_t{}) { }
     size_t size() const { return (size_t) NB_LIST_GET_SIZE(m_ptr); }
 
     template <typename T> void append(T &&value);
+    template <typename T> void insert(Py_ssize_t index, T &&value);
 
     template <typename T, detail::enable_if_t<std::is_arithmetic_v<T>> = 1>
     detail::accessor<detail::num_item_list> operator[](T key) const;
 
+    void clear() {
+        if (PyList_SetSlice(m_ptr, 0, PY_SSIZE_T_MAX, nullptr))
+            raise_python_error();
+    }
+
+    void extend(handle h) {
+        if (PyList_SetSlice(m_ptr, PY_SSIZE_T_MAX, PY_SSIZE_T_MAX, h.ptr()))
+            raise_python_error();
+    }
+
+    void sort() {
+        if (PyList_Sort(m_ptr))
+            raise_python_error();
+    }
+
+    void reverse() {
+        if (PyList_Reverse(m_ptr))
+            raise_python_error();
+    }
+
 #if !defined(Py_LIMITED_API) && !defined(PYPY_VERSION)
     detail::fast_iterator begin() const;
     detail::fast_iterator end() const;
 #endif
 };
 
 class dict : public object {
@@ -481,35 +508,41 @@
     detail::dict_iterator begin() const;
     detail::dict_iterator end() const;
     list keys() const { return steal<list>(detail::obj_op_1(m_ptr, PyDict_Keys)); }
     list values() const { return steal<list>(detail::obj_op_1(m_ptr, PyDict_Values)); }
     list items() const { return steal<list>(detail::obj_op_1(m_ptr, PyDict_Items)); }
     template <typename T> bool contains(T&& key) const;
     void clear() { PyDict_Clear(m_ptr); }
+    void update(handle h) {
+        if (PyDict_Update(m_ptr, h.ptr()))
+            raise_python_error();
+    }
 };
 
-
 class set : public object {
     NB_OBJECT(set, object, "set", PySet_Check)
     set() : object(PySet_New(nullptr), detail::steal_t()) { }
+    explicit set(handle h)
+        : object(detail::set_from_obj(h.ptr()), detail::steal_t{}) { }
     size_t size() const { return (size_t) NB_SET_GET_SIZE(m_ptr); }
     template <typename T> bool contains(T&& key) const;
     template <typename T> void add(T &&value);
     void clear() {
         if (PySet_Clear(m_ptr))
             raise_python_error();
     }
+    template <typename T> bool discard(T &&value);
 };
 
 class sequence : public object {
-    NB_OBJECT_DEFAULT(sequence, object, "Sequence", PySequence_Check)
+    NB_OBJECT_DEFAULT(sequence, object, NB_TYPING_SEQUENCE, PySequence_Check)
 };
 
 class mapping : public object {
-    NB_OBJECT_DEFAULT(mapping, object, "Mapping", PyMapping_Check)
+    NB_OBJECT_DEFAULT(mapping, object, NB_TYPING_MAPPING, PyMapping_Check)
     list keys() const { return steal<list>(detail::obj_op_1(m_ptr, PyMapping_Keys)); }
     list values() const { return steal<list>(detail::obj_op_1(m_ptr, PyMapping_Values)); }
     list items() const { return steal<list>(detail::obj_op_1(m_ptr, PyMapping_Items)); }
     template <typename T> bool contains(T&& key) const;
 };
 
 class args : public tuple {
@@ -523,15 +556,15 @@
 class iterator : public object {
 public:
     using difference_type = Py_ssize_t;
     using value_type = handle;
     using reference = const handle;
     using pointer = const handle *;
 
-    NB_OBJECT_DEFAULT(iterator, object, "iterator", PyIter_Check)
+    NB_OBJECT_DEFAULT(iterator, object, NB_TYPING_ITERATOR, PyIter_Check)
 
     iterator& operator++() {
         m_value = steal(detail::obj_iter_next(m_ptr));
         return *this;
     }
 
     iterator operator++(int) {
@@ -555,15 +588,15 @@
 
 private:
     mutable object m_value;
 };
 
 class iterable : public object {
 public:
-    NB_OBJECT_DEFAULT(iterable, object, "Iterable", detail::iterable_check)
+    NB_OBJECT_DEFAULT(iterable, object, NB_TYPING_ITERABLE, detail::iterable_check)
 };
 
 /// Retrieve the Python type object associated with a C++ class
 template <typename T> handle type() noexcept {
     return detail::nb_type_lookup(&typeid(detail::intrinsic_t<T>));
 }
 
@@ -573,14 +606,18 @@
         return T::check_(h);
     else if constexpr (detail::is_base_caster_v<detail::make_caster<T>>)
         return detail::nb_type_isinstance(h.ptr(), &typeid(detail::intrinsic_t<T>));
     else
         return detail::make_caster<T>().from_python(h, 0, nullptr);
 }
 
+NB_INLINE bool issubclass(handle h1, handle h2) {
+    return detail::issubclass(h1.ptr(), h2.ptr());
+}
+
 NB_INLINE str repr(handle h) { return steal<str>(detail::obj_repr(h.ptr())); }
 NB_INLINE size_t len(handle h) { return detail::obj_len(h.ptr()); }
 NB_INLINE size_t len_hint(handle h) { return detail::obj_len_hint(h.ptr()); }
 NB_INLINE size_t len(const tuple &t) { return (size_t) NB_TUPLE_GET_SIZE(t.ptr()); }
 NB_INLINE size_t len(const list &l) { return (size_t) NB_LIST_GET_SIZE(l.ptr()); }
 NB_INLINE size_t len(const dict &d) { return (size_t) NB_DICT_GET_SIZE(d.ptr()); }
 NB_INLINE size_t len(const set &d) { return (size_t) NB_SET_GET_SIZE(d.ptr()); }
@@ -624,43 +661,50 @@
     }
 };
 
 class ellipsis : public object {
     static bool is_ellipsis(PyObject *obj) { return obj == Py_Ellipsis; }
 
 public:
-    NB_OBJECT(ellipsis, object, "EllipsisType", is_ellipsis)
+    NB_OBJECT(ellipsis, object, "types.EllipsisType", is_ellipsis)
     ellipsis() : object(Py_Ellipsis, detail::borrow_t()) {}
 };
 
 class not_implemented : public object {
     static bool is_not_implemented(PyObject *obj) { return obj == Py_NotImplemented; }
 
 public:
-    NB_OBJECT(not_implemented, object, "NotImplementedType", is_not_implemented)
+    NB_OBJECT(not_implemented, object, "types.NotImplementedType", is_not_implemented)
     not_implemented() : object(Py_NotImplemented, detail::borrow_t()) {}
 };
 
 class callable : public object {
 public:
-    NB_OBJECT(callable, object, "Callable[..., object]", PyCallable_Check)
+    NB_OBJECT(callable, object, NB_TYPING_CALLABLE, PyCallable_Check)
     using object::object;
 };
 
 class weakref : public object {
 public:
-    NB_OBJECT(weakref, object, "weakref", PyWeakref_Check)
+    NB_OBJECT(weakref, object, "weakref.ReferenceType", PyWeakref_Check)
 
     explicit weakref(handle obj, handle callback = {})
         : object(PyWeakref_NewRef(obj.ptr(), callback.ptr()), detail::steal_t{}) {
         if (!m_ptr)
             raise_python_error();
     }
 };
 
+class any : public object {
+public:
+    using object::object;
+    using object::operator=;
+    static constexpr auto Name = detail::const_name("typing.Any");
+};
+
 template <typename T> class handle_t : public handle {
 public:
     static constexpr auto Name = detail::make_caster<T>::Name;
 
     using handle::handle;
     using handle::operator=;
     handle_t(const handle &h) : handle(h) { }
@@ -680,15 +724,20 @@
     static bool check_(handle h) {
         return PyType_Check(h.ptr()) &&
                PyType_IsSubtype((PyTypeObject *) h.ptr(),
                                 (PyTypeObject *) nanobind::type<T>().ptr());
     }
 };
 
-template <typename T, typename X> struct typed { T value; };
+template <typename T, typename...> class typed : public T {
+public:
+    constexpr static bool nb_typed = true;
+    using T::T;
+    using T::operator=;
+};
 
 template <typename T> struct pointer_and_handle {
     T *p;
     handle h;
 };
 
 NAMESPACE_BEGIN(detail)
```

## nanobind/include/nanobind/ndarray.h

```diff
@@ -61,37 +61,33 @@
     int64_t *shape = nullptr;
     int64_t *strides = nullptr;
     uint64_t byte_offset = 0;
 };
 
 NAMESPACE_END(dlpack)
 
-NAMESPACE_BEGIN(detail)
-
-template <typename T> struct is_complex : std::false_type { };
-
-NAMESPACE_END(detail)
-
-constexpr size_t any = (size_t) -1;
-
-template <size_t... Is> struct shape {
+template <ssize_t... Is> struct shape {
+    static_assert(
+        ((Is >= 0 || Is == -1) && ...),
+        "The arguments to nanobind::shape must either be positive or equal to -1"
+    );
     static constexpr size_t size = sizeof...(Is);
 };
 
 struct c_contig { };
 struct f_contig { };
 struct any_contig { };
 struct numpy { };
 struct tensorflow { };
 struct pytorch { };
 struct jax { };
 struct ro { };
 
 template <typename T> struct ndarray_traits {
-    static constexpr bool is_complex = detail::is_complex<T>::value;
+    static constexpr bool is_complex = detail::is_complex_v<T>;
     static constexpr bool is_float   = std::is_floating_point_v<T>;
     static constexpr bool is_bool    = std::is_same_v<std::remove_cv_t<T>, bool>;
     static constexpr bool is_int     = std::is_integral_v<T> && !is_bool;
     static constexpr bool is_signed  = std::is_signed_v<T>;
 };
 
 NAMESPACE_BEGIN(detail)
@@ -99,15 +95,15 @@
 template <typename T>
 constexpr bool is_ndarray_scalar_v =
     ndarray_traits<T>::is_float || ndarray_traits<T>::is_int ||
     ndarray_traits<T>::is_bool || ndarray_traits<T>::is_complex;
 
 template <typename> struct ndim_shape;
 template <size_t... S> struct ndim_shape<std::index_sequence<S...>> {
-    using type = shape<((void) S, any)...>;
+    using type = shape<((void) S, -1)...>;
 };
 
 NAMESPACE_END(detail)
 
 template <size_t N> using ndim = typename detail::ndim_shape<std::make_index_sequence<N>>::type;
 
 template <typename T> constexpr dlpack::dtype dtype() {
@@ -223,24 +219,24 @@
     static constexpr auto name = const_name("writable=False");
 
     static void apply(ndarray_req &tr) {
         tr.req_ro = true;
     }
 };
 
-template <size_t... Is> struct ndarray_arg<shape<Is...>> {
+template <ssize_t... Is> struct ndarray_arg<shape<Is...>> {
     static constexpr size_t size = sizeof...(Is);
     static constexpr auto name =
         const_name("shape=(") +
-        concat(const_name<Is == any>(const_name("*"), const_name<Is>())...) +
+        concat(const_name<Is == -1>(const_name("*"), const_name<(size_t) Is>())...) +
         const_name(")");
 
     static void apply(ndarray_req &tr) {
         size_t i = 0;
-        ((tr.shape[i++] = Is), ...);
+        ((tr.shape[i++] = (size_t) Is), ...);
         tr.ndim = (uint32_t) sizeof...(Is);
         tr.req_shape = true;
     }
 };
 
 template <> struct ndarray_arg<c_contig> {
     static constexpr size_t size = 0;
@@ -277,15 +273,15 @@
 template <typename T, typename... Ts> struct ndarray_info<T, Ts...>  : ndarray_info<Ts...> {
     using scalar_type =
         std::conditional_t<ndarray_traits<T>::is_float || ndarray_traits<T>::is_int ||
                            ndarray_traits<T>::is_bool || ndarray_traits<T>::is_complex,
                            T, typename ndarray_info<Ts...>::scalar_type>;
 };
 
-template <size_t... Is, typename... Ts> struct ndarray_info<shape<Is...>, Ts...> : ndarray_info<Ts...> {
+template <ssize_t... Is, typename... Ts> struct ndarray_info<shape<Is...>, Ts...> : ndarray_info<Ts...> {
     using shape_type = shape<Is...>;
 };
 
 template <typename... Ts> struct ndarray_info<c_contig, Ts...> : ndarray_info<Ts...> {
     constexpr static char order = 'C';
 };
 
@@ -343,22 +339,22 @@
     size_t shape(size_t i) const { return m_shape[i]; }
     int64_t stride(size_t i) const { return m_strides[i]; }
     Scalar *data() const { return m_data; }
 
 private:
     template <typename...> friend class ndarray;
 
-    template <size_t... I1, size_t... I2>
+    template <size_t... I1, ssize_t... I2>
     ndarray_view(Scalar *data, const int64_t *shape, const int64_t *strides,
                  std::index_sequence<I1...>, nanobind::shape<I2...>)
         : m_data(data) {
 
         /* Initialize shape/strides with compile-time knowledge if
            available (to permit vectorization, loop unrolling, etc.) */
-        ((m_shape[I1] = (I2 == any) ? shape[I1] : I2), ...);
+        ((m_shape[I1] = (I2 == -1) ? shape[I1] : (int64_t) I2), ...);
         ((m_strides[I1] = strides[I1]), ...);
 
         if constexpr (Order == 'F') {
             m_strides[0] = 1;
             for (size_t i = 1; i < Dim; ++i)
                 m_strides[i] = m_strides[i - 1] * m_shape[i - 1];
         } else if constexpr (Order == 'C') {
@@ -387,41 +383,41 @@
         if (handle)
             m_dltensor = *detail::ndarray_inc_ref(handle);
     }
 
     template <typename... Args2>
     explicit ndarray(const ndarray<Args2...> &other) : ndarray(other.m_handle) { }
 
-    ndarray(std::conditional_t<std::is_const_v<Scalar>, const void *, void *> value,
+    ndarray(std::conditional_t<std::is_const_v<Scalar>, const void *, void *> data,
             size_t ndim,
             const size_t *shape,
-            handle owner = nanobind::handle(),
+            handle owner,
             const int64_t *strides = nullptr,
             dlpack::dtype dtype = nanobind::dtype<Scalar>(),
             int32_t device_type = device::cpu::value,
             int32_t device_id = 0) {
         m_handle = detail::ndarray_create(
-            (void *) value, ndim, shape, owner.ptr(), strides, &dtype,
+            (void *) data, ndim, shape, owner.ptr(), strides, &dtype,
             std::is_const_v<Scalar>, device_type, device_id);
         m_dltensor = *detail::ndarray_inc_ref(m_handle);
     }
 
-    ndarray(std::conditional_t<std::is_const_v<Scalar>, const void *, void *> value,
+    ndarray(std::conditional_t<std::is_const_v<Scalar>, const void *, void *> data,
             std::initializer_list<size_t> shape,
-            handle owner = nanobind::handle(),
+            handle owner,
             std::initializer_list<int64_t> strides = { },
             dlpack::dtype dtype = nanobind::dtype<Scalar>(),
             int32_t device_type = device::cpu::value,
             int32_t device_id = 0) {
 
         if (strides.size() != 0 && strides.size() != shape.size())
             detail::fail("ndarray(): shape and strides have incompatible size!");
 
         m_handle = detail::ndarray_create(
-            (void *) value, shape.size(), shape.begin(), owner.ptr(),
+            (void *) data, shape.size(), shape.begin(), owner.ptr(),
             (strides.size() == 0) ? nullptr : strides.begin(), &dtype,
             std::is_const_v<Scalar>, device_type, device_id);
 
         m_dltensor = *detail::ndarray_inc_ref(m_handle);
     }
 
     ~ndarray() {
@@ -462,15 +458,15 @@
     const int64_t* stride_ptr() const { return m_dltensor.strides; }
     bool is_valid() const { return m_handle != nullptr; }
     int32_t device_type() const { return m_dltensor.device.device_type; }
     int32_t device_id() const { return m_dltensor.device.device_id; }
     detail::ndarray_handle *handle() const { return m_handle; }
 
     size_t size() const {
-        size_t ret = 1;
+        size_t ret = is_valid();
         for (size_t i = 0; i < ndim(); ++i)
             ret *= shape(i);
         return ret;
     }
 
     size_t itemsize() const { return ((size_t) dtype().bits + 7) / 8; }
     size_t nbytes() const { return ((size_t) dtype().bits * size() + 7) / 8; }
@@ -567,20 +563,24 @@
 
     bool from_python(handle src, uint8_t flags, cleanup_list *cleanup) noexcept {
         constexpr size_t size = (0 + ... + detail::ndarray_arg<Args>::size);
         size_t shape[size + 1];
         detail::ndarray_req req;
         req.shape = shape;
         (detail::ndarray_arg<Args>::apply(req), ...);
+        if (src.is_none()) {
+            value = ndarray<Args...>();
+            return true;
+        }
         value = ndarray<Args...>(ndarray_import(
             src.ptr(), &req, flags & (uint8_t) cast_flags::convert, cleanup));
         return value.is_valid();
     }
 
     static handle from_cpp(const ndarray<Args...> &tensor, rv_policy policy,
                            cleanup_list *cleanup) noexcept {
-        return ndarray_wrap(tensor.handle(), int(Value::Info::framework), policy, cleanup);
+        return ndarray_wrap(tensor.handle(), Value::Info::framework, policy, cleanup);
     }
 };
 
 NAMESPACE_END(detail)
 NAMESPACE_END(NB_NAMESPACE)
```

## nanobind/include/nanobind/eigen/dense.h

```diff
@@ -91,17 +91,17 @@
 
 template <typename T, typename Scalar = typename T::Scalar>
 using array_for_eigen_t = ndarray<
     Scalar,
     numpy,
     std::conditional_t<
         ndim_v<T> == 1,
-        shape<(size_t) T::SizeAtCompileTime>,
-        shape<(size_t) T::RowsAtCompileTime,
-              (size_t) T::ColsAtCompileTime>>,
+        shape<T::SizeAtCompileTime>,
+        shape<T::RowsAtCompileTime,
+              T::ColsAtCompileTime>>,
     std::conditional_t<
         is_contiguous_v<T>,
         std::conditional_t<
             ndim_v<T> == 1 || T::IsRowMajor,
             c_contig,
             f_contig>,
         any_contig>>;
@@ -194,15 +194,15 @@
 
         object owner;
         if (policy == rv_policy::move) {
             T *temp = new T(std::move(v));
             owner = capsule(temp, [](void *p) noexcept { delete (T *) p; });
             ptr = temp->data();
             policy = rv_policy::reference;
-        } else if (policy == rv_policy::reference_internal) {
+        } else if (policy == rv_policy::reference_internal && cleanup->self()) {
             owner = borrow(cleanup->self());
             policy = rv_policy::reference;
         }
 
         object o = steal(NDArrayCaster::from_cpp(
             NDArray(ptr, ndim_v<T>, shape, owner, strides),
             policy, cleanup));
@@ -216,14 +216,15 @@
 struct type_caster<T, enable_if_t<is_eigen_xpr_v<T> &&
                                   is_ndarray_scalar_v<typename T::Scalar>>> {
     using Array = Eigen::Array<typename T::Scalar, T::RowsAtCompileTime,
                                T::ColsAtCompileTime>;
     using Caster = make_caster<Array>;
     static constexpr auto Name = Caster::Name;
     template <typename T_> using Cast = T;
+    template <typename T_> static constexpr bool can_cast() { return true; }
 
     /// Generating an expression template from a Python object is, of course, not possible
     bool from_python(handle src, uint8_t flags, cleanup_list *cleanup) noexcept = delete;
 
     template <typename T2>
     static handle from_cpp(T2 &&v, rv_policy policy, cleanup_list *cleanup) noexcept {
         return Caster::from_cpp(std::forward<T2>(v), policy, cleanup);
@@ -246,14 +247,15 @@
     using NDArray =
         array_for_eigen_t<Map, std::conditional_t<std::is_const_v<T>,
                                                   const typename Map::Scalar,
                                                   typename Map::Scalar>>;
     using NDArrayCaster = type_caster<NDArray>;
     static constexpr auto Name = NDArrayCaster::Name;
     template <typename T_> using Cast = Map;
+    template <typename T_> static constexpr bool can_cast() { return true; }
 
     NDArrayCaster caster;
 
     bool from_python(handle src, uint8_t flags, cleanup_list *cleanup) noexcept {
         // Disable implicit conversions
         return from_python_(src, flags & ~(uint8_t)cast_flags::convert, cleanup);
     }
@@ -399,37 +401,40 @@
     static constexpr bool DMapConstructorOwnsData =
         !Eigen::internal::traits<Ref>::template match<DMap>::type::value;
 
     static constexpr auto Name =
         const_name<MaybeConvert>(DMapCaster::Name, MapCaster::Name);
 
     template <typename T_> using Cast = Ref;
+    template <typename T_> static constexpr bool can_cast() { return true; }
 
     MapCaster caster;
     struct Empty { };
     std::conditional_t<MaybeConvert, DMapCaster, Empty> dcaster;
 
     bool from_python(handle src, uint8_t flags, cleanup_list *cleanup) noexcept {
         // Try a direct cast without implicit conversion first
         if (caster.from_python(src, flags, cleanup))
             return true;
 
         // Potentially convert strides/dtype when casting constant references
         if constexpr (MaybeConvert) {
             /* Generating an implicit copy requires some object to assume
                ownership. During a function call, ``dcaster`` can serve that
-               role (this case is detected by checking whether ``cleanup`` is
-               defined). When used in other situatons (e.g. ``nb::cast()``),
-               the created ``Eigen::Ref<..>`` must take ownership of the copy.
-               This is only guranteed to work if DMapConstructorOwnsData.
+               role (this case is detected by checking whether ``flags`` has
+               the ``manual`` flag set). When used in other situations (e.g.
+               ``nb::cast()``), the created ``Eigen::Ref<..>`` must take
+               ownership of the copy. This is only guranteed to work if
+               DMapConstructorOwnsData.
 
                If neither of these is possible, we disable implicit
                conversions. */
 
-            if (!cleanup && !DMapConstructorOwnsData)
+            if ((flags & (uint8_t) cast_flags::manual) &&
+                !DMapConstructorOwnsData)
                 flags &= ~(uint8_t) cast_flags::convert;
 
             if (dcaster.from_python_(src, flags, cleanup))
                 return true;
         }
 
         return false;
```

## nanobind/include/nanobind/eigen/sparse.h

```diff
@@ -35,16 +35,16 @@
     using SparseMap = Eigen::Map<T>;
 
     static_assert(std::is_same_v<T, Eigen::SparseMatrix<Scalar, T::Options, StorageIndex>>,
                   "nanobind: Eigen sparse caster only implemented for matrices");
 
     static constexpr bool RowMajor = T::IsRowMajor;
 
-    using ScalarNDArray = ndarray<numpy, Scalar, shape<any>>;
-    using StorageIndexNDArray = ndarray<numpy, StorageIndex, shape<any>>;
+    using ScalarNDArray = ndarray<numpy, Scalar, shape<-1>>;
+    using StorageIndexNDArray = ndarray<numpy, StorageIndex, shape<-1>>;
 
     using ScalarCaster = make_caster<ScalarNDArray>;
     using StorageIndexCaster = make_caster<StorageIndexNDArray>;
 
     NB_TYPE_CASTER(T, const_name<RowMajor>("scipy.sparse.csr_matrix[",
                                            "scipy.sparse.csc_matrix[")
                    + make_caster<Scalar>::Name + const_name("]"))
@@ -146,14 +146,15 @@
 /// Caster for Eigen::Map<Eigen::SparseMatrix>, still needs to be implemented.
 template <typename T>
 struct type_caster<Eigen::Map<T>, enable_if_t<is_eigen_sparse_matrix_v<T>>> {
     using Map = Eigen::Map<T>;
     using SparseMatrixCaster = type_caster<T>;
     static constexpr auto Name = SparseMatrixCaster::Name;
     template <typename T_> using Cast = Map;
+    template <typename T_> static constexpr bool can_cast() { return true; }
 
     bool from_python(handle src, uint8_t flags, cleanup_list *cleanup) noexcept = delete;
 
     static handle from_cpp(const Map &v, rv_policy policy, cleanup_list *cleanup) noexcept = delete;
 };
 
 
@@ -161,14 +162,15 @@
 template <typename T, int Options>
 struct type_caster<Eigen::Ref<T, Options>, enable_if_t<is_eigen_sparse_matrix_v<T>>> {
     using Ref = Eigen::Ref<T, Options>;
     using Map = Eigen::Map<T, Options>;
     using MapCaster = make_caster<Map>;
     static constexpr auto Name = MapCaster::Name;
     template <typename T_> using Cast = Ref;
+    template <typename T_> static constexpr bool can_cast() { return true; }
 
     bool from_python(handle src, uint8_t flags, cleanup_list *cleanup) noexcept = delete;
 
     static handle from_cpp(const Ref &v, rv_policy policy, cleanup_list *cleanup) noexcept = delete;
 };
 
 NAMESPACE_END(detail)
```

## nanobind/include/nanobind/stl/bind_map.h

```diff
@@ -11,20 +11,14 @@
 #include <nanobind/make_iterator.h>
 #include <nanobind/operators.h>
 #include <nanobind/stl/detail/traits.h>
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
-template <typename Key, typename Value> struct dict_type_id {
-    static constexpr auto Name =
-        const_name(NB_TYPING_DICT "[") + make_caster<Key>::Name +
-        const_name(", ") + make_caster<Value>::Name + const_name("]");
-};
-
 template <typename Map, typename Key, typename Value>
 inline void map_set(Map &m, const Key &k, const Value &v) {
     if constexpr (detail::is_copy_assignable_v<Value>) {
         m[k] = v;
     } else {
         auto r = m.emplace(k, v);
         if (!r.second) {
@@ -33,19 +27,31 @@
             m.emplace(k, v);
         }
     }
 }
 
 NAMESPACE_END(detail)
 
-template <typename Map, typename... Args>
+template <typename Map,
+          rv_policy Policy = rv_policy::automatic_reference,
+          typename... Args>
 class_<Map> bind_map(handle scope, const char *name, Args &&...args) {
     using Key = typename Map::key_type;
     using Value = typename Map::mapped_type;
 
+    using ValueRef = typename detail::iterator_value_access<typename Map::iterator>::result_type;
+
+    static_assert(
+        !detail::is_base_caster_v<detail::make_caster<Value>> ||
+        detail::is_copy_constructible_v<Value> ||
+        (Policy != rv_policy::automatic_reference &&
+         Policy != rv_policy::copy),
+        "bind_map(): the generated __getitem__ would copy elements, so the "
+        "value type must be copy-constructible");
+
     handle cl_cur = type<Map>();
     if (cl_cur.is_valid()) {
         // Binding already exists, don't re-create
         return borrow<class_<Map>>(cl_cur);
     }
 
     auto cl = class_<Map>(scope, name, std::forward<Args>(args)...)
@@ -67,48 +73,45 @@
              [](const Map &m, const Key &k) { return m.find(k) != m.end(); })
 
         .def("__contains__", // fallback for incompatible types
              [](const Map &, handle) { return false; })
 
         .def("__iter__",
              [](Map &m) {
-                 return make_key_iterator(type<Map>(), "KeyIterator",
-                                          m.begin(), m.end());
+                 return make_key_iterator<Policy>(type<Map>(), "KeyIterator",
+                                                  m.begin(), m.end());
              },
              keep_alive<0, 1>())
 
         .def("__getitem__",
-             [](Map &m, const Key &k) -> Value & {
+             [](Map &m, const Key &k) -> ValueRef {
                  auto it = m.find(k);
                  if (it == m.end())
                      throw key_error();
-                 return it->second;
-             },
-             rv_policy::reference_internal
-        )
+                 return (*it).second;
+             }, Policy)
 
         .def("__delitem__",
             [](Map &m, const Key &k) {
                 auto it = m.find(k);
                 if (it == m.end())
                     throw key_error();
                 m.erase(it);
-            }
-        )
+            })
 
         .def("clear", [](Map &m) { m.clear(); },
              "Remove all items");
 
 
     if constexpr (detail::is_copy_constructible_v<Map>) {
         cl.def(init<const Map &>(), "Copy constructor");
 
-        cl.def("__init__", [](Map *m, typed<dict, detail::dict_type_id<Key, Value>> &d) {
+        cl.def("__init__", [](Map *m, typed<dict, Key, Value> d) {
             new (m) Map();
-            for (auto [k, v] : d.value)
+            for (auto [k, v] : borrow<dict>(std::move(d)))
                 m->emplace(cast<Key>(k), cast<Value>(v));
         }, "Construct from a dictionary");
 
         implicitly_convertible<dict, Map>();
     }
 
     // Assignment operator for copy-assignable/copy-constructible types
@@ -135,36 +138,36 @@
     struct ValueView { Map &map; };
     struct ItemView  { Map &map; };
 
     class_<ItemView>(cl, "ItemView")
         .def("__len__", [](ItemView &v) { return v.map.size(); })
         .def("__iter__",
              [](ItemView &v) {
-                 return make_iterator(type<Map>(), "ItemIterator",
-                                      v.map.begin(), v.map.end());
+                 return make_iterator<Policy>(type<Map>(), "ItemIterator",
+                                              v.map.begin(), v.map.end());
              },
              keep_alive<0, 1>());
 
     class_<KeyView>(cl, "KeyView")
         .def("__contains__", [](KeyView &v, const Key &k) { return v.map.find(k) != v.map.end(); })
         .def("__contains__", [](KeyView &, handle) { return false; })
         .def("__len__", [](KeyView &v) { return v.map.size(); })
         .def("__iter__",
              [](KeyView &v) {
-                 return make_key_iterator(type<Map>(), "KeyIterator",
-                                          v.map.begin(), v.map.end());
+                 return make_key_iterator<Policy>(type<Map>(), "KeyIterator",
+                                                  v.map.begin(), v.map.end());
              },
              keep_alive<0, 1>());
 
     class_<ValueView>(cl, "ValueView")
         .def("__len__", [](ValueView &v) { return v.map.size(); })
         .def("__iter__",
              [](ValueView &v) {
-                 return make_value_iterator(type<Map>(), "ValueIterator",
-                                            v.map.begin(), v.map.end());
+                 return make_value_iterator<Policy>(type<Map>(), "ValueIterator",
+                                                    v.map.begin(), v.map.end());
              },
              keep_alive<0, 1>());
 
     cl.def("keys",   [](Map &m) { return new KeyView{m};   }, keep_alive<0, 1>(),
            "Returns an iterable view of the map's keys.");
     cl.def("values", [](Map &m) { return new ValueView{m}; }, keep_alive<0, 1>(),
            "Returns an iterable view of the map's values.");
```

## nanobind/include/nanobind/stl/bind_vector.h

```diff
@@ -30,28 +30,32 @@
 }
 
 template <> struct iterator_access<typename std::vector<bool>::iterator> {
     using result_type = bool;
     result_type operator()(typename std::vector<bool>::iterator &it) const { return *it; }
 };
 
-template <typename Value> struct iterable_type_id {
-    static constexpr auto Name = const_name("Iterable[") +
-                                 make_caster<Value>::Name +
-                                 const_name("]");
-};
-
 NAMESPACE_END(detail)
 
 
-template <typename Vector, typename... Args>
+template <typename Vector,
+          rv_policy Policy = rv_policy::automatic_reference,
+          typename... Args>
 class_<Vector> bind_vector(handle scope, const char *name, Args &&...args) {
     using ValueRef = typename detail::iterator_access<typename Vector::iterator>::result_type;
     using Value = std::decay_t<ValueRef>;
 
+    static_assert(
+        !detail::is_base_caster_v<detail::make_caster<Value>> ||
+        detail::is_copy_constructible_v<Value> ||
+        (Policy != rv_policy::automatic_reference &&
+         Policy != rv_policy::copy),
+        "bind_vector(): the generated __getitem__ would copy elements, so the "
+        "element type must be copy-constructible");
+
     handle cl_cur = type<Vector>();
     if (cl_cur.is_valid()) {
         // Binding already exists, don't re-create
         return borrow<class_<Vector>>(cl_cur);
     }
 
     auto cl = class_<Vector>(scope, name, std::forward<Args>(args)...)
@@ -66,35 +70,34 @@
         .def("__repr__",
              [](handle_t<Vector> h) {
                 return steal<str>(detail::repr_list(h.ptr()));
              })
 
         .def("__iter__",
              [](Vector &v) {
-                 return make_iterator(type<Vector>(), "Iterator",
-                                      v.begin(), v.end());
+                 return make_iterator<Policy>(type<Vector>(), "Iterator",
+                                              v.begin(), v.end());
              }, keep_alive<0, 1>())
 
         .def("__getitem__",
              [](Vector &v, Py_ssize_t i) -> ValueRef {
                  return v[detail::wrap(i, v.size())];
-             },
-             rv_policy::reference_internal)
+             }, Policy)
 
         .def("clear", [](Vector &v) { v.clear(); },
              "Remove all items from list.");
 
     if constexpr (detail::is_copy_constructible_v<Value>) {
         cl.def(init<const Vector &>(),
                "Copy constructor");
 
-        cl.def("__init__", [](Vector *v, typed<iterable, detail::iterable_type_id<Value>> &seq) {
+        cl.def("__init__", [](Vector *v, typed<iterable, Value> seq) {
             new (v) Vector();
-            v->reserve(len_hint(seq.value));
-            for (handle h : seq.value)
+            v->reserve(len_hint(seq));
+            for (handle h : seq)
                 v->push_back(cast<Value>(h));
         }, "Construct from an iterable object");
 
         implicitly_convertible<iterable, Vector>();
 
         cl.def("append",
                [](Vector &v, const Value &value) { v.push_back(value); },
```

## nanobind/include/nanobind/stl/complex.h

```diff
@@ -11,18 +11,14 @@
 
 #include <nanobind/nanobind.h>
 #include <complex>
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
-template <typename T> struct is_complex;
-template<typename T> struct is_complex<const T> : is_complex<T> {};
-template<typename T> struct is_complex<std::complex<T>> : std::true_type {};
-
 template <typename T> struct type_caster<std::complex<T>> {
     NB_TYPE_CASTER(std::complex<T>, const_name("complex"))
 
     template <bool Recursive = true>
     bool from_python(handle src, uint8_t flags,
                      cleanup_list *cleanup) noexcept {
         (void) flags;
@@ -51,15 +47,15 @@
 
         make_caster<T> caster;
         if (caster.from_python(src, flags, cleanup)) {
             value = std::complex<T>(caster.operator cast_t<T>());
             return true;
         }
 
-        return true;
+        return false;
     }
 
     template <typename T2>
     static handle from_cpp(T2 &&value, rv_policy policy,
                            cleanup_list *cleanup) noexcept {
         (void) policy;
         (void) cleanup;
```

## nanobind/include/nanobind/stl/filesystem.h

```diff
@@ -67,15 +67,19 @@
 
         if (!success)
             PyErr_Clear();
 
         return success;
     }
 
-    NB_TYPE_CASTER(std::filesystem::path, const_name("os.PathLike"))
+#if PY_VERSION_HEX < 0x03090000
+    NB_TYPE_CASTER(std::filesystem::path, io_name("typing.Union[str, os.PathLike]", "pathlib.Path"))
+#else
+    NB_TYPE_CASTER(std::filesystem::path, io_name("str | os.PathLike", "pathlib.Path"))
+#endif
 
 private:
     static str to_py_str(const std::string &s) {
         return steal<str>(
             PyUnicode_DecodeFSDefaultAndSize(s.c_str(), (Py_ssize_t) s.size()));
     }
```

## nanobind/include/nanobind/stl/function.h

```diff
@@ -46,15 +46,15 @@
 
 template <typename Return, typename... Args>
 struct type_caster<std::function<Return(Args...)>> {
     using ReturnCaster = make_caster<
         std::conditional_t<std::is_void_v<Return>, void_type, Return>>;
 
     NB_TYPE_CASTER(std::function <Return(Args...)>,
-                   const_name("Callable[[") +
+                   const_name(NB_TYPING_CALLABLE "[[") +
                        concat(make_caster<Args>::Name...) + const_name("], ") +
                        ReturnCaster::Name + const_name("]"))
 
     struct pyfunc_wrapper_t : pyfunc_wrapper {
         using pyfunc_wrapper::pyfunc_wrapper;
 
         Return operator()(Args... args) const {
```

## nanobind/include/nanobind/stl/optional.h

```diff
@@ -18,48 +18,40 @@
 template <typename T> struct remove_opt_mono<std::optional<T>>
     : remove_opt_mono<T> { };
 
 template <typename T>
 struct type_caster<std::optional<T>> {
     using Caster = make_caster<T>;
 
-    NB_TYPE_CASTER(std::optional<T>, const_name("Optional[") +
-                                         concat(Caster::Name) +
-                                         const_name("]"))
+    NB_TYPE_CASTER(std::optional<T>, optional_name(Caster::Name))
 
     type_caster() : value(std::nullopt) { }
 
     bool from_python(handle src, uint8_t flags, cleanup_list* cleanup) noexcept {
         if (src.is_none()) {
             value = std::nullopt;
             return true;
         }
 
         Caster caster;
-        if (!caster.from_python(src, flags, cleanup))
+        if (!caster.from_python(src, flags_for_local_caster<T>(flags), cleanup) ||
+            !caster.template can_cast<T>())
             return false;
 
-        static_assert(
-            !std::is_pointer_v<T> || is_base_caster_v<Caster>,
-            "Binding ``optional<T*>`` requires that ``T`` is handled "
-            "by nanobind's regular class binding mechanism. However, a "
-            "type caster was registered to intercept this particular "
-            "type, which is not allowed.");
-
         value.emplace(caster.operator cast_t<T>());
 
         return true;
     }
 
     template <typename T_>
     static handle from_cpp(T_ &&value, rv_policy policy, cleanup_list *cleanup) noexcept {
         if (!value)
             return none().release();
 
-        return Caster::from_cpp(forward_like<T_>(*value), policy, cleanup);
+        return Caster::from_cpp(forward_like_<T_>(*value), policy, cleanup);
     }
 };
 
 template <> struct type_caster<std::nullopt_t> {
     bool from_python(handle src, uint8_t, cleanup_list *) noexcept {
         if (src.is_none())
             return true;
```

## nanobind/include/nanobind/stl/pair.h

```diff
@@ -54,29 +54,34 @@
         return from_cpp(*value, policy, cleanup);
     }
 
     template <typename T>
     static handle from_cpp(T &&value, rv_policy policy,
                            cleanup_list *cleanup) noexcept {
         object o1 = steal(
-            Caster1::from_cpp(forward_like<T>(value.first), policy, cleanup));
+            Caster1::from_cpp(forward_like_<T>(value.first), policy, cleanup));
         if (!o1.is_valid())
             return {};
 
         object o2 = steal(
-            Caster2::from_cpp(forward_like<T>(value.second), policy, cleanup));
+            Caster2::from_cpp(forward_like_<T>(value.second), policy, cleanup));
         if (!o2.is_valid())
             return {};
 
         PyObject *r = PyTuple_New(2);
         NB_TUPLE_SET_ITEM(r, 0, o1.release().ptr());
         NB_TUPLE_SET_ITEM(r, 1, o2.release().ptr());
         return r;
     }
 
+    template <typename T>
+    bool can_cast() const noexcept {
+        return caster1.template can_cast<T1>() && caster2.template can_cast<T2>();
+    }
+
     /// Return the constructed tuple by copying from the sub-casters
     explicit operator Value() {
         return Value(caster1.operator cast_t<T1>(),
                      caster2.operator cast_t<T2>());
     }
 
     Caster1 caster1;
```

## nanobind/include/nanobind/stl/tuple.h

```diff
@@ -18,17 +18,18 @@
 template <typename... Ts> struct type_caster<std::tuple<Ts...>> {
     static constexpr size_t N  = sizeof...(Ts),
                             N1 = N > 0 ? N : 1;
 
     using Value = std::tuple<Ts...>;
     using Indices = std::make_index_sequence<N>;
 
-    static constexpr auto Name = const_name(NB_TYPING_TUPLE "[") +
-                                 concat(make_caster<Ts>::Name...) +
-                                 const_name("]");
+    static constexpr auto Name =
+        const_name(NB_TYPING_TUPLE "[") +
+        const_name<N == 0>(const_name("()"), concat(make_caster<Ts>::Name...)) +
+        const_name("]");
 
     /// This caster constructs instances on the fly (otherwise it would not be
     /// able to handle tuples containing references_). Because of this, only the
     /// `operator Value()` cast operator is implemented below, and the type
     /// alias below informs users of this class of this fact.
     template <typename T> using Cast = Value;
 
@@ -73,27 +74,34 @@
                                 std::index_sequence<Is...>) noexcept {
         (void) value; (void) policy; (void) cleanup;
         object o[N1];
 
         bool success =
             (... &&
              ((o[Is] = steal(make_caster<Ts>::from_cpp(
-                   forward_like<T>(std::get<Is>(value)), policy, cleanup))),
+                   forward_like_<T>(std::get<Is>(value)), policy, cleanup))),
               o[Is].is_valid()));
 
         if (!success)
             return handle();
 
         PyObject *r = PyTuple_New(N);
         (NB_TUPLE_SET_ITEM(r, Is, o[Is].release().ptr()), ...);
         return r;
     }
 
+    template <typename T>
+    bool can_cast() const noexcept { return can_cast_impl(Indices{}); }
+
     explicit operator Value() { return cast_impl(Indices{}); }
 
+    template <size_t... Is>
+    bool can_cast_impl(std::index_sequence<Is...>) const noexcept {
+        return (std::get<Is>(casters).template can_cast<Ts>() && ...);
+    }
     template <size_t... Is> Value cast_impl(std::index_sequence<Is...>) {
         return Value(std::get<Is>(casters).operator cast_t<Ts>()...);
     }
 
     std::tuple<make_caster<Ts>...> casters;
 };
```

## nanobind/include/nanobind/stl/unique_ptr.h

```diff
@@ -67,14 +67,32 @@
 
     static constexpr auto Name = Caster::Name;
     template <typename T_> using Cast = Value;
 
     Caster caster;
     handle src;
 
+    /* If true, the Python object has relinquished ownership but we have
+       not yet yielded a unique_ptr that holds ownership on the C++ side.
+
+       `nb_type_relinquish_ownership()` can fail, so we must check it in
+       `can_cast()`. If we do so, but then wind up not executing the cast
+       operator, we must remember to undo our relinquishment and push the
+       ownership back onto the Python side. For example, this might be
+       necessary if the Python object `[(foo, foo)]` is converted to
+       `std::vector<std::pair<std::unique_ptr<T>, std::unique_ptr<T>>>`;
+       the pair caster won't know that it can't cast the second element
+       until after it's verified that it can cast the first one. */
+    mutable bool inflight = false;
+
+    ~type_caster() {
+        if (inflight)
+            nb_type_restore_ownership(src.ptr(), IsDefaultDeleter);
+    }
+
     bool from_python(handle src_, uint8_t, cleanup_list *) noexcept {
         // Stash source python object
         src = src_;
 
         /* Try casting to a pointer of the underlying type. We pass flags=0 and
            cleanup=nullptr to prevent implicit type conversions (they are
            problematic since the instance then wouldn't be owned by 'src') */
@@ -96,14 +114,16 @@
 
         bool cpp_delete = true;
         if constexpr (IsNanobindDeleter)
             cpp_delete = value.get_deleter().owned_by_cpp();
 
         T *ptr = value.get();
         const std::type_info *type = &typeid(T);
+        if (!ptr)
+            return none().release();
 
         constexpr bool has_type_hook =
             !std::is_base_of_v<std::false_type, type_hook<T>>;
         if constexpr (has_type_hook)
             type = type_hook<T>::get(ptr);
 
         handle result;
@@ -122,20 +142,36 @@
             else
                 value.reset();
         }
 
         return result;
     }
 
+    template <typename T_>
+    bool can_cast() const noexcept {
+        if (src.is_none() || inflight)
+            return true;
+        else if (!nb_type_relinquish_ownership(src.ptr(), IsDefaultDeleter))
+            return false;
+        inflight = true;
+        return true;
+    }
+
     explicit operator Value() {
-        nb_type_relinquish_ownership(src.ptr(), IsDefaultDeleter);
+        if (!inflight && !src.is_none() &&
+            !nb_type_relinquish_ownership(src.ptr(), IsDefaultDeleter))
+            throw next_overload();
+
+        T *p = caster.operator T *();
 
-        T *value = caster.operator T *();
+        Value value;
         if constexpr (IsNanobindDeleter)
-            return Value(value, deleter<T>(src.inc_ref()));
+            value = Value(p, deleter<T>(src.inc_ref()));
         else
-            return Value(value);
+            value = Value(p);
+        inflight = false;
+        return value;
     }
 };
 
 NAMESPACE_END(detail)
 NAMESPACE_END(NB_NAMESPACE)
```

## nanobind/include/nanobind/stl/variant.h

```diff
@@ -18,15 +18,15 @@
 template <typename T, typename...>
 struct concat_variant { using type = T; };
 template <typename... Ts1, typename... Ts2, typename... Ts3>
 struct concat_variant<std::variant<Ts1...>, std::variant<Ts2...>, Ts3...>
     : concat_variant<std::variant<Ts1..., Ts2...>, Ts3...> {};
 
 template <typename... Ts> struct remove_opt_mono<std::variant<Ts...>>
-    : concat_variant<std::conditional_t<std::is_same_v<std::monostate, Ts>, std::variant<>, std::variant<Ts>>...> {};
+    : concat_variant<std::conditional_t<std::is_same_v<std::monostate, Ts>, std::variant<>, std::variant<remove_opt_mono_t<Ts>>>...> {};
 
 template <> struct type_caster<std::monostate> {
     NB_TYPE_CASTER(std::monostate, const_name("None"))
 
     bool from_python(handle src, uint8_t, cleanup_list *) noexcept {
         return src.is_none();
     }
@@ -34,34 +34,24 @@
     static handle from_cpp(const std::monostate &, rv_policy,
                            cleanup_list *) noexcept {
         return none().release();
     }
 };
 
 template <typename... Ts> struct type_caster<std::variant<Ts...>> {
-    NB_TYPE_CASTER(std::variant<Ts...>,
-        const_name("Union[") + concat(make_caster<Ts>::Name...) + const_name("]"))
+    NB_TYPE_CASTER(std::variant<Ts...>, union_name(make_caster<Ts>::Name...))
 
     template <typename T>
     bool try_variant(const handle &src, uint8_t flags, cleanup_list *cleanup) {
         using CasterT = make_caster<T>;
 
-        static_assert(
-            !std::is_pointer_v<T> || is_base_caster_v<CasterT>,
-            "Binding ``variant<T*, ...>`` requires that ``T`` is handled "
-            "by nanobind's regular class binding mechanism. However, a "
-            "type caster was registered to intercept this particular "
-            "type, which is not allowed.");
-
-        if constexpr (is_base_caster_v<CasterT> && !std::is_pointer_v<T>)
-            flags |= (uint8_t) cast_flags::none_disallowed;
-
         CasterT caster;
 
-        if (!caster.from_python(src, flags, cleanup))
+        if (!caster.from_python(src, flags_for_local_caster<T>(flags), cleanup) ||
+            !caster.template can_cast<T>())
             return false;
 
         value = caster.operator cast_t<T>();
 
         return true;
     }
```

## nanobind/include/nanobind/stl/detail/nb_array.h

```diff
@@ -2,34 +2,35 @@
 
 #include <nanobind/nanobind.h>
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
 template <typename Array, typename Entry, size_t Size> struct array_caster {
-    NB_TYPE_CASTER(Array, const_name(NB_TYPING_LIST "[") +
-                               make_caster<Entry>::Name + const_name("]"))
+    NB_TYPE_CASTER(Array, io_name(NB_TYPING_SEQUENCE, NB_TYPING_LIST) +
+                              const_name("[") + make_caster<Entry>::Name +
+                              const_name("]"))
 
     using Caster = make_caster<Entry>;
 
     bool from_python(handle src, uint8_t flags, cleanup_list *cleanup) noexcept {
         PyObject *temp;
 
         /* Will initialize 'temp' (NULL in the case of a failure.) */
         PyObject **o = seq_get_with_size(src.ptr(), Size, &temp);
 
         Caster caster;
         bool success = o != nullptr;
 
-        if constexpr (is_base_caster_v<Caster> && !std::is_pointer_v<Entry>)
-            flags |= (uint8_t) cast_flags::none_disallowed;
+        flags = flags_for_local_caster<Entry>(flags);
 
         if (success) {
             for (size_t i = 0; i < Size; ++i) {
-                if (!caster.from_python(o[i], flags, cleanup)) {
+                if (!caster.from_python(o[i], flags, cleanup) ||
+                    !caster.template can_cast<Entry>()) {
                     success = false;
                     break;
                 }
 
                 value[i] = caster.operator cast_t<Entry>();
             }
 
@@ -43,15 +44,15 @@
     static handle from_cpp(T &&src, rv_policy policy, cleanup_list *cleanup) {
         object ret = steal(PyList_New(Size));
 
         if (ret.is_valid()) {
             Py_ssize_t index = 0;
 
             for (auto &value : src) {
-                handle h = Caster::from_cpp(forward_like<T>(value), policy, cleanup);
+                handle h = Caster::from_cpp(forward_like_<T>(value), policy, cleanup);
 
                 if (!h.is_valid()) {
                     ret.reset();
                     break;
                 }
 
                 NB_LIST_SET_ITEM(ret.ptr(), index++, h.ptr());
```

## nanobind/include/nanobind/stl/detail/nb_dict.h

```diff
@@ -11,17 +11,18 @@
 
 #include <nanobind/nanobind.h>
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
 template <typename Dict, typename Key, typename Val> struct dict_caster {
-    NB_TYPE_CASTER(Dict, const_name(NB_TYPING_DICT "[") + make_caster<Key>::Name +
-                               const_name(", ") + make_caster<Val>::Name +
-                               const_name("]"))
+    NB_TYPE_CASTER(Dict, io_name(NB_TYPING_MAPPING, NB_TYPING_DICT) +
+                             const_name("[") + make_caster<Key>::Name +
+                             const_name(", ") + make_caster<Val>::Name +
+                             const_name("]"))
 
     using KeyCaster = make_caster<Key>;
     using ValCaster = make_caster<Val>;
 
     bool from_python(handle src, uint8_t flags, cleanup_list *cleanup) noexcept {
         value.clear();
 
@@ -30,34 +31,32 @@
             PyErr_Clear();
             return false;
         }
 
         Py_ssize_t size = NB_LIST_GET_SIZE(items);
         bool success = size >= 0;
 
-        uint8_t flags_key = flags, flags_val = flags;
-
-        if constexpr (is_base_caster_v<KeyCaster> && !std::is_pointer_v<Key>)
-            flags_key |= (uint8_t) cast_flags::none_disallowed;
-        if constexpr (is_base_caster_v<ValCaster> && !std::is_pointer_v<Val>)
-            flags_val |= (uint8_t) cast_flags::none_disallowed;
+        uint8_t flags_key = flags_for_local_caster<Key>(flags),
+                flags_val = flags_for_local_caster<Val>(flags);
 
         KeyCaster key_caster;
         ValCaster val_caster;
         for (Py_ssize_t i = 0; i < size; ++i) {
             PyObject *item = NB_LIST_GET_ITEM(items, i);
             PyObject *key = NB_TUPLE_GET_ITEM(item, 0);
             PyObject *val = NB_TUPLE_GET_ITEM(item, 1);
 
-            if (!key_caster.from_python(key, flags_key, cleanup)) {
+            if (!key_caster.from_python(key, flags_key, cleanup) ||
+                !key_caster.template can_cast<Key>()) {
                 success = false;
                 break;
             }
 
-            if (!val_caster.from_python(val, flags_val, cleanup)) {
+            if (!val_caster.from_python(val, flags_val, cleanup) ||
+                !val_caster.template can_cast<Val>()) {
                 success = false;
                 break;
             }
 
             value.emplace(key_caster.operator cast_t<Key>(),
                           val_caster.operator cast_t<Val>());
         }
@@ -70,17 +69,17 @@
     template <typename T>
     static handle from_cpp(T &&src, rv_policy policy, cleanup_list *cleanup) {
         dict ret;
 
         if (ret.is_valid()) {
             for (auto &item : src) {
                 object k = steal(KeyCaster::from_cpp(
-                    forward_like<T>(item.first), policy, cleanup));
+                    forward_like_<T>(item.first), policy, cleanup));
                 object e = steal(ValCaster::from_cpp(
-                    forward_like<T>(item.second), policy, cleanup));
+                    forward_like_<T>(item.second), policy, cleanup));
 
                 if (!k.is_valid() || !e.is_valid() ||
                     PyDict_SetItem(ret.ptr(), k.ptr(), e.ptr()) != 0) {
                     ret.reset();
                     break;
                 }
             }
```

## nanobind/include/nanobind/stl/detail/nb_list.h

```diff
@@ -11,16 +11,17 @@
 
 #include <nanobind/nanobind.h>
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
 template <typename List, typename Entry> struct list_caster {
-    NB_TYPE_CASTER(List, const_name(NB_TYPING_LIST "[") +
-                               make_caster<Entry>::Name + const_name("]"))
+    NB_TYPE_CASTER(List, io_name(NB_TYPING_SEQUENCE, NB_TYPING_LIST) +
+                              const_name("[") + make_caster<Entry>::Name +
+                              const_name("]"))
 
     using Caster = make_caster<Entry>;
 
     template <typename T> using has_reserve = decltype(std::declval<T>().reserve(0));
 
     bool from_python(handle src, uint8_t flags, cleanup_list *cleanup) noexcept {
         size_t size;
@@ -34,19 +35,19 @@
 
         if constexpr (is_detected_v<has_reserve, List>)
             value.reserve(size);
 
         Caster caster;
         bool success = o != nullptr;
 
-        if constexpr (is_base_caster_v<Caster> && !std::is_pointer_v<Entry>)
-            flags |= (uint8_t) cast_flags::none_disallowed;
+        flags = flags_for_local_caster<Entry>(flags);
 
         for (size_t i = 0; i < size; ++i) {
-            if (!caster.from_python(o[i], flags, cleanup)) {
+            if (!caster.from_python(o[i], flags, cleanup) ||
+                !caster.template can_cast<Entry>()) {
                 success = false;
                 break;
             }
 
             value.push_back(caster.operator cast_t<Entry>());
         }
 
@@ -59,15 +60,15 @@
     static handle from_cpp(T &&src, rv_policy policy, cleanup_list *cleanup) {
         object ret = steal(PyList_New(src.size()));
 
         if (ret.is_valid()) {
             Py_ssize_t index = 0;
 
             for (auto &&value : src) {
-                handle h = Caster::from_cpp(forward_like<T>(value), policy, cleanup);
+                handle h = Caster::from_cpp(forward_like_<T>(value), policy, cleanup);
 
                 if (!h.is_valid()) {
                     ret.reset();
                     break;
                 }
 
                 NB_LIST_SET_ITEM(ret.ptr(), index++, h.ptr());
```

## nanobind/include/nanobind/stl/detail/nb_set.h

```diff
@@ -11,15 +11,17 @@
 
 #include <nanobind/nanobind.h>
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
 template <typename Set, typename Key> struct set_caster {
-    NB_TYPE_CASTER(Set, const_name(NB_TYPING_SET "[") + make_caster<Key>::Name + const_name("]"))
+    NB_TYPE_CASTER(Set, io_name(NB_TYPING_ABSTRACT_SET, NB_TYPING_SET) +
+                            const_name("[") + make_caster<Key>::Name +
+                            const_name("]"))
 
     using Caster = make_caster<Key>;
 
     bool from_python(handle src, uint8_t flags, cleanup_list *cleanup) noexcept {
         value.clear();
 
         PyObject* iter = obj_iter(src.ptr());
@@ -28,19 +30,19 @@
             return false;
         }
 
         bool success = true;
         Caster key_caster;
         PyObject *key;
 
-        if constexpr (is_base_caster_v<Caster> && !std::is_pointer_v<Key>)
-            flags |= (uint8_t) cast_flags::none_disallowed;
+        flags = flags_for_local_caster<Key>(flags);
 
         while ((key = PyIter_Next(iter)) != nullptr) {
-            success &= key_caster.from_python(key, flags, cleanup);
+            success &= (key_caster.from_python(key, flags, cleanup) &&
+                        key_caster.template can_cast<Key>());
             Py_DECREF(key);
 
             if (!success)
                 break;
 
             value.emplace(key_caster.operator cast_t<Key>());
         }
@@ -58,15 +60,15 @@
     template <typename T>
     static handle from_cpp(T &&src, rv_policy policy, cleanup_list *cleanup) {
         object ret = steal(PySet_New(nullptr));
 
         if (ret.is_valid()) {
             for (auto& key : src) {
                 object k = steal(
-                    Caster::from_cpp(forward_like<T>(key), policy, cleanup));
+                    Caster::from_cpp(forward_like_<T>(key), policy, cleanup));
 
                 if (!k.is_valid() || PySet_Add(ret.ptr(), k.ptr()) != 0) {
                     ret.reset();
                     break;
                 }
             }
         }
```

## nanobind/src/common.cpp

```diff
@@ -150,14 +150,21 @@
 PyObject *module_import(const char *name) {
     PyObject *res = PyImport_ImportModule(name);
     if (!res)
         throw python_error();
     return res;
 }
 
+PyObject *module_import(PyObject *o) {
+    PyObject *res = PyImport_Import(o);
+    if (!res)
+        throw python_error();
+    return res;
+}
+
 PyObject *module_new_submodule(PyObject *base, const char *name,
                                const char *doc) noexcept {
     PyObject *name_py, *res;
 
 #if !defined(PYPY_VERSION)
     PyObject *base_name = PyModule_GetNameObject(base);
     if (!base_name)
@@ -557,22 +564,22 @@
         raise_python_error();
     return result;
 }
 
 PyObject *bytes_from_cstr(const char *str) {
     PyObject *result = PyBytes_FromString(str);
     if (!result)
-        raise("nanobind::detail::bytes_from_cstr(): conversion error!");
+        raise_python_error();
     return result;
 }
 
-PyObject *bytes_from_cstr_and_size(const char *str, size_t size) {
-    PyObject *result = PyBytes_FromStringAndSize(str, (Py_ssize_t) size);
+PyObject *bytes_from_cstr_and_size(const void *str, size_t size) {
+    PyObject *result = PyBytes_FromStringAndSize((const char *) str, (Py_ssize_t) size);
     if (!result)
-        raise("nanobind::detail::bytes_from_cstr_and_size(): conversion error!");
+        raise_python_error();
     return result;
 }
 
 // ========================================================================
 
 PyObject *bool_from_obj(PyObject *o) {
     int rv = PyObject_IsTrue(o);
@@ -607,14 +614,21 @@
 PyObject *list_from_obj(PyObject *o) {
     PyObject *result = PySequence_List(o);
     if (!result)
         raise_python_error();
     return result;
 }
 
+PyObject *set_from_obj(PyObject *o) {
+    PyObject *result = PySet_New(o);
+    if (!result)
+        raise_python_error();
+    return result;
+}
+
 // ========================================================================
 
 PyObject **seq_get(PyObject *seq, size_t *size_out, PyObject **temp_out) noexcept {
     PyObject *temp = nullptr;
     size_t size = 0;
     PyObject **result = nullptr;
 
@@ -1113,9 +1127,18 @@
         s += repr(kv[0]) + str(": ") + repr(kv[1]);
         first = false;
     }
     s += str("})");
     return s.release().ptr();
 }
 
+// ========================================================================
+
+bool issubclass(PyObject *a, PyObject *b) {
+    int rv = PyObject_IsSubclass(a, b);
+    if (rv == -1)
+        raise_python_error();
+    return bool(rv);
+}
+
 NAMESPACE_END(detail)
 NAMESPACE_END(NB_NAMESPACE)
```

## nanobind/src/implicit.cpp

```diff
@@ -18,54 +18,54 @@
     type_data *t = nb_type_c2p(internals, dst);
     check(t, "nanobind::detail::implicitly_convertible(src=%s, dst=%s): "
              "destination type unknown!", type_name(src), type_name(dst));
 
     size_t size = 0;
 
     if (t->flags & (uint32_t) type_flags::has_implicit_conversions) {
-        while (t->implicit && t->implicit[size])
+        while (t->implicit.cpp && t->implicit.cpp[size])
             size++;
     } else {
-        t->implicit = nullptr;
-        t->implicit_py = nullptr;
+        t->implicit.cpp = nullptr;
+        t->implicit.py = nullptr;
         t->flags |= (uint32_t) type_flags::has_implicit_conversions;
     }
 
     void **data = (void **) malloc(sizeof(void *) * (size + 2));
 
     if (size)
-        memcpy(data, t->implicit, size * sizeof(void *));
+        memcpy(data, t->implicit.cpp, size * sizeof(void *));
     data[size] = (void *) src;
     data[size + 1] = nullptr;
-    free(t->implicit);
-    t->implicit = (decltype(t->implicit)) data;
+    free(t->implicit.cpp);
+    t->implicit.cpp = (decltype(t->implicit.cpp)) data;
 }
 
 void implicitly_convertible(bool (*predicate)(PyTypeObject *, PyObject *,
                                               cleanup_list *),
                             const std::type_info *dst) noexcept {
     type_data *t = nb_type_c2p(internals, dst);
     check(t, "nanobind::detail::implicitly_convertible(src=<predicate>, dst=%s): "
              "destination type unknown!", type_name(dst));
 
     size_t size = 0;
 
     if (t->flags & (uint32_t) type_flags::has_implicit_conversions) {
-        while (t->implicit_py && t->implicit_py[size])
+        while (t->implicit.py && t->implicit.py[size])
             size++;
     } else {
-        t->implicit = nullptr;
-        t->implicit_py = nullptr;
+        t->implicit.cpp = nullptr;
+        t->implicit.py = nullptr;
         t->flags |= (uint32_t) type_flags::has_implicit_conversions;
     }
 
     void **data = (void **) malloc(sizeof(void *) * (size + 2));
     if (size)
-        memcpy(data, t->implicit_py, size * sizeof(void *));
+        memcpy(data, t->implicit.py, size * sizeof(void *));
     data[size] = (void *) predicate;
     data[size + 1] = nullptr;
-    free(t->implicit_py);
-    t->implicit_py = (decltype(t->implicit_py)) data;
+    free(t->implicit.py);
+    t->implicit.py = (decltype(t->implicit.py)) data;
 }
 
 NAMESPACE_END(detail)
 NAMESPACE_END(NB_NAMESPACE)
```

## nanobind/src/nb_enum.cpp

```diff
@@ -1,418 +1,224 @@
-/*
-    src/nb_enum.cpp: nanobind enumeration type
-
-    Copyright (c) 2022 Wenzel Jakob
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#include <nanobind/nanobind.h>
 #include "nb_internals.h"
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
-NB_INLINE enum_supplement &nb_enum_supplement(PyTypeObject *type) {
-    return type_supplement<enum_supplement>(type);
-}
-
-static PyObject *nb_enum_int_signed(PyObject *o);
-static PyObject *nb_enum_int_unsigned(PyObject *o);
-
-/// Map to unique representative enum instance, returns a borrowed reference
-static PyObject *nb_enum_lookup(PyObject *self) {
-    enum_supplement &supp = nb_enum_supplement(Py_TYPE(self));
-    PyObject *int_val = supp.is_signed ? nb_enum_int_signed(self)
-                                       : nb_enum_int_unsigned(self);
-    PyObject *rec = nullptr;
-    if (int_val && supp.entries)
-        rec = (PyObject *) PyDict_GetItem(supp.entries, int_val);
-
-    Py_XDECREF(int_val);
-
-    if (rec && PyTuple_CheckExact(rec) && NB_TUPLE_GET_SIZE(rec) == 3) {
-        return rec;
-    } else {
-        PyErr_Clear();
-        PyErr_SetString(PyExc_RuntimeError, "nb_enum: could not find entry!");
-        return nullptr;
+struct int64_hash {
+    size_t operator()(const int64_t value) const {
+        return (size_t) fmix64((uint64_t) value);
     }
-}
-
-static PyObject *nb_enum_repr(PyObject *self) {
-    PyObject *entry = nb_enum_lookup(self);
-    if (!entry)
-        return nullptr;
-
-    PyObject *name = nb_inst_name(self);
-    PyObject *result =
-        PyUnicode_FromFormat("%U.%U", name, NB_TUPLE_GET_ITEM(entry, 0));
-    Py_DECREF(name);
-
-    return result;
-}
-
-static PyObject *nb_enum_get_name(PyObject *self, void *) {
-    PyObject *entry = nb_enum_lookup(self);
-    if (!entry)
-        return nullptr;
-
-    PyObject *result = NB_TUPLE_GET_ITEM(entry, 0);
-    Py_INCREF(result);
-    return result;
-}
-
-static PyObject *nb_enum_get_doc(PyObject *self, void *) {
-    PyObject *entry = nb_enum_lookup(self);
-    if (!entry)
-        return nullptr;
-
-    PyObject *result = NB_TUPLE_GET_ITEM(entry, 1);
-    Py_INCREF(result);
-    return result;
-}
+};
 
-NB_NOINLINE static PyObject *nb_enum_int_signed(PyObject *o) {
-    type_data *t = nb_type_data(Py_TYPE(o));
-    const void *p = inst_ptr((nb_inst *) o);
-    long long value;
-    switch (t->size) {
-        case 1: value = (long long) *(const int8_t *)  p; break;
-        case 2: value = (long long) *(const int16_t *) p; break;
-        case 4: value = (long long) *(const int32_t *) p; break;
-        case 8: value = (long long) *(const int64_t *) p; break;
-        default: PyErr_SetString(PyExc_TypeError, "nb_enum: invalid type size!");
-                 return nullptr;
-    }
-    return PyLong_FromLongLong(value);
-}
+// This data structure is used to map Python instances to integers as well as
+// the inverse. We're reusing the type to avoid generating essentially the same
+// code for two template instantiations. The key/value types are big enough to
+// hold both.
+using enum_map = tsl::robin_map<int64_t, int64_t, int64_hash>;
 
-NB_NOINLINE static PyObject *nb_enum_int_unsigned(PyObject *o) {
-    type_data *t = nb_type_data(Py_TYPE(o));
-    const void *p = inst_ptr((nb_inst *) o);
-    unsigned long long value;
-    switch (t->size) {
-        case 1: value = (unsigned long long) *(const uint8_t *)  p; break;
-        case 2: value = (unsigned long long) *(const uint16_t *) p; break;
-        case 4: value = (unsigned long long) *(const uint32_t *) p; break;
-        case 8: value = (unsigned long long) *(const uint64_t *) p; break;
-        default: PyErr_SetString(PyExc_TypeError, "nb_enum: invalid type size!");
-                 return nullptr;
+PyObject *enum_create(enum_init_data *ed) noexcept {
+    // Update hash table that maps from std::type_info to Python type
+    auto [it, success] = internals->type_c2p_slow.try_emplace(ed->type, nullptr);
+    if (!success) {
+        PyErr_WarnFormat(PyExc_RuntimeWarning, 1, "nanobind: type '%s' was already registered!\n", ed->name);
+        PyObject *tp = (PyObject *) it->second->type_py;
+        Py_INCREF(tp);
+        return tp;
     }
-    return PyLong_FromUnsignedLongLong(value);
-}
-
-static PyObject *nb_enum_init(PyObject *, PyObject *, PyObject *) {
-    return 0;
-}
-
-static PyObject *nb_enum_new(PyTypeObject *subtype, PyObject *args, PyObject *kwds) {
-    PyObject *arg;
 
-    if (kwds || NB_TUPLE_GET_SIZE(args) != 1)
-        goto error;
-
-    arg = NB_TUPLE_GET_ITEM(args, 0);
-    if (PyLong_Check(arg)) {
-        enum_supplement &supp = nb_enum_supplement(subtype);
-        if (!supp.entries)
-            goto error;
-
-        PyObject *item = PyDict_GetItem(supp.entries, arg);
-        if (item && PyTuple_CheckExact(item) && NB_TUPLE_GET_SIZE(item) == 3) {
-            item = NB_TUPLE_GET_ITEM(item, 2);
-            Py_INCREF(item);
-            return item;
-        }
-    } else if (Py_TYPE(arg) == subtype) {
-        Py_INCREF(arg);
-        return arg;
-    }
+    handle scope(ed->scope);
 
-error:
-    PyErr_Clear();
-    PyErr_Format(PyExc_RuntimeError,
-                 "%s(): could not convert the input into an enumeration value!",
-                 nb_type_data(subtype)->name);
-    return nullptr;
-}
+    bool is_arithmetic = ed->flags & (uint32_t) type_flags::is_arithmetic;
 
-static PyGetSetDef nb_enum_getset[] = {
-    { "__doc__", nb_enum_get_doc, nullptr, nullptr, nullptr },
-    { "__name__", nb_enum_get_name, nullptr, nullptr, nullptr },
-    { nullptr, nullptr, nullptr, nullptr, nullptr }
-};
+    str name(ed->name), qualname = name;
+    object modname;
 
-PyObject *nb_enum_richcompare(PyObject *a, PyObject *b, int op) {
-    // SomeType.tp_richcompare(a, b, op) is always invoked with 'a'
-    // having type SomeType. Note that this is different than binary
-    // arithmetic operations because comparisons can be reversed;
-    // Python will ask type(a) to check 'a > b' if type(b) doesn't
-    // know how to check 'b < a'.
-
-    if (op == Py_EQ || op == Py_NE) {
-        // For equality/inequality comparisons, only allow enums to be
-        // equal with their same enum type or with their underlying
-        // value as an integer.  This is a little awkward (it breaks
-        // transitivity of equality) but it's better than allowing
-        // 'Shape.CIRCLE == Color.RED' to be true just because both
-        // enumerators have the same underlying value (which would
-        // also prevent putting both enumerators in the same set or as
-        // keys in the same dictionary).
-        if (Py_TYPE(a) != Py_TYPE(b) && !PyLong_Check(b)) {
-            Py_RETURN_NOTIMPLEMENTED;
-        }
+    if (PyModule_Check(ed->scope)) {
+        modname = getattr(scope, "__name__", handle());
     } else {
-        // For ordering, allow comparison against any number,
-        // including floats. Note that enums count as a number for
-        // purposes of this check (it's anything that defines a __float__,
-        // __int__, or __index__ slot).
-        if (!PyNumber_Check(b)) {
-            Py_RETURN_NOTIMPLEMENTED;
-        }
-    }
+        modname = getattr(scope, "__module__", handle());
 
-    PyObject *ia = PyNumber_Index(a); // must succeed since a is an enum
-    PyObject *ib = nullptr;
-    if (PyIndex_Check(b)) {
-        // If b can be converted losslessly to an integer (which includes
-        // the case where b is also an enum) then do that.
-        ib = PyNumber_Index(b);
-    } else {
-        // Otherwise do the comparison against b as-is, which will probably
-        // wind up calling b's tp_richcompare for the reversed operation.
-        ib = b;
-        Py_INCREF(ib);
-    }
-    PyObject *result = nullptr;
-    if (ia && ib) {
-        result = PyObject_RichCompare(ia, ib, op);
+        object scope_qualname = getattr(scope, "__qualname__", handle());
+        if (scope_qualname.is_valid())
+            qualname = steal<str>(
+                PyUnicode_FromFormat("%U.%U", scope_qualname.ptr(), name.ptr()));
     }
-    Py_XDECREF(ia);
-    Py_XDECREF(ib);
-    return result;
-}
 
-// Unary operands are easy because we know the argument will be this enum type
-#define NB_ENUM_UNOP(name, op)                                                 \
-    PyObject *nb_enum_##name(PyObject *a) {                                    \
-        PyObject *ia = PyNumber_Index(a);                                      \
-        if (!ia)                                                               \
-            return nullptr;                                                    \
-        PyObject *result = op(ia);                                             \
-        Py_DECREF(ia);                                                         \
-        return result;                                                         \
-    }
+    const char *factory_name = is_arithmetic ? "IntEnum" : "Enum";
 
-// Binary operands are trickier due to the potential for reversed operations.
-// We know either a or b is an enum object, but not which one.
-NB_NOINLINE PyObject *nb_enum_binop(PyObject *a, PyObject *b,
-                                    PyObject* (*op)(PyObject*, PyObject*)) {
-    // Both operands should be numbers. (Enums count as numbers because they
-    // define nb_int and nb_index slots.)
-    if (!PyNumber_Check(a) || !PyNumber_Check(b)) {
-        Py_RETURN_NOTIMPLEMENTED;
-    }
+    object enum_mod = module_::import_("enum"),
+           factory = enum_mod.attr(factory_name),
+           result = factory(name, nanobind::tuple(),
+                            arg("module") = modname,
+                            arg("qualname") = qualname);
 
-    // Convert operands that support __index__ (lossless integer conversion),
-    // including enums, to that integer. Leave other kinds of numbers (such
-    // as floats and Decimals) alone. Then repeat the operation.
-    // Note that we can assume at least one of the PyNumber_Index calls
-    // succeeds, since one of our arguments is an enum.
-    PyObject *ia = nullptr, *ib = nullptr, *result = nullptr;
-    if (PyIndex_Check(a)) {
-        ia = PyNumber_Index(a);
-    } else {
-        ia = a;
-        Py_INCREF(ia);
-    }
-    if (PyIndex_Check(b)) {
-        ib = PyNumber_Index(b);
-    } else {
-        ib = b;
-        Py_INCREF(ib);
-    }
-    if (ia == a && ib == b) {
-        PyErr_SetString(PyExc_SystemError,
-                        "nanobind enum arithmetic invoked without an enum "
-                        "as either operand");
-    } else if (ia && ib) {
-        result = op(ia, ib);
-    }
-    Py_XDECREF(ia);
-    Py_XDECREF(ib);
-    return result;
-}
+    scope.attr(name) = result;
+    result.attr("__doc__") = ed->docstr ? str(ed->docstr) : none();
 
-#define NB_ENUM_BINOP(name, op)                                                \
-    PyObject *nb_enum_##name(PyObject *a, PyObject *b) {                       \
-        return nb_enum_binop(a, b, op);                                        \
-    }
+    if (is_arithmetic)
+        result.attr("__str__") = enum_mod.attr("Enum").attr("__str__");
 
-NB_ENUM_BINOP(add, PyNumber_Add)
-NB_ENUM_BINOP(sub, PyNumber_Subtract)
-NB_ENUM_BINOP(mul, PyNumber_Multiply)
-NB_ENUM_BINOP(div, PyNumber_FloorDivide)
-NB_ENUM_BINOP(and, PyNumber_And)
-NB_ENUM_BINOP(or, PyNumber_Or)
-NB_ENUM_BINOP(xor, PyNumber_Xor)
-NB_ENUM_BINOP(lshift, PyNumber_Lshift)
-NB_ENUM_BINOP(rshift, PyNumber_Rshift)
-NB_ENUM_UNOP(neg, PyNumber_Negative)
-NB_ENUM_UNOP(inv, PyNumber_Invert)
-NB_ENUM_UNOP(abs, PyNumber_Absolute)
+    result.attr("__repr__") = result.attr("__str__");
 
-int nb_enum_clear(PyObject *) {
-    return 0;
-}
+    type_init_data *t = new type_init_data();
+    memset(t, 0, sizeof(type_data));
+    t->name = strdup_check(ed->name);
+    t->type = ed->type;
+    t->type_py = (PyTypeObject *) result.ptr();
+    t->flags = ed->flags;
+    t->enum_tbl.fwd = new enum_map();
+    t->enum_tbl.rev = new enum_map();
+    t->scope = ed->scope;
 
-int nb_enum_traverse(PyObject *o, visitproc visit, void *arg) {
-    Py_VISIT(Py_TYPE(o));
-    return 0;
-}
+    it.value() = t;
 
-Py_hash_t nb_enum_hash(PyObject *o) {
-    Py_hash_t value = 0;
-    type_data *t = nb_type_data(Py_TYPE(o));
-    const void *p = inst_ptr((nb_inst *) o);
-    switch (t->size) {
-        case 1: value = *(const int8_t *)  p; break;
-        case 2: value = *(const int16_t *) p; break;
-        case 4: value = *(const int32_t *) p; break;
-        case 8: value = (Py_hash_t) * (const int64_t*)p; break;
-        default:
-            PyErr_SetString(PyExc_TypeError, "nb_enum: invalid type size!");
-            return -1;
-    }
+    internals->type_c2p_fast[ed->type] = t;
+    internals->type_c2p_slow[ed->type] = t;
 
-    // Hash functions should return -1 when an error occurred.
-    // Return -2 that case, since hash(-1) also yields -2.
-    if (value == -1) value = -2;
+    result.attr("__nb_enum__") = capsule(t, [](void *p) noexcept {
+        type_init_data *t = (type_init_data *) p;
+        delete (enum_map *) t->enum_tbl.fwd;
+        delete (enum_map *) t->enum_tbl.rev;
+        nb_type_unregister(t);
+        delete t;
+    });
 
-    return value;
+    return result.release().ptr();
 }
 
-void nb_enum_prepare(const type_init_data *td,
-                     PyType_Slot *&t, size_t max_slots) noexcept {
-    /* 22 is the number of slot assignments below. Update it if you add more.
-       These built-in slots are added before any user-defined ones. */
-    check(max_slots >= 22,
-          "nanobind::detail::nb_enum_prepare(\"%s\"): ran out of "
-          "type slots!", td->name);
-
-    const enum_init_data *ed = static_cast<const enum_init_data *>(td);
-    auto int_fn = ed->is_signed ? nb_enum_int_signed : nb_enum_int_unsigned;
-
-    *t++ = { Py_tp_new, (void *) nb_enum_new };
-    *t++ = { Py_tp_init, (void *) nb_enum_init };
-    *t++ = { Py_tp_repr, (void *) nb_enum_repr };
-    *t++ = { Py_tp_richcompare, (void *) nb_enum_richcompare };
-    *t++ = { Py_nb_int, (void *) int_fn };
-    *t++ = { Py_nb_index, (void *) int_fn };
-    *t++ = { Py_tp_getset, (void *) nb_enum_getset };
-    *t++ = { Py_tp_traverse, (void *) nb_enum_traverse };
-    *t++ = { Py_tp_clear, (void *) nb_enum_clear };
-    *t++ = { Py_tp_hash, (void *) nb_enum_hash };
-
-    if (ed->is_arithmetic) {
-        *t++ = { Py_nb_add, (void *) nb_enum_add };
-        *t++ = { Py_nb_subtract, (void *) nb_enum_sub };
-        *t++ = { Py_nb_multiply, (void *) nb_enum_mul };
-        *t++ = { Py_nb_floor_divide, (void *) nb_enum_div };
-        *t++ = { Py_nb_or, (void *) nb_enum_or };
-        *t++ = { Py_nb_xor, (void *) nb_enum_xor };
-        *t++ = { Py_nb_and, (void *) nb_enum_and };
-        *t++ = { Py_nb_rshift, (void *) nb_enum_rshift };
-        *t++ = { Py_nb_lshift, (void *) nb_enum_lshift };
-        *t++ = { Py_nb_negative, (void *) nb_enum_neg };
-        *t++ = { Py_nb_invert, (void *) nb_enum_inv };
-        *t++ = { Py_nb_absolute, (void *) nb_enum_abs };
-    }
+static type_init_data *enum_get_type_data(handle tp) {
+    return (type_init_data *) (borrow<capsule>(handle(tp).attr("__nb_enum__"))).data();
 }
 
-void nb_enum_put(PyObject *type, const char *name, const void *value,
+void enum_append(PyObject *tp_, const char *name_, int64_t value_,
                  const char *doc) noexcept {
-    PyObject *doc_obj, *rec, *int_val;
-    enum_supplement &supp = nb_enum_supplement((PyTypeObject *) type);
+    handle tp(tp_),
+           val_tp(&PyLong_Type),
+           obj_tp((PyObject *) &PyBaseObject_Type);
+
+    type_data *t = enum_get_type_data(tp);
+
+    object val;
+    if (t->flags & (uint32_t) type_flags::is_signed)
+        val = steal(PyLong_FromLongLong((long long) value_));
+    else
+        val = steal(PyLong_FromUnsignedLongLong((unsigned long long) value_));
+
+    dict value_map = tp.attr("_value2member_map_"),
+         member_map = tp.attr("_member_map_");
+    list member_names = tp.attr("_member_names_");
+    str name(name_);
+
+    if (member_map.contains(name))
+        fail("refusing to add duplicate key \"%s\" to enumeration \"%s\"!",
+             name_, type_name(tp).c_str());
+
+    object el;
+    if (issubclass(tp, val_tp))
+        el = val_tp.attr("__new__")(tp, val);
+    else
+        el = obj_tp.attr("__new__")(tp);
+
+    el.attr("_name_") = name;
+    el.attr("__objclass__") = tp;
+    el.attr("__init__")(val);
+    el.attr("_sort_order_") = len(member_names);
+    el.attr("_value_") = val;
+    el.attr("__doc__") = doc ? str(doc) : none();
+
+    // Compatibility with nanobind 1.x
+    el.attr("__name__") = name;
+
+    setattr(tp, name, el);
+
+    if (!value_map.contains(val)) {
+        member_names.append(name);
+        value_map[val] = el;
+    }
+
+    member_map[name] = el;
+
+    enum_map *fwd = (enum_map *) t->enum_tbl.fwd;
+    fwd->emplace(value_, (int64_t) (uintptr_t) el.ptr());
+
+    enum_map *rev = (enum_map *) t->enum_tbl.rev;
+    rev->emplace((int64_t) (uintptr_t) el.ptr(), value_);
+}
+
+bool enum_from_python(const std::type_info *tp, PyObject *o, int64_t *out, uint8_t flags) noexcept {
+    type_data *t = nb_type_c2p(internals, tp);
+    if (!t)
+        return false;
+
+    enum_map *rev = (enum_map *) t->enum_tbl.rev;
+    enum_map::iterator it = rev->find((int64_t) (uintptr_t) o);
+
+    if (it != rev->end()) {
+        *out = it->second;
+        return true;
+    }
+
+    if (flags & (uint8_t) cast_flags::convert) {
+        enum_map *fwd = (enum_map *) t->enum_tbl.fwd;
+
+        if (t->flags & (uint32_t) type_flags::is_signed) {
+            long long value = PyLong_AsLongLong(o);
+            if (value == -1 && PyErr_Occurred()) {
+                PyErr_Clear();
+                return false;
+            }
+            enum_map::iterator it2 = fwd->find((int64_t) value);
+            if (it2 != fwd->end()) {
+                *out = (int64_t) value;
+                return true;
+            }
+        } else {
+            unsigned long long value = PyLong_AsUnsignedLongLong(o);
+            if (value == (unsigned long long) -1 && PyErr_Occurred()) {
+                PyErr_Clear();
+                return false;
+            }
+            enum_map::iterator it2 = fwd->find((int64_t) value);
+            if (it2 != fwd->end()) {
+                *out = (int64_t) value;
+                return true;
+            }
+        }
 
-    PyObject *name_obj = PyUnicode_InternFromString(name);
-    if (doc) {
-        doc_obj = PyUnicode_FromString(doc);
-    } else {
-        doc_obj = Py_None;
-        Py_INCREF(Py_None);
     }
 
-    nb_inst *inst = (nb_inst *) inst_new_int((PyTypeObject *) type);
+    return false;
+}
 
-    if (!doc_obj || !name_obj || !inst)
-        goto error;
+PyObject *enum_from_cpp(const std::type_info *tp, int64_t key) noexcept {
+    type_data *t = nb_type_c2p(internals, tp);
+    if (!t)
+        return nullptr;
 
-    rec = PyTuple_New(3);
-    NB_TUPLE_SET_ITEM(rec, 0, name_obj);
-    NB_TUPLE_SET_ITEM(rec, 1, doc_obj);
-    NB_TUPLE_SET_ITEM(rec, 2, (PyObject *) inst);
-
-    memcpy(inst_ptr(inst), value, nb_type_data((PyTypeObject *) type)->size);
-    inst->destruct = false;
-    inst->cpp_delete = false;
-    inst->ready = true;
-
-    if (PyObject_SetAttr(type, name_obj, (PyObject *) inst))
-        goto error;
-
-    int_val = supp.is_signed ? nb_enum_int_signed((PyObject *) inst)
-                             : nb_enum_int_unsigned((PyObject *) inst);
-    if (!int_val)
-        goto error;
-
-    if (!supp.entries) {
-        PyObject *dict = PyDict_New();
-        if (!dict)
-            goto error;
-
-        // Stash the entries dict in the type object's dict so that GC
-        // can see the enumerators. nb_type_setattro ensures that user
-        // code can't reassign or delete this attribute (its logic
-        // is based on the @ prefix in the name).
-        if (PyObject_SetAttrString(type, "@entries", dict))
-            goto error;
+    enum_map *fwd = (enum_map *) t->enum_tbl.fwd;
 
-        supp.entries = dict;
-        Py_DECREF(dict);
+    enum_map::iterator it = fwd->find(key);
+    if (it != fwd->end()) {
+        PyObject *value = (PyObject *) it->second;
+        Py_INCREF(value);
+        return value;
     }
 
-    if (PyDict_SetItem(supp.entries, int_val, rec))
-        goto error;
-
-    Py_DECREF(int_val);
-    Py_DECREF(rec);
-
-    return;
-
-error:
-    check(false,
-          "nanobind::detail::nb_enum_put(): could not create enum entry!");
+    if (t->flags & (uint32_t) type_flags::is_signed)
+        PyErr_Format(PyExc_ValueError, "%lli is not a valid %s.",
+                     (long long) key, t->name);
+    else
+        PyErr_Format(PyExc_ValueError, "%llu is not a valid %s.",
+                     (unsigned long long) key, t->name);
+    return nullptr;
 }
 
-void nb_enum_export(PyObject *tp) {
-    enum_supplement &supp = nb_enum_supplement((PyTypeObject *) tp);
-    check(supp.entries && supp.scope != nullptr,
-          "nanobind::detail::nb_enum_export(): internal error!");
-
-    PyObject *key, *value;
-    Py_ssize_t pos = 0;
-
-    while (PyDict_Next(supp.entries, &pos, &key, &value)) {
-        check(PyTuple_CheckExact(value) && NB_TUPLE_GET_SIZE(value) == 3,
-              "nanobind::detail::nb_enum_export(): internal error! (2)");
-
-        setattr(supp.scope,
-                NB_TUPLE_GET_ITEM(value, 0),
-                NB_TUPLE_GET_ITEM(value, 2));
-    }
+void enum_export(PyObject *tp) {
+    type_init_data *t = enum_get_type_data(tp);
+
+    handle scope = t->scope;
+    for (handle item: handle(tp))
+        scope.attr(item.attr("name")) = item;
 }
 
 NAMESPACE_END(detail)
 NAMESPACE_END(NB_NAMESPACE)
```

## nanobind/src/nb_func.cpp

```diff
@@ -28,15 +28,16 @@
 // Forward/external declarations
 extern Buffer buf;
 
 static PyObject *nb_func_vectorcall_simple(PyObject *, PyObject *const *,
                                            size_t, PyObject *) noexcept;
 static PyObject *nb_func_vectorcall_complex(PyObject *, PyObject *const *,
                                             size_t, PyObject *) noexcept;
-static void nb_func_render_signature(const func_data *f) noexcept;
+static uint32_t nb_func_render_signature(const func_data *f,
+                                         bool nb_signature_mode = false) noexcept;
 
 int nb_func_traverse(PyObject *self, visitproc visit, void *arg) {
     size_t size = (size_t) Py_SIZE(self);
 
     if (size) {
         func_data *f = nb_func_data(self);
 
@@ -77,40 +78,40 @@
     PyObject_GC_UnTrack(self);
 
     size_t size = (size_t) Py_SIZE(self);
     if (size) {
         func_data *f = nb_func_data(self);
 
         // Delete from registered function list
-        auto &funcs = internals->funcs;
-        auto it = funcs.find(self);
-        check(it != funcs.end(),
+        size_t n_deleted = internals->funcs.erase(self);
+        check(n_deleted == 1,
               "nanobind::detail::nb_func_dealloc(\"%s\"): function not found!",
               ((f->flags & (uint32_t) func_flags::has_name) ? f->name
                                                             : "<anonymous>"));
-        funcs.erase(it);
-
         for (size_t i = 0; i < size; ++i) {
             if (f->flags & (uint32_t) func_flags::has_free)
                 f->free_capture(f->capture);
 
             if (f->flags & (uint32_t) func_flags::has_args) {
                 for (size_t j = 0; j < f->nargs; ++j) {
-                    Py_XDECREF(f->args[j].value);
-                    Py_XDECREF(f->args[j].name_py);
+                    const arg_data &arg = f->args[j];
+                    Py_XDECREF(arg.value);
+                    Py_XDECREF(arg.name_py);
+                    free((char *) arg.signature);
                 }
             }
 
             if (f->flags & (uint32_t) func_flags::has_doc)
                 free((char *) f->doc);
 
             free((char *) f->name);
             free(f->args);
             free((char *) f->descr);
             free(f->descr_types);
+            free(f->signature);
             ++f;
         }
     }
 
     PyObject_GC_Del(self);
 }
 
@@ -133,16 +134,16 @@
     PyObject_GC_UnTrack(self);
     Py_DECREF((PyObject *) mb->func);
     Py_DECREF(mb->self);
     PyObject_GC_Del(self);
 }
 
 static arg_data method_args[2] = {
-    { "self", nullptr, nullptr, false, false },
-    { nullptr, nullptr, nullptr, false, false }
+    { "self", nullptr, nullptr, nullptr, false, false },
+    { nullptr, nullptr, nullptr, nullptr, false, false }
 };
 
 static bool set_builtin_exception_status(builtin_exception &e) {
     PyObject *o;
 
     switch (e.type()) {
         case exception_type::runtime_error: o = PyExc_RuntimeError; break;
@@ -191,62 +192,69 @@
 PyObject *nb_func_new(const void *in_) noexcept {
     func_data_prelim<0> *f = (func_data_prelim<0> *) in_;
     arg_data *args_in = std::launder((arg_data *) f->args);
 
     bool has_scope      = f->flags & (uint32_t) func_flags::has_scope,
          has_name       = f->flags & (uint32_t) func_flags::has_name,
          has_args       = f->flags & (uint32_t) func_flags::has_args,
-         has_var_args   = f->flags & (uint32_t) func_flags::has_var_args,
-         has_var_kwargs = f->flags & (uint32_t) func_flags::has_var_kwargs,
          has_keep_alive = f->flags & (uint32_t) func_flags::has_keep_alive,
          has_doc        = f->flags & (uint32_t) func_flags::has_doc,
+         has_signature  = f->flags & (uint32_t) func_flags::has_signature,
          is_implicit    = f->flags & (uint32_t) func_flags::is_implicit,
          is_method      = f->flags & (uint32_t) func_flags::is_method,
          return_ref     = f->flags & (uint32_t) func_flags::return_ref,
          is_constructor = false;
 
     PyObject *name = nullptr;
     PyObject *func_prev = nullptr;
 
+    char *name_cstr;
+    if (has_signature) {
+        name_cstr = extract_name("nanobind::detail::nb_func_new", "def ", f->name);
+        has_name = *name_cstr != '\0';
+    } else {
+        name_cstr = strdup_check(has_name ? f->name : "");
+    }
+
     // Check for previous overloads
     if (has_scope && has_name) {
-        name = PyUnicode_FromString(f->name);
-        check(name, "nb::detail::nb_func_new(\"%s\"): invalid name.", f->name);
+        name = PyUnicode_InternFromString(name_cstr);
+        check(name, "nb::detail::nb_func_new(\"%s\"): invalid name.", name_cstr);
 
         func_prev = PyObject_GetAttr(f->scope, name);
         if (func_prev) {
             if (Py_TYPE(func_prev) == internals->nb_func ||
                 Py_TYPE(func_prev) == internals->nb_method) {
                 func_data *fp = nb_func_data(func_prev);
 
                 check((fp->flags & (uint32_t) func_flags::is_method) ==
                           (f->flags & (uint32_t) func_flags::is_method),
                       "nb::detail::nb_func_new(\"%s\"): mismatched static/"
                       "instance method flags in function overloads!",
-                      f->name);
+                      name_cstr);
 
                 /* Never append a method to an overload chain of a parent class;
                    instead, hide the parent's overloads in this case */
                 if (fp->scope != f->scope)
                     Py_CLEAR(func_prev);
-            } else if (f->name[0] == '_') {
+            } else if (name_cstr[0] == '_') {
                 Py_CLEAR(func_prev);
             } else {
                 check(false,
                       "nb::detail::nb_func_new(\"%s\"): cannot overload "
-                      "existing non-function object of the same name!", f->name);
+                      "existing non-function object of the same name!", name_cstr);
             }
         } else {
             PyErr_Clear();
         }
 
         // Is this method a constructor that takes a class binding as first parameter?
         is_constructor = is_method &&
-                         (strcmp(f->name, "__init__") == 0 ||
-                          strcmp(f->name, "__setstate__") == 0) &&
+                         (strcmp(name_cstr, "__init__") == 0 ||
+                          strcmp(name_cstr, "__setstate__") == 0) &&
                          strncmp(f->descr, "({%}", 4) == 0;
 
         // Don't use implicit conversions in copy constructors (causes infinite recursion)
         if (is_constructor && f->nargs == 2 && f->descr_types[0] &&
             f->descr_types[0] == f->descr_types[1]) {
             if (has_args) {
                 f->args[1].convert = false;
@@ -258,39 +266,40 @@
     }
 
     // Create a new function and destroy the old one
     Py_ssize_t to_copy = func_prev ? Py_SIZE(func_prev) : 0;
     nb_func *func = (nb_func *) PyType_GenericAlloc(
         is_method ? internals->nb_method : internals->nb_func, to_copy + 1);
     check(func, "nb::detail::nb_func_new(\"%s\"): alloc. failed (1).",
-          has_name ? f->name : "<anonymous>");
+          name_cstr);
 
-    func->max_nargs_pos = f->nargs;
-    func->complex_call = has_args || has_var_args || has_var_kwargs || has_keep_alive;
+    func->max_nargs = f->nargs;
+    func->complex_call = f->nargs_pos < f->nargs || has_args || has_keep_alive;
 
     if (func_prev) {
         func->complex_call |= ((nb_func *) func_prev)->complex_call;
-        func->max_nargs_pos = std::max(func->max_nargs_pos,
-                                       ((nb_func *) func_prev)->max_nargs_pos);
+        func->max_nargs = std::max(func->max_nargs,
+                                   ((nb_func *) func_prev)->max_nargs);
 
         func_data *cur  = nb_func_data(func),
                   *prev = nb_func_data(func_prev);
 
         memcpy(cur, prev, sizeof(func_data) * to_copy);
         memset(prev, 0, sizeof(func_data) * to_copy);
 
         ((PyVarObject *) func_prev)->ob_size = 0;
 
-        auto it = internals->funcs.find(func_prev);
-        check(it != internals->funcs.end(),
+        size_t n_deleted = internals->funcs.erase(func_prev);
+        check(n_deleted == 1,
               "nanobind::detail::nb_func_new(): internal update failed (1)!");
-        internals->funcs.erase(it);
+
+        Py_CLEAR(func_prev);
     }
 
-    func->complex_call |= func->max_nargs_pos >= NB_MAXARGS_SIMPLE;
+    func->complex_call |= func->max_nargs >= NB_MAXARGS_SIMPLE;
 
     func->vectorcall = func->complex_call ? nb_func_vectorcall_complex
                                           : nb_func_vectorcall_simple;
 
     // Register the function
     auto [it, success] = internals->funcs.try_emplace(func, nullptr);
     check(success,
@@ -306,27 +315,26 @@
     }
 
     if (is_constructor)
         fc->flags |= (uint32_t) func_flags::is_constructor;
     if (has_args)
         fc->flags |= (uint32_t) func_flags::has_args;
 
-    if (!has_name)
-        fc->name = "";
-    fc->name = strdup_check(fc->name);
+    fc->name = name_cstr;
+    fc->signature = has_signature ? strdup_check(f->name) : nullptr;
 
     if (is_implicit) {
         check(fc->flags & (uint32_t) func_flags::is_constructor,
               "nb::detail::nb_func_new(\"%s\"): nanobind::is_implicit() "
               "should only be specified for constructors.",
-              f->name);
+              name_cstr);
         check(f->nargs == 2,
               "nb::detail::nb_func_new(\"%s\"): implicit constructors "
               "should only have one argument.",
-              f->name);
+              name_cstr);
 
         if (f->descr_types[1])
             implicitly_convertible(f->descr_types[1], f->descr_types[0]);
     }
 
     for (size_t i = 0;; ++i) {
         if (!f->descr[i]) {
@@ -352,27 +360,30 @@
         if (is_method) // add implicit 'self' argument annotation
             fc->args[0] = method_args[0];
         for (size_t i = is_method; i < fc->nargs; ++i)
             fc->args[i] = args_in[i - is_method];
 
         for (size_t i = 0; i < fc->nargs; ++i) {
             arg_data &a = fc->args[i];
-            if (a.name)
+            if (a.name) {
                 a.name_py = PyUnicode_InternFromString(a.name);
-            else
+                a.name = PyUnicode_AsUTF8AndSize(a.name_py, nullptr);
+            } else {
                 a.name_py = nullptr;
+            }
             a.none |= a.value == Py_None;
+            a.signature = a.signature ? strdup_check(a.signature) : nullptr;
             Py_XINCREF(a.value);
         }
     }
 
     if (has_scope && name) {
         int rv = PyObject_SetAttr(f->scope, name, (PyObject *) func);
         check(rv == 0, "nb::detail::nb_func_new(\"%s\"): setattr. failed.",
-              f->name);
+              name_cstr);
     }
 
     Py_XDECREF(name);
 
     if (return_ref) {
         return (PyObject *) func;
     } else {
@@ -488,15 +499,15 @@
 
     PyObject *result = nullptr,
              *self_arg = (is_method && nargs_in > 0) ? args_in[0] : nullptr;
 
     /* The following lines allocate memory on the stack, which is very efficient
        but also potentially dangerous since it can be used to generate stack
        overflows. We refuse unrealistically large number of 'kwargs' (the
-       'max_nargs_pos' value is fine since it is specified by the bindings) */
+       'max_nargs' value is fine since it is specified by the bindings) */
     if (nkwargs_in > 1024) {
         PyErr_SetString(PyExc_TypeError,
                         "nanobind::detail::nb_func_vectorcall(): too many (> "
                         "1024) keyword arguments.");
         return nullptr;
     }
 
@@ -504,27 +515,64 @@
     PyObject *(*error_handler)(PyObject *, PyObject *const *, size_t,
                                PyObject *) noexcept = nullptr;
 
     // Small array holding temporaries (implicit conversion/*args/**kwargs)
     cleanup_list cleanup(self_arg);
 
     // Preallocate stack memory for function dispatch
-    size_t max_nargs_pos = ((nb_func *) self)->max_nargs_pos;
-    PyObject **args = (PyObject **) alloca(max_nargs_pos * sizeof(PyObject *));
-    uint8_t *args_flags = (uint8_t *) alloca(max_nargs_pos * sizeof(uint8_t));
+    size_t max_nargs = ((nb_func *) self)->max_nargs;
+    PyObject **args = (PyObject **) alloca(max_nargs * sizeof(PyObject *));
+    uint8_t *args_flags = (uint8_t *) alloca(max_nargs * sizeof(uint8_t));
     bool *kwarg_used = (bool *) alloca(nkwargs_in * sizeof(bool));
 
+    // Ensure that keyword argument names are interned. That makes it faster
+    // to compare them against pre-interned argument names in the overload chain.
+    // Normal function calls will have their keyword arguments already interned,
+    // but we can't rely on that; it fails for things like fn(**json.loads(...)).
+    PyObject **kwnames = nullptr;
+
+#if !defined(PYPY_VERSION) && !defined(Py_LIMITED_API)
+    bool kwnames_interned = true;
+    for (size_t i = 0; i < nkwargs_in; ++i) {
+        PyObject *key = NB_TUPLE_GET_ITEM(kwargs_in, i);
+        kwnames_interned &= ((PyASCIIObject *) key)->state.interned != 0;
+    }
+    if (NB_LIKELY(kwnames_interned)) {
+        kwnames = ((PyTupleObject *) kwargs_in)->ob_item;
+        goto traverse_overloads;
+    }
+#endif
+
+    kwnames = (PyObject **) alloca(nkwargs_in * sizeof(PyObject *));
+    for (size_t i = 0; i < nkwargs_in; ++i) {
+        PyObject *key = NB_TUPLE_GET_ITEM(kwargs_in, i);
+        Py_INCREF(key);
+
+        kwnames[i] = key;
+        PyUnicode_InternInPlace(&kwnames[i]);
+        PyObject *key_interned = kwnames[i];
+
+        if (NB_LIKELY(key == key_interned)) // string was already interned
+            Py_DECREF(key);
+        else
+            cleanup.append(key_interned);
+    }
+
+#if !defined(PYPY_VERSION) && !defined(Py_LIMITED_API)
+  traverse_overloads:
+#endif
+
     /*  The logic below tries to find a suitable overload using two passes
         of the overload chain (or 1, if there are no overloads). The first pass
         is strict and permits no implicit conversions, while the second pass
         allows them.
 
         The following is done per overload during a pass
 
-        1. Copy positional arguments while checking that named positional
+        1. Copy individual arguments while checking that named positional
            arguments weren't *also* specified as kwarg. Substitute missing
            entries using keyword arguments or default argument values provided
            in the bindings, if available.
 
         3. Ensure that either all keyword arguments were "consumed", or that
            the function takes a kwargs argument to accept unconsumed kwargs.
 
@@ -544,49 +592,62 @@
         for (size_t k = 0; k < count; ++k) {
             const func_data *f = fr + k;
 
             const bool has_args       = f->flags & (uint32_t) func_flags::has_args,
                        has_var_args   = f->flags & (uint32_t) func_flags::has_var_args,
                        has_var_kwargs = f->flags & (uint32_t) func_flags::has_var_kwargs;
 
-            /// Number of positional arguments
-            size_t nargs_pos = f->nargs - has_var_args - has_var_kwargs;
+            // Number of C++ parameters eligible to be filled from individual
+            // Python positional arguments
+            size_t nargs_pos = f->nargs_pos;
+
+            // Number of C++ parameters in total, except for a possible trailing
+            // nb::kwargs. All of these are eligible to be filled from individual
+            // Python arguments (keyword always, positional until index nargs_pos)
+            // except for a potential nb::args, which exists at index nargs_pos
+            // if has_var_args is true. We'll skip that one in the individual-args
+            // loop, and go back and fill it later with the unused positionals.
+            size_t nargs_step1 = f->nargs - has_var_kwargs;
 
             if (nargs_in > nargs_pos && !has_var_args)
                 continue; // Too many positional arguments given for this overload
 
             if (nargs_in < nargs_pos && !has_args)
                 continue; // Not enough positional arguments, insufficient
                           // keyword/default arguments to fill in the blanks
 
             memset(kwarg_used, 0, nkwargs_in * sizeof(bool));
 
-            // 1. Copy positional arguments, potentially substitute kwargs/defaults
+            // 1. Copy individual arguments, potentially substitute kwargs/defaults
             size_t i = 0;
-            for (; i < nargs_pos; ++i) {
+            for (; i < nargs_step1; ++i) {
+                if (has_var_args && i == nargs_pos)
+                    continue; // skip nb::args parameter, will be handled below
+
                 PyObject *arg = nullptr;
                 bool arg_convert  = pass == 1,
                      arg_none     = false;
 
-                if (i < nargs_in)
+                // If i >= nargs_pos, then this is a keyword-only parameter.
+                // (We skipped any *args parameter using the test above,
+                // and we set the bounds of nargs_step1 to not include any
+                // **kwargs parameter.) In that case we don't want to take
+                // a positional arg (which might validly exist and be
+                // destined for the *args) but we do still want to look for
+                // a matching keyword arg.
+                if (i < nargs_in && i < nargs_pos)
                     arg = args_in[i];
 
                 if (has_args) {
                     const arg_data &ad = f->args[i];
 
                     if (kwargs_in && ad.name_py) {
                         PyObject *hit = nullptr;
                         for (size_t j = 0; j < nkwargs_in; ++j) {
-                            PyObject *key = NB_TUPLE_GET_ITEM(kwargs_in, j);
-                            #if defined(PYPY_VERSION)
-                                bool match = PyUnicode_Compare(key, ad.name_py) == 0;
-                            #else
-                                bool match = (key == ad.name_py);
-                            #endif
-                            if (match) {
+                            if (kwnames[j] == ad.name_py) {
                                 hit = args_in[nargs_in + j];
                                 kwarg_used[j] = true;
                                 break;
                             }
                         }
 
                         if (hit) {
@@ -606,16 +667,16 @@
                 if (!arg || (arg == Py_None && !arg_none))
                     break;
 
                 args[i] = arg;
                 args_flags[i] = arg_convert ? (uint8_t) cast_flags::convert : (uint8_t) 0;
             }
 
-            // Skip this overload if positional arguments were unavailable
-            if (i != nargs_pos)
+            // Skip this overload if any arguments were unavailable
+            if (i != nargs_step1)
                 continue;
 
             // Deal with remaining positional arguments
             if (has_var_args) {
                 PyObject *tuple = PyTuple_New(
                     nargs_in > nargs_pos ? (Py_ssize_t) (nargs_in - nargs_pos) : 0);
 
@@ -630,21 +691,21 @@
                 cleanup.append(tuple);
             }
 
             // Deal with remaining keyword arguments
             if (has_var_kwargs) {
                 PyObject *dict = PyDict_New();
                 for (size_t j = 0; j < nkwargs_in; ++j) {
-                    PyObject *key = NB_TUPLE_GET_ITEM(kwargs_in, j);
+                    PyObject *key = kwnames[j];
                     if (!kwarg_used[j])
                         PyDict_SetItem(dict, key, args_in[nargs_in + j]);
                 }
 
-                args[nargs_pos + has_var_args] = dict;
-                args_flags[nargs_pos + has_var_args] = 0;
+                args[nargs_step1] = dict;
+                args_flags[nargs_step1] = 0;
                 cleanup.append(dict);
             } else if (kwargs_in) {
                 bool success = true;
                 for (size_t j = 0; j < nkwargs_in; ++j)
                     success &= kwarg_used[j];
                 if (!success)
                     continue;
@@ -679,15 +740,15 @@
                 goto done;
             }
 
             if (result != NB_NEXT_OVERLOAD) {
                 if (is_constructor) {
                     nb_inst *self_arg_nb = (nb_inst *) self_arg;
                     self_arg_nb->destruct = true;
-                    self_arg_nb->ready = true;
+                    self_arg_nb->state = nb_inst::state_ready;
                     if (NB_UNLIKELY(self_arg_nb->intrusive))
                         nb_type_data(Py_TYPE(self_arg))
                             ->set_self_py(inst_ptr(self_arg_nb), self_arg);
                 }
 
                 goto done;
             }
@@ -780,15 +841,15 @@
                 goto done;
             }
 
             if (result != NB_NEXT_OVERLOAD) {
                 if (is_constructor) {
                     nb_inst *self_arg_nb = (nb_inst *) self_arg;
                     self_arg_nb->destruct = true;
-                    self_arg_nb->ready = true;
+                    self_arg_nb->state = nb_inst::state_ready;
                     if (NB_UNLIKELY(self_arg_nb->intrusive))
                         nb_type_data(Py_TYPE(self_arg))
                             ->set_self_py(inst_ptr(self_arg_nb), self_arg);
                 }
 
                 goto done;
             }
@@ -856,46 +917,93 @@
         Py_INCREF(self);
         return self;
     }
 }
 
 
 /// Render the function signature of a single function
-static void nb_func_render_signature(const func_data *f) noexcept {
+static uint32_t nb_func_render_signature(const func_data *f,
+                                         bool nb_signature_mode) noexcept {
     const bool is_method      = f->flags & (uint32_t) func_flags::is_method,
                has_args       = f->flags & (uint32_t) func_flags::has_args,
                has_var_args   = f->flags & (uint32_t) func_flags::has_var_args,
-               has_var_kwargs = f->flags & (uint32_t) func_flags::has_var_kwargs;
+               has_var_kwargs = f->flags & (uint32_t) func_flags::has_var_kwargs,
+               has_signature  = f->flags & (uint32_t) func_flags::has_signature;
+
+    if (has_signature) {
+        const char *s = f->signature;
+
+        if (!nb_signature_mode) {
+            // go to last line of manually provided signature, strip away 'def ' prefix
+            const char *p = strrchr(s, '\n');
+            s = p ? (p + 1) : s;
+            if (strncmp(s, "def ", 4) == 0)
+                s += 4;
+        }
+
+        buf.put_dstr(s);
+        return 0;
+    }
+
+    if (nb_signature_mode)
+        buf.put("def ");
 
     const std::type_info **descr_type = f->descr_types;
+    bool rv = false;
 
-    uint32_t arg_index = 0;
+    uint32_t arg_index = 0, n_default_args = 0;
     buf.put_dstr(f->name);
 
     for (const char *pc = f->descr; *pc != '\0'; ++pc) {
         char c = *pc;
 
         switch (c) {
+            case '@':
+                // Handle types that differ depending on whether they appear
+                // in an argument or a return value position
+                pc++;
+                if (!rv) {
+                    while (*pc && *pc != '@')
+                        buf.put(*pc++);
+                    if (*pc == '@')
+                        pc++;
+                    while (*pc && *pc != '@')
+                        pc++;
+                } else {
+                    while (*pc && *pc != '@')
+                        pc++;
+                    if (*pc == '@')
+                        pc++;
+                    while (*pc && *pc != '@')
+                        buf.put(*pc++);
+                }
+                break;
+
             case '{':
                 {
                     const char *arg_name = has_args ? f->args[arg_index].name : nullptr;
 
                     // Argument name
                     if (has_var_kwargs && arg_index + 1 == f->nargs) {
                         buf.put("**");
                         buf.put_dstr(arg_name ? arg_name : "kwargs");
                         pc += 4; // strlen("dict")
                         break;
                     }
 
-                    if (has_var_args && arg_index + 1 + has_var_kwargs == f->nargs) {
+                    if (arg_index == f->nargs_pos) {
                         buf.put("*");
-                        buf.put_dstr(arg_name ? arg_name : "args");
-                        pc += 5; // strlen("tuple")
-                        break;
+                        if (has_var_args) {
+                            buf.put_dstr(arg_name ? arg_name : "args");
+                            pc += 5; // strlen("tuple")
+                            break;
+                        } else {
+                            buf.put(", ");
+                            // fall through to render the first keyword-only arg
+                        }
                     }
 
                     if (is_method && arg_index == 0) {
                         buf.put("self");
 
                         // Skip over type
                         while (*pc != '}') {
@@ -910,54 +1018,70 @@
                     } else {
                         buf.put("arg");
                         if (f->nargs > 1 + (uint32_t) is_method)
                             buf.put_uint32(arg_index - is_method);
                     }
 
                     buf.put(": ");
-                    if (has_args && f->args[arg_index].none)
-                        buf.put("Optional[");
+                    if (has_args && f->args[arg_index].none) {
+                        #if PY_VERSION_HEX < 0x030A0000
+                            buf.put("typing.Optional[");
+                        #else
+                            // See below
+                        #endif
+                    }
                 }
                 break;
 
             case '}':
                 // Default argument
                 if (has_args) {
-                    if (f->args[arg_index].none)
-                        buf.put(']');
+                    if (f->args[arg_index].none) {
+                        #if PY_VERSION_HEX < 0x030A0000
+                            buf.put(']');
+                        #else
+                            buf.put(" | None");
+                        #endif
+                    }
 
                     if (f->args[arg_index].value) {
-                        PyObject *o = f->args[arg_index].value;
-                        PyObject *str = PyObject_Str(o);
-                        bool is_str = PyUnicode_Check(o);
-
-                        if (str) {
-                            Py_ssize_t size = 0;
-                            const char *cstr =
-                                PyUnicode_AsUTF8AndSize(str, &size);
-                            if (!cstr) {
-                                PyErr_Clear();
+                        const arg_data &arg= f->args[arg_index];
+                        if (nb_signature_mode) {
+                            buf.put(" = \\");
+                            if (arg.signature)
+                                buf.put('=');
+                            buf.put_uint32(n_default_args++);
+                        } else if (arg.signature) {
+                            buf.put(" = ");
+                            buf.put_dstr(arg.signature);
+                        } else {
+                            PyObject *o = arg.value;
+                            PyObject *str = PyObject_Repr(o);
+
+                            if (str) {
+                                Py_ssize_t size = 0;
+                                const char *cstr =
+                                    PyUnicode_AsUTF8AndSize(str, &size);
+                                if (!cstr) {
+                                    PyErr_Clear();
+                                } else {
+                                    buf.put(" = ");
+                                    buf.put(cstr, (size_t) size);
+                                }
+                                Py_DECREF(str);
                             } else {
-                                buf.put(" = ");
-                                if (is_str)
-                                    buf.put('\'');
-                                buf.put(cstr, (size_t) size);
-                                if (is_str)
-                                    buf.put('\'');
+                                PyErr_Clear();
                             }
-                            Py_DECREF(str);
-                        } else {
-                            PyErr_Clear();
                         }
                     }
                 }
 
                 arg_index++;
 
-                if (arg_index == f->nargs - has_var_args - has_var_kwargs && !has_args)
+                if (arg_index == f->nargs_pos && !has_args)
                     buf.put(", /");
 
                 break;
 
             case '%':
                 check(*descr_type,
                       "nb::detail::nb_func_render_signature(): missing type!");
@@ -967,42 +1091,53 @@
 
                     if (it != internals->type_c2p_slow.end()) {
                         handle th((PyObject *) it->second->type_py);
                         buf.put_dstr((borrow<str>(th.attr("__module__"))).c_str());
                         buf.put('.');
                         buf.put_dstr((borrow<str>(th.attr("__qualname__"))).c_str());
                     } else {
+                        if (nb_signature_mode)
+                            buf.put('"');
                         char *name = type_name(*descr_type);
                         buf.put_dstr(name);
                         free(name);
+                        if (nb_signature_mode)
+                            buf.put('"');
                     }
                 }
 
                 descr_type++;
                 break;
 
+            case '-':
+                if (pc[1] == '>')
+                    rv = true;
+                buf.put(c);
+                break;
+
+
             default:
                 buf.put(c);
                 break;
         }
     }
 
     check(arg_index == f->nargs && !*descr_type,
           "nanobind::detail::nb_func_render_signature(%s): arguments inconsistent.",
           f->name);
+
+    return n_default_args;
 }
 
 static PyObject *nb_func_get_name(PyObject *self) {
     func_data *f = nb_func_data(self);
-    if (f->flags & (uint32_t) func_flags::has_name) {
-        return PyUnicode_FromString(f->name);
-    } else {
-        Py_INCREF(Py_None);
-        return Py_None;
-    }
+    const char *name = "";
+    if (f->flags & (uint32_t) func_flags::has_name)
+        name = f->name;
+    return PyUnicode_FromString(name);
 }
 
 static PyObject *nb_func_get_qualname(PyObject *self) {
     func_data *f = nb_func_data(self);
     if ((f->flags & (uint32_t) func_flags::has_scope) &&
         (f->flags & (uint32_t) func_flags::has_name)) {
         PyObject *scope_name = PyObject_GetAttrString(f->scope, "__qualname__");
@@ -1025,26 +1160,98 @@
             f->scope, PyModule_Check(f->scope) ? "__name__" : "__module__");
     } else {
         Py_INCREF(Py_None);
         return Py_None;
     }
 }
 
+PyObject *nb_func_get_nb_signature(PyObject *self, void *) {
+    PyObject *docstr = nullptr, *item = nullptr, *sigstr = nullptr,
+             *defaults = nullptr;
+
+    func_data *f = nb_func_data(self);
+    uint32_t count = (uint32_t) Py_SIZE(self);
+    PyObject *result = PyTuple_New(count);
+    if (!result)
+        return nullptr;
+
+    for (uint32_t i = 0; i < count; ++i) {
+        docstr = item = sigstr = defaults = nullptr;
+
+        const func_data *fi = f + i;
+        if (fi->flags & (uint32_t) func_flags::has_doc && fi->doc[0] != '\0') {
+            docstr = PyUnicode_FromString(fi->doc);
+        } else {
+            docstr = Py_None;
+            Py_INCREF(docstr);
+        }
+
+        buf.clear();
+        uint32_t n_default_args = nb_func_render_signature(fi, true);
+
+        item = PyTuple_New(3);
+        sigstr = PyUnicode_FromString(buf.get());
+        if (n_default_args) {
+            defaults = PyTuple_New(n_default_args);
+        } else {
+            defaults = Py_None;
+            Py_INCREF(defaults);
+        }
+
+        if (!docstr || !sigstr || !item || !defaults)
+            goto fail;
+
+        if (n_default_args) {
+            size_t pos = 0;
+            for (uint32_t j = 0; j < fi->nargs; ++j) {
+                const arg_data &arg = fi->args[j];
+                PyObject *value = arg.value;
+                if (!value)
+                    continue;
+                if (arg.signature) {
+                    value = PyUnicode_FromString(arg.signature);
+                    if (!value)
+                        goto fail;
+                } else {
+                    Py_INCREF(value);
+                }
+                NB_TUPLE_SET_ITEM(defaults, pos, value);
+                pos++;
+            }
+
+            check(pos == n_default_args,
+                  "__nb_signature__: default argument counting inconsistency!");
+        }
+
+        NB_TUPLE_SET_ITEM(item, 0, sigstr);
+        NB_TUPLE_SET_ITEM(item, 1, docstr);
+        NB_TUPLE_SET_ITEM(item, 2, defaults);
+        NB_TUPLE_SET_ITEM(result, (Py_ssize_t) i, item);
+    }
+
+    return result;
+
+fail:
+    Py_XDECREF(docstr);
+    Py_XDECREF(sigstr);
+    Py_XDECREF(defaults);
+    Py_XDECREF(item);
+    Py_DECREF(result);
+    return nullptr;
+}
+
 PyObject *nb_func_get_doc(PyObject *self, void *) {
     func_data *f = nb_func_data(self);
     uint32_t count = (uint32_t) Py_SIZE(self);
 
     buf.clear();
 
     size_t doc_count = 0;
     for (uint32_t i = 0; i < count; ++i) {
         const func_data *fi = f + i;
-        if (fi->flags & (uint32_t) func_flags::raw_doc)
-            return PyUnicode_FromString(fi->doc);
-
         nb_func_render_signature(fi);
         buf.put('\n');
         if ((fi->flags & (uint32_t) func_flags::has_doc) && fi->doc[0] != '\0')
             doc_count++;
     }
 
     if (doc_count > 1)
```

## nanobind/src/nb_internals.cpp

```diff
@@ -13,15 +13,15 @@
 
 #if defined(__GNUC__) && !defined(__clang__)
 #  pragma GCC diagnostic ignored "-Wmissing-field-initializers"
 #endif
 
 /// Tracks the ABI of nanobind
 #ifndef NB_INTERNALS_VERSION
-#  define NB_INTERNALS_VERSION 13
+#  define NB_INTERNALS_VERSION 14
 #endif
 
 /// On MSVC, debug and release builds are not ABI-compatible!
 #if defined(_MSC_VER) && defined(_DEBUG)
 #  define NB_BUILD_TYPE "_debug"
 #else
 #  define NB_BUILD_TYPE ""
@@ -77,14 +77,15 @@
         NB_COMPILER_TYPE NB_STDLIB NB_BUILD_ABI NB_BUILD_TYPE NB_STABLE_ABI
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
 extern PyObject *nb_func_getattro(PyObject *, PyObject *);
 extern PyObject *nb_func_get_doc(PyObject *, void *);
+extern PyObject *nb_func_get_nb_signature(PyObject *, void *);
 extern PyObject *nb_bound_method_getattro(PyObject *, PyObject *);
 extern int nb_func_traverse(PyObject *, visitproc, void *);
 extern int nb_func_clear(PyObject *);
 extern void nb_func_dealloc(PyObject *);
 extern int nb_bound_method_traverse(PyObject *, visitproc, void *);
 extern int nb_bound_method_clear(PyObject *);
 extern void nb_bound_method_dealloc(PyObject *);
@@ -113,14 +114,15 @@
     { "__vectorcalloffset__", T_PYSSIZET,
       (Py_ssize_t) offsetof(nb_func, vectorcall), READONLY, nullptr },
     { nullptr, 0, 0, 0, nullptr }
 };
 
 static PyGetSetDef nb_func_getset[] = {
     { "__doc__", nb_func_get_doc, nullptr, nullptr, nullptr },
+    { "__nb_signature__", nb_func_get_nb_signature, nullptr, nullptr, nullptr },
     { nullptr, nullptr, nullptr, nullptr, nullptr }
 };
 
 static PyType_Slot nb_func_slots[] = {
     { Py_tp_members, (void *) nb_func_members },
     { Py_tp_getset, (void *) nb_func_getset },
     { Py_tp_getattro, (void *) nb_func_getattro },
@@ -295,14 +297,20 @@
                 }
             }
         }
         leak = true;
     }
 
     if (!leak) {
+        nb_translator_seq* t = internals->translators.next;
+        while (t) {
+            nb_translator_seq *next = t->next;
+            delete t;
+            t = next;
+        }
         delete internals;
         internals = nullptr;
         nb_meta_cache = nullptr;
     } else {
         if (print_leak_warnings) {
             fprintf(stderr, "nanobind: this is likely caused by a reference "
                             "counting issue in the binding code.\n");
@@ -350,14 +358,16 @@
 
     nb_meta_slots[0].pfunc = (PyObject *) &PyType_Type;
     nb_meta_cache = p->nb_meta = (PyTypeObject *) PyType_FromSpec(&nb_meta_spec);
     p->nb_type_dict = PyDict_New();
     p->nb_func = (PyTypeObject *) PyType_FromSpec(&nb_func_spec);
     p->nb_method = (PyTypeObject *) PyType_FromSpec(&nb_method_spec);
     p->nb_bound_method = (PyTypeObject *) PyType_FromSpec(&nb_bound_method_spec);
+    p->keep_alive.min_load_factor(.1f);
+    p->inst_c2p.min_load_factor(.1f);
 
     check(p->nb_module && p->nb_meta && p->nb_type_dict && p->nb_func &&
               p->nb_method && p->nb_bound_method,
           "nanobind::detail::init(): initialization failed!");
 
 #if PY_VERSION_HEX < 0x03090000
     p->nb_func->tp_flags |= NB_HAVE_VECTORCALL;
@@ -436,15 +446,19 @@
     Py_DECREF(capsule);
     Py_DECREF(key);
     internals = p;
 }
 
 #if defined(NB_COMPACT_ASSERTIONS)
 NB_NOINLINE void fail_unspecified() noexcept {
-    fail("nanobind: encountered an unrecoverable error condition. Recompile "
-         "using the 'Debug' or 'RelWithDebInfo' modes to obtain further "
-         "information about this problem.");
+    #if defined(NB_COMPACT_ASSERTION_MESSAGE)
+        fail(NB_COMPACT_ASSERTION_MESSAGE);
+    #else
+        fail("nanobind: encountered an unrecoverable error condition. Recompile "
+             "using the 'Debug' or 'RelWithDebInfo' modes to obtain further "
+             "information about this problem.");
+    #endif
 }
 #endif
 
 NAMESPACE_END(detail)
 NAMESPACE_END(NB_NAMESPACE)
```

## nanobind/src/nb_internals.h

```diff
@@ -14,14 +14,18 @@
 #include <nanobind/nanobind.h>
 #include <tsl/robin_map.h>
 #include <cstring>
 #include <string_view>
 #include <functional>
 #include "hash.h"
 
+#if TSL_RH_VERSION_MAJOR != 1 || TSL_RH_VERSION_MINOR < 3
+#  error nanobind depends on tsl::robin_map, in particular version >= 1.3.0, <2.0.0
+#endif
+
 #if defined(_MSC_VER)
 #  define NB_THREAD_LOCAL __declspec(thread)
 #else
 #  define NB_THREAD_LOCAL __thread
 #endif
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
@@ -33,59 +37,68 @@
 #else
 #  define check(cond, ...) if (NB_UNLIKELY(!(cond))) nanobind::detail::fail(__VA_ARGS__)
 #endif
 
 /// Nanobind function metadata (overloads, etc.)
 struct func_data : func_data_prelim<0> {
     arg_data *args;
+    char *signature;
 };
 
 /// Python object representing an instance of a bound C++ type
 struct nb_inst { // usually: 24 bytes
     PyObject_HEAD
 
     /// Offset to the actual instance data
     int32_t offset;
 
+    /// State of the C++ object this instance points to: is it constructed?
+    /// can we use it?
+    uint32_t state : 2;
+
+    // Values for `state`. Note that the numeric values of these are relied upon
+    // for an optimization in `nb_type_get()`.
+    static constexpr uint32_t state_uninitialized = 0; // not constructed
+    static constexpr uint32_t state_relinquished = 1; // owned by C++, don't touch
+    static constexpr uint32_t state_ready = 2; // constructed and usable
+
     /**
      * The variable 'offset' can either encode an offset relative to the
      * nb_inst address that leads to the instance data, or it can encode a
      * relative offset to a pointer that must be dereferenced to get to the
      * instance data. 'direct' is 'true' in the former case.
      */
     uint32_t direct : 1;
 
     /// Is the instance data co-located with the Python object?
     uint32_t internal : 1;
 
-    /// Is the instance properly initialized?
-    uint32_t ready : 1;
-
     /// Should the destructor be called when this instance is GCed?
     uint32_t destruct : 1;
 
     /// Should nanobind call 'operator delete' when this instance is GCed?
     uint32_t cpp_delete : 1;
 
-    /// Does this instance hold reference to others? (via internals.keep_alive)
+    /// Does this instance hold references to others? (via internals.keep_alive)
     uint32_t clear_keep_alive : 1;
 
     /// Does this instance use intrusive reference counting?
     uint32_t intrusive : 1;
 
-    uint32_t unused: 25;
+    // That's a lot of unused space. I wonder if there is a good use for it..
+    uint32_t unused : 24;
 };
 
 static_assert(sizeof(nb_inst) == sizeof(PyObject) + sizeof(uint32_t) * 2);
 
 /// Python object representing a bound C++ function
 struct nb_func {
     PyObject_VAR_HEAD
     PyObject* (*vectorcall)(PyObject *, PyObject * const*, size_t, PyObject *);
-    uint32_t max_nargs_pos;
+    uint32_t max_nargs; // maximum value of func_data::nargs for any overload
     bool complex_call;
 };
 
 /// Python object representing a `nb_ndarray` (which wraps a DLPack ndarray)
 struct nb_ndarray {
     PyObject_HEAD
     ndarray_handle *th;
@@ -272,14 +285,17 @@
 
 // Forward declarations
 extern PyObject *inst_new_ext(PyTypeObject *tp, void *value);
 extern PyObject *inst_new_int(PyTypeObject *tp);
 extern PyTypeObject *nb_static_property_tp() noexcept;
 extern type_data *nb_type_c2p(nb_internals *internals,
                               const std::type_info *type);
+extern void nb_type_unregister(type_data *t) noexcept;
+
+extern PyObject *call_one_arg(PyObject *fn, PyObject *arg) noexcept;
 
 /// Fetch the nanobind function record from a 'nb_func' instance
 NB_INLINE func_data *nb_func_data(void *o) {
     return (func_data *) (((char *) o) + sizeof(nb_func));
 }
 
 #if defined(Py_LIMITED_API)
@@ -318,10 +334,13 @@
     T &operator[](size_t i) { return ptr[i]; }
     T *operator->() { return ptr; }
 private:
     T *ptr{ nullptr };
 };
 
 extern char *strdup_check(const char *);
+extern void *malloc_check(size_t size);
+
+extern char *extract_name(const char *cmd, const char *prefix, const char *s);
 
 NAMESPACE_END(detail)
 NAMESPACE_END(NB_NAMESPACE)
```

## nanobind/src/nb_ndarray.cpp

```diff
@@ -258,16 +258,22 @@
     mt->dltensor.device = { device::cpu::value, 0 };
     mt->dltensor.ndim = view->ndim;
     mt->dltensor.dtype = dt;
     mt->dltensor.byte_offset = value_int - value_rounded;
 
     scoped_pymalloc<int64_t> strides((size_t) view->ndim);
     scoped_pymalloc<int64_t> shape((size_t) view->ndim);
+    const int64_t itemsize = static_cast<int64_t>(view->itemsize);
     for (size_t i = 0; i < (size_t) view->ndim; ++i) {
-        strides[i] = (int64_t) (view->strides[i] / view->itemsize);
+        int64_t stride = view->strides[i] / itemsize;
+        if (stride * itemsize != view->strides[i]) {
+            PyBuffer_Release(view.get());
+            return nullptr;
+        }
+        strides[i] = stride;
         shape[i] = (int64_t) view->shape[i];
     }
 
     mt->manager_ctx = view.release();
     mt->dltensor.shape = shape.release();
     mt->dltensor.strides = strides.release();
 
@@ -281,25 +287,26 @@
         } else {
             PyErr_Clear();
         }
     });
 }
 
 bool ndarray_check(PyObject *o) noexcept {
+    if (PyObject_HasAttrString(o, "__dlpack__") || PyObject_CheckBuffer(o))
+        return true;
+
     PyTypeObject *tp = Py_TYPE(o);
 
     PyObject *name = nb_type_name((PyObject *) tp);
     check(name, "Could not obtain type name! (1)");
 
     const char *tp_name = PyUnicode_AsUTF8AndSize(name, nullptr);
     check(tp_name, "Could not obtain type name! (2)");
 
     bool result =
-        // NumPy
-        strcmp(tp_name, "ndarray") == 0 ||
         // PyTorch
         strcmp(tp_name, "torch.Tensor") == 0 ||
         // XLA
         strcmp(tp_name, "jaxlib.xla_extension.ArrayImpl") == 0 ||
         // Tensorflow
         strcmp(tp_name, "tensorflow.python.framework.ops.EagerTensor") == 0;
 
@@ -371,15 +378,15 @@
 
     if (req->req_shape) {
         pass_shape &= req->ndim == (uint32_t) t.ndim;
 
         if (pass_shape) {
             for (uint32_t i = 0; i < req->ndim; ++i) {
                 if (req->shape[i] != (size_t) t.shape[i] &&
-                    req->shape[i] != nanobind::any) {
+                    req->shape[i] != (size_t) -1) {
                     pass_shape = false;
                     break;
                 }
             }
         }
     }
 
@@ -408,15 +415,15 @@
             pass_order = false;
         }
 
         if (req->req_order && size != 0) { // Tolerate any strides if empty
             if (!t.strides) {
                 /* The provided tensor does not have a valid strides
                    field, which implies a C-style ordering. */
-                pass_order = req->req_order == 'C';
+                pass_order = req->req_order == 'C' || size == 1;
             } else {
                 for (size_t i = 0; i < (size_t) t.ndim; ++i) {
                     if (t.shape[i] != 1 && strides[i] != t.strides[i]) {
                         pass_order = false;
                         break;
                     }
                 }
@@ -630,15 +637,15 @@
 
     if (mt)
         ndarray_dec_ref((ndarray_handle *) mt->manager_ctx);
     else
         PyErr_Clear();
 }
 
-PyObject *ndarray_wrap(ndarray_handle *th, int framework,
+PyObject *ndarray_wrap(ndarray_handle *th, ndarray_framework framework,
                        rv_policy policy, cleanup_list *cleanup) noexcept {
     if (!th)
         return none().release().ptr();
 
     bool copy;
     switch (policy) {
         case rv_policy::reference_internal:
@@ -675,15 +682,15 @@
             Py_INCREF(th->self);
             return th->self;
         } else if (policy == rv_policy::none) {
             return nullptr;
         }
     }
 
-    if ((ndarray_framework) framework == ndarray_framework::numpy) {
+    if (framework == ndarray_framework::numpy) {
         try {
             nb_ndarray *h = PyObject_New(nb_ndarray, nd_ndarray_tp());
             if (!h)
                 return nullptr;
             h->th = th;
             ndarray_inc_ref(th);
 
@@ -698,45 +705,43 @@
                          "convert ndarray to NumPy array: %s", e.what());
             return nullptr;
         }
     }
 
     object package;
     try {
-        switch ((ndarray_framework) framework) {
+        switch (framework) {
             case ndarray_framework::none:
                 break;
 
             case ndarray_framework::pytorch:
                 package = module_::import_("torch.utils.dlpack");
                 break;
 
-
             case ndarray_framework::tensorflow:
                 package = module_::import_("tensorflow.experimental.dlpack");
                 break;
 
             case ndarray_framework::jax:
                 package = module_::import_("jax.dlpack");
                 break;
 
-
             default:
                 check(false, "nanobind::detail::ndarray_wrap(): unknown "
                              "framework specified!");
         }
     } catch (const std::exception &e) {
         PyErr_Format(PyExc_RuntimeError,
                      "nanobind::detail::ndarray_wrap(): could not import ndarray "
                      "framework: %s", e.what());
         return nullptr;
     }
 
     object o;
-    if (copy && (ndarray_framework) framework == ndarray_framework::none && th->self) {
+    if (copy && framework == ndarray_framework::none && th->self) {
         o = borrow(th->self);
     } else {
         o = steal(PyCapsule_New(th->ndarray, "dltensor",
                                        ndarray_capsule_destructor));
         ndarray_inc_ref(th);
     }
```

## nanobind/src/nb_static_property.cpp

 * *Ordering differences only*

```diff
@@ -52,9 +52,9 @@
         internals->nb_static_property = tp;
         internals->nb_static_property_descr_set = nb_static_property_descr_set;
     }
 
     return tp;
 }
 
-NAMESPACE_END(NB_NAMESPACE)
 NAMESPACE_END(detail)
+NAMESPACE_END(NB_NAMESPACE)
```

## nanobind/src/nb_type.cpp

```diff
@@ -32,14 +32,19 @@
     Py_ssize_t weaklistoffset = nb_type_data(tp)->weaklistoffset;
 #else
     Py_ssize_t weaklistoffset = tp->tp_weaklistoffset;
 #endif
     return weaklistoffset ? (PyObject **) ((uint8_t *) self + weaklistoffset) : nullptr;
 }
 
+static PyGetSetDef inst_getset[] = {
+    { "__dict__", PyObject_GenericGetDict, PyObject_GenericSetDict, nullptr, nullptr },
+    { nullptr, nullptr, nullptr, nullptr, nullptr }
+};
+
 static int inst_clear(PyObject *self) {
     PyObject **dict = nb_dict_ptr(self);
     if (dict)
         Py_CLEAR(*dict);
     return 0;
 }
 
@@ -78,15 +83,15 @@
 
         if (NB_UNLIKELY(align > sizeof(void *)))
             payload = (payload + align - 1) / align * align;
 
         self->offset = (int32_t) ((intptr_t) payload - (intptr_t) self);
         self->direct = 1;
         self->internal = 1;
-        self->ready = 0;
+        self->state = nb_inst::state_uninitialized;
         self->destruct = 0;
         self->cpp_delete = 0;
         self->clear_keep_alive = 0;
         self->intrusive = intrusive;
         self->unused = 0;
 
         // Update hash table that maps from C++ to Python instance
@@ -139,15 +144,15 @@
 
     const type_data *t = nb_type_data(tp);
     bool intrusive = t->flags & (uint32_t) type_flags::intrusive_ptr;
 
     self->offset = offset;
     self->direct = direct;
     self->internal = 0;
-    self->ready = 0;
+    self->state = nb_inst::state_uninitialized;
     self->destruct = 0;
     self->cpp_delete = 0;
     self->clear_keep_alive = 0;
     self->intrusive = intrusive;
     self->unused = 0;
 
     // Update hash table that maps from C++ to Python instance
@@ -191,15 +196,15 @@
     PyTypeObject *tp = Py_TYPE(self);
     const type_data *t = nb_type_data(tp);
 
     bool gc = PyType_HasFeature(tp, Py_TPFLAGS_HAVE_GC);
     if (NB_UNLIKELY(gc)) {
         PyObject_GC_UnTrack(self);
 
-        if (t->flags & (uint32_t)type_flags::has_dynamic_attr) {
+        if (t->flags & (uint32_t) type_flags::has_dynamic_attr) {
             PyObject **dict = nb_dict_ptr(self);
             if (dict)
                 Py_CLEAR(*dict);
         }
     }
 
     if (t->flags & (uint32_t) type_flags::is_weak_referenceable &&
@@ -228,45 +233,49 @@
         if (NB_LIKELY(t->align <= (uint32_t) __STDCPP_DEFAULT_NEW_ALIGNMENT__))
             operator delete(p);
         else
             operator delete(p, std::align_val_t(t->align));
     }
 
     if (NB_UNLIKELY(inst->clear_keep_alive)) {
+        size_t self_hash = ptr_hash()(self);
         nb_ptr_map &keep_alive = internals->keep_alive;
-        nb_ptr_map::iterator it = keep_alive.find(self);
+        nb_ptr_map::iterator it = keep_alive.find(self, self_hash);
         check(it != keep_alive.end(),
               "nanobind::detail::inst_dealloc(\"%s\"): inconsistent "
               "keep_alive information", t->name);
 
         nb_weakref_seq *s = (nb_weakref_seq *) it->second;
-        keep_alive.erase(it);
+        keep_alive.erase_fast(it);
+
         do {
             nb_weakref_seq *c = s;
             s = c->next;
 
             if (c->callback)
                 c->callback(c->payload);
             else
                 Py_DECREF((PyObject *) c->payload);
 
             PyObject_Free(c);
         } while (s);
     }
 
+    size_t p_hash = ptr_hash()(p);
+
     // Update hash table that maps from C++ to Python instance
     nb_ptr_map &inst_c2p = internals->inst_c2p;
-    nb_ptr_map::iterator it = inst_c2p.find(p);
+    nb_ptr_map::iterator it = inst_c2p.find(p, p_hash);
     bool found = false;
 
     if (NB_LIKELY(it != inst_c2p.end())) {
         void *entry = it->second;
         if (NB_LIKELY(entry == inst)) {
             found = true;
-            inst_c2p.erase(it);
+            inst_c2p.erase_fast(it);
         } else if (nb_is_seq(entry)) {
             // Multiple objects are associated with this address. Find the right one!
             nb_inst_seq *seq = nb_get_seq(entry),
                         *pred = nullptr;
 
             do {
                 if ((nb_inst *) seq->inst == inst) {
@@ -274,15 +283,15 @@
 
                     if (pred) {
                         pred->next = seq->next;
                     } else {
                         if (seq->next)
                             it.value() = nb_mark_seq(seq->next);
                         else
-                            inst_c2p.erase(it);
+                            inst_c2p.erase_fast(it);
                     }
 
                     PyMem_Free(seq);
                     break;
                 }
 
                 pred = seq;
@@ -292,15 +301,15 @@
     }
 
     check(found,
           "nanobind::detail::inst_dealloc(\"%s\"): attempted to delete an "
           "unknown instance (%p)!", t->name, p);
 
     if (NB_UNLIKELY(gc))
-        NB_SLOT(PyType_Type, tp_free)(self);
+        PyObject_GC_Del(self);
     else
         PyObject_Free(self);
 
     Py_DECREF(tp);
 }
 
 type_data *nb_type_c2p(nb_internals *internals_,
@@ -324,57 +333,53 @@
         type_c2p_fast[type] = d;
         return d;
     }
 
     return nullptr;
 }
 
-static void nb_type_dealloc(PyObject *o) {
-    type_data *t = nb_type_data((PyTypeObject *) o);
-
-    if (t->type && (t->flags & (uint32_t) type_flags::is_python_type) == 0) {
-        nb_type_map_slow &type_c2p_slow = internals->type_c2p_slow;
-        nb_type_map_fast &type_c2p_fast = internals->type_c2p_fast;
-
-        nb_type_map_slow::iterator it_slow = type_c2p_slow.find(t->type);
-        nb_type_map_fast::iterator it_fast = type_c2p_fast.find(t->type);
-
-        bool fail = it_slow == type_c2p_slow.end() ||
-                    it_fast == type_c2p_fast.end();
-
-        if (!fail) {
-            type_c2p_slow.erase(it_slow);
-            type_c2p_fast.erase(it_fast);
-
-            nb_alias_chain *cur = t->alias_chain;
-            while (cur) {
-                nb_alias_chain *next = cur->next;
-                it_fast = type_c2p_fast.find(cur->value);
-                if (it_fast == type_c2p_fast.end()) {
-                    fail = true;
-                    break;
-                }
-                type_c2p_fast.erase(it_fast);
-                PyMem_Free(cur);
-                cur = next;
+void nb_type_unregister(type_data *t) noexcept {
+    nb_type_map_slow &type_c2p_slow = internals->type_c2p_slow;
+    nb_type_map_fast &type_c2p_fast = internals->type_c2p_fast;
+
+    size_t n_del_slow = type_c2p_slow.erase(t->type),
+           n_del_fast = type_c2p_fast.erase(t->type);
+
+    bool fail = n_del_fast != 1 || n_del_slow != 1;
+    if (!fail) {
+        nb_alias_chain *cur = t->alias_chain;
+        while (cur) {
+            nb_alias_chain *next = cur->next;
+            n_del_fast = type_c2p_fast.erase(cur->value);
+            if (n_del_fast != 1) {
+                fail = true;
+                break;
             }
+            PyMem_Free(cur);
+            cur = next;
         }
-
-        check(!fail,
-              "nanobind::detail::nb_type_dealloc(\"%s\"): could not "
-              "find type!", t->name);
     }
 
+    check(!fail,
+          "nanobind::detail::nb_type_unregister(\"%s\"): could not "
+          "find type!", t->name);
+}
+
+static void nb_type_dealloc(PyObject *o) {
+    type_data *t = nb_type_data((PyTypeObject *) o);
+
+    if (t->type && (t->flags & (uint32_t) type_flags::is_python_type) == 0)
+        nb_type_unregister(t);
+
     if (t->flags & (uint32_t) type_flags::has_implicit_conversions) {
-        free(t->implicit);
-        free(t->implicit_py);
+        free(t->implicit.cpp);
+        free(t->implicit.py);
     }
 
     free((char *) t->name);
-
     NB_SLOT(PyType_Type, tp_dealloc)(o);
 }
 
 /// Called when a C++ type is extended from within Python
 static int nb_type_init(PyObject *self, PyObject *args, PyObject *kwds) {
     if (NB_TUPLE_GET_SIZE(args) != 3) {
         PyErr_SetString(PyExc_RuntimeError,
@@ -411,16 +416,16 @@
     *t = *t_b;
     t->flags |=  (uint32_t) type_flags::is_python_type;
     t->flags &= ~((uint32_t) type_flags::has_implicit_conversions);
     PyObject *name = nb_type_name(self);
     t->name = strdup_check(PyUnicode_AsUTF8AndSize(name, nullptr));
     Py_DECREF(name);
     t->type_py = (PyTypeObject *) self;
-    t->implicit = nullptr;
-    t->implicit_py = nullptr;
+    t->implicit.cpp = nullptr;
+    t->implicit.py = nullptr;
     t->alias_chain = nullptr;
 
     return 0;
 }
 
 /// Special case to handle 'Class.property = value' assignments
 static int nb_type_setattro(PyObject* obj, PyObject* name, PyObject* value) {
@@ -621,15 +626,15 @@
 
     const char *name = strrchr(spec->name, '.');
     if (name)
         name++;
     else
         name = spec->name;
 
-    PyObject *name_o = PyUnicode_FromString(name);
+    PyObject *name_o = PyUnicode_InternFromString(name);
     if (!name_o)
         return nullptr;
 
     const char *name_cstr = PyUnicode_AsUTF8AndSize(name_o, nullptr);
     if (!name_cstr) {
         Py_DECREF(name_o);
         return nullptr;
@@ -783,36 +788,91 @@
 
         Py_DECREF(tp);
     }
 
     return tp;
 }
 
+// This helper function extracts the function/class name from a custom signature attribute
+NB_NOINLINE char *extract_name(const char *cmd, const char *prefix, const char *s) {
+    (void) cmd;
+
+    // Move to the last line
+    const char *p = strrchr(s, '\n');
+    p = p ? (p + 1) : s;
+
+    // Check that the last line starts with the right prefix
+    size_t prefix_len = strlen(prefix);
+    check(strncmp(p, prefix, prefix_len) == 0,
+          "%s(): last line of custom signature \"%s\" must start with \"%s\"!",
+          cmd, s, prefix);
+    p += prefix_len;
+
+    // Find the opening parenthesis
+    const char *p2 = strchr(p, '(');
+    check(p2 != nullptr,
+          "%s(): last line of custom signature \"%s\" must contain an opening "
+          "parenthesis (\"(\")!", cmd, s);
+
+    // A few sanity checks
+    size_t len = strlen(p);
+    char last = p[len ? (len - 1) : 0];
+
+    check(last != ':' && last != ' ',
+          "%s(): custom signature \"%s\" should not end with \":\" or \" \"!", cmd, s);
+    check((p2 == p || (p[0] != ' ' && p2[-1] != ' ')),
+          "%s(): custom signature \"%s\" contains leading/trailing space around name!", cmd, s);
+
+    size_t size = p2 - p;
+    char *result = (char *) malloc_check(size + 1);
+    memcpy(result, p, size);
+    result[size] = '\0';
+
+    return result;
+}
+
+#if PY_VERSION_HEX >= 0x03090000
+static PyMethodDef class_getitem_method[] = {
+    { "__class_getitem__", Py_GenericAlias, METH_O | METH_CLASS, nullptr },
+    { nullptr }
+};
+#endif
+
 /// Called when a C++ type is bound via nb::class_<>
 PyObject *nb_type_new(const type_init_data *t) noexcept {
     bool has_doc               = t->flags & (uint32_t) type_init_flags::has_doc,
          has_base              = t->flags & (uint32_t) type_init_flags::has_base,
          has_base_py           = t->flags & (uint32_t) type_init_flags::has_base_py,
          has_type_slots        = t->flags & (uint32_t) type_init_flags::has_type_slots,
          has_supplement        = t->flags & (uint32_t) type_init_flags::has_supplement,
          has_dynamic_attr      = t->flags & (uint32_t) type_flags::has_dynamic_attr,
          is_weak_referenceable = t->flags & (uint32_t) type_flags::is_weak_referenceable,
+         is_generic            = t->flags & (uint32_t) type_flags::is_generic,
          intrusive_ptr         = t->flags & (uint32_t) type_flags::intrusive_ptr,
-         has_shared_from_this  = t->flags & (uint32_t) type_flags::has_shared_from_this;
+         has_shared_from_this  = t->flags & (uint32_t) type_flags::has_shared_from_this,
+         has_signature         = t->flags & (uint32_t) type_flags::has_signature;
+
+    const char *t_name = t->name;
+    if (has_signature)
+        t_name =
+            extract_name("nanobind::detail::nb_type_new", "class ", t->name);
 
-    str name(t->name), qualname = name;
+    str name = steal<str>(PyUnicode_InternFromString(t_name)),
+        qualname = name;
     object modname;
     PyObject *mod = nullptr;
 
     // Update hash table that maps from std::type_info to Python type
     auto [it, success] = internals->type_c2p_slow.try_emplace(t->type, nullptr);
     if (!success) {
-        PyErr_WarnFormat(PyExc_RuntimeWarning, 1, "nanobind: type '%s' was already registered!\n", t->name);
+        PyErr_WarnFormat(PyExc_RuntimeWarning, 1, "nanobind: type '%s' was already registered!\n", t_name);
         PyObject *tp = (PyObject *) it->second->type_py;
         Py_INCREF(tp);
+        if (has_signature)
+            free((char *) t_name);
         return tp;
     }
 
     if (t->scope != nullptr) {
         if (PyModule_Check(t->scope)) {
             mod = t->scope;
             modname = getattr(t->scope, "__name__", handle());
@@ -832,27 +892,43 @@
 
     constexpr size_t ptr_size = sizeof(void *);
     size_t basicsize = sizeof(nb_inst) + t->size;
     if (t->align > ptr_size)
         basicsize += t->align - ptr_size;
 
     PyObject *base = nullptr;
+
+#if PY_VERSION_HEX >= 0x03090000
+    bool generic_base = false;
+#endif
+
     if (has_base_py) {
         check(!has_base,
               "nanobind::detail::nb_type_new(\"%s\"): multiple base types "
-              "specified!", t->name);
+              "specified!", t_name);
         base = (PyObject *) t->base_py;
+
+        #if PY_VERSION_HEX >= 0x03090000 && !defined(PYPY_VERSION) // see https://github.com/pypy/pypy/issues/4914
+        if (Py_TYPE(base) == &Py_GenericAliasType) {
+            base = PyObject_GetAttrString(base, "__origin__");
+            check(base != nullptr,
+                  "nanobind::detail::nb_type_new(\"%s\"): could not access base of type alias!", t_name);
+            Py_DECREF(base);
+            generic_base = true;
+        }
+        #endif
+
         check(nb_type_check(base),
               "nanobind::detail::nb_type_new(\"%s\"): base type is not a "
-              "nanobind type!", t->name);
+              "nanobind type!", t_name);
     } else if (has_base) {
         nb_type_map_slow::iterator it2 = internals->type_c2p_slow.find(t->base);
         check(it2 != internals->type_c2p_slow.end(),
                   "nanobind::detail::nb_type_new(\"%s\"): base type \"%s\" not "
-                  "known to nanobind!", t->name, type_name(t->base));
+                  "known to nanobind!", t_name, type_name(t->base));
         base = (PyObject *) it2->second->type_py;
     }
 
     type_data *tb = nullptr;
     if (base) {
         // Check if the base type already has dynamic attributes
         tb = nb_type_data((PyTypeObject *) base);
@@ -899,36 +975,29 @@
     *s++ = { Py_tp_dealloc, (void *) inst_dealloc };
 
     if (has_doc)
         *s++ = { Py_tp_doc, (void *) t->doc };
 
     if (has_type_slots) {
         size_t num_avail = nb_extra_slots;
-        if (t->type_slots_callback) {
-            PyType_Slot* first_new = s;
-            t->type_slots_callback(t, s, num_avail);
-            check(first_new + num_avail >= s,
-                  "nanobind::detail::nb_type_new(\"%s\"): type_slots_callback "
-                  "overflowed the slots array!", t->name);
-            num_avail -= (s - first_new);
-        }
-        if (t->type_slots) {
-            size_t i = 0;
-            while (t->type_slots[i].slot) {
-                check(i != num_avail,
-                      "nanobind::detail::nb_type_new(\"%s\"): ran out of "
-                      "type slots!", t->name);
-                *s++ = t->type_slots[i++];
-            }
+        size_t i = 0;
+        while (t->type_slots[i].slot) {
+            check(i != num_avail,
+                  "nanobind::detail::nb_type_new(\"%s\"): ran out of "
+                  "type slots!", t_name);
+            *s++ = t->type_slots[i++];
         }
     }
 
     bool has_traverse = false;
-    for (PyType_Slot *ts = slots; ts != s; ++ts)
+    bool has_getset = false;
+    for (PyType_Slot *ts = slots; ts != s; ++ts) {
         has_traverse |= ts->slot == Py_tp_traverse;
+        has_getset |= ts->slot == Py_tp_getset;
+    }
 
     Py_ssize_t dictoffset = 0, weaklistoffset = 0;
     int num_members = 0;
 
     // realign to sizeof(void*) if needed
     if (has_dynamic_attr || is_weak_referenceable)
         basicsize = (basicsize + ptr_size - 1) / ptr_size * ptr_size;
@@ -944,14 +1013,18 @@
         // Install GC traverse and clear routines if not inherited/overridden
         if (!has_traverse) {
             *s++ = { Py_tp_traverse, (void *) inst_traverse };
             *s++ = { Py_tp_clear, (void *) inst_clear };
             has_traverse = true;
         }
         spec.basicsize = (int) basicsize;
+
+        if (!has_getset) {
+            *s++ = { Py_tp_getset, (void *) inst_getset };
+        }
     }
 
     if (is_weak_referenceable) {
         weaklistoffset = (Py_ssize_t) basicsize;
         basicsize += ptr_size;
 
         members[num_members] = PyMemberDef{ "__weaklistoffset__", T_PYSSIZET,
@@ -964,29 +1037,36 @@
             *s++ = { Py_tp_clear, (void *) inst_clear };
             has_traverse = true;
         }
         spec.basicsize = (int) basicsize;
     }
 
     if (num_members > 0)
-        *s++ = { Py_tp_members, (void*)members };
+        *s++ = { Py_tp_members, (void*) members };
+
+#if PY_VERSION_HEX < 0x03090000
+    (void) is_generic; // unsupported on Python 3.8
+#else
+    if (is_generic)
+        *s++ = { Py_tp_methods, (void*) class_getitem_method };
+#endif
 
     if (has_traverse)
         spec.flags |= Py_TPFLAGS_HAVE_GC;
 
     *s++ = { 0, nullptr };
 
     PyTypeObject *metaclass = nb_type_tp(has_supplement ? t->supplement : 0);
 
     PyObject *result = nb_type_from_metaclass(metaclass, mod, &spec);
     if (!result) {
         python_error err;
         check(false,
               "nanobind::detail::nb_type_new(\"%s\"): type construction "
-              "failed: %s!", t->name, err.what());
+              "failed: %s!", t_name, err.what());
     }
 
     type_data *to = nb_type_data((PyTypeObject *) result);
     *to = *t; // note: slices off _init parts
     to->flags &= ~(uint32_t) type_init_flags::all_init_flags;
 
     if (!intrusive_ptr && base_intrusive_ptr) {
@@ -1015,81 +1095,93 @@
         to->flags |= (uint32_t) type_flags::is_weak_referenceable;
         #if defined(Py_LIMITED_API)
             to->weaklistoffset = weaklistoffset;
         #endif
     }
 
     if (t->scope != nullptr)
-        setattr(t->scope, t->name, result);
+        setattr(t->scope, t_name, result);
 
     setattr(result, "__qualname__", qualname.ptr());
 
     if (modname.is_valid())
         setattr(result, "__module__", modname.ptr());
 
     internals->type_c2p_fast[t->type] = to;
     internals->type_c2p_slow[t->type] = to;
 
+    if (has_signature) {
+        setattr(result, "__nb_signature__", str(t->name));
+        free((char *) t_name);
+    }
+
+#if PY_VERSION_HEX >= 0x03090000
+    if (generic_base)
+        setattr(result, "__orig_bases__", make_tuple(handle(t->base_py)));
+#endif
+
+    return result;
+}
+
+
+PyObject *call_one_arg(PyObject *fn, PyObject *arg) noexcept {
+    PyObject *result;
+#if PY_VERSION_HEX < 0x03090000
+    PyObject *args = PyTuple_New(1);
+    if (!args)
+        return nullptr;
+    Py_INCREF(arg);
+    NB_TUPLE_SET_ITEM(args, 0, arg);
+    result = PyObject_CallObject(fn, args);
+    Py_DECREF(args);
+#else
+    PyObject *args[2] = { nullptr, arg };
+    result = PyObject_Vectorcall(fn, args + 1, NB_VECTORCALL_ARGUMENTS_OFFSET + 1, nullptr);
+#endif
     return result;
 }
 
 /// Encapsulates the implicit conversion part of nb_type_get()
 static NB_NOINLINE bool nb_type_get_implicit(PyObject *src,
                                              const std::type_info *cpp_type_src,
                                              const type_data *dst_type,
                                              nb_internals *internals_,
                                              cleanup_list *cleanup, void **out) noexcept {
-    if (dst_type->implicit && cpp_type_src) {
-        const std::type_info **it = dst_type->implicit;
+    if (dst_type->implicit.cpp && cpp_type_src) {
+        const std::type_info **it = dst_type->implicit.cpp;
         const std::type_info *v;
 
         while ((v = *it++)) {
             if (v == cpp_type_src || *v == *cpp_type_src)
                 goto found;
         }
 
-        it = dst_type->implicit;
+        it = dst_type->implicit.cpp;
         while ((v = *it++)) {
             const type_data *d = nb_type_c2p(internals_, v);
             if (d && PyType_IsSubtype(Py_TYPE(src), d->type_py))
                 goto found;
         }
     }
 
-    if (dst_type->implicit_py) {
+    if (dst_type->implicit.py) {
         bool (**it)(PyTypeObject *, PyObject *, cleanup_list *) noexcept =
-            dst_type->implicit_py;
+            dst_type->implicit.py;
         bool (*v2)(PyTypeObject *, PyObject *, cleanup_list *) noexcept;
 
         while ((v2 = *it++)) {
             if (v2(dst_type->type_py, src, cleanup))
                 goto found;
         }
     }
 
     return false;
 
 found:
-
-    PyObject *result;
-#if PY_VERSION_HEX < 0x03090000
-    PyObject *args = PyTuple_New(1);
-    if (!args) {
-        PyErr_Clear();
-        return false;
-    }
-    Py_INCREF(src);
-    NB_TUPLE_SET_ITEM(args, 0, src);
-    result = PyObject_CallObject((PyObject *) dst_type->type_py, args);
-    Py_DECREF(args);
-#else
-    PyObject *args[2] = { nullptr, src };
-    result = PyObject_Vectorcall((PyObject *) dst_type->type_py, args + 1,
-                                 NB_VECTORCALL_ARGUMENTS_OFFSET + 1, nullptr);
-#endif
+    PyObject *result = call_one_arg((PyObject *) dst_type->type_py, src);
 
     if (result) {
         cleanup->append(result);
         *out = inst_ptr((nb_inst *) result);
         return true;
     } else {
         PyErr_Clear();
@@ -1117,15 +1209,15 @@
 
 // Attempt to retrieve a pointer to a C++ instance
 bool nb_type_get(const std::type_info *cpp_type, PyObject *src, uint8_t flags,
                  cleanup_list *cleanup, void **out) noexcept {
     // Convert None -> nullptr
     if (src == Py_None) {
         *out = nullptr;
-        return (flags & (uint8_t) cast_flags::none_disallowed) == 0;
+        return true;
     }
 
     PyTypeObject *src_type = Py_TYPE(src);
     const std::type_info *cpp_type_src = nullptr;
     const bool src_is_nb_type = nb_type_check((PyObject *) src_type);
 
     type_data *dst_type = nullptr;
@@ -1146,21 +1238,36 @@
                 valid = PyType_IsSubtype(src_type, dst_type->type_py);
         }
 
         // Success, return the pointer if the instance is correctly initialized
         if (NB_LIKELY(valid)) {
             nb_inst *inst = (nb_inst *) src;
 
-            if (NB_UNLIKELY(((flags & (uint8_t) cast_flags::construct) != 0) == (bool) inst->ready)) {
+            static_assert(cast_flags::construct == nb_inst::state_ready,
+                          "this function is optimized assuming that "
+                          "cast_flags::construct == nb_inst::state_ready");
+
+            // (flags & construct)       state  xor-result  should accept?
+            //          [normal] 0  [uninit] 0  0           no
+            //          [normal] 0  [relinq] 1  1           no
+            //          [normal] 0   [ready] 2  2           yes
+            //       [construct] 2  [uninit] 0  2           yes
+            //       [construct] 2  [relinq] 1  3           no
+            //       [construct] 2   [ready] 2  0           no
+
+            if (NB_UNLIKELY(((flags & (uint8_t) cast_flags::construct) ^ inst->state) != nb_inst::state_ready)) {
+                constexpr const char* errors[4] = {
+                    /* 0=uninit */ "attempted to access an uninitialized instance",
+                    /* 1=relinq */ "attempted to access a relinquished instance",
+                    /* 2=ready */ "attempted to initialize an already-initialized instance",
+                    /* 3=invalid */ "instance state has become corrupted",
+                };
                 PyErr_WarnFormat(
                     PyExc_RuntimeWarning, 1, "nanobind: %s of type '%s'!\n",
-                    inst->ready
-                        ? "attempted to initialize an already-initialized instance"
-                        : "attempted to access an uninitialized instance",
-                    t->name);
+                    errors[inst->state], t->name);
                 return false;
             }
 
             *out = inst_ptr(inst);
 
             return true;
         }
@@ -1340,15 +1447,15 @@
         !create_new && t->keep_shared_from_this_alive((PyObject *) inst))
         rvp = rv_policy::reference;
     else if (is_new)
         *is_new = true;
 
     inst->destruct = rvp != rv_policy::reference && rvp != rv_policy::reference_internal;
     inst->cpp_delete = rvp == rv_policy::take_ownership;
-    inst->ready = true;
+    inst->state = nb_inst::state_ready;
 
     if (rvp == rv_policy::reference_internal)
         keep_alive((PyObject *) inst, cleanup->self());
 
     if (intrusive)
         t->set_self_py(new_value, (PyObject *) inst);
 
@@ -1519,28 +1626,31 @@
           "nanobind::detail::nb_type_put_unique(type='%s', cpp_delete=%i): "
           "ownership status has become corrupted.",
           type_name(cpp_type), cpp_delete);
 
     nb_inst *inst = (nb_inst *) o;
 
     if (cpp_delete) {
-        check((bool) inst->ready == is_new && (bool) inst->destruct == is_new &&
+        check(inst->state == (is_new ? nb_inst::state_ready
+                                     : nb_inst::state_relinquished) &&
+                  (bool) inst->destruct == is_new &&
                   (bool) inst->cpp_delete == is_new,
               "nanobind::detail::nb_type_put_unique(type='%s', cpp_delete=%i): "
-              "unexpected status flags! (ready=%i, destruct=%i, cpp_delete=%i)",
-              type_name(cpp_type), cpp_delete, inst->ready, inst->destruct,
+              "unexpected status flags! (state=%i, destruct=%i, cpp_delete=%i)",
+              type_name(cpp_type), cpp_delete, inst->state, inst->destruct,
               inst->cpp_delete);
 
-        inst->ready = inst->destruct = inst->cpp_delete = true;
+        inst->state = nb_inst::state_ready;
+        inst->destruct = inst->cpp_delete = true;
     } else {
-        check(!inst->ready,
+        check(inst->state == nb_inst::state_relinquished,
                   "nanobind::detail::nb_type_put_unique('%s'): ownership "
                   "status has become corrupted.", type_name(cpp_type));
 
-        inst->ready = true;
+        inst->state = nb_inst::state_ready;
     }
 }
 
 PyObject *nb_type_put_unique(const std::type_info *cpp_type,
                              void *value,
                              cleanup_list *cleanup, bool cpp_delete) noexcept {
     rv_policy policy = cpp_delete ? rv_policy::take_ownership : rv_policy::none;
@@ -1566,45 +1676,75 @@
 
     if (o)
         nb_type_put_unique_finalize(o, cpp_type, cpp_delete, is_new);
 
     return o;
 }
 
-void nb_type_relinquish_ownership(PyObject *o, bool cpp_delete) {
+static void warn_relinquish_failed(const char *why, PyObject *o) noexcept {
+    PyObject *name = nb_inst_name(o);
+    int rc = PyErr_WarnFormat(
+        PyExc_RuntimeWarning, 1,
+        "nanobind::detail::nb_relinquish_ownership(): could not "
+        "transfer ownership of a Python instance of type '%U' to C++. %s",
+        name, why);
+    if (rc != 0) // user has configured warnings-as-errors
+        PyErr_WriteUnraisable(o);
+    Py_DECREF(name);
+}
+
+bool nb_type_relinquish_ownership(PyObject *o, bool cpp_delete) noexcept {
     nb_inst *inst = (nb_inst *) o;
 
-    // This function is called to indicate ownership *changes*
-    check(inst->ready,
-          "nanobind::detail::nb_relinquish_ownership('%s'): ownership "
-          "status has become corrupted.",
-          PyUnicode_AsUTF8AndSize(nb_inst_name(o), nullptr));
+    /* This function is called after nb_type_get() succeeds, so the instance
+       should be ready; but the !ready case is possible if an attempt is made to
+       transfer ownership of the same object to C++ multiple times as part of
+       the same data structure. For example, converting Python (foo, foo) to C++
+       std::pair<std::unique_ptr<T>, std::unique_ptr<T>>. */
+
+    if (inst->state != nb_inst::state_ready) {
+        warn_relinquish_failed(
+            "The resulting data structure would have multiple "
+            "std::unique_ptrs, each thinking that they own the same instance, "
+            "which is not allowed.", o);
+        return false;
+    }
 
     if (cpp_delete) {
         if (!inst->cpp_delete || !inst->destruct || inst->internal) {
-            PyObject *name = nb_inst_name(o);
-            PyErr_WarnFormat(
-                PyExc_RuntimeWarning, 1,
-                "nanobind::detail::nb_relinquish_ownership(): could not "
-                "transfer ownership of a Python instance of type '%U' to C++. "
+            warn_relinquish_failed(
                 "This is only possible when the instance was previously "
                 "constructed on the C++ side and is now owned by Python, which "
                 "was not the case here. You could change the unique pointer "
-                "signature to std::unique_ptr<T, nb::deleter<T>> to work around "
-                "this issue.", name);
-
-            Py_DECREF(name);
-            throw next_overload();
+                "signature to std::unique_ptr<T, nb::deleter<T>> to work "
+                "around this issue.", o);
+            return false;
         }
 
         inst->cpp_delete = false;
         inst->destruct = false;
     }
 
-    inst->ready = false;
+    inst->state = nb_inst::state_relinquished;
+    return true;
+}
+
+void nb_type_restore_ownership(PyObject *o, bool cpp_delete) noexcept {
+    nb_inst *inst = (nb_inst *) o;
+
+    check(inst->state == nb_inst::state_relinquished,
+          "nanobind::detail::nb_type_restore_ownership('%s'): ownership "
+          "status has become corrupted.",
+          PyUnicode_AsUTF8AndSize(nb_inst_name(o), nullptr));
+
+    inst->state = nb_inst::state_ready;
+    if (cpp_delete) {
+        inst->cpp_delete = true;
+        inst->destruct = true;
+    }
 }
 
 bool nb_type_isinstance(PyObject *o, const std::type_info *t) noexcept {
     type_data *d = nb_type_c2p(internals, t);
     if (d)
         return PyType_IsSubtype(Py_TYPE(o), d->type_py);
     else
@@ -1651,82 +1791,92 @@
 
 PyObject *nb_inst_reference(PyTypeObject *t, void *ptr, PyObject *parent) {
     PyObject *result = inst_new_ext(t, ptr);
     if (!result)
         raise_python_error();
     nb_inst *nbi = (nb_inst *) result;
     nbi->destruct = nbi->cpp_delete = false;
-    nbi->ready = true;
+    nbi->state = nb_inst::state_ready;
     if (parent)
         keep_alive(result, parent);
     return result;
 }
 
 PyObject *nb_inst_take_ownership(PyTypeObject *t, void *ptr) {
     PyObject *result = inst_new_ext(t, ptr);
     if (!result)
         raise_python_error();
     nb_inst *nbi = (nb_inst *) result;
     nbi->destruct = nbi->cpp_delete = true;
-    nbi->ready = true;
+    nbi->state = nb_inst::state_ready;
     return result;
 }
 
 void *nb_inst_ptr(PyObject *o) noexcept {
     return inst_ptr((nb_inst *) o);
 }
 
 void nb_inst_zero(PyObject *o) noexcept {
     nb_inst *nbi = (nb_inst *) o;
     type_data *td = nb_type_data(Py_TYPE(o));
     memset(inst_ptr(nbi), 0, td->size);
-    nbi->ready = nbi->destruct = true;
+    nbi->state = nb_inst::state_ready;
+    nbi->destruct = true;
 }
 
 PyObject *nb_inst_alloc_zero(PyTypeObject *t) {
     PyObject *result = inst_new_int(t);
     if (!result)
         raise_python_error();
     nb_inst *nbi = (nb_inst *) result;
     type_data *td = nb_type_data(t);
     memset(inst_ptr(nbi), 0, td->size);
-    nbi->ready = nbi->destruct = true;
+    nbi->state = nb_inst::state_ready;
+    nbi->destruct = true;
     return result;
 }
 
 void nb_inst_set_state(PyObject *o, bool ready, bool destruct) noexcept {
     nb_inst *nbi = (nb_inst *) o;
-    nbi->ready = ready;
+    nbi->state = ready ? nb_inst::state_ready : nb_inst::state_uninitialized;
     nbi->destruct = destruct;
     nbi->cpp_delete = destruct && !nbi->internal;
 }
 
 std::pair<bool, bool> nb_inst_state(PyObject *o) noexcept {
     nb_inst *nbi = (nb_inst *) o;
-    return { (bool) nbi->ready, (bool) nbi->destruct };
+    return { nbi->state == nb_inst::state_ready, (bool) nbi->destruct };
 }
 
 void nb_inst_destruct(PyObject *o) noexcept {
     nb_inst *nbi = (nb_inst *) o;
     type_data *t = nb_type_data(Py_TYPE(o));
 
+    check(nbi->state != nb_inst::state_relinquished,
+          "nanobind::detail::nb_inst_destruct(\"%s\"): attempted to destroy "
+          "an object whose ownership had been transferred away!",
+          t->name);
+
     if (nbi->destruct) {
         check(t->flags & (uint32_t) type_flags::is_destructible,
               "nanobind::detail::nb_inst_destruct(\"%s\"): attempted to call "
               "the destructor of a non-destructible type!",
               t->name);
         if (t->flags & (uint32_t) type_flags::has_destruct)
             t->destruct(inst_ptr(nbi));
         nbi->destruct = false;
     }
 
-    nbi->ready = false;
+    nbi->state = nb_inst::state_uninitialized;
 }
 
 void nb_inst_copy(PyObject *dst, const PyObject *src) noexcept {
+    if (src == dst)
+        return;
+
     PyTypeObject *tp = Py_TYPE((PyObject *) src);
     type_data *t = nb_type_data(tp);
 
     check(tp == Py_TYPE(dst) &&
               (t->flags & (uint32_t) type_flags::is_copy_constructible),
           "nanobind::detail::nb_inst_copy(): invalid arguments!");
 
@@ -1735,18 +1885,22 @@
     void *dst_data = inst_ptr(nbi);
 
     if (t->flags & (uint32_t) type_flags::has_copy)
         t->copy(dst_data, src_data);
     else
         memcpy(dst_data, src_data, t->size);
 
-    nbi->ready = nbi->destruct = true;
+    nbi->state = nb_inst::state_ready;
+    nbi->destruct = true;
 }
 
 void nb_inst_move(PyObject *dst, const PyObject *src) noexcept {
+    if (src == dst)
+        return;
+
     PyTypeObject *tp = Py_TYPE((PyObject *) src);
     type_data *t = nb_type_data(tp);
 
     check(tp == Py_TYPE(dst) &&
               (t->flags & (uint32_t) type_flags::is_move_constructible),
           "nanobind::detail::nb_inst_move(): invalid arguments!");
 
@@ -1757,27 +1911,32 @@
     if (t->flags & (uint32_t) type_flags::has_move) {
         t->move(dst_data, src_data);
     } else {
         memcpy(dst_data, src_data, t->size);
         memset(src_data, 0, t->size);
     }
 
-    nbi->ready = nbi->destruct = true;
+    nbi->state = nb_inst::state_ready;
+    nbi->destruct = true;
 }
 
 void nb_inst_replace_move(PyObject *dst, const PyObject *src) noexcept {
+    if (src == dst)
+        return;
     nb_inst *nbi = (nb_inst *) dst;
     bool destruct = nbi->destruct;
     nbi->destruct = true;
     nb_inst_destruct(dst);
     nb_inst_move(dst, src);
     nbi->destruct = destruct;
 }
 
 void nb_inst_replace_copy(PyObject *dst, const PyObject *src) noexcept {
+    if (src == dst)
+        return;
     nb_inst *nbi = (nb_inst *) dst;
     bool destruct = nbi->destruct;
     nbi->destruct = true;
     nb_inst_destruct(dst);
     nb_inst_copy(dst, src);
     nbi->destruct = destruct;
 }
```

## Comparing `nanobind-1.9.2.dist-info/LICENSE` & `nanobind-2.0.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `nanobind-1.9.2.dist-info/METADATA` & `nanobind-2.0.0.dist-info/METADATA`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: nanobind
-Version: 1.9.2
+Version: 2.0.0
 Summary: nanobind: tiny and efficient C++/Python bindings
 Home-page: https://github.com/wjakob/nanobind
 Author: Wenzel Jakob
 Author-email: wenzel.jakob@epfl.ch
 License: BSD
 Description-Content-Type: text/markdown
 License-File: LICENSE
```

## Comparing `nanobind-1.9.2.dist-info/RECORD` & `nanobind-2.0.0.dist-info/RECORD`

 * *Files 9% similar despite different names*

```diff
@@ -1,80 +1,84 @@
-nanobind/__init__.py,sha256=sGXThFZPRqU0P0GYIHtjxrsVJOpWWOVxbmmsmrUmcho,536
-nanobind/__main__.py,sha256=pOZfAi6HXCHLnzBZ0Ax1jJ-PbFDYJ-XP51yG5AgTmjA,839
-nanobind/cmake/darwin-ld-cpython.sym,sha256=0b19wSSxq_oOstAuyu_S148eag-ArNbuUaXqsdCePwc,21604
+nanobind/__init__.py,sha256=KLAKigsTXUkUVvmYEWRPlKdhqWZWbS4vYisFw3MaQk8,536
+nanobind/__main__.py,sha256=jOzPuAfyhatsLv0Brecum119Ibc93dfu33h3Ly_gLhI,855
+nanobind/stubgen.py,sha256=asfj0wNlicmPIBBtw2ZBRaipopwj9ojOWkPFJId-UDc,50666
+nanobind/cmake/darwin-ld-cpython.sym,sha256=nWMv0eYkljqSP4TaqhuYY_36DuG9muK4gzDqLpG7yPE,21656
 nanobind/cmake/darwin-ld-pypy.sym,sha256=W6jU_5etCgRqRZm5EHJBjvgQoUTIp8lxAD837IiVphY,24687
-nanobind/cmake/nanobind-config.cmake,sha256=ASLdgFrDri16YQRiScPe5pM_C4aGWivZ0UEhY5-wzd8,12296
-nanobind/ext/robin_map/include/tsl/robin_growth_policy.h,sha256=LJaMwboQYidGGoaldoAplZDcslLeT5sP6L8lZghVaDU,11776
-nanobind/ext/robin_map/include/tsl/robin_hash.h,sha256=9jsUsbV085jb736e5Z6MJIYUSvrwBpLYmagPsOTiglc,54550
-nanobind/ext/robin_map/include/tsl/robin_map.h,sha256=WQiZfe4hA3mzQLlJXDZQax0rWjctSnyJnB9jJJgeC6Y,28414
+nanobind/cmake/nanobind-config.cmake,sha256=Qm9Tv_Q0tR7zqz_k7igr_Ih1AwWm2Q8Yhe3CkIkAiUI,14995
+nanobind/ext/robin_map/include/tsl/robin_growth_policy.h,sha256=4GmPsjUNR-1WZK80V0MdyrwwBLGgNAOK5wTKsEvvIAs,12181
+nanobind/ext/robin_map/include/tsl/robin_hash.h,sha256=EGUYa1e5hKD_9kbJ94F2kvz-Ps6TbcNVE5Lh4OkLLyk,54606
+nanobind/ext/robin_map/include/tsl/robin_map.h,sha256=I7-W_pPcWuqbHgAtDfHLkfokzMv6dM4Fc_RLuoZdIKs,28770
 nanobind/include/nanobind/eval.h,sha256=dRG80Vz6sCPOzyrmG_2jR5IZ4oOwgnUE3HY8zVAyLSI,1939
-nanobind/include/nanobind/make_iterator.h,sha256=WKcEOQc_L_Mhhk1GgwwvsysUTbSgiBCmDnm0X7K330o,5601
-nanobind/include/nanobind/nanobind.h,sha256=oKGyny4PG6sfsYCJ16dWwObXdE0LZfnjL02ed9uMG0g,1628
+nanobind/include/nanobind/make_iterator.h,sha256=OZ6pWTjYdNEzuNV3s3EoaqWRD8PVlsc84lxPWlIb8ow,6738
+nanobind/include/nanobind/nanobind.h,sha256=4pBT1gVQ0CskzOvexIpNEuPjfkJt3vNzN35DF6P5jmI,1628
 nanobind/include/nanobind/nb_accessor.h,sha256=IYk3UCBjDMUvWqVZakZegs8oIfMXWqp5ZGTuY2b12b0,6228
-nanobind/include/nanobind/nb_attr.h,sha256=rDOCK024As9UgdEsNEdeHB8zbiJ5u31t8wLE_oNUvmo,9513
-nanobind/include/nanobind/nb_call.h,sha256=ERAXrFSw4-2HhAiQBEGrWs4jMRWePNwYCyYts3bAS1g,5471
-nanobind/include/nanobind/nb_cast.h,sha256=xIgSBMOq-n3fHR4PJV7oISBAr5bw3jBBG-0-tJUDMe8,17851
-nanobind/include/nanobind/nb_class.h,sha256=uPkfNt6eSi-h6Wvcxei_ZDJhdhKka2C6JCGq_Qre-is,25113
-nanobind/include/nanobind/nb_defs.h,sha256=iMhRKcb4xSIwdu43hQdsR01V9MLVQe98PrlOHOkNS20,6232
-nanobind/include/nanobind/nb_descr.h,sha256=tX2-_5kHTuIe62iGi0sqn-QehGNYGjcL32OmeWoYY2g,4129
+nanobind/include/nanobind/nb_attr.h,sha256=3637U2o1c5xdfmUp95UPfjScVZR0gxkTeUQp6Pq_gsA,10641
+nanobind/include/nanobind/nb_call.h,sha256=QTjsz-9pQ2dP5MGqV72ZwvQeQofMvf10bags5C8ij5k,5472
+nanobind/include/nanobind/nb_cast.h,sha256=bOPvwqw13oo0UppRRwqcxua1v8KhA3rsOhxm12A9CR0,25362
+nanobind/include/nanobind/nb_class.h,sha256=X_4ybglDA63ZXeqSWbmMHQQ9EyFlPEpg4YL8v8-Vhsg,29365
+nanobind/include/nanobind/nb_defs.h,sha256=PoPgd8Ef1_VvBQChTMI220bBSfo0WVoffXCQSLYUXOg,6855
+nanobind/include/nanobind/nb_descr.h,sha256=hgzZTGUqo1JVjRituEPD2xHkvs9mZFf_CiGdXvQAhIk,5130
 nanobind/include/nanobind/nb_enums.h,sha256=JSxGC4c2YyN83gmcTVV450KLJX_RTRPAHRPUhxuAvds,666
 nanobind/include/nanobind/nb_error.h,sha256=lT4KCQL_hbcQKCuz_DjVB_gNqDE1FTmAsCYtyQnoNDo,5207
-nanobind/include/nanobind/nb_func.h,sha256=FQwosIBVGMaaF7ZkQETf5l2ltSzZbVDOC0HwYyX_Oe8,10802
-nanobind/include/nanobind/nb_lib.h,sha256=uYzqFEI8S4PuqXijy_CbtWAQ0Q8pQ2dVfxc1nIKTv1s,21272
+nanobind/include/nanobind/nb_func.h,sha256=K5tslivWGFsrPeDepQQAbfGpNsoD0XbNDpLuGLkDja4,15280
+nanobind/include/nanobind/nb_lib.h,sha256=Ag92IO85Q_-1IXMYGEw6JjW5uJy1ihZwIl35AlJos-g,22139
 nanobind/include/nanobind/nb_misc.h,sha256=zzXk2DL9P2i-20jAH9o1o7Ou4vCRZWerPIDPnX_NaN4,1413
 nanobind/include/nanobind/nb_python.h,sha256=tuHjb9Dd4X5MOILJdgOFN_7RBIAAq3Y1bL_-POIRqKU,1377
-nanobind/include/nanobind/nb_traits.h,sha256=nznim9du7L8FTeew_Q5IXQTyCsoFYUwcutppCSKMNzc,7314
+nanobind/include/nanobind/nb_traits.h,sha256=xc-reZ8k9dXYAaH5WZ3RNkgIEW7VWQJskOkeqeMdlCs,8923
 nanobind/include/nanobind/nb_tuple.h,sha256=aqqTm9DkjH_SvDuPLKjU3Ya1lgs_LWyaQMkhTQRZoIc,2468
-nanobind/include/nanobind/nb_types.h,sha256=OILF5pm9T7BPxZXg3cRZi-eKERCslQmCVIjm49qHmTM,28452
-nanobind/include/nanobind/ndarray.h,sha256=JuL4zoUsDwL_ez_l63fT8tNyKS7ihJTh4wbxdMqG_ZE,20322
+nanobind/include/nanobind/nb_types.h,sha256=S8q2xlDS4HwGvWgFzYVaSvMYRKdqg-nu6ci5EIaKE5I,29798
+nanobind/include/nanobind/ndarray.h,sha256=FjoTFi4Nm3Wo1P90h3wWBPq8WtI6WEwlCcqIYSHo1kM,20407
 nanobind/include/nanobind/operators.h,sha256=jSHKzNE_NDc--E65ycUsU6b0x1O_ThpzzCMV4uv5IE4,7449
 nanobind/include/nanobind/trampoline.h,sha256=DsLGyZiFf5h54yVjhnqD4aACWI0gLZtEPujAH8aIeUs,2975
-nanobind/include/nanobind/eigen/dense.h,sha256=CydjJLrDLFQInurX6YAkFNhHJ7_0nSlmaXPFJ95Lf9A,17889
-nanobind/include/nanobind/eigen/sparse.h,sha256=0ptUA2-I8RZR7ff289x3ar7QQWxyGhY38BkH-oVJzKo,6505
+nanobind/include/nanobind/typing.h,sha256=ZJ9MxrTLUl1ETt2-OweqJxPQbTTxsicXc425v1Yyuu0,753
+nanobind/include/nanobind/eigen/dense.h,sha256=0YsH1yEThq4rM2rpMBWpdxTb4YA6IVQ5VsHpUg_Gq3s,18189
+nanobind/include/nanobind/eigen/sparse.h,sha256=eYxZxfrTG7cHnzYbE72hWbouuJ98_BxDb7F1eNTNM0c,6657
 nanobind/include/nanobind/intrusive/counter.h,sha256=46Xcd2U-9LteV7o41h425pDYXED7BiyPfp2sWg9zeTU,8884
 nanobind/include/nanobind/intrusive/counter.inl,sha256=Wz4Rhq-L3ySb1PaYl5hr3Lgofcp23fio1R2Azb8wLlE,4874
 nanobind/include/nanobind/intrusive/ref.h,sha256=cEAeGgTJRsp3EWiwli-xEr1fPoG4KXlkAG3nf52xu8c,4860
 nanobind/include/nanobind/stl/array.h,sha256=-jdVTy9gcqjH4kBVWbm52dGecHr90rwkusJX6ucHrII,535
-nanobind/include/nanobind/stl/bind_map.h,sha256=Lk3_TbUkqGiiUC6hQBCDIs26rB98z388FHHYQogktEg,5939
-nanobind/include/nanobind/stl/bind_vector.h,sha256=m8WMOgWlpS2656YnA1MyIDkABfDanXBd7NIQljwvBjU,7420
+nanobind/include/nanobind/stl/bind_map.h,sha256=o9XlK8FVufyebosfDNC5B4u1qRIPN_1qhrLHRtNk3lc,6234
+nanobind/include/nanobind/stl/bind_vector.h,sha256=6d8ydhvmQuCWzfxqD5KW5Ggc0fIeswdmSwtCaPhEX2g,7564
 nanobind/include/nanobind/stl/chrono.h,sha256=G6KN72M6NeeRkXxz8V_Y5eQlOM9-W6PvlEAyChDItLs,8673
-nanobind/include/nanobind/stl/complex.h,sha256=VzmwxKhfufDd9cPPoRAorXoP1xkv6we25e8rZluR4ME,2154
-nanobind/include/nanobind/stl/filesystem.h,sha256=aaIUfJk0lRpag2kQfQNXmgY3IjU6oKY5rckTzRm7zCM,2719
-nanobind/include/nanobind/stl/function.h,sha256=TO1OKwgsMoQiGRmVGHLenM90ga9oaiYU7JZowSiIDjI,2477
+nanobind/include/nanobind/stl/complex.h,sha256=QwL3Qm8qDrzhRxAXs7llS8cCLsnEeOriHyAurZWi2rk,1968
+nanobind/include/nanobind/stl/filesystem.h,sha256=hDT-J4uVwBmZz692Gmj1oE-3GoJsffANUIMQ0yremUc,2884
+nanobind/include/nanobind/stl/function.h,sha256=g7RmySuAZ_Z1UKQrilmHeQM6Zr9IsIKSK4VySIhtQRg,2488
 nanobind/include/nanobind/stl/list.h,sha256=6ZAtdW-epqSXkrXSEOl8fbutH36Eosd8qH2KrXSvIUk,527
 nanobind/include/nanobind/stl/map.h,sha256=1wxxFgt_oxW8zN-AMFPHhCQkaY5cZlA46x0wmKKoPLw,596
-nanobind/include/nanobind/stl/optional.h,sha256=ysnCPhsB66KcqJEc7T-ghT--0YgLj_7pjlUn4W0Z_YY,2202
-nanobind/include/nanobind/stl/pair.h,sha256=jFV34rM8EaDiXHtRjsm_K1_GYJXBU9goucQZ4kMPGn8,2770
+nanobind/include/nanobind/stl/optional.h,sha256=ykjv5jQzOhiC49nh6QxbNo8CWJuV8MfacQN0OuHQLoU,1811
+nanobind/include/nanobind/stl/pair.h,sha256=6OiPtUylnFkgWgyOu9p1Q_mrq7As_ydHFLdNCnN0LvQ,2925
 nanobind/include/nanobind/stl/set.h,sha256=_kN6BEkiLKE6JdJjlQAFdb79GQ27rtUvMVrkU5Zx_OA,575
 nanobind/include/nanobind/stl/shared_ptr.h,sha256=Shybkjkv45esaOZu8cA_PUW8wAYVgGEdmxVvI7VVU_w,4820
 nanobind/include/nanobind/stl/string.h,sha256=ZbZySXX53jPcBRWtIY0a5IBBXv65nP0mTjshZDsktV4,1018
 nanobind/include/nanobind/stl/string_view.h,sha256=arW6gVy3LA5UBYnApx3VV4S13V9GrFCeyTbZ2VPLbyo,1062
-nanobind/include/nanobind/stl/tuple.h,sha256=-gH6qWpLV66tST_wI0kBQPotREs6Nc8kTCxwaoDHgtw,3307
-nanobind/include/nanobind/stl/unique_ptr.h,sha256=2LKRlvZozOtwiriVKZJ_36KmdLagPYXXVtBVKbyCXrA,4389
+nanobind/include/nanobind/stl/tuple.h,sha256=g3yt4OYuT4Abew2zBt8Ftwvkl9U2QG2DSFrNZ-VmWKA,3576
+nanobind/include/nanobind/stl/unique_ptr.h,sha256=_MsQ3hkqW8UXrGlcIKDmk8KNQRIarGTIkZlNK8J4zKo,5747
 nanobind/include/nanobind/stl/unordered_map.h,sha256=CtLH0eyX3FzYPKFV6yYEr9R-yEKoVTnKITwwWLoYxZI,646
 nanobind/include/nanobind/stl/unordered_set.h,sha256=60NNDLwnLr-D2INwMSokHVJPwbmJ50iFuuhHjoHsP0g,652
-nanobind/include/nanobind/stl/variant.h,sha256=HCPc9Ggnc7Fw7gDMhWdE1zOiWEMn9Cf2OYY7cdCTifo,2776
+nanobind/include/nanobind/stl/variant.h,sha256=jFY7LloduJkGn4u2UxBle0nCn-VHbeSa5pr14F9de9c,2337
 nanobind/include/nanobind/stl/vector.h,sha256=22zqOx9R65LCLc5k4UJit84NwWxBQsYVtcQaNraFs2M,537
+nanobind/include/nanobind/stl/wstring.h,sha256=3OdHdyyJaa1F5S6Tc6cGmItV8XiPN5EtqAU2SRXS9S4,1023
 nanobind/include/nanobind/stl/detail/chrono.h,sha256=bT5XK6rf52kLrrNw9PwvrOsZqsJUEYLWp3lGG3HkCT8,10571
-nanobind/include/nanobind/stl/detail/nb_array.h,sha256=gw20PFosv_zl0BQJsqQZvCSUQ5cbKSpwssqQp6Iz38A,1798
-nanobind/include/nanobind/stl/detail/nb_dict.h,sha256=uyVORVtWq9JwvyYwoAAErLD215UxX26jwRiYd1T0ARA,2904
-nanobind/include/nanobind/stl/detail/nb_list.h,sha256=gtRHQrpF-lzRrvCzdlsBqsMdlmi-WLCFx1Shi2x3b9I,2247
-nanobind/include/nanobind/stl/detail/nb_set.h,sha256=gV3uLhvJDgJAUYCOCKtzsijdYMjdJMmZ9XUWc-V8G9c,2033
+nanobind/include/nanobind/stl/detail/nb_array.h,sha256=BIIi0ZLx67AbY1PJYZSpwzENVJPr0WTRmh7V7dVL2fE,1834
+nanobind/include/nanobind/stl/detail/nb_dict.h,sha256=qG62Z3ozrttOaTJE0rHHf_15mOdPYfdrxEoqiGeMR2o,2862
+nanobind/include/nanobind/stl/detail/nb_list.h,sha256=1LQzznxnS4blSPl6LS3HR7pT_go2oVRKsHOA4NMN500,2279
+nanobind/include/nanobind/stl/detail/nb_set.h,sha256=XU1PNot_ypGoKhjybcHDyOLLyilNTxYHfOpZxwIGk-4,2107
 nanobind/include/nanobind/stl/detail/traits.h,sha256=Al-8r5VMNaOnnmF0tSuMwFkxSnag4kpV_fXv1e5G3mM,3219
 nanobind/src/buffer.h,sha256=1aCpBkkr883-9gYhuaoG0vGwNH760WnTis0B2eNuoXo,4239
-nanobind/src/common.cpp,sha256=9QjkOFZosDvD8UMSzUGE4IbKhoGrAfFXiLXCbMtW8Q0,30688
+nanobind/src/common.cpp,sha256=kJ4mEW-wezq73VT1b3o2ujq8eDU2xTiskHTWDqExv_4,31127
 nanobind/src/error.cpp,sha256=aYA5wOKVZtNWIAR8D6htDqduzhcXR0wAqrQwkhry8fA,8851
 nanobind/src/hash.h,sha256=vKxjBj_EOs9I24ifBbBIKKp-ktqBF5qK5eS3YIs4asg,1009
-nanobind/src/implicit.cpp,sha256=qCIOGgbG63Z6LsZg3PPmx3TG0jviOGrDIx5yQHY-CZY,2318
-nanobind/src/nb_enum.cpp,sha256=eT8HQhXQLSDyFxbR6UOml1BlvwrxVW5yb7L6u_5hpAA,14686
-nanobind/src/nb_func.cpp,sha256=xmcm70xtvalDekgpempSathWf1pOexUJJIGH-4kWNhY,40196
-nanobind/src/nb_internals.cpp,sha256=2Y0srDJBhYdK35066wYkn9rHRtRWo-ITe-GOQIWayx0,15914
-nanobind/src/nb_internals.h,sha256=aDMDqEc78RVWIzQU4eSEu7pWKIVK3vEJRF3szu3TFYA,10614
-nanobind/src/nb_ndarray.cpp,sha256=OKWbOp5NydUPctQW3FQsFKAIIYVeq90EJ-vKTjm0E9A,24024
-nanobind/src/nb_static_property.cpp,sha256=V0k84IJyAxyZmtTHC4Q6zuyrtfTdKDd4JVdobjUUegM,1905
-nanobind/src/nb_type.cpp,sha256=QLrahhtvfULxvCp-vLbMhHJ0jwgbVy5ZJ82-AQro_sY,59202
+nanobind/src/implicit.cpp,sha256=YVflnNY97Vo4VqDEf6zh0iQ4M9iw5w8a5luirwvlnOI,2350
+nanobind/src/nb_combined.cpp,sha256=DUspVdQoFRsI2DUjKN9-CvEZSCW8lS4yAiKMypXHmTo,3908
+nanobind/src/nb_enum.cpp,sha256=Ux-jZqd4XQsja16mTmPIYsU6qAJ9mp47Q95oYLlXZDc,6951
+nanobind/src/nb_func.cpp,sha256=Q5vQwZvcmuynSSffArakBv0bJ7vPOtIPyjxw6qXAkGA,47581
+nanobind/src/nb_internals.cpp,sha256=37q32O5D_OKh3fWxLIzR763TKtdL0G0nV_mwIxWgPDU,16440
+nanobind/src/nb_internals.h,sha256=KMDSpRoJxAIOujRAZnA1_XfAWdk_04G_Qc1Rsyc6mx4,11572
+nanobind/src/nb_ndarray.cpp,sha256=VriZb8sKQKEv1HQgFIsZoZYuS2MeRzKh77304cJhjhc,24240
+nanobind/src/nb_static_property.cpp,sha256=YLO6PQwSI-tx-U0uOgYMeBHzYSzxeAnIWEmHcLrhv-0,1905
+nanobind/src/nb_type.cpp,sha256=R9CN-dz_Uu2HOuLTnurH0iQbVvyrObtf9hk-HPpYuWM,64788
 nanobind/src/trampoline.cpp,sha256=kLn60AVuvoOALLeI-g6O7zGMk8ud0ZjG4H0gmmsn34A,5144
-nanobind-1.9.2.dist-info/LICENSE,sha256=8wUJGk5XgFhwsheijqSx8WYQ7s6EV9I3D4Iqlpa3WDY,1521
-nanobind-1.9.2.dist-info/METADATA,sha256=hRm7pCFw5lInOPuU9e-hZJQam9IV9sAA-1Ut75R7FMM,1406
-nanobind-1.9.2.dist-info/WHEEL,sha256=oiQVh_5PnQM0E3gPdiz09WCNmwiHDMaGer_elqB3coM,92
-nanobind-1.9.2.dist-info/top_level.txt,sha256=3pRezwhnZCbmPhzcbPKfaw-IRYTQ6WbLWu14UZgONhs,9
-nanobind-1.9.2.dist-info/RECORD,,
+nanobind-2.0.0.dist-info/LICENSE,sha256=8wUJGk5XgFhwsheijqSx8WYQ7s6EV9I3D4Iqlpa3WDY,1521
+nanobind-2.0.0.dist-info/METADATA,sha256=gVSAh3MRjOd_Vofq0NUV7q3vJ8FWoLOJ9HvX_ndudWM,1406
+nanobind-2.0.0.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+nanobind-2.0.0.dist-info/top_level.txt,sha256=3pRezwhnZCbmPhzcbPKfaw-IRYTQ6WbLWu14UZgONhs,9
+nanobind-2.0.0.dist-info/RECORD,,
```

