# Comparing `tmp/finlab-1.1.1-cp39-cp39-win_amd64.whl.zip` & `tmp/finlab-1.1.2-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl.zip`

## zipinfo {}

```diff
@@ -1,51 +1,61 @@
-Zip file size: 1391750 bytes, number of entries: 49
--rw-rw-rw-  2.0 fat     2605 b- defN 24-Apr-15 14:36 finlab/__init__.py
--rw-rw-rw-  2.0 fat    32555 b- defN 24-Apr-15 14:36 finlab/backtest.py
--rw-rw-rw-  2.0 fat    49465 b- defN 24-Apr-15 14:36 finlab/data.py
--rw-rw-rw-  2.0 fat    30324 b- defN 24-Apr-15 14:36 finlab/dataframe.py
--rw-rw-rw-  2.0 fat    80855 b- defN 24-Apr-15 14:36 finlab/ffn_core.py
--rw-rw-rw-  2.0 fat    17331 b- defN 24-Apr-15 14:36 finlab/market_info.py
--rw-rw-rw-  2.0 fat    43954 b- defN 24-Apr-15 14:36 finlab/plot.py
--rw-rw-rw-  2.0 fat     6760 b- defN 24-Apr-15 14:36 finlab/utils.py
--rw-rw-rw-  2.0 fat     7772 b- defN 24-Apr-15 14:36 finlab/analysis/__init__.py
--rw-rw-rw-  2.0 fat     2380 b- defN 24-Apr-15 14:36 finlab/analysis/alphaBetaAnalysis.py
--rw-rw-rw-  2.0 fat     1449 b- defN 24-Apr-15 14:36 finlab/analysis/drawdownAnalysis.py
--rw-rw-rw-  2.0 fat     5013 b- defN 24-Apr-15 14:36 finlab/analysis/inequalityAnalysis.py
--rw-rw-rw-  2.0 fat     5692 b- defN 24-Apr-15 14:36 finlab/analysis/liquidityAnalysis.py
--rw-rw-rw-  2.0 fat    12357 b- defN 24-Apr-15 14:36 finlab/analysis/maeMfeAnalysis.py
--rw-rw-rw-  2.0 fat     7622 b- defN 24-Apr-15 14:36 finlab/analysis/periodStatsAnalysis.py
--rw-rw-rw-  2.0 fat        2 b- defN 24-Apr-15 14:36 finlab/core/__init__.py
--rw-rw-rw-  2.0 fat   216064 b- defN 24-Apr-15 14:41 finlab/core/aes.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat   165888 b- defN 24-Apr-15 14:41 finlab/core/backtest_core.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat  1125698 b- defN 24-Apr-15 14:36 finlab/core/everything.js
--rw-rw-rw-  2.0 fat    76288 b- defN 24-Apr-15 14:41 finlab/core/mae_mfe.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat   414720 b- defN 24-Apr-15 14:42 finlab/core/report.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat   873859 b- defN 24-Apr-15 14:36 finlab/core/style.css
--rw-rw-rw-  2.0 fat    32768 b- defN 24-Apr-15 14:42 finlab/core/utils_core.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat      712 b- defN 24-Apr-15 14:36 finlab/ml/__init__.py
--rw-rw-rw-  2.0 fat     7448 b- defN 24-Apr-15 14:36 finlab/ml/alphalens.py
--rw-rw-rw-  2.0 fat     5160 b- defN 24-Apr-15 14:36 finlab/ml/cpcv.py
--rw-rw-rw-  2.0 fat    16145 b- defN 24-Apr-15 14:36 finlab/ml/feature.py
--rw-rw-rw-  2.0 fat     6357 b- defN 24-Apr-15 14:36 finlab/ml/label.py
--rw-rw-rw-  2.0 fat    25631 b- defN 24-Apr-15 14:36 finlab/ml/qlib.py
--rw-rw-rw-  2.0 fat     3131 b- defN 24-Apr-15 14:36 finlab/ml/utils.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-15 14:36 finlab/online/__init__.py
--rw-rw-rw-  2.0 fat     8475 b- defN 24-Apr-15 14:36 finlab/online/base_account.py
--rw-rw-rw-  2.0 fat    14777 b- defN 24-Apr-15 14:36 finlab/online/binance_account.py
--rw-rw-rw-  2.0 fat     7264 b- defN 24-Apr-15 14:36 finlab/online/dashboard.py
--rw-rw-rw-  2.0 fat      263 b- defN 24-Apr-15 14:36 finlab/online/enums.py
--rw-rw-rw-  2.0 fat    13420 b- defN 24-Apr-15 14:36 finlab/online/fugle_account.py
--rw-rw-rw-  2.0 fat    29166 b- defN 24-Apr-15 14:36 finlab/online/order_executor.py
--rw-rw-rw-  2.0 fat    13190 b- defN 24-Apr-15 14:36 finlab/online/panel.py
--rw-rw-rw-  2.0 fat    10390 b- defN 24-Apr-15 14:36 finlab/online/sinopac_account.py
--rw-rw-rw-  2.0 fat     5303 b- defN 24-Apr-15 14:36 finlab/online/utils.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-15 14:36 finlab/optimize/__init__.py
--rw-rw-rw-  2.0 fat     9862 b- defN 24-Apr-15 14:36 finlab/optimize/combinations.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-15 14:36 finlab/tools/__init__.py
--rw-rw-rw-  2.0 fat     7195 b- defN 24-Apr-15 14:36 finlab/tools/event_study.py
--rw-rw-rw-  2.0 fat    35823 b- defN 24-Apr-15 14:42 finlab-1.1.1.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     4726 b- defN 24-Apr-15 14:42 finlab-1.1.1.dist-info/METADATA
--rw-rw-rw-  2.0 fat      100 b- defN 24-Apr-15 14:42 finlab-1.1.1.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        7 b- defN 24-Apr-15 14:42 finlab-1.1.1.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     4058 b- defN 24-Apr-15 14:42 finlab-1.1.1.dist-info/RECORD
-49 files, 3440024 bytes uncompressed, 1385386 bytes compressed:  59.7%
+Zip file size: 3923359 bytes, number of entries: 59
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-23 02:34 finlab.libs/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-23 02:34 finlab/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-23 02:34 finlab-1.1.2.dist-info/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-23 02:34 finlab/core/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-23 02:34 finlab/optimize/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-23 02:34 finlab/analysis/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-23 02:34 finlab/tools/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-23 02:34 finlab/online/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-23 02:34 finlab/ml/
+-rw-r--r--  2.0 unx    29536 b- defN 24-May-23 02:34 finlab/dataframe.py
+-rw-r--r--  2.0 unx     6521 b- defN 24-May-23 02:34 finlab/utils.py
+-rw-r--r--  2.0 unx    48175 b- defN 24-May-23 02:34 finlab/data.py
+-rw-r--r--  2.0 unx    42864 b- defN 24-May-23 02:34 finlab/plot.py
+-rw-r--r--  2.0 unx    31789 b- defN 24-May-23 02:34 finlab/backtest.py
+-rw-r--r--  2.0 unx    78494 b- defN 24-May-23 02:34 finlab/ffn_core.py
+-rw-r--r--  2.0 unx    16818 b- defN 24-May-23 02:34 finlab/market_info.py
+-rw-r--r--  2.0 unx     2540 b- defN 24-May-23 02:34 finlab/__init__.py
+-rwxr-xr-x  2.0 unx  2277128 b- defN 24-May-23 02:34 finlab/core/aes.cpython-310-aarch64-linux-gnu.so
+-rwxr-xr-x  2.0 unx  4610016 b- defN 24-May-23 02:34 finlab/core/report.cpython-310-aarch64-linux-gnu.so
+-rwxr-xr-x  2.0 unx  2779416 b- defN 24-May-23 02:34 finlab/core/backtest_core.cpython-310-aarch64-linux-gnu.so
+-rw-r--r--  2.0 unx   873858 b- defN 24-May-23 02:34 finlab/core/style.css
+-rwxr-xr-x  2.0 unx   243680 b- defN 24-May-23 02:34 finlab/core/utils_core.cpython-310-aarch64-linux-gnu.so
+-rwxr-xr-x  2.0 unx  1070384 b- defN 24-May-23 02:34 finlab/core/mae_mfe.cpython-310-aarch64-linux-gnu.so
+-rw-r--r--  2.0 unx  1100642 b- defN 24-May-23 02:34 finlab/core/everything.js
+-rw-r--r--  2.0 unx        1 b- defN 24-May-23 02:34 finlab/core/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-23 02:34 finlab/optimize/__init__.py
+-rw-r--r--  2.0 unx     9617 b- defN 24-May-23 02:34 finlab/optimize/combinations.py
+-rw-r--r--  2.0 unx     1405 b- defN 24-May-23 02:34 finlab/analysis/drawdownAnalysis.py
+-rw-r--r--  2.0 unx    12088 b- defN 24-May-23 02:34 finlab/analysis/maeMfeAnalysis.py
+-rw-r--r--  2.0 unx     5555 b- defN 24-May-23 02:34 finlab/analysis/liquidityAnalysis.py
+-rw-r--r--  2.0 unx     4858 b- defN 24-May-23 02:34 finlab/analysis/inequalityAnalysis.py
+-rw-r--r--  2.0 unx     7442 b- defN 24-May-23 02:34 finlab/analysis/periodStatsAnalysis.py
+-rw-r--r--  2.0 unx     7577 b- defN 24-May-23 02:34 finlab/analysis/__init__.py
+-rw-r--r--  2.0 unx     2306 b- defN 24-May-23 02:34 finlab/analysis/alphaBetaAnalysis.py
+-rw-r--r--  2.0 unx      994 b- defN 24-May-23 02:34 finlab/tools/factor_analysis.py
+-rw-r--r--  2.0 unx     6996 b- defN 24-May-23 02:34 finlab/tools/event_study.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-23 02:34 finlab/tools/__init__.py
+-rw-r--r--  2.0 unx    10120 b- defN 24-May-23 02:34 finlab/online/sinopac_account.py
+-rw-r--r--  2.0 unx    28459 b- defN 24-May-23 02:34 finlab/online/order_executor.py
+-rw-r--r--  2.0 unx     8206 b- defN 24-May-23 02:34 finlab/online/base_account.py
+-rw-r--r--  2.0 unx    13043 b- defN 24-May-23 02:34 finlab/online/fugle_account.py
+-rw-r--r--  2.0 unx     5161 b- defN 24-May-23 02:34 finlab/online/utils.py
+-rw-r--r--  2.0 unx      256 b- defN 24-May-23 02:34 finlab/online/enums.py
+-rw-r--r--  2.0 unx    14373 b- defN 24-May-23 02:34 finlab/online/binance_account.py
+-rw-r--r--  2.0 unx    12850 b- defN 24-May-23 02:34 finlab/online/panel.py
+-rw-r--r--  2.0 unx     7035 b- defN 24-May-23 02:34 finlab/online/dashboard.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-23 02:34 finlab/online/__init__.py
+-rw-r--r--  2.0 unx    24914 b- defN 24-May-23 02:34 finlab/ml/qlib.py
+-rw-r--r--  2.0 unx     5018 b- defN 24-May-23 02:34 finlab/ml/cpcv.py
+-rw-r--r--  2.0 unx     3042 b- defN 24-May-23 02:34 finlab/ml/utils.py
+-rw-r--r--  2.0 unx     7240 b- defN 24-May-23 02:34 finlab/ml/alphalens.py
+-rw-r--r--  2.0 unx    15831 b- defN 24-May-23 02:34 finlab/ml/feature.py
+-rw-r--r--  2.0 unx     6203 b- defN 24-May-23 02:34 finlab/ml/label.py
+-rw-r--r--  2.0 unx      679 b- defN 24-May-23 02:34 finlab/ml/__init__.py
+-rw-rw-r--  2.0 unx     4271 b- defN 24-May-23 02:34 finlab-1.1.2.dist-info/RECORD
+-rw-r--r--  2.0 unx     4621 b- defN 24-May-23 02:34 finlab-1.1.2.dist-info/METADATA
+-rw-r--r--  2.0 unx        7 b- defN 24-May-23 02:34 finlab-1.1.2.dist-info/top_level.txt
+-rw-r--r--  2.0 unx      154 b- defN 24-May-23 02:34 finlab-1.1.2.dist-info/WHEEL
+-rw-r--r--  2.0 unx    35149 b- defN 24-May-23 02:34 finlab-1.1.2.dist-info/LICENSE
+59 files, 13477332 bytes uncompressed, 3915787 bytes compressed:  70.9%
```

## zipnote {}

```diff
@@ -1,148 +1,178 @@
-Filename: finlab/__init__.py
+Filename: finlab.libs/
 Comment: 
 
-Filename: finlab/backtest.py
+Filename: finlab/
 Comment: 
 
-Filename: finlab/data.py
+Filename: finlab-1.1.2.dist-info/
 Comment: 
 
-Filename: finlab/dataframe.py
+Filename: finlab/core/
 Comment: 
 
-Filename: finlab/ffn_core.py
+Filename: finlab/optimize/
 Comment: 
 
-Filename: finlab/market_info.py
+Filename: finlab/analysis/
 Comment: 
 
-Filename: finlab/plot.py
+Filename: finlab/tools/
+Comment: 
+
+Filename: finlab/online/
+Comment: 
+
+Filename: finlab/ml/
+Comment: 
+
+Filename: finlab/dataframe.py
 Comment: 
 
 Filename: finlab/utils.py
 Comment: 
 
-Filename: finlab/analysis/__init__.py
+Filename: finlab/data.py
 Comment: 
 
-Filename: finlab/analysis/alphaBetaAnalysis.py
+Filename: finlab/plot.py
 Comment: 
 
-Filename: finlab/analysis/drawdownAnalysis.py
+Filename: finlab/backtest.py
 Comment: 
 
-Filename: finlab/analysis/inequalityAnalysis.py
+Filename: finlab/ffn_core.py
 Comment: 
 
-Filename: finlab/analysis/liquidityAnalysis.py
+Filename: finlab/market_info.py
 Comment: 
 
-Filename: finlab/analysis/maeMfeAnalysis.py
+Filename: finlab/__init__.py
 Comment: 
 
-Filename: finlab/analysis/periodStatsAnalysis.py
+Filename: finlab/core/aes.cpython-310-aarch64-linux-gnu.so
 Comment: 
 
-Filename: finlab/core/__init__.py
+Filename: finlab/core/report.cpython-310-aarch64-linux-gnu.so
 Comment: 
 
-Filename: finlab/core/aes.cp39-win_amd64.pyd
+Filename: finlab/core/backtest_core.cpython-310-aarch64-linux-gnu.so
 Comment: 
 
-Filename: finlab/core/backtest_core.cp39-win_amd64.pyd
+Filename: finlab/core/style.css
+Comment: 
+
+Filename: finlab/core/utils_core.cpython-310-aarch64-linux-gnu.so
+Comment: 
+
+Filename: finlab/core/mae_mfe.cpython-310-aarch64-linux-gnu.so
 Comment: 
 
 Filename: finlab/core/everything.js
 Comment: 
 
-Filename: finlab/core/mae_mfe.cp39-win_amd64.pyd
+Filename: finlab/core/__init__.py
 Comment: 
 
-Filename: finlab/core/report.cp39-win_amd64.pyd
+Filename: finlab/optimize/__init__.py
 Comment: 
 
-Filename: finlab/core/style.css
+Filename: finlab/optimize/combinations.py
 Comment: 
 
-Filename: finlab/core/utils_core.cp39-win_amd64.pyd
+Filename: finlab/analysis/drawdownAnalysis.py
 Comment: 
 
-Filename: finlab/ml/__init__.py
+Filename: finlab/analysis/maeMfeAnalysis.py
 Comment: 
 
-Filename: finlab/ml/alphalens.py
+Filename: finlab/analysis/liquidityAnalysis.py
 Comment: 
 
-Filename: finlab/ml/cpcv.py
+Filename: finlab/analysis/inequalityAnalysis.py
 Comment: 
 
-Filename: finlab/ml/feature.py
+Filename: finlab/analysis/periodStatsAnalysis.py
 Comment: 
 
-Filename: finlab/ml/label.py
+Filename: finlab/analysis/__init__.py
 Comment: 
 
-Filename: finlab/ml/qlib.py
+Filename: finlab/analysis/alphaBetaAnalysis.py
 Comment: 
 
-Filename: finlab/ml/utils.py
+Filename: finlab/tools/factor_analysis.py
 Comment: 
 
-Filename: finlab/online/__init__.py
+Filename: finlab/tools/event_study.py
 Comment: 
 
-Filename: finlab/online/base_account.py
+Filename: finlab/tools/__init__.py
 Comment: 
 
-Filename: finlab/online/binance_account.py
+Filename: finlab/online/sinopac_account.py
 Comment: 
 
-Filename: finlab/online/dashboard.py
+Filename: finlab/online/order_executor.py
 Comment: 
 
-Filename: finlab/online/enums.py
+Filename: finlab/online/base_account.py
 Comment: 
 
 Filename: finlab/online/fugle_account.py
 Comment: 
 
-Filename: finlab/online/order_executor.py
+Filename: finlab/online/utils.py
+Comment: 
+
+Filename: finlab/online/enums.py
+Comment: 
+
+Filename: finlab/online/binance_account.py
 Comment: 
 
 Filename: finlab/online/panel.py
 Comment: 
 
-Filename: finlab/online/sinopac_account.py
+Filename: finlab/online/dashboard.py
 Comment: 
 
-Filename: finlab/online/utils.py
+Filename: finlab/online/__init__.py
 Comment: 
 
-Filename: finlab/optimize/__init__.py
+Filename: finlab/ml/qlib.py
 Comment: 
 
-Filename: finlab/optimize/combinations.py
+Filename: finlab/ml/cpcv.py
 Comment: 
 
-Filename: finlab/tools/__init__.py
+Filename: finlab/ml/utils.py
 Comment: 
 
-Filename: finlab/tools/event_study.py
+Filename: finlab/ml/alphalens.py
+Comment: 
+
+Filename: finlab/ml/feature.py
+Comment: 
+
+Filename: finlab/ml/label.py
+Comment: 
+
+Filename: finlab/ml/__init__.py
 Comment: 
 
-Filename: finlab-1.1.1.dist-info/LICENSE
+Filename: finlab-1.1.2.dist-info/RECORD
 Comment: 
 
-Filename: finlab-1.1.1.dist-info/METADATA
+Filename: finlab-1.1.2.dist-info/METADATA
 Comment: 
 
-Filename: finlab-1.1.1.dist-info/WHEEL
+Filename: finlab-1.1.2.dist-info/top_level.txt
 Comment: 
 
-Filename: finlab-1.1.1.dist-info/top_level.txt
+Filename: finlab-1.1.2.dist-info/WHEEL
 Comment: 
 
-Filename: finlab-1.1.1.dist-info/RECORD
+Filename: finlab-1.1.2.dist-info/LICENSE
 Comment: 
 
 Zip file comment:
```

## filetype from file(1)

```diff
@@ -1 +1 @@
-Zip archive data, at least v2.0 to extract, compression method=deflate
+Zip archive data, at least v2.0 to extract, compression method=store
```

## finlab/__init__.py

```diff
@@ -1,92 +1,93 @@
-import os
-import logging
-import pkgutil
-from getpass import getpass
-
-
-# Get an instance of a logger
-logger = logging.getLogger(__name__)
-
-__version__ = '1.1.1'
-
-
-class LoginPanel():
-
-    def __init__(self):
-        pass
-
-    def gui_supported(self):
-        try:
-            if "VSCODE_PID" in os.environ or pkgutil.find_loader('IPython') is None:
-                return False # vscode not support getpass and display at the same time
-            else:
-                return True
-        except:
-            return False
-
-    def display_gui(self):
-
-        from IPython.display import IFrame, display, clear_output
-        iframe = IFrame(
-            f'https://ai.finlab.tw/api_token/?version={__version__}', width=620, height=300)
-        display(iframe)
-
-        try:
-            token = getpass('請從 https://ai.finlab.tw/api_token 複製驗證碼: \n')
-        except:
-            print('請從 https://ai.finlab.tw/api_token 複製驗證碼: \n')
-            token = input('驗證碼：')
-        clear_output()
-        self.login(token)
-
-    def display_text_input(self):
-        print('請從 https://ai.finlab.tw/api_token 複製驗證碼，貼於此處:\n')
-        token = input('驗證碼：')
-        self.login(token)
-        print('之後可以使用以下方法自動登入')
-        print('import finlab')
-        print('finlab.login("YOUR API TOKEN")')
-
-    @staticmethod
-    def login(token):
-        # set token
-        token = token[:64]
-        os.environ['finlab_id_token'] = token
-        os.environ['FINLAB_API_TOKEN'] = token
-        print('輸入成功!')
-
-
-def login(api_token=None):
-    """登錄量化平台。
-
-    可以至 [api_token查詢頁面](https://ai.finlab.tw/api_token/) 獲取api_token，傳入函數後執行登錄動作。
-    之後使用Finlab模組的會員功能時，系統就不會自動跳出請求輸入api_token的[GUI頁面](https://ai.finlab.tw/api_token/)。
-    若傳入的api_toke格式有誤，系統會要求再次輸入。
-
-    Args:
-        api_token (str): FinLab api_token
-    """
-    lp = LoginPanel()
-
-    if api_token:
-        lp.login(api_token)
-        return
-
-    if lp.gui_supported():
-        lp.display_gui()
-    else:
-        lp.display_text_input()
-
-
-def get_token():
-    """取得登錄會員的finlab_id。
-
-    若未登錄過，會跳出登錄頁面請求登錄。
-
-    Returns:
-        (str): finlab api token
-    """
-    if 'FINLAB_API_TOKEN' not in os.environ:
-        login()
-
-    return os.environ['FINLAB_API_TOKEN'][:64]
+import os
+import logging
+import pkgutil
+from getpass import getpass
+
+
+# Get an instance of a logger
+logger = logging.getLogger(__name__)
+
+__version__ = '1.1.2'
+
+
+class LoginPanel():
+
+    def __init__(self):
+        pass
+
+    def gui_supported(self):
+        try:
+            if "VSCODE_PID" in os.environ or pkgutil.find_loader('IPython') is None:
+                return False # vscode not support getpass and display at the same time
+            else:
+                return True
+        except:
+            return False
+
+    def display_gui(self):
+
+        from IPython.display import IFrame, display, clear_output
+        iframe = IFrame(
+            f'https://ai.finlab.tw/api_token/?version={__version__}', width=620, height=300)
+        display(iframe)
+
+        try:
+            token = getpass('請從 https://ai.finlab.tw/api_token 複製驗證碼: \n')
+        except:
+            print('請從 https://ai.finlab.tw/api_token 複製驗證碼: \n')
+            token = input('驗證碼：')
+        clear_output()
+        self.login(token)
+
+    def display_text_input(self):
+        print('請從 https://ai.finlab.tw/api_token 複製驗證碼:\n')
+        # token = getpass('驗證碼：')
+        token = input('驗證碼：')
+        self.login(token)
+        print('之後可以使用以下方法自動登入')
+        print('import finlab')
+        print('finlab.login("YOUR API TOKEN")')
+
+    @staticmethod
+    def login(token):
+        # set token
+        token = token[:64]
+        os.environ['finlab_id_token'] = token
+        os.environ['FINLAB_API_TOKEN'] = token
+        print('輸入成功!')
+
+
+def login(api_token=None):
+    """登錄量化平台。
+
+    可以至 [api_token查詢頁面](https://ai.finlab.tw/api_token/) 獲取api_token，傳入函數後執行登錄動作。
+    之後使用Finlab模組的會員功能時，系統就不會自動跳出請求輸入api_token的[GUI頁面](https://ai.finlab.tw/api_token/)。
+    若傳入的api_toke格式有誤，系統會要求再次輸入。
+
+    Args:
+        api_token (str): FinLab api_token
+    """
+    lp = LoginPanel()
+
+    if api_token:
+        lp.login(api_token)
+        return
+
+    if lp.gui_supported():
+        lp.display_gui()
+    else:
+        lp.display_text_input()
+
+
+def get_token():
+    """取得登錄會員的finlab_id。
+
+    若未登錄過，會跳出登錄頁面請求登錄。
+
+    Returns:
+        (str): finlab api token
+    """
+    if 'FINLAB_API_TOKEN' not in os.environ:
+        login()
+
+    return os.environ['FINLAB_API_TOKEN'][:64]
```

## finlab/backtest.py

```diff
@@ -1,764 +1,764 @@
-import sys
-import warnings
-import datetime
-import numpy as np
-import pandas as pd
-from typing import Union
-from pandas.tseries.offsets import DateOffset
-from pandas.tseries.frequencies import to_offset
-
-import finlab
-from finlab.market_info import get_market_info
-from finlab import data, market_info
-from finlab.core import mae_mfe as maemfe
-from finlab.core import report
-from finlab.utils import check_version, requests, set_global
-from finlab.core.backtest_core import backtest_, get_trade_stocks
-from finlab.dataframe import FinlabDataFrame
-
-def warning_resample(resample):
-
-  if '+' not in resample and '-' not in resample:
-      return
-
-  if '-' in resample and not resample.split('-')[-1].isdigit():
-      return
-
-  if '+' in resample:
-      r, o = resample.split('+')
-  elif '-' in resample:
-      r, o = resample.split('-')
-
-  warnings.warn(f"The argument sim(..., resample = '{resample}') will no longer support after 0.1.37.dev1.\n"
-                f"please use sim(..., resample='{r}', offset='{o}d')", DeprecationWarning)
-
-
-
-def download_backtest_encryption_function_factory():
-
-    encryption_time = datetime.datetime.now()
-    encryption = ''
-
-    def ret():
-
-        nonlocal encryption_time
-        nonlocal encryption
-
-        if datetime.datetime.now() < encryption_time + datetime.timedelta(days=1) and encryption:
-            return encryption
-
-        res = requests.get('https://asia-east2-fdata-299302.cloudfunctions.net/auth_backtest',
-                {'api_token': finlab.get_token(), 'time': str(datetime.datetime.now())})
-
-        if not res.ok:
-            try:
-                result = res.json()
-            except:
-                result = None
-
-            print(result)
-            return ''
-
-        d = res.json()
-
-        if 'v' in d and 'v_msg' in d and finlab.__version__ < d['v']:
-            print(d['v_msg'])
-
-        if 'msg' in d:
-            print(d['msg'])
-
-        encryption_time = datetime.datetime.now()
-        encryption = d['encryption']
-
-        return encryption
-    return ret
-
-download_backtest_encryption = download_backtest_encryption_function_factory()
-
-
-def calc_essential_price(price, dates):
-
-    dt = min(price.index.values[1:] - price.index.values[:-1])
-
-    indexer = price.index.get_indexer(dates + dt)
-
-    valid_idx = np.where(indexer == -1, np.searchsorted(price.index, dates, side='right'), indexer)
-    valid_idx = np.where(valid_idx >= len(price), len(price) - 1, valid_idx)
-
-    return price.iloc[valid_idx]
-
-def arguments(price, high, low, open_, position, resample_dates=None, fast_mode=False):
-
-    resample_dates = price.index if resample_dates is None else resample_dates
-    position = position.astype(float).fillna(0)
-
-    if fast_mode:
-        date_index = pd.to_datetime(resample_dates)
-        position = position.reindex(date_index, method='ffill')
-        price = calc_essential_price(price, date_index)
-        high = calc_essential_price(high, date_index)
-        low = calc_essential_price(low, date_index)
-        open_ = calc_essential_price(open_, date_index)
-
-    resample_dates = pd.Series(resample_dates).view(np.int64).values
-
-    return [price.values,
-            high.values,
-            low.values,
-            open_.values,
-            price.index.view(np.int64),
-            price.columns.astype(str).values,
-            position.values,
-            position.index.view(np.int64),
-            position.columns.astype(str).values,
-            resample_dates
-            ]
-
-
-def line_notify(report=None, line_access_token:str='', test:bool=False):
-    """傳送回測結果之目前部位、近期換股訊息至Line聊天室。
-
-    Args:
-        report (Report):
-            回測完的結果報告。
-
-        line_access_token (str):
-            於Line Notify取得的access_token(權杖)。至[Line Notify](https://notify-bot.line.me/zh_TW/ )登入Line帳號後，點選個人頁面，點選「發行權杖」，選擇欲接收訊息的聊天室(可選擇1對1接收Line Notify通知、或是選擇其他群組聊天室)，即可取得權杖。
-        test (bool):
-            是否進行傳送訊息測試。
-
-    Examples:
-        欲進行測試，則設定`test`參數為True。
-
-        ``` py
-        from finlab import backtest
-
-        line_access_token = 'xxxxxxxxxxxx'
-        backtest.line_notify(line_access_token=line_access_token, test=True)
-        ```
-
-        若成功收到通知，則權杖設定已完畢，可直接在`sim`回測模組中開啟使用，或單獨調用此函式發送回測換股訊息。
-        於sim中使用:
-
-        ``` py
-        from finlab import backtest
-
-        line_access_token = 'xxxxxxxxxxxx'
-        position = ...
-        report = backtest.sim(position, notification_enable =True, line_access_token = line_access_token)
-        ```
-
-        已回測完，單獨傳訊息用:
-
-        ``` py
-        from finlab import backtest
-
-        line_access_token = 'xxxxxxxxxxxx'
-        report = backtest.sim(position)
-        backtest.line_notify(report, line_access_token=line_access_token)
-        ```
-
-    """
-    if test:
-        message = 'Finlab line_notify 測試成功'
-    else:
-        if not isinstance(report, finlab.core.report.Report):
-            raise Exception('Please provide a valid backtest report.')
-        hold = []
-        enter = []
-        exit = []
-        for i,p in report.position_info().items():
-            if isinstance(p,dict):
-                if i[:4].isdigit():
-                    if p['status'] in ['exit'] and pd.isnull(report.current_trades.loc[i].exit_date):
-                        hold.append(f"{i}: {p['entry_date'][:10]}, {str(p['entry_price'])}")
-                    if p['status'] in ['hold','sl','tp']:
-                        hold.append(f"{i}: {p['entry_date'][:10]}, {str(p['entry_price'])}")
-                    if p['status'] in ['enter']:
-                        enter.append(f"{i}: {p['entry_date'][:10]}的下個交易日進場")
-                    if p['status'] in ['exit','sl','tp', 'sl_enter', 'tp_enter']:
-                        exit.append(f"{i}: {p['exit_date'][:10]}的下個交易日出場")
-        message_lines = ['目前策略清單 進場日及進場價格：']
-        message_lines.extend(hold)
-        message_lines.append('------------------------------')
-        message_lines.append('近期操作：')
-        message_lines.append('-策略新增')
-        if len(enter) > 0:
-            message_lines.extend(enter)
-        else:
-            message_lines.append('尚無')
-        message_lines.append('-策略移除')
-        if len(exit) > 0:
-            message_lines.extend(exit)
-        else:
-            message_lines.append('尚無')
-        message = "\n".join(message_lines)
-
-    headers = {
-        "Authorization": "Bearer " + line_access_token,
-        "Content-Type" : "application/x-www-form-urlencoded"
-        }
-    r = requests.post("https://notify-api.line.me/api/notify", headers = headers, params = {'message': message})
-    if test:
-        if eval(r.text)['status'] == 401:
-            print(f'測試失敗。{r.text}')
-        elif eval(r.text)['status'] == 200:
-            print('測試成功，可開始使用finlab line_notify')
-
-def sim(position: Union[pd.DataFrame, pd.Series],
-        resample:Union[str, None]=None, resample_offset:Union[str, None] = None,
-        trade_at_price: Union[str, pd.DataFrame] = 'close',
-        position_limit:float=1, fee_ratio:float=1.425/1000,
-        tax_ratio: float=3/1000, name:str='未命名', stop_loss: Union[float, None]=None,
-        take_profit: Union[float, None]=None, trail_stop: Union[float, None]=None, touched_exit: bool=False,
-        retain_cost_when_rebalance: bool=False, stop_trading_next_period: bool=True, live_performance_start:Union[str, None]=None,
-        mae_mfe_window:int=0, mae_mfe_window_step:int=1, market:Union[str, market_info.MarketInfo]='AUTO', upload:bool=True, fast_mode=False,
-        notification_enable: bool=False, line_access_token: str='') -> report.Report:
-
-    """Simulate the equity given the stock position history. 回測模擬股票部位所產生的淨值報酬率。
-
-    Args:
-        position (pd.DataFrame or pd.Series):
-            買賣訊號紀錄。True 為持有， False 為空手。 若選擇做空position，只要將 sim(position) 改成負的 sim(-position.astype(float))即可做空。
-
-        resample (str, None, pd.DataFrame, pd.Series, finlab.dataframe.FinlabDataFrame):
-            交易週期。將 position 的訊號以週期性的方式論動股票，預設為每天換股。其他常用數值為 W、 M 、 Q （每週、每月、每季換股一次），也可以使用 W-Fri 在週五的時候產生新的股票清單，並且於下週交易日下單。
-
-            * `D`: Daily
-            * `W`: Weekly
-            * `W-Wed`: Every Wednesday
-            * `M`: Monthly
-            * `MS`: Start of every month
-            * `Q`: Quarterly
-            * `QS`: Start of every quarter
-
-            !!!note
-                'D'與'None'的差別？
-                resample='D' 的意義為每天隨股價變化做再平衡，就算當天股票清單沒變，但股票漲跌後，部位大小會變化，而 resample='D' 會強制再平衡，平均分散風險。
-
-                但是當 resample=None 的話，假如清單不變，則不會強制再平衡，只有清單改變時，才做再平衡。適用情境在較常選到大波段標的的趨勢策略，較有機會將強勢股留下，而不會汰強留弱做再平衡。
-
-            另外 `resample` 也接受 pd.DataFrame 以及 pd.Series，並且將其 index 用來當成換股的時間點，例如以下的範例：
-
-            ``` py
-            from finlab import backtest, data
-
-            rev = data.get('monthly_revenue:當月營收')
-            position = ...
-
-            # 月營收發布時才換股
-            backtest.sim(position, resample=rev)
-            ```
-
-
-
-        resample_offset (str or None):
-            交易週期的時間位移，例如。
-
-            - '1D': 位移一天
-            - '1H': 位移一小時
-
-        trade_at_price (str or pd.DataFrame):
-            選擇回測之還原股價以收盤價或開盤價計算，預設為'close'。可選'close'、'open'、'open_close_avg'、'high_low_avg'或 'price_avg'。
-
-        position_limit (float): maximum amount of investing a stock.
-            單檔標的持股比例上限，控制倉位風險。預設為None。範例：0.2，代表單檔標的最多持有 20 % 部位。
-
-        fee_ratio (float): fee ratio of buying or selling a stock.
-            交易手續費率，預設為台灣無打折手續費 0.001425。可視個人使用的券商優惠調整費率。
-
-        tax_ratio (float): tax ratio of selling a stock.
-            交易稅率，預設為台灣普通股一般交易交易稅率 0.003。若交易策略的標的皆為ETF，記得設成 0.001。
-
-        name (str): name of the strategy.
-            策略名稱，預設為 未指名。策略名稱。相同名稱之策略上傳會覆寫。命名規則:全英文或開頭中文，不接受開頭英文接中文。
-
-        stop_loss (float):
-            停損基準，預設為None，不執行停損。範例：0.1，代表從再平衡開始，虧損 10% 時產生出場訊號。
-
-        take_profit (float):
-            停利基準，預設為None，不執行停利。範例：0.1，代表從再平衡開始， 10% 時產生出場訊號。
-
-        trail_stop (float):
-            移動停損停利基準，預設為None，不執行。範例：0.1，代表從最高點開始下跌，跌至 10% 時產生出場訊號。
-
-        touched_exit (bool):
-            是否在回測時，使用觸價停損停利？預設為 False。
-
-        retain_cost_when_rebalance (bool):
-            預設回測時，會將進場股票進場成本更新到到新的 rebalance 的當天價格，假如希望保留原本的進場價格當成停損停利的依據，可以設定為 `True`
-
-        stop_trading_next_period (bool):
-            當期已經停損停利，則下一期不買入，預設為 True。
-
-        live_performance_start (str):
-            策略建構的日期，例如 `2022-01-01` 此日期之前，策略未撰寫，此日期之後則視為與實單有類似效果，實際不影響回測的結果，單純紀錄而已。
-
-        mae_mfe_window (int):
-            計算mae_mfe於進場後於不同持有天數下的數據變化，主要應用為edge_ratio (優勢比率)計算。預設為0，則Report.display_mae_mfe_analysis(...)中的edge_ratio不會顯現。
-
-        mae_mfe_window_step (int):
-            與mae_mfe_window參數做搭配，為時間間隔設定，預設為1。若mae_mfe_window設20，mae_mfe_window_step設定為2，相當於python的range(0,20,2)，以2日為間距計算mae_mfe。
-
-        market (str or MarketInfo):
-            可選擇`'TW_STOCK', 'CRYPTO'`，分別為台股或加密貨幣，
-            或繼承 finlab.market_info.MarketInfo 開發回測市場類別。
-
-        upload (bool):
-            上傳策略至finlab網站，預設為True，上傳策略。
-            範例： False，不上傳，可用 finlab.backtest.sim(position, upload=False, ...).display() 快速檢視策略績效。
-
-        fast_mode (bool):
-            預設為False，若設定為True，則會使用快速模式，快速模式會忽略所有的停利停損設定，並且只有換股日進行報酬率模擬，因此會有一些誤差，當持有較多檔股票時，可以大幅加速回測速度。
-
-    Returns:
-        (finlab.analysis.Report):回測數據報告
-
-    Examples:
-        Assume the history of portfolio is construct as follows: When market close on 2021-12-31, the portfolio {B: 0.2, C: 0.4} is calculated. When market close on 2022-03-31, the portfolio {A:1} is calculated.
-
-
-        |            | Stock 2330 | Stock 1101 | Stock 2454 |
-        |------------|------------|------------|------------|
-        | 2021-12-31 | 0%         | 20%        | 40%        |
-        | 2022-03-31 | 100%       | 0%         | 0%         |
-        | 2022-06-30 | 100%       | 0%         | 0%         |
-
-
-        With the portfolio, one could backtest the equity history as follows:
-
-        ``` py
-        import pandas as pd
-        from finlab import backtest
-
-        position = pd.DataFrame({
-            '2330': [0, 1, 1],
-            '1101': [0.2, 0, 0],
-            '2454': [0.4, 0, 0]
-        }, index=pd.to_datetime(['2021-12-31', '2022-03-31', '2022-06-30']))
-
-        report = backtest.sim(position)
-        ```
-
-    """
-
-    # check version
-    check_version()
-
-    if notification_enable == True and line_access_token == '':
-        raise Exception('line_access_token is required when enabling notifications. Please provide a valid token.')
-
-    if isinstance(position, FinlabDataFrame):
-        position = position.index_str_to_date()
-
-    if (trail_stop is not None or stop_loss is not None or take_profit is not None) and fast_mode:
-        raise Exception('fast_mode cannot be used with trail_stop, stop_loss or take_profit.')
-
-    # check type of position
-    if not isinstance(position.index, pd.DatetimeIndex):
-        raise TypeError("Expected the dataframe to have a DatetimeIndex")
-
-    if isinstance(position, pd.Series) and position.name is None:
-        raise Exception('Asset name not found. Please asign asset name by "position.name = \'2330\'".')
-
-    # auto detect market type
-    # todo: use less hacky method to identify the market
-    market = get_market_info(position, user_market_info=market)
-
-    if not isinstance(market, market_info.MarketInfo):
-        raise Exception("It seems like the market has"
-            "not been specified well when using the hold_until"
-            " function. Please provide the market='TW', "
-            "market='US' or market=MarketInfo")
-
-    # determine trading price
-    price = trade_at_price
-    if isinstance(trade_at_price, str):
-        price = market.get_trading_price(trade_at_price, adj=True)
-
-    assert isinstance(price, pd.DataFrame)
-
-    if isinstance(trade_at_price, pd.DataFrame) and touched_exit:
-        print('**WARNING: Using trade_at_price as dataframe without high, and low price. Candle information is not completed.')
-        print('           The backtest result can be incorrect when touched_exit=True.')
-        print('           If the complete backtest result is required, please implement MarketInfo with get_price function.')
-        print('           MarketInfo details: https://doc.finlab.tw/reference/market_info/')
-        print('           And use backtest.sim(..., market=MarketInfo) during backtest, so that the correct information is accessable from backtest.sim().')
-
-    try:
-        if isinstance(live_performance_start, str):
-            live_performance_start = datetime.datetime.fromisoformat(live_performance_start)
-    except:
-        raise Exception("**ERROR: live_performance_start string format not valid. It should be ISO format, i.e. YYYY-MM-DD.")
-
-
-    high = price
-    low = price
-    open_ = price
-    if touched_exit:
-        high = market.get_price('high', adj=True).reindex_like(price)
-        low = market.get_price('low', adj=True).reindex_like(price)
-        open_ = market.get_price('open', adj=True).reindex_like(price)
-
-    # check position types
-    if isinstance(position, pd.Series):
-        if position.name in price.columns:
-            position = position.to_frame()
-        else:
-            raise Exception('Asset name not found. Please asign asset name by "position.name = \'2330\'".')
-
-    # check position is valid
-    # if position.abs().sum().sum() == 0 or len(position.index) == 0:
-    #     raise Exception('Position is empty and zero stock is selected.')
-
-    # format position index
-    if isinstance(position.index[0], str):
-        position = FinlabDataFrame(position).index_str_to_date()
-
-    if not isinstance(position.index, pd.DatetimeIndex):
-        raise Exception("The DataFrame index is not of type DatetimeIndex!")
-
-    # if position date is very close to price end date, run all backtesting dates
-    assert len(position.shape) >= 2
-    delta_time_rebalance = position.index[-1] - position.index[-3]
-    backtest_to_end = position.index[-1] + \
-        delta_time_rebalance > price.index[-1]
-
-
-    tz = position.index.tz
-    now = datetime.datetime.now(tz=tz)
-
-    # check if position date is daily (pd.Timestamp hour, minute, second is 0)
-    is_daily = (position.index.hour == 0).all()\
-        and (position.index.minute == 0).all()\
-        and (position.index.second == 0).all()
-
-    # set now to yesterday's end if is_daily position
-    if is_daily and datetime.datetime.now(tz=market.tzinfo()) < market.market_close_at_timestamp():
-        now = now.replace(hour=23, minute=59, second=0, microsecond=0) - datetime.timedelta(days=1)
-
-    present_data_date = max(price.index[-1], now)
-
-    position = position[(position.index <= present_data_date)]
-    backtest_end_date = price.index[-1] if backtest_to_end else position.index[-1]
-
-    # resample dates
-    dates = None
-    next_trading_date = position.index[-1]
-    if isinstance(resample, pd.DataFrame) or isinstance(resample, pd.Series):
-
-        if isinstance(resample.index, pd.DatetimeIndex):
-            dates = resample.index.tolist()
-        elif isinstance(resample, FinlabDataFrame):
-            dates = resample.index_str_to_date().index.tolist()
-
-        dates = [d for d in dates if position.index[0] <= d and d <= present_data_date]
-        next_trading_date = dates[-1]
-
-    elif isinstance(resample, pd.DatetimeIndex):
-
-        dates = resample.tolist()
-        dates = [d for d in dates if position.index[0] <= d and d <= present_data_date]
-        next_trading_date = dates[-1]
-
-    elif isinstance(resample, str):
-
-        if pd.__version__ >= '3.0.0':
-            old_resample_strings = ['M', 'BM', 'SM', 'CBM', 'Q', 'BQ', 'A', 'Y', 'BY']
-            if resample in old_resample_strings:
-                resample += 'E'
-
-        # add additional day offset
-        offset_days = 0
-        if '+' in resample:
-            offset_days = int(resample.split('+')[-1])
-            resample = resample.split('+')[0]
-        if '-' in resample and resample.split('-')[-1].isdigit():
-            offset_days = -int(resample.split('-')[-1])
-            resample = resample.split('-')[0]
-
-        # generate rebalance dates
-        alldates = pd.date_range(
-            position.index[0],
-            present_data_date + datetime.timedelta(days=360),
-            freq=resample, tz=tz)
-
-        alldates += DateOffset(days=offset_days)
-
-        if resample_offset is not None:
-            alldates += to_offset(resample_offset)
-
-        dates = [d for d in alldates if position.index[0]
-                 <= d and d <= present_data_date]
-
-        # calculate the latest trading date
-        if position.index[-1] > dates[-1]:
-            dates += [min(set(alldates) - set(dates))]
-
-        next_trading_date = dates[-1]
-
-    elif resample is None:
-        # user set resample to None. Rebalance everyday might cause over transaction.
-        # remove rebalance date if portfolio is the same.
-        change = (position.diff().abs().sum(axis=1) != 0) | ((position.index == position.index[0]) & position.iloc[0].notna().any())
-        position = position.loc[change]
-
-    if stop_loss is None or stop_loss == 0:
-        stop_loss = 1
-
-    if take_profit is None or take_profit == 0:
-        take_profit = np.inf
-
-    if trail_stop is None or trail_stop == 0:
-        trail_stop = np.inf
-
-    if dates is not None:
-        position = position.reindex(dates, method='ffill')
-
-    encryption = download_backtest_encryption()
-
-    if encryption == '':
-        raise Exception('Cannot perform backtest, permission denied.')
-
-    args = arguments(price, high, low, open_, position, dates, fast_mode=fast_mode)
-
-    creturn_value = backtest_(*args,
-                              encryption=encryption,
-                              fee_ratio=fee_ratio, tax_ratio=tax_ratio,
-                              stop_loss=stop_loss, take_profit=take_profit, trail_stop=trail_stop,
-                              touched_exit=touched_exit, position_limit=position_limit,
-                              retain_cost_when_rebalance=retain_cost_when_rebalance,
-                              stop_trading_next_period=stop_trading_next_period,
-                              mae_mfe_window=mae_mfe_window, mae_mfe_window_step=mae_mfe_window_step)
-
-    total_weight = position.abs().sum(axis=1).clip(1, None)
-
-    position = position.div(total_weight.where(total_weight!=0, np.nan), axis=0).fillna(0)\
-                       .clip(-abs(position_limit), abs(position_limit))
-
-
-    creturn_dates = dates if dates and fast_mode else price.index
-
-    creturn = (pd.Series(creturn_value, creturn_dates)
-                # remove the begining of creturn since there is no pct change
-                .pipe(lambda df: df[(df != 1).cumsum().shift(-1, fill_value=1) != 0])
-                # remove the tail of creturn for verification
-                .loc[:backtest_end_date]
-                # replace creturn to 1 if creturn is None
-                .pipe(lambda df: df if len(df) != 0 else pd.Series(1, position.index)))
-
-    position = position.loc[creturn.index[0]:]
-
-    price_index = args[4]
-    position_columns = args[8]
-    trades, operation_and_weight = get_trade_stocks(position_columns,
-                                                    price_index, touched_exit=touched_exit)
-
-    ####################################
-    # refine mae mfe dataframe
-    ####################################
-    def refine_mae_mfe():
-        if len(maemfe.mae_mfe) == 0:
-            return pd.DataFrame()
-
-        m = pd.DataFrame(maemfe.mae_mfe)
-        nsets = int((m.shape[1]-1) / 6)
-
-        metrics = ['mae', 'gmfe', 'bmfe', 'mdd', 'pdays', 'return']
-
-        tuples = sum([[(n, metric) if n == 'exit' else (n * mae_mfe_window_step, metric)
-                       for metric in metrics] for n in list(range(nsets)) + ['exit']], [])
-
-        m.columns = pd.MultiIndex.from_tuples(
-            tuples, names=["window", "metric"])
-        m.index.name = 'trade_index'
-        m[m == -1] = np.nan
-
-        exit = m.exit.copy()
-
-        if touched_exit and len(m) > 0 and 'exit' in m.columns:
-            m['exit'] = (exit
-                .assign(gmfe=exit.gmfe.clip(-abs(stop_loss), abs(take_profit)))
-                .assign(bmfe=exit.bmfe.clip(-abs(stop_loss), abs(take_profit)))
-                .assign(mae=exit.mae.clip(-abs(stop_loss), abs(take_profit)))
-                .assign(mdd=exit.mdd.clip(-abs(stop_loss), abs(take_profit))))
-
-        return m
-
-    m = refine_mae_mfe()
-
-    ####################################
-    # refine trades dataframe
-    ####################################
-    def convert_datetime_series(df):
-        cols = ['entry_date', 'exit_date', 'entry_sig_date', 'exit_sig_date']
-        df[cols] = df[cols].apply(lambda s: pd.to_datetime(s).dt.tz_localize(tz))
-        return df
-
-    def assign_exit_nat(df):
-        cols = ['exit_date', 'exit_sig_date']
-        df[cols] = df[cols].loc[df.exit_index != -1]
-        return df
-
-    trades = (pd.DataFrame(trades,
-                           columns=['stock_id', 'entry_date', 'exit_date',
-                                    'entry_sig_date', 'exit_sig_date', 'position',
-                                    'period', 'entry_index', 'exit_index'])
-              .rename_axis('trade_index')
-              .pipe(convert_datetime_series)
-              .pipe(assign_exit_nat)
-              )
-
-    if len(trades) != 0:
-        trades = trades.assign(**{'return': (1 - fee_ratio) * (m.iloc[:, -1]+1) * (1 - tax_ratio - fee_ratio) - 1})
-
-        if touched_exit:
-            min_return = (1 - fee_ratio) * (1 - abs(stop_loss)) * (1 - tax_ratio - fee_ratio) - 1
-            max_return = (1 - fee_ratio) * (1 + abs(take_profit)) * (1 - tax_ratio - fee_ratio) - 1
-            trades['return'] = trades['return'].clip(min_return, max_return)
-
-    r = report.Report(
-        creturn=creturn,
-        position=position,
-        fee_ratio=fee_ratio,
-        tax_ratio=tax_ratio,
-        trade_at=trade_at_price,
-        next_trading_date=next_trading_date,
-        market_info=market)
-
-    r.resample = resample if isinstance(resample, str) else None
-    r.stop_loss = stop_loss
-    r.take_profit = take_profit
-    r.trail_stop = trail_stop
-    r.live_performance_start = live_performance_start
-
-    r.mae_mfe = m
-
-    r.trades = trades
-
-    # calculate weights
-    if len(operation_and_weight['weights']) != 0:
-        r.weights = pd.Series(operation_and_weight['weights'])
-        r.weights.index = r.position.columns[r.weights.index]
-    else:
-        r.weights = pd.Series(dtype='float64')
-
-
-    # calculate next weights
-    if len(operation_and_weight['next_weights']) != 0:
-        r.next_weights = pd.Series(operation_and_weight['next_weights'])
-        r.next_weights.index = r.position.columns[r.next_weights.index]
-    else:
-        r.next_weights = pd.Series(dtype='float64')
-
-
-    # calculate actions
-    if len(operation_and_weight['actions']) != 0:
-        # find selling and buying stocks
-        r.actions = pd.Series(operation_and_weight['actions'])
-        r.actions.index = r.position.columns[r.actions.index]
-    else:
-        r.actions = pd.Series(dtype=object)
-
-
-    # fill stock id to trade history
-    snames = market.get_asset_id_to_name()
-    f_id_to_name = lambda sid: f"{sid + ' ' + snames[sid] if sid in snames else sid}"
-    if len(trades) != 0:
-        r.trades['stock_id'] = r.trades.stock_id.map(f_id_to_name)
-
-    if hasattr(r, 'actions') and len(r.actions) != 0:
-        r.actions.index = r.actions.index.map(f_id_to_name)
-
-    r.weights.index = r.weights.index.map(f_id_to_name)
-    r.next_weights.index = r.next_weights.index.map(f_id_to_name)
-
-    if len(r.actions) != 0:
-
-        actions = r.actions
-
-        sell_sids = actions[actions == 'exit'].index
-        sell_instant_sids = actions[(actions == 'sl') | (actions == 'tp')
-                                    | (actions == 'sl_enter') | (actions == 'tp_enter')].index
-        buy_sids = actions[actions == 'enter'].index
-
-        if len(trades):
-            # check if the sell stocks are in the current position
-            assert len(set(sell_sids) - set(trades.stock_id[trades.exit_sig_date.isnull()])) == 0
-
-            # fill exit_sig_date and exit_date
-            temp = trades.loc[trades.stock_id.isin(sell_sids), 'exit_sig_date'].fillna(r.position.index[-1])
-            trades.loc[trades.stock_id.isin(sell_sids), 'exit_sig_date'] = temp
-
-            temp = trades.loc[trades.stock_id.isin(sell_instant_sids), 'exit_sig_date'].fillna(price.index[-1])
-            trades.loc[trades.stock_id.isin(sell_instant_sids), 'exit_sig_date'] = temp.to_numpy()
-
-            r.trades = pd.concat([r.trades, pd.DataFrame({
-              'stock_id': buy_sids.map(f_id_to_name),
-              'entry_date': pd.NaT,
-              'entry_sig_date': r.position.index[-1],
-              'exit_date': pd.NaT,
-              'exit_sig_date': pd.NaT,
-            })], ignore_index=True)
-
-            r.trades['exit_sig_date'] = pd.to_datetime(r.trades.exit_sig_date)
-
-    r.add_trade_info('trade_price', market.get_trading_price(trade_at_price, adj=False), ['entry_date', 'exit_date'])
-    if len(r.trades) != 0 and not fast_mode:
-        r.run_analysis("Liquidity", display=False)
-
-    # add mae mfe to report
-    if len(trades) != 0:
-        trades = r.trades
-        mae_mfe = r.mae_mfe
-        exit_mae_mfe = mae_mfe['exit'].copy()
-        exit_mae_mfe = exit_mae_mfe.drop(columns=['return'])
-        r.trades = pd.concat([trades, exit_mae_mfe], axis=1)
-        r.trades.index.name = 'trade_index'
-
-        # calculate r.current_trades
-        # find trade without end or end today
-        maxday = max(r.trades.entry_sig_date.max(), r.trades.exit_sig_date.max())
-        latest_entry_day = r.trades.entry_sig_date[r.trades.entry_date.notna()].max()
-        r.current_trades = r.trades[
-                (r.trades.entry_sig_date == maxday )
-                | (r.trades.exit_sig_date == maxday)
-                | (r.trades.exit_sig_date >= latest_entry_day) # for the case of sl_enter, tp_enter
-                | (r.trades.entry_sig_date == latest_entry_day)
-                | (r.trades.exit_sig_date.isnull())]\
-            .set_index('stock_id')# \
-        
-        # cannot drop duplicates, because the same stock can be traded multiple times
-        # when a stock is exited and re-entered (tp_enter, sl_enter)
-            # .pipe(lambda df: df[~df.index.duplicated(keep='last')])
-
-        r.current_trades.loc[r.current_trades['return'].isna(), 'trade_price@entry_date'] = np.nan
-        r.current_trades.loc[r.current_trades['return'].isna(), 'trade_price@exit_date'] = np.nan
-
-        # r.next_trading_date = max(r.current_trades.entry_sig_date.max(), r.current_trades.exit_sig_date.max())
-
-        r.current_trades['weight'] = 0
-        if len(r.weights) != 0:
-            r.current_trades['weight'] = r.weights.reindex(r.current_trades.index).fillna(0)
-
-        r.current_trades['next_weights'] = 0
-        if len(r.next_weights) != 0:
-            r.current_trades['next_weights'] = r.next_weights.reindex(r.current_trades.index).fillna(0)
-
-        if len(r.current_trades):
-            r.current_trades.index = r.current_trades.index.map(f_id_to_name)
-
-    if "pyodide" in sys.modules and "js" in sys.modules:
-        set_global('backtest_report', {
-            'report': r.to_json(),
-            'position': r.position_info2()
-            })
-
-    if notification_enable:
-        line_notify(r, line_access_token)
-
-    if not upload:
-        return r
-
-    r.upload(name)
+import sys
+import warnings
+import datetime
+import numpy as np
+import pandas as pd
+from typing import Union
+from pandas.tseries.offsets import DateOffset
+from pandas.tseries.frequencies import to_offset
+
+import finlab
+from finlab.market_info import get_market_info
+from finlab import data, market_info
+from finlab.core import mae_mfe as maemfe
+from finlab.core import report
+from finlab.utils import check_version, requests, set_global
+from finlab.core.backtest_core import backtest_, get_trade_stocks
+from finlab.dataframe import FinlabDataFrame
+
+def warning_resample(resample):
+
+  if '+' not in resample and '-' not in resample:
+      return
+
+  if '-' in resample and not resample.split('-')[-1].isdigit():
+      return
+
+  if '+' in resample:
+      r, o = resample.split('+')
+  elif '-' in resample:
+      r, o = resample.split('-')
+
+  warnings.warn(f"The argument sim(..., resample = '{resample}') will no longer support after 0.1.37.dev1.\n"
+                f"please use sim(..., resample='{r}', offset='{o}d')", DeprecationWarning)
+
+
+
+def download_backtest_encryption_function_factory():
+
+    encryption_time = datetime.datetime.now()
+    encryption = ''
+
+    def ret():
+
+        nonlocal encryption_time
+        nonlocal encryption
+
+        if datetime.datetime.now() < encryption_time + datetime.timedelta(days=1) and encryption:
+            return encryption
+
+        res = requests.get('https://asia-east2-fdata-299302.cloudfunctions.net/auth_backtest',
+                {'api_token': finlab.get_token(), 'time': str(datetime.datetime.now())})
+
+        if not res.ok:
+            try:
+                result = res.json()
+            except:
+                result = None
+
+            print(result)
+            return ''
+
+        d = res.json()
+
+        if 'v' in d and 'v_msg' in d and finlab.__version__ < d['v']:
+            print(d['v_msg'])
+
+        if 'msg' in d:
+            print(d['msg'])
+
+        encryption_time = datetime.datetime.now()
+        encryption = d['encryption']
+
+        return encryption
+    return ret
+
+download_backtest_encryption = download_backtest_encryption_function_factory()
+
+
+def calc_essential_price(price, dates):
+
+    dt = min(price.index.values[1:] - price.index.values[:-1])
+
+    indexer = price.index.get_indexer(dates + dt)
+
+    valid_idx = np.where(indexer == -1, np.searchsorted(price.index, dates, side='right'), indexer)
+    valid_idx = np.where(valid_idx >= len(price), len(price) - 1, valid_idx)
+
+    return price.iloc[valid_idx]
+
+def arguments(price, high, low, open_, position, resample_dates=None, fast_mode=False):
+
+    resample_dates = price.index if resample_dates is None else resample_dates
+    position = position.astype(float).fillna(0)
+
+    if fast_mode:
+        date_index = pd.to_datetime(resample_dates)
+        position = position.reindex(date_index, method='ffill')
+        price = calc_essential_price(price, date_index)
+        high = calc_essential_price(high, date_index)
+        low = calc_essential_price(low, date_index)
+        open_ = calc_essential_price(open_, date_index)
+
+    resample_dates = pd.Series(resample_dates).view(np.int64).values
+
+    return [price.values,
+            high.values,
+            low.values,
+            open_.values,
+            price.index.view(np.int64),
+            price.columns.astype(str).values,
+            position.values,
+            position.index.view(np.int64),
+            position.columns.astype(str).values,
+            resample_dates
+            ]
+
+
+def line_notify(report=None, line_access_token:str='', test:bool=False):
+    """傳送回測結果之目前部位、近期換股訊息至Line聊天室。
+
+    Args:
+        report (Report):
+            回測完的結果報告。
+
+        line_access_token (str):
+            於Line Notify取得的access_token(權杖)。至[Line Notify](https://notify-bot.line.me/zh_TW/ )登入Line帳號後，點選個人頁面，點選「發行權杖」，選擇欲接收訊息的聊天室(可選擇1對1接收Line Notify通知、或是選擇其他群組聊天室)，即可取得權杖。
+        test (bool):
+            是否進行傳送訊息測試。
+
+    Examples:
+        欲進行測試，則設定`test`參數為True。
+
+        ``` py
+        from finlab import backtest
+
+        line_access_token = 'xxxxxxxxxxxx'
+        backtest.line_notify(line_access_token=line_access_token, test=True)
+        ```
+
+        若成功收到通知，則權杖設定已完畢，可直接在`sim`回測模組中開啟使用，或單獨調用此函式發送回測換股訊息。
+        於sim中使用:
+
+        ``` py
+        from finlab import backtest
+
+        line_access_token = 'xxxxxxxxxxxx'
+        position = ...
+        report = backtest.sim(position, notification_enable =True, line_access_token = line_access_token)
+        ```
+
+        已回測完，單獨傳訊息用:
+
+        ``` py
+        from finlab import backtest
+
+        line_access_token = 'xxxxxxxxxxxx'
+        report = backtest.sim(position)
+        backtest.line_notify(report, line_access_token=line_access_token)
+        ```
+
+    """
+    if test:
+        message = 'Finlab line_notify 測試成功'
+    else:
+        if not isinstance(report, finlab.core.report.Report):
+            raise Exception('Please provide a valid backtest report.')
+        hold = []
+        enter = []
+        exit = []
+        for i,p in report.position_info().items():
+            if isinstance(p,dict):
+                if i[:4].isdigit():
+                    if p['status'] in ['exit'] and pd.isnull(report.current_trades.loc[i].exit_date):
+                        hold.append(f"{i}: {p['entry_date'][:10]}, {str(p['entry_price'])}")
+                    if p['status'] in ['hold','sl','tp']:
+                        hold.append(f"{i}: {p['entry_date'][:10]}, {str(p['entry_price'])}")
+                    if p['status'] in ['enter']:
+                        enter.append(f"{i}: {p['entry_date'][:10]}的下個交易日進場")
+                    if p['status'] in ['exit','sl','tp', 'sl_enter', 'tp_enter']:
+                        exit.append(f"{i}: {p['exit_date'][:10]}的下個交易日出場")
+        message_lines = ['目前策略清單 進場日及進場價格：']
+        message_lines.extend(hold)
+        message_lines.append('------------------------------')
+        message_lines.append('近期操作：')
+        message_lines.append('-策略新增')
+        if len(enter) > 0:
+            message_lines.extend(enter)
+        else:
+            message_lines.append('尚無')
+        message_lines.append('-策略移除')
+        if len(exit) > 0:
+            message_lines.extend(exit)
+        else:
+            message_lines.append('尚無')
+        message = "\n".join(message_lines)
+
+    headers = {
+        "Authorization": "Bearer " + line_access_token,
+        "Content-Type" : "application/x-www-form-urlencoded"
+        }
+    r = requests.post("https://notify-api.line.me/api/notify", headers = headers, params = {'message': message})
+    if test:
+        if eval(r.text)['status'] == 401:
+            print(f'測試失敗。{r.text}')
+        elif eval(r.text)['status'] == 200:
+            print('測試成功，可開始使用finlab line_notify')
+
+def sim(position: Union[pd.DataFrame, pd.Series],
+        resample:Union[str, None]=None, resample_offset:Union[str, None] = None,
+        trade_at_price: Union[str, pd.DataFrame] = 'close',
+        position_limit:float=1, fee_ratio:float=1.425/1000,
+        tax_ratio: float=3/1000, name:str='未命名', stop_loss: Union[float, None]=None,
+        take_profit: Union[float, None]=None, trail_stop: Union[float, None]=None, touched_exit: bool=False,
+        retain_cost_when_rebalance: bool=False, stop_trading_next_period: bool=True, live_performance_start:Union[str, None]=None,
+        mae_mfe_window:int=0, mae_mfe_window_step:int=1, market:Union[str, market_info.MarketInfo]='AUTO', upload:bool=True, fast_mode=False,
+        notification_enable: bool=False, line_access_token: str='') -> report.Report:
+
+    """Simulate the equity given the stock position history. 回測模擬股票部位所產生的淨值報酬率。
+
+    Args:
+        position (pd.DataFrame or pd.Series):
+            買賣訊號紀錄。True 為持有， False 為空手。 若選擇做空position，只要將 sim(position) 改成負的 sim(-position.astype(float))即可做空。
+
+        resample (str, None, pd.DataFrame, pd.Series, finlab.dataframe.FinlabDataFrame):
+            交易週期。將 position 的訊號以週期性的方式論動股票，預設為每天換股。其他常用數值為 W、 M 、 Q （每週、每月、每季換股一次），也可以使用 W-Fri 在週五的時候產生新的股票清單，並且於下週交易日下單。
+
+            * `D`: Daily
+            * `W`: Weekly
+            * `W-Wed`: Every Wednesday
+            * `M`: Monthly
+            * `MS`: Start of every month
+            * `Q`: Quarterly
+            * `QS`: Start of every quarter
+
+            !!!note
+                'D'與'None'的差別？
+                resample='D' 的意義為每天隨股價變化做再平衡，就算當天股票清單沒變，但股票漲跌後，部位大小會變化，而 resample='D' 會強制再平衡，平均分散風險。
+
+                但是當 resample=None 的話，假如清單不變，則不會強制再平衡，只有清單改變時，才做再平衡。適用情境在較常選到大波段標的的趨勢策略，較有機會將強勢股留下，而不會汰強留弱做再平衡。
+
+            另外 `resample` 也接受 pd.DataFrame 以及 pd.Series，並且將其 index 用來當成換股的時間點，例如以下的範例：
+
+            ``` py
+            from finlab import backtest, data
+
+            rev = data.get('monthly_revenue:當月營收')
+            position = ...
+
+            # 月營收發布時才換股
+            backtest.sim(position, resample=rev)
+            ```
+
+
+
+        resample_offset (str or None):
+            交易週期的時間位移，例如。
+
+            - '1D': 位移一天
+            - '1H': 位移一小時
+
+        trade_at_price (str or pd.DataFrame):
+            選擇回測之還原股價以收盤價或開盤價計算，預設為'close'。可選'close'、'open'、'open_close_avg'、'high_low_avg'或 'price_avg'。
+
+        position_limit (float): maximum amount of investing a stock.
+            單檔標的持股比例上限，控制倉位風險。預設為None。範例：0.2，代表單檔標的最多持有 20 % 部位。
+
+        fee_ratio (float): fee ratio of buying or selling a stock.
+            交易手續費率，預設為台灣無打折手續費 0.001425。可視個人使用的券商優惠調整費率。
+
+        tax_ratio (float): tax ratio of selling a stock.
+            交易稅率，預設為台灣普通股一般交易交易稅率 0.003。若交易策略的標的皆為ETF，記得設成 0.001。
+
+        name (str): name of the strategy.
+            策略名稱，預設為 未指名。策略名稱。相同名稱之策略上傳會覆寫。命名規則:全英文或開頭中文，不接受開頭英文接中文。
+
+        stop_loss (float):
+            停損基準，預設為None，不執行停損。範例：0.1，代表從再平衡開始，虧損 10% 時產生出場訊號。
+
+        take_profit (float):
+            停利基準，預設為None，不執行停利。範例：0.1，代表從再平衡開始， 10% 時產生出場訊號。
+
+        trail_stop (float):
+            移動停損停利基準，預設為None，不執行。範例：0.1，代表從最高點開始下跌，跌至 10% 時產生出場訊號。
+
+        touched_exit (bool):
+            是否在回測時，使用觸價停損停利？預設為 False。
+
+        retain_cost_when_rebalance (bool):
+            預設回測時，會將進場股票進場成本更新到到新的 rebalance 的當天價格，假如希望保留原本的進場價格當成停損停利的依據，可以設定為 `True`
+
+        stop_trading_next_period (bool):
+            當期已經停損停利，則下一期不買入，預設為 True。
+
+        live_performance_start (str):
+            策略建構的日期，例如 `2022-01-01` 此日期之前，策略未撰寫，此日期之後則視為與實單有類似效果，實際不影響回測的結果，單純紀錄而已。
+
+        mae_mfe_window (int):
+            計算mae_mfe於進場後於不同持有天數下的數據變化，主要應用為edge_ratio (優勢比率)計算。預設為0，則Report.display_mae_mfe_analysis(...)中的edge_ratio不會顯現。
+
+        mae_mfe_window_step (int):
+            與mae_mfe_window參數做搭配，為時間間隔設定，預設為1。若mae_mfe_window設20，mae_mfe_window_step設定為2，相當於python的range(0,20,2)，以2日為間距計算mae_mfe。
+
+        market (str or MarketInfo):
+            可選擇`'TW_STOCK', 'CRYPTO'`，分別為台股或加密貨幣，
+            或繼承 finlab.market_info.MarketInfo 開發回測市場類別。
+
+        upload (bool):
+            上傳策略至finlab網站，預設為True，上傳策略。
+            範例： False，不上傳，可用 finlab.backtest.sim(position, upload=False, ...).display() 快速檢視策略績效。
+
+        fast_mode (bool):
+            預設為False，若設定為True，則會使用快速模式，快速模式會忽略所有的停利停損設定，並且只有換股日進行報酬率模擬，因此會有一些誤差，當持有較多檔股票時，可以大幅加速回測速度。
+
+    Returns:
+        (finlab.analysis.Report):回測數據報告
+
+    Examples:
+        Assume the history of portfolio is construct as follows: When market close on 2021-12-31, the portfolio {B: 0.2, C: 0.4} is calculated. When market close on 2022-03-31, the portfolio {A:1} is calculated.
+
+
+        |            | Stock 2330 | Stock 1101 | Stock 2454 |
+        |------------|------------|------------|------------|
+        | 2021-12-31 | 0%         | 20%        | 40%        |
+        | 2022-03-31 | 100%       | 0%         | 0%         |
+        | 2022-06-30 | 100%       | 0%         | 0%         |
+
+
+        With the portfolio, one could backtest the equity history as follows:
+
+        ``` py
+        import pandas as pd
+        from finlab import backtest
+
+        position = pd.DataFrame({
+            '2330': [0, 1, 1],
+            '1101': [0.2, 0, 0],
+            '2454': [0.4, 0, 0]
+        }, index=pd.to_datetime(['2021-12-31', '2022-03-31', '2022-06-30']))
+
+        report = backtest.sim(position)
+        ```
+
+    """
+
+    # check version
+    check_version()
+
+    if notification_enable == True and line_access_token == '':
+        raise Exception('line_access_token is required when enabling notifications. Please provide a valid token.')
+
+    if isinstance(position, FinlabDataFrame):
+        position = position.index_str_to_date()
+
+    if (trail_stop is not None or stop_loss is not None or take_profit is not None) and fast_mode:
+        raise Exception('fast_mode cannot be used with trail_stop, stop_loss or take_profit.')
+
+    # check type of position
+    if not isinstance(position.index, pd.DatetimeIndex):
+        raise TypeError("Expected the dataframe to have a DatetimeIndex")
+
+    if isinstance(position, pd.Series) and position.name is None:
+        raise Exception('Asset name not found. Please asign asset name by "position.name = \'2330\'".')
+
+    # auto detect market type
+    # todo: use less hacky method to identify the market
+    market = get_market_info(position, user_market_info=market)
+
+    if not isinstance(market, market_info.MarketInfo):
+        raise Exception("It seems like the market has"
+            "not been specified well when using the hold_until"
+            " function. Please provide the market='TW', "
+            "market='US' or market=MarketInfo")
+
+    # determine trading price
+    price = trade_at_price
+    if isinstance(trade_at_price, str):
+        price = market.get_trading_price(trade_at_price, adj=True)
+
+    assert isinstance(price, pd.DataFrame)
+
+    if isinstance(trade_at_price, pd.DataFrame) and touched_exit:
+        print('**WARNING: Using trade_at_price as dataframe without high, and low price. Candle information is not completed.')
+        print('           The backtest result can be incorrect when touched_exit=True.')
+        print('           If the complete backtest result is required, please implement MarketInfo with get_price function.')
+        print('           MarketInfo details: https://doc.finlab.tw/reference/market_info/')
+        print('           And use backtest.sim(..., market=MarketInfo) during backtest, so that the correct information is accessable from backtest.sim().')
+
+    try:
+        if isinstance(live_performance_start, str):
+            live_performance_start = datetime.datetime.fromisoformat(live_performance_start)
+    except:
+        raise Exception("**ERROR: live_performance_start string format not valid. It should be ISO format, i.e. YYYY-MM-DD.")
+
+
+    high = price
+    low = price
+    open_ = price
+    if touched_exit:
+        high = market.get_price('high', adj=True).reindex_like(price)
+        low = market.get_price('low', adj=True).reindex_like(price)
+        open_ = market.get_price('open', adj=True).reindex_like(price)
+
+    # check position types
+    if isinstance(position, pd.Series):
+        if position.name in price.columns:
+            position = position.to_frame()
+        else:
+            raise Exception('Asset name not found. Please asign asset name by "position.name = \'2330\'".')
+
+    # check position is valid
+    # if position.abs().sum().sum() == 0 or len(position.index) == 0:
+    #     raise Exception('Position is empty and zero stock is selected.')
+
+    # format position index
+    if isinstance(position.index[0], str):
+        position = FinlabDataFrame(position).index_str_to_date()
+
+    if not isinstance(position.index, pd.DatetimeIndex):
+        raise Exception("The DataFrame index is not of type DatetimeIndex!")
+
+    # if position date is very close to price end date, run all backtesting dates
+    assert len(position.shape) >= 2
+    delta_time_rebalance = position.index[-1] - position.index[-3]
+    backtest_to_end = position.index[-1] + \
+        delta_time_rebalance > price.index[-1]
+
+
+    tz = position.index.tz
+    now = datetime.datetime.now(tz=tz)
+
+    # check if position date is daily (pd.Timestamp hour, minute, second is 0)
+    is_daily = (position.index.hour == 0).all()\
+        and (position.index.minute == 0).all()\
+        and (position.index.second == 0).all()
+
+    # set now to yesterday's end if is_daily position
+    if is_daily and datetime.datetime.now(tz=market.tzinfo()) < market.market_close_at_timestamp():
+        now = now.replace(hour=23, minute=59, second=0, microsecond=0) - datetime.timedelta(days=1)
+
+    present_data_date = max(price.index[-1], now)
+
+    position = position[(position.index <= present_data_date)]
+    backtest_end_date = price.index[-1] if backtest_to_end else position.index[-1]
+
+    # resample dates
+    dates = None
+    next_trading_date = position.index[-1]
+    if isinstance(resample, pd.DataFrame) or isinstance(resample, pd.Series):
+
+        if isinstance(resample.index, pd.DatetimeIndex):
+            dates = resample.index.tolist()
+        elif isinstance(resample, FinlabDataFrame):
+            dates = resample.index_str_to_date().index.tolist()
+
+        dates = [d for d in dates if position.index[0] <= d and d <= present_data_date]
+        next_trading_date = dates[-1]
+
+    elif isinstance(resample, pd.DatetimeIndex):
+
+        dates = resample.tolist()
+        dates = [d for d in dates if position.index[0] <= d and d <= present_data_date]
+        next_trading_date = dates[-1]
+
+    elif isinstance(resample, str):
+
+        if pd.__version__ >= '3.0.0':
+            old_resample_strings = ['M', 'BM', 'SM', 'CBM', 'Q', 'BQ', 'A', 'Y', 'BY']
+            if resample in old_resample_strings:
+                resample += 'E'
+
+        # add additional day offset
+        offset_days = 0
+        if '+' in resample:
+            offset_days = int(resample.split('+')[-1])
+            resample = resample.split('+')[0]
+        if '-' in resample and resample.split('-')[-1].isdigit():
+            offset_days = -int(resample.split('-')[-1])
+            resample = resample.split('-')[0]
+
+        # generate rebalance dates
+        alldates = pd.date_range(
+            position.index[0],
+            present_data_date + datetime.timedelta(days=360),
+            freq=resample, tz=tz)
+
+        alldates += DateOffset(days=offset_days)
+
+        if resample_offset is not None:
+            alldates += to_offset(resample_offset)
+
+        dates = [d for d in alldates if position.index[0]
+                 <= d and d <= present_data_date]
+
+        # calculate the latest trading date
+        if price.index[-1] > dates[-1]:
+            dates += [min(set(alldates) - set(dates))]
+
+        next_trading_date = dates[-1]
+
+    elif resample is None:
+        # user set resample to None. Rebalance everyday might cause over transaction.
+        # remove rebalance date if portfolio is the same.
+        change = (position.diff().abs().sum(axis=1) != 0) | ((position.index == position.index[0]) & position.iloc[0].notna().any())
+        position = position.loc[change]
+
+    if stop_loss is None or stop_loss == 0:
+        stop_loss = 1
+
+    if take_profit is None or take_profit == 0:
+        take_profit = np.inf
+
+    if trail_stop is None or trail_stop == 0:
+        trail_stop = np.inf
+
+    if dates is not None:
+        position = position.reindex(dates, method='ffill')
+
+    encryption = download_backtest_encryption()
+
+    if encryption == '':
+        raise Exception('Cannot perform backtest, permission denied.')
+
+    args = arguments(price, high, low, open_, position, dates, fast_mode=fast_mode)
+
+    creturn_value = backtest_(*args,
+                              encryption=encryption,
+                              fee_ratio=fee_ratio, tax_ratio=tax_ratio,
+                              stop_loss=stop_loss, take_profit=take_profit, trail_stop=trail_stop,
+                              touched_exit=touched_exit, position_limit=position_limit,
+                              retain_cost_when_rebalance=retain_cost_when_rebalance,
+                              stop_trading_next_period=stop_trading_next_period,
+                              mae_mfe_window=mae_mfe_window, mae_mfe_window_step=mae_mfe_window_step)
+
+    total_weight = position.abs().sum(axis=1).clip(1, None)
+
+    position = position.div(total_weight.where(total_weight!=0, np.nan), axis=0).fillna(0)\
+                       .clip(-abs(position_limit), abs(position_limit))
+
+
+    creturn_dates = dates if dates and fast_mode else price.index
+
+    creturn = (pd.Series(creturn_value, creturn_dates)
+                # remove the begining of creturn since there is no pct change
+                .pipe(lambda df: df[(df != 1).cumsum().shift(-1, fill_value=1) != 0])
+                # remove the tail of creturn for verification
+                .loc[:backtest_end_date]
+                # replace creturn to 1 if creturn is None
+                .pipe(lambda df: df if len(df) != 0 else pd.Series(1, position.index)))
+
+    position = position.loc[creturn.index[0]:]
+
+    price_index = args[4]
+    position_columns = args[8]
+    trades, operation_and_weight = get_trade_stocks(position_columns,
+                                                    price_index, touched_exit=touched_exit)
+
+    ####################################
+    # refine mae mfe dataframe
+    ####################################
+    def refine_mae_mfe():
+        if len(maemfe.mae_mfe) == 0:
+            return pd.DataFrame()
+
+        m = pd.DataFrame(maemfe.mae_mfe)
+        nsets = int((m.shape[1]-1) / 6)
+
+        metrics = ['mae', 'gmfe', 'bmfe', 'mdd', 'pdays', 'return']
+
+        tuples = sum([[(n, metric) if n == 'exit' else (n * mae_mfe_window_step, metric)
+                       for metric in metrics] for n in list(range(nsets)) + ['exit']], [])
+
+        m.columns = pd.MultiIndex.from_tuples(
+            tuples, names=["window", "metric"])
+        m.index.name = 'trade_index'
+        m[m == -1] = np.nan
+
+        exit = m.exit.copy()
+
+        if touched_exit and len(m) > 0 and 'exit' in m.columns:
+            m['exit'] = (exit
+                .assign(gmfe=exit.gmfe.clip(-abs(stop_loss), abs(take_profit)))
+                .assign(bmfe=exit.bmfe.clip(-abs(stop_loss), abs(take_profit)))
+                .assign(mae=exit.mae.clip(-abs(stop_loss), abs(take_profit)))
+                .assign(mdd=exit.mdd.clip(-abs(stop_loss), abs(take_profit))))
+
+        return m
+
+    m = refine_mae_mfe()
+
+    ####################################
+    # refine trades dataframe
+    ####################################
+    def convert_datetime_series(df):
+        cols = ['entry_date', 'exit_date', 'entry_sig_date', 'exit_sig_date']
+        df[cols] = df[cols].apply(lambda s: pd.to_datetime(s).dt.tz_localize(tz))
+        return df
+
+    def assign_exit_nat(df):
+        cols = ['exit_date', 'exit_sig_date']
+        df[cols] = df[cols].loc[df.exit_index != -1]
+        return df
+
+    trades = (pd.DataFrame(trades,
+                           columns=['stock_id', 'entry_date', 'exit_date',
+                                    'entry_sig_date', 'exit_sig_date', 'position',
+                                    'period', 'entry_index', 'exit_index'])
+              .rename_axis('trade_index')
+              .pipe(convert_datetime_series)
+              .pipe(assign_exit_nat)
+              )
+
+    if len(trades) != 0:
+        trades = trades.assign(**{'return': (1 - fee_ratio) * (m.iloc[:, -1]+1) * (1 - tax_ratio - fee_ratio) - 1})
+
+        if touched_exit:
+            min_return = (1 - fee_ratio) * (1 - abs(stop_loss)) * (1 - tax_ratio - fee_ratio) - 1
+            max_return = (1 - fee_ratio) * (1 + abs(take_profit)) * (1 - tax_ratio - fee_ratio) - 1
+            trades['return'] = trades['return'].clip(min_return, max_return)
+
+    r = report.Report(
+        creturn=creturn,
+        position=position,
+        fee_ratio=fee_ratio,
+        tax_ratio=tax_ratio,
+        trade_at=trade_at_price,
+        next_trading_date=next_trading_date,
+        market_info=market)
+
+    r.resample = resample if isinstance(resample, str) else None
+    r.stop_loss = stop_loss
+    r.take_profit = take_profit
+    r.trail_stop = trail_stop
+    r.live_performance_start = live_performance_start
+
+    r.mae_mfe = m
+
+    r.trades = trades
+
+    # calculate weights
+    if len(operation_and_weight['weights']) != 0:
+        r.weights = pd.Series(operation_and_weight['weights'])
+        r.weights.index = r.position.columns[r.weights.index]
+    else:
+        r.weights = pd.Series(dtype='float64')
+
+
+    # calculate next weights
+    if len(operation_and_weight['next_weights']) != 0:
+        r.next_weights = pd.Series(operation_and_weight['next_weights'])
+        r.next_weights.index = r.position.columns[r.next_weights.index]
+    else:
+        r.next_weights = pd.Series(dtype='float64')
+
+
+    # calculate actions
+    if len(operation_and_weight['actions']) != 0:
+        # find selling and buying stocks
+        r.actions = pd.Series(operation_and_weight['actions'])
+        r.actions.index = r.position.columns[r.actions.index]
+    else:
+        r.actions = pd.Series(dtype=object)
+
+
+    # fill stock id to trade history
+    snames = market.get_asset_id_to_name()
+    f_id_to_name = lambda sid: f"{sid + ' ' + snames[sid] if sid in snames else sid}"
+    if len(trades) != 0:
+        r.trades['stock_id'] = r.trades.stock_id.map(f_id_to_name)
+
+    if hasattr(r, 'actions') and len(r.actions) != 0:
+        r.actions.index = r.actions.index.map(f_id_to_name)
+
+    r.weights.index = r.weights.index.map(f_id_to_name)
+    r.next_weights.index = r.next_weights.index.map(f_id_to_name)
+
+    if len(r.actions) != 0:
+
+        actions = r.actions
+
+        sell_sids = actions[actions == 'exit'].index
+        sell_instant_sids = actions[(actions == 'sl') | (actions == 'tp')
+                                    | (actions == 'sl_enter') | (actions == 'tp_enter')].index
+        buy_sids = actions[actions == 'enter'].index
+
+        if len(trades):
+            # check if the sell stocks are in the current position
+            assert len(set(sell_sids) - set(trades.stock_id[trades.exit_sig_date.isnull()])) == 0
+
+            # fill exit_sig_date and exit_date
+            temp = trades.loc[trades.stock_id.isin(sell_sids), 'exit_sig_date'].fillna(r.position.index[-1])
+            trades.loc[trades.stock_id.isin(sell_sids), 'exit_sig_date'] = temp
+
+            temp = trades.loc[trades.stock_id.isin(sell_instant_sids), 'exit_sig_date'].fillna(price.index[-1])
+            trades.loc[trades.stock_id.isin(sell_instant_sids), 'exit_sig_date'] = temp.to_numpy()
+
+            r.trades = pd.concat([r.trades, pd.DataFrame({
+              'stock_id': buy_sids.map(f_id_to_name),
+              'entry_date': pd.NaT,
+              'entry_sig_date': r.position.index[-1],
+              'exit_date': pd.NaT,
+              'exit_sig_date': pd.NaT,
+            })], ignore_index=True)
+
+            r.trades['exit_sig_date'] = pd.to_datetime(r.trades.exit_sig_date)
+
+    r.add_trade_info('trade_price', market.get_trading_price(trade_at_price, adj=False), ['entry_date', 'exit_date'])
+    if len(r.trades) != 0 and not fast_mode:
+        r.run_analysis("Liquidity", display=False)
+
+    # add mae mfe to report
+    if len(trades) != 0:
+        trades = r.trades
+        mae_mfe = r.mae_mfe
+        exit_mae_mfe = mae_mfe['exit'].copy()
+        exit_mae_mfe = exit_mae_mfe.drop(columns=['return'])
+        r.trades = pd.concat([trades, exit_mae_mfe], axis=1)
+        r.trades.index.name = 'trade_index'
+
+        # calculate r.current_trades
+        # find trade without end or end today
+        maxday = max(r.trades.entry_sig_date.max(), r.trades.exit_sig_date.max())
+        latest_entry_day = r.trades.entry_sig_date[r.trades.entry_date.notna()].max()
+        r.current_trades = r.trades[
+                (r.trades.entry_sig_date == maxday )
+                | (r.trades.exit_sig_date == maxday)
+                | (r.trades.exit_sig_date >= latest_entry_day) # for the case of sl_enter, tp_enter
+                | (r.trades.entry_sig_date == latest_entry_day)
+                | (r.trades.exit_sig_date.isnull())]\
+            .set_index('stock_id')# \
+        
+        # cannot drop duplicates, because the same stock can be traded multiple times
+        # when a stock is exited and re-entered (tp_enter, sl_enter)
+            # .pipe(lambda df: df[~df.index.duplicated(keep='last')])
+
+        r.current_trades.loc[r.current_trades['return'].isna(), 'trade_price@entry_date'] = np.nan
+        r.current_trades.loc[r.current_trades['return'].isna(), 'trade_price@exit_date'] = np.nan
+
+        # r.next_trading_date = max(r.current_trades.entry_sig_date.max(), r.current_trades.exit_sig_date.max())
+
+        r.current_trades['weight'] = 0
+        if len(r.weights) != 0:
+            r.current_trades['weight'] = r.weights.reindex(r.current_trades.index).fillna(0)
+
+        r.current_trades['next_weights'] = 0
+        if len(r.next_weights) != 0:
+            r.current_trades['next_weights'] = r.next_weights.reindex(r.current_trades.index).fillna(0)
+
+        if len(r.current_trades):
+            r.current_trades.index = r.current_trades.index.map(f_id_to_name)
+
+    if "pyodide" in sys.modules and "js" in sys.modules:
+        set_global('backtest_report', {
+            'report': r.to_json(),
+            'position': r.position_info2()
+            })
+
+    if notification_enable:
+        line_notify(r, line_access_token)
+
+    if not upload:
+        return r
+
+    r.upload(name)
     return r
```

## finlab/data.py

 * *Ordering differences only*

```diff
@@ -1,1290 +1,1290 @@
-import os
-import gc
-import re
-import sys
-import json
-import math
-import pickle
-import shutil
-import logging
-import hashlib
-import datetime
-import numpy as np
-import pandas as pd
-from io import BytesIO
-from typing import Union
-from functools import lru_cache
-
-import finlab.utils
-import finlab.dataframe
-import finlab.market_info
-
-logger = logging.getLogger(__name__)
-
-has_print_free_user_warning = False
-role = None
-
-use_local_data_only = False
-force_cloud_download = False
-
-class CacheStorage():
-
-    def __init__(self):
-        """將歷史資料儲存於快取中
-
-          Examples:
-              欲切換成以檔案方式儲存，可以用以下之方式：
-
-              ``` py
-              from finlab import data
-              data.set_storage(data.CacheStorage())
-              close = data.get('price:收盤價')
-              ```
-
-              可以直接調閱快取資料：
-
-              ``` py
-              close = data._storage._cache['price:收盤價']
-              ```
-        """
-
-        self._cache = {}
-        self._cache_time = {}
-        self._cache_expiry = {}
-        self._stock_names = {}
-
-    @staticmethod
-    def now():
-        return datetime.datetime.now(tz=datetime.timezone.utc)
-
-    def set_dataframe(self, name, df, expiry=None):
-        self._cache[name] = df
-        self._cache_time[name] = self.now()
-        self._cache_expiry[name] = expiry or self.now()
-
-    def set_stock_names(self, stock_names):
-        self._stock_names = {**self._stock_names, **stock_names}
-
-    def get_time_created(self, name):
-
-        if name not in self._cache or name not in self._cache_time:
-            return None
-
-        return self._cache_time[name]
-
-    def get_time_expired(self, name):
-
-        if name in self._cache_expiry:
-            return self._cache_expiry[name]
-
-        return None
-    
-    def set_time_expired(self, name, expiry):
-        self._cache_expiry[name] = expiry
-
-    def get_dataframe(self, name):
-
-        # not exists
-        if name not in self._cache or name not in self._cache_time:
-            return None
-
-        return self._cache[name]
-
-    def get_stock_names(self):
-        return self._stock_names
-
-
-class FileStorage():
-    def __init__(self, path=None, use_cache=True):
-        """將歷史資料儲存於檔案中
-
-          Args:
-                path (str): 資料儲存的路徑
-                use_cache (bool): 是否額外使用快取，將資料複製一份到記憶體中。
-
-          Examples:
-              欲切換成以檔案方式儲存，可以用以下之方式：
-
-              ``` py
-              from finlab import data
-              data.set_storage(data.FileStorage())
-              close = data.get('price:收盤價')
-              ```
-
-              可以在本地端的 `./finlab_db/price#收盤價.pickle` 中，看到下載的資料，
-              可以使用 `pickle` 調閱歷史資料：
-              ``` py
-              import pickle
-              close = pickle.load(open('finlab_db/price#收盤價.pickle', 'rb'))
-              ```
-        """
-        if path is None:
-            path = finlab.utils.get_tmp_dir()
-            
-        self._path = path
-        self._cache = {}
-        self._stock_names = None
-        self._expiry = {}
-        self.use_cache = use_cache
-
-        if not os.path.isdir(path):
-            os.mkdir(path)
-
-        f_stock_names = os.path.join(path, 'stock_names.pkl')
-
-        if not os.path.isfile(f_stock_names):
-            with open(f_stock_names, 'wb') as f:
-                pickle.dump({}, f)
-        else:
-            with open(f_stock_names, 'rb') as f:
-                self._stock_names = pickle.load(f)
-
-        f_expiry = os.path.join(self._path, 'expiry.pkl')
-
-        if os.path.isfile(f_expiry):
-            with open(f_expiry, 'rb') as f:
-                try:
-                    self._expiry = pickle.load(f)
-                except:
-                    self._expiry = {}
-        
-        if self._expiry:
-            res = finlab.utils.requests.get('https://asia-east1-fdata-299302.cloudfunctions.net/data_reset_time')
-            reset_data_time = datetime.datetime.fromtimestamp(float(res.text), tz=datetime.timezone.utc)
-            for k, v in self._expiry.items():
-                created = self.get_time_created(k)
-                if created and created  < reset_data_time:
-                    logger.info(f' set {k} time expired since the system reset time: {reset_data_time} > created time: {self.get_time_created(k)}')
-                    self.set_time_expired(k, reset_data_time, save=False)
-
-        self.save_expiry()
-
-
-    def set_dataframe(self, name, df, expiry=None):
-
-        file_path = os.path.join(
-            self._path, name.replace(':', '#') + '.pickle')
-        try:
-            df.to_pickle(file_path)
-        except:
-            logger.warning(f' {name} save dataframe fail please check your disk permission or memory usage')
-            return
-
-        if self.use_cache:
-            self._cache[name] = df
-
-        self._expiry[name] = expiry or CacheStorage.now()
-        self.save_expiry()
-
-    def get_time_created(self, name):
-
-        # check existence
-        file_path = os.path.join(
-            self._path, name.replace(':', '#') + '.pickle')
-
-        if not os.path.isfile(file_path):
-            return None
-
-        return datetime.datetime.fromtimestamp(
-            os.path.getmtime(file_path), tz=datetime.timezone.utc)
-
-    def get_time_expired(self, name):
-
-        if name in self._expiry:
-            return self._expiry[name]
-
-        return None
-    
-    def set_time_expired(self, name, expiry, save=True):
-        self._expiry[name] = expiry
-        if save:
-            self.save_expiry()
-
-    def save_expiry(self):
-        try:
-            with open(os.path.join(self._path, 'expiry.pkl'), 'wb') as f:
-                pickle.dump(self._expiry, f)
-        except Exception as e:
-            logger.warning(f' save expiry fail {e}')
-            pass
-
-    def get_dataframe(self, name):
-
-        if name in self._cache:
-            return self._cache[name]
-
-        file_path = os.path.join(
-            self._path, name.replace(':', '#') + '.pickle')
-
-        if os.path.isfile(file_path):
-            try:
-                ret = pd.read_pickle(file_path)
-                if self.use_cache:
-                    self._cache[name] = ret
-            except:
-                return None
-            return ret
-
-        return None
-
-    def set_stock_names(self, stock_names):
-        self._stock_names = {**self._stock_names, **stock_names}
-
-        with open(os.path.join(self._path, 'stock_names.pkl'), 'wb') as f:
-            pickle.dump(self._stock_names, f)
-
-    def get_stock_names(self):
-
-        if self._stock_names is not None:
-            return self._stock_names
-
-        with open(os.path.join(self._path, 'stock_names.pkl'), 'rb') as f:
-            stock_names = pickle.load(f)
-        self._stock_names = stock_names
-        return stock_names
-    
-    def clear(self):
-        folder_path = self._path
-        for filename in os.listdir(folder_path):
-            file_path = os.path.join(folder_path, filename)
-            try:
-                if os.path.isfile(file_path) or os.path.islink(file_path):
-                    os.unlink(file_path)
-                elif os.path.isdir(file_path):
-                    shutil.rmtree(file_path)
-            except Exception as e:
-                print(f'Failed to delete {file_path}. Reason: {e}')
-
-def clear():
-    """清除本地端儲存的歷史資料，並還原初始設定。
-    Examples:
-        ``` py
-        from finlab import data
-        data.clear()
-        ```
-    """
-    global _storage
-    if isinstance(_storage, FileStorage):
-        _storage.clear()
-    _storage = FileStorage()
-
-
-_storage = FileStorage()
-universe_stocks = set()
-
-
-def set_storage(storage):
-    """設定本地端儲存歷史資料的方式
-    假設使用 `data.get` 獲取歷史資料則，在預設情況下，程式會自動在本地複製一份，以避免重複下載大量數據。
-    storage 就是用來儲存歷史資料的接口。我們提供兩種 `storage` 接口，分別是 `finlab.data.CacheStorage` (預設) 以及
-    `finlab.data.FileStorage`。前者是直接存在記憶體中，後者是存在檔案中。詳情請參考 `CacheStorage` 和 `FileStorage` 來獲得更詳細的資訊。
-    在預設情況下，程式會自動使用 `finlab.data.FileStorage` 並將重複索取之歷史資料存在作業系統預設「暫時資料夾」。
-
-    Args:
-        storage (data.Storage): The interface of storage
-
-    Examples:
-        欲切換成以檔案方式儲存，可以用以下之方式：
-
-        ``` py
-        from finlab import data
-        data.set_storage(data.FileStorage())
-        close = data.get('price:收盤價')
-        ```
-
-        可以在本地端的 `./finlab_db/price#收盤價.pickle` 中，看到下載的資料，
-        可以使用 `pickle` 調閱歷史資料：
-        ``` py
-        import pickle
-        close = pickle.load(open('finlab_db/price#收盤價.pickle', 'rb'))
-        ```
-    """
-
-    global _storage
-    _storage = storage
-
-
-class universe():
-    def __init__(self, market='ALL', category='ALL'):
-        """當呼叫 `data.get` 或是 `data.indicator` 時，返回產業相關類股。
-
-        Args:
-            market (str): Universe market type. ex: `ALL`, `TSE`, `OTC`, `TSE_OTC`, `ETF`, `STOCK_FUTURE`
-            category (str or list)): Stock categories. ex: `光電業`, `其他`, `其他電子業`, `化學工業`, `半導體`, `塑膠工業`, `存託憑證`, `建材營造`, `文化創意業`, `橡膠工業`, `水泥工業`,`汽車工業`, `油電燃氣業`, `玻璃陶瓷`, `生技醫療`, `生技醫療業`, `紡織纖維`, `航運業`, `觀光事業`, `貿易百貨`, `資訊服務業`, `農業科技`, `通信網路業`, `造紙工業`, `金融`, `鋼鐵工業`, `電器電纜`, `電子商務`, `電子通路業`, `電子零組件`, `電機機械`, `電腦及週邊`, `食品工業`
-
-        Examples:
-            想要當鋼鐵人、航海王，可以用以下方法將這些類股一次選出來
-            ``` py
-            with universe('TSE_OTC', ['鋼鐵工業', '航運業']):
-                close_subset = data.get('price:收盤價')
-                print(close_subset)
-            ```
-
-            | date       |   2002 |   2006 |   ..   |   2008 |   2009 |
-            |:-----------|-------:|-------:|-------:|-------:|-------:|
-            | 2007-04-23 |  39.65 |  38.3  |   ..   |   7.8  |  17.55 |
-            | 2007-04-24 |  39.85 |  38.85 |   ..   |   8.34 |  17.5  |
-            | 2007-04-25 |  39.25 |  38.1  |   ..   |   8.25 |  17.3  |
-            | 2007-04-26 |  39    |  37.85 |   ..   |   8.2  |  17.3  |
-            | 2007-04-27 |  38.2  |  37.2  |   ..   |   7.88 |  16.6  |
-
-        """
-        self._market = market
-        self._category = category
-        self._previous_stocks = set()
-
-    def __enter__(self):
-        global universe_stocks
-        self._previous_stocks = universe_stocks
-        set_universe(self._market, self._category)
-        return self
-
-    def __exit__(self, type, value, traceback):
-        global universe_stocks
-        universe_stocks = self._previous_stocks
-
-
-def set_universe(market: str = 'ALL', category='ALL', industry='All'):
-    """Set subset of stock ids when retrieve data using data.get or data.indicator
-
-    Args:
-        market (str): universe market type. ex: 'ALL', 'TSE', 'OTC', 'TSE_OTC', 'ETF', 'STOCK_FUTURE'
-        category (str): stock categories, can be either a string or a list. ex: '光電業', '其他', '其他電子業',
-    '化學工業', '半導體', '塑膠工業', '存託憑證', '建材營造', '文化創意業', '橡膠工業', '水泥工業',
-    '汽車工業', '油電燃氣業', '玻璃陶瓷', '生技醫療', '生技醫療業', '紡織纖維', '航運業', '觀光事業', '貿易百貨',
-    '資訊服務業', '農業科技', '通信網路業', '造紙工業', '金融', '鋼鐵工業', '電器電纜', '電子商務',
-    '電子通路業', '電子零組件', '電機機械', '電腦及週邊', '食品工業'
-    當 `market == 'ETF'` 時，可以選擇：
-    * `domestic_etf`: 以台股為成分股之 ETF
-    * `foreign_etf`: 以國外商品為成分股之 ETF
-    * `leveraged_etf`: 槓桿型 ETF
-    * `vanilla_futures_etf`: 無槓桿期貨 ETF
-    * `leveraged_futures_etf`: 槓桿型期貨 ETF
-
-    """
-
-    categories = get('security_categories').reset_index().set_index('stock_id')
-
-    market_match = pd.Series(True, categories.index)
-
-    if 'TSE' in market and 'OTC' in market:
-        market = 'TSE_OTC'
-
-    if market == 'ALL':
-        pass
-    elif market == 'TSE':
-        market_match = categories.market == 'sii'
-    elif market == 'OTC':
-        market_match = categories.market == 'otc'
-    elif market == 'TSE_OTC':
-        market_match = (categories.market == 'sii') | (
-            categories.market == 'otc')
-    elif market == 'ETF':
-        market_match = categories.market == 'etf'
-    elif market == 'STOCK_FUTURE':
-        market_match = get('single_stock_futures_and_equity_options_underlying')\
-            .pipe(lambda df: df[df['是否為股票期貨標的'] == 'Y'])\
-            .pipe(lambda df: pd.Series(True, set(df.stock_id)).reindex(categories.index).fillna(False))
-
-    category_match = pd.Series(True, categories.index)
-
-    if category == 'ALL':
-        pass
-    else:
-        if isinstance(category, str):
-            category = [category]
-
-        matched_categories = set()
-        all_categories = set(categories.category)
-        for ca in category:
-            matched_categories |= (
-                set([c for c in all_categories if isinstance(c, str) and re.search(ca, c)]))
-        category_match = categories.category.isin(matched_categories)
-
-    global universe_stocks
-    universe_stocks = set(categories.index[market_match & category_match])
-
-
-class us_universe:
-    def __init__(self, market='ALL', sector='ALL', industry='ALL', exchange='ALL'):
-        """當呼叫 `data.get` 或是 `data.indicator` 時，返回美股產業相關類股。
-
-        Args:
-            market (str): Universe market type.
-                          ex: `Common Stock`, `Preferred Stock`, `Domestic`, `Domestic Common Stock`, `ADR`
-            sector (str or list): The sector the stock belongs to.
-                                  ex:`Basic Materials`,`Communication Services`,`Consumer Cyclical`,`Consumer Defensive`,`Energy`,`Financial Services`,`Healthcare`,`Industrials`,`Real Estate`,`Technology`,`Utilities`
-            industry (str or list): The industry the stock belongs to.See industry list from `set(data.get('us_tickers')['industry'])`.ex:`Steel`,`Software - Application`...
-            exchange (str or list): The exchange the stock belongs to.
-                                   ex:`BATS`, `INDEX`, `NASDAQ`, `NYSE`, `NYSEARCA`, `NYSEMKT`, `OTC`
-
-        Examples:
-            想選出美股普通股中的科技類股
-            ``` py
-            with us_universe('Common Stock', ['Technology']):
-                close_subset = data.get('us_price:close')
-                print(close_subset)
-            ```
-
-            | date       |   AAOI  |  AAPL |   ..   |   ABCO |   NVDA |
-            |:-----------|-------:|-------:|-------:|-------:|-------:|
-            | 2017-01-03 |  39.65 |  38.3  |   ..   |   7.8  |  17.55 |
-            | 2017-01-04 |  39.85 |  38.85 |   ..   |   8.34 |  17.5  |
-            | 2017-01-05 |  39.25 |  38.1  |   ..   |   8.25 |  17.3  |
-            | 2017-01-06 |  39    |  37.85 |   ..   |   8.2  |  17.3  |
-            | 2017-01-09 |  38.2  |  37.2  |   ..   |   7.88 |  16.6  |
-
-            想選出美股特別股中的基礎原物料和能源類股
-            ``` py
-            with data.us_universe('Preferred Stock', ['Basic Materials','Energy']):
-                close_subset = data.get('us_price:close')
-                print(close_subset)
-            ```
-
-            | date       |   AEUA |  ALIN-PA |  ..  | ALIN-PB | ALIN-PE |
-            |:-----------|-------:|-------:|-------:|-------:|-------:|
-            | 2017-01-03 |  39.65 |  38.3  |   ..   |   7.8  |  17.55 |
-            | 2017-01-04 |  39.85 |  38.85 |   ..   |   8.34 |  17.5  |
-            | 2017-01-05 |  39.25 |  38.1  |   ..   |   8.25 |  17.3  |
-            | 2017-01-06 |  39    |  37.85 |   ..   |   8.2  |  17.3  |
-            | 2017-01-09 |  38.2  |  37.2  |   ..   |   7.88 |  16.6  |
-
-            想從美股 NASDAQ 交易所的普通股中篩選出軟體類股
-            ``` py
-            with data.us_universe('Common Stock', industry='Software', exchange='NASDAQ'):
-                close_subset = data.get('us_price:close')
-                print(close_subset)
-            ```
-
-            | date       |   ACIW |  ACVA |  ..  | ZI | ZS |
-            |:-----------|-------:|-------:|-------:|-------:|-------:|
-            | 2017-01-03 |  39.65 |  38.3  |   ..   |   7.8  |  17.55 |
-            | 2017-01-04 |  39.85 |  38.85 |   ..   |   8.34 |  17.5  |
-            | 2017-01-05 |  39.25 |  38.1  |   ..   |   8.25 |  17.3  |
-            | 2017-01-06 |  39    |  37.85 |   ..   |   8.2  |  17.3  |
-            | 2017-01-09 |  38.2  |  37.2  |   ..   |   7.88 |  16.6  |
-
-
-            檢視有哪些產業可選擇
-            ``` py
-            print(set(data.get('us_tickers')['industry']))
-            ```
-            ```
-            {'Advertising Agencies',
-             'Aerospace & Defense',
-             'Agricultural Inputs',
-             'Airlines',
-             'Airports & Air Services',
-             'Aluminum',
-             ...}
-            ```
-
-        """
-        self._market = market
-        self._sector = sector
-        self._industry = industry
-        self._exchange = exchange
-        self._previous_stocks = set()
-
-    def __enter__(self):
-        global universe_stocks
-        self._previous_stocks = universe_stocks
-        set_us_universe(self._market, self._sector, self._industry, self._exchange)
-        return self
-
-    def __exit__(self, type, value, traceback):
-        global universe_stocks
-        universe_stocks = self._previous_stocks
-
-
-def set_us_universe(market: str = 'ALL', sector='ALL', industry='All', exchange='ALL'):
-    """Set subset of us stock ids when retrieve data using data.get or data.indicator
-
-    Args:
-        market (str): Universe market type.
-                      ex: `Common Stock`, `Preferred Stock`, `Domestic`, `Domestic Common Stock`, `ADR`
-        sector (str or list): The sector the stock belongs to.
-                              ex:`Basic Materials`,`Communication Services`,`Consumer Cyclical`,`Consumer Defensive`,`Energy`,`Financial Services`,`Healthcare`,`Industrials`,`Real Estate`,`Technology`,`Utilities`
-        industry (str or list): The industry the stock belongs to.See industry list from `set(data.get('us_tickers')['industry'])`.ex:`Steel`,`Software - Application`...
-        exchange (str or list): The exchange the stock belongs to.
-                               ex:`BATS`, `INDEX`, `NASDAQ`, `NYSE`, `NYSEARCA`, `NYSEMKT`, `OTC`
-    """
-
-    categories = get('us_tickers').reset_index().set_index('stock_id')
-    market_range = ['ADR Common Stock',
-                    'ADR Common Stock Primary Class',
-                    'ADR Common Stock Secondary Class',
-                    'ADR Preferred Stock',
-                    'Domestic Common Stock',
-                    'Domestic Common Stock Primary Class',
-                    'Domestic Common Stock Secondary Class',
-                    'Domestic Preferred Stock', ]
-
-    if market == 'ALL':
-        market_match = categories.category.isin(market_range)
-    else:
-        market_match = categories.category.isin([m for m in market_range if market in m])
-
-    def match_ids(column, item):
-        category_match = pd.Series(True, categories.index)
-        if item == 'ALL':
-            pass
-        else:
-            if isinstance(item, str):
-                item = [item]
-            matched_categories = set()
-            all_categories = set(categories[column])
-            for ca in item:
-                matched_categories |= (
-                    set([c for c in all_categories if isinstance(c, str) and re.search(ca, c)]))
-            category_match = categories[column].isin(matched_categories)
-        return category_match
-
-    sector_match = match_ids('sector', sector)
-    industry_match = match_ids('industry', industry)
-
-    exchange_match = pd.Series(True, categories.index)
-    if exchange == 'ALL':
-        pass
-    else:
-        if isinstance(exchange, str):
-            exchange = [exchange]
-        exchange_match = categories.exchange.isin(exchange)
-
-    global universe_stocks
-    universe_stocks = set(categories.index[market_match & sector_match & industry_match & exchange_match])
-
-not_available_universe_stocks = [
-    'benchmark_return', 'institutional_investors_trading_all_market_summary',
-    'margin_balance', 'intraday_trading_stat',
-    'stock_index_price', 'stock_index_vol',
-    'taiex_total_index', 'broker_info',
-    'rotc_monthly_revenue', 'rotc_price',
-    'world_index', 'rotc_broker_trade_record',
-    'security_categories', 'finlab_tw_stock_market_ind',
-    'tw_industry_pmi', 'tw_industry_nmi',
-    'tw_total_pmi', 'tw_total_nmi',
-    'tw_business_indicators', 'tw_business_indicators_details',
-    'tw_monetary_aggregates', 'us_unemployment_rate_seasonally_adjusted',
-    'us_tickers',
-    ]
-
-def refine_stock_id(dataset, ret):
-
-    ret = process_data(dataset, ret)
-    
-    if dataset in not_available_universe_stocks:
-        return ret
-
-    if not universe_stocks:
-        return ret
-
-    if ':' in dataset:
-        subset_stocks = ret.columns.intersection(universe_stocks)
-
-        if subset_stocks.any():
-            return ret.loc[:, subset_stocks]
-
-    if 'stock_id' in ret.columns:
-        subset_stocks = ret['stock_id'].isin(universe_stocks)
-
-        if subset_stocks.any():
-            return ret.loc[subset_stocks]
-
-    return ret
-
-
-@lru_cache(maxsize=None)
-def get_bucket_name():
-
-    def get_location():
-        response = finlab.utils.requests.get('http://ipinfo.io')
-        if response.status_code == 200:
-            data = response.json()
-            return data['city'], data['region'], data['country'], data['loc']
-
-    def haversine_distance(coord1, coord2):
-        R = 6371  # Radius of the Earth in km
-
-        lat1, lon1 = map(math.radians, coord1)
-        lat2, lon2 = map(math.radians, coord2)
-
-        dlat = lat2 - lat1
-        dlon = lon2 - lon1
-
-        a = math.sin(dlat / 2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2)**2
-        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
-
-        return R * c
-
-    def choose_storage_region(coordinates):
-        # Coordinates for us-east1 (South Carolina, USA)
-        us_east1_coord = (33.8361, -81.1637)
-
-        # Coordinates for asia-east1 (Taiwan)
-        asia_east1_coord = (23.6978, 120.9605)
-
-        user_coord = tuple(map(float, coordinates.split(',')))
-
-        distance_to_us_east1 = haversine_distance(user_coord, us_east1_coord)
-        distance_to_asia_east1 = haversine_distance(user_coord, asia_east1_coord)
-
-        if distance_to_us_east1 < distance_to_asia_east1:
-            return 'finlab_us_stock_item'
-        else:
-            return 'finlab_tw_stock_item'
-        
-    # Fetch location information
-    try:
-        city, region, country, loc = get_location()
-        # Choose the storage region based on the coordinates
-        ret = choose_storage_region(loc)
-        logger.info(f'User location: {city}, {region}, {country}, {loc} -> select {ret} as storage region')
-        return ret
-    except:
-        pass
-    
-    return 'finlab_tw_stock_item'
-
-
-
-def fetch_data(dataset: str, time_saved=None):
-    """
-    Fetches data from a specified dataset.
-
-    Args:
-        dataset (str): The name of the dataset to fetch.
-        time_saved (datetime, optional): The time to fetch the data from. Defaults to None.
-
-    Returns:
-        dict: A dictionary containing the fetched data and other information.
-    """
-
-    url = 'https://asia-east2-fdata-299302.cloudfunctions.net/auth_generate_data_url'
-    params = {
-        'api_token': finlab.get_token(),
-        'bucket_name': get_bucket_name(),
-        'blob_name': dataset.replace(':', '#') \
-                + ('.pickle' if "pyodide" in sys.modules else '.feather'),
-        'pyodide': 'pyodide' in sys.modules
-    }
-    if time_saved:
-        params['time_saved'] = time_saved.strftime('%Y%m%d%H%M%S')
-
-    headers = {'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36',}
-    res = finlab.utils.requests.post(url, params, headers=headers)
-    ret = res.json()
-
-    if 'error' in ret:
-
-        if ret['error'] in [
-            'request not valid',
-            'User not found',
-            'api_token not valid',
-            'api_token not match', ]:
-            finlab.login()
-            return fetch_data(dataset, time_saved)
-        
-        if ret['error'] == 'Usage exceed 500 MB/day. Please consider upgrade to VIP program.':
-            raise Exception(f"**Error: {ret['error']}")
-
-        return None
-
-    
-    # print free user warning
-    global has_print_free_user_warning
-    if not has_print_free_user_warning \
-            and 'role' in ret \
-            and ret['role'] == 'free':
-        print('Due to your status as a free user, '
-            'the most recent data has been shortened or limited.')
-        has_print_free_user_warning = True
-
-    if 'quota' in ret and '.recent' not in dataset:
-        print(f'Daily usage: {ret["quota"]:.1f} / {ret["limit_size"]} MB - {dataset}')
-
-    ret['expiry'] = datetime.datetime.strptime(
-        ret['time_scheduled'], '%Y%m%d%H%M%S').replace(tzinfo=datetime.timezone.utc)\
-        if 'time_scheduled' in ret else None
-    
-    # download data if server return an url
-    if 'url' in ret and len(ret['url']) > 0:
-
-        if 'pyodide' in sys.modules:
-            if hasattr(finlab.utils.requests, 'getBytes'):
-                res = finlab.utils.requests.getBytes(ret['url'])
-                df = pd.read_pickle(BytesIO(res), compression='gzip')
-            else:
-                res = finlab.utils.requests.get(ret['url'])
-                df = pd.read_pickle(BytesIO(res.content), compression='gzip')
-        else:
-            res = finlab.utils.requests.get(ret['url'], headers=headers)
-            df = pd.read_feather(BytesIO(res.content))
-
-        ret['data'] = df#process_data(dataset, df)
-    return ret
-
-
-def has_index_name(df, name):
-    # Check if the DataFrame has a single index
-    if df.index.name == name:
-        return True
-    # Check if the DataFrame has a MultiIndex
-    elif isinstance(df.index, pd.MultiIndex):
-        if name in df.index.names:
-            return True
-    return False
-
-def process_data(dataset, df):
-
-    if 'stock_id' in df.columns and 'date' in df.columns:
-        df.set_index(['stock_id', 'date'], inplace=True)
-    elif 'date' in df.columns:
-        df.set_index('date', inplace=True)
-    elif 'stock_id' in df.columns:
-        df.set_index('stock_id', inplace=True)
-
-    # special case (to align with tutorial)
-    if dataset == 'broker_transactions':
-        df = df.reset_index().set_index('date')
-
-    # the column name is stock id, and index is date
-    if ':' in dataset:
-        df.columns.name = f'symbol'
-
-    # table format
-    if ':' not in dataset:
-        df = df.reset_index()
-
-    if not has_index_name(df, 'date'):
-        return df
-
-    table_name = dataset.split(':')[0]
-    if table_name in ['tw_total_pmi', 'tw_total_nmi', 'tw_industry_nmi', 'tw_industry_pmi']:
-        if isinstance(df.index[0], pd.Timestamp):
-            close = get('price:收盤價')
-            df.index = df.index.map(
-                lambda d: d if len(close.loc[d:]) == 0 or d < close.index[0] else close.loc[d:].index[0])
-
-    # if column is stock name
-    if (df.columns.str.find(' ') != -1).all():
-
-        # remove stock names
-        df.columns = df.columns.str.split(' ').str[0]
-
-        # combine same stock history according to sid
-        check_numeric_dtype = pd.api.types.is_numeric_dtype(df.values)
-        if check_numeric_dtype:
-            df = df.transpose().groupby(level=0).mean().transpose()
-        else:
-            df = df.fillna(np.nan).transpose().groupby(
-                level=0).last().transpose()
-
-    df = finlab.dataframe.FinlabDataFrame(df)
-
-    if table_name in ['monthly_revenue', 'rotc_monthly_revenue']:
-        df = df._index_to_business_day()
-    elif table_name in ['financial_statement', 'fundamental_features',]:
-        df = df._index_date_to_str_season()
-    elif table_name in ['us_fundamental', 'us_fundamental_ART']:
-        df = df._index_date_to_str_season('-US')
-    elif table_name in ['us_fundamental_all', 'us_fundamental_all_ART']:
-        df = df._index_date_to_str_season('-US-ALL')
-
-    return df
-
-
-def hash(df):
-    return hashlib.md5(pd.util.hash_pandas_object(df, index=True).values).hexdigest()[:7]
-
-
-def get(dataset: str, save_to_storage: bool = True, force_download=False):
-    """下載歷史資料
-
-    請至[歷史資料目錄](https://ai.finlab.tw/database) 來獲得所有歷史資料的名稱，即可使用此函式來獲取歷史資料。
-    假設 `save_to_storage` 為 `True` 則，程式會自動在本地複製一份，以避免重複下載大量數據。
-
-    Args:
-        dataset (str): The name of dataset.
-        save_to_storage (bool): Whether to save the dataset to storage for later use. Default is True. The argument will be removed in the future. Please use data.set_storage(FileStorage(use_cache=True)) instead.
-        force_download (bool): Whether to force download the dataset from cloud. Default is False.
-
-    Returns:
-        (pd.DataFrame): financial data
-
-    Examples:
-        欲下載所有上市上櫃之收盤價歷史資料，只需要使用此函式即可:
-
-        ``` py
-        from finlab import data
-        close = data.get('price:收盤價')
-        close
-        ```
-
-        | date       |   0015 |   0050 |   0051 |   0052 |   0053 |
-        |:-----------|-------:|-------:|-------:|-------:|-------:|
-        | 2007-04-23 |   9.54 |  57.85 |  32.83 |  38.4  |    nan |
-        | 2007-04-24 |   9.54 |  58.1  |  32.99 |  38.65 |    nan |
-        | 2007-04-25 |   9.52 |  57.6  |  32.8  |  38.59 |    nan |
-        | 2007-04-26 |   9.59 |  57.7  |  32.8  |  38.6  |    nan |
-        | 2007-04-27 |   9.55 |  57.5  |  32.72 |  38.4  |    nan |
-
-        !!!note
-            使用 `data.get` 時，會預設優先下載近期資料，並與本地資料合併，以避免重複下載大量數據。
-
-            假如想要強制下載所有資料，可以在下載資料前，使用
-            ```py
-            data.force_cloud_download = True
-            ```
-            假如想要強制使用本地資料，不額外下載，可以在下載資料前，使用
-            ```py
-            data.use_local_data_only = True
-            ```
-
-    """
-    finlab.utils.check_version()
-
-    global universe_stocks
-    global _storage
-    global force_cloud_download
-    global use_local_data_only
-
-    if force_download:
-        logger.warning('force download will be deprecated after 2024/06/01, please use data.force_cloud_download = True instead')
-
-    if not save_to_storage:
-        logger.warning('save_to_storage will be deprecated after 2024/06/01. Please use data.set_storage(CacheStorage()) to disable data saved to local storage')
-    
-    force_download |= force_cloud_download
-
-    if use_local_data_only and force_download:
-        raise Exception('data.use_local_data_only and data.force_download cannot be both True')
-    
-    if use_local_data_only:
-        df = _storage.get_dataframe(dataset)
-        if df is not None and len(df) != 0:
-            return refine_stock_id(dataset, finlab.dataframe.FinlabDataFrame(df))
-        raise Exception(f"**Error: {dataset} not exists at local storage. Please set data.use_local_data_only = False to download data from cloud.")
-
-
-    # not expired
-    time_expired = _storage.get_time_expired(dataset)
-    df = _storage.get_dataframe(dataset)
-    if time_expired and time_expired > CacheStorage.now() and not force_download and df is not None and len(df) != 0:
-        logger.debug(f'{dataset} not expired -> get data from local')
-        return refine_stock_id(dataset, finlab.dataframe.FinlabDataFrame(df))
-    
-    # free user can only use historical data without merge
-    global role
-    if role == 'free' and df is not None:
-        return refine_stock_id(dataset, finlab.dataframe.FinlabDataFrame(df))
-    
-    ############################
-    # try to merge short data
-    ############################
-    url_data = fetch_data(dataset + '.recent', time_saved=_storage.get_time_created(dataset))
-    if url_data is not None and df is not None and len(df) != 0 and not force_download:
-        if 'data' not in url_data:
-            _storage.set_time_expired(dataset, url_data['expiry'])
-            logger.debug(f'{dataset} get recent, server says not expired -> get data from local')
-            return refine_stock_id(dataset, finlab.dataframe.FinlabDataFrame(df))
-
-        short_df = url_data['data']
-        merge_success = False
-        try:
-            compare_cols = df.columns.intersection(['stock_id', 'date', '持股分級', 'broker'])
-            df = pd.concat([df, short_df])\
-                .pipe(lambda df: df[~df.duplicated(subset=compare_cols, keep='last')])\
-                [short_df.columns]\
-                .reset_index(drop=True)
-            merge_success = True
-        except Exception as e:
-            # logger.warning(f'{dataset} get recent, merge fail -> cancel merge recent to local data')
-            pass
-
-        if merge_success:
-            hash_df = hash(df)
-            logger.debug(f'hash df: {hash_df} url: {url_data.get("hash", None)}')
-
-            if url_data.get('hash', None) == hash_df and len(df) != 0:
-                _storage.set_dataframe(dataset, df, expiry=url_data['expiry'])
-                logger.debug('get recent, is valid -> and merge recent to local data')
-                return refine_stock_id(dataset, finlab.dataframe.FinlabDataFrame(df))
-            else:
-                pass
-                # logger.warning(f' {dataset} get recent, shape not valid -> cancel merge recent to local data')
-
-    ###################
-    # all data download
-    ###################
-    del df
-    del url_data
-    gc.collect()
-    
-    # expired at local but may not expired at server
-    url_data = fetch_data(dataset)
-
-    if url_data is None:
-        raise Exception(f"**Error: {dataset} not exists")
-
-    df = url_data['data']
-
-    # fallback to cache storage if user is free user
-    if url_data is not None and role is None:
-        if url_data['role'] == 'free':
-            role = 'free'
-            _storage = CacheStorage()
-
-    if len(df) > 0:
-        _storage.set_dataframe(dataset, df, expiry=url_data['expiry'])
-    
-    if len(df) == 0:
-        raise Exception(f"**Error: {dataset} download fail")
-
-    logger.debug(f' {dataset} get recent, merge fail -> get whole data from cloud')
-    return refine_stock_id(dataset, finlab.dataframe.FinlabDataFrame(df))
-
-
-def get_input_args(attr):
-    input_names = attr.input_names
-    refine_input_names = []
-    for key, val in input_names.items():
-        if 'price' in key:
-            if isinstance(val, list):
-                refine_input_names += val
-            elif isinstance(val, str):
-                refine_input_names.append(val)
-
-    return refine_input_names
-
-def indicator(indname, adjust_price=False, resample='D', market='TW_STOCK', **kwargs):
-    """支援 Talib 和 pandas_ta 上百種技術指標，計算 2000 檔股票、10年的所有資訊。
-
-    在使用這個函式前，需要安裝計算技術指標的 Packages
-
-    * [Ta-Lib](https://github.com/mrjbq7/ta-lib)
-    * [Pandas-ta](https://github.com/twopirllc/pandas-ta)
-
-    Args:
-        indname (str): 指標名稱，
-            以 TA-Lib 舉例，例如 SMA, STOCH, RSI 等，可以參考 [talib 文件](https://mrjbq7.github.io/ta-lib/doc_index.html)。
-
-            以 Pandas-ta 舉例，例如 supertrend, ssf 等，可以參考 [Pandas-ta 文件](https://twopirllc.github.io/pandas-ta/#indicators-by-category)。
-        adjust_price (bool): 是否使用還原股價計算。
-        resample (str): 技術指標價格週期，ex: `D` 代表日線, `W` 代表週線, `M` 代表月線。
-        market (str): 市場選擇，ex: `TW_STOCK` 代表台股, `US_STOCK` 代表美股。
-        **kwargs (dict): 技術指標的參數設定，TA-Lib 中的 RSI 為例，調整項為計算週期 `timeperiod=14`。
-    建議使用者可以先參考以下範例，並且搭配 talib官方文件，就可以掌握製作技術指標的方法了。
-    """
-    package = None
-
-    try:
-        from talib import abstract
-        import talib
-        attr = getattr(abstract, indname)
-        package = 'talib'
-    except:
-        try:
-            import pandas_ta
-            # test df.ta has attribute
-            getattr(pd.DataFrame().ta, indname)
-            attr = lambda df, **kwargs: getattr(df.ta, indname)(**kwargs)
-            package = 'pandas_ta'
-        except:
-            raise Exception(
-                "Please install TA-Lib or pandas_ta to get indicators.")
-
-
-    market = finlab.market_info.get_market_info(user_market_info=market)
-
-    close = market.get_price('close', adj=adjust_price)
-    open_ = market.get_price('open', adj=adjust_price)
-    high = market.get_price('high', adj=adjust_price)
-    low = market.get_price('low', adj=adjust_price)
-    volume = market.get_price('volume', adj=adjust_price)
-
-    if resample.upper() != 'D':
-        close = close.resample(resample).last()
-        open_ = open_.resample(resample).first()
-        high = high.resample(resample).max()
-        low = low.resample(resample).min()
-        volume = volume.resample(resample).sum()
-
-    latest_date = min([close.index[-1], open_.index[-1], high.index[-1], low.index[-1], volume.index[-1]])
-
-    if (latest_date != close.index[-1] 
-        or latest_date != open_.index[-1] 
-        or latest_date != high.index[-1] 
-        or latest_date != low.index[-1] 
-        or latest_date != volume.index[-1]):
-
-        logger.warning(f'indicator: {indname} market: {market} has different end date, '
-                       'cut to {latest_date}. This is due to server updating data. '
-                       'If you want to get the latest data, please try again 3 minutes later.')
-        
-        close = close.loc[:latest_date]
-        open_ = open_.loc[:latest_date]
-        high = high.loc[:latest_date]
-        low = low.loc[:latest_date]
-        volume = volume.loc[:latest_date]
-        
-    dfs = {}
-    default_output_columns = None
-    for key in close.columns:
-
-        prices = {'open': open_[key].ffill(),
-                  'high': high[key].ffill(),
-                  'low': low[key].ffill(),
-                  'close': close[key].ffill(),
-                  'volume': volume[key].ffill()}
-
-        if prices['close'].iloc[-1] != prices['close'].iloc[-1]:
-            continue
-
-        if package == 'pandas_ta':
-            prices = pd.DataFrame(prices)
-            s = attr(prices, **kwargs)
-
-        elif package == 'talib':
-            abstract_input = list(attr.input_names.values())[0]
-            abstract_input = get_input_args(attr)
-
-            # quick fix talib bug
-            if indname == 'OBV':
-                abstract_input = ['close', 'volume']
-
-            if indname == 'BETA':
-                abstract_input = ['high', 'low']
-
-            if isinstance(abstract_input, str):
-                abstract_input = [abstract_input]
-            paras = [prices[k] for k in abstract_input]
-            s = attr(*paras, **kwargs)
-        else:
-            raise Exception("Cannot determine technical package from indname")
-
-        if isinstance(s, list):
-            s = {i: series for i, series in enumerate(s)}
-
-        if isinstance(s, np.ndarray):
-            s = {0: s}
-
-        if isinstance(s, pd.Series):
-            s = {0: s.values}
-
-        if isinstance(s, pd.DataFrame):
-            s = {i: series.values for i, series in s.items()}
-
-        if default_output_columns is None:
-            default_output_columns = list(s.keys())
-
-        for colname, series in s.items():
-            if colname not in dfs:
-                dfs[colname] = {}
-            dfs[colname][key] = series if isinstance(
-                series, pd.Series) else series
-
-    newdic = {}
-    for key, df in dfs.items():
-        newdic[key] = pd.DataFrame(df, index=close.index)
-
-    ret = [newdic[n] for n in default_output_columns]
-    ret = [d.apply(lambda s:pd.to_numeric(s, errors='coerce')) for d in ret]
-
-    if len(ret) == 1:
-        return finlab.dataframe.FinlabDataFrame(ret[0])
-
-    return tuple([finlab.dataframe.FinlabDataFrame(df) for df in ret])
-
-indicator.us_stock = lambda *args, **kwargs: indicator(*args, **{**kwargs, **{'market': 'US_STOCK'}})
-indicator.tw_stock = lambda *args, **kwargs: indicator(*args, **{**kwargs, **{'market': 'TW_STOCK'}})
-
-def get_strategies(api_token=None):
-    """取得已上傳量化平台的策略回傳資料。
-
-    可取得自己策略儀表板上的數據，例如每個策略的報酬率曲線、報酬率統計、夏普率、近期部位、近期換股日...，
-    這些數據可以用來進行多策略彙整的應用喔！
-
-
-    Args:
-        api_token (str): 若未帶入finlab模組的api_token，會自動跳出[GUI](https://ai.finlab.tw/api_token/)頁面，
-                         複製網頁內的api_token貼至輸入欄位即可。
-    Returns:
-        (dict): strategies data
-    Response detail:
-
-        ``` py
-        {
-          strategy1:{
-            'asset_type': '',
-            'drawdown_details': {
-               '2015-06-04': {
-                 'End': '2015-11-03',
-                 'Length': 152,
-                 'drawdown': -0.19879090089478024
-                 },
-                 ...
-              },
-            'fee_ratio': 0.000475,
-            'last_trading_date': '2022-06-10',
-            'last_updated': 'Sun, 03 Jul 2022 12:02:27 GMT',
-            'ndays_return': {
-              '1': -0.01132480035770611,
-              '10': -0.0014737286933147464,
-              '20': -0.06658015749110646,
-              '5': -0.002292995729485159,
-              '60': -0.010108700314771735
-              },
-            'next_trading_date': '2022-06-10',
-            'positions': {
-              '1413 宏洲': {
-                'entry_date': '2022-05-10',
-                'entry_price': 10.05,
-                'exit_date': '',
-                'next_weight': 0.1,
-                'return': -0.010945273631840613,
-                'status': '買進',
-                'weight': 0.1479332345384493
-                },
-              'last_updated': 'Sun, 03 Jul 2022 12:02:27 GMT',
-              'next_trading_date': '2022-06-10',
-              'trade_at': 'open',
-              'update_date': '2022-06-10'
-              },
-            'return_table': {
-              '2014': {
-                'Apr': 0.0,
-                'Aug': 0.06315180932606546,
-                'Dec': 0.0537589857541485,
-                'Feb': 0.0,
-                'Jan': 0.0,
-                'Jul': 0.02937490104459939,
-                'Jun': 0.01367930162104769,
-                'Mar': 0.0,
-                'May': 0.0,
-                'Nov': -0.0014734320286596825,
-                'Oct': -0.045082529665408266,
-                'Sep': 0.04630906972509852,
-                'YTD': 0.16626214846456966
-                },
-                ...
-              },
-            'returns': {
-              'time': [
-                '2014-06-10',
-                '2014-06-11',
-                '2014-06-12',
-                ...
-                ],
-              'value': [
-                100,
-                99.9,
-                100.2,
-                ...
-                ]
-              },
-            'stats': {
-              'avg_down_month': -0.03304015302646822,
-              'avg_drawdown': -0.0238021414698247,
-              'avg_drawdown_days': 19.77952755905512,
-              'avg_up_month': 0.05293384465715908,
-              'cagr': 0.33236021285588846,
-              'calmar': 1.65261094975066,
-              'daily_kurt': 4.008888367138843,
-              'daily_mean': 0.3090784769257415,
-              'daily_sharpe': 1.747909002374217,
-              'daily_skew': -0.6966018726321078,
-              'daily_sortino': 2.8300677082214034,
-              ...
-              },
-            'tax_ratio': 0.003,
-            'trade_at': 'open',
-            'update_date': '2022-06-10'
-            },
-          strategy2:{...},
-          ...}
-        ```
-    """
-    if api_token is None:
-        api_token = finlab.get_token()
-
-    request_args = {
-        'api_token': api_token,
-    }
-
-    url = 'https://asia-east2-fdata-299302.cloudfunctions.net/auth_get_strategies'
-    response = finlab.utils.requests.get(url, request_args)
-    status_code = response.status_code
-    if status_code in [400, 401]:
-        logger.error("The authentication code is wrong or the account is not existed."
-                     "Please input right authentication code or register account ")
-        return {}
-    try:
-        return json.loads(response.text)
-    except:
-        pass
-
-    return response.text
-
-
-def search(keyword=None, display_info=['name', 'description', 'items']):
-    """查詢與取得資料庫目錄資訊。
-
-    查詢FinLab資料庫目錄中的資料表名稱或項目欄位名稱是否包含關鍵字，方便搜尋資料庫是否存在目標資料。
-
-    Args:
-        keyword (str): 欲查詢關鍵字。
-        display_info (list):指定顯示的資訊項目，預設只顯示「資料表英文代稱、資料表的中文描述、資料表欄位名稱」，若設定為None，則顯示全部資訊。
-
-    Returns:
-        (list): database information
-
-    Response detail:
-        ``` py
-        [{'name': 'financial_statement',
-          'description': '財報',
-          'items': {'存貨': {'type': 'float', 'description': '資產負債表(仟元)'},
-                    '存貨_增加_減少': {'type': 'float', 'description': '單季現金流量表(仟元)'}}},
-         {'name': 'fundamental_features',
-          'description': '財務指標',
-          'items': {'存貨週轉率': {'type': 'float', 'description': '(%)'}}},...]
-
-        ```
-    Examples:
-        ``` py
-
-        # 查詢各資料表的欄位名稱含有'存貨'關鍵字資料表的基本資訊
-        ex1 = data.search(keyword='存貨')
-        # 取得含有'存貨'關鍵字相關資料表的所有資訊
-        ex2 = data.search(keyword='存貨', display_info=None)
-        ```
-    """
-    if not hasattr(search, 'db_info'):
-        res = finlab.utils.requests.get('https://asia-east2-fdata-299302.cloudfunctions.net/get_data_info')
-        search.db_info = json.loads(res.text)['data']
-
-    db_info = search.db_info
-
-    if display_info:
-        db_info = [{i: table[i] for i in display_info} for table in db_info]
-
-    result = []
-    if keyword:
-        result = [table for table in db_info if (re.search(keyword, table['description'], re.IGNORECASE)) or (
-            re.search(keyword, table['name'], re.IGNORECASE))]
-        result_tables = [table['name'] for table in result]
-
-    def check_column_contains_keyword(table, keyword):
-        table = table.copy()
-        keyword_exist = {k: v for k, v in table['items'].items() if re.search(keyword, k, re.IGNORECASE)}
-        if len(keyword_exist) > 0:
-            table['items'] = keyword_exist
-            return table
-
-    if keyword:
-        for table in db_info:
-            if table['name'] not in result_tables:
-                checked_table = check_column_contains_keyword(table, keyword=keyword)
-            if checked_table is not None:
-                result.append(checked_table)
-    return result
+import os
+import gc
+import re
+import sys
+import json
+import math
+import pickle
+import shutil
+import logging
+import hashlib
+import datetime
+import numpy as np
+import pandas as pd
+from io import BytesIO
+from typing import Union
+from functools import lru_cache
+
+import finlab.utils
+import finlab.dataframe
+import finlab.market_info
+
+logger = logging.getLogger(__name__)
+
+has_print_free_user_warning = False
+role = None
+
+use_local_data_only = False
+force_cloud_download = False
+
+class CacheStorage():
+
+    def __init__(self):
+        """將歷史資料儲存於快取中
+
+          Examples:
+              欲切換成以檔案方式儲存，可以用以下之方式：
+
+              ``` py
+              from finlab import data
+              data.set_storage(data.CacheStorage())
+              close = data.get('price:收盤價')
+              ```
+
+              可以直接調閱快取資料：
+
+              ``` py
+              close = data._storage._cache['price:收盤價']
+              ```
+        """
+
+        self._cache = {}
+        self._cache_time = {}
+        self._cache_expiry = {}
+        self._stock_names = {}
+
+    @staticmethod
+    def now():
+        return datetime.datetime.now(tz=datetime.timezone.utc)
+
+    def set_dataframe(self, name, df, expiry=None):
+        self._cache[name] = df
+        self._cache_time[name] = self.now()
+        self._cache_expiry[name] = expiry or self.now()
+
+    def set_stock_names(self, stock_names):
+        self._stock_names = {**self._stock_names, **stock_names}
+
+    def get_time_created(self, name):
+
+        if name not in self._cache or name not in self._cache_time:
+            return None
+
+        return self._cache_time[name]
+
+    def get_time_expired(self, name):
+
+        if name in self._cache_expiry:
+            return self._cache_expiry[name]
+
+        return None
+    
+    def set_time_expired(self, name, expiry):
+        self._cache_expiry[name] = expiry
+
+    def get_dataframe(self, name):
+
+        # not exists
+        if name not in self._cache or name not in self._cache_time:
+            return None
+
+        return self._cache[name]
+
+    def get_stock_names(self):
+        return self._stock_names
+
+
+class FileStorage():
+    def __init__(self, path=None, use_cache=True):
+        """將歷史資料儲存於檔案中
+
+          Args:
+                path (str): 資料儲存的路徑
+                use_cache (bool): 是否額外使用快取，將資料複製一份到記憶體中。
+
+          Examples:
+              欲切換成以檔案方式儲存，可以用以下之方式：
+
+              ``` py
+              from finlab import data
+              data.set_storage(data.FileStorage())
+              close = data.get('price:收盤價')
+              ```
+
+              可以在本地端的 `./finlab_db/price#收盤價.pickle` 中，看到下載的資料，
+              可以使用 `pickle` 調閱歷史資料：
+              ``` py
+              import pickle
+              close = pickle.load(open('finlab_db/price#收盤價.pickle', 'rb'))
+              ```
+        """
+        if path is None:
+            path = finlab.utils.get_tmp_dir()
+            
+        self._path = path
+        self._cache = {}
+        self._stock_names = None
+        self._expiry = {}
+        self.use_cache = use_cache
+
+        if not os.path.isdir(path):
+            os.mkdir(path)
+
+        f_stock_names = os.path.join(path, 'stock_names.pkl')
+
+        if not os.path.isfile(f_stock_names):
+            with open(f_stock_names, 'wb') as f:
+                pickle.dump({}, f)
+        else:
+            with open(f_stock_names, 'rb') as f:
+                self._stock_names = pickle.load(f)
+
+        f_expiry = os.path.join(self._path, 'expiry.pkl')
+
+        if os.path.isfile(f_expiry):
+            with open(f_expiry, 'rb') as f:
+                try:
+                    self._expiry = pickle.load(f)
+                except:
+                    self._expiry = {}
+        
+        if self._expiry:
+            res = finlab.utils.requests.get('https://asia-east1-fdata-299302.cloudfunctions.net/data_reset_time')
+            reset_data_time = datetime.datetime.fromtimestamp(float(res.text), tz=datetime.timezone.utc)
+            for k, v in self._expiry.items():
+                created = self.get_time_created(k)
+                if created and created  < reset_data_time:
+                    logger.info(f' set {k} time expired since the system reset time: {reset_data_time} > created time: {self.get_time_created(k)}')
+                    self.set_time_expired(k, reset_data_time, save=False)
+
+        self.save_expiry()
+
+
+    def set_dataframe(self, name, df, expiry=None):
+
+        file_path = os.path.join(
+            self._path, name.replace(':', '#') + '.pickle')
+        try:
+            df.to_pickle(file_path)
+        except:
+            logger.warning(f' {name} save dataframe fail please check your disk permission or memory usage')
+            return
+
+        if self.use_cache:
+            self._cache[name] = df
+
+        self._expiry[name] = expiry or CacheStorage.now()
+        self.save_expiry()
+
+    def get_time_created(self, name):
+
+        # check existence
+        file_path = os.path.join(
+            self._path, name.replace(':', '#') + '.pickle')
+
+        if not os.path.isfile(file_path):
+            return None
+
+        return datetime.datetime.fromtimestamp(
+            os.path.getmtime(file_path), tz=datetime.timezone.utc)
+
+    def get_time_expired(self, name):
+
+        if name in self._expiry:
+            return self._expiry[name]
+
+        return None
+    
+    def set_time_expired(self, name, expiry, save=True):
+        self._expiry[name] = expiry
+        if save:
+            self.save_expiry()
+
+    def save_expiry(self):
+        try:
+            with open(os.path.join(self._path, 'expiry.pkl'), 'wb') as f:
+                pickle.dump(self._expiry, f)
+        except Exception as e:
+            logger.warning(f' save expiry fail {e}')
+            pass
+
+    def get_dataframe(self, name):
+
+        if name in self._cache:
+            return self._cache[name]
+
+        file_path = os.path.join(
+            self._path, name.replace(':', '#') + '.pickle')
+
+        if os.path.isfile(file_path):
+            try:
+                ret = pd.read_pickle(file_path)
+                if self.use_cache:
+                    self._cache[name] = ret
+            except:
+                return None
+            return ret
+
+        return None
+
+    def set_stock_names(self, stock_names):
+        self._stock_names = {**self._stock_names, **stock_names}
+
+        with open(os.path.join(self._path, 'stock_names.pkl'), 'wb') as f:
+            pickle.dump(self._stock_names, f)
+
+    def get_stock_names(self):
+
+        if self._stock_names is not None:
+            return self._stock_names
+
+        with open(os.path.join(self._path, 'stock_names.pkl'), 'rb') as f:
+            stock_names = pickle.load(f)
+        self._stock_names = stock_names
+        return stock_names
+    
+    def clear(self):
+        folder_path = self._path
+        for filename in os.listdir(folder_path):
+            file_path = os.path.join(folder_path, filename)
+            try:
+                if os.path.isfile(file_path) or os.path.islink(file_path):
+                    os.unlink(file_path)
+                elif os.path.isdir(file_path):
+                    shutil.rmtree(file_path)
+            except Exception as e:
+                print(f'Failed to delete {file_path}. Reason: {e}')
+
+def clear():
+    """清除本地端儲存的歷史資料，並還原初始設定。
+    Examples:
+        ``` py
+        from finlab import data
+        data.clear()
+        ```
+    """
+    global _storage
+    if isinstance(_storage, FileStorage):
+        _storage.clear()
+    _storage = FileStorage()
+
+
+_storage = FileStorage()
+universe_stocks = set()
+
+
+def set_storage(storage):
+    """設定本地端儲存歷史資料的方式
+    假設使用 `data.get` 獲取歷史資料則，在預設情況下，程式會自動在本地複製一份，以避免重複下載大量數據。
+    storage 就是用來儲存歷史資料的接口。我們提供兩種 `storage` 接口，分別是 `finlab.data.CacheStorage` (預設) 以及
+    `finlab.data.FileStorage`。前者是直接存在記憶體中，後者是存在檔案中。詳情請參考 `CacheStorage` 和 `FileStorage` 來獲得更詳細的資訊。
+    在預設情況下，程式會自動使用 `finlab.data.FileStorage` 並將重複索取之歷史資料存在作業系統預設「暫時資料夾」。
+
+    Args:
+        storage (data.Storage): The interface of storage
+
+    Examples:
+        欲切換成以檔案方式儲存，可以用以下之方式：
+
+        ``` py
+        from finlab import data
+        data.set_storage(data.FileStorage())
+        close = data.get('price:收盤價')
+        ```
+
+        可以在本地端的 `./finlab_db/price#收盤價.pickle` 中，看到下載的資料，
+        可以使用 `pickle` 調閱歷史資料：
+        ``` py
+        import pickle
+        close = pickle.load(open('finlab_db/price#收盤價.pickle', 'rb'))
+        ```
+    """
+
+    global _storage
+    _storage = storage
+
+
+class universe():
+    def __init__(self, market='ALL', category='ALL'):
+        """當呼叫 `data.get` 或是 `data.indicator` 時，返回產業相關類股。
+
+        Args:
+            market (str): Universe market type. ex: `ALL`, `TSE`, `OTC`, `TSE_OTC`, `ETF`, `STOCK_FUTURE`
+            category (str or list)): Stock categories. ex: `光電業`, `其他`, `其他電子業`, `化學工業`, `半導體`, `塑膠工業`, `存託憑證`, `建材營造`, `文化創意業`, `橡膠工業`, `水泥工業`,`汽車工業`, `油電燃氣業`, `玻璃陶瓷`, `生技醫療`, `生技醫療業`, `紡織纖維`, `航運業`, `觀光事業`, `貿易百貨`, `資訊服務業`, `農業科技`, `通信網路業`, `造紙工業`, `金融`, `鋼鐵工業`, `電器電纜`, `電子商務`, `電子通路業`, `電子零組件`, `電機機械`, `電腦及週邊`, `食品工業`
+
+        Examples:
+            想要當鋼鐵人、航海王，可以用以下方法將這些類股一次選出來
+            ``` py
+            with universe('TSE_OTC', ['鋼鐵工業', '航運業']):
+                close_subset = data.get('price:收盤價')
+                print(close_subset)
+            ```
+
+            | date       |   2002 |   2006 |   ..   |   2008 |   2009 |
+            |:-----------|-------:|-------:|-------:|-------:|-------:|
+            | 2007-04-23 |  39.65 |  38.3  |   ..   |   7.8  |  17.55 |
+            | 2007-04-24 |  39.85 |  38.85 |   ..   |   8.34 |  17.5  |
+            | 2007-04-25 |  39.25 |  38.1  |   ..   |   8.25 |  17.3  |
+            | 2007-04-26 |  39    |  37.85 |   ..   |   8.2  |  17.3  |
+            | 2007-04-27 |  38.2  |  37.2  |   ..   |   7.88 |  16.6  |
+
+        """
+        self._market = market
+        self._category = category
+        self._previous_stocks = set()
+
+    def __enter__(self):
+        global universe_stocks
+        self._previous_stocks = universe_stocks
+        set_universe(self._market, self._category)
+        return self
+
+    def __exit__(self, type, value, traceback):
+        global universe_stocks
+        universe_stocks = self._previous_stocks
+
+
+def set_universe(market: str = 'ALL', category='ALL', industry='All'):
+    """Set subset of stock ids when retrieve data using data.get or data.indicator
+
+    Args:
+        market (str): universe market type. ex: 'ALL', 'TSE', 'OTC', 'TSE_OTC', 'ETF', 'STOCK_FUTURE'
+        category (str): stock categories, can be either a string or a list. ex: '光電業', '其他', '其他電子業',
+    '化學工業', '半導體', '塑膠工業', '存託憑證', '建材營造', '文化創意業', '橡膠工業', '水泥工業',
+    '汽車工業', '油電燃氣業', '玻璃陶瓷', '生技醫療', '生技醫療業', '紡織纖維', '航運業', '觀光事業', '貿易百貨',
+    '資訊服務業', '農業科技', '通信網路業', '造紙工業', '金融', '鋼鐵工業', '電器電纜', '電子商務',
+    '電子通路業', '電子零組件', '電機機械', '電腦及週邊', '食品工業'
+    當 `market == 'ETF'` 時，可以選擇：
+    * `domestic_etf`: 以台股為成分股之 ETF
+    * `foreign_etf`: 以國外商品為成分股之 ETF
+    * `leveraged_etf`: 槓桿型 ETF
+    * `vanilla_futures_etf`: 無槓桿期貨 ETF
+    * `leveraged_futures_etf`: 槓桿型期貨 ETF
+
+    """
+
+    categories = get('security_categories').reset_index().set_index('stock_id')
+
+    market_match = pd.Series(True, categories.index)
+
+    if 'TSE' in market and 'OTC' in market:
+        market = 'TSE_OTC'
+
+    if market == 'ALL':
+        pass
+    elif market == 'TSE':
+        market_match = categories.market == 'sii'
+    elif market == 'OTC':
+        market_match = categories.market == 'otc'
+    elif market == 'TSE_OTC':
+        market_match = (categories.market == 'sii') | (
+            categories.market == 'otc')
+    elif market == 'ETF':
+        market_match = categories.market == 'etf'
+    elif market == 'STOCK_FUTURE':
+        market_match = get('single_stock_futures_and_equity_options_underlying')\
+            .pipe(lambda df: df[df['是否為股票期貨標的'] == 'Y'])\
+            .pipe(lambda df: pd.Series(True, set(df.stock_id)).reindex(categories.index).fillna(False))
+
+    category_match = pd.Series(True, categories.index)
+
+    if category == 'ALL':
+        pass
+    else:
+        if isinstance(category, str):
+            category = [category]
+
+        matched_categories = set()
+        all_categories = set(categories.category)
+        for ca in category:
+            matched_categories |= (
+                set([c for c in all_categories if isinstance(c, str) and re.search(ca, c)]))
+        category_match = categories.category.isin(matched_categories)
+
+    global universe_stocks
+    universe_stocks = set(categories.index[market_match & category_match])
+
+
+class us_universe:
+    def __init__(self, market='ALL', sector='ALL', industry='ALL', exchange='ALL'):
+        """當呼叫 `data.get` 或是 `data.indicator` 時，返回美股產業相關類股。
+
+        Args:
+            market (str): Universe market type.
+                          ex: `Common Stock`, `Preferred Stock`, `Domestic`, `Domestic Common Stock`, `ADR`
+            sector (str or list): The sector the stock belongs to.
+                                  ex:`Basic Materials`,`Communication Services`,`Consumer Cyclical`,`Consumer Defensive`,`Energy`,`Financial Services`,`Healthcare`,`Industrials`,`Real Estate`,`Technology`,`Utilities`
+            industry (str or list): The industry the stock belongs to.See industry list from `set(data.get('us_tickers')['industry'])`.ex:`Steel`,`Software - Application`...
+            exchange (str or list): The exchange the stock belongs to.
+                                   ex:`BATS`, `INDEX`, `NASDAQ`, `NYSE`, `NYSEARCA`, `NYSEMKT`, `OTC`
+
+        Examples:
+            想選出美股普通股中的科技類股
+            ``` py
+            with us_universe('Common Stock', ['Technology']):
+                close_subset = data.get('us_price:close')
+                print(close_subset)
+            ```
+
+            | date       |   AAOI  |  AAPL |   ..   |   ABCO |   NVDA |
+            |:-----------|-------:|-------:|-------:|-------:|-------:|
+            | 2017-01-03 |  39.65 |  38.3  |   ..   |   7.8  |  17.55 |
+            | 2017-01-04 |  39.85 |  38.85 |   ..   |   8.34 |  17.5  |
+            | 2017-01-05 |  39.25 |  38.1  |   ..   |   8.25 |  17.3  |
+            | 2017-01-06 |  39    |  37.85 |   ..   |   8.2  |  17.3  |
+            | 2017-01-09 |  38.2  |  37.2  |   ..   |   7.88 |  16.6  |
+
+            想選出美股特別股中的基礎原物料和能源類股
+            ``` py
+            with data.us_universe('Preferred Stock', ['Basic Materials','Energy']):
+                close_subset = data.get('us_price:close')
+                print(close_subset)
+            ```
+
+            | date       |   AEUA |  ALIN-PA |  ..  | ALIN-PB | ALIN-PE |
+            |:-----------|-------:|-------:|-------:|-------:|-------:|
+            | 2017-01-03 |  39.65 |  38.3  |   ..   |   7.8  |  17.55 |
+            | 2017-01-04 |  39.85 |  38.85 |   ..   |   8.34 |  17.5  |
+            | 2017-01-05 |  39.25 |  38.1  |   ..   |   8.25 |  17.3  |
+            | 2017-01-06 |  39    |  37.85 |   ..   |   8.2  |  17.3  |
+            | 2017-01-09 |  38.2  |  37.2  |   ..   |   7.88 |  16.6  |
+
+            想從美股 NASDAQ 交易所的普通股中篩選出軟體類股
+            ``` py
+            with data.us_universe('Common Stock', industry='Software', exchange='NASDAQ'):
+                close_subset = data.get('us_price:close')
+                print(close_subset)
+            ```
+
+            | date       |   ACIW |  ACVA |  ..  | ZI | ZS |
+            |:-----------|-------:|-------:|-------:|-------:|-------:|
+            | 2017-01-03 |  39.65 |  38.3  |   ..   |   7.8  |  17.55 |
+            | 2017-01-04 |  39.85 |  38.85 |   ..   |   8.34 |  17.5  |
+            | 2017-01-05 |  39.25 |  38.1  |   ..   |   8.25 |  17.3  |
+            | 2017-01-06 |  39    |  37.85 |   ..   |   8.2  |  17.3  |
+            | 2017-01-09 |  38.2  |  37.2  |   ..   |   7.88 |  16.6  |
+
+
+            檢視有哪些產業可選擇
+            ``` py
+            print(set(data.get('us_tickers')['industry']))
+            ```
+            ```
+            {'Advertising Agencies',
+             'Aerospace & Defense',
+             'Agricultural Inputs',
+             'Airlines',
+             'Airports & Air Services',
+             'Aluminum',
+             ...}
+            ```
+
+        """
+        self._market = market
+        self._sector = sector
+        self._industry = industry
+        self._exchange = exchange
+        self._previous_stocks = set()
+
+    def __enter__(self):
+        global universe_stocks
+        self._previous_stocks = universe_stocks
+        set_us_universe(self._market, self._sector, self._industry, self._exchange)
+        return self
+
+    def __exit__(self, type, value, traceback):
+        global universe_stocks
+        universe_stocks = self._previous_stocks
+
+
+def set_us_universe(market: str = 'ALL', sector='ALL', industry='All', exchange='ALL'):
+    """Set subset of us stock ids when retrieve data using data.get or data.indicator
+
+    Args:
+        market (str): Universe market type.
+                      ex: `Common Stock`, `Preferred Stock`, `Domestic`, `Domestic Common Stock`, `ADR`
+        sector (str or list): The sector the stock belongs to.
+                              ex:`Basic Materials`,`Communication Services`,`Consumer Cyclical`,`Consumer Defensive`,`Energy`,`Financial Services`,`Healthcare`,`Industrials`,`Real Estate`,`Technology`,`Utilities`
+        industry (str or list): The industry the stock belongs to.See industry list from `set(data.get('us_tickers')['industry'])`.ex:`Steel`,`Software - Application`...
+        exchange (str or list): The exchange the stock belongs to.
+                               ex:`BATS`, `INDEX`, `NASDAQ`, `NYSE`, `NYSEARCA`, `NYSEMKT`, `OTC`
+    """
+
+    categories = get('us_tickers').reset_index().set_index('stock_id')
+    market_range = ['ADR Common Stock',
+                    'ADR Common Stock Primary Class',
+                    'ADR Common Stock Secondary Class',
+                    'ADR Preferred Stock',
+                    'Domestic Common Stock',
+                    'Domestic Common Stock Primary Class',
+                    'Domestic Common Stock Secondary Class',
+                    'Domestic Preferred Stock', ]
+
+    if market == 'ALL':
+        market_match = categories.category.isin(market_range)
+    else:
+        market_match = categories.category.isin([m for m in market_range if market in m])
+
+    def match_ids(column, item):
+        category_match = pd.Series(True, categories.index)
+        if item == 'ALL':
+            pass
+        else:
+            if isinstance(item, str):
+                item = [item]
+            matched_categories = set()
+            all_categories = set(categories[column])
+            for ca in item:
+                matched_categories |= (
+                    set([c for c in all_categories if isinstance(c, str) and re.search(ca, c)]))
+            category_match = categories[column].isin(matched_categories)
+        return category_match
+
+    sector_match = match_ids('sector', sector)
+    industry_match = match_ids('industry', industry)
+
+    exchange_match = pd.Series(True, categories.index)
+    if exchange == 'ALL':
+        pass
+    else:
+        if isinstance(exchange, str):
+            exchange = [exchange]
+        exchange_match = categories.exchange.isin(exchange)
+
+    global universe_stocks
+    universe_stocks = set(categories.index[market_match & sector_match & industry_match & exchange_match])
+
+not_available_universe_stocks = [
+    'benchmark_return', 'institutional_investors_trading_all_market_summary',
+    'margin_balance', 'intraday_trading_stat',
+    'stock_index_price', 'stock_index_vol',
+    'taiex_total_index', 'broker_info',
+    'rotc_monthly_revenue', 'rotc_price',
+    'world_index', 'rotc_broker_trade_record',
+    'security_categories', 'finlab_tw_stock_market_ind',
+    'tw_industry_pmi', 'tw_industry_nmi',
+    'tw_total_pmi', 'tw_total_nmi',
+    'tw_business_indicators', 'tw_business_indicators_details',
+    'tw_monetary_aggregates', 'us_unemployment_rate_seasonally_adjusted',
+    'us_tickers',
+    ]
+
+def refine_stock_id(dataset, ret):
+
+    ret = process_data(dataset, ret)
+    
+    if dataset in not_available_universe_stocks:
+        return ret
+
+    if not universe_stocks:
+        return ret
+
+    if ':' in dataset:
+        subset_stocks = ret.columns.intersection(universe_stocks)
+
+        if subset_stocks.any():
+            return ret.loc[:, subset_stocks]
+
+    if 'stock_id' in ret.columns:
+        subset_stocks = ret['stock_id'].isin(universe_stocks)
+
+        if subset_stocks.any():
+            return ret.loc[subset_stocks]
+
+    return ret
+
+
+@lru_cache(maxsize=None)
+def get_bucket_name():
+
+    def get_location():
+        response = finlab.utils.requests.get('http://ipinfo.io')
+        if response.status_code == 200:
+            data = response.json()
+            return data['city'], data['region'], data['country'], data['loc']
+
+    def haversine_distance(coord1, coord2):
+        R = 6371  # Radius of the Earth in km
+
+        lat1, lon1 = map(math.radians, coord1)
+        lat2, lon2 = map(math.radians, coord2)
+
+        dlat = lat2 - lat1
+        dlon = lon2 - lon1
+
+        a = math.sin(dlat / 2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2)**2
+        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
+
+        return R * c
+
+    def choose_storage_region(coordinates):
+        # Coordinates for us-east1 (South Carolina, USA)
+        us_east1_coord = (33.8361, -81.1637)
+
+        # Coordinates for asia-east1 (Taiwan)
+        asia_east1_coord = (23.6978, 120.9605)
+
+        user_coord = tuple(map(float, coordinates.split(',')))
+
+        distance_to_us_east1 = haversine_distance(user_coord, us_east1_coord)
+        distance_to_asia_east1 = haversine_distance(user_coord, asia_east1_coord)
+
+        if distance_to_us_east1 < distance_to_asia_east1:
+            return 'finlab_us_stock_item'
+        else:
+            return 'finlab_tw_stock_item'
+        
+    # Fetch location information
+    try:
+        city, region, country, loc = get_location()
+        # Choose the storage region based on the coordinates
+        ret = choose_storage_region(loc)
+        logger.info(f'User location: {city}, {region}, {country}, {loc} -> select {ret} as storage region')
+        return ret
+    except:
+        pass
+    
+    return 'finlab_tw_stock_item'
+
+
+
+def fetch_data(dataset: str, time_saved=None):
+    """
+    Fetches data from a specified dataset.
+
+    Args:
+        dataset (str): The name of the dataset to fetch.
+        time_saved (datetime, optional): The time to fetch the data from. Defaults to None.
+
+    Returns:
+        dict: A dictionary containing the fetched data and other information.
+    """
+
+    url = 'https://asia-east2-fdata-299302.cloudfunctions.net/auth_generate_data_url'
+    params = {
+        'api_token': finlab.get_token(),
+        'bucket_name': get_bucket_name(),
+        'blob_name': dataset.replace(':', '#') \
+                + ('.pickle' if "pyodide" in sys.modules else '.feather'),
+        'pyodide': 'pyodide' in sys.modules
+    }
+    if time_saved:
+        params['time_saved'] = time_saved.strftime('%Y%m%d%H%M%S')
+
+    headers = {'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36',}
+    res = finlab.utils.requests.post(url, params, headers=headers)
+    ret = res.json()
+
+    if 'error' in ret:
+
+        if ret['error'] in [
+            'request not valid',
+            'User not found',
+            'api_token not valid',
+            'api_token not match', ]:
+            finlab.login()
+            return fetch_data(dataset, time_saved)
+        
+        if ret['error'] == 'Usage exceed 500 MB/day. Please consider upgrade to VIP program.':
+            raise Exception(f"**Error: {ret['error']}")
+
+        return None
+
+    
+    # print free user warning
+    global has_print_free_user_warning
+    if not has_print_free_user_warning \
+            and 'role' in ret \
+            and ret['role'] == 'free':
+        print('Due to your status as a free user, '
+            'the most recent data has been shortened or limited.')
+        has_print_free_user_warning = True
+
+    if 'quota' in ret and '.recent' not in dataset:
+        print(f'Daily usage: {ret["quota"]:.1f} / {ret["limit_size"]} MB - {dataset}')
+
+    ret['expiry'] = datetime.datetime.strptime(
+        ret['time_scheduled'], '%Y%m%d%H%M%S').replace(tzinfo=datetime.timezone.utc)\
+        if 'time_scheduled' in ret else None
+    
+    # download data if server return an url
+    if 'url' in ret and len(ret['url']) > 0:
+
+        if 'pyodide' in sys.modules:
+            if hasattr(finlab.utils.requests, 'getBytes'):
+                res = finlab.utils.requests.getBytes(ret['url'])
+                df = pd.read_pickle(BytesIO(res), compression='gzip')
+            else:
+                res = finlab.utils.requests.get(ret['url'])
+                df = pd.read_pickle(BytesIO(res.content), compression='gzip')
+        else:
+            res = finlab.utils.requests.get(ret['url'], headers=headers)
+            df = pd.read_feather(BytesIO(res.content))
+
+        ret['data'] = df#process_data(dataset, df)
+    return ret
+
+
+def has_index_name(df, name):
+    # Check if the DataFrame has a single index
+    if df.index.name == name:
+        return True
+    # Check if the DataFrame has a MultiIndex
+    elif isinstance(df.index, pd.MultiIndex):
+        if name in df.index.names:
+            return True
+    return False
+
+def process_data(dataset, df):
+
+    if 'stock_id' in df.columns and 'date' in df.columns:
+        df.set_index(['stock_id', 'date'], inplace=True)
+    elif 'date' in df.columns:
+        df.set_index('date', inplace=True)
+    elif 'stock_id' in df.columns:
+        df.set_index('stock_id', inplace=True)
+
+    # special case (to align with tutorial)
+    if dataset == 'broker_transactions':
+        df = df.reset_index().set_index('date')
+
+    # the column name is stock id, and index is date
+    if ':' in dataset:
+        df.columns.name = f'symbol'
+
+    # table format
+    if ':' not in dataset:
+        df = df.reset_index()
+
+    if not has_index_name(df, 'date'):
+        return df
+
+    table_name = dataset.split(':')[0]
+    if table_name in ['tw_total_pmi', 'tw_total_nmi', 'tw_industry_nmi', 'tw_industry_pmi']:
+        if isinstance(df.index[0], pd.Timestamp):
+            close = get('price:收盤價')
+            df.index = df.index.map(
+                lambda d: d if len(close.loc[d:]) == 0 or d < close.index[0] else close.loc[d:].index[0])
+
+    # if column is stock name
+    if (df.columns.str.find(' ') != -1).all():
+
+        # remove stock names
+        df.columns = df.columns.str.split(' ').str[0]
+
+        # combine same stock history according to sid
+        check_numeric_dtype = pd.api.types.is_numeric_dtype(df.values)
+        if check_numeric_dtype:
+            df = df.transpose().groupby(level=0).mean().transpose()
+        else:
+            df = df.fillna(np.nan).transpose().groupby(
+                level=0).last().transpose()
+
+    df = finlab.dataframe.FinlabDataFrame(df)
+
+    if table_name in ['monthly_revenue', 'rotc_monthly_revenue']:
+        df = df._index_to_business_day()
+    elif table_name in ['financial_statement', 'fundamental_features',]:
+        df = df._index_date_to_str_season()
+    elif table_name in ['us_fundamental', 'us_fundamental_ART']:
+        df = df._index_date_to_str_season('-US')
+    elif table_name in ['us_fundamental_all', 'us_fundamental_all_ART']:
+        df = df._index_date_to_str_season('-US-ALL')
+
+    return df
+
+
+def hash(df):
+    return hashlib.md5(pd.util.hash_pandas_object(df, index=True).values).hexdigest()[:7]
+
+
+def get(dataset: str, save_to_storage: bool = True, force_download=False):
+    """下載歷史資料
+
+    請至[歷史資料目錄](https://ai.finlab.tw/database) 來獲得所有歷史資料的名稱，即可使用此函式來獲取歷史資料。
+    假設 `save_to_storage` 為 `True` 則，程式會自動在本地複製一份，以避免重複下載大量數據。
+
+    Args:
+        dataset (str): The name of dataset.
+        save_to_storage (bool): Whether to save the dataset to storage for later use. Default is True. The argument will be removed in the future. Please use data.set_storage(FileStorage(use_cache=True)) instead.
+        force_download (bool): Whether to force download the dataset from cloud. Default is False.
+
+    Returns:
+        (pd.DataFrame): financial data
+
+    Examples:
+        欲下載所有上市上櫃之收盤價歷史資料，只需要使用此函式即可:
+
+        ``` py
+        from finlab import data
+        close = data.get('price:收盤價')
+        close
+        ```
+
+        | date       |   0015 |   0050 |   0051 |   0052 |   0053 |
+        |:-----------|-------:|-------:|-------:|-------:|-------:|
+        | 2007-04-23 |   9.54 |  57.85 |  32.83 |  38.4  |    nan |
+        | 2007-04-24 |   9.54 |  58.1  |  32.99 |  38.65 |    nan |
+        | 2007-04-25 |   9.52 |  57.6  |  32.8  |  38.59 |    nan |
+        | 2007-04-26 |   9.59 |  57.7  |  32.8  |  38.6  |    nan |
+        | 2007-04-27 |   9.55 |  57.5  |  32.72 |  38.4  |    nan |
+
+        !!!note
+            使用 `data.get` 時，會預設優先下載近期資料，並與本地資料合併，以避免重複下載大量數據。
+
+            假如想要強制下載所有資料，可以在下載資料前，使用
+            ```py
+            data.force_cloud_download = True
+            ```
+            假如想要強制使用本地資料，不額外下載，可以在下載資料前，使用
+            ```py
+            data.use_local_data_only = True
+            ```
+
+    """
+    finlab.utils.check_version()
+
+    global universe_stocks
+    global _storage
+    global force_cloud_download
+    global use_local_data_only
+
+    if force_download:
+        logger.warning('force download will be deprecated after 2024/06/01, please use data.force_cloud_download = True instead')
+
+    if not save_to_storage:
+        logger.warning('save_to_storage will be deprecated after 2024/06/01. Please use data.set_storage(CacheStorage()) to disable data saved to local storage')
+    
+    force_download |= force_cloud_download
+
+    if use_local_data_only and force_download:
+        raise Exception('data.use_local_data_only and data.force_download cannot be both True')
+    
+    if use_local_data_only:
+        df = _storage.get_dataframe(dataset)
+        if df is not None and len(df) != 0:
+            return refine_stock_id(dataset, finlab.dataframe.FinlabDataFrame(df))
+        raise Exception(f"**Error: {dataset} not exists at local storage. Please set data.use_local_data_only = False to download data from cloud.")
+
+
+    # not expired
+    time_expired = _storage.get_time_expired(dataset)
+    df = _storage.get_dataframe(dataset)
+    if time_expired and time_expired > CacheStorage.now() and not force_download and df is not None and len(df) != 0:
+        logger.debug(f'{dataset} not expired -> get data from local')
+        return refine_stock_id(dataset, finlab.dataframe.FinlabDataFrame(df))
+    
+    # free user can only use historical data without merge
+    global role
+    if role == 'free' and df is not None:
+        return refine_stock_id(dataset, finlab.dataframe.FinlabDataFrame(df))
+    
+    ############################
+    # try to merge short data
+    ############################
+    url_data = fetch_data(dataset + '.recent', time_saved=_storage.get_time_created(dataset))
+    if url_data is not None and df is not None and len(df) != 0 and not force_download:
+        if 'data' not in url_data:
+            _storage.set_time_expired(dataset, url_data['expiry'])
+            logger.debug(f'{dataset} get recent, server says not expired -> get data from local')
+            return refine_stock_id(dataset, finlab.dataframe.FinlabDataFrame(df))
+
+        short_df = url_data['data']
+        merge_success = False
+        try:
+            compare_cols = df.columns.intersection(['stock_id', 'date', '持股分級', 'broker'])
+            df = pd.concat([df, short_df])\
+                .pipe(lambda df: df[~df.duplicated(subset=compare_cols, keep='last')])\
+                [short_df.columns]\
+                .reset_index(drop=True)
+            merge_success = True
+        except Exception as e:
+            # logger.warning(f'{dataset} get recent, merge fail -> cancel merge recent to local data')
+            pass
+
+        if merge_success:
+            hash_df = hash(df)
+            logger.debug(f'hash df: {hash_df} url: {url_data.get("hash", None)}')
+
+            if url_data.get('hash', None) == hash_df and len(df) != 0:
+                _storage.set_dataframe(dataset, df, expiry=url_data['expiry'])
+                logger.debug('get recent, is valid -> and merge recent to local data')
+                return refine_stock_id(dataset, finlab.dataframe.FinlabDataFrame(df))
+            else:
+                pass
+                # logger.warning(f' {dataset} get recent, shape not valid -> cancel merge recent to local data')
+
+    ###################
+    # all data download
+    ###################
+    del df
+    del url_data
+    gc.collect()
+    
+    # expired at local but may not expired at server
+    url_data = fetch_data(dataset)
+
+    if url_data is None:
+        raise Exception(f"**Error: {dataset} not exists")
+
+    df = url_data['data']
+
+    # fallback to cache storage if user is free user
+    if url_data is not None and role is None:
+        if url_data['role'] == 'free':
+            role = 'free'
+            _storage = CacheStorage()
+
+    if len(df) > 0:
+        _storage.set_dataframe(dataset, df, expiry=url_data['expiry'])
+    
+    if len(df) == 0:
+        raise Exception(f"**Error: {dataset} download fail")
+
+    logger.debug(f' {dataset} get recent, merge fail -> get whole data from cloud')
+    return refine_stock_id(dataset, finlab.dataframe.FinlabDataFrame(df))
+
+
+def get_input_args(attr):
+    input_names = attr.input_names
+    refine_input_names = []
+    for key, val in input_names.items():
+        if 'price' in key:
+            if isinstance(val, list):
+                refine_input_names += val
+            elif isinstance(val, str):
+                refine_input_names.append(val)
+
+    return refine_input_names
+
+def indicator(indname, adjust_price=False, resample='D', market='TW_STOCK', **kwargs):
+    """支援 Talib 和 pandas_ta 上百種技術指標，計算 2000 檔股票、10年的所有資訊。
+
+    在使用這個函式前，需要安裝計算技術指標的 Packages
+
+    * [Ta-Lib](https://github.com/mrjbq7/ta-lib)
+    * [Pandas-ta](https://github.com/twopirllc/pandas-ta)
+
+    Args:
+        indname (str): 指標名稱，
+            以 TA-Lib 舉例，例如 SMA, STOCH, RSI 等，可以參考 [talib 文件](https://mrjbq7.github.io/ta-lib/doc_index.html)。
+
+            以 Pandas-ta 舉例，例如 supertrend, ssf 等，可以參考 [Pandas-ta 文件](https://twopirllc.github.io/pandas-ta/#indicators-by-category)。
+        adjust_price (bool): 是否使用還原股價計算。
+        resample (str): 技術指標價格週期，ex: `D` 代表日線, `W` 代表週線, `M` 代表月線。
+        market (str): 市場選擇，ex: `TW_STOCK` 代表台股, `US_STOCK` 代表美股。
+        **kwargs (dict): 技術指標的參數設定，TA-Lib 中的 RSI 為例，調整項為計算週期 `timeperiod=14`。
+    建議使用者可以先參考以下範例，並且搭配 talib官方文件，就可以掌握製作技術指標的方法了。
+    """
+    package = None
+
+    try:
+        from talib import abstract
+        import talib
+        attr = getattr(abstract, indname)
+        package = 'talib'
+    except:
+        try:
+            import pandas_ta
+            # test df.ta has attribute
+            getattr(pd.DataFrame().ta, indname)
+            attr = lambda df, **kwargs: getattr(df.ta, indname)(**kwargs)
+            package = 'pandas_ta'
+        except:
+            raise Exception(
+                "Please install TA-Lib or pandas_ta to get indicators.")
+
+
+    market = finlab.market_info.get_market_info(user_market_info=market)
+
+    close = market.get_price('close', adj=adjust_price)
+    open_ = market.get_price('open', adj=adjust_price)
+    high = market.get_price('high', adj=adjust_price)
+    low = market.get_price('low', adj=adjust_price)
+    volume = market.get_price('volume', adj=adjust_price)
+
+    if resample.upper() != 'D':
+        close = close.resample(resample).last()
+        open_ = open_.resample(resample).first()
+        high = high.resample(resample).max()
+        low = low.resample(resample).min()
+        volume = volume.resample(resample).sum()
+
+    latest_date = min([close.index[-1], open_.index[-1], high.index[-1], low.index[-1], volume.index[-1]])
+
+    if (latest_date != close.index[-1] 
+        or latest_date != open_.index[-1] 
+        or latest_date != high.index[-1] 
+        or latest_date != low.index[-1] 
+        or latest_date != volume.index[-1]):
+
+        logger.warning(f'indicator: {indname} market: {market} has different end date, '
+                       'cut to {latest_date}. This is due to server updating data. '
+                       'If you want to get the latest data, please try again 3 minutes later.')
+        
+        close = close.loc[:latest_date]
+        open_ = open_.loc[:latest_date]
+        high = high.loc[:latest_date]
+        low = low.loc[:latest_date]
+        volume = volume.loc[:latest_date]
+        
+    dfs = {}
+    default_output_columns = None
+    for key in close.columns:
+
+        prices = {'open': open_[key].ffill(),
+                  'high': high[key].ffill(),
+                  'low': low[key].ffill(),
+                  'close': close[key].ffill(),
+                  'volume': volume[key].ffill()}
+
+        if prices['close'].iloc[-1] != prices['close'].iloc[-1]:
+            continue
+
+        if package == 'pandas_ta':
+            prices = pd.DataFrame(prices)
+            s = attr(prices, **kwargs)
+
+        elif package == 'talib':
+            abstract_input = list(attr.input_names.values())[0]
+            abstract_input = get_input_args(attr)
+
+            # quick fix talib bug
+            if indname == 'OBV':
+                abstract_input = ['close', 'volume']
+
+            if indname == 'BETA':
+                abstract_input = ['high', 'low']
+
+            if isinstance(abstract_input, str):
+                abstract_input = [abstract_input]
+            paras = [prices[k] for k in abstract_input]
+            s = attr(*paras, **kwargs)
+        else:
+            raise Exception("Cannot determine technical package from indname")
+
+        if isinstance(s, list):
+            s = {i: series for i, series in enumerate(s)}
+
+        if isinstance(s, np.ndarray):
+            s = {0: s}
+
+        if isinstance(s, pd.Series):
+            s = {0: s.values}
+
+        if isinstance(s, pd.DataFrame):
+            s = {i: series.values for i, series in s.items()}
+
+        if default_output_columns is None:
+            default_output_columns = list(s.keys())
+
+        for colname, series in s.items():
+            if colname not in dfs:
+                dfs[colname] = {}
+            dfs[colname][key] = series if isinstance(
+                series, pd.Series) else series
+
+    newdic = {}
+    for key, df in dfs.items():
+        newdic[key] = pd.DataFrame(df, index=close.index)
+
+    ret = [newdic[n] for n in default_output_columns]
+    ret = [d.apply(lambda s:pd.to_numeric(s, errors='coerce')) for d in ret]
+
+    if len(ret) == 1:
+        return finlab.dataframe.FinlabDataFrame(ret[0])
+
+    return tuple([finlab.dataframe.FinlabDataFrame(df) for df in ret])
+
+indicator.us_stock = lambda *args, **kwargs: indicator(*args, **{**kwargs, **{'market': 'US_STOCK'}})
+indicator.tw_stock = lambda *args, **kwargs: indicator(*args, **{**kwargs, **{'market': 'TW_STOCK'}})
+
+def get_strategies(api_token=None):
+    """取得已上傳量化平台的策略回傳資料。
+
+    可取得自己策略儀表板上的數據，例如每個策略的報酬率曲線、報酬率統計、夏普率、近期部位、近期換股日...，
+    這些數據可以用來進行多策略彙整的應用喔！
+
+
+    Args:
+        api_token (str): 若未帶入finlab模組的api_token，會自動跳出[GUI](https://ai.finlab.tw/api_token/)頁面，
+                         複製網頁內的api_token貼至輸入欄位即可。
+    Returns:
+        (dict): strategies data
+    Response detail:
+
+        ``` py
+        {
+          strategy1:{
+            'asset_type': '',
+            'drawdown_details': {
+               '2015-06-04': {
+                 'End': '2015-11-03',
+                 'Length': 152,
+                 'drawdown': -0.19879090089478024
+                 },
+                 ...
+              },
+            'fee_ratio': 0.000475,
+            'last_trading_date': '2022-06-10',
+            'last_updated': 'Sun, 03 Jul 2022 12:02:27 GMT',
+            'ndays_return': {
+              '1': -0.01132480035770611,
+              '10': -0.0014737286933147464,
+              '20': -0.06658015749110646,
+              '5': -0.002292995729485159,
+              '60': -0.010108700314771735
+              },
+            'next_trading_date': '2022-06-10',
+            'positions': {
+              '1413 宏洲': {
+                'entry_date': '2022-05-10',
+                'entry_price': 10.05,
+                'exit_date': '',
+                'next_weight': 0.1,
+                'return': -0.010945273631840613,
+                'status': '買進',
+                'weight': 0.1479332345384493
+                },
+              'last_updated': 'Sun, 03 Jul 2022 12:02:27 GMT',
+              'next_trading_date': '2022-06-10',
+              'trade_at': 'open',
+              'update_date': '2022-06-10'
+              },
+            'return_table': {
+              '2014': {
+                'Apr': 0.0,
+                'Aug': 0.06315180932606546,
+                'Dec': 0.0537589857541485,
+                'Feb': 0.0,
+                'Jan': 0.0,
+                'Jul': 0.02937490104459939,
+                'Jun': 0.01367930162104769,
+                'Mar': 0.0,
+                'May': 0.0,
+                'Nov': -0.0014734320286596825,
+                'Oct': -0.045082529665408266,
+                'Sep': 0.04630906972509852,
+                'YTD': 0.16626214846456966
+                },
+                ...
+              },
+            'returns': {
+              'time': [
+                '2014-06-10',
+                '2014-06-11',
+                '2014-06-12',
+                ...
+                ],
+              'value': [
+                100,
+                99.9,
+                100.2,
+                ...
+                ]
+              },
+            'stats': {
+              'avg_down_month': -0.03304015302646822,
+              'avg_drawdown': -0.0238021414698247,
+              'avg_drawdown_days': 19.77952755905512,
+              'avg_up_month': 0.05293384465715908,
+              'cagr': 0.33236021285588846,
+              'calmar': 1.65261094975066,
+              'daily_kurt': 4.008888367138843,
+              'daily_mean': 0.3090784769257415,
+              'daily_sharpe': 1.747909002374217,
+              'daily_skew': -0.6966018726321078,
+              'daily_sortino': 2.8300677082214034,
+              ...
+              },
+            'tax_ratio': 0.003,
+            'trade_at': 'open',
+            'update_date': '2022-06-10'
+            },
+          strategy2:{...},
+          ...}
+        ```
+    """
+    if api_token is None:
+        api_token = finlab.get_token()
+
+    request_args = {
+        'api_token': api_token,
+    }
+
+    url = 'https://asia-east2-fdata-299302.cloudfunctions.net/auth_get_strategies'
+    response = finlab.utils.requests.get(url, request_args)
+    status_code = response.status_code
+    if status_code in [400, 401]:
+        logger.error("The authentication code is wrong or the account is not existed."
+                     "Please input right authentication code or register account ")
+        return {}
+    try:
+        return json.loads(response.text)
+    except:
+        pass
+
+    return response.text
+
+
+def search(keyword=None, display_info=['name', 'description', 'items']):
+    """查詢與取得資料庫目錄資訊。
+
+    查詢FinLab資料庫目錄中的資料表名稱或項目欄位名稱是否包含關鍵字，方便搜尋資料庫是否存在目標資料。
+
+    Args:
+        keyword (str): 欲查詢關鍵字。
+        display_info (list):指定顯示的資訊項目，預設只顯示「資料表英文代稱、資料表的中文描述、資料表欄位名稱」，若設定為None，則顯示全部資訊。
+
+    Returns:
+        (list): database information
+
+    Response detail:
+        ``` py
+        [{'name': 'financial_statement',
+          'description': '財報',
+          'items': {'存貨': {'type': 'float', 'description': '資產負債表(仟元)'},
+                    '存貨_增加_減少': {'type': 'float', 'description': '單季現金流量表(仟元)'}}},
+         {'name': 'fundamental_features',
+          'description': '財務指標',
+          'items': {'存貨週轉率': {'type': 'float', 'description': '(%)'}}},...]
+
+        ```
+    Examples:
+        ``` py
+
+        # 查詢各資料表的欄位名稱含有'存貨'關鍵字資料表的基本資訊
+        ex1 = data.search(keyword='存貨')
+        # 取得含有'存貨'關鍵字相關資料表的所有資訊
+        ex2 = data.search(keyword='存貨', display_info=None)
+        ```
+    """
+    if not hasattr(search, 'db_info'):
+        res = finlab.utils.requests.get('https://asia-east2-fdata-299302.cloudfunctions.net/get_data_info')
+        search.db_info = json.loads(res.text)['data']
+
+    db_info = search.db_info
+
+    if display_info:
+        db_info = [{i: table[i] for i in display_info} for table in db_info]
+
+    result = []
+    if keyword:
+        result = [table for table in db_info if (re.search(keyword, table['description'], re.IGNORECASE)) or (
+            re.search(keyword, table['name'], re.IGNORECASE))]
+        result_tables = [table['name'] for table in result]
+
+    def check_column_contains_keyword(table, keyword):
+        table = table.copy()
+        keyword_exist = {k: v for k, v in table['items'].items() if re.search(keyword, k, re.IGNORECASE)}
+        if len(keyword_exist) > 0:
+            table['items'] = keyword_exist
+            return table
+
+    if keyword:
+        for table in db_info:
+            if table['name'] not in result_tables:
+                checked_table = check_column_contains_keyword(table, keyword=keyword)
+            if checked_table is not None:
+                result.append(checked_table)
+    return result
```

## finlab/dataframe.py

 * *Ordering differences only*

```diff
@@ -1,788 +1,788 @@
-import uuid
-import logging
-import inspect
-import datetime
-import numpy as np
-import pandas as pd
-from functools import lru_cache
-
-import finlab.market_info
-
-logger = logging.getLogger(__name__)
-
-
-def reshape_operations(cls):
-
-    # Define a mapping of operations to override to their corresponding pandas method
-    methods_to_check = [
-        '__getitem__',
-        '__add__', '__sub__', '__mul__', '__truediv__', '__floordiv__',
-        '__mod__', '__pow__', '__lshift__', '__rshift__', '__and__',
-        '__or__', '__xor__', '__iadd__', '__isub__', '__imul__',
-        '__itruediv__', '__ifloordiv__', '__imod__', '__ipow__',
-        '__ilshift__', '__irshift__', '__iand__', '__ior__', '__ixor__',
-        '__lt__', '__le__', '__eq__', '__ne__', '__gt__', '__ge__',
-    ]
-
-    # find operation mapping that map str -> function for the function need reshape.
-
-    base_class = pd.DataFrame
-    operations_mapping = {}
-
-    for method_name in methods_to_check:
-        if hasattr(base_class, method_name):
-            method = getattr(base_class, method_name)
-            params = inspect.signature(method).parameters
-            can_accept_df = any(
-                param.annotation == pd.DataFrame or param.annotation == inspect._empty
-                for param in params.values()
-            )
-            if can_accept_df:
-                operations_mapping[method_name] = getattr(
-                    pd.DataFrame, method_name)
-
-    # replace original function to reshaped function
-
-    for op, pandas_method in operations_mapping.items():
-        if hasattr(cls, op):
-
-            def make_wrapped_method(op):
-                def wrapped_method(self, other, pandas_method=pandas_method):
-
-                    df1, df2 = self.reshape(self, other)
-
-                    if isinstance(other, pd.Series) and op == '__getitem__':
-                        return df1.loc[df2.iloc[:, 0]]
-
-                    return pandas_method(df1, df2)
-
-                return wrapped_method
-
-            setattr(cls, op, make_wrapped_method(op))
-
-    return cls
-
-
-def get_index_str_frequency(df):
-
-    if not hasattr(df, 'index'):
-        return None
-
-    if len(df.index) == 0:
-        return None
-
-    if not isinstance(df.index[0], str):
-        return None
-
-    if (df.index.str.find('M') != -1).all():
-        return 'month'
-
-    if (df.index.str.find('Q') != -1).all():
-        return 'season'
-
-    return None
-
-
-@reshape_operations
-class FinlabDataFrame(pd.DataFrame):
-    """回測語法糖
-    除了使用熟悉的 Pandas 語法外，我們也提供很多語法糖，讓大家開發程式時，可以用簡易的語法完成複雜的功能，讓開發策略更簡潔！
-    我們將所有的語法糖包裹在 `FinlabDataFrame` 中，用起來跟 `pd.DataFrame` 一樣，但是多了很多功能！
-    只要使用 `finlab.data.get()` 所獲得的資料，皆為 `FinlabDataFrame` 格式，
-    接下來我們就來看看， `FinlabDataFrame` 有哪些好用的語法糖吧！
-
-    當資料日期沒有對齊（例如: 財報 vs 收盤價 vs 月報）時，在使用以下運算符號：
-    `+`, `-`, `*`, `/`, `>`, `>=`, `==`, `<`, `<=`, `&`, `|`, `~`，
-    不需要先將資料對齊，因為 `FinlabDataFrame` 會自動幫你處理，以下是示意圖。
-
-    <img src="https://i.ibb.co/pQr5yx5/Screen-Shot-2021-10-26-at-5-32-44-AM.png" alt="steps">
-
-    以下是範例：`cond1` 與 `cond2` 分別為「每天」，和「每季」的資料，假如要取交集的時間，可以用以下語法：
-
-    ```py
-    from finlab import data
-    # 取得 FinlabDataFrame
-    close = data.get('price:收盤價')
-    roa = data.get('fundamental_features:ROA稅後息前')
-
-    # 運算兩個選股條件交集
-    cond1 = close > 37
-    cond2 = roa > 0
-    cond_1_2 = cond1 & cond2
-    ```
-    擷取 1101 台泥 的訊號如下圖，可以看到 `cond1` 跟 `cond2` 訊號的頻率雖然不相同，
-    但是由於 `cond1` 跟 `cond2` 是 `FinlabDataFrame`，所以可以直接取交集，而不用處理資料頻率對齊的問題。
-    <br />
-    <img src="https://i.ibb.co/m9chXSQ/imageconds.png" alt="imageconds">
-
-    總結來說，FinlabDataFrame 與一般 dataframe 唯二不同之處：
-    1. 多了一些 method，如`df.is_largest()`, `df.sustain()`...等。
-    2. 在做四則運算、不等式運算前，會將 df1、df2 的 index 取聯集，column 取交集。
-    """
-
-    def __init__(self, *args, **kwargs):
-        super().__init__(*args, **kwargs)
-        self.id = uuid.uuid4().int
-
-    @property
-    def _constructor(self):
-        return FinlabDataFrame
-
-    @staticmethod
-    def reshape(df1, df2):
-
-        isdf1 = isinstance(df1, pd.DataFrame)
-        isdf2 = isinstance(df2, pd.DataFrame) or isinstance(df2, pd.Series)
-
-        d1_index_freq = get_index_str_frequency(df1) if isdf1 else None
-        d2_index_freq = get_index_str_frequency(df2) if isdf2 else None
-
-        if isinstance(df2, pd.Series):
-            df2 = FinlabDataFrame({c: df2 for c in df1.columns})
-            if d2_index_freq:
-                # tell user has high chance to use future data
-                logger.warning('Detect pd.Series has season/month index, the chance of using future data is high!\n'
-                               'Please convert index from str to date first then perform calculations.\n'
-                               'Example: df.quantile(0.3, axis=1) -> df.index_str_to_date().quantile(0.3, axis=1)'
-                               )
-
-        if ((d1_index_freq or d2_index_freq)
-                and (d1_index_freq != d2_index_freq)) and isdf1 and isdf2:
-
-            df1 = df1.index_str_to_date() if isinstance(df1, FinlabDataFrame) else df1
-            df2 = df2.index_str_to_date() if isinstance(df2, FinlabDataFrame) else df2
-
-        if (isdf1 and isdf2 and len(df1) and len(df2)
-            and isinstance(df1.index[0], pd.Timestamp)
-                and isinstance(df2.index[0], pd.Timestamp)):
-
-            index = df1.index.union(df2.index)
-            columns = df1.columns.intersection(df2.columns)
-
-            if len(df1.index) * len(df2.index) != 0:
-                index_start = max(df1.index[0], df2.index[0])
-                index = [t for t in index if index_start <= t]
-
-            return df1.reindex(index=index, method='ffill')[columns], \
-                df2.reindex(index=index, method='ffill')[columns]
-
-        return df1, df2
-
-    def index_str_to_date(self):
-        """財務月季報索引格式轉換
-
-          將以下資料的索引轉換成datetime格式:
-
-          財務季報 (ex:2022-Q1) 從文字格式轉為財報電子檔資料上傳日。
-
-          通常使用情境為對不同週期的dataframe做reindex，常用於以公告截止日作為訊號產生日。
-
-          Returns:
-            (pd.DataFrame): data
-
-          Examples:
-              ```py
-              data.get('financial_statement:現金及約當現金').index_str_to_date()
-              ```
-        """
-        if len(self.index) == 0 or not isinstance(self.index[0], str):
-            return self
-
-        if self.index[0].find('M') != -1:
-            return self._index_str_to_date_month()
-        elif self.index[0].find('Q') != -1:
-            if self.index[0].find('US-ALL') != -1:
-                return self._index_str_to_date_season(market='us_stock_all')
-            elif self.index[0].find('US') != -1:
-                return self._index_str_to_date_season(market='us_stock')
-            else:
-                return self._index_str_to_date_season()
-
-        return self
-
-    def __hash__(self):
-        if not hasattr(self, 'id'):
-            self.id = uuid.uuid4().int
-        return self.id
-
-    @staticmethod
-    def to_business_day(date, close=None):
-
-        def skip_weekend(d):
-            add_days = {5: 2, 6: 1}
-            wd = d.weekday()
-            if wd in add_days:
-                d += datetime.timedelta(days=add_days[wd])
-            return d
-
-        if close is None:
-            from finlab import data
-            close = data.get('price:收盤價')
-
-        return pd.Series(date).apply(lambda d: skip_weekend(d) if d in close.index or d < close.index[0] or d > close.index[-1] else close.loc[d:].index[0]).values
-
-    def _index_date_to_str_month(self):
-
-        # index is already str
-        if len(self.index) == 0 or not isinstance(self.index[0], pd.Timestamp):
-            return self
-
-        index = (self.index - datetime.timedelta(days=30)).strftime('%Y-M%m')
-        df = FinlabDataFrame(self.values, index=index, columns=self.columns)
-
-        return df
-
-    def _index_str_to_date_month(self):
-        return self
-
-        # index is already timestamps
-        if len(self.index) == 0 or not isinstance(self.index[0], str):
-            return self
-
-        global monthly_index
-
-        if monthly_index is None:
-            rev = data.get('monthly_revenue:當月營收', force_download=True)
-
-        if not (self.index.str.find('M') != -1).all():
-            logger.warning(
-                'FinlabDataFrame: invalid index, cannot format index to monthly timestamp.')
-            return self
-
-        index = monthly_index
-        index = self.to_business_day(index)
-
-        ret = FinlabDataFrame(self.values, index=index, columns=self.columns)
-        ret.index.name = 'date'
-
-        return ret
-
-    def _index_to_business_day(self):
-
-        index = self.to_business_day(self.index)
-        ret = FinlabDataFrame(self.values, index=index, columns=self.columns)
-        ret.index.name = 'date'
-        return ret
-
-    def _index_date_to_str_season(self, postfix=''):
-
-        # index is already str
-        if len(self.index) == 0 or not isinstance(self.index[0], pd.Timestamp):
-            return self
-
-        year = self.index.year.copy()
-        if postfix:
-            q = self.index.strftime('%m').astype(
-                int).map({3: 1, 6: 2, 9: 3, 12: 4})
-        else:
-            q = self.index.strftime('%m').astype(int).map(
-                {5: 1, 8: 2, 9: 2, 10: 3, 11: 3, 3: 4, 4: 4})
-            year -= (q == 4)
-        index = year.astype(str) + f'{postfix}-Q' + q.astype(str)
-        return FinlabDataFrame(self.values, index=index, columns=self.columns)
-
-    def deadline(self):
-        """財務索引轉換成公告截止日
-
-          將財務季報 (ex:2022Q1) 從文字格式轉為公告截止日的datetime格式，
-          通常使用情境為對不同週期的dataframe做reindex，常用於以公告截止日作為訊號產生日。
-          Returns:
-            (pd.DataFrame): data
-          Examples:
-              ```py
-              data.get('financial_statement:現金及約當現金').deadline()
-              data.get('monthly_revenue:當月營收').deadline()
-              ```
-        """
-        if len(self.index) == 0 or not isinstance(self.index[0], str):
-            return self
-
-        if self.index[0].find('M') != -1:
-            return self._index_str_to_date_month()
-        elif self.index[0].find('Q') != -1:
-            return self._index_str_to_date_season(detail=False)
-
-        raise Exception("Cannot apply deadline to dataframe. "
-                        "Index is not compatable."
-                        "Index should be 2013-Q1 or 2013-M1."
-                        )
-
-    def _index_str_to_date_season(self, detail=True, market='tw_stock'):
-
-        if market == 'tw_stock':
-            from finlab import data
-            if detail:
-                datekey = data.get(
-                    'etl:financial_statements_disclosure_dates').copy()
-            else:
-                datekey = data.get('etl:financial_statements_deadline').copy()
-        elif market == 'us_stock':
-            from finlab import data
-            datekey = data.get('us_fundamental:datekey').copy()
-        elif market == 'us_stock_all':
-            from finlab import data
-            datekey = data.get('us_fundamental_all:datekey').copy()
-
-        intersect_cols = self.columns.intersection(datekey.columns)
-
-        disclosure_dates = (datekey
-                            .reindex(self.index)
-                            [intersect_cols]
-                            .unstack())
-
-        if not hasattr(self.columns, 'name') or self.columns.name is None:
-            self.columns.name = 'symbol'
-
-        col_name = self.columns.name
-
-        unstacked = self[intersect_cols].unstack()
-
-        ret = pd.DataFrame({
-            'value': unstacked.values,
-            'disclosures': disclosure_dates.values,
-        }, unstacked.index)
-        ret.index.names = [col_name, 'date']
-        ret = (ret
-               .reset_index()
-               .drop_duplicates(['disclosures', col_name])
-               .pivot(index='disclosures', columns=col_name, values='value').ffill()
-               .pipe(lambda df: df.loc[df.index.notna()])
-               .pipe(lambda df: FinlabDataFrame(df))
-               .rename_axis('date')
-               )
-
-        if not detail:
-            ret.index = self.to_business_day(ret.index)
-
-        return ret
-
-    def average(self, n):
-        """取 n 筆移動平均
-
-        若股票在時間窗格內，有 N/2 筆 NaN，則會產生 NaN。
-        Args:
-          n (positive-int): 設定移動窗格數。
-        Returns:
-          (pd.DataFrame): data
-        Examples:
-            股價在均線之上
-            ```py
-            from finlab import data
-            close = data.get('price:收盤價')
-            sma = close.average(10)
-            cond = close > sma
-            ```
-            只需要簡單的語法，就可以將其中一部分的訊號繪製出來檢查：
-            ```py
-            import matplotlib.pyplot as plt
-
-            close.loc['2021', '2330'].plot()
-            sma.loc['2021', '2330'].plot()
-            cond.loc['2021', '2330'].mul(20).add(500).plot()
-
-            plt.legend(['close', 'sma', 'cond'])
-            ```
-            <img src="https://i.ibb.co/Mg1P85y/sma.png" alt="sma">
-        """
-        return self.rolling(n, min_periods=int(n/2)).mean()
-
-    def is_largest(self, n):
-        """取每列前 n 筆大的數值
-
-        若符合 `True` ，反之為 `False` 。用來篩選每天數值最大的股票。
-
-        <img src="https://i.ibb.co/8rh3tbt/is-largest.png" alt="is-largest">
-        Args:
-          n (positive-int): 設定每列前 n 筆大的數值。
-        Returns:
-          (pd.DataFrame): data
-        Examples:
-            每季 ROA 前 10 名的股票
-            ```py
-            from finlab import data
-
-            roa = data.get('fundamental_features:ROA稅後息前')
-            good_stocks = roa.is_largest(10)
-            ```
-        """
-        return self.astype(float).apply(lambda s: s.nlargest(n), axis=1).reindex_like(self).notna()
-
-    def is_smallest(self, n):
-        """取每列前 n 筆小的數值
-
-        若符合 `True` ，反之為 `False` 。用來篩選每天數值最小的股票。
-        Args:
-          n (positive-int): 設定每列前 n 筆小的數值。
-        Returns:
-          (pd.DataFrame): data
-        Examples:
-            股價淨值比最小的 10 檔股票
-            ```py
-            from finlab import data
-
-            pb = data.get('price_earning_ratio:股價淨值比')
-            cheap_stocks = pb.is_smallest(10)
-            ```
-        """
-        return self.astype(float).apply(lambda s: s.nsmallest(n), axis=1).reindex_like(self).notna()
-
-    def is_entry(self):
-        """進場點
-
-        取進場訊號點，若符合條件的值則為True，反之為False。
-        Returns:
-          (pd.DataFrame): data
-        Examples:
-          策略為每日收盤價前10高，取進場點。
-            ```py
-            from finlab import data
-            data.get('price:收盤價').is_largest(10).is_entry()
-            ```
-        """
-        return (self & ~self.shift(fill_value=False))
-
-    def is_exit(self):
-        """出場點
-
-        取出場訊號點，若符合條件的值則為 True，反之為 False。
-        Returns:
-          (pd.DataFrame): data
-        Examples:
-          策略為每日收盤價前10高，取出場點。
-            ```py
-            from finlab import data
-            data.get('price:收盤價').is_largest(10).is_exit()
-            ```
-        """
-        return (~self & self.shift(fill_value=False))
-
-    def rise(self, n=1):
-        """數值上升中
-
-        取是否比前第n筆高，若符合條件的值則為True，反之為False。
-        <img src="https://i.ibb.co/Y72bN5v/Screen-Shot-2021-10-26-at-6-43-41-AM.png" alt="Screen-Shot-2021-10-26-at-6-43-41-AM">
-        Args:
-          n (positive-int): 設定比較前第n筆高。
-        Returns:
-          (pd.DataFrame): data
-        Examples:
-            收盤價是否高於10日前股價
-            ```py
-            from finlab import data
-            data.get('price:收盤價').rise(10)
-            ```
-        """
-        return self > self.shift(n)
-
-    def fall(self, n=1):
-        """數值下降中
-
-        取是否比前第n筆低，若符合條件的值則為True，反之為False。
-        <img src="https://i.ibb.co/Y72bN5v/Screen-Shot-2021-10-26-at-6-43-41-AM.png" alt="Screen-Shot-2021-10-26-at-6-43-41-AM">
-        Args:
-          n (positive-int): 設定比較前第n筆低。
-        Returns:
-          (pd.DataFrame): data
-        Examples:
-            收盤價是否低於10日前股價
-            ```py
-            from finlab import data
-            data.get('price:收盤價').fall(10)
-            ```
-        """
-        return self < self.shift(n)
-
-    def groupby_category(self):
-        """資料按產業分群
-
-        類似 `pd.DataFrame.groupby()`的處理效果。
-        Returns:
-          (pd.DataFrame): data
-        Examples:
-          半導體平均股價淨值比時間序列
-            ```py
-            from finlab import data
-            pe = data.get('price_earning_ratio:股價淨值比')
-            pe.groupby_category().mean()['半導體'].plot()
-            ```
-            <img src="https://i.ibb.co/Tq2fKBp/pbmean.png" alt="pbmean">
-
-            全球 2020 量化寬鬆加上晶片短缺，使得半導體股價淨值比衝高。
-        """
-        from finlab import data
-        categories = data.get('security_categories')
-        cat = categories.set_index('stock_id').category.to_dict()
-        org_set = set(cat.values())
-        set_remove_illegal = set(
-            o for o in org_set if isinstance(o, str) and o != 'nan')
-        set_remove_illegal
-
-        refine_cat = {}
-        for s, c in cat.items():
-            if c == None or c == 'nan':
-                refine_cat[s] = '其他'
-                continue
-
-            if c == '電腦及週邊':
-                refine_cat[s] = '電腦及週邊設備業'
-                continue
-
-            if c[-1] == '業' and c[:-1] in set_remove_illegal:
-                refine_cat[s] = c[:-1]
-            else:
-                refine_cat[s] = c
-
-        col_categories = pd.Series(self.columns.map(
-            lambda s: refine_cat[s] if s in cat else '其他'))
-
-        return self.groupby(col_categories.values, axis=1)
-
-    def entry_price(self, trade_at='close'):
-
-        signal = self.is_entry()
-        from finlab import data
-        adj = data.get('etl:adj_close') if trade_at == 'close' else data.get(
-            'etl:adj_open')
-        adj, signal = adj.reshape(
-            adj.loc[signal.index[0]: signal.index[-1]], signal)
-        return adj.bfill()[signal.shift(fill_value=False)].ffill()
-
-    def sustain(self, nwindow, nsatisfy=None):
-        """持續 N 天滿足條件
-
-        取移動 nwindow 筆加總大於等於nsatisfy，若符合條件的值則為True，反之為False。
-
-        Args:
-          nwindow (positive-int): 設定移動窗格。
-          nsatisfy (positive-int): 設定移動窗格計算後最低滿足數值。
-        Returns:
-          (pd.DataFrame): data
-        Examples:
-            收盤價是否連兩日上漲
-            ```py
-            from finlab import data
-            data.get('price:收盤價').rise().sustain(2)
-            ```
-        """
-        nsatisfy = nsatisfy or nwindow
-        return self.rolling(nwindow).sum() >= nsatisfy
-
-    def industry_rank(self, categories=None):
-        """計算產業 ranking 排名，0 代表產業內最低，1 代表產業內最高
-        Args:
-          categories (list of str): 欲考慮的產業，ex: ['貿易百貨', '雲端運算']，預設為全產業，請參考 `data.get('security_industry_themes')` 中的產業項目。
-        Examples:
-            本意比產業排名分數
-            ```py
-            from finlab import data
-
-            pe = data.get('price_earning_ratio:本益比')
-            pe_rank = pe.industry_rank()
-            print(pe_rank)
-            ```
-        """
-        from finlab import data
-
-        themes = (data.get('security_industry_themes')
-                  .copy()  # 複製
-                  .assign(category=lambda self: self.category
-                          .apply(lambda s: eval(s)))  # 從文字格式轉成陣列格
-                  .explode('category')  # 展開資料
-                  )
-
-        categories = (categories
-                      or set(themes.category[themes.category.str.find(':') == -1]))
-
-        def calc_rank(ind):
-            stock_ids = themes.stock_id[themes.category == ind]
-            return (self[list(stock_ids)].pipe(lambda self: self.rank(axis=1, pct=True)))
-
-        return (pd.concat([calc_rank(ind) for ind in categories], axis=1)
-                .groupby(level=0, axis=1).mean())
-
-    def quantile_row(self, c):
-        """股票當天數值分位數
-
-        取得每列c定分位數的值。
-        Args:
-          c (positive-int): 設定每列 n 定分位數的值。
-        Returns:
-          (pd.DataFrame): data
-        Examples:
-            取每日股價前90％分位數
-            ```py
-            from finlab import data
-            data.get('price:收盤價').quantile_row(0.9)
-            ```
-        """
-        s = self.index_str_to_date().quantile(c, axis=1)
-        return s
-
-    def exit_when(self, exit):
-
-        df, exit = self.reshape(self, exit)
-
-        df.fillna(False, inplace=True)
-        exit.fillna(False, inplace=True)
-
-        entry_signal = df.is_entry()
-        exit_signal = df.is_exit()
-        exit_signal |= exit
-
-        # build position using entry_signal and exit_signal
-        position = pd.DataFrame(np.nan, index=df.index, columns=df.columns)
-        position[entry_signal] = 1
-        position[exit_signal] = 0
-
-        position.ffill(inplace=True)
-        position = position == 1
-        position.fillna(False)
-        return position
-
-    def hold_until(self, exit, nstocks_limit=None, stop_loss=-np.inf, take_profit=np.inf, trade_at='close', rank=None, market='AUTO'):
-        """訊號進出場
-
-        這大概是所有策略撰寫中，最重要的語法糖，上述語法中 `entries` 為進場訊號，而 `exits` 是出場訊號。所以 `entries.hold_until(exits)` ，就是進場訊號為 `True` 時，買入並持有該檔股票，直到出場訊號為 `True ` 則賣出。
-        <img src="https://i.ibb.co/PCt4hPd/Screen-Shot-2021-10-26-at-6-35-05-AM.png" alt="Screen-Shot-2021-10-26-at-6-35-05-AM">
-        此函式有很多細部設定，可以讓你最多選擇 N 檔股票做輪動。另外，當超過 N 檔進場訊號發生，也可以按照客制化的排序，選擇優先選入的股票。最後，可以設定價格波動當輪動訊號，來增加出場的時機點。
-
-        Args:
-          exit (pd.Dataframe): 出場訊號。
-          nstocks_limit (int)`: 輪動檔數上限，預設為None。
-          stop_loss (float): 價格波動輪動訊號，預設為None，不生成輪動訊號。範例：0.1，代表成本價下跌 10% 時產生出場訊號。
-          take_profit (float): 價格波動輪動訊號，預設為None，不生成輪動訊號。範例：0.1，代表成本價上漲 10% 時產生出場訊號。
-          trade_at (str): 價格波動輪動訊號參考價，預設為'close'。可選 `close` 或 `open`。
-          rank (pd.Dataframe): 當天進場訊號數量超過 nstocks_limit 時，以 rank 數值越大的股票優先進場。
-
-        Returns:
-          (pd.DataFrame): data
-
-        Examples:
-            價格 > 20 日均線入場, 價格 < 60 日均線出場，最多持有10檔，超過 10 個進場訊號，則以股價淨值比小的股票優先選入。
-            ```py
-            from finlab import data
-            from finlab.backtest import sim
-
-            close = data.get('price:收盤價')
-            pb = data.get('price_earning_ratio:股價淨值比')
-
-            sma20 = close.average(20)
-            sma60 = close.average(60)
-
-            entries = close > sma20
-            exits = close < sma60
-
-            #pb前10小的標的做輪動
-            position = entries.hold_until(exits, nstocks_limit=10, rank=-pb)
-            sim(position)
-            ```
-        """
-        if nstocks_limit is None:
-            nstocks_limit = len(self.columns)
-
-        self_reindex = self.index_str_to_date()
-        exit_reindex = exit.index_str_to_date()
-        rank_reindex = rank.index_str_to_date() if rank is not None else None
-
-        union_index = self_reindex.index.union(exit_reindex.index)
-        intersect_col = self_reindex.columns.intersection(exit_reindex.columns)
-
-        if stop_loss != -np.inf or take_profit != np.inf:
-            market = finlab.market_info.get_market_info(
-                self_reindex, user_market_info=market)
-
-            if not isinstance(market, finlab.market_info.MarketInfo):
-                raise Exception("It seems like the market has"
-                                "not been specified well when using the hold_until"
-                                " function. Please provide the appropriate"
-                                " market parameter to the hold_until function "
-                                "to ensure it can determine the correct market"
-                                " for the transaction.")
-
-            price = market.get_price(trade_at, adj=True)
-
-            union_index = union_index.union(
-                price.loc[union_index[0]: union_index[-1]].index)
-            intersect_col = intersect_col.intersection(price.columns)
-        else:
-            price = pd.DataFrame(index=union_index, columns=intersect_col)
-            price.index = pd.to_datetime(price.index)
-
-        if rank_reindex is not None:
-            union_index = union_index.union(rank_reindex.index)
-            intersect_col = intersect_col.intersection(rank_reindex.columns)
-
-        entry = self_reindex.reindex(union_index, method='ffill')[
-            intersect_col].ffill().fillna(False)
-
-        exit = exit_reindex.reindex(union_index, method='ffill')[
-            intersect_col].ffill().fillna(False)
-
-        if price is not None:
-            price = price.reindex(union_index, method='ffill')[intersect_col]
-
-        if rank_reindex is not None:
-            rank_reindex = rank_reindex.reindex(
-                union_index, method='ffill')[intersect_col]
-        else:
-            rank_reindex = pd.DataFrame(
-                1, index=union_index, columns=intersect_col)
-
-        rank_reindex = rank_reindex.replace([np.inf, -np.inf], np.nan)
-
-        max_rank = rank_reindex.max().max()
-        min_rank = rank_reindex.min().min()
-        rank_reindex = (rank_reindex - min_rank) / (max_rank - min_rank)
-        rank_reindex.fillna(0, inplace=True)
-
-        def rotate_stocks(ret, entry, exit, nstocks_limit, stop_loss=-np.inf, take_profit=np.inf, price=None, ranking=None):
-
-            nstocks = 0
-
-            ret[0][np.argsort(entry[0], kind='stable')[-nstocks_limit:]] = 1
-            ret[0][exit[0] == 1] = 0
-            ret[0][entry[0] == 0] = 0
-
-            entry_price = np.empty(entry.shape[1])
-            entry_price[:] = np.nan
-
-            for i in range(1, entry.shape[0]):
-
-                # regitser entry price
-                if stop_loss != -np.inf or take_profit != np.inf:
-                    is_entry = ((ret[i-2] == 0) if i >
-                                1 else (ret[i-1] == 1))
-
-                    is_waiting_for_entry = np.isnan(
-                        entry_price) & (ret[i-1] == 1)
-
-                    is_entry |= is_waiting_for_entry
-
-                    entry_price[is_entry == 1] = price[i][is_entry == 1]
-
-                    # check stop_loss and take_profit
-                    returns = price[i] / entry_price
-                    stop = (returns > 1 + abs(take_profit)
-                            ) | (returns < 1 - abs(stop_loss))
-                    exit[i] |= stop
-
-                # run signal
-                rank = (entry[i] * ranking[i] + ret[i-1] * 3)
-                rank[exit[i] == 1] = -1
-                rank[(entry[i] == 0) & (ret[i-1] == 0)] = -1
-
-                ret[i][np.argsort(rank)[-nstocks_limit:]] = 1
-                ret[i][rank == -1] = 0
-
-            return ret
-
-        ret = pd.DataFrame(0, index=entry.index, columns=entry.columns)
-        ret = rotate_stocks(ret.values,
-                            entry.astype(int).values,
-                            exit.astype(int).values,
-                            nstocks_limit,
-                            stop_loss,
-                            take_profit,
-                            price=price.values,
-                            ranking=rank_reindex.values)
-        return pd.DataFrame(ret, index=entry.index, columns=entry.columns).astype(bool)
+import uuid
+import logging
+import inspect
+import datetime
+import numpy as np
+import pandas as pd
+from functools import lru_cache
+
+import finlab.market_info
+
+logger = logging.getLogger(__name__)
+
+
+def reshape_operations(cls):
+
+    # Define a mapping of operations to override to their corresponding pandas method
+    methods_to_check = [
+        '__getitem__',
+        '__add__', '__sub__', '__mul__', '__truediv__', '__floordiv__',
+        '__mod__', '__pow__', '__lshift__', '__rshift__', '__and__',
+        '__or__', '__xor__', '__iadd__', '__isub__', '__imul__',
+        '__itruediv__', '__ifloordiv__', '__imod__', '__ipow__',
+        '__ilshift__', '__irshift__', '__iand__', '__ior__', '__ixor__',
+        '__lt__', '__le__', '__eq__', '__ne__', '__gt__', '__ge__',
+    ]
+
+    # find operation mapping that map str -> function for the function need reshape.
+
+    base_class = pd.DataFrame
+    operations_mapping = {}
+
+    for method_name in methods_to_check:
+        if hasattr(base_class, method_name):
+            method = getattr(base_class, method_name)
+            params = inspect.signature(method).parameters
+            can_accept_df = any(
+                param.annotation == pd.DataFrame or param.annotation == inspect._empty
+                for param in params.values()
+            )
+            if can_accept_df:
+                operations_mapping[method_name] = getattr(
+                    pd.DataFrame, method_name)
+
+    # replace original function to reshaped function
+
+    for op, pandas_method in operations_mapping.items():
+        if hasattr(cls, op):
+
+            def make_wrapped_method(op):
+                def wrapped_method(self, other, pandas_method=pandas_method):
+
+                    df1, df2 = self.reshape(self, other)
+
+                    if isinstance(other, pd.Series) and op == '__getitem__':
+                        return df1.loc[df2.iloc[:, 0]]
+
+                    return pandas_method(df1, df2)
+
+                return wrapped_method
+
+            setattr(cls, op, make_wrapped_method(op))
+
+    return cls
+
+
+def get_index_str_frequency(df):
+
+    if not hasattr(df, 'index'):
+        return None
+
+    if len(df.index) == 0:
+        return None
+
+    if not isinstance(df.index[0], str):
+        return None
+
+    if (df.index.str.find('M') != -1).all():
+        return 'month'
+
+    if (df.index.str.find('Q') != -1).all():
+        return 'season'
+
+    return None
+
+
+@reshape_operations
+class FinlabDataFrame(pd.DataFrame):
+    """回測語法糖
+    除了使用熟悉的 Pandas 語法外，我們也提供很多語法糖，讓大家開發程式時，可以用簡易的語法完成複雜的功能，讓開發策略更簡潔！
+    我們將所有的語法糖包裹在 `FinlabDataFrame` 中，用起來跟 `pd.DataFrame` 一樣，但是多了很多功能！
+    只要使用 `finlab.data.get()` 所獲得的資料，皆為 `FinlabDataFrame` 格式，
+    接下來我們就來看看， `FinlabDataFrame` 有哪些好用的語法糖吧！
+
+    當資料日期沒有對齊（例如: 財報 vs 收盤價 vs 月報）時，在使用以下運算符號：
+    `+`, `-`, `*`, `/`, `>`, `>=`, `==`, `<`, `<=`, `&`, `|`, `~`，
+    不需要先將資料對齊，因為 `FinlabDataFrame` 會自動幫你處理，以下是示意圖。
+
+    <img src="https://i.ibb.co/pQr5yx5/Screen-Shot-2021-10-26-at-5-32-44-AM.png" alt="steps">
+
+    以下是範例：`cond1` 與 `cond2` 分別為「每天」，和「每季」的資料，假如要取交集的時間，可以用以下語法：
+
+    ```py
+    from finlab import data
+    # 取得 FinlabDataFrame
+    close = data.get('price:收盤價')
+    roa = data.get('fundamental_features:ROA稅後息前')
+
+    # 運算兩個選股條件交集
+    cond1 = close > 37
+    cond2 = roa > 0
+    cond_1_2 = cond1 & cond2
+    ```
+    擷取 1101 台泥 的訊號如下圖，可以看到 `cond1` 跟 `cond2` 訊號的頻率雖然不相同，
+    但是由於 `cond1` 跟 `cond2` 是 `FinlabDataFrame`，所以可以直接取交集，而不用處理資料頻率對齊的問題。
+    <br />
+    <img src="https://i.ibb.co/m9chXSQ/imageconds.png" alt="imageconds">
+
+    總結來說，FinlabDataFrame 與一般 dataframe 唯二不同之處：
+    1. 多了一些 method，如`df.is_largest()`, `df.sustain()`...等。
+    2. 在做四則運算、不等式運算前，會將 df1、df2 的 index 取聯集，column 取交集。
+    """
+
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
+        self.id = uuid.uuid4().int
+
+    @property
+    def _constructor(self):
+        return FinlabDataFrame
+
+    @staticmethod
+    def reshape(df1, df2):
+
+        isdf1 = isinstance(df1, pd.DataFrame)
+        isdf2 = isinstance(df2, pd.DataFrame) or isinstance(df2, pd.Series)
+
+        d1_index_freq = get_index_str_frequency(df1) if isdf1 else None
+        d2_index_freq = get_index_str_frequency(df2) if isdf2 else None
+
+        if isinstance(df2, pd.Series):
+            df2 = FinlabDataFrame({c: df2 for c in df1.columns})
+            if d2_index_freq:
+                # tell user has high chance to use future data
+                logger.warning('Detect pd.Series has season/month index, the chance of using future data is high!\n'
+                               'Please convert index from str to date first then perform calculations.\n'
+                               'Example: df.quantile(0.3, axis=1) -> df.index_str_to_date().quantile(0.3, axis=1)'
+                               )
+
+        if ((d1_index_freq or d2_index_freq)
+                and (d1_index_freq != d2_index_freq)) and isdf1 and isdf2:
+
+            df1 = df1.index_str_to_date() if isinstance(df1, FinlabDataFrame) else df1
+            df2 = df2.index_str_to_date() if isinstance(df2, FinlabDataFrame) else df2
+
+        if (isdf1 and isdf2 and len(df1) and len(df2)
+            and isinstance(df1.index[0], pd.Timestamp)
+                and isinstance(df2.index[0], pd.Timestamp)):
+
+            index = df1.index.union(df2.index)
+            columns = df1.columns.intersection(df2.columns)
+
+            if len(df1.index) * len(df2.index) != 0:
+                index_start = max(df1.index[0], df2.index[0])
+                index = [t for t in index if index_start <= t]
+
+            return df1.reindex(index=index, method='ffill')[columns], \
+                df2.reindex(index=index, method='ffill')[columns]
+
+        return df1, df2
+
+    def index_str_to_date(self):
+        """財務月季報索引格式轉換
+
+          將以下資料的索引轉換成datetime格式:
+
+          財務季報 (ex:2022-Q1) 從文字格式轉為財報電子檔資料上傳日。
+
+          通常使用情境為對不同週期的dataframe做reindex，常用於以公告截止日作為訊號產生日。
+
+          Returns:
+            (pd.DataFrame): data
+
+          Examples:
+              ```py
+              data.get('financial_statement:現金及約當現金').index_str_to_date()
+              ```
+        """
+        if len(self.index) == 0 or not isinstance(self.index[0], str):
+            return self
+
+        if self.index[0].find('M') != -1:
+            return self._index_str_to_date_month()
+        elif self.index[0].find('Q') != -1:
+            if self.index[0].find('US-ALL') != -1:
+                return self._index_str_to_date_season(market='us_stock_all')
+            elif self.index[0].find('US') != -1:
+                return self._index_str_to_date_season(market='us_stock')
+            else:
+                return self._index_str_to_date_season()
+
+        return self
+
+    def __hash__(self):
+        if not hasattr(self, 'id'):
+            self.id = uuid.uuid4().int
+        return self.id
+
+    @staticmethod
+    def to_business_day(date, close=None):
+
+        def skip_weekend(d):
+            add_days = {5: 2, 6: 1}
+            wd = d.weekday()
+            if wd in add_days:
+                d += datetime.timedelta(days=add_days[wd])
+            return d
+
+        if close is None:
+            from finlab import data
+            close = data.get('price:收盤價')
+
+        return pd.Series(date).apply(lambda d: skip_weekend(d) if d in close.index or d < close.index[0] or d > close.index[-1] else close.loc[d:].index[0]).values
+
+    def _index_date_to_str_month(self):
+
+        # index is already str
+        if len(self.index) == 0 or not isinstance(self.index[0], pd.Timestamp):
+            return self
+
+        index = (self.index - datetime.timedelta(days=30)).strftime('%Y-M%m')
+        df = FinlabDataFrame(self.values, index=index, columns=self.columns)
+
+        return df
+
+    def _index_str_to_date_month(self):
+        return self
+
+        # index is already timestamps
+        if len(self.index) == 0 or not isinstance(self.index[0], str):
+            return self
+
+        global monthly_index
+
+        if monthly_index is None:
+            rev = data.get('monthly_revenue:當月營收', force_download=True)
+
+        if not (self.index.str.find('M') != -1).all():
+            logger.warning(
+                'FinlabDataFrame: invalid index, cannot format index to monthly timestamp.')
+            return self
+
+        index = monthly_index
+        index = self.to_business_day(index)
+
+        ret = FinlabDataFrame(self.values, index=index, columns=self.columns)
+        ret.index.name = 'date'
+
+        return ret
+
+    def _index_to_business_day(self):
+
+        index = self.to_business_day(self.index)
+        ret = FinlabDataFrame(self.values, index=index, columns=self.columns)
+        ret.index.name = 'date'
+        return ret
+
+    def _index_date_to_str_season(self, postfix=''):
+
+        # index is already str
+        if len(self.index) == 0 or not isinstance(self.index[0], pd.Timestamp):
+            return self
+
+        year = self.index.year.copy()
+        if postfix:
+            q = self.index.strftime('%m').astype(
+                int).map({3: 1, 6: 2, 9: 3, 12: 4})
+        else:
+            q = self.index.strftime('%m').astype(int).map(
+                {5: 1, 8: 2, 9: 2, 10: 3, 11: 3, 3: 4, 4: 4})
+            year -= (q == 4)
+        index = year.astype(str) + f'{postfix}-Q' + q.astype(str)
+        return FinlabDataFrame(self.values, index=index, columns=self.columns)
+
+    def deadline(self):
+        """財務索引轉換成公告截止日
+
+          將財務季報 (ex:2022Q1) 從文字格式轉為公告截止日的datetime格式，
+          通常使用情境為對不同週期的dataframe做reindex，常用於以公告截止日作為訊號產生日。
+          Returns:
+            (pd.DataFrame): data
+          Examples:
+              ```py
+              data.get('financial_statement:現金及約當現金').deadline()
+              data.get('monthly_revenue:當月營收').deadline()
+              ```
+        """
+        if len(self.index) == 0 or not isinstance(self.index[0], str):
+            return self
+
+        if self.index[0].find('M') != -1:
+            return self._index_str_to_date_month()
+        elif self.index[0].find('Q') != -1:
+            return self._index_str_to_date_season(detail=False)
+
+        raise Exception("Cannot apply deadline to dataframe. "
+                        "Index is not compatable."
+                        "Index should be 2013-Q1 or 2013-M1."
+                        )
+
+    def _index_str_to_date_season(self, detail=True, market='tw_stock'):
+
+        if market == 'tw_stock':
+            from finlab import data
+            if detail:
+                datekey = data.get(
+                    'etl:financial_statements_disclosure_dates').copy()
+            else:
+                datekey = data.get('etl:financial_statements_deadline').copy()
+        elif market == 'us_stock':
+            from finlab import data
+            datekey = data.get('us_fundamental:datekey').copy()
+        elif market == 'us_stock_all':
+            from finlab import data
+            datekey = data.get('us_fundamental_all:datekey').copy()
+
+        intersect_cols = self.columns.intersection(datekey.columns)
+
+        disclosure_dates = (datekey
+                            .reindex(self.index)
+                            [intersect_cols]
+                            .unstack())
+
+        if not hasattr(self.columns, 'name') or self.columns.name is None:
+            self.columns.name = 'symbol'
+
+        col_name = self.columns.name
+
+        unstacked = self[intersect_cols].unstack()
+
+        ret = pd.DataFrame({
+            'value': unstacked.values,
+            'disclosures': disclosure_dates.values,
+        }, unstacked.index)
+        ret.index.names = [col_name, 'date']
+        ret = (ret
+               .reset_index()
+               .drop_duplicates(['disclosures', col_name])
+               .pivot(index='disclosures', columns=col_name, values='value').ffill()
+               .pipe(lambda df: df.loc[df.index.notna()])
+               .pipe(lambda df: FinlabDataFrame(df))
+               .rename_axis('date')
+               )
+
+        if not detail:
+            ret.index = self.to_business_day(ret.index)
+
+        return ret
+
+    def average(self, n):
+        """取 n 筆移動平均
+
+        若股票在時間窗格內，有 N/2 筆 NaN，則會產生 NaN。
+        Args:
+          n (positive-int): 設定移動窗格數。
+        Returns:
+          (pd.DataFrame): data
+        Examples:
+            股價在均線之上
+            ```py
+            from finlab import data
+            close = data.get('price:收盤價')
+            sma = close.average(10)
+            cond = close > sma
+            ```
+            只需要簡單的語法，就可以將其中一部分的訊號繪製出來檢查：
+            ```py
+            import matplotlib.pyplot as plt
+
+            close.loc['2021', '2330'].plot()
+            sma.loc['2021', '2330'].plot()
+            cond.loc['2021', '2330'].mul(20).add(500).plot()
+
+            plt.legend(['close', 'sma', 'cond'])
+            ```
+            <img src="https://i.ibb.co/Mg1P85y/sma.png" alt="sma">
+        """
+        return self.rolling(n, min_periods=int(n/2)).mean()
+
+    def is_largest(self, n):
+        """取每列前 n 筆大的數值
+
+        若符合 `True` ，反之為 `False` 。用來篩選每天數值最大的股票。
+
+        <img src="https://i.ibb.co/8rh3tbt/is-largest.png" alt="is-largest">
+        Args:
+          n (positive-int): 設定每列前 n 筆大的數值。
+        Returns:
+          (pd.DataFrame): data
+        Examples:
+            每季 ROA 前 10 名的股票
+            ```py
+            from finlab import data
+
+            roa = data.get('fundamental_features:ROA稅後息前')
+            good_stocks = roa.is_largest(10)
+            ```
+        """
+        return self.astype(float).apply(lambda s: s.nlargest(n), axis=1).reindex_like(self).notna()
+
+    def is_smallest(self, n):
+        """取每列前 n 筆小的數值
+
+        若符合 `True` ，反之為 `False` 。用來篩選每天數值最小的股票。
+        Args:
+          n (positive-int): 設定每列前 n 筆小的數值。
+        Returns:
+          (pd.DataFrame): data
+        Examples:
+            股價淨值比最小的 10 檔股票
+            ```py
+            from finlab import data
+
+            pb = data.get('price_earning_ratio:股價淨值比')
+            cheap_stocks = pb.is_smallest(10)
+            ```
+        """
+        return self.astype(float).apply(lambda s: s.nsmallest(n), axis=1).reindex_like(self).notna()
+
+    def is_entry(self):
+        """進場點
+
+        取進場訊號點，若符合條件的值則為True，反之為False。
+        Returns:
+          (pd.DataFrame): data
+        Examples:
+          策略為每日收盤價前10高，取進場點。
+            ```py
+            from finlab import data
+            data.get('price:收盤價').is_largest(10).is_entry()
+            ```
+        """
+        return (self & ~self.shift(fill_value=False))
+
+    def is_exit(self):
+        """出場點
+
+        取出場訊號點，若符合條件的值則為 True，反之為 False。
+        Returns:
+          (pd.DataFrame): data
+        Examples:
+          策略為每日收盤價前10高，取出場點。
+            ```py
+            from finlab import data
+            data.get('price:收盤價').is_largest(10).is_exit()
+            ```
+        """
+        return (~self & self.shift(fill_value=False))
+
+    def rise(self, n=1):
+        """數值上升中
+
+        取是否比前第n筆高，若符合條件的值則為True，反之為False。
+        <img src="https://i.ibb.co/Y72bN5v/Screen-Shot-2021-10-26-at-6-43-41-AM.png" alt="Screen-Shot-2021-10-26-at-6-43-41-AM">
+        Args:
+          n (positive-int): 設定比較前第n筆高。
+        Returns:
+          (pd.DataFrame): data
+        Examples:
+            收盤價是否高於10日前股價
+            ```py
+            from finlab import data
+            data.get('price:收盤價').rise(10)
+            ```
+        """
+        return self > self.shift(n)
+
+    def fall(self, n=1):
+        """數值下降中
+
+        取是否比前第n筆低，若符合條件的值則為True，反之為False。
+        <img src="https://i.ibb.co/Y72bN5v/Screen-Shot-2021-10-26-at-6-43-41-AM.png" alt="Screen-Shot-2021-10-26-at-6-43-41-AM">
+        Args:
+          n (positive-int): 設定比較前第n筆低。
+        Returns:
+          (pd.DataFrame): data
+        Examples:
+            收盤價是否低於10日前股價
+            ```py
+            from finlab import data
+            data.get('price:收盤價').fall(10)
+            ```
+        """
+        return self < self.shift(n)
+
+    def groupby_category(self):
+        """資料按產業分群
+
+        類似 `pd.DataFrame.groupby()`的處理效果。
+        Returns:
+          (pd.DataFrame): data
+        Examples:
+          半導體平均股價淨值比時間序列
+            ```py
+            from finlab import data
+            pe = data.get('price_earning_ratio:股價淨值比')
+            pe.groupby_category().mean()['半導體'].plot()
+            ```
+            <img src="https://i.ibb.co/Tq2fKBp/pbmean.png" alt="pbmean">
+
+            全球 2020 量化寬鬆加上晶片短缺，使得半導體股價淨值比衝高。
+        """
+        from finlab import data
+        categories = data.get('security_categories')
+        cat = categories.set_index('stock_id').category.to_dict()
+        org_set = set(cat.values())
+        set_remove_illegal = set(
+            o for o in org_set if isinstance(o, str) and o != 'nan')
+        set_remove_illegal
+
+        refine_cat = {}
+        for s, c in cat.items():
+            if c == None or c == 'nan':
+                refine_cat[s] = '其他'
+                continue
+
+            if c == '電腦及週邊':
+                refine_cat[s] = '電腦及週邊設備業'
+                continue
+
+            if c[-1] == '業' and c[:-1] in set_remove_illegal:
+                refine_cat[s] = c[:-1]
+            else:
+                refine_cat[s] = c
+
+        col_categories = pd.Series(self.columns.map(
+            lambda s: refine_cat[s] if s in cat else '其他'))
+
+        return self.groupby(col_categories.values, axis=1)
+
+    def entry_price(self, trade_at='close'):
+
+        signal = self.is_entry()
+        from finlab import data
+        adj = data.get('etl:adj_close') if trade_at == 'close' else data.get(
+            'etl:adj_open')
+        adj, signal = adj.reshape(
+            adj.loc[signal.index[0]: signal.index[-1]], signal)
+        return adj.bfill()[signal.shift(fill_value=False)].ffill()
+
+    def sustain(self, nwindow, nsatisfy=None):
+        """持續 N 天滿足條件
+
+        取移動 nwindow 筆加總大於等於nsatisfy，若符合條件的值則為True，反之為False。
+
+        Args:
+          nwindow (positive-int): 設定移動窗格。
+          nsatisfy (positive-int): 設定移動窗格計算後最低滿足數值。
+        Returns:
+          (pd.DataFrame): data
+        Examples:
+            收盤價是否連兩日上漲
+            ```py
+            from finlab import data
+            data.get('price:收盤價').rise().sustain(2)
+            ```
+        """
+        nsatisfy = nsatisfy or nwindow
+        return self.rolling(nwindow).sum() >= nsatisfy
+
+    def industry_rank(self, categories=None):
+        """計算產業 ranking 排名，0 代表產業內最低，1 代表產業內最高
+        Args:
+          categories (list of str): 欲考慮的產業，ex: ['貿易百貨', '雲端運算']，預設為全產業，請參考 `data.get('security_industry_themes')` 中的產業項目。
+        Examples:
+            本意比產業排名分數
+            ```py
+            from finlab import data
+
+            pe = data.get('price_earning_ratio:本益比')
+            pe_rank = pe.industry_rank()
+            print(pe_rank)
+            ```
+        """
+        from finlab import data
+
+        themes = (data.get('security_industry_themes')
+                  .copy()  # 複製
+                  .assign(category=lambda self: self.category
+                          .apply(lambda s: eval(s)))  # 從文字格式轉成陣列格
+                  .explode('category')  # 展開資料
+                  )
+
+        categories = (categories
+                      or set(themes.category[themes.category.str.find(':') == -1]))
+
+        def calc_rank(ind):
+            stock_ids = themes.stock_id[themes.category == ind]
+            return (self[list(stock_ids)].pipe(lambda self: self.rank(axis=1, pct=True)))
+
+        return (pd.concat([calc_rank(ind) for ind in categories], axis=1)
+                .groupby(level=0, axis=1).mean())
+
+    def quantile_row(self, c):
+        """股票當天數值分位數
+
+        取得每列c定分位數的值。
+        Args:
+          c (positive-int): 設定每列 n 定分位數的值。
+        Returns:
+          (pd.DataFrame): data
+        Examples:
+            取每日股價前90％分位數
+            ```py
+            from finlab import data
+            data.get('price:收盤價').quantile_row(0.9)
+            ```
+        """
+        s = self.index_str_to_date().quantile(c, axis=1)
+        return s
+
+    def exit_when(self, exit):
+
+        df, exit = self.reshape(self, exit)
+
+        df.fillna(False, inplace=True)
+        exit.fillna(False, inplace=True)
+
+        entry_signal = df.is_entry()
+        exit_signal = df.is_exit()
+        exit_signal |= exit
+
+        # build position using entry_signal and exit_signal
+        position = pd.DataFrame(np.nan, index=df.index, columns=df.columns)
+        position[entry_signal] = 1
+        position[exit_signal] = 0
+
+        position.ffill(inplace=True)
+        position = position == 1
+        position.fillna(False)
+        return position
+
+    def hold_until(self, exit, nstocks_limit=None, stop_loss=-np.inf, take_profit=np.inf, trade_at='close', rank=None, market='AUTO'):
+        """訊號進出場
+
+        這大概是所有策略撰寫中，最重要的語法糖，上述語法中 `entries` 為進場訊號，而 `exits` 是出場訊號。所以 `entries.hold_until(exits)` ，就是進場訊號為 `True` 時，買入並持有該檔股票，直到出場訊號為 `True ` 則賣出。
+        <img src="https://i.ibb.co/PCt4hPd/Screen-Shot-2021-10-26-at-6-35-05-AM.png" alt="Screen-Shot-2021-10-26-at-6-35-05-AM">
+        此函式有很多細部設定，可以讓你最多選擇 N 檔股票做輪動。另外，當超過 N 檔進場訊號發生，也可以按照客制化的排序，選擇優先選入的股票。最後，可以設定價格波動當輪動訊號，來增加出場的時機點。
+
+        Args:
+          exit (pd.Dataframe): 出場訊號。
+          nstocks_limit (int)`: 輪動檔數上限，預設為None。
+          stop_loss (float): 價格波動輪動訊號，預設為None，不生成輪動訊號。範例：0.1，代表成本價下跌 10% 時產生出場訊號。
+          take_profit (float): 價格波動輪動訊號，預設為None，不生成輪動訊號。範例：0.1，代表成本價上漲 10% 時產生出場訊號。
+          trade_at (str): 價格波動輪動訊號參考價，預設為'close'。可選 `close` 或 `open`。
+          rank (pd.Dataframe): 當天進場訊號數量超過 nstocks_limit 時，以 rank 數值越大的股票優先進場。
+
+        Returns:
+          (pd.DataFrame): data
+
+        Examples:
+            價格 > 20 日均線入場, 價格 < 60 日均線出場，最多持有10檔，超過 10 個進場訊號，則以股價淨值比小的股票優先選入。
+            ```py
+            from finlab import data
+            from finlab.backtest import sim
+
+            close = data.get('price:收盤價')
+            pb = data.get('price_earning_ratio:股價淨值比')
+
+            sma20 = close.average(20)
+            sma60 = close.average(60)
+
+            entries = close > sma20
+            exits = close < sma60
+
+            #pb前10小的標的做輪動
+            position = entries.hold_until(exits, nstocks_limit=10, rank=-pb)
+            sim(position)
+            ```
+        """
+        if nstocks_limit is None:
+            nstocks_limit = len(self.columns)
+
+        self_reindex = self.index_str_to_date()
+        exit_reindex = exit.index_str_to_date()
+        rank_reindex = rank.index_str_to_date() if rank is not None else None
+
+        union_index = self_reindex.index.union(exit_reindex.index)
+        intersect_col = self_reindex.columns.intersection(exit_reindex.columns)
+
+        if stop_loss != -np.inf or take_profit != np.inf:
+            market = finlab.market_info.get_market_info(
+                self_reindex, user_market_info=market)
+
+            if not isinstance(market, finlab.market_info.MarketInfo):
+                raise Exception("It seems like the market has"
+                                "not been specified well when using the hold_until"
+                                " function. Please provide the appropriate"
+                                " market parameter to the hold_until function "
+                                "to ensure it can determine the correct market"
+                                " for the transaction.")
+
+            price = market.get_price(trade_at, adj=True)
+
+            union_index = union_index.union(
+                price.loc[union_index[0]: union_index[-1]].index)
+            intersect_col = intersect_col.intersection(price.columns)
+        else:
+            price = pd.DataFrame(index=union_index, columns=intersect_col)
+            price.index = pd.to_datetime(price.index)
+
+        if rank_reindex is not None:
+            union_index = union_index.union(rank_reindex.index)
+            intersect_col = intersect_col.intersection(rank_reindex.columns)
+
+        entry = self_reindex.reindex(union_index, method='ffill')[
+            intersect_col].ffill().fillna(False)
+
+        exit = exit_reindex.reindex(union_index, method='ffill')[
+            intersect_col].ffill().fillna(False)
+
+        if price is not None:
+            price = price.reindex(union_index, method='ffill')[intersect_col]
+
+        if rank_reindex is not None:
+            rank_reindex = rank_reindex.reindex(
+                union_index, method='ffill')[intersect_col]
+        else:
+            rank_reindex = pd.DataFrame(
+                1, index=union_index, columns=intersect_col)
+
+        rank_reindex = rank_reindex.replace([np.inf, -np.inf], np.nan)
+
+        max_rank = rank_reindex.max().max()
+        min_rank = rank_reindex.min().min()
+        rank_reindex = (rank_reindex - min_rank) / (max_rank - min_rank)
+        rank_reindex.fillna(0, inplace=True)
+
+        def rotate_stocks(ret, entry, exit, nstocks_limit, stop_loss=-np.inf, take_profit=np.inf, price=None, ranking=None):
+
+            nstocks = 0
+
+            ret[0][np.argsort(entry[0], kind='stable')[-nstocks_limit:]] = 1
+            ret[0][exit[0] == 1] = 0
+            ret[0][entry[0] == 0] = 0
+
+            entry_price = np.empty(entry.shape[1])
+            entry_price[:] = np.nan
+
+            for i in range(1, entry.shape[0]):
+
+                # regitser entry price
+                if stop_loss != -np.inf or take_profit != np.inf:
+                    is_entry = ((ret[i-2] == 0) if i >
+                                1 else (ret[i-1] == 1))
+
+                    is_waiting_for_entry = np.isnan(
+                        entry_price) & (ret[i-1] == 1)
+
+                    is_entry |= is_waiting_for_entry
+
+                    entry_price[is_entry == 1] = price[i][is_entry == 1]
+
+                    # check stop_loss and take_profit
+                    returns = price[i] / entry_price
+                    stop = (returns > 1 + abs(take_profit)
+                            ) | (returns < 1 - abs(stop_loss))
+                    exit[i] |= stop
+
+                # run signal
+                rank = (entry[i] * ranking[i] + ret[i-1] * 3)
+                rank[exit[i] == 1] = -1
+                rank[(entry[i] == 0) & (ret[i-1] == 0)] = -1
+
+                ret[i][np.argsort(rank)[-nstocks_limit:]] = 1
+                ret[i][rank == -1] = 0
+
+            return ret
+
+        ret = pd.DataFrame(0, index=entry.index, columns=entry.columns)
+        ret = rotate_stocks(ret.values,
+                            entry.astype(int).values,
+                            exit.astype(int).values,
+                            nstocks_limit,
+                            stop_loss,
+                            take_profit,
+                            price=price.values,
+                            ranking=rank_reindex.values)
+        return pd.DataFrame(ret, index=entry.index, columns=entry.columns).astype(bool)
```

## finlab/ffn_core.py

 * *Ordering differences only*

```diff
@@ -1,2361 +1,2361 @@
-# all credit goes to ffn package:
-# https://github.com/pmorissette/ffn
-
-import re
-import numpy as np
-import pandas as pd
-
-try:
-    import cPickle as pickle
-except ImportError:
-    import pickle
-
-
-def _memoize(func, *args, **kw):
-    # should we refresh the cache?
-    refresh = False
-    refresh_kw = func.mrefresh_keyword
-
-    # kw is not always set - check args
-    if refresh_kw in func.__code__.co_varnames:
-        if args[func.__code__.co_varnames.index(refresh_kw)]:
-            refresh = True
-
-    # check in kw if not already set above
-    if not refresh and refresh_kw in kw:
-        if kw[refresh_kw]:
-            refresh = True
-
-    key = pickle.dumps(args, 1) + pickle.dumps(kw, 1)
-
-    cache = func.mcache
-    if not refresh and key in cache:
-        return cache[key]
-    else:
-        cache[key] = result = func(*args, **kw)
-        return result
-
-
-def parse_arg(arg):
-    """
-    Parses arguments for convenience. Argument can be a
-    csv list ('a,b,c'), a string, a list, a tuple.
-    Returns a list.
-    """
-    # handle string input
-    if type(arg) == str:
-        arg = arg.strip()
-        # parse csv as tickers and create children
-        if "," in arg:
-            arg = arg.split(",")
-            arg = [x.strip() for x in arg]
-        # assume single string - create single item list
-        else:
-            arg = [arg]
-
-    return arg
-
-
-def clean_ticker(ticker):
-    """
-    Cleans a ticker for easier use throughout MoneyTree
-    Splits by space and only keeps first bit. Also removes
-    any characters that are not letters. Returns as lowercase.
-    >>> clean_ticker('^VIX')
-    'vix'
-    >>> clean_ticker('SPX Index')
-    'spx'
-    """
-    pattern = re.compile("[\\W_]+")
-    res = pattern.sub("", ticker.split(" ")[0])
-    return res.lower()
-
-
-def clean_tickers(tickers):
-    """
-    Maps clean_ticker over tickers.
-    """
-    return [clean_ticker(x) for x in tickers]
-
-
-def fmtp(number):
-    """
-    Formatting helper - percent
-    """
-    if np.isnan(number):
-        return "-"
-    return format(number, ".2%")
-
-
-def fmtpn(number):
-    """
-    Formatting helper - percent no % sign
-    """
-    if np.isnan(number):
-        return "-"
-    return format(number * 100, ".2f")
-
-
-def fmtn(number):
-    """
-    Formatting helper - float
-    """
-    if np.isnan(number):
-        return "-"
-    return format(number, ".2f")
-
-
-def get_freq_name(period):
-    period = period.upper()
-    periods = {
-        "B": "business day",
-        "C": "custom business day",
-        "D": "daily",
-        "W": "weekly",
-        "M": "monthly",
-        "BM": "business month end",
-        "CBM": "custom business month end",
-        "MS": "month start",
-        "BMS": "business month start",
-        "CBMS": "custom business month start",
-        "Q": "quarterly",
-        "BQ": "business quarter end",
-        "QS": "quarter start",
-        "BQS": "business quarter start",
-        "Y": "yearly",
-        "A": "yearly",
-        "BA": "business year end",
-        "AS": "year start",
-        "BAS": "business year start",
-        "H": "hourly",
-        "T": "minutely",
-        "S": "secondly",
-        "L": "milliseonds",
-        "U": "microseconds",
-    }
-
-    if period in periods:
-        return periods[period]
-    else:
-        return None
-
-
-def scale(val, src, dst):
-    """
-    Scale value from src range to dst range.
-    If value outside bounds, it is clipped and set to
-    the low or high bound of dst.
-    Ex:
-        scale(0, (0.0, 99.0), (-1.0, 1.0)) == -1.0
-        scale(-5, (0.0, 99.0), (-1.0, 1.0)) == -1.0
-    """
-    if val < src[0]:
-        return dst[0]
-    if val > src[1]:
-        return dst[1]
-
-    return ((val - src[0]) / (src[1] - src[0])) * (dst[1] - dst[0]) + dst[0]
-
-
-def as_percent(self, digits=2):
-    return as_format(self, ".%s%%" % digits)
-
-
-def as_format(item, format_str=".2f"):
-    """
-    Map a format string over a pandas object.
-    """
-    if isinstance(item, pd.Series):
-        return item.map(lambda x: format(x, format_str))
-    elif isinstance(item, pd.DataFrame):
-        return item.applymap(lambda x: format(x, format_str))
-import random
-
-import numpy as np
-import pandas as pd
-from pandas.core.base import PandasObject
-
-def tabulate(data, headers):
-    return pd.DataFrame(data, columns=headers)
-
-try:
-    import prettyplotlib  # NOQA
-except ImportError:
-    pass
-
-# avoid pyplot import failure in headless environment
-import os
-
-class PerformanceStats(object):
-    """
-    PerformanceStats is a convenience class used for the performance
-    evaluation of a price series. It contains various helper functions
-    to help with plotting and contains a large amount of descriptive
-    statistics.
-    Args:
-        * prices (Series): A price series.
-        * rf (float, Series): `Risk-free rate <https://www.investopedia.com/terms/r/risk-freerate.asp>`_ used in various calculation. Should be
-            expressed as a yearly (annualized) return if it is a float. Otherwise
-            rf should be a price series.
-    Attributes:
-        * name (str): Name, derived from price series name
-        * return_table (DataFrame): A table of monthly returns with
-            YTD figures as well.
-        * lookback_returns (Series): Returns for different
-            lookback periods (1m, 3m, 6m, ytd...)
-        * stats (Series): A series that contains all the stats
-    """
-
-    def __init__(self, prices, rf=0.0):
-        super(PerformanceStats, self).__init__()
-        self.prices = prices
-        self.name = self.prices.name
-        self._start = self.prices.index[0]
-        self._end = self.prices.index[-1]
-
-        self.rf = rf
-
-        self._update(self.prices)
-
-    def set_riskfree_rate(self, rf):
-
-        """
-        Set annual risk-free rate property and calculate properly annualized
-        monthly and daily rates. Then performance stats are recalculated.
-        Affects only this instance of the PerformanceStats.
-        Args:
-            * rf (float): Annual `risk-free rate <https://www.investopedia.com/terms/r/risk-freerate.asp>`_
-        """
-        self.rf = rf
-
-        # Note, that we recalculate everything.
-        self._update(self.prices)
-
-    def _update(self, obj):
-        # calc
-        self._calculate(obj)
-
-        # update derived structure
-        # return table as dataframe for easier manipulation
-        self.return_table = pd.DataFrame(self.return_table).T
-        # name columns
-        if len(self.return_table.columns) == 13:
-            self.return_table.columns = [
-                "Jan",
-                "Feb",
-                "Mar",
-                "Apr",
-                "May",
-                "Jun",
-                "Jul",
-                "Aug",
-                "Sep",
-                "Oct",
-                "Nov",
-                "Dec",
-                "YTD",
-            ]
-
-        self.lookback_returns = pd.Series(
-            [
-                self.mtd,
-                self.three_month,
-                self.six_month,
-                self.ytd,
-                self.one_year,
-                self.three_year,
-                self.five_year,
-                self.ten_year,
-                self.cagr,
-            ],
-            ["mtd", "3m", "6m", "ytd", "1y", "3y", "5y", "10y", "incep"],
-        )
-        self.lookback_returns.name = self.name
-
-        self.stats = self._create_stats_series()
-
-    def _calculate(self, obj):
-        # default values
-        self.daily_mean = np.nan
-        self.daily_vol = np.nan
-        self.daily_sharpe = np.nan
-        self.daily_sortino = np.nan
-        self.best_day = np.nan
-        self.worst_day = np.nan
-        self.total_return = np.nan
-        self.cagr = np.nan
-        self.incep = np.nan
-        self.drawdown = np.nan
-        self.max_drawdown = np.nan
-        self.drawdown_details = np.nan
-        self.daily_skew = np.nan
-        self.daily_kurt = np.nan
-        self.monthly_returns = np.nan
-        self.avg_drawdown = np.nan
-        self.avg_drawdown_days = np.nan
-        self.monthly_mean = np.nan
-        self.monthly_vol = np.nan
-        self.monthly_sharpe = np.nan
-        self.monthly_sortino = np.nan
-        self.best_month = np.nan
-        self.worst_month = np.nan
-        self.mtd = np.nan
-        self.three_month = np.nan
-        self.pos_month_perc = np.nan
-        self.avg_up_month = np.nan
-        self.avg_down_month = np.nan
-        self.monthly_skew = np.nan
-        self.monthly_kurt = np.nan
-        self.six_month = np.nan
-        self.yearly_returns = np.nan
-        self.ytd = np.nan
-        self.one_year = np.nan
-        self.yearly_mean = np.nan
-        self.yearly_vol = np.nan
-        self.yearly_sharpe = np.nan
-        self.yearly_sortino = np.nan
-        self.best_year = np.nan
-        self.worst_year = np.nan
-        self.three_year = np.nan
-        self.win_year_perc = np.nan
-        self.twelve_month_win_perc = np.nan
-        self.yearly_skew = np.nan
-        self.yearly_kurt = np.nan
-        self.five_year = np.nan
-        self.ten_year = np.nan
-        self.calmar = np.nan
-
-        self.return_table = {}
-        # end default values
-
-        if len(obj) == 0:
-            return
-
-        self.start = obj.index[0]
-        self.end = obj.index[-1]
-
-        # save daily prices for future use
-        self.daily_prices = obj.resample("D").last()
-        # resample('D') imputes na values for any day that didn't have a price
-        #  .dropna() removes the na values but also implies that the original
-        #  price series didn't have any na values
-        #  if months or years are missing then we will need .dropna() too
-        self.daily_prices = self.daily_prices.dropna()
-        # M = month end frequency
-        self.monthly_prices = obj.resample("M").last()  # .dropna()
-        # A == year end frequency
-        self.yearly_prices = obj.resample("A").last()  # .dropna()
-
-        # let's save some typing
-        dp = self.daily_prices
-        mp = self.monthly_prices
-        yp = self.yearly_prices
-
-        if len(dp) == 1:
-            return
-
-        self.mtd = calc_mtd(dp, mp)
-        self.ytd = calc_ytd(dp, yp)
-
-        # stats using daily data
-        self.returns = dp.to_returns()
-        self.log_returns = dp.to_log_returns()
-        r = self.returns
-
-        if len(r) < 2:
-            return
-
-        # Will calculate daily figures only if the input data has at least daily frequency or higher (e.g hourly)
-        # Rather < 2 days than <= 1 days in case of data taken at different hours of the days
-        if r.index.to_series().diff().min() < pd.Timedelta("2 days"):
-            self.daily_mean = r.mean() * 252
-            self.daily_vol = np.std(r, ddof=1) * np.sqrt(252)
-
-            # if type(self.rf) is float:
-            if isinstance(self.rf, float):
-                self.daily_sharpe = r.calc_sharpe(rf=self.rf, nperiods=252)
-                self.daily_sortino = calc_sortino_ratio(r, rf=self.rf, nperiods=252)
-            # rf is a price series
-            else:
-                _rf_daily_price_returns = self.rf.to_returns()
-                self.daily_sharpe = r.calc_sharpe(
-                    rf=_rf_daily_price_returns, nperiods=252
-                )
-                self.daily_sortino = calc_sortino_ratio(
-                    r, rf=_rf_daily_price_returns, nperiods=252
-                )
-
-            self.best_day = r.max()
-            self.worst_day = r.min()
-
-        self.total_return = obj.iloc[-1] / obj.iloc[0] - 1
-
-        self.cagr = calc_cagr(dp)
-        self.incep = self.cagr
-
-        self.drawdown = dp.to_drawdown_series()
-        self.max_drawdown = self.drawdown.min()
-        self.drawdown_details = drawdown_details(self.drawdown)
-        if self.drawdown_details is not None:
-            self.avg_drawdown = self.drawdown_details["drawdown"].mean()
-            self.avg_drawdown_days = self.drawdown_details["Length"].mean()
-
-        self.calmar = np.divide(self.cagr, np.abs(self.max_drawdown)+0.00001)
-
-        if len(r) < 4:
-            return
-
-        if r.index.to_series().diff().min() <= pd.Timedelta("2 days"):
-            self.daily_skew = r.skew()
-
-            # if all zero/nan kurt fails division by zero
-            if len(r[(~np.isnan(r)) & (r != 0)]) > 0:
-                self.daily_kurt = r.kurt()
-
-        # stats using monthly data
-        self.monthly_returns = self.monthly_prices.to_returns()
-        mr = self.monthly_returns
-
-        if len(mr) < 2:
-            return
-
-        # Will calculate monthly figures only if the input data has at least monthly frequency or higher (e.g daily)
-        # Rather < 32 days than <= 31 days in case of data taken at different hours of the days
-        if r.index.to_series().diff().min() < pd.Timedelta("32 days"):
-            self.monthly_mean = mr.mean() * 12
-            self.monthly_vol = np.std(mr, ddof=1) * np.sqrt(12)
-
-            if type(self.rf) is float:
-                self.monthly_sharpe = mr.calc_sharpe(rf=self.rf, nperiods=12)
-                self.monthly_sortino = calc_sortino_ratio(mr, rf=self.rf, nperiods=12)
-            # rf is a price series
-            else:
-                _rf_monthly_price_returns = self.rf.resample("M").last().to_returns()
-                self.monthly_sharpe = mr.calc_sharpe(
-                    rf=_rf_monthly_price_returns, nperiods=12
-                )
-                self.monthly_sortino = calc_sortino_ratio(
-                    mr, rf=_rf_monthly_price_returns, nperiods=12
-                )
-            self.best_month = mr.max()
-            self.worst_month = mr.min()
-
-            # -1 here to account for first return that will be nan
-            self.pos_month_perc = len(mr[mr > 0]) / float(len(mr) - 1)
-            self.avg_up_month = mr[mr > 0].mean()
-            self.avg_down_month = mr[mr <= 0].mean()
-
-            # return_table
-            for idx in mr.index:
-                if idx.year not in self.return_table:
-                    self.return_table[idx.year] = {
-                        1: 0,
-                        2: 0,
-                        3: 0,
-                        4: 0,
-                        5: 0,
-                        6: 0,
-                        7: 0,
-                        8: 0,
-                        9: 0,
-                        10: 0,
-                        11: 0,
-                        12: 0,
-                    }
-                if not np.isnan(mr[idx]):
-                    self.return_table[idx.year][idx.month] = mr[idx]
-            # add first month
-            fidx = mr.index[0]
-            try:
-                self.return_table[fidx.year][fidx.month] = float(mp.iloc[0]) / dp.iloc[0] - 1
-            except ZeroDivisionError:
-                self.return_table[fidx.year][fidx.month] = 0
-            # calculate the YTD values
-            for idx in self.return_table:
-                arr = np.array(list(self.return_table[idx].values()))
-                self.return_table[idx][13] = np.prod(arr + 1) - 1
-
-        if r.index.to_series().diff().min() < pd.Timedelta("93 days"):
-            if len(mr) < 3:
-                return
-
-            denom = dp[: dp.index[-1] - pd.DateOffset(months=3)]
-            if len(denom) > 0:
-                self.three_month = dp.iloc[-1] / denom.iloc[-1] - 1
-
-        if r.index.to_series().diff().min() < pd.Timedelta("32 days"):
-            if len(mr) < 4:
-                return
-
-            self.monthly_skew = mr.skew()
-
-            # if all zero/nan kurt fails division by zero
-            if len(mr[(~np.isnan(mr)) & (mr != 0)]) > 0:
-                self.monthly_kurt = mr.kurt()
-
-        if r.index.to_series().diff().min() < pd.Timedelta("185 days"):
-            if len(mr) < 6:
-                return
-
-            denom = dp[: dp.index[-1] - pd.DateOffset(months=6)]
-
-            if len(denom) > 0:
-                self.six_month = dp.iloc[-1] / denom.iloc[-1] - 1
-
-        # Will calculate yearly figures only if the input data has at least yearly frequency or higher (e.g monthly)
-        # Rather < 367 days than <= 366 days in case of data taken at different hours of the days
-        if r.index.to_series().diff().min() < pd.Timedelta("367 days"):
-            self.yearly_returns = self.yearly_prices.to_returns()
-            yr = self.yearly_returns
-
-            if len(yr) < 2:
-                return
-
-            denom = dp[: dp.index[-1] - pd.DateOffset(years=1)]
-
-            if len(denom) > 0:
-                self.one_year = dp.iloc[-1] / denom.iloc[-1] - 1
-
-            self.yearly_mean = yr.mean()
-            self.yearly_vol = np.std(yr, ddof=1)
-
-            # if type(self.rf) is float:
-            if isinstance(self.rf, float):
-                if self.yearly_vol > 0:
-                    self.yearly_sharpe = yr.calc_sharpe(rf=self.rf, nperiods=1)
-                self.yearly_sortino = calc_sortino_ratio(yr, rf=self.rf, nperiods=1)
-            # rf is a price series
-            else:
-                _rf_yearly_price_returns = self.rf.resample("A").last().to_returns()
-                if self.yearly_vol > 0:
-                    self.yearly_sharpe = yr.calc_sharpe(
-                        rf=_rf_yearly_price_returns, nperiods=1
-                    )
-                self.yearly_sortino = calc_sortino_ratio(
-                    yr, rf=_rf_yearly_price_returns, nperiods=1
-                )
-
-            self.best_year = yr.max()
-            self.worst_year = yr.min()
-
-            # -1 here to account for first return that will be nan
-            self.win_year_perc = len(yr[yr > 0]) / float(len(yr) - 1)
-
-            # need at least 1 year of monthly returns
-            if mr.size > 11:
-                tot = 0
-                win = 0
-                for i in range(11, len(mr)):
-                    tot += 1
-                    if mp.iloc[i] / mp.iloc[i - 11] > 1:
-                        win += 1
-                self.twelve_month_win_perc = float(win) / tot
-
-        if r.index.to_series().diff().min() < pd.Timedelta("1097 days"):
-            if len(yr) < 3:
-                return
-
-            # annualize stat for over 1 year
-            self.three_year = calc_cagr(dp[dp.index[-1] - pd.DateOffset(years=3) :])
-
-        if r.index.to_series().diff().min() < pd.Timedelta("367 days"):
-            if len(yr) < 4:
-                return
-
-            self.yearly_skew = yr.skew()
-
-            # if all zero/nan kurt fails division by zero
-            if len(yr[(~np.isnan(yr)) & (yr != 0)]) > 0:
-                self.yearly_kurt = yr.kurt()
-
-        if r.index.to_series().diff().min() < pd.Timedelta("1828 days"):
-            if len(yr) < 5:
-                return
-            self.five_year = calc_cagr(dp[dp.index[-1] - pd.DateOffset(years=5) :])
-
-        if r.index.to_series().diff().min() < pd.Timedelta("3654 days"):
-            if len(yr) < 10:
-                return
-            self.ten_year = calc_cagr(dp[dp.index[-1] - pd.DateOffset(years=10) :])
-
-        return
-
-    def _stats(self):
-        stats = [
-            ("start", "Start", "dt"),
-            ("end", "End", "dt"),
-            ("rf", "Risk-free rate", "p"),
-            (None, None, None),
-            ("total_return", "Total Return", "p"),
-            ("cagr", "CAGR", "p"),
-            ("max_drawdown", "Max Drawdown", "p"),
-            ("calmar", "Calmar Ratio", "n"),
-            (None, None, None),
-            ("mtd", "MTD", "p"),
-            ("three_month", "3m", "p"),
-            ("six_month", "6m", "p"),
-            ("ytd", "YTD", "p"),
-            ("one_year", "1Y", "p"),
-            ("three_year", "3Y (ann.)", "p"),
-            ("five_year", "5Y (ann.)", "p"),
-            ("ten_year", "10Y (ann.)", "p"),
-            ("incep", "Since Incep. (ann.)", "p"),
-            (None, None, None),
-            ("daily_sharpe", "Daily Sharpe", "n"),
-            ("daily_sortino", "Daily Sortino", "n"),
-            ("daily_mean", "Daily Mean (ann.)", "p"),
-            ("daily_vol", "Daily Vol (ann.)", "p"),
-            ("daily_skew", "Daily Skew", "n"),
-            ("daily_kurt", "Daily Kurt", "n"),
-            ("best_day", "Best Day", "p"),
-            ("worst_day", "Worst Day", "p"),
-            (None, None, None),
-            ("monthly_sharpe", "Monthly Sharpe", "n"),
-            ("monthly_sortino", "Monthly Sortino", "n"),
-            ("monthly_mean", "Monthly Mean (ann.)", "p"),
-            ("monthly_vol", "Monthly Vol (ann.)", "p"),
-            ("monthly_skew", "Monthly Skew", "n"),
-            ("monthly_kurt", "Monthly Kurt", "n"),
-            ("best_month", "Best Month", "p"),
-            ("worst_month", "Worst Month", "p"),
-            (None, None, None),
-            ("yearly_sharpe", "Yearly Sharpe", "n"),
-            ("yearly_sortino", "Yearly Sortino", "n"),
-            ("yearly_mean", "Yearly Mean", "p"),
-            ("yearly_vol", "Yearly Vol", "p"),
-            ("yearly_skew", "Yearly Skew", "n"),
-            ("yearly_kurt", "Yearly Kurt", "n"),
-            ("best_year", "Best Year", "p"),
-            ("worst_year", "Worst Year", "p"),
-            (None, None, None),
-            ("avg_drawdown", "Avg. Drawdown", "p"),
-            ("avg_drawdown_days", "Avg. Drawdown Days", "n"),
-            ("avg_up_month", "Avg. Up Month", "p"),
-            ("avg_down_month", "Avg. Down Month", "p"),
-            ("win_year_perc", "Win Year %", "p"),
-            ("twelve_month_win_perc", "Win 12m %", "p"),
-        ]
-
-        return stats
-
-    def set_date_range(self, start=None, end=None):
-        """
-        Update date range of stats, charts, etc. If None then
-        the original date is used. So to reset to the original
-        range, just call with no args.
-        Args:
-            * start (date): start date
-            * end (end): end date
-        """
-        start = self._start if start is None else pd.to_datetime(start)
-        end = self._end if end is None else pd.to_datetime(end)
-        self._update(self.prices.loc[start:end])
-
-    def display(self):
-        """
-        Displays an overview containing descriptive stats for the Series
-        provided.
-        """
-        print("Stats for %s from %s - %s" % (self.name, self.start, self.end))
-        if type(self.rf) is float:
-            print("Annual risk-free rate considered: %s" % (fmtp(self.rf)))
-        print("Summary:")
-        data = [
-            [
-                fmtp(self.total_return),
-                fmtn(self.daily_sharpe),
-                fmtp(self.cagr),
-                fmtp(self.max_drawdown),
-            ]
-        ]
-        print(
-            tabulate(data, headers=["Total Return", "Sharpe", "CAGR", "Max Drawdown"])
-        )
-
-        print("\nAnnualized Returns:")
-        data = [
-            [
-                fmtp(self.mtd),
-                fmtp(self.three_month),
-                fmtp(self.six_month),
-                fmtp(self.ytd),
-                fmtp(self.one_year),
-                fmtp(self.three_year),
-                fmtp(self.five_year),
-                fmtp(self.ten_year),
-                fmtp(self.incep),
-            ]
-        ]
-        print(
-            tabulate(
-                data,
-                headers=["mtd", "3m", "6m", "ytd", "1y", "3y", "5y", "10y", "incep."],
-            )
-        )
-
-        print("\nPeriodic:")
-        data = [
-            [
-                "sharpe",
-                fmtn(self.daily_sharpe),
-                fmtn(self.monthly_sharpe),
-                fmtn(self.yearly_sharpe),
-            ],
-            [
-                "mean",
-                fmtp(self.daily_mean),
-                fmtp(self.monthly_mean),
-                fmtp(self.yearly_mean),
-            ],
-            [
-                "vol",
-                fmtp(self.daily_vol),
-                fmtp(self.monthly_vol),
-                fmtp(self.yearly_vol),
-            ],
-            [
-                "skew",
-                fmtn(self.daily_skew),
-                fmtn(self.monthly_skew),
-                fmtn(self.yearly_skew),
-            ],
-            [
-                "kurt",
-                fmtn(self.daily_kurt),
-                fmtn(self.monthly_kurt),
-                fmtn(self.yearly_kurt),
-            ],
-            ["best", fmtp(self.best_day), fmtp(self.best_month), fmtp(self.best_year)],
-            [
-                "worst",
-                fmtp(self.worst_day),
-                fmtp(self.worst_month),
-                fmtp(self.worst_year),
-            ],
-        ]
-        print(tabulate(data, headers=["index", "daily", "monthly", "yearly"]))
-
-        print("\nDrawdowns:")
-        data = [
-            [
-                fmtp(self.max_drawdown),
-                fmtp(self.avg_drawdown),
-                fmtn(self.avg_drawdown_days),
-            ]
-        ]
-        print(tabulate(data, headers=["max", "avg", "# days"]))
-
-        print("\nMisc:")
-        data = [
-            ["avg. up month", fmtp(self.avg_up_month)],
-            ["avg. down month", fmtp(self.avg_down_month)],
-            ["up year %", fmtp(self.win_year_perc)],
-            ["12m up %", fmtp(self.twelve_month_win_perc)],
-        ]
-        print(tabulate(data, headers=["name", "value"]))
-
-    def display_monthly_returns(self):
-        """
-        Display a table containing monthly returns and ytd returns
-        for every year in range.
-        """
-        data = [
-            [
-                "Year",
-                "Jan",
-                "Feb",
-                "Mar",
-                "Apr",
-                "May",
-                "Jun",
-                "Jul",
-                "Aug",
-                "Sep",
-                "Oct",
-                "Nov",
-                "Dec",
-                "YTD",
-            ]
-        ]
-        for k in self.return_table.index:
-            r = self.return_table.loc[k].values
-            data.append([k] + [fmtpn(x) for x in r])
-        print(tabulate(data, headers="firstrow"))
-
-    def display_lookback_returns(self):
-        """
-        Displays the current lookback returns.
-        """
-        return self.lookback_returns.map("{:,.2%}".format)
-
-    def _get_default_plot_title(self, name, freq, kind):
-        if freq is None:
-            return "%s %s" % (name, kind)
-        else:
-            return "%s %s %s" % (name, get_freq_name(freq), kind)
-
-    def plot(self, freq=None, figsize=(15, 5), title=None, logy=False, **kwargs):
-        """
-        Helper function for plotting the series.
-        Args:
-            * freq (str): Data frequency used for display purposes.
-                Refer to pandas docs for valid freq strings.
-            * figsize ((x,y)): figure size
-            * title (str): Title if default not appropriate
-            * logy (bool): log-scale for y axis
-            * kwargs: passed to pandas' plot method
-        """
-        if title is None:
-            title = self._get_default_plot_title(self.name, freq, "Price Series")
-
-        ser = self._get_series(freq)
-        return ser.plot(figsize=figsize, title=title, logy=logy, **kwargs)
-
-    def plot_histogram(self, freq=None, figsize=(15, 5), title=None, bins=20, **kwargs):
-        """
-        Plots a histogram of returns given a return frequency.
-        Args:
-            * freq (str): Data frequency used for display purposes.
-                This will dictate the type of returns
-                (daily returns, monthly, ...)
-                Refer to pandas docs for valid period strings.
-            * figsize ((x,y)): figure size
-            * title (str): Title if default not appropriate
-            * bins (int): number of bins for the histogram
-            * kwargs: passed to pandas' hist method
-        """
-        if title is None:
-            title = self._get_default_plot_title(self.name, freq, "Return Histogram")
-
-        ser = self._get_series(freq).to_returns().dropna()
-
-        plt.figure(figsize=figsize)
-
-        if matplotlib.__version__ > "2.":
-            # normed deprecated
-            ax = ser.hist(bins=bins, figsize=figsize, density=True, **kwargs)
-        else:
-            ax = ser.hist(bins=bins, figsize=figsize, normed=True, **kwargs)
-
-        ax.set_title(title)
-        plt.axvline(0, linewidth=4)
-        return ser.plot(kind="kde")
-
-    def _get_series(self, freq):
-        if freq is None:
-            return self.daily_prices
-
-        if freq == "y":
-            freq = "a"
-        return self.daily_prices.asfreq(freq, "ffill")
-
-    def _create_stats_series(self):
-        stats = self._stats()
-
-        short_names = []
-        values = []
-
-        for stat in stats:
-            k, n, f = stat
-
-            # blank row
-            if k is None:
-                continue
-            elif k == "rf" and not type(self.rf) == float:
-                continue
-
-            if n in short_names:
-                continue
-
-            short_names.append(k)
-            raw = getattr(self, k)
-            values.append(raw)
-        return pd.Series(values, short_names)
-
-    def to_csv(self, sep=",", path=None):
-        """
-        Returns a CSV string with appropriate formatting.
-        If path is not None, the string will be saved to file
-        at path.
-        Args:
-            * sep (char): Separator
-            * path (str): If None, CSV string returned. Else file written
-                to specified path.
-        """
-        stats = self._stats()
-
-        data = []
-        first_row = ["Stat", self.name]
-        data.append(sep.join(first_row))
-
-        for stat in stats:
-            k, n, f = stat
-
-            # blank row
-            if k is None:
-                row = [""] * len(data[0])
-                data.append(sep.join(row))
-                continue
-            elif k == "rf" and not type(self.rf) == float:
-                continue
-
-            row = [n]
-            raw = getattr(self, k)
-            if f is None:
-                row.append(raw)
-            elif f == "p":
-                row.append(fmtp(raw))
-            elif f == "n":
-                row.append(fmtn(raw))
-            elif f == "dt":
-                row.append(raw.strftime("%Y-%m-%d"))
-            else:
-                raise NotImplementedError("unsupported format %s" % f)
-
-            data.append(sep.join(row))
-
-        res = "\n".join(data)
-
-        if path is not None:
-            with open(path, "w") as fl:
-                fl.write(res)
-        else:
-            return res
-
-
-class GroupStats(dict):
-    """
-    GroupStats enables one to compare multiple series side by side.
-    It is a wrapper around a dict of {price.name: PerformanceStats} and
-    provides many convenience methods.
-    The order of the series passed in will be preserved.
-    Individual PerformanceStats objects can be accessed via index
-    position or name via the [] accessor.
-    Args:
-        * prices (Series): Multiple price series to be compared.
-    Attributes:
-        * stats (DataFrame): Dataframe containing stats for each
-            series provided.  Stats in rows, series in columns.
-        * lookback_returns (DataFrame): Returns for diffrent
-            lookback periods (1m, 3m, 6m, ytd...)
-            Period in rows, series in columns.
-        * prices (DataFrame): The merged and rebased prices.
-    """
-
-    def __init__(self, *prices):
-        names = []
-        for p in prices:
-            if isinstance(p, pd.DataFrame):
-                names.extend(p.columns)
-            elif isinstance(p, pd.Series):
-                names.append(p.name)
-            else:
-                print("else")
-                names.append(getattr(p, "name", "n/a"))
-        self._names = names
-
-        # store original prices
-        self._prices = merge(*prices).dropna()
-
-        # proper ordering
-        self._prices = self._prices[self._names]
-
-        # check for duplicate columns
-        if len(self._prices.columns) != len(set(self._prices.columns)):
-            raise ValueError(
-                "One or more data series provided",
-                "have same name! Please provide unique names",
-            )
-
-        self._start = self._prices.index[0]
-        self._end = self._prices.index[-1]
-        # calculate stats for entire series
-        self._update(self._prices)
-
-    def __getitem__(self, key):
-        if isinstance(key, int):
-            # if type(key) == int:
-            return self[self._names[key]]
-        else:
-            return self.get(key)
-
-    def _update(self, data):
-        self._calculate(data)
-        self._update_stats()
-
-    def _calculate(self, data):
-        self.prices = data
-        for c in data.columns:
-            prc = data[c]
-            self[c] = PerformanceStats(prc)
-
-    def _stats(self):
-        stats = [
-            ("start", "Start", "dt"),
-            ("end", "End", "dt"),
-            ("rf", "Risk-free rate", "p"),
-            (None, None, None),
-            ("total_return", "Total Return", "p"),
-            ("daily_sharpe", "Daily Sharpe", "n"),
-            ("daily_sortino", "Daily Sortino", "n"),
-            ("cagr", "CAGR", "p"),
-            ("max_drawdown", "Max Drawdown", "p"),
-            ("calmar", "Calmar Ratio", "n"),
-            (None, None, None),
-            ("mtd", "MTD", "p"),
-            ("three_month", "3m", "p"),
-            ("six_month", "6m", "p"),
-            ("ytd", "YTD", "p"),
-            ("one_year", "1Y", "p"),
-            ("three_year", "3Y (ann.)", "p"),
-            ("five_year", "5Y (ann.)", "p"),
-            ("ten_year", "10Y (ann.)", "p"),
-            ("incep", "Since Incep. (ann.)", "p"),
-            (None, None, None),
-            ("daily_sharpe", "Daily Sharpe", "n"),
-            ("daily_sortino", "Daily Sortino", "n"),
-            ("daily_mean", "Daily Mean (ann.)", "p"),
-            ("daily_vol", "Daily Vol (ann.)", "p"),
-            ("daily_skew", "Daily Skew", "n"),
-            ("daily_kurt", "Daily Kurt", "n"),
-            ("best_day", "Best Day", "p"),
-            ("worst_day", "Worst Day", "p"),
-            (None, None, None),
-            ("monthly_sharpe", "Monthly Sharpe", "n"),
-            ("monthly_sortino", "Monthly Sortino", "n"),
-            ("monthly_mean", "Monthly Mean (ann.)", "p"),
-            ("monthly_vol", "Monthly Vol (ann.)", "p"),
-            ("monthly_skew", "Monthly Skew", "n"),
-            ("monthly_kurt", "Monthly Kurt", "n"),
-            ("best_month", "Best Month", "p"),
-            ("worst_month", "Worst Month", "p"),
-            (None, None, None),
-            ("yearly_sharpe", "Yearly Sharpe", "n"),
-            ("yearly_sortino", "Yearly Sortino", "n"),
-            ("yearly_mean", "Yearly Mean", "p"),
-            ("yearly_vol", "Yearly Vol", "p"),
-            ("yearly_skew", "Yearly Skew", "n"),
-            ("yearly_kurt", "Yearly Kurt", "n"),
-            ("best_year", "Best Year", "p"),
-            ("worst_year", "Worst Year", "p"),
-            (None, None, None),
-            ("avg_drawdown", "Avg. Drawdown", "p"),
-            ("avg_drawdown_days", "Avg. Drawdown Days", "n"),
-            ("avg_up_month", "Avg. Up Month", "p"),
-            ("avg_down_month", "Avg. Down Month", "p"),
-            ("win_year_perc", "Win Year %", "p"),
-            ("twelve_month_win_perc", "Win 12m %", "p"),
-        ]
-
-        return stats
-
-    def _update_stats(self):
-        # lookback returns dataframe
-        self.lookback_returns = pd.DataFrame(
-            {x.lookback_returns.name: x.lookback_returns for x in self.values()}
-        )
-
-        self.stats = pd.DataFrame({x.name: x.stats for x in self.values()})
-
-    def _get_default_plot_title(self, freq, kind):
-        if freq is None:
-            return "%s" % kind
-        else:
-            return "%s %s" % (get_freq_name(freq), kind)
-
-    def set_riskfree_rate(self, rf):
-
-        """
-        Set annual `risk-free rate <https://www.investopedia.com/terms/r/risk-freerate.asp>`_ property and calculate properly annualized
-        monthly and daily rates. Then performance stats are recalculated.
-        Affects only those instances of PerformanceStats that are children of
-        this GroupStats object.
-        Args:
-            * rf (float, Series): Annual risk-free rate or risk-free rate price series
-        """
-
-        for key in self._names:
-            self[key].set_riskfree_rate(rf)
-
-        # calculate stats for entire series
-        self._update_stats()
-
-    def set_date_range(self, start=None, end=None):
-        """
-        Update date range of stats, charts, etc. If None then
-        the original date range is used. So to reset to the original
-        range, just call with no args.
-        Args:
-            * start (date): start date
-            * end (end): end date
-        """
-        start = self._start if start is None else pd.to_datetime(start)
-        end = self._end if end is None else pd.to_datetime(end)
-        self._update(self._prices.loc[start:end])
-
-    def display(self):
-        """
-        Display summary stats table.
-        """
-        data = []
-        first_row = ["Stat"]
-        first_row.extend(self._names)
-        data.append(first_row)
-
-        stats = self._stats()
-
-        for stat in stats:
-            k, n, f = stat
-            # blank row
-            if k is None:
-                row = [""] * len(data[0])
-                data.append(row)
-                continue
-
-            row = [n]
-            for key in self._names:
-                raw = getattr(self[key], k)
-
-                # if rf is a series print nan
-                if k == "rf" and not type(raw) == float:
-                    row.append(np.nan)
-                elif f is None:
-                    row.append(raw)
-                elif f == "p":
-                    row.append(fmtp(raw))
-                elif f == "n":
-                    row.append(fmtn(raw))
-                elif f == "dt":
-                    row.append(raw.strftime("%Y-%m-%d"))
-                else:
-                    raise NotImplementedError("unsupported format %s" % f)
-            data.append(row)
-
-        print(tabulate(data, headers="firstrow"))
-
-    def display_lookback_returns(self):
-        """
-        Displays the current lookback returns for each series.
-        """
-        return self.lookback_returns.apply(lambda x: x.map("{:,.2%}".format), axis=1)
-
-    def plot(self, freq=None, figsize=(15, 5), title=None, logy=False, **kwargs):
-        """
-        Helper function for plotting the series.
-        Args:
-            * freq (str): Data frequency used for display purposes.
-                Refer to pandas docs for valid freq strings.
-            * figsize ((x,y)): figure size
-            * title (str): Title if default not appropriate
-            * logy (bool): log-scale for y axis
-            * kwargs: passed to pandas' plot method
-        """
-
-        if title is None:
-            title = self._get_default_plot_title(freq, "Equity Progression")
-
-        ser = self._get_series(freq).rebase()
-        return ser.plot(figsize=figsize, logy=logy, title=title, **kwargs)
-
-    def plot_scatter_matrix(self, freq=None, title=None, figsize=(10, 10), **kwargs):
-        """
-        Wrapper around pandas' scatter_matrix.
-        Args:
-            * freq (str): Data frequency used for display purposes.
-                Refer to pandas docs for valid freq strings.
-            * figsize ((x,y)): figure size
-            * title (str): Title if default not appropriate
-            * kwargs: passed to pandas' scatter_matrix method
-        """
-        if title is None:
-            title = self._get_default_plot_title(freq, "Return Scatter Matrix")
-
-        plt.figure()
-        ser = self._get_series(freq).to_returns().dropna()
-        if hasattr(pd, "scatter_matrix"):
-            pd.scatter_matrix(ser, figsize=figsize, **kwargs)
-        else:
-            pd.plotting.scatter_matrix(ser, figsize=figsize, **kwargs)
-        return plt.suptitle(title)
-
-    def plot_histograms(self, freq=None, title=None, figsize=(10, 10), **kwargs):
-        """
-        Wrapper around pandas' hist.
-        Args:
-            * freq (str): Data frequency used for display purposes.
-                Refer to pandas docs for valid freq strings.
-            * figsize ((x,y)): figure size
-            * title (str): Title if default not appropriate
-            * kwargs: passed to pandas' hist method
-        """
-        if title is None:
-            title = self._get_default_plot_title(freq, "Return Histogram Matrix")
-
-        plt.figure()
-        ser = self._get_series(freq).to_returns().dropna()
-        ser.hist(figsize=figsize, **kwargs)
-        return plt.suptitle(title)
-
-    def plot_correlation(self, freq=None, title=None, figsize=(12, 6), **kwargs):
-        """
-        Utility function to plot correlations.
-        Args:
-            * freq (str): Pandas data frequency alias string
-            * title (str): Plot title
-            * figsize (tuple (x,y)): figure size
-            * kwargs: passed to Pandas' plot_corr_heatmap function
-        """
-        if title is None:
-            title = self._get_default_plot_title(freq, "Return Correlation Matrix")
-
-        rets = self._get_series(freq).to_returns().dropna()
-        return rets.plot_corr_heatmap(title=title, figsize=figsize, **kwargs)
-
-    def _get_series(self, freq):
-        if freq is None:
-            return self.prices
-
-        if freq == "y":
-            freq = "a"
-        return self.prices.asfreq(freq, "ffill")
-
-    def to_csv(self, sep=",", path=None):
-        """
-        Returns a CSV string with appropriate formatting.
-        If path is not None, the string will be saved to file
-        at path.
-        Args:
-            * sep (char): Separator
-            * path (str): If None, CSV string returned. Else file
-                written to specified path.
-        """
-        data = []
-        first_row = ["Stat"]
-        first_row.extend(self._names)
-        data.append(sep.join(first_row))
-
-        stats = self._stats()
-
-        for stat in stats:
-            k, n, f = stat
-            # blank row
-            if k is None:
-                row = [""] * len(data[0])
-                data.append(sep.join(row))
-                continue
-
-            row = [n]
-            for key in self._names:
-                raw = getattr(self[key], k)
-                if f is None:
-                    row.append(raw)
-                elif f == "p":
-                    row.append(fmtp(raw))
-                elif f == "n":
-                    row.append(fmtn(raw))
-                elif f == "dt":
-                    row.append(raw.strftime("%Y-%m-%d"))
-                else:
-                    raise NotImplementedError("unsupported format %s" % f)
-            data.append(sep.join(row))
-
-        res = "\n".join(data)
-
-        if path is not None:
-            with open(path, "w") as fl:
-                fl.write(res)
-        else:
-            return res
-
-
-def to_returns(prices):
-    """
-    Calculates the simple arithmetic returns of a price series.
-    Formula is: (t1 / t0) - 1
-    Args:
-        * prices: Expects a price series
-    """
-    return prices / prices.shift(1) - 1
-
-
-def to_log_returns(prices):
-    """
-    Calculates the log returns of a price series.
-    Formula is: ln(p1/p0)
-    Args:
-        * prices: Expects a price series
-    """
-    return np.log(prices / prices.shift(1))
-
-
-def to_price_index(returns, start=100):
-    """
-    Returns a price index given a series of returns.
-    Args:
-        * returns: Expects a return series
-        * start (number): Starting level
-    Assumes arithmetic returns.
-    Formula is: cumprod (1+r)
-    """
-    return (returns.replace(to_replace=np.nan, value=0) + 1).cumprod() * start
-
-
-def rebase(prices, value=100):
-    """
-    Rebase all series to a given intial value.
-    This makes comparing/plotting different series
-    together easier.
-    Args:
-        * prices: Expects a price series
-        * value (number): starting value for all series.
-    """
-    if isinstance(prices, pd.DataFrame):
-        return prices.div(prices.iloc[0], axis=1) * value
-    return prices / prices.iloc[0] * value
-
-
-def calc_perf_stats(prices):
-    """
-    Calculates the performance statistics given an object.
-    The object should be a Series of prices.
-    A PerformanceStats object will be returned containing all the stats.
-    Args:
-        * prices (Series): Series of prices
-    """
-    return PerformanceStats(prices)
-
-
-def calc_stats(prices):
-    """
-    Calculates performance stats of a given object.
-    If object is Series, a PerformanceStats object is
-    returned. If object is DataFrame, a GroupStats object
-    is returned.
-    Args:
-        * prices (Series, DataFrame): Set of prices
-    """
-    if isinstance(prices, pd.Series):
-        return PerformanceStats(prices)
-    elif isinstance(prices, pd.DataFrame):
-        return GroupStats(*[prices[x] for x in prices.columns])
-    else:
-        raise NotImplementedError("Unsupported type")
-
-
-def to_drawdown_series(prices):
-    """
-    Calculates the `drawdown <https://www.investopedia.com/terms/d/drawdown.asp>`_ series.
-    This returns a series representing a drawdown.
-    When the price is at all time highs, the drawdown
-    is 0. However, when prices are below high water marks,
-    the drawdown series = current / hwm - 1
-    The max drawdown can be obtained by simply calling .min()
-    on the result (since the drawdown series is negative)
-    Method ignores all gaps of NaN's in the price series.
-    Args:
-        * prices (Series or DataFrame): Series of prices.
-    """
-    # make a copy so that we don't modify original data
-    drawdown = prices.copy()
-
-    # Fill NaN's with previous values
-    drawdown = drawdown.ffill()
-
-    # Ignore problems with NaN's in the beginning
-    drawdown[np.isnan(drawdown)] = -np.Inf
-
-    # Rolling maximum
-    if isinstance(drawdown, pd.DataFrame):
-        roll_max = pd.DataFrame()
-        for col in drawdown:
-            roll_max[col] = np.maximum.accumulate(drawdown[col])
-    else:
-        roll_max = np.maximum.accumulate(drawdown)
-
-    drawdown = drawdown / roll_max - 1.0
-    return drawdown
-
-
-def calc_mtd(daily_prices, monthly_prices):
-    """
-    Calculates mtd return of a price series.
-    Use daily_prices if prices are only available from same month
-    else use monthly_prices
-    """
-    if len(monthly_prices) == 1:
-        return daily_prices.iloc[-1] / daily_prices.iloc[0] - 1
-    else:
-        return daily_prices.iloc[-1] / monthly_prices.iloc[-2] - 1
-
-
-def calc_ytd(daily_prices, yearly_prices):
-    """
-    Calculates ytd return of a price series.
-    Use daily_prices if prices are only available from same year
-    else use yearly_prices
-    """
-    if len(yearly_prices) == 1:
-        return daily_prices.iloc[-1] / daily_prices.iloc[0] - 1
-    else:
-        return daily_prices.iloc[-1] / yearly_prices.iloc[-2] - 1
-
-
-def calc_max_drawdown(prices):
-    """
-    Calculates the max drawdown of a price series. If you want the
-    actual drawdown series, please use to_drawdown_series.
-    """
-    return (prices / prices.expanding(min_periods=1).max()).min() - 1
-
-
-def drawdown_details(drawdown, index_type=pd.DatetimeIndex):
-    """
-    Returns a data frame with start, end, days (duration) and
-    drawdown for each drawdown in a drawdown series.
-    .. note::
-        days are actual calendar days, not trading days
-    Args:
-        * drawdown (pandas.Series): A drawdown Series
-            (can be obtained w/ drawdown(prices).
-    Returns:
-        * pandas.DataFrame -- A data frame with the following
-            columns: start, end, days, drawdown.
-    """
-
-    is_zero = drawdown == 0
-    # find start dates (first day where dd is non-zero after a zero)
-    start = ~is_zero & is_zero.shift(1)
-    start = list(start[start == True].index)  # NOQA
-
-    # find end dates (first day where dd is 0 after non-zero)
-    end = is_zero & (~is_zero).shift(1)
-    end = list(end[end == True].index)  # NOQA
-
-    if len(start) == 0:  # start.empty
-        return None
-
-    # drawdown has no end (end period in dd)
-    if len(end) == 0:  # end.empty
-        end.append(drawdown.index[-1])
-
-    # if the first drawdown start is larger than the first drawdown end it
-    # means the drawdown series begins in a drawdown and therefore we must add
-    # the first index to the start series
-    if start[0] > end[0]:
-        start.insert(0, drawdown.index[0])
-
-    # if the last start is greater than the end then we must add the last index
-    # to the end series since the drawdown series must finish with a drawdown
-    if start[-1] > end[-1]:
-        end.append(drawdown.index[-1])
-
-    result = pd.DataFrame(
-        columns=("Start", "End", "Length", "drawdown"), index=range(0, len(start))
-    )
-
-    for i in range(0, len(start)):
-        dd = drawdown[start[i] : end[i]].min()
-
-        if index_type is pd.DatetimeIndex:
-            result.iloc[i] = (start[i], end[i], (end[i] - start[i]).days, dd)
-        else:
-            result.iloc[i] = (start[i], end[i], (end[i] - start[i]), dd)
-
-    return result
-
-
-def calc_cagr(prices):
-    """
-    Calculates the `CAGR (compound annual growth rate) <https://www.investopedia.com/terms/c/cagr.asp>`_ for a given price series.
-    Args:
-        * prices (pandas.Series): A Series of prices.
-    Returns:
-        * float -- cagr.
-    """
-    start = prices.index[0]
-    end = prices.index[-1]
-    return (prices.iloc[-1] / prices.iloc[0]) ** (1 / year_frac(start, end)) - 1
-
-
-def calc_risk_return_ratio(returns):
-    """
-    Calculates the return / risk ratio. Basically the
-    `Sharpe ratio <https://www.investopedia.com/terms/s/sharperatio.asp>`_ without factoring in the `risk-free rate <https://www.investopedia.com/terms/r/risk-freerate.asp>`_.
-    """
-    return calc_sharpe(returns)
-
-
-def calc_sharpe(returns, rf=0.0, nperiods=None, annualize=True):
-    """
-    Calculates the `Sharpe ratio <https://www.investopedia.com/terms/s/sharperatio.asp>`_
-    (see `Sharpe vs. Sortino <https://www.investopedia.com/ask/answers/010815/what-difference-between-sharpe-ratio-and-sortino-ratio.asp>`_).
-    If rf is non-zero and a float, you must specify nperiods. In this case, rf is assumed
-    to be expressed in yearly (annualized) terms.
-    Args:
-        * returns (Series, DataFrame): Input return series
-        * rf (float, Series): `Risk-free rate <https://www.investopedia.com/terms/r/risk-freerate.asp>`_ expressed as a yearly (annualized) return or return series
-        * nperiods (int): Frequency of returns (252 for daily, 12 for monthly,
-            etc.)
-    """
-    # if type(rf) is float and rf != 0 and nperiods is None:
-    if isinstance(rf, float) and rf != 0 and nperiods is None:
-        raise Exception("Must provide nperiods if rf != 0")
-
-    er = returns.to_excess_returns(rf, nperiods=nperiods)
-    std = np.std(er, ddof=1)
-    res = np.divide(er.mean(), max(std, 0.000001))
-
-    if annualize:
-        if nperiods is None:
-            nperiods = 1
-        return res * np.sqrt(nperiods)
-    else:
-        return res
-
-
-def calc_information_ratio(returns, benchmark_returns):
-    """
-    Calculates the `Information ratio <https://www.investopedia.com/terms/i/informationratio.asp>`_ (or `from Wikipedia <http://en.wikipedia.org/wiki/Information_ratio>`_).
-    """
-    diff_rets = returns - benchmark_returns
-    diff_std = np.std(diff_rets, ddof=1)
-
-    if np.isnan(diff_std) or diff_std == 0:
-        return 0.0
-
-    return np.divide(diff_rets.mean(), diff_std)
-
-
-def calc_prob_mom(returns, other_returns):
-    """
-    `Probabilistic momentum <http://cssanalytics.wordpress.com/2014/01/28/are-simple-momentum-strategies-too-dumb-introducing-probabilistic-momentum/>`_ (see `momentum investing <https://www.investopedia.com/terms/m/momentum_investing.asp>`_)
-    Basically the "probability or confidence that one asset
-    is going to outperform the other".
-    Source:
-        http://cssanalytics.wordpress.com/2014/01/28/are-simple-momentum-strategies-too-dumb-introducing-probabilistic-momentum/ # NOQA
-    """
-    return t.cdf(returns.calc_information_ratio(other_returns), len(returns) - 1)
-
-
-def calc_total_return(prices):
-    """
-    Calculates the total return of a series.
-    last / first - 1
-    """
-    return (prices.iloc[-1] / prices.iloc[0]) - 1
-
-
-def year_frac(start, end):
-    """
-    Similar to excel's yearfrac function. Returns
-    a year fraction between two dates (i.e. 1.53 years).
-    Approximation using the average number of seconds
-    in a year.
-    Args:
-        * start (datetime): start date
-        * end (datetime): end date
-    """
-    if start > end:
-        raise ValueError("start cannot be larger than end")
-
-    # obviously not perfect but good enough
-    return (end - start).total_seconds() / (31557600)
-
-
-def merge(*series):
-    """
-    Merge Series and/or DataFrames together.
-    Returns a DataFrame.
-    """
-    dfs = []
-    for s in series:
-        if isinstance(s, pd.DataFrame):
-            dfs.append(s)
-        elif isinstance(s, pd.Series):
-            tmpdf = pd.DataFrame({s.name: s})
-            dfs.append(tmpdf)
-        else:
-            raise NotImplementedError("Unsupported merge type")
-
-    return pd.concat(dfs, axis=1)
-
-
-def drop_duplicate_cols(df):
-    """
-    Removes duplicate columns from a dataframe
-    and keeps column w/ longest history
-    """
-    names = set(df.columns)
-    for n in names:
-        if len(df[n].shape) > 1:
-            # get subset of df w/ colname n
-            sub = df[n]
-            # make unique colnames
-            sub.columns = ["%s-%s" % (n, x) for x in range(sub.shape[1])]
-            # get colname w/ max # of data
-            keep = sub.count().idxmax()
-            # drop all columns of name n from original df
-            del df[n]
-            # update original df w/ longest col with name n
-            df[n] = sub[keep]
-
-    return df
-
-
-def to_monthly(series, method="ffill", how="end"):
-    """
-    Convenience method that wraps asfreq_actual
-    with 'M' param (method='ffill', how='end').
-    """
-    return series.asfreq_actual("M", method=method, how=how)
-
-
-def asfreq_actual(series, freq, method="ffill", how="end", normalize=False):
-    """
-    Similar to pandas' asfreq but keeps the actual dates.
-    For example, if last data point in Jan is on the 29th,
-    that date will be used instead of the 31st.
-    """
-    orig = series
-    is_series = False
-    if isinstance(series, pd.Series):
-        is_series = True
-        name = series.name if series.name else "data"
-        orig = pd.DataFrame({name: series})
-
-    # add date column
-    t = pd.concat(
-        [orig, pd.DataFrame({"dt": orig.index.values}, index=orig.index.values)], axis=1
-    )
-    # fetch dates
-    dts = t.asfreq(freq=freq, method=method, how=how, normalize=normalize)["dt"]
-
-    res = orig.loc[dts.values]
-
-    if is_series:
-        return res[name]
-    else:
-        return res
-
-
-def calc_inv_vol_weights(returns):
-    """
-    Calculates weights proportional to inverse volatility of each column.
-    Returns weights that are inversely proportional to the column's
-    volatility resulting in a set of portfolio weights where each position
-    has the same level of volatility.
-    Note, that assets with returns all equal to NaN or 0 are excluded from
-    the portfolio (their weight is set to NaN).
-    Returns:
-        Series {col_name: weight}
-    """
-    # calc vols
-    vol = np.divide(1.0, np.std(returns, ddof=1))
-    vol[np.isinf(vol)] = np.NaN
-    volsum = vol.sum()
-    return np.divide(vol, volsum)
-
-
-def _erc_weights_slsqp(x0, cov, b, maximum_iterations, tolerance):
-    """
-    Calculates the equal risk contribution / risk parity weights given
-        a DataFrame of returns.
-    Args:
-    * x0 (np.array): Starting asset weights.
-    * cov (np.array): covariance matrix.
-    * b (np.array): Risk target weights. By definition target total risk contributions are all equal which makes this redundant.
-    * maximum_iterations (int): Maximum iterations in iterative solutions.
-    * tolerance (float): Tolerance level in iterative solutions.
-    Returns:
-    np.array {weight}
-    You can read more about ERC at
-    http://thierry-roncalli.com/download/erc.pdf
-    """
-
-    def fitness(weights, covar):
-        # total risk contributions
-        # trc = weights*np.matmul(covar,weights)/np.sqrt(np.matmul(weights.T,np.matmul(covar,weights)))
-
-        # instead of using the true definition for trc we will use the optimization on page 5
-        trc = weights * np.matmul(covar, weights)
-
-        n = len(trc)
-        # sum of squared differences of total risk contributions
-        sse = 0.0
-        for i in range(n):
-            for j in range(n):
-                # switched from squared deviations to absolute deviations to avoid numerical instability
-                sse += np.abs(trc[i] - trc[j])
-        # minimizes metric
-        return sse
-
-    # nonnegative
-    bounds = [(0, None) for i in range(len(x0))]
-    # sum of weights must be equal to 1
-    constraints = {"type": "eq", "fun": lambda W: sum(W) - 1.0}
-    options = {"maxiter": maximum_iterations}
-
-    optimized = minimize(
-        fitness,
-        x0,
-        (cov),
-        method="SLSQP",
-        constraints=constraints,
-        bounds=bounds,
-        options=options,
-        tol=tolerance,
-    )
-    # check if success
-    if not optimized.success:
-        raise Exception(optimized.message)
-
-    # return weight vector
-    return optimized.x
-
-
-def _erc_weights_ccd(x0, cov, b, maximum_iterations, tolerance):
-    """
-    Calculates the equal risk contribution / risk parity weights given
-    a DataFrame of returns.
-    Args:
-        * x0 (np.array): Starting asset weights.
-        * cov (np.array): covariance matrix.
-        * b (np.array): Risk target weights.
-        * maximum_iterations (int): Maximum iterations in iterative solutions.
-        * tolerance (float): Tolerance level in iterative solutions.
-    Returns:
-        np.array {weight}
-    Reference:
-        Griveau-Billion, Theophile and Richard, Jean-Charles and Roncalli,
-        Thierry, A Fast Algorithm for Computing High-Dimensional Risk Parity
-        Portfolios (2013).
-        Available at SSRN: https://ssrn.com/abstract=2325255
-    """
-    n = len(x0)
-    x = x0.copy()
-    var = np.diagonal(cov)
-    ctr = cov.dot(x)
-    sigma_x = np.sqrt(x.T.dot(ctr))
-
-    for iteration in range(maximum_iterations):
-
-        for i in range(n):
-            alpha = var[i]
-            beta = ctr[i] - x[i] * alpha
-            gamma = -b[i] * sigma_x
-
-            x_tilde = (-beta + np.sqrt(beta * beta - 4 * alpha * gamma)) / (2 * alpha)
-            x_i = x[i]
-
-            ctr = ctr - cov[i] * x_i + cov[i] * x_tilde
-            sigma_x = sigma_x * sigma_x - 2 * x_i * cov[i].dot(x) + x_i * x_i * var[i]
-            x[i] = x_tilde
-            sigma_x = np.sqrt(
-                sigma_x + 2 * x_tilde * cov[i].dot(x) - x_tilde * x_tilde * var[i]
-            )
-
-        # check convergence
-        if np.power((x - x0) / x.sum(), 2).sum() < tolerance:
-            return x / x.sum()
-
-        x0 = x.copy()
-
-    # no solution found
-    raise ValueError(
-        "No solution found after {0} iterations.".format(maximum_iterations)
-    )
-
-
-def calc_erc_weights(
-    returns,
-    initial_weights=None,
-    risk_weights=None,
-    covar_method="ledoit-wolf",
-    risk_parity_method="ccd",
-    maximum_iterations=100,
-    tolerance=1e-8,
-):
-    """
-    Calculates the equal risk contribution / risk parity weights given a
-    DataFrame of returns.
-    Args:
-        * returns (DataFrame): Returns for multiple securities.
-        * initial_weights (list): Starting asset weights [default inverse vol].
-        * risk_weights (list): Risk target weights [default equal weight].
-        * covar_method (str): Covariance matrix estimation method.
-            Currently supported:
-                - `ledoit-wolf <http://www.ledoit.net/honey.pdf>`_ [default]
-                - standard
-        * risk_parity_method (str): Risk parity estimation method.
-            Currently supported:
-                - ccd (cyclical coordinate descent)[default]
-                - slsqp (scipy's implementation of sequential least squares programming)
-        * maximum_iterations (int): Maximum iterations in iterative solutions.
-        * tolerance (float): Tolerance level in iterative solutions.
-    Returns:
-        Series {col_name: weight}
-    """
-    n = len(returns.columns)
-
-    # calc covariance matrix
-    if covar_method == "ledoit-wolf":
-        covar = sklearn.covariance.ledoit_wolf(returns)[0]
-    elif covar_method == "standard":
-        covar = returns.cov().values
-    else:
-        raise NotImplementedError("covar_method not implemented")
-
-    # initial weights (default to inverse vol)
-    if initial_weights is None:
-        inv_vol = 1.0 / np.sqrt(np.diagonal(covar))
-        initial_weights = inv_vol / inv_vol.sum()
-
-    # default to equal risk weight
-    if risk_weights is None:
-        risk_weights = np.ones(n) / n
-
-    # calc risk parity weights matrix
-    if risk_parity_method == "ccd":
-        # cyclical coordinate descent implementation
-        erc_weights = _erc_weights_ccd(
-            initial_weights, covar, risk_weights, maximum_iterations, tolerance
-        )
-    elif risk_parity_method == "slsqp":
-        # scipys slsqp optimizer
-        erc_weights = _erc_weights_slsqp(
-            initial_weights, covar, risk_weights, maximum_iterations, tolerance
-        )
-
-    else:
-        raise NotImplementedError("risk_parity_method not implemented")
-
-    # return erc weights vector
-    return pd.Series(erc_weights, index=returns.columns, name="erc")
-
-
-def get_num_days_required(offset, period="d", perc_required=0.90):
-    """
-    Estimates the number of days required to assume that data is OK.
-    Helper function used to determine if there are enough "good" data
-    days over a given period.
-    Args:
-        * offset (DateOffset): Offset (lookback) period.
-        * period (str): Period string.
-        * perc_required (float): percentage of number of days
-            expected required.
-    """
-    x = pd.to_datetime("2010-01-01")
-    delta = x - (x - offset)
-    # convert to 'trading days' - rough guestimate
-    days = delta.days * 0.69
-
-    if period == "d":
-        req = days * perc_required
-    elif period == "m":
-        req = (days / 20) * perc_required
-    elif period == "y":
-        req = (days / 252) * perc_required
-    else:
-        raise NotImplementedError("period not supported. Supported periods are d, m, y")
-
-    return req
-
-
-
-def calc_ftca(returns, threshold=0.5):
-    """
-    Implementation of David Varadi's `Fast Threshold Clustering Algorithm (FTCA) <http://cssanalytics.wordpress.com/2013/11/26/fast-threshold-clustering-algorithm-ftca/>`_.
-    http://cssanalytics.wordpress.com/2013/11/26/fast-threshold-clustering-algorithm-ftca/  # NOQA
-    More stable than k-means for clustering purposes.
-    If you want more clusters, use a higher threshold.
-    Args:
-        * returns - expects a pandas dataframe of returns where
-            each column is the name of a given security.
-        * threshold (float): Threshold parameter - use higher value
-            for more clusters. Basically controls how similar
-            (correlated) series have to be.
-    Returns:
-        dict of cluster name (a number) and list of securities in cluster
-    """
-    # cluster index (name)
-    i = 0
-    # correlation matrix
-    corr = returns.corr()
-    # remaining securities to cluster
-    remain = list(corr.index.copy())
-    n = len(remain)
-    res = {}
-
-    while n > 0:
-        # if only one left then create cluster and finish
-        if n == 1:
-            i += 1
-            res[i] = remain
-            n = 0
-        # if not then we have some work to do
-        else:
-            # filter down correlation matrix to current remain
-            cur_corr = corr[remain].loc[remain]
-            # get mean correlations, ordered
-            mc = cur_corr.mean().sort_values()
-            # get lowest and highest mean correlation
-            low = mc.index[0]
-            high = mc.index[-1]
-
-            # case if corr(high,low) > threshold
-            if corr[high][low] > threshold:
-                i += 1
-
-                # new cluster for high and low
-                res[i] = [low, high]
-                remain.remove(low)
-                remain.remove(high)
-
-                rmv = []
-                for x in remain:
-                    avg_corr = (corr[x][high] + corr[x][low]) / 2.0
-                    if avg_corr > threshold:
-                        res[i].append(x)
-                        rmv.append(x)
-                [remain.remove(x) for x in rmv]
-
-                n = len(remain)
-
-            # otherwise we are creating two clusters - one for high
-            # and one for low
-            else:
-                # add cluster with HC
-                i += 1
-                res[i] = [high]
-                remain.remove(high)
-                remain.remove(low)
-
-                rmv = []
-                for x in remain:
-                    if corr[x][high] > threshold:
-                        res[i].append(x)
-                        rmv.append(x)
-                [remain.remove(x) for x in rmv]
-
-                i += 1
-                res[i] = [low]
-
-                rmv = []
-                for x in remain:
-                    if corr[x][low] > threshold:
-                        res[i].append(x)
-                        rmv.append(x)
-                [remain.remove(x) for x in rmv]
-
-                n = len(remain)
-
-    return res
-
-
-def limit_weights(weights, limit=0.1):
-    """
-    Limits weights and redistributes excedent amount
-    proportionally.
-    ex:
-        - weights are {a: 0.7, b: 0.2, c: 0.1}
-        - call with limit=0.5
-        - excess 0.2 in a is ditributed to b and c
-            proportionally.
-            - result is {a: 0.5, b: 0.33, c: 0.167}
-    Args:
-        * weights (Series): A series describing the weights
-        * limit (float): Maximum weight allowed
-    """
-    if 1.0 / limit > len(weights):
-        raise ValueError("invalid limit -> 1 / limit must be <= len(weights)")
-
-    if isinstance(weights, dict):
-        weights = pd.Series(weights)
-
-    if np.round(weights.sum(), 1) != 1.0:
-        raise ValueError(
-            "Expecting weights (that sum to 1) - sum is %s" % weights.sum()
-        )
-
-    res = np.round(weights.copy(), 4)
-    to_rebalance = (res[res > limit] - limit).sum()
-
-    ok = res[res < limit]
-    ok += (ok / ok.sum()) * to_rebalance
-
-    res[res > limit] = limit
-    res[res < limit] = ok
-
-    if any(x > limit for x in res):
-        return limit_weights(res, limit=limit)
-
-    return res
-
-
-def random_weights(n, bounds=(0.0, 1.0), total=1.0):
-    """
-    Generate pseudo-random weights.
-    Returns a list of random weights that is of length
-    n, where each weight is in the range bounds, and
-    where the weights sum up to total.
-    Useful for creating random portfolios when benchmarking.
-    Args:
-        * n (int): number of random weights
-        * bounds ((low, high)): bounds for each weight
-        * total (float): total sum of the weights
-    """
-    low = bounds[0]
-    high = bounds[1]
-
-    if high < low:
-        raise ValueError("Higher bound must be greater or " "equal to lower bound")
-
-    if n * high < total or n * low > total:
-        raise ValueError("solution not possible with given n and bounds")
-
-    w = [0] * n
-    tgt = -float(total)
-
-    for i in range(n):
-        rn = n - i - 1
-        rhigh = rn * high
-        rlow = rn * low
-
-        lowb = max(-rhigh - tgt, low)
-        highb = min(-rlow - tgt, high)
-
-        rw = random.uniform(lowb, highb)
-        w[i] = rw
-
-        tgt += rw
-
-    random.shuffle(w)
-    return w
-
-
-def plot_heatmap(
-    data,
-    title="Heatmap",
-    show_legend=True,
-    show_labels=True,
-    label_fmt=".2f",
-    vmin=None,
-    vmax=None,
-    figsize=None,
-    label_color="w",
-    cmap="RdBu",
-    **kwargs
-):
-    """
-    Plot a heatmap using matplotlib's pcolor.
-    Args:
-        * data (DataFrame): DataFrame to plot. Usually small matrix (ex.
-            correlation matrix).
-        * title (string): Plot title
-        * show_legend (bool): Show color legend
-        * show_labels (bool): Show value labels
-        * label_fmt (str): Label format string
-        * vmin (float): Min value for scale
-        * vmax (float): Max value for scale
-        * cmap (string): Color map
-        * kwargs: Passed to matplotlib's pcolor
-    """
-    fig, ax = plt.subplots(figsize=figsize)
-
-    heatmap = ax.pcolor(data, vmin=vmin, vmax=vmax, cmap=cmap)
-    # for some reason heatmap has the y values backwards....
-    ax.invert_yaxis()
-
-    if title is not None:
-        plt.title(title)
-
-    if show_legend:
-        fig.colorbar(heatmap)
-
-    if show_labels:
-        vals = data.values
-        for x in range(data.shape[0]):
-            for y in range(data.shape[1]):
-                plt.text(
-                    x + 0.5,
-                    y + 0.5,
-                    format(vals[y, x], label_fmt),
-                    horizontalalignment="center",
-                    verticalalignment="center",
-                    color=label_color,
-                )
-
-    plt.yticks(np.arange(0.5, len(data.index), 1), data.index)
-    plt.xticks(np.arange(0.5, len(data.columns), 1), data.columns)
-
-    return plt
-
-
-def plot_corr_heatmap(data, **kwargs):
-    """
-    Plots the correlation heatmap for a given DataFrame.
-    """
-    return plot_heatmap(data.corr(), vmin=-1, vmax=1, **kwargs)
-
-
-def rollapply(data, window, fn):
-    """
-    Apply a function fn over a rolling window of size window.
-    Args:
-        * data (Series or DataFrame): Series or DataFrame
-        * window (int): Window size
-        * fn (function): Function to apply over the rolling window.
-            For a series, the return value is expected to be a single
-            number. For a DataFrame, it shuold return a new row.
-    Returns:
-        * Object of same dimensions as data
-    """
-    res = data.copy()
-    res[:] = np.nan
-    n = len(data)
-
-    if window > n:
-        return res
-
-    for i in range(window - 1, n):
-        res.iloc[i] = fn(data.iloc[i - window + 1 : i + 1])
-
-    return res
-
-
-def _winsorize_wrapper(x, limits):
-    """
-    Wraps scipy winsorize function to drop na's
-    """
-    if isinstance(x, pd.Series):
-        if x.count() == 0:
-            return x
-
-        notnanx = ~np.isnan(x)
-        x[notnanx] = scipy.stats.mstats.winsorize(x[notnanx], limits=limits)
-        return x
-    else:
-        return scipy.stats.mstats.winsorize(x, limits=limits)
-
-
-def winsorize(x, axis=0, limits=0.01):
-    """
-    `Winsorize <https://en.wikipedia.org/wiki/Winsorizing>`_ values based on limits
-    """
-    # operate on copy
-    x = x.copy()
-
-    if isinstance(x, pd.DataFrame):
-        return x.apply(_winsorize_wrapper, axis=axis, args=(limits,))
-    else:
-        return pd.Series(_winsorize_wrapper(x, limits).values, index=x.index)
-
-
-def rescale(x, min=0.0, max=1.0, axis=0):
-    """
-    Rescale values to fit a certain range [min, max]
-    """
-
-    def innerfn(x, min, max):
-        return np.interp(x, [np.min(x), np.max(x)], [min, max])
-
-    if isinstance(x, pd.DataFrame):
-        return x.apply(
-            innerfn,
-            axis=axis,
-            args=(
-                min,
-                max,
-            ),
-        )
-    else:
-        return pd.Series(innerfn(x, min, max), index=x.index)
-
-
-def annualize(returns, durations, one_year=365.0):
-    """
-    Annualize returns using their respective durations.
-    Formula used is:
-        (1 + returns) ** (1 / (durations / one_year)) - 1
-    """
-    return np.power(1.0 + returns, 1.0 / (durations / one_year)) - 1.0
-
-
-def deannualize(returns, nperiods):
-    """
-    Convert return expressed in annual terms on a different basis.
-    Args:
-        * returns (float, Series, DataFrame): Return(s)
-        * nperiods (int): Target basis, typically 252 for daily, 12 for
-            monthly, etc.
-    """
-    return np.power(1 + returns, 1.0 / nperiods) - 1.0
-
-
-def calc_sortino_ratio(returns, rf=0.0, nperiods=None, annualize=True):
-    """
-    Calculates the `Sortino ratio <https://www.investopedia.com/terms/s/sortinoratio.asp>`_ given a series of returns
-    (see `Sharpe vs. Sortino <https://www.investopedia.com/ask/answers/010815/what-difference-between-sharpe-ratio-and-sortino-ratio.asp>`_).
-    Args:
-        * returns (Series or DataFrame): Returns
-        * rf (float, Series): `Risk-free rate <https://www.investopedia.com/terms/r/risk-freerate.asp>`_ expressed in yearly (annualized) terms or return series.
-        * nperiods (int): Number of periods used for annualization. Must be
-            provided if rf is non-zero and rf is not a price series
-    """
-    # if type(rf) is float and rf != 0 and nperiods is None:
-    if isinstance(rf, float) and rf != 0 and nperiods is None:
-        raise Exception("nperiods must be set if rf != 0 and rf is not a price series")
-
-    er = returns.to_excess_returns(rf, nperiods=nperiods)
-
-    negative_returns = np.minimum(er[1:], 0.0)
-    std = np.std(negative_returns, ddof=1)
-    if std != 0:
-        res = np.divide(er.mean(), std)
-    else:
-        res = np.nan
-
-    if annualize:
-        if nperiods is None:
-            nperiods = 1
-        return res * np.sqrt(nperiods)
-
-    return res
-
-
-def to_excess_returns(returns, rf, nperiods=None):
-    """
-    Given a series of returns, it will return the excess returns over rf.
-    Args:
-        * returns (Series, DataFrame): Returns
-        * rf (float, Series): `Risk-Free rate(s) <https://www.investopedia.com/terms/r/risk-freerate.asp>`_ expressed in annualized term or return series
-        * nperiods (int): Optional. If provided, will convert rf to different
-            frequency using deannualize only if rf is a float
-    Returns:
-        * excess_returns (Series, DataFrame): Returns - rf
-    """
-    # if type(rf) is float and nperiods is not None:
-    if isinstance(rf, float) and nperiods is not None:
-
-        _rf = deannualize(rf, nperiods)
-    else:
-        _rf = rf
-
-    return returns - _rf
-
-
-def calc_calmar_ratio(prices):
-    """
-    Calculates the `Calmar ratio <https://www.investopedia.com/terms/c/calmarratio.asp>`_ given a series of prices
-    Args:
-        * prices (Series, DataFrame): Price series
-    """
-    return np.divide(prices.calc_cagr(), abs(prices.calc_max_drawdown()))
-
-
-def to_ulcer_index(prices):
-    """
-    Converts from prices -> `Ulcer index <https://www.investopedia.com/terms/u/ulcerindex.asp>`_
-    See https://en.wikipedia.org/wiki/Ulcer_index
-    Args:
-        * prices (Series, DataFrame): Prices
-    """
-    dd = prices.to_drawdown_series()
-    return np.divide(np.sqrt(np.sum(np.power(dd, 2))), dd.count())
-
-
-def to_ulcer_performance_index(prices, rf=0.0, nperiods=None):
-    """
-    Converts from prices -> `ulcer performance index <https://www.investopedia.com/terms/u/ulcerindex.asp>`_.
-    See https://en.wikipedia.org/wiki/Ulcer_index
-    Args:
-        * prices (Series, DataFrame): Prices
-        * rf (float, Series): `Risk-free rate of return <https://www.investopedia.com/terms/r/risk-freerate.asp>`_. Assumed to be expressed in
-            yearly (annualized) terms or return series
-        * nperiods (int): Used to deannualize rf if rf is provided (non-zero)
-    """
-    # if type(rf) is float and rf != 0 and nperiods is None:
-    if isinstance(rf, float) and rf != 0 and nperiods is None:
-        raise Exception("nperiods must be set if rf != 0 and rf is not a price series")
-
-    er = prices.to_returns().to_excess_returns(rf, nperiods=nperiods)
-
-    return np.divide(er.mean(), prices.to_ulcer_index())
-
-
-def resample_returns(returns, func, seed=0, num_trials=100):
-    """
-    Resample the returns and calculate any statistic on every new sample.
-    https://en.wikipedia.org/wiki/Resampling_(statistics)
-    :param returns (Series, DataFrame): Returns
-    :param func: Given the resampled returns calculate a statistic
-    :param seed: Seed for random number generator
-    :param num_trials: Number of times to resample and run the experiment
-    :return: Series of resampled statistics
-    """
-
-    # stats = []
-    if type(returns) is pd.Series:
-        stats = pd.Series(index=range(num_trials))
-    elif type(returns) is pd.DataFrame:
-        stats = pd.DataFrame(index=range(num_trials), columns=returns.columns)
-    else:
-        raise (TypeError("returns needs to be a Series or DataFrame!"))
-
-    n = returns.shape[0]
-    for i in range(num_trials):
-        random_indices = resample(returns.index, n_samples=n, random_state=seed + i)
-        stats.loc[i] = func(returns.loc[random_indices])
-
-    return stats
-
-
-def extend_pandas():
-    """
-    Extends pandas' PandasObject (Series, Series,
-    DataFrame) with some functions defined in this file.
-    This facilitates common functional composition used in quant
-    finance.
-    Ex:
-        prices.to_returns().dropna().calc_clusters()
-        (where prices would be a DataFrame)
-    """
-    PandasObject.to_returns = to_returns
-    PandasObject.to_log_returns = to_log_returns
-    PandasObject.to_price_index = to_price_index
-    PandasObject.rebase = rebase
-    PandasObject.calc_perf_stats = calc_perf_stats
-    PandasObject.to_drawdown_series = to_drawdown_series
-    PandasObject.calc_max_drawdown = calc_max_drawdown
-    PandasObject.calc_cagr = calc_cagr
-    PandasObject.calc_total_return = calc_total_return
-    PandasObject.as_percent = as_percent
-    PandasObject.as_format = as_format
-    PandasObject.to_monthly = to_monthly
-    PandasObject.asfreq_actual = asfreq_actual
-    PandasObject.drop_duplicate_cols = drop_duplicate_cols
-    PandasObject.calc_information = calc_information_ratio
-    PandasObject.calc_information_ratio = calc_information_ratio
-    PandasObject.calc_prob_mom = calc_prob_mom
-    PandasObject.calc_risk_return = calc_risk_return_ratio
-    PandasObject.calc_risk_return_ratio = calc_risk_return_ratio
-    PandasObject.calc_erc_weights = calc_erc_weights
-    PandasObject.calc_inv_vol_weights = calc_inv_vol_weights
-    PandasObject.calc_ftca = calc_ftca
-    PandasObject.calc_stats = calc_stats
-    PandasObject.plot_heatmap = plot_heatmap
-    PandasObject.plot_corr_heatmap = plot_corr_heatmap
-    PandasObject.rollapply = rollapply
-    PandasObject.winsorize = winsorize
-    PandasObject.rescale = rescale
-    PandasObject.calc_sortino = calc_sortino_ratio
-    PandasObject.calc_sortino_ratio = calc_sortino_ratio
-    PandasObject.calc_calmar = calc_calmar_ratio
-    PandasObject.calc_calmar_ratio = calc_calmar_ratio
-    PandasObject.calc_sharpe = calc_sharpe
-    PandasObject.calc_sharpe_ratio = calc_sharpe
-    PandasObject.to_excess_returns = to_excess_returns
-    PandasObject.to_ulcer_index = to_ulcer_index
-    PandasObject.to_ulcer_performance_index = to_ulcer_performance_index
-
-extend_pandas()
+# all credit goes to ffn package:
+# https://github.com/pmorissette/ffn
+
+import re
+import numpy as np
+import pandas as pd
+
+try:
+    import cPickle as pickle
+except ImportError:
+    import pickle
+
+
+def _memoize(func, *args, **kw):
+    # should we refresh the cache?
+    refresh = False
+    refresh_kw = func.mrefresh_keyword
+
+    # kw is not always set - check args
+    if refresh_kw in func.__code__.co_varnames:
+        if args[func.__code__.co_varnames.index(refresh_kw)]:
+            refresh = True
+
+    # check in kw if not already set above
+    if not refresh and refresh_kw in kw:
+        if kw[refresh_kw]:
+            refresh = True
+
+    key = pickle.dumps(args, 1) + pickle.dumps(kw, 1)
+
+    cache = func.mcache
+    if not refresh and key in cache:
+        return cache[key]
+    else:
+        cache[key] = result = func(*args, **kw)
+        return result
+
+
+def parse_arg(arg):
+    """
+    Parses arguments for convenience. Argument can be a
+    csv list ('a,b,c'), a string, a list, a tuple.
+    Returns a list.
+    """
+    # handle string input
+    if type(arg) == str:
+        arg = arg.strip()
+        # parse csv as tickers and create children
+        if "," in arg:
+            arg = arg.split(",")
+            arg = [x.strip() for x in arg]
+        # assume single string - create single item list
+        else:
+            arg = [arg]
+
+    return arg
+
+
+def clean_ticker(ticker):
+    """
+    Cleans a ticker for easier use throughout MoneyTree
+    Splits by space and only keeps first bit. Also removes
+    any characters that are not letters. Returns as lowercase.
+    >>> clean_ticker('^VIX')
+    'vix'
+    >>> clean_ticker('SPX Index')
+    'spx'
+    """
+    pattern = re.compile("[\\W_]+")
+    res = pattern.sub("", ticker.split(" ")[0])
+    return res.lower()
+
+
+def clean_tickers(tickers):
+    """
+    Maps clean_ticker over tickers.
+    """
+    return [clean_ticker(x) for x in tickers]
+
+
+def fmtp(number):
+    """
+    Formatting helper - percent
+    """
+    if np.isnan(number):
+        return "-"
+    return format(number, ".2%")
+
+
+def fmtpn(number):
+    """
+    Formatting helper - percent no % sign
+    """
+    if np.isnan(number):
+        return "-"
+    return format(number * 100, ".2f")
+
+
+def fmtn(number):
+    """
+    Formatting helper - float
+    """
+    if np.isnan(number):
+        return "-"
+    return format(number, ".2f")
+
+
+def get_freq_name(period):
+    period = period.upper()
+    periods = {
+        "B": "business day",
+        "C": "custom business day",
+        "D": "daily",
+        "W": "weekly",
+        "M": "monthly",
+        "BM": "business month end",
+        "CBM": "custom business month end",
+        "MS": "month start",
+        "BMS": "business month start",
+        "CBMS": "custom business month start",
+        "Q": "quarterly",
+        "BQ": "business quarter end",
+        "QS": "quarter start",
+        "BQS": "business quarter start",
+        "Y": "yearly",
+        "A": "yearly",
+        "BA": "business year end",
+        "AS": "year start",
+        "BAS": "business year start",
+        "H": "hourly",
+        "T": "minutely",
+        "S": "secondly",
+        "L": "milliseonds",
+        "U": "microseconds",
+    }
+
+    if period in periods:
+        return periods[period]
+    else:
+        return None
+
+
+def scale(val, src, dst):
+    """
+    Scale value from src range to dst range.
+    If value outside bounds, it is clipped and set to
+    the low or high bound of dst.
+    Ex:
+        scale(0, (0.0, 99.0), (-1.0, 1.0)) == -1.0
+        scale(-5, (0.0, 99.0), (-1.0, 1.0)) == -1.0
+    """
+    if val < src[0]:
+        return dst[0]
+    if val > src[1]:
+        return dst[1]
+
+    return ((val - src[0]) / (src[1] - src[0])) * (dst[1] - dst[0]) + dst[0]
+
+
+def as_percent(self, digits=2):
+    return as_format(self, ".%s%%" % digits)
+
+
+def as_format(item, format_str=".2f"):
+    """
+    Map a format string over a pandas object.
+    """
+    if isinstance(item, pd.Series):
+        return item.map(lambda x: format(x, format_str))
+    elif isinstance(item, pd.DataFrame):
+        return item.applymap(lambda x: format(x, format_str))
+import random
+
+import numpy as np
+import pandas as pd
+from pandas.core.base import PandasObject
+
+def tabulate(data, headers):
+    return pd.DataFrame(data, columns=headers)
+
+try:
+    import prettyplotlib  # NOQA
+except ImportError:
+    pass
+
+# avoid pyplot import failure in headless environment
+import os
+
+class PerformanceStats(object):
+    """
+    PerformanceStats is a convenience class used for the performance
+    evaluation of a price series. It contains various helper functions
+    to help with plotting and contains a large amount of descriptive
+    statistics.
+    Args:
+        * prices (Series): A price series.
+        * rf (float, Series): `Risk-free rate <https://www.investopedia.com/terms/r/risk-freerate.asp>`_ used in various calculation. Should be
+            expressed as a yearly (annualized) return if it is a float. Otherwise
+            rf should be a price series.
+    Attributes:
+        * name (str): Name, derived from price series name
+        * return_table (DataFrame): A table of monthly returns with
+            YTD figures as well.
+        * lookback_returns (Series): Returns for different
+            lookback periods (1m, 3m, 6m, ytd...)
+        * stats (Series): A series that contains all the stats
+    """
+
+    def __init__(self, prices, rf=0.0):
+        super(PerformanceStats, self).__init__()
+        self.prices = prices
+        self.name = self.prices.name
+        self._start = self.prices.index[0]
+        self._end = self.prices.index[-1]
+
+        self.rf = rf
+
+        self._update(self.prices)
+
+    def set_riskfree_rate(self, rf):
+
+        """
+        Set annual risk-free rate property and calculate properly annualized
+        monthly and daily rates. Then performance stats are recalculated.
+        Affects only this instance of the PerformanceStats.
+        Args:
+            * rf (float): Annual `risk-free rate <https://www.investopedia.com/terms/r/risk-freerate.asp>`_
+        """
+        self.rf = rf
+
+        # Note, that we recalculate everything.
+        self._update(self.prices)
+
+    def _update(self, obj):
+        # calc
+        self._calculate(obj)
+
+        # update derived structure
+        # return table as dataframe for easier manipulation
+        self.return_table = pd.DataFrame(self.return_table).T
+        # name columns
+        if len(self.return_table.columns) == 13:
+            self.return_table.columns = [
+                "Jan",
+                "Feb",
+                "Mar",
+                "Apr",
+                "May",
+                "Jun",
+                "Jul",
+                "Aug",
+                "Sep",
+                "Oct",
+                "Nov",
+                "Dec",
+                "YTD",
+            ]
+
+        self.lookback_returns = pd.Series(
+            [
+                self.mtd,
+                self.three_month,
+                self.six_month,
+                self.ytd,
+                self.one_year,
+                self.three_year,
+                self.five_year,
+                self.ten_year,
+                self.cagr,
+            ],
+            ["mtd", "3m", "6m", "ytd", "1y", "3y", "5y", "10y", "incep"],
+        )
+        self.lookback_returns.name = self.name
+
+        self.stats = self._create_stats_series()
+
+    def _calculate(self, obj):
+        # default values
+        self.daily_mean = np.nan
+        self.daily_vol = np.nan
+        self.daily_sharpe = np.nan
+        self.daily_sortino = np.nan
+        self.best_day = np.nan
+        self.worst_day = np.nan
+        self.total_return = np.nan
+        self.cagr = np.nan
+        self.incep = np.nan
+        self.drawdown = np.nan
+        self.max_drawdown = np.nan
+        self.drawdown_details = np.nan
+        self.daily_skew = np.nan
+        self.daily_kurt = np.nan
+        self.monthly_returns = np.nan
+        self.avg_drawdown = np.nan
+        self.avg_drawdown_days = np.nan
+        self.monthly_mean = np.nan
+        self.monthly_vol = np.nan
+        self.monthly_sharpe = np.nan
+        self.monthly_sortino = np.nan
+        self.best_month = np.nan
+        self.worst_month = np.nan
+        self.mtd = np.nan
+        self.three_month = np.nan
+        self.pos_month_perc = np.nan
+        self.avg_up_month = np.nan
+        self.avg_down_month = np.nan
+        self.monthly_skew = np.nan
+        self.monthly_kurt = np.nan
+        self.six_month = np.nan
+        self.yearly_returns = np.nan
+        self.ytd = np.nan
+        self.one_year = np.nan
+        self.yearly_mean = np.nan
+        self.yearly_vol = np.nan
+        self.yearly_sharpe = np.nan
+        self.yearly_sortino = np.nan
+        self.best_year = np.nan
+        self.worst_year = np.nan
+        self.three_year = np.nan
+        self.win_year_perc = np.nan
+        self.twelve_month_win_perc = np.nan
+        self.yearly_skew = np.nan
+        self.yearly_kurt = np.nan
+        self.five_year = np.nan
+        self.ten_year = np.nan
+        self.calmar = np.nan
+
+        self.return_table = {}
+        # end default values
+
+        if len(obj) == 0:
+            return
+
+        self.start = obj.index[0]
+        self.end = obj.index[-1]
+
+        # save daily prices for future use
+        self.daily_prices = obj.resample("D").last()
+        # resample('D') imputes na values for any day that didn't have a price
+        #  .dropna() removes the na values but also implies that the original
+        #  price series didn't have any na values
+        #  if months or years are missing then we will need .dropna() too
+        self.daily_prices = self.daily_prices.dropna()
+        # M = month end frequency
+        self.monthly_prices = obj.resample("M").last()  # .dropna()
+        # A == year end frequency
+        self.yearly_prices = obj.resample("A").last()  # .dropna()
+
+        # let's save some typing
+        dp = self.daily_prices
+        mp = self.monthly_prices
+        yp = self.yearly_prices
+
+        if len(dp) == 1:
+            return
+
+        self.mtd = calc_mtd(dp, mp)
+        self.ytd = calc_ytd(dp, yp)
+
+        # stats using daily data
+        self.returns = dp.to_returns()
+        self.log_returns = dp.to_log_returns()
+        r = self.returns
+
+        if len(r) < 2:
+            return
+
+        # Will calculate daily figures only if the input data has at least daily frequency or higher (e.g hourly)
+        # Rather < 2 days than <= 1 days in case of data taken at different hours of the days
+        if r.index.to_series().diff().min() < pd.Timedelta("2 days"):
+            self.daily_mean = r.mean() * 252
+            self.daily_vol = np.std(r, ddof=1) * np.sqrt(252)
+
+            # if type(self.rf) is float:
+            if isinstance(self.rf, float):
+                self.daily_sharpe = r.calc_sharpe(rf=self.rf, nperiods=252)
+                self.daily_sortino = calc_sortino_ratio(r, rf=self.rf, nperiods=252)
+            # rf is a price series
+            else:
+                _rf_daily_price_returns = self.rf.to_returns()
+                self.daily_sharpe = r.calc_sharpe(
+                    rf=_rf_daily_price_returns, nperiods=252
+                )
+                self.daily_sortino = calc_sortino_ratio(
+                    r, rf=_rf_daily_price_returns, nperiods=252
+                )
+
+            self.best_day = r.max()
+            self.worst_day = r.min()
+
+        self.total_return = obj.iloc[-1] / obj.iloc[0] - 1
+
+        self.cagr = calc_cagr(dp)
+        self.incep = self.cagr
+
+        self.drawdown = dp.to_drawdown_series()
+        self.max_drawdown = self.drawdown.min()
+        self.drawdown_details = drawdown_details(self.drawdown)
+        if self.drawdown_details is not None:
+            self.avg_drawdown = self.drawdown_details["drawdown"].mean()
+            self.avg_drawdown_days = self.drawdown_details["Length"].mean()
+
+        self.calmar = np.divide(self.cagr, np.abs(self.max_drawdown)+0.00001)
+
+        if len(r) < 4:
+            return
+
+        if r.index.to_series().diff().min() <= pd.Timedelta("2 days"):
+            self.daily_skew = r.skew()
+
+            # if all zero/nan kurt fails division by zero
+            if len(r[(~np.isnan(r)) & (r != 0)]) > 0:
+                self.daily_kurt = r.kurt()
+
+        # stats using monthly data
+        self.monthly_returns = self.monthly_prices.to_returns()
+        mr = self.monthly_returns
+
+        if len(mr) < 2:
+            return
+
+        # Will calculate monthly figures only if the input data has at least monthly frequency or higher (e.g daily)
+        # Rather < 32 days than <= 31 days in case of data taken at different hours of the days
+        if r.index.to_series().diff().min() < pd.Timedelta("32 days"):
+            self.monthly_mean = mr.mean() * 12
+            self.monthly_vol = np.std(mr, ddof=1) * np.sqrt(12)
+
+            if type(self.rf) is float:
+                self.monthly_sharpe = mr.calc_sharpe(rf=self.rf, nperiods=12)
+                self.monthly_sortino = calc_sortino_ratio(mr, rf=self.rf, nperiods=12)
+            # rf is a price series
+            else:
+                _rf_monthly_price_returns = self.rf.resample("M").last().to_returns()
+                self.monthly_sharpe = mr.calc_sharpe(
+                    rf=_rf_monthly_price_returns, nperiods=12
+                )
+                self.monthly_sortino = calc_sortino_ratio(
+                    mr, rf=_rf_monthly_price_returns, nperiods=12
+                )
+            self.best_month = mr.max()
+            self.worst_month = mr.min()
+
+            # -1 here to account for first return that will be nan
+            self.pos_month_perc = len(mr[mr > 0]) / float(len(mr) - 1)
+            self.avg_up_month = mr[mr > 0].mean()
+            self.avg_down_month = mr[mr <= 0].mean()
+
+            # return_table
+            for idx in mr.index:
+                if idx.year not in self.return_table:
+                    self.return_table[idx.year] = {
+                        1: 0,
+                        2: 0,
+                        3: 0,
+                        4: 0,
+                        5: 0,
+                        6: 0,
+                        7: 0,
+                        8: 0,
+                        9: 0,
+                        10: 0,
+                        11: 0,
+                        12: 0,
+                    }
+                if not np.isnan(mr[idx]):
+                    self.return_table[idx.year][idx.month] = mr[idx]
+            # add first month
+            fidx = mr.index[0]
+            try:
+                self.return_table[fidx.year][fidx.month] = float(mp.iloc[0]) / dp.iloc[0] - 1
+            except ZeroDivisionError:
+                self.return_table[fidx.year][fidx.month] = 0
+            # calculate the YTD values
+            for idx in self.return_table:
+                arr = np.array(list(self.return_table[idx].values()))
+                self.return_table[idx][13] = np.prod(arr + 1) - 1
+
+        if r.index.to_series().diff().min() < pd.Timedelta("93 days"):
+            if len(mr) < 3:
+                return
+
+            denom = dp[: dp.index[-1] - pd.DateOffset(months=3)]
+            if len(denom) > 0:
+                self.three_month = dp.iloc[-1] / denom.iloc[-1] - 1
+
+        if r.index.to_series().diff().min() < pd.Timedelta("32 days"):
+            if len(mr) < 4:
+                return
+
+            self.monthly_skew = mr.skew()
+
+            # if all zero/nan kurt fails division by zero
+            if len(mr[(~np.isnan(mr)) & (mr != 0)]) > 0:
+                self.monthly_kurt = mr.kurt()
+
+        if r.index.to_series().diff().min() < pd.Timedelta("185 days"):
+            if len(mr) < 6:
+                return
+
+            denom = dp[: dp.index[-1] - pd.DateOffset(months=6)]
+
+            if len(denom) > 0:
+                self.six_month = dp.iloc[-1] / denom.iloc[-1] - 1
+
+        # Will calculate yearly figures only if the input data has at least yearly frequency or higher (e.g monthly)
+        # Rather < 367 days than <= 366 days in case of data taken at different hours of the days
+        if r.index.to_series().diff().min() < pd.Timedelta("367 days"):
+            self.yearly_returns = self.yearly_prices.to_returns()
+            yr = self.yearly_returns
+
+            if len(yr) < 2:
+                return
+
+            denom = dp[: dp.index[-1] - pd.DateOffset(years=1)]
+
+            if len(denom) > 0:
+                self.one_year = dp.iloc[-1] / denom.iloc[-1] - 1
+
+            self.yearly_mean = yr.mean()
+            self.yearly_vol = np.std(yr, ddof=1)
+
+            # if type(self.rf) is float:
+            if isinstance(self.rf, float):
+                if self.yearly_vol > 0:
+                    self.yearly_sharpe = yr.calc_sharpe(rf=self.rf, nperiods=1)
+                self.yearly_sortino = calc_sortino_ratio(yr, rf=self.rf, nperiods=1)
+            # rf is a price series
+            else:
+                _rf_yearly_price_returns = self.rf.resample("A").last().to_returns()
+                if self.yearly_vol > 0:
+                    self.yearly_sharpe = yr.calc_sharpe(
+                        rf=_rf_yearly_price_returns, nperiods=1
+                    )
+                self.yearly_sortino = calc_sortino_ratio(
+                    yr, rf=_rf_yearly_price_returns, nperiods=1
+                )
+
+            self.best_year = yr.max()
+            self.worst_year = yr.min()
+
+            # -1 here to account for first return that will be nan
+            self.win_year_perc = len(yr[yr > 0]) / float(len(yr) - 1)
+
+            # need at least 1 year of monthly returns
+            if mr.size > 11:
+                tot = 0
+                win = 0
+                for i in range(11, len(mr)):
+                    tot += 1
+                    if mp.iloc[i] / mp.iloc[i - 11] > 1:
+                        win += 1
+                self.twelve_month_win_perc = float(win) / tot
+
+        if r.index.to_series().diff().min() < pd.Timedelta("1097 days"):
+            if len(yr) < 3:
+                return
+
+            # annualize stat for over 1 year
+            self.three_year = calc_cagr(dp[dp.index[-1] - pd.DateOffset(years=3) :])
+
+        if r.index.to_series().diff().min() < pd.Timedelta("367 days"):
+            if len(yr) < 4:
+                return
+
+            self.yearly_skew = yr.skew()
+
+            # if all zero/nan kurt fails division by zero
+            if len(yr[(~np.isnan(yr)) & (yr != 0)]) > 0:
+                self.yearly_kurt = yr.kurt()
+
+        if r.index.to_series().diff().min() < pd.Timedelta("1828 days"):
+            if len(yr) < 5:
+                return
+            self.five_year = calc_cagr(dp[dp.index[-1] - pd.DateOffset(years=5) :])
+
+        if r.index.to_series().diff().min() < pd.Timedelta("3654 days"):
+            if len(yr) < 10:
+                return
+            self.ten_year = calc_cagr(dp[dp.index[-1] - pd.DateOffset(years=10) :])
+
+        return
+
+    def _stats(self):
+        stats = [
+            ("start", "Start", "dt"),
+            ("end", "End", "dt"),
+            ("rf", "Risk-free rate", "p"),
+            (None, None, None),
+            ("total_return", "Total Return", "p"),
+            ("cagr", "CAGR", "p"),
+            ("max_drawdown", "Max Drawdown", "p"),
+            ("calmar", "Calmar Ratio", "n"),
+            (None, None, None),
+            ("mtd", "MTD", "p"),
+            ("three_month", "3m", "p"),
+            ("six_month", "6m", "p"),
+            ("ytd", "YTD", "p"),
+            ("one_year", "1Y", "p"),
+            ("three_year", "3Y (ann.)", "p"),
+            ("five_year", "5Y (ann.)", "p"),
+            ("ten_year", "10Y (ann.)", "p"),
+            ("incep", "Since Incep. (ann.)", "p"),
+            (None, None, None),
+            ("daily_sharpe", "Daily Sharpe", "n"),
+            ("daily_sortino", "Daily Sortino", "n"),
+            ("daily_mean", "Daily Mean (ann.)", "p"),
+            ("daily_vol", "Daily Vol (ann.)", "p"),
+            ("daily_skew", "Daily Skew", "n"),
+            ("daily_kurt", "Daily Kurt", "n"),
+            ("best_day", "Best Day", "p"),
+            ("worst_day", "Worst Day", "p"),
+            (None, None, None),
+            ("monthly_sharpe", "Monthly Sharpe", "n"),
+            ("monthly_sortino", "Monthly Sortino", "n"),
+            ("monthly_mean", "Monthly Mean (ann.)", "p"),
+            ("monthly_vol", "Monthly Vol (ann.)", "p"),
+            ("monthly_skew", "Monthly Skew", "n"),
+            ("monthly_kurt", "Monthly Kurt", "n"),
+            ("best_month", "Best Month", "p"),
+            ("worst_month", "Worst Month", "p"),
+            (None, None, None),
+            ("yearly_sharpe", "Yearly Sharpe", "n"),
+            ("yearly_sortino", "Yearly Sortino", "n"),
+            ("yearly_mean", "Yearly Mean", "p"),
+            ("yearly_vol", "Yearly Vol", "p"),
+            ("yearly_skew", "Yearly Skew", "n"),
+            ("yearly_kurt", "Yearly Kurt", "n"),
+            ("best_year", "Best Year", "p"),
+            ("worst_year", "Worst Year", "p"),
+            (None, None, None),
+            ("avg_drawdown", "Avg. Drawdown", "p"),
+            ("avg_drawdown_days", "Avg. Drawdown Days", "n"),
+            ("avg_up_month", "Avg. Up Month", "p"),
+            ("avg_down_month", "Avg. Down Month", "p"),
+            ("win_year_perc", "Win Year %", "p"),
+            ("twelve_month_win_perc", "Win 12m %", "p"),
+        ]
+
+        return stats
+
+    def set_date_range(self, start=None, end=None):
+        """
+        Update date range of stats, charts, etc. If None then
+        the original date is used. So to reset to the original
+        range, just call with no args.
+        Args:
+            * start (date): start date
+            * end (end): end date
+        """
+        start = self._start if start is None else pd.to_datetime(start)
+        end = self._end if end is None else pd.to_datetime(end)
+        self._update(self.prices.loc[start:end])
+
+    def display(self):
+        """
+        Displays an overview containing descriptive stats for the Series
+        provided.
+        """
+        print("Stats for %s from %s - %s" % (self.name, self.start, self.end))
+        if type(self.rf) is float:
+            print("Annual risk-free rate considered: %s" % (fmtp(self.rf)))
+        print("Summary:")
+        data = [
+            [
+                fmtp(self.total_return),
+                fmtn(self.daily_sharpe),
+                fmtp(self.cagr),
+                fmtp(self.max_drawdown),
+            ]
+        ]
+        print(
+            tabulate(data, headers=["Total Return", "Sharpe", "CAGR", "Max Drawdown"])
+        )
+
+        print("\nAnnualized Returns:")
+        data = [
+            [
+                fmtp(self.mtd),
+                fmtp(self.three_month),
+                fmtp(self.six_month),
+                fmtp(self.ytd),
+                fmtp(self.one_year),
+                fmtp(self.three_year),
+                fmtp(self.five_year),
+                fmtp(self.ten_year),
+                fmtp(self.incep),
+            ]
+        ]
+        print(
+            tabulate(
+                data,
+                headers=["mtd", "3m", "6m", "ytd", "1y", "3y", "5y", "10y", "incep."],
+            )
+        )
+
+        print("\nPeriodic:")
+        data = [
+            [
+                "sharpe",
+                fmtn(self.daily_sharpe),
+                fmtn(self.monthly_sharpe),
+                fmtn(self.yearly_sharpe),
+            ],
+            [
+                "mean",
+                fmtp(self.daily_mean),
+                fmtp(self.monthly_mean),
+                fmtp(self.yearly_mean),
+            ],
+            [
+                "vol",
+                fmtp(self.daily_vol),
+                fmtp(self.monthly_vol),
+                fmtp(self.yearly_vol),
+            ],
+            [
+                "skew",
+                fmtn(self.daily_skew),
+                fmtn(self.monthly_skew),
+                fmtn(self.yearly_skew),
+            ],
+            [
+                "kurt",
+                fmtn(self.daily_kurt),
+                fmtn(self.monthly_kurt),
+                fmtn(self.yearly_kurt),
+            ],
+            ["best", fmtp(self.best_day), fmtp(self.best_month), fmtp(self.best_year)],
+            [
+                "worst",
+                fmtp(self.worst_day),
+                fmtp(self.worst_month),
+                fmtp(self.worst_year),
+            ],
+        ]
+        print(tabulate(data, headers=["index", "daily", "monthly", "yearly"]))
+
+        print("\nDrawdowns:")
+        data = [
+            [
+                fmtp(self.max_drawdown),
+                fmtp(self.avg_drawdown),
+                fmtn(self.avg_drawdown_days),
+            ]
+        ]
+        print(tabulate(data, headers=["max", "avg", "# days"]))
+
+        print("\nMisc:")
+        data = [
+            ["avg. up month", fmtp(self.avg_up_month)],
+            ["avg. down month", fmtp(self.avg_down_month)],
+            ["up year %", fmtp(self.win_year_perc)],
+            ["12m up %", fmtp(self.twelve_month_win_perc)],
+        ]
+        print(tabulate(data, headers=["name", "value"]))
+
+    def display_monthly_returns(self):
+        """
+        Display a table containing monthly returns and ytd returns
+        for every year in range.
+        """
+        data = [
+            [
+                "Year",
+                "Jan",
+                "Feb",
+                "Mar",
+                "Apr",
+                "May",
+                "Jun",
+                "Jul",
+                "Aug",
+                "Sep",
+                "Oct",
+                "Nov",
+                "Dec",
+                "YTD",
+            ]
+        ]
+        for k in self.return_table.index:
+            r = self.return_table.loc[k].values
+            data.append([k] + [fmtpn(x) for x in r])
+        print(tabulate(data, headers="firstrow"))
+
+    def display_lookback_returns(self):
+        """
+        Displays the current lookback returns.
+        """
+        return self.lookback_returns.map("{:,.2%}".format)
+
+    def _get_default_plot_title(self, name, freq, kind):
+        if freq is None:
+            return "%s %s" % (name, kind)
+        else:
+            return "%s %s %s" % (name, get_freq_name(freq), kind)
+
+    def plot(self, freq=None, figsize=(15, 5), title=None, logy=False, **kwargs):
+        """
+        Helper function for plotting the series.
+        Args:
+            * freq (str): Data frequency used for display purposes.
+                Refer to pandas docs for valid freq strings.
+            * figsize ((x,y)): figure size
+            * title (str): Title if default not appropriate
+            * logy (bool): log-scale for y axis
+            * kwargs: passed to pandas' plot method
+        """
+        if title is None:
+            title = self._get_default_plot_title(self.name, freq, "Price Series")
+
+        ser = self._get_series(freq)
+        return ser.plot(figsize=figsize, title=title, logy=logy, **kwargs)
+
+    def plot_histogram(self, freq=None, figsize=(15, 5), title=None, bins=20, **kwargs):
+        """
+        Plots a histogram of returns given a return frequency.
+        Args:
+            * freq (str): Data frequency used for display purposes.
+                This will dictate the type of returns
+                (daily returns, monthly, ...)
+                Refer to pandas docs for valid period strings.
+            * figsize ((x,y)): figure size
+            * title (str): Title if default not appropriate
+            * bins (int): number of bins for the histogram
+            * kwargs: passed to pandas' hist method
+        """
+        if title is None:
+            title = self._get_default_plot_title(self.name, freq, "Return Histogram")
+
+        ser = self._get_series(freq).to_returns().dropna()
+
+        plt.figure(figsize=figsize)
+
+        if matplotlib.__version__ > "2.":
+            # normed deprecated
+            ax = ser.hist(bins=bins, figsize=figsize, density=True, **kwargs)
+        else:
+            ax = ser.hist(bins=bins, figsize=figsize, normed=True, **kwargs)
+
+        ax.set_title(title)
+        plt.axvline(0, linewidth=4)
+        return ser.plot(kind="kde")
+
+    def _get_series(self, freq):
+        if freq is None:
+            return self.daily_prices
+
+        if freq == "y":
+            freq = "a"
+        return self.daily_prices.asfreq(freq, "ffill")
+
+    def _create_stats_series(self):
+        stats = self._stats()
+
+        short_names = []
+        values = []
+
+        for stat in stats:
+            k, n, f = stat
+
+            # blank row
+            if k is None:
+                continue
+            elif k == "rf" and not type(self.rf) == float:
+                continue
+
+            if n in short_names:
+                continue
+
+            short_names.append(k)
+            raw = getattr(self, k)
+            values.append(raw)
+        return pd.Series(values, short_names)
+
+    def to_csv(self, sep=",", path=None):
+        """
+        Returns a CSV string with appropriate formatting.
+        If path is not None, the string will be saved to file
+        at path.
+        Args:
+            * sep (char): Separator
+            * path (str): If None, CSV string returned. Else file written
+                to specified path.
+        """
+        stats = self._stats()
+
+        data = []
+        first_row = ["Stat", self.name]
+        data.append(sep.join(first_row))
+
+        for stat in stats:
+            k, n, f = stat
+
+            # blank row
+            if k is None:
+                row = [""] * len(data[0])
+                data.append(sep.join(row))
+                continue
+            elif k == "rf" and not type(self.rf) == float:
+                continue
+
+            row = [n]
+            raw = getattr(self, k)
+            if f is None:
+                row.append(raw)
+            elif f == "p":
+                row.append(fmtp(raw))
+            elif f == "n":
+                row.append(fmtn(raw))
+            elif f == "dt":
+                row.append(raw.strftime("%Y-%m-%d"))
+            else:
+                raise NotImplementedError("unsupported format %s" % f)
+
+            data.append(sep.join(row))
+
+        res = "\n".join(data)
+
+        if path is not None:
+            with open(path, "w") as fl:
+                fl.write(res)
+        else:
+            return res
+
+
+class GroupStats(dict):
+    """
+    GroupStats enables one to compare multiple series side by side.
+    It is a wrapper around a dict of {price.name: PerformanceStats} and
+    provides many convenience methods.
+    The order of the series passed in will be preserved.
+    Individual PerformanceStats objects can be accessed via index
+    position or name via the [] accessor.
+    Args:
+        * prices (Series): Multiple price series to be compared.
+    Attributes:
+        * stats (DataFrame): Dataframe containing stats for each
+            series provided.  Stats in rows, series in columns.
+        * lookback_returns (DataFrame): Returns for diffrent
+            lookback periods (1m, 3m, 6m, ytd...)
+            Period in rows, series in columns.
+        * prices (DataFrame): The merged and rebased prices.
+    """
+
+    def __init__(self, *prices):
+        names = []
+        for p in prices:
+            if isinstance(p, pd.DataFrame):
+                names.extend(p.columns)
+            elif isinstance(p, pd.Series):
+                names.append(p.name)
+            else:
+                print("else")
+                names.append(getattr(p, "name", "n/a"))
+        self._names = names
+
+        # store original prices
+        self._prices = merge(*prices).dropna()
+
+        # proper ordering
+        self._prices = self._prices[self._names]
+
+        # check for duplicate columns
+        if len(self._prices.columns) != len(set(self._prices.columns)):
+            raise ValueError(
+                "One or more data series provided",
+                "have same name! Please provide unique names",
+            )
+
+        self._start = self._prices.index[0]
+        self._end = self._prices.index[-1]
+        # calculate stats for entire series
+        self._update(self._prices)
+
+    def __getitem__(self, key):
+        if isinstance(key, int):
+            # if type(key) == int:
+            return self[self._names[key]]
+        else:
+            return self.get(key)
+
+    def _update(self, data):
+        self._calculate(data)
+        self._update_stats()
+
+    def _calculate(self, data):
+        self.prices = data
+        for c in data.columns:
+            prc = data[c]
+            self[c] = PerformanceStats(prc)
+
+    def _stats(self):
+        stats = [
+            ("start", "Start", "dt"),
+            ("end", "End", "dt"),
+            ("rf", "Risk-free rate", "p"),
+            (None, None, None),
+            ("total_return", "Total Return", "p"),
+            ("daily_sharpe", "Daily Sharpe", "n"),
+            ("daily_sortino", "Daily Sortino", "n"),
+            ("cagr", "CAGR", "p"),
+            ("max_drawdown", "Max Drawdown", "p"),
+            ("calmar", "Calmar Ratio", "n"),
+            (None, None, None),
+            ("mtd", "MTD", "p"),
+            ("three_month", "3m", "p"),
+            ("six_month", "6m", "p"),
+            ("ytd", "YTD", "p"),
+            ("one_year", "1Y", "p"),
+            ("three_year", "3Y (ann.)", "p"),
+            ("five_year", "5Y (ann.)", "p"),
+            ("ten_year", "10Y (ann.)", "p"),
+            ("incep", "Since Incep. (ann.)", "p"),
+            (None, None, None),
+            ("daily_sharpe", "Daily Sharpe", "n"),
+            ("daily_sortino", "Daily Sortino", "n"),
+            ("daily_mean", "Daily Mean (ann.)", "p"),
+            ("daily_vol", "Daily Vol (ann.)", "p"),
+            ("daily_skew", "Daily Skew", "n"),
+            ("daily_kurt", "Daily Kurt", "n"),
+            ("best_day", "Best Day", "p"),
+            ("worst_day", "Worst Day", "p"),
+            (None, None, None),
+            ("monthly_sharpe", "Monthly Sharpe", "n"),
+            ("monthly_sortino", "Monthly Sortino", "n"),
+            ("monthly_mean", "Monthly Mean (ann.)", "p"),
+            ("monthly_vol", "Monthly Vol (ann.)", "p"),
+            ("monthly_skew", "Monthly Skew", "n"),
+            ("monthly_kurt", "Monthly Kurt", "n"),
+            ("best_month", "Best Month", "p"),
+            ("worst_month", "Worst Month", "p"),
+            (None, None, None),
+            ("yearly_sharpe", "Yearly Sharpe", "n"),
+            ("yearly_sortino", "Yearly Sortino", "n"),
+            ("yearly_mean", "Yearly Mean", "p"),
+            ("yearly_vol", "Yearly Vol", "p"),
+            ("yearly_skew", "Yearly Skew", "n"),
+            ("yearly_kurt", "Yearly Kurt", "n"),
+            ("best_year", "Best Year", "p"),
+            ("worst_year", "Worst Year", "p"),
+            (None, None, None),
+            ("avg_drawdown", "Avg. Drawdown", "p"),
+            ("avg_drawdown_days", "Avg. Drawdown Days", "n"),
+            ("avg_up_month", "Avg. Up Month", "p"),
+            ("avg_down_month", "Avg. Down Month", "p"),
+            ("win_year_perc", "Win Year %", "p"),
+            ("twelve_month_win_perc", "Win 12m %", "p"),
+        ]
+
+        return stats
+
+    def _update_stats(self):
+        # lookback returns dataframe
+        self.lookback_returns = pd.DataFrame(
+            {x.lookback_returns.name: x.lookback_returns for x in self.values()}
+        )
+
+        self.stats = pd.DataFrame({x.name: x.stats for x in self.values()})
+
+    def _get_default_plot_title(self, freq, kind):
+        if freq is None:
+            return "%s" % kind
+        else:
+            return "%s %s" % (get_freq_name(freq), kind)
+
+    def set_riskfree_rate(self, rf):
+
+        """
+        Set annual `risk-free rate <https://www.investopedia.com/terms/r/risk-freerate.asp>`_ property and calculate properly annualized
+        monthly and daily rates. Then performance stats are recalculated.
+        Affects only those instances of PerformanceStats that are children of
+        this GroupStats object.
+        Args:
+            * rf (float, Series): Annual risk-free rate or risk-free rate price series
+        """
+
+        for key in self._names:
+            self[key].set_riskfree_rate(rf)
+
+        # calculate stats for entire series
+        self._update_stats()
+
+    def set_date_range(self, start=None, end=None):
+        """
+        Update date range of stats, charts, etc. If None then
+        the original date range is used. So to reset to the original
+        range, just call with no args.
+        Args:
+            * start (date): start date
+            * end (end): end date
+        """
+        start = self._start if start is None else pd.to_datetime(start)
+        end = self._end if end is None else pd.to_datetime(end)
+        self._update(self._prices.loc[start:end])
+
+    def display(self):
+        """
+        Display summary stats table.
+        """
+        data = []
+        first_row = ["Stat"]
+        first_row.extend(self._names)
+        data.append(first_row)
+
+        stats = self._stats()
+
+        for stat in stats:
+            k, n, f = stat
+            # blank row
+            if k is None:
+                row = [""] * len(data[0])
+                data.append(row)
+                continue
+
+            row = [n]
+            for key in self._names:
+                raw = getattr(self[key], k)
+
+                # if rf is a series print nan
+                if k == "rf" and not type(raw) == float:
+                    row.append(np.nan)
+                elif f is None:
+                    row.append(raw)
+                elif f == "p":
+                    row.append(fmtp(raw))
+                elif f == "n":
+                    row.append(fmtn(raw))
+                elif f == "dt":
+                    row.append(raw.strftime("%Y-%m-%d"))
+                else:
+                    raise NotImplementedError("unsupported format %s" % f)
+            data.append(row)
+
+        print(tabulate(data, headers="firstrow"))
+
+    def display_lookback_returns(self):
+        """
+        Displays the current lookback returns for each series.
+        """
+        return self.lookback_returns.apply(lambda x: x.map("{:,.2%}".format), axis=1)
+
+    def plot(self, freq=None, figsize=(15, 5), title=None, logy=False, **kwargs):
+        """
+        Helper function for plotting the series.
+        Args:
+            * freq (str): Data frequency used for display purposes.
+                Refer to pandas docs for valid freq strings.
+            * figsize ((x,y)): figure size
+            * title (str): Title if default not appropriate
+            * logy (bool): log-scale for y axis
+            * kwargs: passed to pandas' plot method
+        """
+
+        if title is None:
+            title = self._get_default_plot_title(freq, "Equity Progression")
+
+        ser = self._get_series(freq).rebase()
+        return ser.plot(figsize=figsize, logy=logy, title=title, **kwargs)
+
+    def plot_scatter_matrix(self, freq=None, title=None, figsize=(10, 10), **kwargs):
+        """
+        Wrapper around pandas' scatter_matrix.
+        Args:
+            * freq (str): Data frequency used for display purposes.
+                Refer to pandas docs for valid freq strings.
+            * figsize ((x,y)): figure size
+            * title (str): Title if default not appropriate
+            * kwargs: passed to pandas' scatter_matrix method
+        """
+        if title is None:
+            title = self._get_default_plot_title(freq, "Return Scatter Matrix")
+
+        plt.figure()
+        ser = self._get_series(freq).to_returns().dropna()
+        if hasattr(pd, "scatter_matrix"):
+            pd.scatter_matrix(ser, figsize=figsize, **kwargs)
+        else:
+            pd.plotting.scatter_matrix(ser, figsize=figsize, **kwargs)
+        return plt.suptitle(title)
+
+    def plot_histograms(self, freq=None, title=None, figsize=(10, 10), **kwargs):
+        """
+        Wrapper around pandas' hist.
+        Args:
+            * freq (str): Data frequency used for display purposes.
+                Refer to pandas docs for valid freq strings.
+            * figsize ((x,y)): figure size
+            * title (str): Title if default not appropriate
+            * kwargs: passed to pandas' hist method
+        """
+        if title is None:
+            title = self._get_default_plot_title(freq, "Return Histogram Matrix")
+
+        plt.figure()
+        ser = self._get_series(freq).to_returns().dropna()
+        ser.hist(figsize=figsize, **kwargs)
+        return plt.suptitle(title)
+
+    def plot_correlation(self, freq=None, title=None, figsize=(12, 6), **kwargs):
+        """
+        Utility function to plot correlations.
+        Args:
+            * freq (str): Pandas data frequency alias string
+            * title (str): Plot title
+            * figsize (tuple (x,y)): figure size
+            * kwargs: passed to Pandas' plot_corr_heatmap function
+        """
+        if title is None:
+            title = self._get_default_plot_title(freq, "Return Correlation Matrix")
+
+        rets = self._get_series(freq).to_returns().dropna()
+        return rets.plot_corr_heatmap(title=title, figsize=figsize, **kwargs)
+
+    def _get_series(self, freq):
+        if freq is None:
+            return self.prices
+
+        if freq == "y":
+            freq = "a"
+        return self.prices.asfreq(freq, "ffill")
+
+    def to_csv(self, sep=",", path=None):
+        """
+        Returns a CSV string with appropriate formatting.
+        If path is not None, the string will be saved to file
+        at path.
+        Args:
+            * sep (char): Separator
+            * path (str): If None, CSV string returned. Else file
+                written to specified path.
+        """
+        data = []
+        first_row = ["Stat"]
+        first_row.extend(self._names)
+        data.append(sep.join(first_row))
+
+        stats = self._stats()
+
+        for stat in stats:
+            k, n, f = stat
+            # blank row
+            if k is None:
+                row = [""] * len(data[0])
+                data.append(sep.join(row))
+                continue
+
+            row = [n]
+            for key in self._names:
+                raw = getattr(self[key], k)
+                if f is None:
+                    row.append(raw)
+                elif f == "p":
+                    row.append(fmtp(raw))
+                elif f == "n":
+                    row.append(fmtn(raw))
+                elif f == "dt":
+                    row.append(raw.strftime("%Y-%m-%d"))
+                else:
+                    raise NotImplementedError("unsupported format %s" % f)
+            data.append(sep.join(row))
+
+        res = "\n".join(data)
+
+        if path is not None:
+            with open(path, "w") as fl:
+                fl.write(res)
+        else:
+            return res
+
+
+def to_returns(prices):
+    """
+    Calculates the simple arithmetic returns of a price series.
+    Formula is: (t1 / t0) - 1
+    Args:
+        * prices: Expects a price series
+    """
+    return prices / prices.shift(1) - 1
+
+
+def to_log_returns(prices):
+    """
+    Calculates the log returns of a price series.
+    Formula is: ln(p1/p0)
+    Args:
+        * prices: Expects a price series
+    """
+    return np.log(prices / prices.shift(1))
+
+
+def to_price_index(returns, start=100):
+    """
+    Returns a price index given a series of returns.
+    Args:
+        * returns: Expects a return series
+        * start (number): Starting level
+    Assumes arithmetic returns.
+    Formula is: cumprod (1+r)
+    """
+    return (returns.replace(to_replace=np.nan, value=0) + 1).cumprod() * start
+
+
+def rebase(prices, value=100):
+    """
+    Rebase all series to a given intial value.
+    This makes comparing/plotting different series
+    together easier.
+    Args:
+        * prices: Expects a price series
+        * value (number): starting value for all series.
+    """
+    if isinstance(prices, pd.DataFrame):
+        return prices.div(prices.iloc[0], axis=1) * value
+    return prices / prices.iloc[0] * value
+
+
+def calc_perf_stats(prices):
+    """
+    Calculates the performance statistics given an object.
+    The object should be a Series of prices.
+    A PerformanceStats object will be returned containing all the stats.
+    Args:
+        * prices (Series): Series of prices
+    """
+    return PerformanceStats(prices)
+
+
+def calc_stats(prices):
+    """
+    Calculates performance stats of a given object.
+    If object is Series, a PerformanceStats object is
+    returned. If object is DataFrame, a GroupStats object
+    is returned.
+    Args:
+        * prices (Series, DataFrame): Set of prices
+    """
+    if isinstance(prices, pd.Series):
+        return PerformanceStats(prices)
+    elif isinstance(prices, pd.DataFrame):
+        return GroupStats(*[prices[x] for x in prices.columns])
+    else:
+        raise NotImplementedError("Unsupported type")
+
+
+def to_drawdown_series(prices):
+    """
+    Calculates the `drawdown <https://www.investopedia.com/terms/d/drawdown.asp>`_ series.
+    This returns a series representing a drawdown.
+    When the price is at all time highs, the drawdown
+    is 0. However, when prices are below high water marks,
+    the drawdown series = current / hwm - 1
+    The max drawdown can be obtained by simply calling .min()
+    on the result (since the drawdown series is negative)
+    Method ignores all gaps of NaN's in the price series.
+    Args:
+        * prices (Series or DataFrame): Series of prices.
+    """
+    # make a copy so that we don't modify original data
+    drawdown = prices.copy()
+
+    # Fill NaN's with previous values
+    drawdown = drawdown.ffill()
+
+    # Ignore problems with NaN's in the beginning
+    drawdown[np.isnan(drawdown)] = -np.Inf
+
+    # Rolling maximum
+    if isinstance(drawdown, pd.DataFrame):
+        roll_max = pd.DataFrame()
+        for col in drawdown:
+            roll_max[col] = np.maximum.accumulate(drawdown[col])
+    else:
+        roll_max = np.maximum.accumulate(drawdown)
+
+    drawdown = drawdown / roll_max - 1.0
+    return drawdown
+
+
+def calc_mtd(daily_prices, monthly_prices):
+    """
+    Calculates mtd return of a price series.
+    Use daily_prices if prices are only available from same month
+    else use monthly_prices
+    """
+    if len(monthly_prices) == 1:
+        return daily_prices.iloc[-1] / daily_prices.iloc[0] - 1
+    else:
+        return daily_prices.iloc[-1] / monthly_prices.iloc[-2] - 1
+
+
+def calc_ytd(daily_prices, yearly_prices):
+    """
+    Calculates ytd return of a price series.
+    Use daily_prices if prices are only available from same year
+    else use yearly_prices
+    """
+    if len(yearly_prices) == 1:
+        return daily_prices.iloc[-1] / daily_prices.iloc[0] - 1
+    else:
+        return daily_prices.iloc[-1] / yearly_prices.iloc[-2] - 1
+
+
+def calc_max_drawdown(prices):
+    """
+    Calculates the max drawdown of a price series. If you want the
+    actual drawdown series, please use to_drawdown_series.
+    """
+    return (prices / prices.expanding(min_periods=1).max()).min() - 1
+
+
+def drawdown_details(drawdown, index_type=pd.DatetimeIndex):
+    """
+    Returns a data frame with start, end, days (duration) and
+    drawdown for each drawdown in a drawdown series.
+    .. note::
+        days are actual calendar days, not trading days
+    Args:
+        * drawdown (pandas.Series): A drawdown Series
+            (can be obtained w/ drawdown(prices).
+    Returns:
+        * pandas.DataFrame -- A data frame with the following
+            columns: start, end, days, drawdown.
+    """
+
+    is_zero = drawdown == 0
+    # find start dates (first day where dd is non-zero after a zero)
+    start = ~is_zero & is_zero.shift(1)
+    start = list(start[start == True].index)  # NOQA
+
+    # find end dates (first day where dd is 0 after non-zero)
+    end = is_zero & (~is_zero).shift(1)
+    end = list(end[end == True].index)  # NOQA
+
+    if len(start) == 0:  # start.empty
+        return None
+
+    # drawdown has no end (end period in dd)
+    if len(end) == 0:  # end.empty
+        end.append(drawdown.index[-1])
+
+    # if the first drawdown start is larger than the first drawdown end it
+    # means the drawdown series begins in a drawdown and therefore we must add
+    # the first index to the start series
+    if start[0] > end[0]:
+        start.insert(0, drawdown.index[0])
+
+    # if the last start is greater than the end then we must add the last index
+    # to the end series since the drawdown series must finish with a drawdown
+    if start[-1] > end[-1]:
+        end.append(drawdown.index[-1])
+
+    result = pd.DataFrame(
+        columns=("Start", "End", "Length", "drawdown"), index=range(0, len(start))
+    )
+
+    for i in range(0, len(start)):
+        dd = drawdown[start[i] : end[i]].min()
+
+        if index_type is pd.DatetimeIndex:
+            result.iloc[i] = (start[i], end[i], (end[i] - start[i]).days, dd)
+        else:
+            result.iloc[i] = (start[i], end[i], (end[i] - start[i]), dd)
+
+    return result
+
+
+def calc_cagr(prices):
+    """
+    Calculates the `CAGR (compound annual growth rate) <https://www.investopedia.com/terms/c/cagr.asp>`_ for a given price series.
+    Args:
+        * prices (pandas.Series): A Series of prices.
+    Returns:
+        * float -- cagr.
+    """
+    start = prices.index[0]
+    end = prices.index[-1]
+    return (prices.iloc[-1] / prices.iloc[0]) ** (1 / year_frac(start, end)) - 1
+
+
+def calc_risk_return_ratio(returns):
+    """
+    Calculates the return / risk ratio. Basically the
+    `Sharpe ratio <https://www.investopedia.com/terms/s/sharperatio.asp>`_ without factoring in the `risk-free rate <https://www.investopedia.com/terms/r/risk-freerate.asp>`_.
+    """
+    return calc_sharpe(returns)
+
+
+def calc_sharpe(returns, rf=0.0, nperiods=None, annualize=True):
+    """
+    Calculates the `Sharpe ratio <https://www.investopedia.com/terms/s/sharperatio.asp>`_
+    (see `Sharpe vs. Sortino <https://www.investopedia.com/ask/answers/010815/what-difference-between-sharpe-ratio-and-sortino-ratio.asp>`_).
+    If rf is non-zero and a float, you must specify nperiods. In this case, rf is assumed
+    to be expressed in yearly (annualized) terms.
+    Args:
+        * returns (Series, DataFrame): Input return series
+        * rf (float, Series): `Risk-free rate <https://www.investopedia.com/terms/r/risk-freerate.asp>`_ expressed as a yearly (annualized) return or return series
+        * nperiods (int): Frequency of returns (252 for daily, 12 for monthly,
+            etc.)
+    """
+    # if type(rf) is float and rf != 0 and nperiods is None:
+    if isinstance(rf, float) and rf != 0 and nperiods is None:
+        raise Exception("Must provide nperiods if rf != 0")
+
+    er = returns.to_excess_returns(rf, nperiods=nperiods)
+    std = np.std(er, ddof=1)
+    res = np.divide(er.mean(), max(std, 0.000001))
+
+    if annualize:
+        if nperiods is None:
+            nperiods = 1
+        return res * np.sqrt(nperiods)
+    else:
+        return res
+
+
+def calc_information_ratio(returns, benchmark_returns):
+    """
+    Calculates the `Information ratio <https://www.investopedia.com/terms/i/informationratio.asp>`_ (or `from Wikipedia <http://en.wikipedia.org/wiki/Information_ratio>`_).
+    """
+    diff_rets = returns - benchmark_returns
+    diff_std = np.std(diff_rets, ddof=1)
+
+    if np.isnan(diff_std) or diff_std == 0:
+        return 0.0
+
+    return np.divide(diff_rets.mean(), diff_std)
+
+
+def calc_prob_mom(returns, other_returns):
+    """
+    `Probabilistic momentum <http://cssanalytics.wordpress.com/2014/01/28/are-simple-momentum-strategies-too-dumb-introducing-probabilistic-momentum/>`_ (see `momentum investing <https://www.investopedia.com/terms/m/momentum_investing.asp>`_)
+    Basically the "probability or confidence that one asset
+    is going to outperform the other".
+    Source:
+        http://cssanalytics.wordpress.com/2014/01/28/are-simple-momentum-strategies-too-dumb-introducing-probabilistic-momentum/ # NOQA
+    """
+    return t.cdf(returns.calc_information_ratio(other_returns), len(returns) - 1)
+
+
+def calc_total_return(prices):
+    """
+    Calculates the total return of a series.
+    last / first - 1
+    """
+    return (prices.iloc[-1] / prices.iloc[0]) - 1
+
+
+def year_frac(start, end):
+    """
+    Similar to excel's yearfrac function. Returns
+    a year fraction between two dates (i.e. 1.53 years).
+    Approximation using the average number of seconds
+    in a year.
+    Args:
+        * start (datetime): start date
+        * end (datetime): end date
+    """
+    if start > end:
+        raise ValueError("start cannot be larger than end")
+
+    # obviously not perfect but good enough
+    return (end - start).total_seconds() / (31557600)
+
+
+def merge(*series):
+    """
+    Merge Series and/or DataFrames together.
+    Returns a DataFrame.
+    """
+    dfs = []
+    for s in series:
+        if isinstance(s, pd.DataFrame):
+            dfs.append(s)
+        elif isinstance(s, pd.Series):
+            tmpdf = pd.DataFrame({s.name: s})
+            dfs.append(tmpdf)
+        else:
+            raise NotImplementedError("Unsupported merge type")
+
+    return pd.concat(dfs, axis=1)
+
+
+def drop_duplicate_cols(df):
+    """
+    Removes duplicate columns from a dataframe
+    and keeps column w/ longest history
+    """
+    names = set(df.columns)
+    for n in names:
+        if len(df[n].shape) > 1:
+            # get subset of df w/ colname n
+            sub = df[n]
+            # make unique colnames
+            sub.columns = ["%s-%s" % (n, x) for x in range(sub.shape[1])]
+            # get colname w/ max # of data
+            keep = sub.count().idxmax()
+            # drop all columns of name n from original df
+            del df[n]
+            # update original df w/ longest col with name n
+            df[n] = sub[keep]
+
+    return df
+
+
+def to_monthly(series, method="ffill", how="end"):
+    """
+    Convenience method that wraps asfreq_actual
+    with 'M' param (method='ffill', how='end').
+    """
+    return series.asfreq_actual("M", method=method, how=how)
+
+
+def asfreq_actual(series, freq, method="ffill", how="end", normalize=False):
+    """
+    Similar to pandas' asfreq but keeps the actual dates.
+    For example, if last data point in Jan is on the 29th,
+    that date will be used instead of the 31st.
+    """
+    orig = series
+    is_series = False
+    if isinstance(series, pd.Series):
+        is_series = True
+        name = series.name if series.name else "data"
+        orig = pd.DataFrame({name: series})
+
+    # add date column
+    t = pd.concat(
+        [orig, pd.DataFrame({"dt": orig.index.values}, index=orig.index.values)], axis=1
+    )
+    # fetch dates
+    dts = t.asfreq(freq=freq, method=method, how=how, normalize=normalize)["dt"]
+
+    res = orig.loc[dts.values]
+
+    if is_series:
+        return res[name]
+    else:
+        return res
+
+
+def calc_inv_vol_weights(returns):
+    """
+    Calculates weights proportional to inverse volatility of each column.
+    Returns weights that are inversely proportional to the column's
+    volatility resulting in a set of portfolio weights where each position
+    has the same level of volatility.
+    Note, that assets with returns all equal to NaN or 0 are excluded from
+    the portfolio (their weight is set to NaN).
+    Returns:
+        Series {col_name: weight}
+    """
+    # calc vols
+    vol = np.divide(1.0, np.std(returns, ddof=1))
+    vol[np.isinf(vol)] = np.NaN
+    volsum = vol.sum()
+    return np.divide(vol, volsum)
+
+
+def _erc_weights_slsqp(x0, cov, b, maximum_iterations, tolerance):
+    """
+    Calculates the equal risk contribution / risk parity weights given
+        a DataFrame of returns.
+    Args:
+    * x0 (np.array): Starting asset weights.
+    * cov (np.array): covariance matrix.
+    * b (np.array): Risk target weights. By definition target total risk contributions are all equal which makes this redundant.
+    * maximum_iterations (int): Maximum iterations in iterative solutions.
+    * tolerance (float): Tolerance level in iterative solutions.
+    Returns:
+    np.array {weight}
+    You can read more about ERC at
+    http://thierry-roncalli.com/download/erc.pdf
+    """
+
+    def fitness(weights, covar):
+        # total risk contributions
+        # trc = weights*np.matmul(covar,weights)/np.sqrt(np.matmul(weights.T,np.matmul(covar,weights)))
+
+        # instead of using the true definition for trc we will use the optimization on page 5
+        trc = weights * np.matmul(covar, weights)
+
+        n = len(trc)
+        # sum of squared differences of total risk contributions
+        sse = 0.0
+        for i in range(n):
+            for j in range(n):
+                # switched from squared deviations to absolute deviations to avoid numerical instability
+                sse += np.abs(trc[i] - trc[j])
+        # minimizes metric
+        return sse
+
+    # nonnegative
+    bounds = [(0, None) for i in range(len(x0))]
+    # sum of weights must be equal to 1
+    constraints = {"type": "eq", "fun": lambda W: sum(W) - 1.0}
+    options = {"maxiter": maximum_iterations}
+
+    optimized = minimize(
+        fitness,
+        x0,
+        (cov),
+        method="SLSQP",
+        constraints=constraints,
+        bounds=bounds,
+        options=options,
+        tol=tolerance,
+    )
+    # check if success
+    if not optimized.success:
+        raise Exception(optimized.message)
+
+    # return weight vector
+    return optimized.x
+
+
+def _erc_weights_ccd(x0, cov, b, maximum_iterations, tolerance):
+    """
+    Calculates the equal risk contribution / risk parity weights given
+    a DataFrame of returns.
+    Args:
+        * x0 (np.array): Starting asset weights.
+        * cov (np.array): covariance matrix.
+        * b (np.array): Risk target weights.
+        * maximum_iterations (int): Maximum iterations in iterative solutions.
+        * tolerance (float): Tolerance level in iterative solutions.
+    Returns:
+        np.array {weight}
+    Reference:
+        Griveau-Billion, Theophile and Richard, Jean-Charles and Roncalli,
+        Thierry, A Fast Algorithm for Computing High-Dimensional Risk Parity
+        Portfolios (2013).
+        Available at SSRN: https://ssrn.com/abstract=2325255
+    """
+    n = len(x0)
+    x = x0.copy()
+    var = np.diagonal(cov)
+    ctr = cov.dot(x)
+    sigma_x = np.sqrt(x.T.dot(ctr))
+
+    for iteration in range(maximum_iterations):
+
+        for i in range(n):
+            alpha = var[i]
+            beta = ctr[i] - x[i] * alpha
+            gamma = -b[i] * sigma_x
+
+            x_tilde = (-beta + np.sqrt(beta * beta - 4 * alpha * gamma)) / (2 * alpha)
+            x_i = x[i]
+
+            ctr = ctr - cov[i] * x_i + cov[i] * x_tilde
+            sigma_x = sigma_x * sigma_x - 2 * x_i * cov[i].dot(x) + x_i * x_i * var[i]
+            x[i] = x_tilde
+            sigma_x = np.sqrt(
+                sigma_x + 2 * x_tilde * cov[i].dot(x) - x_tilde * x_tilde * var[i]
+            )
+
+        # check convergence
+        if np.power((x - x0) / x.sum(), 2).sum() < tolerance:
+            return x / x.sum()
+
+        x0 = x.copy()
+
+    # no solution found
+    raise ValueError(
+        "No solution found after {0} iterations.".format(maximum_iterations)
+    )
+
+
+def calc_erc_weights(
+    returns,
+    initial_weights=None,
+    risk_weights=None,
+    covar_method="ledoit-wolf",
+    risk_parity_method="ccd",
+    maximum_iterations=100,
+    tolerance=1e-8,
+):
+    """
+    Calculates the equal risk contribution / risk parity weights given a
+    DataFrame of returns.
+    Args:
+        * returns (DataFrame): Returns for multiple securities.
+        * initial_weights (list): Starting asset weights [default inverse vol].
+        * risk_weights (list): Risk target weights [default equal weight].
+        * covar_method (str): Covariance matrix estimation method.
+            Currently supported:
+                - `ledoit-wolf <http://www.ledoit.net/honey.pdf>`_ [default]
+                - standard
+        * risk_parity_method (str): Risk parity estimation method.
+            Currently supported:
+                - ccd (cyclical coordinate descent)[default]
+                - slsqp (scipy's implementation of sequential least squares programming)
+        * maximum_iterations (int): Maximum iterations in iterative solutions.
+        * tolerance (float): Tolerance level in iterative solutions.
+    Returns:
+        Series {col_name: weight}
+    """
+    n = len(returns.columns)
+
+    # calc covariance matrix
+    if covar_method == "ledoit-wolf":
+        covar = sklearn.covariance.ledoit_wolf(returns)[0]
+    elif covar_method == "standard":
+        covar = returns.cov().values
+    else:
+        raise NotImplementedError("covar_method not implemented")
+
+    # initial weights (default to inverse vol)
+    if initial_weights is None:
+        inv_vol = 1.0 / np.sqrt(np.diagonal(covar))
+        initial_weights = inv_vol / inv_vol.sum()
+
+    # default to equal risk weight
+    if risk_weights is None:
+        risk_weights = np.ones(n) / n
+
+    # calc risk parity weights matrix
+    if risk_parity_method == "ccd":
+        # cyclical coordinate descent implementation
+        erc_weights = _erc_weights_ccd(
+            initial_weights, covar, risk_weights, maximum_iterations, tolerance
+        )
+    elif risk_parity_method == "slsqp":
+        # scipys slsqp optimizer
+        erc_weights = _erc_weights_slsqp(
+            initial_weights, covar, risk_weights, maximum_iterations, tolerance
+        )
+
+    else:
+        raise NotImplementedError("risk_parity_method not implemented")
+
+    # return erc weights vector
+    return pd.Series(erc_weights, index=returns.columns, name="erc")
+
+
+def get_num_days_required(offset, period="d", perc_required=0.90):
+    """
+    Estimates the number of days required to assume that data is OK.
+    Helper function used to determine if there are enough "good" data
+    days over a given period.
+    Args:
+        * offset (DateOffset): Offset (lookback) period.
+        * period (str): Period string.
+        * perc_required (float): percentage of number of days
+            expected required.
+    """
+    x = pd.to_datetime("2010-01-01")
+    delta = x - (x - offset)
+    # convert to 'trading days' - rough guestimate
+    days = delta.days * 0.69
+
+    if period == "d":
+        req = days * perc_required
+    elif period == "m":
+        req = (days / 20) * perc_required
+    elif period == "y":
+        req = (days / 252) * perc_required
+    else:
+        raise NotImplementedError("period not supported. Supported periods are d, m, y")
+
+    return req
+
+
+
+def calc_ftca(returns, threshold=0.5):
+    """
+    Implementation of David Varadi's `Fast Threshold Clustering Algorithm (FTCA) <http://cssanalytics.wordpress.com/2013/11/26/fast-threshold-clustering-algorithm-ftca/>`_.
+    http://cssanalytics.wordpress.com/2013/11/26/fast-threshold-clustering-algorithm-ftca/  # NOQA
+    More stable than k-means for clustering purposes.
+    If you want more clusters, use a higher threshold.
+    Args:
+        * returns - expects a pandas dataframe of returns where
+            each column is the name of a given security.
+        * threshold (float): Threshold parameter - use higher value
+            for more clusters. Basically controls how similar
+            (correlated) series have to be.
+    Returns:
+        dict of cluster name (a number) and list of securities in cluster
+    """
+    # cluster index (name)
+    i = 0
+    # correlation matrix
+    corr = returns.corr()
+    # remaining securities to cluster
+    remain = list(corr.index.copy())
+    n = len(remain)
+    res = {}
+
+    while n > 0:
+        # if only one left then create cluster and finish
+        if n == 1:
+            i += 1
+            res[i] = remain
+            n = 0
+        # if not then we have some work to do
+        else:
+            # filter down correlation matrix to current remain
+            cur_corr = corr[remain].loc[remain]
+            # get mean correlations, ordered
+            mc = cur_corr.mean().sort_values()
+            # get lowest and highest mean correlation
+            low = mc.index[0]
+            high = mc.index[-1]
+
+            # case if corr(high,low) > threshold
+            if corr[high][low] > threshold:
+                i += 1
+
+                # new cluster for high and low
+                res[i] = [low, high]
+                remain.remove(low)
+                remain.remove(high)
+
+                rmv = []
+                for x in remain:
+                    avg_corr = (corr[x][high] + corr[x][low]) / 2.0
+                    if avg_corr > threshold:
+                        res[i].append(x)
+                        rmv.append(x)
+                [remain.remove(x) for x in rmv]
+
+                n = len(remain)
+
+            # otherwise we are creating two clusters - one for high
+            # and one for low
+            else:
+                # add cluster with HC
+                i += 1
+                res[i] = [high]
+                remain.remove(high)
+                remain.remove(low)
+
+                rmv = []
+                for x in remain:
+                    if corr[x][high] > threshold:
+                        res[i].append(x)
+                        rmv.append(x)
+                [remain.remove(x) for x in rmv]
+
+                i += 1
+                res[i] = [low]
+
+                rmv = []
+                for x in remain:
+                    if corr[x][low] > threshold:
+                        res[i].append(x)
+                        rmv.append(x)
+                [remain.remove(x) for x in rmv]
+
+                n = len(remain)
+
+    return res
+
+
+def limit_weights(weights, limit=0.1):
+    """
+    Limits weights and redistributes excedent amount
+    proportionally.
+    ex:
+        - weights are {a: 0.7, b: 0.2, c: 0.1}
+        - call with limit=0.5
+        - excess 0.2 in a is ditributed to b and c
+            proportionally.
+            - result is {a: 0.5, b: 0.33, c: 0.167}
+    Args:
+        * weights (Series): A series describing the weights
+        * limit (float): Maximum weight allowed
+    """
+    if 1.0 / limit > len(weights):
+        raise ValueError("invalid limit -> 1 / limit must be <= len(weights)")
+
+    if isinstance(weights, dict):
+        weights = pd.Series(weights)
+
+    if np.round(weights.sum(), 1) != 1.0:
+        raise ValueError(
+            "Expecting weights (that sum to 1) - sum is %s" % weights.sum()
+        )
+
+    res = np.round(weights.copy(), 4)
+    to_rebalance = (res[res > limit] - limit).sum()
+
+    ok = res[res < limit]
+    ok += (ok / ok.sum()) * to_rebalance
+
+    res[res > limit] = limit
+    res[res < limit] = ok
+
+    if any(x > limit for x in res):
+        return limit_weights(res, limit=limit)
+
+    return res
+
+
+def random_weights(n, bounds=(0.0, 1.0), total=1.0):
+    """
+    Generate pseudo-random weights.
+    Returns a list of random weights that is of length
+    n, where each weight is in the range bounds, and
+    where the weights sum up to total.
+    Useful for creating random portfolios when benchmarking.
+    Args:
+        * n (int): number of random weights
+        * bounds ((low, high)): bounds for each weight
+        * total (float): total sum of the weights
+    """
+    low = bounds[0]
+    high = bounds[1]
+
+    if high < low:
+        raise ValueError("Higher bound must be greater or " "equal to lower bound")
+
+    if n * high < total or n * low > total:
+        raise ValueError("solution not possible with given n and bounds")
+
+    w = [0] * n
+    tgt = -float(total)
+
+    for i in range(n):
+        rn = n - i - 1
+        rhigh = rn * high
+        rlow = rn * low
+
+        lowb = max(-rhigh - tgt, low)
+        highb = min(-rlow - tgt, high)
+
+        rw = random.uniform(lowb, highb)
+        w[i] = rw
+
+        tgt += rw
+
+    random.shuffle(w)
+    return w
+
+
+def plot_heatmap(
+    data,
+    title="Heatmap",
+    show_legend=True,
+    show_labels=True,
+    label_fmt=".2f",
+    vmin=None,
+    vmax=None,
+    figsize=None,
+    label_color="w",
+    cmap="RdBu",
+    **kwargs
+):
+    """
+    Plot a heatmap using matplotlib's pcolor.
+    Args:
+        * data (DataFrame): DataFrame to plot. Usually small matrix (ex.
+            correlation matrix).
+        * title (string): Plot title
+        * show_legend (bool): Show color legend
+        * show_labels (bool): Show value labels
+        * label_fmt (str): Label format string
+        * vmin (float): Min value for scale
+        * vmax (float): Max value for scale
+        * cmap (string): Color map
+        * kwargs: Passed to matplotlib's pcolor
+    """
+    fig, ax = plt.subplots(figsize=figsize)
+
+    heatmap = ax.pcolor(data, vmin=vmin, vmax=vmax, cmap=cmap)
+    # for some reason heatmap has the y values backwards....
+    ax.invert_yaxis()
+
+    if title is not None:
+        plt.title(title)
+
+    if show_legend:
+        fig.colorbar(heatmap)
+
+    if show_labels:
+        vals = data.values
+        for x in range(data.shape[0]):
+            for y in range(data.shape[1]):
+                plt.text(
+                    x + 0.5,
+                    y + 0.5,
+                    format(vals[y, x], label_fmt),
+                    horizontalalignment="center",
+                    verticalalignment="center",
+                    color=label_color,
+                )
+
+    plt.yticks(np.arange(0.5, len(data.index), 1), data.index)
+    plt.xticks(np.arange(0.5, len(data.columns), 1), data.columns)
+
+    return plt
+
+
+def plot_corr_heatmap(data, **kwargs):
+    """
+    Plots the correlation heatmap for a given DataFrame.
+    """
+    return plot_heatmap(data.corr(), vmin=-1, vmax=1, **kwargs)
+
+
+def rollapply(data, window, fn):
+    """
+    Apply a function fn over a rolling window of size window.
+    Args:
+        * data (Series or DataFrame): Series or DataFrame
+        * window (int): Window size
+        * fn (function): Function to apply over the rolling window.
+            For a series, the return value is expected to be a single
+            number. For a DataFrame, it shuold return a new row.
+    Returns:
+        * Object of same dimensions as data
+    """
+    res = data.copy()
+    res[:] = np.nan
+    n = len(data)
+
+    if window > n:
+        return res
+
+    for i in range(window - 1, n):
+        res.iloc[i] = fn(data.iloc[i - window + 1 : i + 1])
+
+    return res
+
+
+def _winsorize_wrapper(x, limits):
+    """
+    Wraps scipy winsorize function to drop na's
+    """
+    if isinstance(x, pd.Series):
+        if x.count() == 0:
+            return x
+
+        notnanx = ~np.isnan(x)
+        x[notnanx] = scipy.stats.mstats.winsorize(x[notnanx], limits=limits)
+        return x
+    else:
+        return scipy.stats.mstats.winsorize(x, limits=limits)
+
+
+def winsorize(x, axis=0, limits=0.01):
+    """
+    `Winsorize <https://en.wikipedia.org/wiki/Winsorizing>`_ values based on limits
+    """
+    # operate on copy
+    x = x.copy()
+
+    if isinstance(x, pd.DataFrame):
+        return x.apply(_winsorize_wrapper, axis=axis, args=(limits,))
+    else:
+        return pd.Series(_winsorize_wrapper(x, limits).values, index=x.index)
+
+
+def rescale(x, min=0.0, max=1.0, axis=0):
+    """
+    Rescale values to fit a certain range [min, max]
+    """
+
+    def innerfn(x, min, max):
+        return np.interp(x, [np.min(x), np.max(x)], [min, max])
+
+    if isinstance(x, pd.DataFrame):
+        return x.apply(
+            innerfn,
+            axis=axis,
+            args=(
+                min,
+                max,
+            ),
+        )
+    else:
+        return pd.Series(innerfn(x, min, max), index=x.index)
+
+
+def annualize(returns, durations, one_year=365.0):
+    """
+    Annualize returns using their respective durations.
+    Formula used is:
+        (1 + returns) ** (1 / (durations / one_year)) - 1
+    """
+    return np.power(1.0 + returns, 1.0 / (durations / one_year)) - 1.0
+
+
+def deannualize(returns, nperiods):
+    """
+    Convert return expressed in annual terms on a different basis.
+    Args:
+        * returns (float, Series, DataFrame): Return(s)
+        * nperiods (int): Target basis, typically 252 for daily, 12 for
+            monthly, etc.
+    """
+    return np.power(1 + returns, 1.0 / nperiods) - 1.0
+
+
+def calc_sortino_ratio(returns, rf=0.0, nperiods=None, annualize=True):
+    """
+    Calculates the `Sortino ratio <https://www.investopedia.com/terms/s/sortinoratio.asp>`_ given a series of returns
+    (see `Sharpe vs. Sortino <https://www.investopedia.com/ask/answers/010815/what-difference-between-sharpe-ratio-and-sortino-ratio.asp>`_).
+    Args:
+        * returns (Series or DataFrame): Returns
+        * rf (float, Series): `Risk-free rate <https://www.investopedia.com/terms/r/risk-freerate.asp>`_ expressed in yearly (annualized) terms or return series.
+        * nperiods (int): Number of periods used for annualization. Must be
+            provided if rf is non-zero and rf is not a price series
+    """
+    # if type(rf) is float and rf != 0 and nperiods is None:
+    if isinstance(rf, float) and rf != 0 and nperiods is None:
+        raise Exception("nperiods must be set if rf != 0 and rf is not a price series")
+
+    er = returns.to_excess_returns(rf, nperiods=nperiods)
+
+    negative_returns = np.minimum(er[1:], 0.0)
+    std = np.std(negative_returns, ddof=1)
+    if std != 0:
+        res = np.divide(er.mean(), std)
+    else:
+        res = np.nan
+
+    if annualize:
+        if nperiods is None:
+            nperiods = 1
+        return res * np.sqrt(nperiods)
+
+    return res
+
+
+def to_excess_returns(returns, rf, nperiods=None):
+    """
+    Given a series of returns, it will return the excess returns over rf.
+    Args:
+        * returns (Series, DataFrame): Returns
+        * rf (float, Series): `Risk-Free rate(s) <https://www.investopedia.com/terms/r/risk-freerate.asp>`_ expressed in annualized term or return series
+        * nperiods (int): Optional. If provided, will convert rf to different
+            frequency using deannualize only if rf is a float
+    Returns:
+        * excess_returns (Series, DataFrame): Returns - rf
+    """
+    # if type(rf) is float and nperiods is not None:
+    if isinstance(rf, float) and nperiods is not None:
+
+        _rf = deannualize(rf, nperiods)
+    else:
+        _rf = rf
+
+    return returns - _rf
+
+
+def calc_calmar_ratio(prices):
+    """
+    Calculates the `Calmar ratio <https://www.investopedia.com/terms/c/calmarratio.asp>`_ given a series of prices
+    Args:
+        * prices (Series, DataFrame): Price series
+    """
+    return np.divide(prices.calc_cagr(), abs(prices.calc_max_drawdown()))
+
+
+def to_ulcer_index(prices):
+    """
+    Converts from prices -> `Ulcer index <https://www.investopedia.com/terms/u/ulcerindex.asp>`_
+    See https://en.wikipedia.org/wiki/Ulcer_index
+    Args:
+        * prices (Series, DataFrame): Prices
+    """
+    dd = prices.to_drawdown_series()
+    return np.divide(np.sqrt(np.sum(np.power(dd, 2))), dd.count())
+
+
+def to_ulcer_performance_index(prices, rf=0.0, nperiods=None):
+    """
+    Converts from prices -> `ulcer performance index <https://www.investopedia.com/terms/u/ulcerindex.asp>`_.
+    See https://en.wikipedia.org/wiki/Ulcer_index
+    Args:
+        * prices (Series, DataFrame): Prices
+        * rf (float, Series): `Risk-free rate of return <https://www.investopedia.com/terms/r/risk-freerate.asp>`_. Assumed to be expressed in
+            yearly (annualized) terms or return series
+        * nperiods (int): Used to deannualize rf if rf is provided (non-zero)
+    """
+    # if type(rf) is float and rf != 0 and nperiods is None:
+    if isinstance(rf, float) and rf != 0 and nperiods is None:
+        raise Exception("nperiods must be set if rf != 0 and rf is not a price series")
+
+    er = prices.to_returns().to_excess_returns(rf, nperiods=nperiods)
+
+    return np.divide(er.mean(), prices.to_ulcer_index())
+
+
+def resample_returns(returns, func, seed=0, num_trials=100):
+    """
+    Resample the returns and calculate any statistic on every new sample.
+    https://en.wikipedia.org/wiki/Resampling_(statistics)
+    :param returns (Series, DataFrame): Returns
+    :param func: Given the resampled returns calculate a statistic
+    :param seed: Seed for random number generator
+    :param num_trials: Number of times to resample and run the experiment
+    :return: Series of resampled statistics
+    """
+
+    # stats = []
+    if type(returns) is pd.Series:
+        stats = pd.Series(index=range(num_trials))
+    elif type(returns) is pd.DataFrame:
+        stats = pd.DataFrame(index=range(num_trials), columns=returns.columns)
+    else:
+        raise (TypeError("returns needs to be a Series or DataFrame!"))
+
+    n = returns.shape[0]
+    for i in range(num_trials):
+        random_indices = resample(returns.index, n_samples=n, random_state=seed + i)
+        stats.loc[i] = func(returns.loc[random_indices])
+
+    return stats
+
+
+def extend_pandas():
+    """
+    Extends pandas' PandasObject (Series, Series,
+    DataFrame) with some functions defined in this file.
+    This facilitates common functional composition used in quant
+    finance.
+    Ex:
+        prices.to_returns().dropna().calc_clusters()
+        (where prices would be a DataFrame)
+    """
+    PandasObject.to_returns = to_returns
+    PandasObject.to_log_returns = to_log_returns
+    PandasObject.to_price_index = to_price_index
+    PandasObject.rebase = rebase
+    PandasObject.calc_perf_stats = calc_perf_stats
+    PandasObject.to_drawdown_series = to_drawdown_series
+    PandasObject.calc_max_drawdown = calc_max_drawdown
+    PandasObject.calc_cagr = calc_cagr
+    PandasObject.calc_total_return = calc_total_return
+    PandasObject.as_percent = as_percent
+    PandasObject.as_format = as_format
+    PandasObject.to_monthly = to_monthly
+    PandasObject.asfreq_actual = asfreq_actual
+    PandasObject.drop_duplicate_cols = drop_duplicate_cols
+    PandasObject.calc_information = calc_information_ratio
+    PandasObject.calc_information_ratio = calc_information_ratio
+    PandasObject.calc_prob_mom = calc_prob_mom
+    PandasObject.calc_risk_return = calc_risk_return_ratio
+    PandasObject.calc_risk_return_ratio = calc_risk_return_ratio
+    PandasObject.calc_erc_weights = calc_erc_weights
+    PandasObject.calc_inv_vol_weights = calc_inv_vol_weights
+    PandasObject.calc_ftca = calc_ftca
+    PandasObject.calc_stats = calc_stats
+    PandasObject.plot_heatmap = plot_heatmap
+    PandasObject.plot_corr_heatmap = plot_corr_heatmap
+    PandasObject.rollapply = rollapply
+    PandasObject.winsorize = winsorize
+    PandasObject.rescale = rescale
+    PandasObject.calc_sortino = calc_sortino_ratio
+    PandasObject.calc_sortino_ratio = calc_sortino_ratio
+    PandasObject.calc_calmar = calc_calmar_ratio
+    PandasObject.calc_calmar_ratio = calc_calmar_ratio
+    PandasObject.calc_sharpe = calc_sharpe
+    PandasObject.calc_sharpe_ratio = calc_sharpe
+    PandasObject.to_excess_returns = to_excess_returns
+    PandasObject.to_ulcer_index = to_ulcer_index
+    PandasObject.to_ulcer_performance_index = to_ulcer_performance_index
+
+extend_pandas()
```

## finlab/market_info.py

 * *Ordering differences only*

```diff
@@ -1,513 +1,513 @@
-import logging
-import datetime
-import numpy as np
-import pandas as pd
-from typing import Dict, Optional, Union
-
-import sys
-if sys.platform != 'emscripten':
-    from multiprocessing import shared_memory
-
-import finlab.data
-
-class MarketInfo():
-    """市場類別
-    假如希望開發新的交易市場套用到回測系統，可以繼承 `finlab.market_info.MarketInfo` 來實做新類別。
-    """
-    @staticmethod
-    def get_freq() -> str:
-        """
-        Returns the frequency of the data.
-        Used to determine how to resample the data when the data is not daily.
-        The freq will be saved in `finlab.core.report`.
-        
-        Returns:
-        str: The frequency of the data.
-        """
-        return '1d'
-
-    @staticmethod
-    def get_name() -> str:
-        """
-        Returns the name of the market data source.
-        
-        This function is used to get the name of the market data source.
-        """
-        return 'auto'
-
-    @staticmethod
-    def get_benchmark() -> pd.Series:
-        """設定對標報酬率的時間序列
-        
-        這個函數用於設定對標報酬率的時間序列。
-
-        Returns:
-            pd.Series: 時間序列的報酬率。
-
-        Raises:
-            ExceptionType: Description of conditions under which the exception is raised.
-
-        Examples:
-            | date       |   0050 |
-            |:-----------|-------:|
-            | 2007-04-23 |   100 |
-            | 2007-04-24 |   100.1 |
-            | 2007-04-25 |   99 |
-            | 2007-04-26 |   98.3 |
-            | 2007-04-27 |   99.55 |
-        """
-        return pd.Series([], index=pd.Index([], dtype='datetime64[ns]'), dtype='float64')
-
-    @staticmethod
-    def get_asset_id_to_name() -> Dict:
-        """設定對標報酬率的時間序列
-        Returns:
-          (dict): 股號與股名對照表，ex:`{'2330':'台積電'}`
-        """
-        return {}
-
-    @staticmethod
-    def get_price(trade_at_price:str, adj:bool=True) -> pd.DataFrame:
-        """取得回測用價格數據
-
-        Args:
-           trade_at_price (str): 選擇回測之還原股價以收盤價或開盤價計算，預設為'close'。可選'close'或'open'。
-           adj (str): 是否使用還原股價計算。
-        
-        Returns:
-          (pd.DataFrame): 價格數據
-        
-        Examples:
-            格式範例
-
-            | date       |   0015 |   0050 |   0051 |   0052 |
-            |:-----------|-------:|-------:|-------:|-------:|
-            | 2007-04-23 |   9.54 |  57.85 |  32.83 |  38.4  |
-            | 2007-04-24 |   9.54 |  58.1  |  32.99 |  38.65 |
-            | 2007-04-25 |   9.52 |  57.6  |  32.8  |  38.59 |
-            | 2007-04-26 |   9.59 |  57.7  |  32.8  |  38.6  |
-            | 2007-04-27 |   9.55 |  57.5  |  32.72 |  38.4  |
-            """
-        return pd.DataFrame()
-
-    @staticmethod
-    def get_market_value():
-        """取得回測用市值數據
-
-        Returns:
-          (pd.DataFrame): 市值數據，其中 index 為日期，而 columns 是股票代號。
-
-        """
-        return pd.DataFrame()
-
-    def get_trading_price(self, name: str, adj=True) -> pd.DataFrame:
-
-        """取得回測用價格數據
-        
-        Args:
-            name (str): 選擇回測之還原股價以收盤價或開盤價計算，預設為'close'。可選 'open'、'close'、'high'、'low'、'open_close_avg'、'high_low_avg'、或 'price_avg'。
-        Returns:
-            (pd.DataFrame): 價格數據
-
-        """
-
-
-        if name in ['open', 'close', 'high', 'low']:
-            return self.get_price(name, adj=adj)
-        elif name == 'close_open_avg' or name == 'open_close_avg':
-            return (self.get_price('open', adj=adj) + self.get_price('close', adj=adj)) / 2
-        elif name == 'high_low_avg' or name == 'low_high_avg':
-            return (self.get_price('high', adj=adj) + self.get_price('low', adj=adj)) / 2
-        elif name == 'price_avg':
-            return (self.get_price('open', adj=adj) + self.get_price('close', adj=adj)\
-                     + self.get_price('high', adj=adj) + self.get_price('low', adj=adj)) / 4
-
-        raise ValueError(f"Unknown trade price name: {name}")
-    
-
-    def market_close_at_timestamp(self, timestamp=None):
-        """
-        Returns the timestamp of the market close of the given timestamp.
-
-        Args:
-            timestamp (datetime): The timestamp to find the market close to.
-
-        Returns:
-            datetime: The timestamp of the closest market close.
-        """
-
-        indexes = self.get_price('close').index
-
-        if timestamp is None:
-            timestamp = indexes[-1]
-
-        # find min delta between indexes
-        delta = np.abs(indexes[1:] - indexes[:-1]).min()
-        return timestamp + delta
-    
-    def get_reference_price(self):
-        """Returns the most recent reference price of the market.
-        
-        Returns:
-            pandas.Series: The most recent reference price of the market.
-        """
-        return self.get_price('close').iloc[-1]
-    
-    @staticmethod
-    def tzinfo():
-        """Returns the timezone of the market.
-        
-        Returns:
-            datetime.timezone: The timezone of the market.
-        """
-        return None
-
-    @staticmethod
-    def get_odd_lot():
-        """Returns the odd lot size of the market.
-
-        Returns:
-            int: The odd lot size of the market.
-        """
-        return 1
-
-
-class TWMarketInfo(MarketInfo):
-
-    @staticmethod
-    def get_freq():
-        return '1d'
-
-    @staticmethod
-    def get_name():
-        return 'tw_stock'
-
-    @staticmethod
-    def get_benchmark() -> pd.Series:
-        return finlab.data.get('benchmark_return:發行量加權股價報酬指數').squeeze()
-
-    @staticmethod
-    def get_asset_id_to_name():
-        categories = finlab.data.get('security_categories')
-        stock_names = dict(
-            zip(categories.reset_index()['stock_id'], categories['name']))
-
-        return stock_names
-
-    @staticmethod
-    def get_price(trade_at_price, adj=True):
-        if isinstance(trade_at_price, pd.Series):
-            return trade_at_price.to_frame()
-
-        if isinstance(trade_at_price, pd.DataFrame):
-            return trade_at_price
-
-        if isinstance(trade_at_price, str):
-            if trade_at_price == 'volume':
-                return finlab.data.get('price:成交股數')
-
-            if adj:
-                table_name = 'etl:adj_'
-                price_name = trade_at_price
-            else:
-                table_name = 'price:'
-                price_name = {'open': '開盤價', 'close': '收盤價', 'high': '最高價', 'low': '最低價'}[trade_at_price]
-
-            price = finlab.data.get(f'{table_name}{price_name}')
-            return price
-
-        raise ValueError('trade_at_price is not allowed (accepted types: pd.DataFrame, pd.Series, str).')
-
-    @staticmethod
-    def get_market_value():
-        return finlab.data.get('etl:market_value')
-    
-
-    def market_close_at_timestamp(self, timestamp=None):
-
-        if not isinstance(timestamp, pd.Timestamp) and timestamp is not None:
-            timestamp = pd.Timestamp(timestamp).tz_localize('Asia/Taipei')
-
-        if timestamp is None:
-            timestamp = pd.Timestamp.now().tz_localize('Asia/Taipei')
-
-        # check if timestamp is localized, if not, localize it to Asia/Taipei
-        if timestamp.tzinfo is None:
-            timestamp = timestamp.tz_localize('Asia/Taipei')
-        
-        # get market close time
-        market_close = pd.Timestamp(timestamp.date()) + pd.Timedelta('15:00:00')
-        return market_close.tz_localize('Asia/Taipei')
-    
-    @staticmethod
-    def tzinfo():
-        return datetime.timezone(datetime.timedelta(hours=8))
-    
-    @staticmethod
-    def get_reference_price():
-        ref_price = finlab.data.get('reference_price')
-        return ref_price.set_index('stock_id')['收盤價'].to_dict()
-
-    @staticmethod
-    def get_odd_lot():
-        return 1000
-
-
-class USMarketInfo(MarketInfo):
-
-    @staticmethod
-    def get_freq():
-        return '1d'
-
-    @staticmethod
-    def get_name():
-        return 'us_stock'
-
-    @staticmethod
-    def get_benchmark():
-        return finlab.data.get('world_index:adj_close')['^GSPC']
-
-    @staticmethod
-    def get_asset_id_to_name():
-        categories = finlab.data.get('us_tickers')
-        stock_names = dict(
-            zip(categories['stock_id'], categories['name']))
-        return stock_names
-
-    @staticmethod
-    def get_price(trade_at_price, adj=True):
-        if isinstance(trade_at_price, pd.Series):
-            return trade_at_price.to_frame()
-
-        if isinstance(trade_at_price, pd.DataFrame):
-            return trade_at_price
-
-        if isinstance(trade_at_price, str):
-            if trade_at_price == 'volume':
-                return finlab.data.get('us_price:volume')
-
-            if adj:
-                table_name = 'us_price:adj_'
-                price_name = trade_at_price
-            else:
-                table_name = 'us_price:'
-                price_name = trade_at_price
-
-            price = finlab.data.get(f'{table_name}{price_name}')
-            return price
-
-        raise ValueError('trade_at_price is not allowed. Accepted types are pd.DataFrame, pd.Series, and str.')
-    
-
-    def market_close_at_timestamp(self, timestamp=None):
-
-        if timestamp is None:
-            timestamp = self.get_price('close').index[-1]
-
-        # check if timestamp is localized, if not, localize it to US/Eastern
-        if timestamp.tzinfo is None or timestamp.tzinfo.utcoffset(timestamp) is None:
-            timestamp = timestamp.tz_localize('US/Eastern')
-
-        # get market close time
-        market_close = pd.Timestamp(timestamp.date()) + pd.Timedelta('16:00:00')
-        return market_close.tz_localize('US/Eastern')
-
-    @staticmethod    
-    def tzinfo():
-        return datetime.timezone(datetime.timedelta(hours=-4))
-
-
-class USAllMarketInfo(USMarketInfo):
-    @staticmethod
-    def get_price(trade_at_price, adj=True):
-        if isinstance(trade_at_price, pd.Series):
-            return trade_at_price.to_frame()
-
-        if isinstance(trade_at_price, pd.DataFrame):
-            return trade_at_price
-
-        if isinstance(trade_at_price, str):
-            if trade_at_price == 'volume':
-                return finlab.data.get('us_price_all:volume')
-
-            if adj:
-                table_name = 'us_price_all:adj_'
-                price_name = trade_at_price
-            else:
-                table_name = 'us_price_all:'
-                price_name = trade_at_price
-
-            price = finlab.data.get(f'{table_name}{price_name}')
-            return price
-
-        raise Exception(f'**ERROR: trade_at_price is not allowed (accepted types: pd.DataFrame, pd.Series, str).')
-
-    @staticmethod
-    def get_market_value():
-        return finlab.data.get('us_fundamental:marketcap')
-
-
-def get_market_info(df:Union[None, pd.DataFrame, pd.Series]=None, 
-                    user_market_info:Union[None, str, MarketInfo]='AUTO') -> Optional[MarketInfo]:
-
-    
-    # return market info base on user_market_info
-    if user_market_info == 'TW_STOCK':
-        return TWMarketInfo()
-
-    if user_market_info == 'US_STOCK':
-        return USMarketInfo()
-
-    if user_market_info == 'US_STOCK_ALL':
-        return USAllMarketInfo()
-
-    if user_market_info != 'AUTO':
-        return user_market_info
-
-    # deal with user_market_info == 'AUTO'
-    if df is not None:
-        ids = set([df.name]) if isinstance(df, pd.Series) else set(df.columns)
-        for market in [TWMarketInfo(), USMarketInfo()]:
-            market_ids = set(market.get_asset_id_to_name().keys())
-            id_not_found = ids - market_ids
-
-            if len(id_not_found) / len(ids) < 0.5:
-                if len(id_not_found):
-                    logging.warning(f"Symbols {str(id_not_found)[:30]}... not found in MarketInfo.")
-                return market
-
-    raise Exception("Market cannot be determined automatically. "
-                    "Please set the market argument to either "
-                    "'TW_STOCK' for Taiwan stock market, 'US_STOCK' "
-                    "for US stock market, or use subclass of MarketInfo"
-                    " to specify a different market.")
-
-
-def create_shared_memory_from_df(df, name):
-    """Create a shared memory from a pandas DataFrame."""
-
-    names = [name, name+'_index', name+'_columns']
-    for name in names:
-        try:
-            shm = shared_memory.SharedMemory(name=name)
-            shm.close()
-            shm.unlink()
-
-        except FileNotFoundError:
-            pass
-
-    # create
-    array = df.to_numpy()
-    shm = shared_memory.SharedMemory(create=True, size=array.nbytes, name=name)
-    np_array = np.ndarray(array.shape, dtype=array.dtype, buffer=shm.buf)
-    np_array[:] = array[:]
-
-    # index
-    array_index = df.index.to_numpy()
-    shm_index = shared_memory.SharedMemory(create=True, size=array_index.nbytes, name=name+'_index')
-    np_array_index = np.ndarray(array_index.shape, dtype=array_index.dtype, buffer=shm_index.buf)
-    np_array_index[:] = array_index[:]
-
-    # columns
-    array_columns = df.columns.to_numpy()
-    shm_columns = shared_memory.SharedMemory(create=True, size=array_columns.nbytes, name=name+'_columns')
-    np_array_columns = np.ndarray(array_columns.shape, dtype=array_columns.dtype, buffer=shm_columns.buf)
-    np_array_columns[:] = array_columns[:]
-    # return shm, array.shape, array.dtype
-
-    return shm, array.shape, array.dtype, \
-        shm_index, array_index.shape, array_index.dtype, \
-        shm_columns, array_columns.shape, array_columns.dtype
-
-def create_df_from_shared_memory(shm, shape, dtype, shm_index, index_shape, index_dtype, shm_columns, columns_shape, columns_dtype):
-    """Create a pandas DataFrame from a shared memory."""
-
-    np_array = np.ndarray(shape, dtype=dtype, buffer=shm.buf) # np.frombuffer(shm.buf).reshape(shape)#
-    np_array_index = np.ndarray(index_shape, dtype=index_dtype, buffer=shm_index.buf)
-    return pd.DataFrame(np_array, index=np_array_index, )
-
-
-class MarketInfoSharedMemory(MarketInfo):
-
-    names = ['close', 'open', 'high', 'low', 'volume']
-
-    def __init__(self, market:MarketInfo, adj=True, start_time=None, end_time=None):
-
-        self.df_args = []
-        self.cache = {}
-        self.localize = None
-
-        shape_check = None
-
-        # fetch all dataframe and set localize to None (because localize is not supported in shared memory)
-        dfs = {}
-        for n in self.names:
-            df = market.get_price(n, adj=adj).loc[start_time:end_time].dropna(axis=1, how='all')
-
-            # get localize
-            if self.localize is None:
-                self.localize = df.index.tzinfo
-            else:
-                if self.localize != df.index.tzinfo:
-                    raise Exception("The timezone of the data is not the same. "
-                                    "Please check if the timezone of the data is correct.")
-                
-            self.cache[n] = df.copy()
-                
-            df.index = df.index.tz_localize(None)
-            dfs[n] = df
-
-        # intersection of columns of dataframe
-        columns = dfs['close'].columns.copy()
-        for name in dfs:
-            columns = columns.intersection(dfs[name].columns)
-
-        # reshape dataframe
-        for name, df in dfs.items():
-            dfs[name] = df[columns]
-
-        for n, df in dfs.items():
-            shape = df.shape
-            args = create_shared_memory_from_df(df, n)
-            self.df_args.append(args)
-
-            # check shape
-            if shape_check is None:
-                shape_check = shape
-            else:
-                if shape_check != shape:
-                    raise Exception("Shape of open, high, low, close, volume are not the same. "
-                                    "This is because the data is not updated yet. "
-                                    "Please try again few minutes later.")
-
-    def to_args(self):
-        return self.df_args + [self.localize]
-    
-    @classmethod
-    def from_args(cls, args):
-        self = cls.__new__(cls)
-        self.df_args = args[:-1]
-        self.localize = args[-1]
-        self.cache = {}
-        return self
-
-    def get_price(self, name, adj=True):
-
-        if name in self.cache:
-            return self.cache[name]
-        
-        args = self.df_args[self.names.index(name)]
-        df = create_df_from_shared_memory(*args)
-
-        df.index = df.index.tz_localize(self.localize)
-        self.cache[name] = df
-        return df
-
-    def close(self):
-        for args in self.df_args:
-            args[0].close()
-            args[0].unlink()
-            args[3].close()
-            args[3].unlink()
-            args[6].close()
-            args[6].unlink()
+import logging
+import datetime
+import numpy as np
+import pandas as pd
+from typing import Dict, Optional, Union
+
+import sys
+if sys.platform != 'emscripten':
+    from multiprocessing import shared_memory
+
+import finlab.data
+
+class MarketInfo():
+    """市場類別
+    假如希望開發新的交易市場套用到回測系統，可以繼承 `finlab.market_info.MarketInfo` 來實做新類別。
+    """
+    @staticmethod
+    def get_freq() -> str:
+        """
+        Returns the frequency of the data.
+        Used to determine how to resample the data when the data is not daily.
+        The freq will be saved in `finlab.core.report`.
+        
+        Returns:
+        str: The frequency of the data.
+        """
+        return '1d'
+
+    @staticmethod
+    def get_name() -> str:
+        """
+        Returns the name of the market data source.
+        
+        This function is used to get the name of the market data source.
+        """
+        return 'auto'
+
+    @staticmethod
+    def get_benchmark() -> pd.Series:
+        """設定對標報酬率的時間序列
+        
+        這個函數用於設定對標報酬率的時間序列。
+
+        Returns:
+            pd.Series: 時間序列的報酬率。
+
+        Raises:
+            ExceptionType: Description of conditions under which the exception is raised.
+
+        Examples:
+            | date       |   0050 |
+            |:-----------|-------:|
+            | 2007-04-23 |   100 |
+            | 2007-04-24 |   100.1 |
+            | 2007-04-25 |   99 |
+            | 2007-04-26 |   98.3 |
+            | 2007-04-27 |   99.55 |
+        """
+        return pd.Series([], index=pd.Index([], dtype='datetime64[ns]'), dtype='float64')
+
+    @staticmethod
+    def get_asset_id_to_name() -> Dict:
+        """設定對標報酬率的時間序列
+        Returns:
+          (dict): 股號與股名對照表，ex:`{'2330':'台積電'}`
+        """
+        return {}
+
+    @staticmethod
+    def get_price(trade_at_price:str, adj:bool=True) -> pd.DataFrame:
+        """取得回測用價格數據
+
+        Args:
+           trade_at_price (str): 選擇回測之還原股價以收盤價或開盤價計算，預設為'close'。可選'close'或'open'。
+           adj (str): 是否使用還原股價計算。
+        
+        Returns:
+          (pd.DataFrame): 價格數據
+        
+        Examples:
+            格式範例
+
+            | date       |   0015 |   0050 |   0051 |   0052 |
+            |:-----------|-------:|-------:|-------:|-------:|
+            | 2007-04-23 |   9.54 |  57.85 |  32.83 |  38.4  |
+            | 2007-04-24 |   9.54 |  58.1  |  32.99 |  38.65 |
+            | 2007-04-25 |   9.52 |  57.6  |  32.8  |  38.59 |
+            | 2007-04-26 |   9.59 |  57.7  |  32.8  |  38.6  |
+            | 2007-04-27 |   9.55 |  57.5  |  32.72 |  38.4  |
+            """
+        return pd.DataFrame()
+
+    @staticmethod
+    def get_market_value():
+        """取得回測用市值數據
+
+        Returns:
+          (pd.DataFrame): 市值數據，其中 index 為日期，而 columns 是股票代號。
+
+        """
+        return pd.DataFrame()
+
+    def get_trading_price(self, name: str, adj=True) -> pd.DataFrame:
+
+        """取得回測用價格數據
+        
+        Args:
+            name (str): 選擇回測之還原股價以收盤價或開盤價計算，預設為'close'。可選 'open'、'close'、'high'、'low'、'open_close_avg'、'high_low_avg'、或 'price_avg'。
+        Returns:
+            (pd.DataFrame): 價格數據
+
+        """
+
+
+        if name in ['open', 'close', 'high', 'low']:
+            return self.get_price(name, adj=adj)
+        elif name == 'close_open_avg' or name == 'open_close_avg':
+            return (self.get_price('open', adj=adj) + self.get_price('close', adj=adj)) / 2
+        elif name == 'high_low_avg' or name == 'low_high_avg':
+            return (self.get_price('high', adj=adj) + self.get_price('low', adj=adj)) / 2
+        elif name == 'price_avg':
+            return (self.get_price('open', adj=adj) + self.get_price('close', adj=adj)\
+                     + self.get_price('high', adj=adj) + self.get_price('low', adj=adj)) / 4
+
+        raise ValueError(f"Unknown trade price name: {name}")
+    
+
+    def market_close_at_timestamp(self, timestamp=None):
+        """
+        Returns the timestamp of the market close of the given timestamp.
+
+        Args:
+            timestamp (datetime): The timestamp to find the market close to.
+
+        Returns:
+            datetime: The timestamp of the closest market close.
+        """
+
+        indexes = self.get_price('close').index
+
+        if timestamp is None:
+            timestamp = indexes[-1]
+
+        # find min delta between indexes
+        delta = np.abs(indexes[1:] - indexes[:-1]).min()
+        return timestamp + delta
+    
+    def get_reference_price(self):
+        """Returns the most recent reference price of the market.
+        
+        Returns:
+            pandas.Series: The most recent reference price of the market.
+        """
+        return self.get_price('close').iloc[-1]
+    
+    @staticmethod
+    def tzinfo():
+        """Returns the timezone of the market.
+        
+        Returns:
+            datetime.timezone: The timezone of the market.
+        """
+        return None
+
+    @staticmethod
+    def get_odd_lot():
+        """Returns the odd lot size of the market.
+
+        Returns:
+            int: The odd lot size of the market.
+        """
+        return 1
+
+
+class TWMarketInfo(MarketInfo):
+
+    @staticmethod
+    def get_freq():
+        return '1d'
+
+    @staticmethod
+    def get_name():
+        return 'tw_stock'
+
+    @staticmethod
+    def get_benchmark() -> pd.Series:
+        return finlab.data.get('benchmark_return:發行量加權股價報酬指數').squeeze()
+
+    @staticmethod
+    def get_asset_id_to_name():
+        categories = finlab.data.get('security_categories')
+        stock_names = dict(
+            zip(categories.reset_index()['stock_id'], categories['name']))
+
+        return stock_names
+
+    @staticmethod
+    def get_price(trade_at_price, adj=True):
+        if isinstance(trade_at_price, pd.Series):
+            return trade_at_price.to_frame()
+
+        if isinstance(trade_at_price, pd.DataFrame):
+            return trade_at_price
+
+        if isinstance(trade_at_price, str):
+            if trade_at_price == 'volume':
+                return finlab.data.get('price:成交股數')
+
+            if adj:
+                table_name = 'etl:adj_'
+                price_name = trade_at_price
+            else:
+                table_name = 'price:'
+                price_name = {'open': '開盤價', 'close': '收盤價', 'high': '最高價', 'low': '最低價'}[trade_at_price]
+
+            price = finlab.data.get(f'{table_name}{price_name}')
+            return price
+
+        raise ValueError('trade_at_price is not allowed (accepted types: pd.DataFrame, pd.Series, str).')
+
+    @staticmethod
+    def get_market_value():
+        return finlab.data.get('etl:market_value')
+    
+
+    def market_close_at_timestamp(self, timestamp=None):
+
+        if not isinstance(timestamp, pd.Timestamp) and timestamp is not None:
+            timestamp = pd.Timestamp(timestamp).tz_localize('Asia/Taipei')
+
+        if timestamp is None:
+            timestamp = pd.Timestamp.now().tz_localize('Asia/Taipei')
+
+        # check if timestamp is localized, if not, localize it to Asia/Taipei
+        if timestamp.tzinfo is None:
+            timestamp = timestamp.tz_localize('Asia/Taipei')
+        
+        # get market close time
+        market_close = pd.Timestamp(timestamp.date()) + pd.Timedelta('15:00:00')
+        return market_close.tz_localize('Asia/Taipei')
+    
+    @staticmethod
+    def tzinfo():
+        return datetime.timezone(datetime.timedelta(hours=8))
+    
+    @staticmethod
+    def get_reference_price():
+        ref_price = finlab.data.get('reference_price')
+        return ref_price.set_index('stock_id')['收盤價'].to_dict()
+
+    @staticmethod
+    def get_odd_lot():
+        return 1000
+
+
+class USMarketInfo(MarketInfo):
+
+    @staticmethod
+    def get_freq():
+        return '1d'
+
+    @staticmethod
+    def get_name():
+        return 'us_stock'
+
+    @staticmethod
+    def get_benchmark():
+        return finlab.data.get('world_index:adj_close')['^GSPC']
+
+    @staticmethod
+    def get_asset_id_to_name():
+        categories = finlab.data.get('us_tickers')
+        stock_names = dict(
+            zip(categories['stock_id'], categories['name']))
+        return stock_names
+
+    @staticmethod
+    def get_price(trade_at_price, adj=True):
+        if isinstance(trade_at_price, pd.Series):
+            return trade_at_price.to_frame()
+
+        if isinstance(trade_at_price, pd.DataFrame):
+            return trade_at_price
+
+        if isinstance(trade_at_price, str):
+            if trade_at_price == 'volume':
+                return finlab.data.get('us_price:volume')
+
+            if adj:
+                table_name = 'us_price:adj_'
+                price_name = trade_at_price
+            else:
+                table_name = 'us_price:'
+                price_name = trade_at_price
+
+            price = finlab.data.get(f'{table_name}{price_name}')
+            return price
+
+        raise ValueError('trade_at_price is not allowed. Accepted types are pd.DataFrame, pd.Series, and str.')
+    
+
+    def market_close_at_timestamp(self, timestamp=None):
+
+        if timestamp is None:
+            timestamp = self.get_price('close').index[-1]
+
+        # check if timestamp is localized, if not, localize it to US/Eastern
+        if timestamp.tzinfo is None or timestamp.tzinfo.utcoffset(timestamp) is None:
+            timestamp = timestamp.tz_localize('US/Eastern')
+
+        # get market close time
+        market_close = pd.Timestamp(timestamp.date()) + pd.Timedelta('16:00:00')
+        return market_close.tz_localize('US/Eastern')
+
+    @staticmethod    
+    def tzinfo():
+        return datetime.timezone(datetime.timedelta(hours=-4))
+
+
+class USAllMarketInfo(USMarketInfo):
+    @staticmethod
+    def get_price(trade_at_price, adj=True):
+        if isinstance(trade_at_price, pd.Series):
+            return trade_at_price.to_frame()
+
+        if isinstance(trade_at_price, pd.DataFrame):
+            return trade_at_price
+
+        if isinstance(trade_at_price, str):
+            if trade_at_price == 'volume':
+                return finlab.data.get('us_price_all:volume')
+
+            if adj:
+                table_name = 'us_price_all:adj_'
+                price_name = trade_at_price
+            else:
+                table_name = 'us_price_all:'
+                price_name = trade_at_price
+
+            price = finlab.data.get(f'{table_name}{price_name}')
+            return price
+
+        raise Exception(f'**ERROR: trade_at_price is not allowed (accepted types: pd.DataFrame, pd.Series, str).')
+
+    @staticmethod
+    def get_market_value():
+        return finlab.data.get('us_fundamental:marketcap')
+
+
+def get_market_info(df:Union[None, pd.DataFrame, pd.Series]=None, 
+                    user_market_info:Union[None, str, MarketInfo]='AUTO') -> Optional[MarketInfo]:
+
+    
+    # return market info base on user_market_info
+    if user_market_info == 'TW_STOCK':
+        return TWMarketInfo()
+
+    if user_market_info == 'US_STOCK':
+        return USMarketInfo()
+
+    if user_market_info == 'US_STOCK_ALL':
+        return USAllMarketInfo()
+
+    if user_market_info != 'AUTO':
+        return user_market_info
+
+    # deal with user_market_info == 'AUTO'
+    if df is not None:
+        ids = set([df.name]) if isinstance(df, pd.Series) else set(df.columns)
+        for market in [TWMarketInfo(), USMarketInfo()]:
+            market_ids = set(market.get_asset_id_to_name().keys())
+            id_not_found = ids - market_ids
+
+            if len(id_not_found) / len(ids) < 0.5:
+                if len(id_not_found):
+                    logging.warning(f"Symbols {str(id_not_found)[:30]}... not found in MarketInfo.")
+                return market
+
+    raise Exception("Market cannot be determined automatically. "
+                    "Please set the market argument to either "
+                    "'TW_STOCK' for Taiwan stock market, 'US_STOCK' "
+                    "for US stock market, or use subclass of MarketInfo"
+                    " to specify a different market.")
+
+
+def create_shared_memory_from_df(df, name):
+    """Create a shared memory from a pandas DataFrame."""
+
+    names = [name, name+'_index', name+'_columns']
+    for name in names:
+        try:
+            shm = shared_memory.SharedMemory(name=name)
+            shm.close()
+            shm.unlink()
+
+        except FileNotFoundError:
+            pass
+
+    # create
+    array = df.to_numpy()
+    shm = shared_memory.SharedMemory(create=True, size=array.nbytes, name=name)
+    np_array = np.ndarray(array.shape, dtype=array.dtype, buffer=shm.buf)
+    np_array[:] = array[:]
+
+    # index
+    array_index = df.index.to_numpy()
+    shm_index = shared_memory.SharedMemory(create=True, size=array_index.nbytes, name=name+'_index')
+    np_array_index = np.ndarray(array_index.shape, dtype=array_index.dtype, buffer=shm_index.buf)
+    np_array_index[:] = array_index[:]
+
+    # columns
+    array_columns = df.columns.to_numpy()
+    shm_columns = shared_memory.SharedMemory(create=True, size=array_columns.nbytes, name=name+'_columns')
+    np_array_columns = np.ndarray(array_columns.shape, dtype=array_columns.dtype, buffer=shm_columns.buf)
+    np_array_columns[:] = array_columns[:]
+    # return shm, array.shape, array.dtype
+
+    return shm, array.shape, array.dtype, \
+        shm_index, array_index.shape, array_index.dtype, \
+        shm_columns, array_columns.shape, array_columns.dtype
+
+def create_df_from_shared_memory(shm, shape, dtype, shm_index, index_shape, index_dtype, shm_columns, columns_shape, columns_dtype):
+    """Create a pandas DataFrame from a shared memory."""
+
+    np_array = np.ndarray(shape, dtype=dtype, buffer=shm.buf) # np.frombuffer(shm.buf).reshape(shape)#
+    np_array_index = np.ndarray(index_shape, dtype=index_dtype, buffer=shm_index.buf)
+    return pd.DataFrame(np_array, index=np_array_index, )
+
+
+class MarketInfoSharedMemory(MarketInfo):
+
+    names = ['close', 'open', 'high', 'low', 'volume']
+
+    def __init__(self, market:MarketInfo, adj=True, start_time=None, end_time=None):
+
+        self.df_args = []
+        self.cache = {}
+        self.localize = None
+
+        shape_check = None
+
+        # fetch all dataframe and set localize to None (because localize is not supported in shared memory)
+        dfs = {}
+        for n in self.names:
+            df = market.get_price(n, adj=adj).loc[start_time:end_time].dropna(axis=1, how='all')
+
+            # get localize
+            if self.localize is None:
+                self.localize = df.index.tzinfo
+            else:
+                if self.localize != df.index.tzinfo:
+                    raise Exception("The timezone of the data is not the same. "
+                                    "Please check if the timezone of the data is correct.")
+                
+            self.cache[n] = df.copy()
+                
+            df.index = df.index.tz_localize(None)
+            dfs[n] = df
+
+        # intersection of columns of dataframe
+        columns = dfs['close'].columns.copy()
+        for name in dfs:
+            columns = columns.intersection(dfs[name].columns)
+
+        # reshape dataframe
+        for name, df in dfs.items():
+            dfs[name] = df[columns]
+
+        for n, df in dfs.items():
+            shape = df.shape
+            args = create_shared_memory_from_df(df, n)
+            self.df_args.append(args)
+
+            # check shape
+            if shape_check is None:
+                shape_check = shape
+            else:
+                if shape_check != shape:
+                    raise Exception("Shape of open, high, low, close, volume are not the same. "
+                                    "This is because the data is not updated yet. "
+                                    "Please try again few minutes later.")
+
+    def to_args(self):
+        return self.df_args + [self.localize]
+    
+    @classmethod
+    def from_args(cls, args):
+        self = cls.__new__(cls)
+        self.df_args = args[:-1]
+        self.localize = args[-1]
+        self.cache = {}
+        return self
+
+    def get_price(self, name, adj=True):
+
+        if name in self.cache:
+            return self.cache[name]
+        
+        args = self.df_args[self.names.index(name)]
+        df = create_df_from_shared_memory(*args)
+
+        df.index = df.index.tz_localize(self.localize)
+        self.cache[name] = df
+        return df
+
+    def close(self):
+        for args in self.df_args:
+            args[0].close()
+            args[0].unlink()
+            args[3].close()
+            args[3].unlink()
+            args[6].close()
+            args[6].unlink()
```

## finlab/plot.py

 * *Ordering differences only*

```diff
@@ -1,1090 +1,1090 @@
-import pandas as pd
-from finlab import data
-from plotly.subplots import make_subplots
-import plotly.graph_objects as go
-import plotly.express as px
-import numpy as np
-from finlab.utils import logger
-import itertools
-
-"""
-Candles
-"""
-
-
-def str_to_indicator(s, df):
-    from talib import abstract
-    import talib
-
-    params = {}
-    if '(' in s:
-        params = 'dict(' + s.split('(')[-1][:-1] + ')'
-        params = eval(params)
-    s = s.split('(')[0]
-
-    func = getattr(abstract, s)
-    real_func = getattr(talib, s)
-
-    abstract_input = list(func.input_names.values())[0]
-    if isinstance(abstract_input, str):
-        abstract_input = [abstract_input]
-
-    pos_paras = [df[k] for k in abstract_input]
-
-    ret = real_func(*pos_paras, **params)
-
-    if isinstance(ret, np.ndarray):
-        ret = pd.Series(ret, index=df.index)
-
-    if isinstance(ret, pd.Series):
-        return ret.to_frame(s)
-    return ret
-
-
-def color_generator():
-    for i in itertools.cycle(px.colors.qualitative.Plotly):
-        yield i
-
-
-def average(series, n):
-    return series.rolling(n, min_periods=int(n / 2)).mean()
-
-
-def evaluate_to_df(node, stock_id, df):
-    if callable(node):
-        node = node(df)
-
-    if isinstance(node, str):
-        node = str_to_indicator(node, df)
-
-    if isinstance(node, pd.Series):
-        return node.to_frame('0')
-
-    if isinstance(node, np.ndarray):
-        return pd.Series(node, df.index).to_frame('0')
-
-    if isinstance(node, pd.DataFrame):
-        if stock_id in node.columns:
-            return pd.DataFrame({'0': node[stock_id]})
-        else:
-            return node
-
-    if isinstance(node, list) or isinstance(node, tuple):
-        new_node = {}
-        ivalue = 0
-        for n in node:
-            if isinstance(n, str):
-                new_node[n] = n
-            else:
-                new_node[ivalue] = n
-                ivalue += 1
-        node = new_node
-
-    if isinstance(node, dict):
-        dfs = []
-        for name, n in node.items():
-            nn = evaluate_to_df(n, stock_id, df)
-            if len(nn.columns) == 1:
-                nn.columns = [name]
-            dfs.append(nn)
-
-        return pd.concat(dfs, axis=1)
-
-    assert 0
-
-
-def format_indicators(indicators, stock_id, stock_df):
-    if not isinstance(indicators, list):
-        indicators = [indicators]
-
-    ret = [evaluate_to_df(i, stock_id, stock_df) for i in indicators]
-
-    return ret
-
-
-def plot_candles(stock_id, close, open_, high, low, volume, recent_days=250, resample='D', overlay_func=None,
-                 technical_func=None):
-    c = color_generator()
-    next(c)
-    next(c)
-
-    df = (pd.DataFrame({
-        'close': close.values,
-        'open': open_.values,
-        'high': high.values,
-        'low': low.values,
-        'volume': volume.values}, index=close.index).iloc[-abs(recent_days):]
-    )
-
-    if resample:
-        df = df.resample(resample).agg({
-            'close': 'last',
-            'open': 'first',
-            'high': 'max',
-            'low': 'min',
-            'volume': 'sum'})
-
-    if overlay_func is None:
-        upperband, middleband, lowerband = data.indicator('BBANDS')
-        overlay_func = {
-            'upperband': upperband,
-            'middleband': middleband,
-            'lowerband': lowerband,
-        }
-
-    if technical_func is None:
-        k, d = data.indicator('STOCH')
-        technical_func = [{'K': k, 'D': d}]
-
-    overlay_indicator = format_indicators(overlay_func, stock_id, df)
-
-    # merge overlay indicator if it has multiple plots
-    if len(overlay_indicator) > 1:
-        overlay_indicator = [pd.concat(overlay_indicator, axis=1)]
-        overlay_indicator[0].columns = range(len(overlay_indicator[0].columns))
-
-    technical_indicator = format_indicators(technical_func, stock_id, df)
-
-    # truncate recent days
-    for i, d in enumerate(overlay_indicator):
-        o_ind = d.iloc[-abs(recent_days):]
-        if resample != 'D':
-            o_ind = o_ind.reindex(df.index, method='ffill')
-        overlay_indicator[i] = o_ind
-    for i, d in enumerate(technical_indicator):
-        t_ind = d.iloc[-abs(recent_days):]
-        if resample != 'D':
-            t_ind = t_ind.reindex(df.index, method='ffill')
-        technical_indicator[i] = t_ind
-
-    technical_func_num = len(technical_indicator)
-    index_value = close.index
-
-    nrows = 1 + len(technical_indicator)
-
-    fig_titles = ['']
-    if isinstance(technical_func, list):
-        for t in technical_func:
-            fig_titles.append(','.join(list(t.keys())))
-    elif isinstance(technical_func, dict):
-        fig_titles.append(','.join(list(technical_func.keys())))
-
-    fig = make_subplots(
-        rows=nrows,
-        specs=[[{"secondary_y": True}]] * nrows,
-        shared_xaxes=True,
-        vertical_spacing=0.05,
-        subplot_titles=fig_titles,
-        row_heights=[0.4] + [0.1] * (nrows - 1))
-
-    fig.add_trace(
-        go.Bar(x=df.index, y=df.volume, opacity=0.3, name="volume",
-               marker={'color': 'gray', 'line_width': 0}),
-        row=1, col=1
-    )
-
-    fig.add_trace(go.Candlestick(x=df.index,
-                                 open=df.open,
-                                 high=df.high,
-                                 low=df.low,
-                                 close=df.close,
-                                 increasing_line_color='#ff5084',
-                                 decreasing_line_color='#2bbd91',
-                                 legendgroup='1',
-                                 name='candle',
-                                 ), row=1, col=1, secondary_y=True)
-
-    # overlay plot
-    if overlay_indicator:
-        fig_overlay = px.line(overlay_indicator[0])
-        for o in fig_overlay.data:
-            fig.add_trace(go.Scatter(x=o['x'], y=o['y'], name=o['name'], line=dict(color=next(c)), legendgroup="1"),
-                          row=1, col=1, secondary_y=True)
-
-    for num, tech_ind in enumerate(technical_indicator):
-        fig_tech = px.line(tech_ind)
-        for t in fig_tech.data:
-            color = next(c)
-
-            fig.add_trace(
-                go.Scatter(x=t['x'], y=t['y'], name=t['name'], line=dict(color=color),
-                           legendgroup=str(2 + num),
-
-                           ),
-                row=2 + num, col=1)
-
-    # hide holiday
-    if resample == 'D':
-        dt_all = pd.date_range(start=index_value[0], end=index_value[-1])
-        # retrieve the dates that are in the original dataset
-        dt_obs = [d.strftime("%Y-%m-%d") for d in pd.to_datetime(index_value)]
-        # define dates with missing values
-        dt_breaks = [d for d in dt_all.strftime(
-            "%Y-%m-%d").tolist() if d not in dt_obs]
-        # hide dates with no values
-        fig.update_xaxes(rangebreaks=[dict(values=dt_breaks)])
-
-    fig.update_layout(
-        height=600 + 100 * technical_func_num,
-    )
-
-    fig.update_layout(
-        yaxis1=dict(
-            title="volume",
-            titlefont=dict(
-                color="#777"
-            ),
-            tickfont=dict(
-                color="#777"
-            ),
-            range=[df.volume.min(), df.volume.max() * 2]
-        ),
-        yaxis2=dict(
-            title="price",
-            titlefont=dict(
-                color="#777"
-            ),
-            tickfont=dict(
-                color="#777"
-            ),
-            showgrid=False
-        ),
-        hovermode='x unified',
-    )
-
-    fig.update_layout(**{
-        'xaxis1_rangeslider_visible': False,
-        f'xaxis': dict(
-            rangeselector=dict(
-                buttons=list([
-                    dict(count=6,
-                         label="6m",
-                         step="month",
-                         stepmode="backward"),
-                    dict(count=1,
-                         label="YTD",
-                         step="year",
-                         stepmode="todate"),
-                    dict(count=1,
-                         label="1y",
-                         step="year",
-                         stepmode="backward"),
-                    dict(step="all")
-                ])
-            ),
-        ),
-        f'xaxis{nrows}': dict(
-            rangeslider=dict(
-                visible=True,
-                thickness=0.1,
-                bgcolor='gainsboro',
-            ),
-            type="date",
-        ),
-    })
-
-    # fig.update_traces(xaxis='x2')
-    fig.update_xaxes(showspikes=True)
-    fig.update_yaxes(showspikes=True, spikemode="across")
-    fig.update_layout(showlegend=False)
-    fig.update_layout(plot_bgcolor="white")
-    fig.update_xaxes(showline=True, linecolor='#ddd')
-    fig.update_yaxes(showline=True, linecolor='#ddd')
-    fig.update_yaxes(titlefont=dict(
-        color="#777"
-    ),
-        tickfont=dict(
-            color="#777"
-    ))
-
-    fig.update_layout(title={'text': f'Candlestick Plot {stock_id}', 'font': {
-                      'size': 18, 'color': 'gray'}})
-
-    return fig
-
-
-def plot_tw_stock_candles(stock_id, recent_days=400, adjust_price=False, resample='D', overlay_func=None,
-                          technical_func=None):
-    """繪製台股技術線圖圖組
-    Args:
-        stock_id (str): 台股股號，ex:`'2330'`。
-        recent_days (int):取近n個交易日資料。
-        adjust_price (bool):是否使用還原股價計算。
-        resample (str): 技術指標價格週期，ex: `D` 代表日線, `W` 代表週線, `M` 代表月線。
-        overlay_func (dict):
-            K線圖輔助線，預設使用布林通道。
-             ```py
-             from finlab.data import indicator
-
-             overlay_func={
-                          'ema_5':indicator('EMA',timeperiod=5),
-                          'ema_10':indicator('EMA',timeperiod=10),
-                          'ema_20':indicator('EMA',timeperiod=20),
-                          'ema_60':indicator('EMA',timeperiod=60),
-                         }
-             ```
-        technical_func (list):
-            技術指標子圖，預設使用KD技術指標單組子圖。
-
-            設定多組技術指標：
-            ```py
-            from finlab.data import indicator
-
-            k,d = indicator('STOCH')
-            rsi = indicator('RSI')
-            technical_func = [{'K':k,'D':d},{'RSI':rsi}]
-            ```
-
-    Returns:
-        (plotly.graph_objects.Figure): 技術線圖
-
-    Examples:
-        ```py
-        from finlab.plot import plot_tw_stock_candles
-        from finlab.data import indicator
-
-        overlay_func={
-                      'ema_5':indicator('EMA',timeperiod=5),
-                      'ema_10':indicator('EMA',timeperiod=10),
-                      'ema_20':indicator('EMA',timeperiod=20),
-                      'ema_60':indicator('EMA',timeperiod=60),
-                     }
-        k,d = indicator('STOCH')
-        rsi = indicator('RSI')
-        technical_func = [{'K':k,'D':d},{'RSI':rsi}]
-        plot_tw_stock_candles(stock_id='2330',recent_days=600,adjust_price=False,overlay_func=overlay_func,technical_func=technical_func)
-        ```
-    """
-    if adjust_price:
-        close = data.get('etl:adj_close')[stock_id]
-        open_ = data.get('etl:adj_open')[stock_id]
-        high = data.get('etl:adj_high')[stock_id]
-        low = data.get('etl:adj_low')[stock_id]
-    else:
-        close = data.get('price:收盤價')[stock_id]
-        open_ = data.get('price:開盤價')[stock_id]
-        high = data.get('price:最高價')[stock_id]
-        low = data.get('price:最低價')[stock_id]
-
-    volume = data.get('price:成交股數')[stock_id]
-
-    return plot_candles(stock_id, close, open_, high, low, volume, recent_days=recent_days, resample=resample,
-                        overlay_func=overlay_func, technical_func=technical_func)
-
-
-"""
-Treemap
-"""
-
-
-def df_date_filter(df, start=None, end=None):
-    if start:
-        df = df[df.index >= start]
-    if end:
-        df = df[df.index <= end]
-    return df
-
-
-def create_treemap_data(start, end, item='return_ratio', clip=None):
-    """產生台股板塊圖資料
-
-    產生繪製樹狀圖所用的資料，可再外加FinLab資料庫以外的指標製作客製化DataFrame，
-    並傳入`plot_tw_stock_treemap(treemap_data=treemap_data)。`
-
-    Args:
-      start (str): 資料開始日，ex:`"2021-01-02"`。
-      end (str):資料結束日，ex:`"2021-01-05"`。
-      item (str): 決定板塊顏色深淺的指標。
-                  除了可選擇依照 start 與 end 計算的`"return_ratio"`(報酬率)，
-                  亦可選擇[FinLab資料庫](https://ai.finlab.tw/database)內的指標顯示近一期資料。
-          example:
-
-          * `'price_earning_ratio:本益比'` - 顯示近日產業的本益比高低。
-          * `'monthly_revenue:去年同月增減(%)'` - 顯示近月的單月營收年增率。
-
-      clip (tuple): 將item邊界外的值分配給邊界值，防止資料上限值過大或過小，造成顏色深淺變化不明顯。
-                    ex:(0,100)，將數值低高界線，設為0~100，超過的數值。
-        !!! note
-
-            參考[pandas文件](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.clip.html)更了解`pd.clip`細節。
-
-    Returns:
-        (pd.DataFrame): 台股個股指標
-    Examples:
-
-        欲下載所有上市上櫃之價量歷史資料與產業分類，只需執行此函式:
-
-        ``` py
-        from finlab.plot import create_treemap_data
-        create_treemap_data(start= '2021-07-01',end = '2021-07-02')
-        ```
-
-        | stock_id   |  close |turnover|category|market|market_value|return_ratio|country|
-        |:-----------|-------:|-------:|-------:|-------:|-------:|-------:|-------:|
-        | 1101       |   20 |  57.85 |  水泥工業 |  sii   |    111  |    0.1  |  TW-Stock|
-        | 1102       |  20 |  58.1  |  水泥工業 |  sii    |    111  |    -0.1 |  TW-Stock|
-
-
-    """
-    close = data.get('price:收盤價')
-    basic_info = data.get('company_basic_info')
-    turnover = data.get('price:成交金額')
-    close_data = df_date_filter(close, start, end)
-    turnover_data = df_date_filter(
-        turnover, start, end).iloc[1:].sum() / 100000000
-    return_ratio = (
-        close_data.loc[end] / close_data.loc[start]).dropna().replace(np.inf, 0)
-    return_ratio = round((return_ratio - 1) * 100, 2)
-
-    concat_list = [close_data.iloc[-1], turnover_data, return_ratio]
-    col_names = ['stock_id', 'close', 'turnover', 'return_ratio']
-    if item not in ["return_ratio", "turnover_ratio"]:
-        try:
-            custom_item = df_date_filter(
-                data.get(item), start, end).iloc[-1].fillna(0)
-        except Exception as e:
-            logger.error(
-                'data error, check the data is existed between start and end.')
-            logger.error(e)
-            return None
-        if clip:
-            custom_item = custom_item.clip(*clip)
-        concat_list.append(custom_item)
-        col_names.append(item)
-
-    df = pd.concat(concat_list, axis=1).dropna()
-    df = df.reset_index()
-    df.columns = col_names
-
-    basic_info_df = basic_info.copy().reset_index()
-    basic_info_df['stock_id_name'] = basic_info_df['stock_id'].astype(
-        str) + basic_info_df['公司簡稱']
-
-    df = df.merge(basic_info_df[['stock_id', 'stock_id_name', '產業類別', '市場別', '實收資本額(元)']], how='left',
-                  on='stock_id')
-    df = df.rename(columns={'產業類別': 'category',
-                   '市場別': 'market', '實收資本額(元)': 'base'})
-    df = df.dropna(thresh=5)
-    df['market_value'] = round(df['base'] / 10 * df['close'] / 100000000, 2)
-    df['country'] = 'TW-Stock'
-    return df
-
-
-def plot_tw_stock_treemap(start=None, end=None, area_ind='market_value', item='return_ratio', clip=None,
-                          color_continuous_scale='Temps', treemap_data=None):
-    """繪製台股板塊圖資料
-
-    巢狀樹狀圖可以顯示多維度資料，將依照產業分類的台股資料絢麗顯示。
-
-    Args:
-      start (str): 資料開始日，ex:`'2021-01-02'`。
-      end (str): 資料結束日，ex:`'2021-01-05'`。
-      area_ind (str): 決定板塊面積數值的指標。
-                      可選擇`["market_value","turnover"]`，數值代表含義分別為市值、成交金額。
-      item (str): 決定板塊顏色深淺的指標。
-                  除了可選擇依照 start 與 end 計算的`"return_ratio"`(報酬率)，
-                  亦可選擇[FinLab資料庫](https://ai.finlab.tw/database)內的指標顯示近一期資料。
-          example:
-
-          * `'price_earning_ratio:本益比'` - 顯示近日產業的本益比高低。
-          * `'monthly_revenue:去年同月增減(%)'` - 顯示近月的單月營收年增率。
-
-      clip (tuple): 將 item 邊界外的值分配給邊界值，防止資料上限值過大或過小，造成顏色深淺變化不明顯。
-                    ex:(0,100)，將數值低高界線，設為 0~100，超過的數值。
-        !!!note
-
-            參考[pandas文件](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.clip.html)更了解`pd.clip`細節。
-      color_continuous_scale (str):[顏色變化序列的樣式名稱](https://plotly.com/python/builtin-colorscales/)
-      treemap_data (pd.DataFrame): 客製化資料，格式參照 `create_treemap_data()` 返回值。
-    Returns:
-        (plotly.graph_objects.Figure): 樹狀板塊圖
-    Examples:
-        ex1:
-        板塊面積顯示成交金額，顏色顯示'2021-07-01'～'2021-07-02'的報酬率變化，可以觀察市場資金集中的產業與漲跌強弱。
-        ```py
-        from finlab.plot import plot_tw_stock_treemap
-        plot_tw_stock_treemap(start= '2021-07-01',end = '2021-07-02',area_ind="turnover",item="return_ratio")
-        ```
-        ![成交佔比/報酬率板塊圖](img/plot/treemap_return.png)
-        ex2:
-        板塊面積顯示市值(股本*收盤價)，顏色顯示近期本益比，可以觀察全市場哪些是權值股？哪些產業本益比評價高？限制數值範圍在(0,50)，
-        將過高本益比的數值壓在50，不讓顏色變化突兀，能分出高低階層即可。
-        ```py
-        from finlab.plot import plot_tw_stock_treemap
-        plot_tw_stock_treemap(area_ind="market_value",item="price_earning_ratio:本益比",clip=(0,50), color_continuous_scale='RdBu_r')
-        ```
-        ![市值/本益比板塊圖](img/plot/treemap_pe.png)
-    """
-    if treemap_data is None:
-        df = create_treemap_data(start, end, item, clip)
-    else:
-        df = treemap_data.copy()
-
-    if df is None:
-        return None
-    df['custom_item_label'] = round(df[item], 2).astype(str)
-    df.dropna(how='any', inplace=True)
-
-    if area_ind not in df.columns:
-        return None
-
-    if item in ['return_ratio']:
-        color_continuous_midpoint = 0
-    else:
-        color_continuous_midpoint = np.average(df[item], weights=df[area_ind])
-
-    fig = px.treemap(df,
-                     path=['country', 'market', 'category', 'stock_id_name'],
-                     values=area_ind,
-                     color=item,
-                     color_continuous_scale=color_continuous_scale,
-                     color_continuous_midpoint=color_continuous_midpoint,
-                     custom_data=['custom_item_label', 'close', 'turnover'],
-                     title=f'TW-Stock Market TreeMap({start}~{end})'
-                           f'---area_ind:{area_ind}---item:{item}',
-                     width=1600,
-                     height=800)
-
-    fig.update_traces(textposition='middle center',
-                      textfont_size=24,
-                      texttemplate="%{label}<br>(%{customdata[1]})<br>%{customdata[0]}",
-                      )
-    return fig
-
-
-"""
-Radar
-"""
-
-
-def plot_radar(df, mode='bar_polar', line_polar_fill=None, title=None, polar_range=10):
-    args = dict(data_frame=df, r="value", theta="variable", color="stock_id", line_close=True,
-                color_discrete_sequence=px.colors.sequential.Plasma_r,
-                template="plotly_dark")
-    if mode != 'line_polar':
-        args.pop('line_close')
-
-    fig = getattr(px, mode)(**args)
-    if title is None:
-        title = 'Features Radar'
-    fig.update_layout(
-        title={
-            'text': title,
-            'x': 0.49,
-            'y': 0.99,
-            'xanchor': 'center',
-            'yanchor': 'top'},
-        paper_bgcolor='rgb(41, 30, 109)',
-        polar=dict(
-            radialaxis=dict(
-                visible=True,
-                range=[0, polar_range]
-            )),
-        width=1200,
-        height=600)
-    if mode == 'line_polar':
-        # None,toself,tonext
-        fig.update_traces(fill=line_polar_fill)
-    return fig
-
-
-def get_rank(item: str, period=None, cut_bins=10):
-    df = data.get(item)
-    if period == None:
-        df = df.iloc[-1]
-    else:
-        df = df.loc[period]
-
-    df_rank = df.rank(pct=True)
-    df_rank = pd.cut(x=df_rank, bins=cut_bins, labels=[
-                     i for i in range(1, cut_bins + 1)])
-    return df_rank
-
-
-def get_rank_df(feats: list, period=None, cut_bins=10):
-    df = pd.concat([get_rank(f, period, cut_bins) for f in feats], axis=1)
-    columns_name = [f[f.index(':') + 1:] for f in feats]
-    df.columns = columns_name
-    df.index.name = 'stock_id'
-    return df
-
-
-def plot_tw_stock_radar(portfolio, feats=None, mode='line_polar', line_polar_fill=None,
-                        period=None, cut_bins=10, title=None, custom_data=None):
-    """繪製台股雷達圖
-
-    比較持股組合的指標分級特性。若數值為nan，則不顯示分級。
-
-    Args:
-      portfolio (list):持股組合，ex:`['1101','1102']`。
-      feats (list): 選定FinLab資料庫內的指標組成資料集。預設為18項財務指標。
-                    ex:['fundamental_features:營業毛利率','fundamental_features:營業利益率']
-      mode (str): 雷達圖模式 ，ex:'bar_polar','scatter_polar','line_polar'`。
-        !!!note
-
-            參考[不同模式的差異](https://plotly.com/python-api-reference/generated/plotly.express.html)
-      line_polar_fill (str):將區域設置為用純色填充 。ex:`None,'toself','tonext'`
-                           `'toself'`將跡線的端點（或跡線的每一段，如果它有間隙）連接成一個封閉的形狀。
-                           如果一條完全包圍另一條（例如連續的等高線），則`'tonext'`填充兩條跡線之間的空間，如果之前沒有跡線，
-                           則其行為類似於`'toself'`。如果一條跡線不包含另一條跡線，則不應使用`'tonext'`。
-        欲使用 line_polar，請將pandas版本降至 1.4.4。
-        !!!note
-
-            參考[plotly.graph_objects.Scatterpolar.fill](https://plotly.github.io/plotly.py-docs/generated/plotly.graph_objects.Scatterpolar.html)
-
-      period (str): 選擇第幾期的特徵資料，預設為近一季。
-                    ex: 設定數值為'2020-Q2，取得2020年第二季資料比較。
-      cut_bins (int):特徵分級級距。
-      title (str):圖片標題名稱。
-      custom_data (pd.DataFrame): 客製化指標分級，欄名為特徵
-                    格式範例:
-
-        | stock_id   |  營業毛利率 |營業利益率|稅後淨利率|
-        |:-----------|-------:|-------:|-------:|
-        | 1101       |   2    |    5   |      3|
-        | 1102       |   1    |    8   |      4|
-    Returns:
-        (plotly.graph_objects.Figure): 雷達圖
-    Examples:
-        ex1:比較持股組合累計分數，看持股組合偏重哪像特徵。
-        ```py
-        from finlab.plot import plot_tw_stock_radar
-        plot_tw_stock_radar(portfolio=["1101", "2330", "8942", "6263"], mode="bar_polar", line_polar_fill='None')
-        ```
-        ![持股組合雷達圖](img/plot/radar_many.png)
-        ex2:看單一個股特徵分級落點。
-        ```py
-        from finlab.plot import plot_tw_stock_radar
-        feats = ['fundamental_features:營業毛利率', 'fundamental_features:營業利益率', 'fundamental_features:稅後淨利率',
-                 'fundamental_features:現金流量比率', 'fundamental_features:負債比率']
-        plot_tw_stock_radar(portfolio=["9939"], feats=feats, mode="line_polar", line_polar_fill='toself', cut_bins=8)
-        ```
-        ![單檔標的子選指標雷達圖](img/plot/radar_single.png)
-    """
-    if custom_data is None:
-        if feats is None:
-            feats = ['fundamental_features:營業毛利率', 'fundamental_features:營業利益率',
-                     'fundamental_features:稅後淨利率',
-                     'fundamental_features:ROA綜合損益', 'fundamental_features:ROE綜合損益',
-                     'fundamental_features:業外收支營收率',
-                     'fundamental_features:現金流量比率', 'fundamental_features:負債比率',
-                     'fundamental_features:流動比率', 'fundamental_features:速動比率',
-                     'fundamental_features:存貨週轉率',
-                     'fundamental_features:營收成長率', 'fundamental_features:營業毛利成長率',
-                     'fundamental_features:營業利益成長率', 'fundamental_features:稅前淨利成長率',
-                     'fundamental_features:稅後淨利成長率',
-                     'fundamental_features:資產總額成長率', 'fundamental_features:淨值成長率'
-                     ]
-        df = get_rank_df(feats, period=period, cut_bins=cut_bins)
-    else:
-        df = custom_data.copy()
-
-    col_name = df.columns
-    portfolio = df.index.intersection(portfolio)
-    if len(portfolio) < 1:
-        logger.error('data is not existed.')
-        return
-    df = df.loc[portfolio]
-    df = df.reset_index()
-    df = pd.melt(df, id_vars=['stock_id'], value_vars=col_name)
-    polar_range = cut_bins * len(portfolio)
-    fig = plot_radar(df=df, mode=mode, line_polar_fill=line_polar_fill,
-                     title=title, polar_range=polar_range)
-    return fig
-
-
-"""
-PE PB River
-"""
-
-
-def get_pe_river_data(start=None, end=None, stock_id='2330', mode='pe', split_range=6):
-    if mode not in ['pe', 'pb']:
-        logger.error('mode error')
-        return None
-    close = df_date_filter(data.get('price:收盤價'), start, end)
-    pe = df_date_filter(data.get('price_earning_ratio:本益比'), start, end)
-    pb = df_date_filter(data.get('price_earning_ratio:股價淨值比'), start, end)
-    df = eval(mode)
-    if stock_id not in df.columns:
-        logger.error('stock_id input is not in data.')
-        return None
-    df = df[stock_id]
-    max_value = df.max()
-    min_value = df.min()
-    quan_value = (max_value - min_value) / split_range
-    river_borders = [round(min_value + quan_value * i, 2)
-                     for i in range(0, split_range + 1)]
-    result = (close[stock_id] / df).dropna().to_frame()
-    index_name = f'{mode}/close'
-    result.columns = [index_name]
-    result['close'] = close[stock_id]
-    result['pe'] = pe[stock_id]
-    result['pb'] = pb[stock_id]
-    for r in river_borders:
-        col_name = f"{r} {mode}"
-        result[col_name] = result[index_name] * r
-    result = round(result, 2)
-    return result
-
-
-def plot_tw_stock_river(stock_id='2330', start=None, end=None, mode='pe', split_range=8):
-    """繪製台股河流圖
-
-    使用 PE or PB 的最高與最低值繪製河流圖，判斷指標所處位階。
-
-    Args:
-      stock_id (str): 台股股號，ex:`'2330'`。
-      start (str): 資料開始日，ex:`'2020-01-02'`。
-      end (str): 資料結束日，ex:`'2022-01-05'`。
-      mode (str): `'pe'` or `'pb'` (本益比或股價淨值比)。
-      split_range (int): 河流階層數。
-    Returns:
-        (plotly.graph_objects.Figure): 河流圖
-    Examples:
-      ```py
-      from finlab.plot import plot_tw_stock_river
-      plot_tw_stock_river(stock_id='2330', start='2015-1-1', end='2022-7-1', mode='pe', split_range=10)
-      ```
-      ![單檔標的子選指標雷達圖](img/plot/pe_river.png)
-    """
-    df = get_pe_river_data(start, end, stock_id, mode, split_range)
-    if df is None:
-        logger.error('data error')
-        return None
-    col_name_set = [i for i in df.columns if any(map(str.isdigit, i))]
-
-    fig = go.Figure()
-    for n, c in enumerate(col_name_set):
-        if n == 0:
-            fill_mode = None
-        else:
-            fill_mode = 'tonexty'
-        fig.add_trace(
-            go.Scatter(x=df.index, y=df[c], fill=fill_mode, line=dict(width=0, color=px.colors.qualitative.Prism[n]),
-                       name=c))
-    customdata = [(c, p) for c, p in zip(df['close'], df[mode])]
-    hovertemplate = "<br>date:%{x|%Y/%m/%d}<br>close:%{customdata[0]}" + \
-        f"<br>{mode}" + ":%{customdata[1]}"
-    fig.add_trace(go.Scatter(x=df.index, y=df['close'], line=dict(width=2.5, color='#2e4391'), customdata=customdata,
-                             hovertemplate=hovertemplate, name='close'))
-
-    security_categories = data.get('security_categories').set_index('stock_id')
-    stock_name = security_categories.loc[stock_id]['name']
-    fig.update_layout(title=f"{stock_id} {stock_name} {mode.upper()} River Chart",
-                      template="ggplot2",
-                      yaxis=dict(
-                          title='price',
-                      ),
-                      # hovermode='x unified',
-                      )
-    fig.update_xaxes(showspikes=True)
-    fig.update_yaxes(showspikes=True)
-    return fig
-
-
-class StrategySunburst:
-    def __init__(self):
-        """繪製策略部位旭日圖
-
-        監控多策略。
-        """
-        d = data.get_strategies()
-        for k, v in d.items():
-            if 'position' in d[k]['positions']:
-                d[k]['positions'] = d[k]['positions']['position']
-        self.s_data = d
-
-    def process_position(self, s_name, s_weight=1):
-        if s_name == '現金':
-            result = pd.DataFrame(
-                {'return': 0, 'weight': 1, 'category': '現金', 'market': '現金'}, index=['現金'])
-            result.index.name = 'stock_id'
-        else:
-            df = pd.DataFrame(self.s_data[s_name]['positions'])
-            df = df[[c for c in df.columns if ' ' in c]]
-            df = df.T
-            df['weight'] = df['weight'].apply(
-                lambda s: abs(pd.to_numeric(s, errors='coerce')))
-            df = df[df['weight'] > 0]
-            if len(df) == 0:
-                df['weight'] = 0
-            df.index.name = 'stock_id'
-            old_security_categories = data.get(
-                'security_categories').reset_index()
-            security_categories = old_security_categories.copy()
-            security_categories['category'] = security_categories['category'].fillna(
-                'other_securities')
-            security_categories['stock_id'] = security_categories['stock_id'] + \
-                ' ' + security_categories['name']
-            security_categories = security_categories.set_index(['stock_id'])
-            result = df.join(security_categories)
-
-            asset_type = self.s_data[s_name]['asset_type']
-            if asset_type == '':
-                asset_type = 'tw_stock'
-            elif asset_type == 'crypto':
-                category = 'crypto'
-                result['category'] = category
-
-            result['market'] = asset_type
-            cash = pd.DataFrame({'return': 0, 'weight': 1 - (df['weight'].sum()), 'category': '現金', 'market': '現金'},
-                                index=['現金'])
-            cash.index.name = 'stock_id'
-            result = pd.concat([result, cash])
-
-        result['s_name'] = s_name
-        result['s_weight'] = s_weight
-        return result
-
-    def get_strategy_df(self, select_strategy=None):
-        """獲取策略部位與分配權重後計算的資料
-
-        Args:
-          select_strategy (dict): 選擇策略名稱並設定權重，預設是抓取權策略並平分資金比例到各策略。
-                                 ex:`{'低波動本益成長比':0.5,'研發魔人':0.2, '現金':0.2}`
-        Returns:
-            (pd.DataFrame): strategies data
-        """
-        if select_strategy is None:
-            s_name = self.s_data.keys()
-            s_num = len(s_name)
-            if s_num == 0:
-                return None
-            s_weight = [1 / s_num] * len(s_name)
-        else:
-            s_name = select_strategy.keys()
-            s_weight = select_strategy.values()
-
-        all_position = pd.concat([self.process_position(
-            name, weight) for name, weight in zip(s_name, s_weight)])
-        all_position['weight'] *= all_position['s_weight']
-        all_position['return'] = round(all_position['return'].astype(float), 2)
-        all_position['color'] = round(
-            all_position['return'].clip(all_position['return'].min() / 2, all_position['return'].max() / 2), 2)
-        all_position = all_position[all_position['weight'] > 0]
-        all_position = all_position.reset_index()
-        all_position = all_position[all_position['s_name'] != 'playground']
-        all_position['category'] = all_position['category'].fillna(
-            'other_securities')
-        return all_position
-
-    def plot(self, select_strategy=None, path=None, color_continuous_scale='RdBu_r'):
-        """繪圖
-
-        Args:
-          select_strategy (dict): 選擇策略名稱並設定權重，預設是抓取權策略並平分資金比例到各策略。
-                                 ex:`{'低波動本益成長比':0.5,'研發魔人':0.2, '現金':0.2}`
-          path (list): 旭日圖由裡到外的顯示路徑，預設為`['s_name', 'market', 'category', 'stock_id']`。
-                       `['market', 'category','stock_id','s_name']`也是常用選項。
-          color_continuous_scale (str):[顏色變化序列的樣式名稱](https://plotly.com/python/builtin-colorscales/)
-
-        Returns:
-            (plotly.graph_objects.Figure): 策略部位旭日圖
-        Examples:
-            ```py
-            from finlab.plot import StrategySunburst
-
-            # 實例化物件
-            strategies = StrategySunburst()
-            strategies.plot().show()
-            strategies.plot(select_strategy={'高殖利率烏龜':0.4,'營收強勢動能瘋狗':0.25,'低波動本益成長比':0.2,'現金':0.15},path =  ['market', 'category','stock_id','s_name']).show()
-            ```
-        ex1:策略選到哪些標的?
-        ![市值/本益比板塊圖](img/plot/sunburst1.png)
-
-        ex2:部位被哪些策略選到，標的若被不同策略選到，可能有獨特之處喔！
-        ![市值/本益比板塊圖](img/plot/sunburst2.png)
-        """
-        position = self.get_strategy_df(select_strategy)
-        if position is None:
-            return
-        position = position[(position['return'] != np.inf)
-                            | (position['weight'] != np.inf)]
-        if path is None:
-            path = ['s_name', 'market', 'category', 'stock_id']
-        fig = px.sunburst(position, path=path, values='weight',
-                          color='color', hover_data=['return'],
-                          color_continuous_scale=color_continuous_scale,
-                          color_continuous_midpoint=0,
-                          width=1000, height=800)
-        return fig
-
-
-class StrategyReturnStats:
-
-    def __init__(self, start_date: str, end_date: str, strategy_names=[], benchmark_return=None):
-        """繪製策略報酬率統計比較圖
-
-        監控策略群體相對對標指數的表現。
-
-        Args:
-            start_date (str): 報酬率計算開始日
-            end_date (str): 報酬率計算結束日
-            strategy_names (list): 用戶本人的策略集設定，填入欲納入統計的策略名稱，只限定自己的策略。ex:`['膽小貓','三頻率RSI策略', '二次創高股票',...]`，預設為全部已上傳的策略。
-            benchmark_return (pandas.Series): 策略比對基準序列，預設為台股加權報酬指數。
-
-
-        Examples:
-
-            統計2022-12-31~2023-07-31的報酬率數據
-            ``` py
-            # 回測起始時間
-            start_date = '2022-12-31'
-            end_date  = '2023-07-31'
-
-            # 選定策略範圍
-            strategy_names = ['膽小貓','三頻率RSI策略', '二次創高股票', '低波動本益成長比', '合約負債建築工', '多產業價投', '小蝦米跟大鯨魚', '小資族資優生策略', '本益成長比', '營收股價雙渦輪', '現金流價值成長', '研發魔人', '股價淨值比策略', '藏獒', '高殖利率烏龜','監獄兔', '財報指標20大']
-
-            report = StrategyReturnStats(start_date ,end_date, strategy_names)
-            # 繪製策略報酬率近期報酬率長條圖
-            report.plot_strategy_last_return().show()
-            # 繪製策略累積報酬率時間序列
-            report.plot_strategy_creturn().show()
-            ```
-
-        """
-        # 回測起始時間
-        self.start_date = start_date
-        self.end_date = end_date
-
-        # 選定策略範圍
-        self.s_data = data.get_strategies()
-        self.strategy_names = strategy_names
-        self.benchmark_return = data.get('benchmark_return:發行量加權股價報酬指數')[
-            '發行量加權股價報酬指數'] if benchmark_return is None else benchmark_return
-        self.returns_set = self._get_returns_set()
-
-    def _get_returns_set(self):
-        """計算報酬率數據
-        Returns:
-            (dict): 報酬率數據，ex: `{'膽小貓': -5.98,'股價淨值比策略': -1.68,...}`
-        """
-        returns_set = {}
-        strategy_names = self.s_data.keys() if len(
-            self.strategy_names) == 0 else self.strategy_names
-        for s_name in strategy_names:
-            try:
-                s_df = self.s_data[s_name]
-                returns = pd.Series(
-                    s_df['returns']['value'], index=s_df['returns']['time'])
-                if self.start_date:
-                    returns = returns[returns.index >= self.start_date]
-                if self.end_date:
-                    returns = returns[returns.index <= self.end_date]
-                return_value = round(
-                    ((returns.iloc[-1] / returns.iloc[0]) - 1) * 100, 2)
-                returns_set[s_name] = return_value
-            except:
-                pass
-
-        returns_set = dict(sorted(returns_set.items(), key=lambda x: x[1]))
-        return returns_set
-
-    def get_benchmark_return(self):
-        """設定對標指數
-        Returns:
-            (pandas.Series): 對標指數時間序列
-        """
-        benchmark_return = self.benchmark_return
-        benchmark_return = benchmark_return[
-            (benchmark_return.index >= self.start_date) & (benchmark_return.index <= self.end_date)]
-        return benchmark_return
-
-    def plot_strategy_last_return(self):
-        """繪製策略報酬率近期報酬率長條圖
-        Returns:
-            (plotly.graph_objects.Figure): 圖表物件
-        ![繪製策略報酬率近期報酬率長條圖](img/plot/finlab_strategy_performance.png)
-        """
-        returns_set = self.returns_set
-        benchmark_return = self.get_benchmark_return()
-        benchmark_last_return = round(
-            ((benchmark_return.iloc[-1] / benchmark_return.iloc[0]) - 1) * 100, 2)
-
-        fig = go.Figure(go.Bar(
-            x=list(returns_set.values()),
-            y=list(returns_set.keys()),
-            marker=dict(
-                color='rgba(50, 171, 96, 0.6)',
-                line=dict(color='rgba(50, 171, 96, 1)', width=3)
-            ),
-            orientation='h'))
-
-        fig.add_vline(x=benchmark_last_return, line_width=3, line_dash="dash", line_color="#4a6dce",
-                      annotation_text=f"benchmark:{benchmark_last_return}",
-                      annotation_position="top left")
-
-        returns_mean = round(sum((returns_set.values())) / len(returns_set), 2)
-
-        fig.add_vline(x=returns_mean, line_width=3, line_dash="dash", line_color="#aa00ff",
-                      annotation_font_color="#aa00ff", annotation_text=f"strategy_mean:{returns_mean}",
-                      annotation_position="bottom right")
-
-        fig.update_layout(
-            title=f'FinLab Strategy Performance ({self.start_date}~{self.end_date})',
-            legend=dict(x=0.029, y=1.038, font_size=12),
-            margin=dict(l=100, r=20, t=70, b=70),
-            paper_bgcolor='rgb(248, 248, 255)',
-            plot_bgcolor='rgb(248, 248, 255)',
-            xaxis_title="return(%)",
-        )
-
-        return fig
-
-    def plot_strategy_creturn(self):
-        """繪製策略累積報酬率時間序列
-        Returns:
-            (plotly.graph_objects.Figure): 圖表物件
-        ![繪製策略累積報酬率時間序列](img/plot/finlab_strategy_creturn.png)
-        """
-
-        returns_set = self.returns_set
-        benchmark_return = self.get_benchmark_return()
-
-        sorted_s_names = list(returns_set.keys())[::-1]
-
-        returns_set2 = {}
-        for s_name in sorted_s_names:
-            s_df = self.s_data[s_name]
-            returns = pd.Series(s_df['returns']['value'],
-                                index=s_df['returns']['time'])
-            if self.start_date:
-                returns = returns[returns.index >= self.start_date]
-            if self.end_date:
-                returns = returns[returns.index <= self.end_date]
-            returns_set2[s_name] = round(
-                ((returns / returns.iloc[0]) - 1) * 100, 2)
-
-        returns_df = pd.DataFrame(
-            returns_set2).unstack().to_frame().reset_index()
-        returns_df.columns = ['strategy', 'date', 'creturns']
-        benchmark_creturn = round(
-            ((benchmark_return / benchmark_return.iloc[0]) - 1) * 100, 2)
-
-        fig = px.line(returns_df, x="date", y="creturns", color="strategy")
-        fig.add_trace(
-            go.Scatter(x=benchmark_creturn.index, y=benchmark_creturn.values, fill='tonexty', name='benchmark',
-                       opacity=0.2,
-                       marker=dict(
-                           color='LightSkyBlue',
-                           opacity=0.2,
-                           size=20,
-                           line=dict(
-                               color='MediumPurple',
-                               width=2
-                           )
-                       ), ))
-
-        fig.update_layout(
-            title=f'FinLab Strategy Creturn ({self.start_date}~{self.end_date})',
-            margin=dict(l=100, r=20, t=70, b=70),
-            paper_bgcolor='rgb(248, 248, 255)',
-            plot_bgcolor='rgb(248, 248, 255)',
-            yaxis_title="creturn (%)",
-        )
-
-        fig.update_layout(yaxis_range=(
-            returns_df["creturns"].min() - 0.1, returns_df["creturns"].max() + 0.1))
-
-        return fig
+import pandas as pd
+from finlab import data
+from plotly.subplots import make_subplots
+import plotly.graph_objects as go
+import plotly.express as px
+import numpy as np
+from finlab.utils import logger
+import itertools
+
+"""
+Candles
+"""
+
+
+def str_to_indicator(s, df):
+    from talib import abstract
+    import talib
+
+    params = {}
+    if '(' in s:
+        params = 'dict(' + s.split('(')[-1][:-1] + ')'
+        params = eval(params)
+    s = s.split('(')[0]
+
+    func = getattr(abstract, s)
+    real_func = getattr(talib, s)
+
+    abstract_input = list(func.input_names.values())[0]
+    if isinstance(abstract_input, str):
+        abstract_input = [abstract_input]
+
+    pos_paras = [df[k] for k in abstract_input]
+
+    ret = real_func(*pos_paras, **params)
+
+    if isinstance(ret, np.ndarray):
+        ret = pd.Series(ret, index=df.index)
+
+    if isinstance(ret, pd.Series):
+        return ret.to_frame(s)
+    return ret
+
+
+def color_generator():
+    for i in itertools.cycle(px.colors.qualitative.Plotly):
+        yield i
+
+
+def average(series, n):
+    return series.rolling(n, min_periods=int(n / 2)).mean()
+
+
+def evaluate_to_df(node, stock_id, df):
+    if callable(node):
+        node = node(df)
+
+    if isinstance(node, str):
+        node = str_to_indicator(node, df)
+
+    if isinstance(node, pd.Series):
+        return node.to_frame('0')
+
+    if isinstance(node, np.ndarray):
+        return pd.Series(node, df.index).to_frame('0')
+
+    if isinstance(node, pd.DataFrame):
+        if stock_id in node.columns:
+            return pd.DataFrame({'0': node[stock_id]})
+        else:
+            return node
+
+    if isinstance(node, list) or isinstance(node, tuple):
+        new_node = {}
+        ivalue = 0
+        for n in node:
+            if isinstance(n, str):
+                new_node[n] = n
+            else:
+                new_node[ivalue] = n
+                ivalue += 1
+        node = new_node
+
+    if isinstance(node, dict):
+        dfs = []
+        for name, n in node.items():
+            nn = evaluate_to_df(n, stock_id, df)
+            if len(nn.columns) == 1:
+                nn.columns = [name]
+            dfs.append(nn)
+
+        return pd.concat(dfs, axis=1)
+
+    assert 0
+
+
+def format_indicators(indicators, stock_id, stock_df):
+    if not isinstance(indicators, list):
+        indicators = [indicators]
+
+    ret = [evaluate_to_df(i, stock_id, stock_df) for i in indicators]
+
+    return ret
+
+
+def plot_candles(stock_id, close, open_, high, low, volume, recent_days=250, resample='D', overlay_func=None,
+                 technical_func=None):
+    c = color_generator()
+    next(c)
+    next(c)
+
+    df = (pd.DataFrame({
+        'close': close.values,
+        'open': open_.values,
+        'high': high.values,
+        'low': low.values,
+        'volume': volume.values}, index=close.index).iloc[-abs(recent_days):]
+    )
+
+    if resample:
+        df = df.resample(resample).agg({
+            'close': 'last',
+            'open': 'first',
+            'high': 'max',
+            'low': 'min',
+            'volume': 'sum'})
+
+    if overlay_func is None:
+        upperband, middleband, lowerband = data.indicator('BBANDS')
+        overlay_func = {
+            'upperband': upperband,
+            'middleband': middleband,
+            'lowerband': lowerband,
+        }
+
+    if technical_func is None:
+        k, d = data.indicator('STOCH')
+        technical_func = [{'K': k, 'D': d}]
+
+    overlay_indicator = format_indicators(overlay_func, stock_id, df)
+
+    # merge overlay indicator if it has multiple plots
+    if len(overlay_indicator) > 1:
+        overlay_indicator = [pd.concat(overlay_indicator, axis=1)]
+        overlay_indicator[0].columns = range(len(overlay_indicator[0].columns))
+
+    technical_indicator = format_indicators(technical_func, stock_id, df)
+
+    # truncate recent days
+    for i, d in enumerate(overlay_indicator):
+        o_ind = d.iloc[-abs(recent_days):]
+        if resample != 'D':
+            o_ind = o_ind.reindex(df.index, method='ffill')
+        overlay_indicator[i] = o_ind
+    for i, d in enumerate(technical_indicator):
+        t_ind = d.iloc[-abs(recent_days):]
+        if resample != 'D':
+            t_ind = t_ind.reindex(df.index, method='ffill')
+        technical_indicator[i] = t_ind
+
+    technical_func_num = len(technical_indicator)
+    index_value = close.index
+
+    nrows = 1 + len(technical_indicator)
+
+    fig_titles = ['']
+    if isinstance(technical_func, list):
+        for t in technical_func:
+            fig_titles.append(','.join(list(t.keys())))
+    elif isinstance(technical_func, dict):
+        fig_titles.append(','.join(list(technical_func.keys())))
+
+    fig = make_subplots(
+        rows=nrows,
+        specs=[[{"secondary_y": True}]] * nrows,
+        shared_xaxes=True,
+        vertical_spacing=0.05,
+        subplot_titles=fig_titles,
+        row_heights=[0.4] + [0.1] * (nrows - 1))
+
+    fig.add_trace(
+        go.Bar(x=df.index, y=df.volume, opacity=0.3, name="volume",
+               marker={'color': 'gray', 'line_width': 0}),
+        row=1, col=1
+    )
+
+    fig.add_trace(go.Candlestick(x=df.index,
+                                 open=df.open,
+                                 high=df.high,
+                                 low=df.low,
+                                 close=df.close,
+                                 increasing_line_color='#ff5084',
+                                 decreasing_line_color='#2bbd91',
+                                 legendgroup='1',
+                                 name='candle',
+                                 ), row=1, col=1, secondary_y=True)
+
+    # overlay plot
+    if overlay_indicator:
+        fig_overlay = px.line(overlay_indicator[0])
+        for o in fig_overlay.data:
+            fig.add_trace(go.Scatter(x=o['x'], y=o['y'], name=o['name'], line=dict(color=next(c)), legendgroup="1"),
+                          row=1, col=1, secondary_y=True)
+
+    for num, tech_ind in enumerate(technical_indicator):
+        fig_tech = px.line(tech_ind)
+        for t in fig_tech.data:
+            color = next(c)
+
+            fig.add_trace(
+                go.Scatter(x=t['x'], y=t['y'], name=t['name'], line=dict(color=color),
+                           legendgroup=str(2 + num),
+
+                           ),
+                row=2 + num, col=1)
+
+    # hide holiday
+    if resample == 'D':
+        dt_all = pd.date_range(start=index_value[0], end=index_value[-1])
+        # retrieve the dates that are in the original dataset
+        dt_obs = [d.strftime("%Y-%m-%d") for d in pd.to_datetime(index_value)]
+        # define dates with missing values
+        dt_breaks = [d for d in dt_all.strftime(
+            "%Y-%m-%d").tolist() if d not in dt_obs]
+        # hide dates with no values
+        fig.update_xaxes(rangebreaks=[dict(values=dt_breaks)])
+
+    fig.update_layout(
+        height=600 + 100 * technical_func_num,
+    )
+
+    fig.update_layout(
+        yaxis1=dict(
+            title="volume",
+            titlefont=dict(
+                color="#777"
+            ),
+            tickfont=dict(
+                color="#777"
+            ),
+            range=[df.volume.min(), df.volume.max() * 2]
+        ),
+        yaxis2=dict(
+            title="price",
+            titlefont=dict(
+                color="#777"
+            ),
+            tickfont=dict(
+                color="#777"
+            ),
+            showgrid=False
+        ),
+        hovermode='x unified',
+    )
+
+    fig.update_layout(**{
+        'xaxis1_rangeslider_visible': False,
+        f'xaxis': dict(
+            rangeselector=dict(
+                buttons=list([
+                    dict(count=6,
+                         label="6m",
+                         step="month",
+                         stepmode="backward"),
+                    dict(count=1,
+                         label="YTD",
+                         step="year",
+                         stepmode="todate"),
+                    dict(count=1,
+                         label="1y",
+                         step="year",
+                         stepmode="backward"),
+                    dict(step="all")
+                ])
+            ),
+        ),
+        f'xaxis{nrows}': dict(
+            rangeslider=dict(
+                visible=True,
+                thickness=0.1,
+                bgcolor='gainsboro',
+            ),
+            type="date",
+        ),
+    })
+
+    # fig.update_traces(xaxis='x2')
+    fig.update_xaxes(showspikes=True)
+    fig.update_yaxes(showspikes=True, spikemode="across")
+    fig.update_layout(showlegend=False)
+    fig.update_layout(plot_bgcolor="white")
+    fig.update_xaxes(showline=True, linecolor='#ddd')
+    fig.update_yaxes(showline=True, linecolor='#ddd')
+    fig.update_yaxes(titlefont=dict(
+        color="#777"
+    ),
+        tickfont=dict(
+            color="#777"
+    ))
+
+    fig.update_layout(title={'text': f'Candlestick Plot {stock_id}', 'font': {
+                      'size': 18, 'color': 'gray'}})
+
+    return fig
+
+
+def plot_tw_stock_candles(stock_id, recent_days=400, adjust_price=False, resample='D', overlay_func=None,
+                          technical_func=None):
+    """繪製台股技術線圖圖組
+    Args:
+        stock_id (str): 台股股號，ex:`'2330'`。
+        recent_days (int):取近n個交易日資料。
+        adjust_price (bool):是否使用還原股價計算。
+        resample (str): 技術指標價格週期，ex: `D` 代表日線, `W` 代表週線, `M` 代表月線。
+        overlay_func (dict):
+            K線圖輔助線，預設使用布林通道。
+             ```py
+             from finlab.data import indicator
+
+             overlay_func={
+                          'ema_5':indicator('EMA',timeperiod=5),
+                          'ema_10':indicator('EMA',timeperiod=10),
+                          'ema_20':indicator('EMA',timeperiod=20),
+                          'ema_60':indicator('EMA',timeperiod=60),
+                         }
+             ```
+        technical_func (list):
+            技術指標子圖，預設使用KD技術指標單組子圖。
+
+            設定多組技術指標：
+            ```py
+            from finlab.data import indicator
+
+            k,d = indicator('STOCH')
+            rsi = indicator('RSI')
+            technical_func = [{'K':k,'D':d},{'RSI':rsi}]
+            ```
+
+    Returns:
+        (plotly.graph_objects.Figure): 技術線圖
+
+    Examples:
+        ```py
+        from finlab.plot import plot_tw_stock_candles
+        from finlab.data import indicator
+
+        overlay_func={
+                      'ema_5':indicator('EMA',timeperiod=5),
+                      'ema_10':indicator('EMA',timeperiod=10),
+                      'ema_20':indicator('EMA',timeperiod=20),
+                      'ema_60':indicator('EMA',timeperiod=60),
+                     }
+        k,d = indicator('STOCH')
+        rsi = indicator('RSI')
+        technical_func = [{'K':k,'D':d},{'RSI':rsi}]
+        plot_tw_stock_candles(stock_id='2330',recent_days=600,adjust_price=False,overlay_func=overlay_func,technical_func=technical_func)
+        ```
+    """
+    if adjust_price:
+        close = data.get('etl:adj_close')[stock_id]
+        open_ = data.get('etl:adj_open')[stock_id]
+        high = data.get('etl:adj_high')[stock_id]
+        low = data.get('etl:adj_low')[stock_id]
+    else:
+        close = data.get('price:收盤價')[stock_id]
+        open_ = data.get('price:開盤價')[stock_id]
+        high = data.get('price:最高價')[stock_id]
+        low = data.get('price:最低價')[stock_id]
+
+    volume = data.get('price:成交股數')[stock_id]
+
+    return plot_candles(stock_id, close, open_, high, low, volume, recent_days=recent_days, resample=resample,
+                        overlay_func=overlay_func, technical_func=technical_func)
+
+
+"""
+Treemap
+"""
+
+
+def df_date_filter(df, start=None, end=None):
+    if start:
+        df = df[df.index >= start]
+    if end:
+        df = df[df.index <= end]
+    return df
+
+
+def create_treemap_data(start, end, item='return_ratio', clip=None):
+    """產生台股板塊圖資料
+
+    產生繪製樹狀圖所用的資料，可再外加FinLab資料庫以外的指標製作客製化DataFrame，
+    並傳入`plot_tw_stock_treemap(treemap_data=treemap_data)。`
+
+    Args:
+      start (str): 資料開始日，ex:`"2021-01-02"`。
+      end (str):資料結束日，ex:`"2021-01-05"`。
+      item (str): 決定板塊顏色深淺的指標。
+                  除了可選擇依照 start 與 end 計算的`"return_ratio"`(報酬率)，
+                  亦可選擇[FinLab資料庫](https://ai.finlab.tw/database)內的指標顯示近一期資料。
+          example:
+
+          * `'price_earning_ratio:本益比'` - 顯示近日產業的本益比高低。
+          * `'monthly_revenue:去年同月增減(%)'` - 顯示近月的單月營收年增率。
+
+      clip (tuple): 將item邊界外的值分配給邊界值，防止資料上限值過大或過小，造成顏色深淺變化不明顯。
+                    ex:(0,100)，將數值低高界線，設為0~100，超過的數值。
+        !!! note
+
+            參考[pandas文件](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.clip.html)更了解`pd.clip`細節。
+
+    Returns:
+        (pd.DataFrame): 台股個股指標
+    Examples:
+
+        欲下載所有上市上櫃之價量歷史資料與產業分類，只需執行此函式:
+
+        ``` py
+        from finlab.plot import create_treemap_data
+        create_treemap_data(start= '2021-07-01',end = '2021-07-02')
+        ```
+
+        | stock_id   |  close |turnover|category|market|market_value|return_ratio|country|
+        |:-----------|-------:|-------:|-------:|-------:|-------:|-------:|-------:|
+        | 1101       |   20 |  57.85 |  水泥工業 |  sii   |    111  |    0.1  |  TW-Stock|
+        | 1102       |  20 |  58.1  |  水泥工業 |  sii    |    111  |    -0.1 |  TW-Stock|
+
+
+    """
+    close = data.get('price:收盤價')
+    basic_info = data.get('company_basic_info')
+    turnover = data.get('price:成交金額')
+    close_data = df_date_filter(close, start, end)
+    turnover_data = df_date_filter(
+        turnover, start, end).iloc[1:].sum() / 100000000
+    return_ratio = (
+        close_data.loc[end] / close_data.loc[start]).dropna().replace(np.inf, 0)
+    return_ratio = round((return_ratio - 1) * 100, 2)
+
+    concat_list = [close_data.iloc[-1], turnover_data, return_ratio]
+    col_names = ['stock_id', 'close', 'turnover', 'return_ratio']
+    if item not in ["return_ratio", "turnover_ratio"]:
+        try:
+            custom_item = df_date_filter(
+                data.get(item), start, end).iloc[-1].fillna(0)
+        except Exception as e:
+            logger.error(
+                'data error, check the data is existed between start and end.')
+            logger.error(e)
+            return None
+        if clip:
+            custom_item = custom_item.clip(*clip)
+        concat_list.append(custom_item)
+        col_names.append(item)
+
+    df = pd.concat(concat_list, axis=1).dropna()
+    df = df.reset_index()
+    df.columns = col_names
+
+    basic_info_df = basic_info.copy().reset_index()
+    basic_info_df['stock_id_name'] = basic_info_df['stock_id'].astype(
+        str) + basic_info_df['公司簡稱']
+
+    df = df.merge(basic_info_df[['stock_id', 'stock_id_name', '產業類別', '市場別', '實收資本額(元)']], how='left',
+                  on='stock_id')
+    df = df.rename(columns={'產業類別': 'category',
+                   '市場別': 'market', '實收資本額(元)': 'base'})
+    df = df.dropna(thresh=5)
+    df['market_value'] = round(df['base'] / 10 * df['close'] / 100000000, 2)
+    df['country'] = 'TW-Stock'
+    return df
+
+
+def plot_tw_stock_treemap(start=None, end=None, area_ind='market_value', item='return_ratio', clip=None,
+                          color_continuous_scale='Temps', treemap_data=None):
+    """繪製台股板塊圖資料
+
+    巢狀樹狀圖可以顯示多維度資料，將依照產業分類的台股資料絢麗顯示。
+
+    Args:
+      start (str): 資料開始日，ex:`'2021-01-02'`。
+      end (str): 資料結束日，ex:`'2021-01-05'`。
+      area_ind (str): 決定板塊面積數值的指標。
+                      可選擇`["market_value","turnover"]`，數值代表含義分別為市值、成交金額。
+      item (str): 決定板塊顏色深淺的指標。
+                  除了可選擇依照 start 與 end 計算的`"return_ratio"`(報酬率)，
+                  亦可選擇[FinLab資料庫](https://ai.finlab.tw/database)內的指標顯示近一期資料。
+          example:
+
+          * `'price_earning_ratio:本益比'` - 顯示近日產業的本益比高低。
+          * `'monthly_revenue:去年同月增減(%)'` - 顯示近月的單月營收年增率。
+
+      clip (tuple): 將 item 邊界外的值分配給邊界值，防止資料上限值過大或過小，造成顏色深淺變化不明顯。
+                    ex:(0,100)，將數值低高界線，設為 0~100，超過的數值。
+        !!!note
+
+            參考[pandas文件](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.clip.html)更了解`pd.clip`細節。
+      color_continuous_scale (str):[顏色變化序列的樣式名稱](https://plotly.com/python/builtin-colorscales/)
+      treemap_data (pd.DataFrame): 客製化資料，格式參照 `create_treemap_data()` 返回值。
+    Returns:
+        (plotly.graph_objects.Figure): 樹狀板塊圖
+    Examples:
+        ex1:
+        板塊面積顯示成交金額，顏色顯示'2021-07-01'～'2021-07-02'的報酬率變化，可以觀察市場資金集中的產業與漲跌強弱。
+        ```py
+        from finlab.plot import plot_tw_stock_treemap
+        plot_tw_stock_treemap(start= '2021-07-01',end = '2021-07-02',area_ind="turnover",item="return_ratio")
+        ```
+        ![成交佔比/報酬率板塊圖](img/plot/treemap_return.png)
+        ex2:
+        板塊面積顯示市值(股本*收盤價)，顏色顯示近期本益比，可以觀察全市場哪些是權值股？哪些產業本益比評價高？限制數值範圍在(0,50)，
+        將過高本益比的數值壓在50，不讓顏色變化突兀，能分出高低階層即可。
+        ```py
+        from finlab.plot import plot_tw_stock_treemap
+        plot_tw_stock_treemap(area_ind="market_value",item="price_earning_ratio:本益比",clip=(0,50), color_continuous_scale='RdBu_r')
+        ```
+        ![市值/本益比板塊圖](img/plot/treemap_pe.png)
+    """
+    if treemap_data is None:
+        df = create_treemap_data(start, end, item, clip)
+    else:
+        df = treemap_data.copy()
+
+    if df is None:
+        return None
+    df['custom_item_label'] = round(df[item], 2).astype(str)
+    df.dropna(how='any', inplace=True)
+
+    if area_ind not in df.columns:
+        return None
+
+    if item in ['return_ratio']:
+        color_continuous_midpoint = 0
+    else:
+        color_continuous_midpoint = np.average(df[item], weights=df[area_ind])
+
+    fig = px.treemap(df,
+                     path=['country', 'market', 'category', 'stock_id_name'],
+                     values=area_ind,
+                     color=item,
+                     color_continuous_scale=color_continuous_scale,
+                     color_continuous_midpoint=color_continuous_midpoint,
+                     custom_data=['custom_item_label', 'close', 'turnover'],
+                     title=f'TW-Stock Market TreeMap({start}~{end})'
+                           f'---area_ind:{area_ind}---item:{item}',
+                     width=1600,
+                     height=800)
+
+    fig.update_traces(textposition='middle center',
+                      textfont_size=24,
+                      texttemplate="%{label}<br>(%{customdata[1]})<br>%{customdata[0]}",
+                      )
+    return fig
+
+
+"""
+Radar
+"""
+
+
+def plot_radar(df, mode='bar_polar', line_polar_fill=None, title=None, polar_range=10):
+    args = dict(data_frame=df, r="value", theta="variable", color="stock_id", line_close=True,
+                color_discrete_sequence=px.colors.sequential.Plasma_r,
+                template="plotly_dark")
+    if mode != 'line_polar':
+        args.pop('line_close')
+
+    fig = getattr(px, mode)(**args)
+    if title is None:
+        title = 'Features Radar'
+    fig.update_layout(
+        title={
+            'text': title,
+            'x': 0.49,
+            'y': 0.99,
+            'xanchor': 'center',
+            'yanchor': 'top'},
+        paper_bgcolor='rgb(41, 30, 109)',
+        polar=dict(
+            radialaxis=dict(
+                visible=True,
+                range=[0, polar_range]
+            )),
+        width=1200,
+        height=600)
+    if mode == 'line_polar':
+        # None,toself,tonext
+        fig.update_traces(fill=line_polar_fill)
+    return fig
+
+
+def get_rank(item: str, period=None, cut_bins=10):
+    df = data.get(item)
+    if period == None:
+        df = df.iloc[-1]
+    else:
+        df = df.loc[period]
+
+    df_rank = df.rank(pct=True)
+    df_rank = pd.cut(x=df_rank, bins=cut_bins, labels=[
+                     i for i in range(1, cut_bins + 1)])
+    return df_rank
+
+
+def get_rank_df(feats: list, period=None, cut_bins=10):
+    df = pd.concat([get_rank(f, period, cut_bins) for f in feats], axis=1)
+    columns_name = [f[f.index(':') + 1:] for f in feats]
+    df.columns = columns_name
+    df.index.name = 'stock_id'
+    return df
+
+
+def plot_tw_stock_radar(portfolio, feats=None, mode='line_polar', line_polar_fill=None,
+                        period=None, cut_bins=10, title=None, custom_data=None):
+    """繪製台股雷達圖
+
+    比較持股組合的指標分級特性。若數值為nan，則不顯示分級。
+
+    Args:
+      portfolio (list):持股組合，ex:`['1101','1102']`。
+      feats (list): 選定FinLab資料庫內的指標組成資料集。預設為18項財務指標。
+                    ex:['fundamental_features:營業毛利率','fundamental_features:營業利益率']
+      mode (str): 雷達圖模式 ，ex:'bar_polar','scatter_polar','line_polar'`。
+        !!!note
+
+            參考[不同模式的差異](https://plotly.com/python-api-reference/generated/plotly.express.html)
+      line_polar_fill (str):將區域設置為用純色填充 。ex:`None,'toself','tonext'`
+                           `'toself'`將跡線的端點（或跡線的每一段，如果它有間隙）連接成一個封閉的形狀。
+                           如果一條完全包圍另一條（例如連續的等高線），則`'tonext'`填充兩條跡線之間的空間，如果之前沒有跡線，
+                           則其行為類似於`'toself'`。如果一條跡線不包含另一條跡線，則不應使用`'tonext'`。
+        欲使用 line_polar，請將pandas版本降至 1.4.4。
+        !!!note
+
+            參考[plotly.graph_objects.Scatterpolar.fill](https://plotly.github.io/plotly.py-docs/generated/plotly.graph_objects.Scatterpolar.html)
+
+      period (str): 選擇第幾期的特徵資料，預設為近一季。
+                    ex: 設定數值為'2020-Q2，取得2020年第二季資料比較。
+      cut_bins (int):特徵分級級距。
+      title (str):圖片標題名稱。
+      custom_data (pd.DataFrame): 客製化指標分級，欄名為特徵
+                    格式範例:
+
+        | stock_id   |  營業毛利率 |營業利益率|稅後淨利率|
+        |:-----------|-------:|-------:|-------:|
+        | 1101       |   2    |    5   |      3|
+        | 1102       |   1    |    8   |      4|
+    Returns:
+        (plotly.graph_objects.Figure): 雷達圖
+    Examples:
+        ex1:比較持股組合累計分數，看持股組合偏重哪像特徵。
+        ```py
+        from finlab.plot import plot_tw_stock_radar
+        plot_tw_stock_radar(portfolio=["1101", "2330", "8942", "6263"], mode="bar_polar", line_polar_fill='None')
+        ```
+        ![持股組合雷達圖](img/plot/radar_many.png)
+        ex2:看單一個股特徵分級落點。
+        ```py
+        from finlab.plot import plot_tw_stock_radar
+        feats = ['fundamental_features:營業毛利率', 'fundamental_features:營業利益率', 'fundamental_features:稅後淨利率',
+                 'fundamental_features:現金流量比率', 'fundamental_features:負債比率']
+        plot_tw_stock_radar(portfolio=["9939"], feats=feats, mode="line_polar", line_polar_fill='toself', cut_bins=8)
+        ```
+        ![單檔標的子選指標雷達圖](img/plot/radar_single.png)
+    """
+    if custom_data is None:
+        if feats is None:
+            feats = ['fundamental_features:營業毛利率', 'fundamental_features:營業利益率',
+                     'fundamental_features:稅後淨利率',
+                     'fundamental_features:ROA綜合損益', 'fundamental_features:ROE綜合損益',
+                     'fundamental_features:業外收支營收率',
+                     'fundamental_features:現金流量比率', 'fundamental_features:負債比率',
+                     'fundamental_features:流動比率', 'fundamental_features:速動比率',
+                     'fundamental_features:存貨週轉率',
+                     'fundamental_features:營收成長率', 'fundamental_features:營業毛利成長率',
+                     'fundamental_features:營業利益成長率', 'fundamental_features:稅前淨利成長率',
+                     'fundamental_features:稅後淨利成長率',
+                     'fundamental_features:資產總額成長率', 'fundamental_features:淨值成長率'
+                     ]
+        df = get_rank_df(feats, period=period, cut_bins=cut_bins)
+    else:
+        df = custom_data.copy()
+
+    col_name = df.columns
+    portfolio = df.index.intersection(portfolio)
+    if len(portfolio) < 1:
+        logger.error('data is not existed.')
+        return
+    df = df.loc[portfolio]
+    df = df.reset_index()
+    df = pd.melt(df, id_vars=['stock_id'], value_vars=col_name)
+    polar_range = cut_bins * len(portfolio)
+    fig = plot_radar(df=df, mode=mode, line_polar_fill=line_polar_fill,
+                     title=title, polar_range=polar_range)
+    return fig
+
+
+"""
+PE PB River
+"""
+
+
+def get_pe_river_data(start=None, end=None, stock_id='2330', mode='pe', split_range=6):
+    if mode not in ['pe', 'pb']:
+        logger.error('mode error')
+        return None
+    close = df_date_filter(data.get('price:收盤價'), start, end)
+    pe = df_date_filter(data.get('price_earning_ratio:本益比'), start, end)
+    pb = df_date_filter(data.get('price_earning_ratio:股價淨值比'), start, end)
+    df = eval(mode)
+    if stock_id not in df.columns:
+        logger.error('stock_id input is not in data.')
+        return None
+    df = df[stock_id]
+    max_value = df.max()
+    min_value = df.min()
+    quan_value = (max_value - min_value) / split_range
+    river_borders = [round(min_value + quan_value * i, 2)
+                     for i in range(0, split_range + 1)]
+    result = (close[stock_id] / df).dropna().to_frame()
+    index_name = f'{mode}/close'
+    result.columns = [index_name]
+    result['close'] = close[stock_id]
+    result['pe'] = pe[stock_id]
+    result['pb'] = pb[stock_id]
+    for r in river_borders:
+        col_name = f"{r} {mode}"
+        result[col_name] = result[index_name] * r
+    result = round(result, 2)
+    return result
+
+
+def plot_tw_stock_river(stock_id='2330', start=None, end=None, mode='pe', split_range=8):
+    """繪製台股河流圖
+
+    使用 PE or PB 的最高與最低值繪製河流圖，判斷指標所處位階。
+
+    Args:
+      stock_id (str): 台股股號，ex:`'2330'`。
+      start (str): 資料開始日，ex:`'2020-01-02'`。
+      end (str): 資料結束日，ex:`'2022-01-05'`。
+      mode (str): `'pe'` or `'pb'` (本益比或股價淨值比)。
+      split_range (int): 河流階層數。
+    Returns:
+        (plotly.graph_objects.Figure): 河流圖
+    Examples:
+      ```py
+      from finlab.plot import plot_tw_stock_river
+      plot_tw_stock_river(stock_id='2330', start='2015-1-1', end='2022-7-1', mode='pe', split_range=10)
+      ```
+      ![單檔標的子選指標雷達圖](img/plot/pe_river.png)
+    """
+    df = get_pe_river_data(start, end, stock_id, mode, split_range)
+    if df is None:
+        logger.error('data error')
+        return None
+    col_name_set = [i for i in df.columns if any(map(str.isdigit, i))]
+
+    fig = go.Figure()
+    for n, c in enumerate(col_name_set):
+        if n == 0:
+            fill_mode = None
+        else:
+            fill_mode = 'tonexty'
+        fig.add_trace(
+            go.Scatter(x=df.index, y=df[c], fill=fill_mode, line=dict(width=0, color=px.colors.qualitative.Prism[n]),
+                       name=c))
+    customdata = [(c, p) for c, p in zip(df['close'], df[mode])]
+    hovertemplate = "<br>date:%{x|%Y/%m/%d}<br>close:%{customdata[0]}" + \
+        f"<br>{mode}" + ":%{customdata[1]}"
+    fig.add_trace(go.Scatter(x=df.index, y=df['close'], line=dict(width=2.5, color='#2e4391'), customdata=customdata,
+                             hovertemplate=hovertemplate, name='close'))
+
+    security_categories = data.get('security_categories').set_index('stock_id')
+    stock_name = security_categories.loc[stock_id]['name']
+    fig.update_layout(title=f"{stock_id} {stock_name} {mode.upper()} River Chart",
+                      template="ggplot2",
+                      yaxis=dict(
+                          title='price',
+                      ),
+                      # hovermode='x unified',
+                      )
+    fig.update_xaxes(showspikes=True)
+    fig.update_yaxes(showspikes=True)
+    return fig
+
+
+class StrategySunburst:
+    def __init__(self):
+        """繪製策略部位旭日圖
+
+        監控多策略。
+        """
+        d = data.get_strategies()
+        for k, v in d.items():
+            if 'position' in d[k]['positions']:
+                d[k]['positions'] = d[k]['positions']['position']
+        self.s_data = d
+
+    def process_position(self, s_name, s_weight=1):
+        if s_name == '現金':
+            result = pd.DataFrame(
+                {'return': 0, 'weight': 1, 'category': '現金', 'market': '現金'}, index=['現金'])
+            result.index.name = 'stock_id'
+        else:
+            df = pd.DataFrame(self.s_data[s_name]['positions'])
+            df = df[[c for c in df.columns if ' ' in c]]
+            df = df.T
+            df['weight'] = df['weight'].apply(
+                lambda s: abs(pd.to_numeric(s, errors='coerce')))
+            df = df[df['weight'] > 0]
+            if len(df) == 0:
+                df['weight'] = 0
+            df.index.name = 'stock_id'
+            old_security_categories = data.get(
+                'security_categories').reset_index()
+            security_categories = old_security_categories.copy()
+            security_categories['category'] = security_categories['category'].fillna(
+                'other_securities')
+            security_categories['stock_id'] = security_categories['stock_id'] + \
+                ' ' + security_categories['name']
+            security_categories = security_categories.set_index(['stock_id'])
+            result = df.join(security_categories)
+
+            asset_type = self.s_data[s_name]['asset_type']
+            if asset_type == '':
+                asset_type = 'tw_stock'
+            elif asset_type == 'crypto':
+                category = 'crypto'
+                result['category'] = category
+
+            result['market'] = asset_type
+            cash = pd.DataFrame({'return': 0, 'weight': 1 - (df['weight'].sum()), 'category': '現金', 'market': '現金'},
+                                index=['現金'])
+            cash.index.name = 'stock_id'
+            result = pd.concat([result, cash])
+
+        result['s_name'] = s_name
+        result['s_weight'] = s_weight
+        return result
+
+    def get_strategy_df(self, select_strategy=None):
+        """獲取策略部位與分配權重後計算的資料
+
+        Args:
+          select_strategy (dict): 選擇策略名稱並設定權重，預設是抓取權策略並平分資金比例到各策略。
+                                 ex:`{'低波動本益成長比':0.5,'研發魔人':0.2, '現金':0.2}`
+        Returns:
+            (pd.DataFrame): strategies data
+        """
+        if select_strategy is None:
+            s_name = self.s_data.keys()
+            s_num = len(s_name)
+            if s_num == 0:
+                return None
+            s_weight = [1 / s_num] * len(s_name)
+        else:
+            s_name = select_strategy.keys()
+            s_weight = select_strategy.values()
+
+        all_position = pd.concat([self.process_position(
+            name, weight) for name, weight in zip(s_name, s_weight)])
+        all_position['weight'] *= all_position['s_weight']
+        all_position['return'] = round(all_position['return'].astype(float), 2)
+        all_position['color'] = round(
+            all_position['return'].clip(all_position['return'].min() / 2, all_position['return'].max() / 2), 2)
+        all_position = all_position[all_position['weight'] > 0]
+        all_position = all_position.reset_index()
+        all_position = all_position[all_position['s_name'] != 'playground']
+        all_position['category'] = all_position['category'].fillna(
+            'other_securities')
+        return all_position
+
+    def plot(self, select_strategy=None, path=None, color_continuous_scale='RdBu_r'):
+        """繪圖
+
+        Args:
+          select_strategy (dict): 選擇策略名稱並設定權重，預設是抓取權策略並平分資金比例到各策略。
+                                 ex:`{'低波動本益成長比':0.5,'研發魔人':0.2, '現金':0.2}`
+          path (list): 旭日圖由裡到外的顯示路徑，預設為`['s_name', 'market', 'category', 'stock_id']`。
+                       `['market', 'category','stock_id','s_name']`也是常用選項。
+          color_continuous_scale (str):[顏色變化序列的樣式名稱](https://plotly.com/python/builtin-colorscales/)
+
+        Returns:
+            (plotly.graph_objects.Figure): 策略部位旭日圖
+        Examples:
+            ```py
+            from finlab.plot import StrategySunburst
+
+            # 實例化物件
+            strategies = StrategySunburst()
+            strategies.plot().show()
+            strategies.plot(select_strategy={'高殖利率烏龜':0.4,'營收強勢動能瘋狗':0.25,'低波動本益成長比':0.2,'現金':0.15},path =  ['market', 'category','stock_id','s_name']).show()
+            ```
+        ex1:策略選到哪些標的?
+        ![市值/本益比板塊圖](img/plot/sunburst1.png)
+
+        ex2:部位被哪些策略選到，標的若被不同策略選到，可能有獨特之處喔！
+        ![市值/本益比板塊圖](img/plot/sunburst2.png)
+        """
+        position = self.get_strategy_df(select_strategy)
+        if position is None:
+            return
+        position = position[(position['return'] != np.inf)
+                            | (position['weight'] != np.inf)]
+        if path is None:
+            path = ['s_name', 'market', 'category', 'stock_id']
+        fig = px.sunburst(position, path=path, values='weight',
+                          color='color', hover_data=['return'],
+                          color_continuous_scale=color_continuous_scale,
+                          color_continuous_midpoint=0,
+                          width=1000, height=800)
+        return fig
+
+
+class StrategyReturnStats:
+
+    def __init__(self, start_date: str, end_date: str, strategy_names=[], benchmark_return=None):
+        """繪製策略報酬率統計比較圖
+
+        監控策略群體相對對標指數的表現。
+
+        Args:
+            start_date (str): 報酬率計算開始日
+            end_date (str): 報酬率計算結束日
+            strategy_names (list): 用戶本人的策略集設定，填入欲納入統計的策略名稱，只限定自己的策略。ex:`['膽小貓','三頻率RSI策略', '二次創高股票',...]`，預設為全部已上傳的策略。
+            benchmark_return (pandas.Series): 策略比對基準序列，預設為台股加權報酬指數。
+
+
+        Examples:
+
+            統計2022-12-31~2023-07-31的報酬率數據
+            ``` py
+            # 回測起始時間
+            start_date = '2022-12-31'
+            end_date  = '2023-07-31'
+
+            # 選定策略範圍
+            strategy_names = ['膽小貓','三頻率RSI策略', '二次創高股票', '低波動本益成長比', '合約負債建築工', '多產業價投', '小蝦米跟大鯨魚', '小資族資優生策略', '本益成長比', '營收股價雙渦輪', '現金流價值成長', '研發魔人', '股價淨值比策略', '藏獒', '高殖利率烏龜','監獄兔', '財報指標20大']
+
+            report = StrategyReturnStats(start_date ,end_date, strategy_names)
+            # 繪製策略報酬率近期報酬率長條圖
+            report.plot_strategy_last_return().show()
+            # 繪製策略累積報酬率時間序列
+            report.plot_strategy_creturn().show()
+            ```
+
+        """
+        # 回測起始時間
+        self.start_date = start_date
+        self.end_date = end_date
+
+        # 選定策略範圍
+        self.s_data = data.get_strategies()
+        self.strategy_names = strategy_names
+        self.benchmark_return = data.get('benchmark_return:發行量加權股價報酬指數')[
+            '發行量加權股價報酬指數'] if benchmark_return is None else benchmark_return
+        self.returns_set = self._get_returns_set()
+
+    def _get_returns_set(self):
+        """計算報酬率數據
+        Returns:
+            (dict): 報酬率數據，ex: `{'膽小貓': -5.98,'股價淨值比策略': -1.68,...}`
+        """
+        returns_set = {}
+        strategy_names = self.s_data.keys() if len(
+            self.strategy_names) == 0 else self.strategy_names
+        for s_name in strategy_names:
+            try:
+                s_df = self.s_data[s_name]
+                returns = pd.Series(
+                    s_df['returns']['value'], index=s_df['returns']['time'])
+                if self.start_date:
+                    returns = returns[returns.index >= self.start_date]
+                if self.end_date:
+                    returns = returns[returns.index <= self.end_date]
+                return_value = round(
+                    ((returns.iloc[-1] / returns.iloc[0]) - 1) * 100, 2)
+                returns_set[s_name] = return_value
+            except:
+                pass
+
+        returns_set = dict(sorted(returns_set.items(), key=lambda x: x[1]))
+        return returns_set
+
+    def get_benchmark_return(self):
+        """設定對標指數
+        Returns:
+            (pandas.Series): 對標指數時間序列
+        """
+        benchmark_return = self.benchmark_return
+        benchmark_return = benchmark_return[
+            (benchmark_return.index >= self.start_date) & (benchmark_return.index <= self.end_date)]
+        return benchmark_return
+
+    def plot_strategy_last_return(self):
+        """繪製策略報酬率近期報酬率長條圖
+        Returns:
+            (plotly.graph_objects.Figure): 圖表物件
+        ![繪製策略報酬率近期報酬率長條圖](img/plot/finlab_strategy_performance.png)
+        """
+        returns_set = self.returns_set
+        benchmark_return = self.get_benchmark_return()
+        benchmark_last_return = round(
+            ((benchmark_return.iloc[-1] / benchmark_return.iloc[0]) - 1) * 100, 2)
+
+        fig = go.Figure(go.Bar(
+            x=list(returns_set.values()),
+            y=list(returns_set.keys()),
+            marker=dict(
+                color='rgba(50, 171, 96, 0.6)',
+                line=dict(color='rgba(50, 171, 96, 1)', width=3)
+            ),
+            orientation='h'))
+
+        fig.add_vline(x=benchmark_last_return, line_width=3, line_dash="dash", line_color="#4a6dce",
+                      annotation_text=f"benchmark:{benchmark_last_return}",
+                      annotation_position="top left")
+
+        returns_mean = round(sum((returns_set.values())) / len(returns_set), 2)
+
+        fig.add_vline(x=returns_mean, line_width=3, line_dash="dash", line_color="#aa00ff",
+                      annotation_font_color="#aa00ff", annotation_text=f"strategy_mean:{returns_mean}",
+                      annotation_position="bottom right")
+
+        fig.update_layout(
+            title=f'FinLab Strategy Performance ({self.start_date}~{self.end_date})',
+            legend=dict(x=0.029, y=1.038, font_size=12),
+            margin=dict(l=100, r=20, t=70, b=70),
+            paper_bgcolor='rgb(248, 248, 255)',
+            plot_bgcolor='rgb(248, 248, 255)',
+            xaxis_title="return(%)",
+        )
+
+        return fig
+
+    def plot_strategy_creturn(self):
+        """繪製策略累積報酬率時間序列
+        Returns:
+            (plotly.graph_objects.Figure): 圖表物件
+        ![繪製策略累積報酬率時間序列](img/plot/finlab_strategy_creturn.png)
+        """
+
+        returns_set = self.returns_set
+        benchmark_return = self.get_benchmark_return()
+
+        sorted_s_names = list(returns_set.keys())[::-1]
+
+        returns_set2 = {}
+        for s_name in sorted_s_names:
+            s_df = self.s_data[s_name]
+            returns = pd.Series(s_df['returns']['value'],
+                                index=s_df['returns']['time'])
+            if self.start_date:
+                returns = returns[returns.index >= self.start_date]
+            if self.end_date:
+                returns = returns[returns.index <= self.end_date]
+            returns_set2[s_name] = round(
+                ((returns / returns.iloc[0]) - 1) * 100, 2)
+
+        returns_df = pd.DataFrame(
+            returns_set2).unstack().to_frame().reset_index()
+        returns_df.columns = ['strategy', 'date', 'creturns']
+        benchmark_creturn = round(
+            ((benchmark_return / benchmark_return.iloc[0]) - 1) * 100, 2)
+
+        fig = px.line(returns_df, x="date", y="creturns", color="strategy")
+        fig.add_trace(
+            go.Scatter(x=benchmark_creturn.index, y=benchmark_creturn.values, fill='tonexty', name='benchmark',
+                       opacity=0.2,
+                       marker=dict(
+                           color='LightSkyBlue',
+                           opacity=0.2,
+                           size=20,
+                           line=dict(
+                               color='MediumPurple',
+                               width=2
+                           )
+                       ), ))
+
+        fig.update_layout(
+            title=f'FinLab Strategy Creturn ({self.start_date}~{self.end_date})',
+            margin=dict(l=100, r=20, t=70, b=70),
+            paper_bgcolor='rgb(248, 248, 255)',
+            plot_bgcolor='rgb(248, 248, 255)',
+            yaxis_title="creturn (%)",
+        )
+
+        fig.update_layout(yaxis_range=(
+            returns_df["creturns"].min() - 0.1, returns_df["creturns"].max() + 0.1))
+
+        return fig
```

## finlab/utils.py

```diff
@@ -1,239 +1,239 @@
-import os
-import re
-import sys
-import json
-import logging
-import tempfile
-from pathlib import Path
-import finlab
-from finlab.core.utils_core import str_to_bytearray
-
-# Get an instance of a logger
-logger = logging.getLogger(__name__)
-
-def requests_module_factory():
-
-    """Creates a requests module
-
-    The function returns requests module if it is installed.
-    If requests module is not installed, raise error to inform user.
-    If the python version is pyodide, try to create a custom requests module.
-
-    Returns:
-        requests module
-
-    """
-
-    # check requests is installed and return the module
-    if "pyodide" not in sys.modules:
-        import requests
-        return requests
-
-    # raise error if not install requests and not in pyodide env
-    from js import XMLHttpRequest, Blob, FormData
-    import urllib.parse
-    from pyodide import http
-    import pyodide
-
-    # in pyodide env, make fake requests
-    class Response:
-        text = ''
-        json_ = ''
-        content = ''
-        ok = True
-
-        def json(self):
-            return self.json_
-
-    class requests:
-
-        def getBytes(url):
-            req = XMLHttpRequest.new()
-            req.open("GET", url, False)
-            req.overrideMimeType('text/plain; charset=x-user-defined')
-            req.send(None)
-            return str_to_bytearray(req.response)
-
-        def get(url, params=None):
-
-            if params == None:
-                params = {}
-
-
-            complete_url = url + '?' + '&'.join([
-                urllib.parse.quote_plus(k)
-                + '=' + urllib.parse.quote_plus(v)
-                for k, v in params.items()])
-
-            str_io = http.open_url(complete_url)
-
-            res = Response()
-            res.text = str_io.read()
-            res.json_ = requests.parse_json(res.text)
-            res.status_code = 200
-
-            return res
-
-        def post(url, data, asyn=False):
-
-            if data == None:
-                data = {}
-
-
-            req = XMLHttpRequest.new()
-            form = FormData.new()
-
-            for k, v in data.items():
-                form.append(k, v)
-
-            req.open("POST", url, asyn)
-            req.send(form)
-
-            res = Response()
-            res.content = req.response
-            res.text = str(req.response)
-            res.json_ = requests.parse_json(res.text)
-            res.status_code = 200
-
-            return res
-
-        def parse_json(text):
-
-            if len(text) == 0:
-                return {}
-
-            if text[-1] == '\n':
-                text = text[:-1]
-
-            if text[0] != '{' or text[-1] != '}':
-                return {}
-
-            try:
-                return json.loads(text)
-            except:
-                return {}
-
-    return requests
-
-import os
-import tempfile
-from pathlib import Path
-
-def get_tmp_dir():
-    # Check if running in Google Colab
-    if 'COLAB_GPU' in os.environ:
-        # Try to use Google Drive as the tmp directory
-        try:
-            from google.colab import drive
-
-            # Mount Google Drive
-            if not os.path.exists('/content/drive/'):
-                drive.mount('/content/drive')
-            
-            # Custom tmp dir inside Google Drive
-            google_drive_tmp_dir = Path("/content/drive/My Drive/Colab_tmp/finlab_db")
-            google_drive_tmp_dir.mkdir(parents=True, exist_ok=True)
-
-            return str(google_drive_tmp_dir)
-        
-        except ImportError:
-            print("Google Drive is not mounted. Please mount Google Drive to use as tmp directory.")
-            raise
-
-    # If running in a cloud function environment
-    elif os.environ.get('FUNCTION_TARGET', None):
-        # Set tmp directory to be /tmp for cloud functions
-        tmp_subdir = Path("/tmp/finlab_db")
-        tmp_subdir.mkdir(parents=True, exist_ok=True)
-        return str(tmp_subdir)
-
-
-    # For local machine use-cases
-    else:
-        # Default tmp directory
-        home_dir = Path.home()
-
-        # Create 'finlab_db' under tmp directory
-        tmp_subdir = Path(home_dir) / 'finlab_db'
-        tmp_subdir.mkdir(parents=True, exist_ok=True)
-
-        return str(tmp_subdir)
-
-
-
-def check_version_function_factory():
-
-    """ Check finlab package version is the latest or not
-
-    if the package version is out of date, info user to update.
-
-    Returns
-        None
-
-    """
-    if "pyodide" in sys.modules:
-        return lambda : None
-
-    latest_package_version = None
-
-    def ret():
-
-        nonlocal latest_package_version
-
-        if latest_package_version is None:
-            res = requests.get('https://pypi.org/project/finlab/')
-            res.encoding = 'utf-8'
-
-            m = re.findall("finlab\s([a-z0-9.]*)\s*</h1>", res.text)
-            latest_package_version =  m[0] if m else None
-
-            if latest_package_version != finlab.__version__:
-                logger.warning(f'Your version is {finlab.__version__}, please install a newer version.\nUse "pip install finlab=={latest_package_version}" to update the latest version.')
-
-    return ret
-
-
-def global_object_getter_setter_factory():
-    _finlab_global_objects = {}
-
-    def get_global(name):
-        nonlocal _finlab_global_objects
-        if name in _finlab_global_objects:
-            return _finlab_global_objects[name]
-        else:
-            return None
-
-    def set_global(name, obj):
-        nonlocal _finlab_global_objects
-        _finlab_global_objects[name] = obj
-        if "pyodide" in sys.modules and "js" in sys.modules:
-            import js
-            from pyodide import ffi
-            if hasattr(js, "_pyodide_execution_id"):
-                js.postMessage(ffi.to_js({'content': obj, 'finish': False, 'type': name, 'id': js._pyodide_execution_id}))
-
-
-    return get_global, set_global
-
-def notify_progress(snippet_id, position, progress):
-    """  notify progress of the backtest (only work in pyodide)
-    """
-
-    if "pyodide" in sys.modules and "js" in sys.modules:
-        import js
-        from pyodide import ffi
-        if hasattr(js, "_pyodide_execution_id"):
-            content = {
-                "nstocks": (position!=0).sum(axis=1).mean(),
-                "timestamp": snippet_id,
-                "progress": progress,
-            }
-
-            js.postMessage(ffi.to_js({'content': content, 'finish': False, 'type': "backtest-progress", 'id': js._pyodide_execution_id}))
-
-
-get_global, set_global = global_object_getter_setter_factory()
-
-requests = requests_module_factory()
-check_version = check_version_function_factory()
-
+import os
+import re
+import sys
+import json
+import logging
+import tempfile
+from pathlib import Path
+import finlab
+from finlab.core.utils_core import str_to_bytearray
+
+# Get an instance of a logger
+logger = logging.getLogger(__name__)
+
+def requests_module_factory():
+
+    """Creates a requests module
+
+    The function returns requests module if it is installed.
+    If requests module is not installed, raise error to inform user.
+    If the python version is pyodide, try to create a custom requests module.
+
+    Returns:
+        requests module
+
+    """
+
+    # check requests is installed and return the module
+    if "pyodide" not in sys.modules:
+        import requests
+        return requests
+
+    # raise error if not install requests and not in pyodide env
+    from js import XMLHttpRequest, Blob, FormData
+    import urllib.parse
+    from pyodide import http
+    import pyodide
+
+    # in pyodide env, make fake requests
+    class Response:
+        text = ''
+        json_ = ''
+        content = ''
+        ok = True
+
+        def json(self):
+            return self.json_
+
+    class requests:
+
+        def getBytes(url):
+            req = XMLHttpRequest.new()
+            req.open("GET", url, False)
+            req.overrideMimeType('text/plain; charset=x-user-defined')
+            req.send(None)
+            return str_to_bytearray(req.response)
+
+        def get(url, params=None, **kwargs):
+
+            if params == None:
+                params = {}
+
+
+            complete_url = url + '?' + '&'.join([
+                urllib.parse.quote_plus(k)
+                + '=' + urllib.parse.quote_plus(v)
+                for k, v in params.items()])
+
+            str_io = http.open_url(complete_url)
+
+            res = Response()
+            res.text = str_io.read()
+            res.json_ = requests.parse_json(res.text)
+            res.status_code = 200
+
+            return res
+
+        def post(url, data, asyn=False, **kwargs):
+
+            if data == None:
+                data = {}
+
+
+            req = XMLHttpRequest.new()
+            form = FormData.new()
+
+            for k, v in data.items():
+                form.append(k, v)
+
+            req.open("POST", url, asyn)
+            req.send(form)
+
+            res = Response()
+            res.content = req.response
+            res.text = str(req.response)
+            res.json_ = requests.parse_json(res.text)
+            res.status_code = 200
+
+            return res
+
+        def parse_json(text):
+
+            if len(text) == 0:
+                return {}
+
+            if text[-1] == '\n':
+                text = text[:-1]
+
+            if text[0] != '{' or text[-1] != '}':
+                return {}
+
+            try:
+                return json.loads(text)
+            except:
+                return {}
+
+    return requests
+
+import os
+import tempfile
+from pathlib import Path
+
+def get_tmp_dir():
+    # Check if running in Google Colab
+    if 'COLAB_GPU' in os.environ:
+        # Try to use Google Drive as the tmp directory
+        try:
+            from google.colab import drive
+
+            # Mount Google Drive
+            if not os.path.exists('/content/drive/'):
+                drive.mount('/content/drive')
+
+            # Custom tmp dir inside Google Drive
+            google_drive_tmp_dir = Path("/content/drive/My Drive/Colab_tmp/finlab_db")
+            google_drive_tmp_dir.mkdir(parents=True, exist_ok=True)
+
+            return str(google_drive_tmp_dir)
+
+        except ImportError:
+            print("Google Drive is not mounted. Please mount Google Drive to use as tmp directory.")
+            raise
+
+    # If running in a cloud function environment
+    elif os.environ.get('FUNCTION_TARGET', None):
+        # Set tmp directory to be /tmp for cloud functions
+        tmp_subdir = Path("/tmp/finlab_db")
+        tmp_subdir.mkdir(parents=True, exist_ok=True)
+        return str(tmp_subdir)
+
+
+    # For local machine use-cases
+    else:
+        # Default tmp directory
+        home_dir = Path.home()
+
+        # Create 'finlab_db' under tmp directory
+        tmp_subdir = Path(home_dir) / 'finlab_db'
+        tmp_subdir.mkdir(parents=True, exist_ok=True)
+
+        return str(tmp_subdir)
+
+
+
+def check_version_function_factory():
+
+    """ Check finlab package version is the latest or not
+
+    if the package version is out of date, info user to update.
+
+    Returns
+        None
+
+    """
+    if "pyodide" in sys.modules:
+        return lambda : None
+
+    latest_package_version = None
+
+    def ret():
+
+        nonlocal latest_package_version
+
+        if latest_package_version is None:
+            res = requests.get('https://pypi.org/project/finlab/')
+            res.encoding = 'utf-8'
+
+            m = re.findall("finlab\s([a-z0-9.]*)\s*</h1>", res.text)
+            latest_package_version =  m[0] if m else None
+
+            if latest_package_version != finlab.__version__:
+                logger.warning(f'Your version is {finlab.__version__}, please install a newer version.\nUse "pip install finlab=={latest_package_version}" to update the latest version.')
+
+    return ret
+
+
+def global_object_getter_setter_factory():
+    _finlab_global_objects = {}
+
+    def get_global(name):
+        nonlocal _finlab_global_objects
+        if name in _finlab_global_objects:
+            return _finlab_global_objects[name]
+        else:
+            return None
+
+    def set_global(name, obj):
+        nonlocal _finlab_global_objects
+        _finlab_global_objects[name] = obj
+        if "pyodide" in sys.modules and "js" in sys.modules:
+            import js
+            from pyodide import ffi
+            if hasattr(js, "_pyodide_execution_id"):
+                js.postMessage(ffi.to_js({'content': obj, 'finish': False, 'type': name, 'id': js._pyodide_execution_id}))
+
+
+    return get_global, set_global
+
+def notify_progress(snippet_id, position, progress):
+    """  notify progress of the backtest (only work in pyodide)
+    """
+
+    if "pyodide" in sys.modules and "js" in sys.modules:
+        import js
+        from pyodide import ffi
+        if hasattr(js, "_pyodide_execution_id"):
+            content = {
+                "nstocks": (position!=0).sum(axis=1).mean(),
+                "timestamp": snippet_id,
+                "progress": progress,
+            }
+
+            js.postMessage(ffi.to_js({'content': content, 'finish': False, 'type': "backtest-progress", 'id': js._pyodide_execution_id}))
+
+
+get_global, set_global = global_object_getter_setter_factory()
+
+requests = requests_module_factory()
+check_version = check_version_function_factory()
+
```

## finlab/analysis/__init__.py

 * *Ordering differences only*

```diff
@@ -1,195 +1,195 @@
-from abc import ABC
-from finlab.core.report import Report as ReportPyx
-
-
-class Analysis(ABC):
-
-    def is_market_info_supported(self, market_info):
-        """Check if market info is supported
-
-        Returns:
-          (bool): True, support. False not support.
-        """
-        return True
-
-    def calculate_trade_info(self, report):
-        """Additional trade info can be calculated easily.
-
-        User could override this function if additional trade info is required for later anlaysis.
-
-        Examples:
-
-          ``` py
-          from finlab.analysis import Analysis
-
-          class SomeAnalysis(Analysis):
-            def calculate_trade_info(self, report):
-              return [
-                ['股價淨值比', data.get('price_earning_ratio:股價淨值比'), 'entry_sig_date']
-              ]
-
-          report.run_analysis(SomeAnalysis())
-          trades = report.get_trades()
-
-          assert '股價淨值比@entry_sig_date' in trades.columns
-
-          print(trades)
-          ```
-        """
-        return []
-
-    def analyze(self, report):
-        """Analyze trading report.
-
-        One could assume self.caluclate_trade_info will be executed before self.analyze,
-        so the `report.get_trades()` will contain the required trade info.
-        """
-        pass
-
-    def display(self):
-        """Display result
-
-        When implement this function, returning Plotly figure instance is recommended.
-        """
-        pass
-
-
-class Report(ReportPyx):
-    def __init__(self, creturn, position, fee_ratio, tax_ratio, trade_at, next_trading_date, market_info):
-        """策略回測基礎報告
-        Args:
-          creturn (pd.Series): 策略報酬率時間序列。
-          position (pd.DataFrame): 策略報酬率時間序列。
-          fee_ratio (float): 交易手續費率，預設為台灣無打折手續費 0.001425。可視個人使用的券商優惠調整費率。
-          tax_ratio (float): 交易稅率，預設為台灣普通股一般交易交易稅率 0.003。若交易策略的標的皆為 ETF，記得設成 0.001。
-          trade_at (str): 選擇回測之還原股價以收盤價或開盤價計算，預設為 close。可選 close 或 open。
-          next_trading_date (str): 預期下期換股日。
-          market_info (str or MarketInfo): 可選擇`'TWSTOCK', 'CRYPTO'`，分別為台股或加密貨幣，
-                                                                     或繼承 `finlab.market_info.MarketInfo` 開發回測市場類別。
-        Attributes:
-          benchmark (pd.Series): 對標報酬率曲線的時間序列，用於 Report.display() 顯示策略報酬率比較標準。
-          update_date (str): 用於 Report.display() 顯示策略對標的報酬率曲線。
-          asset_type (str): 資產類別， tw_stock 或 crypto。
-          last_trading_date (str): 最近產生交易訊號的日期。
-        """
-        super().__init__(creturn, position, fee_ratio, tax_ratio, trade_at, next_trading_date, market_info)
-
-    def upload(self, name=None):
-        """上傳回測報告資料到量化平台網站
-        Args:
-          name (str): 策略名稱。
-        """
-        return super().upload(name)
-
-    def position_info(self):
-        """取得近期持有部位與預期換股資訊
-        Returns:
-          (dict): 部位資訊
-        """
-        return super().position_info()
-
-    def display(self, return_fig=False):
-        """顯示回測報酬率圖組
-        Args:
-           return_fig (bool): 是否回傳圖組
-        Returns:
-          (plotly.graph_objects.Figure): 圖組
-
-        Examples:
-          設定對標指數
-          ```py
-          from finlab import data
-          ...
-          report = sim(position, resample='Q',mae_mfe_window=30,mae_mfe_window_step=2)
-          report.benchmark = data.get('benchmark_return:發行量加權股價報酬指數').squeeze()
-          report.display()
-          ```
-          ![報酬率圖組](img/analysis/display.png)
-        """
-        return super().display(return_fig)
-
-    def get_mae_mfe(self):
-        """取得 mae_mfe 時序資料
-
-        Returns:
-          (pd.DataFrame): 波動時序資料
-        """
-        return super().get_mae_mfe()
-
-    def get_trades(self):
-        """取得回測逐筆交易紀錄
-
-        Returns:
-          (pd.DataFrame): 交易紀錄，欄位包含：
-
-            * entry_sig_date:進場訊號產生日。
-            * exit_sig_date:出場訊號產生日。
-            * entry_date:進場日。
-            * exit_date:出場日。
-            * position:持有佔比。
-            * period:持有天數。
-            * return:報酬率。
-            * trade_price@entry_date:進場價。
-            * trade_price@exit_date:出場價。
-            * mae:持有期間最大不利報酬率幅度。
-            * gmfe:持有期間最大有利報酬率幅度。
-            * bmfe:mae發生前的最大有利報酬率幅度。
-            * mdd:持有期間最大回撤。
-            * pdays:處於獲利時的天數。
-        """
-        return super().get_trades()
-
-    def get_stats(self, resample='1d', riskfree_rate=0.02):
-        """取得策略統計數據
-        取得數據如：年化報酬、勝率、夏普率、索提諾比率、最大回檔、近期各年月報酬率統計、alpha_beta...
-        Args:
-            resample (str): 報酬率檢測週期，其他常用數值為 W、 M 、Q（每週、每月、每季換股）。
-            riskfree_rate (float): 無風險利率，與夏普率計算有關。
-        Returns:
-            (dict): 策略指標數據
-        """
-        return super().get_stats(resample, riskfree_rate)
-
-    def run_analysis(self, analysis, display=True, **kwargs):
-        """執行策略分析外掛模組
-        Args:
-          analysis (str or object): `finlab.analysis`內的分析模組名稱，ex:`'liquidityAnalysis'`。
-          display (bool): 是否顯示模組分析圖表。
-          **kwargs (mapping, optional): 分析模組參數調整。
-        Returns:
-          (pd.DataFrame or plotly.graph_objects.Figure): 分析結果
-        """
-        return super().run_analysis(analysis, display=display, **kwargs)
-
-    def display_mae_mfe_analysis(self, violinmode='group', mfe_scatter_x='mae', **kwargs):
-        """ 顯示波動分析圖組
-
-        [分析使用說明](https://www.finlab.tw/display_mae_mfe_analysis/)。
-        Args:
-          violinmode (str): violin 型態統計圖樣式，模式分為 group 與 overlay。
-                            預設為 group，group 模式為將交易勝敗分群統計'，overlay 採取全數統計。
-          mfe_scatter_x (str): 子圖 2-1、2-2 MFE 散點圖的X軸比較項目設定，可選`'mae' or 'return'`。
-          **kwargs (dict): 其餘圖表外觀(layout)參數。
-        Returns:
-          (plotly.graph_objects.Figure): 波動分析圖組
-
-        Examples:
-          group :
-          ![波動分析圖組](img/analysis/display_mae_mfe_group.png)
-
-          overlay :
-          ![波動分析圖組](img/analysis/display_mae_mfe_overlay.png)
-        """
-        return super().display_mae_mfe_analysis(violinmode, mfe_scatter_x, **kwargs)
-    
-    def display(self, lagacy=False, save_report_path=None):
-        """ 顯示回測報告
-
-        Args:
-            lagacy (bool): True, 使用舊版報告格式。False, 使用新版報告格式。
-            save_report_path (str): 報告儲存路徑，預設為 None，即不儲存報告。
-            
-        Returns:
-            None
-        """
-
+from abc import ABC
+from finlab.core.report import Report as ReportPyx
+
+
+class Analysis(ABC):
+
+    def is_market_info_supported(self, market_info):
+        """Check if market info is supported
+
+        Returns:
+          (bool): True, support. False not support.
+        """
+        return True
+
+    def calculate_trade_info(self, report):
+        """Additional trade info can be calculated easily.
+
+        User could override this function if additional trade info is required for later anlaysis.
+
+        Examples:
+
+          ``` py
+          from finlab.analysis import Analysis
+
+          class SomeAnalysis(Analysis):
+            def calculate_trade_info(self, report):
+              return [
+                ['股價淨值比', data.get('price_earning_ratio:股價淨值比'), 'entry_sig_date']
+              ]
+
+          report.run_analysis(SomeAnalysis())
+          trades = report.get_trades()
+
+          assert '股價淨值比@entry_sig_date' in trades.columns
+
+          print(trades)
+          ```
+        """
+        return []
+
+    def analyze(self, report):
+        """Analyze trading report.
+
+        One could assume self.caluclate_trade_info will be executed before self.analyze,
+        so the `report.get_trades()` will contain the required trade info.
+        """
+        pass
+
+    def display(self):
+        """Display result
+
+        When implement this function, returning Plotly figure instance is recommended.
+        """
+        pass
+
+
+class Report(ReportPyx):
+    def __init__(self, creturn, position, fee_ratio, tax_ratio, trade_at, next_trading_date, market_info):
+        """策略回測基礎報告
+        Args:
+          creturn (pd.Series): 策略報酬率時間序列。
+          position (pd.DataFrame): 策略報酬率時間序列。
+          fee_ratio (float): 交易手續費率，預設為台灣無打折手續費 0.001425。可視個人使用的券商優惠調整費率。
+          tax_ratio (float): 交易稅率，預設為台灣普通股一般交易交易稅率 0.003。若交易策略的標的皆為 ETF，記得設成 0.001。
+          trade_at (str): 選擇回測之還原股價以收盤價或開盤價計算，預設為 close。可選 close 或 open。
+          next_trading_date (str): 預期下期換股日。
+          market_info (str or MarketInfo): 可選擇`'TWSTOCK', 'CRYPTO'`，分別為台股或加密貨幣，
+                                                                     或繼承 `finlab.market_info.MarketInfo` 開發回測市場類別。
+        Attributes:
+          benchmark (pd.Series): 對標報酬率曲線的時間序列，用於 Report.display() 顯示策略報酬率比較標準。
+          update_date (str): 用於 Report.display() 顯示策略對標的報酬率曲線。
+          asset_type (str): 資產類別， tw_stock 或 crypto。
+          last_trading_date (str): 最近產生交易訊號的日期。
+        """
+        super().__init__(creturn, position, fee_ratio, tax_ratio, trade_at, next_trading_date, market_info)
+
+    def upload(self, name=None):
+        """上傳回測報告資料到量化平台網站
+        Args:
+          name (str): 策略名稱。
+        """
+        return super().upload(name)
+
+    def position_info(self):
+        """取得近期持有部位與預期換股資訊
+        Returns:
+          (dict): 部位資訊
+        """
+        return super().position_info()
+
+    def display(self, return_fig=False):
+        """顯示回測報酬率圖組
+        Args:
+           return_fig (bool): 是否回傳圖組
+        Returns:
+          (plotly.graph_objects.Figure): 圖組
+
+        Examples:
+          設定對標指數
+          ```py
+          from finlab import data
+          ...
+          report = sim(position, resample='Q',mae_mfe_window=30,mae_mfe_window_step=2)
+          report.benchmark = data.get('benchmark_return:發行量加權股價報酬指數').squeeze()
+          report.display()
+          ```
+          ![報酬率圖組](img/analysis/display.png)
+        """
+        return super().display(return_fig)
+
+    def get_mae_mfe(self):
+        """取得 mae_mfe 時序資料
+
+        Returns:
+          (pd.DataFrame): 波動時序資料
+        """
+        return super().get_mae_mfe()
+
+    def get_trades(self):
+        """取得回測逐筆交易紀錄
+
+        Returns:
+          (pd.DataFrame): 交易紀錄，欄位包含：
+
+            * entry_sig_date:進場訊號產生日。
+            * exit_sig_date:出場訊號產生日。
+            * entry_date:進場日。
+            * exit_date:出場日。
+            * position:持有佔比。
+            * period:持有天數。
+            * return:報酬率。
+            * trade_price@entry_date:進場價。
+            * trade_price@exit_date:出場價。
+            * mae:持有期間最大不利報酬率幅度。
+            * gmfe:持有期間最大有利報酬率幅度。
+            * bmfe:mae發生前的最大有利報酬率幅度。
+            * mdd:持有期間最大回撤。
+            * pdays:處於獲利時的天數。
+        """
+        return super().get_trades()
+
+    def get_stats(self, resample='1d', riskfree_rate=0.02):
+        """取得策略統計數據
+        取得數據如：年化報酬、勝率、夏普率、索提諾比率、最大回檔、近期各年月報酬率統計、alpha_beta...
+        Args:
+            resample (str): 報酬率檢測週期，其他常用數值為 W、 M 、Q（每週、每月、每季換股）。
+            riskfree_rate (float): 無風險利率，與夏普率計算有關。
+        Returns:
+            (dict): 策略指標數據
+        """
+        return super().get_stats(resample, riskfree_rate)
+
+    def run_analysis(self, analysis, display=True, **kwargs):
+        """執行策略分析外掛模組
+        Args:
+          analysis (str or object): `finlab.analysis`內的分析模組名稱，ex:`'liquidityAnalysis'`。
+          display (bool): 是否顯示模組分析圖表。
+          **kwargs (mapping, optional): 分析模組參數調整。
+        Returns:
+          (pd.DataFrame or plotly.graph_objects.Figure): 分析結果
+        """
+        return super().run_analysis(analysis, display=display, **kwargs)
+
+    def display_mae_mfe_analysis(self, violinmode='group', mfe_scatter_x='mae', **kwargs):
+        """ 顯示波動分析圖組
+
+        [分析使用說明](https://www.finlab.tw/display_mae_mfe_analysis/)。
+        Args:
+          violinmode (str): violin 型態統計圖樣式，模式分為 group 與 overlay。
+                            預設為 group，group 模式為將交易勝敗分群統計'，overlay 採取全數統計。
+          mfe_scatter_x (str): 子圖 2-1、2-2 MFE 散點圖的X軸比較項目設定，可選`'mae' or 'return'`。
+          **kwargs (dict): 其餘圖表外觀(layout)參數。
+        Returns:
+          (plotly.graph_objects.Figure): 波動分析圖組
+
+        Examples:
+          group :
+          ![波動分析圖組](img/analysis/display_mae_mfe_group.png)
+
+          overlay :
+          ![波動分析圖組](img/analysis/display_mae_mfe_overlay.png)
+        """
+        return super().display_mae_mfe_analysis(violinmode, mfe_scatter_x, **kwargs)
+    
+    def display(self, lagacy=False, save_report_path=None):
+        """ 顯示回測報告
+
+        Args:
+            lagacy (bool): True, 使用舊版報告格式。False, 使用新版報告格式。
+            save_report_path (str): 報告儲存路徑，預設為 None，即不儲存報告。
+            
+        Returns:
+            None
+        """
+
```

## finlab/analysis/alphaBetaAnalysis.py

 * *Ordering differences only*

```diff
@@ -1,74 +1,74 @@
-import math
-import pandas as pd
-import numpy as np
-from finlab import data
-from finlab.analysis import Analysis
-
-def safe_division(n, d):
-    return n / d if d else 0
-
-calc_cagr = (
-    lambda s: (s.add(1).prod()) ** safe_division(365.25, (s.index[-1] - s.index[0]).days) - 1 
-    if len(s) > 1 else 0)
-
-class AlphaBetaAnalysis(Analysis):
-
-    def __init__(self):
-        self._result = None
-
-    def is_market_info_supported(self, market_info):
-        return 'TWMarketInfo' in str(market_info)
-
-    @staticmethod
-    def calculate_alpha_beta(creturn, benchmark):
-
-        a = creturn
-        b = benchmark
-
-        beta = pd.DataFrame({'a': a.values, 'b': b.values}).cov().iloc[0,1] / b.var()
-
-        cagr_a = calc_cagr(creturn)
-        cagr_b = calc_cagr(benchmark)
-        alpha = cagr_a - beta * cagr_b
-
-        return alpha, beta
-
-    def analyze(self, report):
-
-        creturn_pct = report.daily_creturn.pct_change()
-        benchmark_pct = report.daily_benchmark\
-                .pct_change()\
-                .fillna(0)\
-                .reindex(creturn_pct.index, method='ffill')
-
-        # recent metrics
-        recent = {'alpha': [], 'beta': [], 'ndays': [], 'info': []}
-        for n in [0, 20, 60, 120, 252]:
-            a = creturn_pct.iloc[-n:]
-            b = benchmark_pct.loc[a.index[0]:].reindex(a.index)
-
-            alpha, beta = self.calculate_alpha_beta(a, b)
-            recent['alpha'].append(0 if math.isnan(alpha) else alpha)
-            recent['beta'].append(1 if math.isnan(beta) else beta)
-            recent['ndays'].append(n)
-
-        # yearly metrics
-        yearly = {'alpha': [], 'beta': [], 'year': []}
-        for year in range(creturn_pct.index[0].year, creturn_pct.index[-1].year+1):
-            a = creturn_pct.loc[str(year)]
-            b = benchmark_pct.loc[str(year)]
-            alpha, beta = self.calculate_alpha_beta(a, b)
-            yearly['alpha'].append(0 if math.isnan(alpha) else alpha)
-            yearly['beta'].append(1 if math.isnan(beta) else beta)
-            yearly['year'].append(year)
-
-        # overall metrics
-        alpha, beta = self.calculate_alpha_beta(creturn_pct, benchmark_pct)
-
-        return {
-            'yearly': yearly,
-            'recent': recent,
-            'overall': {'alpha': alpha, 'beta': beta}
-        }
-        
-
+import math
+import pandas as pd
+import numpy as np
+from finlab import data
+from finlab.analysis import Analysis
+
+def safe_division(n, d):
+    return n / d if d else 0
+
+calc_cagr = (
+    lambda s: (s.add(1).prod()) ** safe_division(365.25, (s.index[-1] - s.index[0]).days) - 1 
+    if len(s) > 1 else 0)
+
+class AlphaBetaAnalysis(Analysis):
+
+    def __init__(self):
+        self._result = None
+
+    def is_market_info_supported(self, market_info):
+        return 'TWMarketInfo' in str(market_info)
+
+    @staticmethod
+    def calculate_alpha_beta(creturn, benchmark):
+
+        a = creturn
+        b = benchmark
+
+        beta = pd.DataFrame({'a': a.values, 'b': b.values}).cov().iloc[0,1] / b.var()
+
+        cagr_a = calc_cagr(creturn)
+        cagr_b = calc_cagr(benchmark)
+        alpha = cagr_a - beta * cagr_b
+
+        return alpha, beta
+
+    def analyze(self, report):
+
+        creturn_pct = report.daily_creturn.pct_change()
+        benchmark_pct = report.daily_benchmark\
+                .pct_change()\
+                .fillna(0)\
+                .reindex(creturn_pct.index, method='ffill')
+
+        # recent metrics
+        recent = {'alpha': [], 'beta': [], 'ndays': [], 'info': []}
+        for n in [0, 20, 60, 120, 252]:
+            a = creturn_pct.iloc[-n:]
+            b = benchmark_pct.loc[a.index[0]:].reindex(a.index)
+
+            alpha, beta = self.calculate_alpha_beta(a, b)
+            recent['alpha'].append(0 if math.isnan(alpha) else alpha)
+            recent['beta'].append(1 if math.isnan(beta) else beta)
+            recent['ndays'].append(n)
+
+        # yearly metrics
+        yearly = {'alpha': [], 'beta': [], 'year': []}
+        for year in range(creturn_pct.index[0].year, creturn_pct.index[-1].year+1):
+            a = creturn_pct.loc[str(year)]
+            b = benchmark_pct.loc[str(year)]
+            alpha, beta = self.calculate_alpha_beta(a, b)
+            yearly['alpha'].append(0 if math.isnan(alpha) else alpha)
+            yearly['beta'].append(1 if math.isnan(beta) else beta)
+            yearly['year'].append(year)
+
+        # overall metrics
+        alpha, beta = self.calculate_alpha_beta(creturn_pct, benchmark_pct)
+
+        return {
+            'yearly': yearly,
+            'recent': recent,
+            'overall': {'alpha': alpha, 'beta': beta}
+        }
+        
+
```

## finlab/analysis/drawdownAnalysis.py

 * *Ordering differences only*

```diff
@@ -1,44 +1,44 @@
-import pandas as pd
-from finlab.analysis import Analysis
-from finlab.ffn_core import drawdown_details
-
-
-class DrawdownAnalysis(Analysis):
-
-    @staticmethod
-    def drawdown(series):
-        drawdown = series.to_drawdown_series()
-        drawdown_obj = {
-                'values': drawdown.values.tolist(),
-                'index': drawdown.index.values.tolist()
-                }
-
-        drawdown_result = drawdown_details(drawdown)
-
-        if drawdown_result is None:
-            drawdown_result = pd.DataFrame(columns=("Start", "End", "Length", "drawdown"))
-        
-        details = (drawdown_result
-            .assign(Start=lambda df: df.Start.astype(str).str.split(' ').str[0])
-            .assign(End=lambda df: df.Start.astype(str).str.split(' ').str[0])
-            .set_index('Start')
-            )
-
-        longest_drawdown_details = (details
-            .sort_values('Length')
-            .tail(5)
-            .to_dict('index'))
-
-        max_drawdown_details = (details
-            .sort_values('drawdown')
-            .head(5)
-            .to_dict('index'))
-
-        return {'drawdown': drawdown_obj, 'longest_drawdown': longest_drawdown_details, 
-                'largest_drawdown':max_drawdown_details}
-
-    def analyze(self, report):
-        return {
-            'strategy': self.drawdown(report.daily_creturn),
-            'benchmark': self.drawdown(report.daily_benchmark)
-        }
+import pandas as pd
+from finlab.analysis import Analysis
+from finlab.ffn_core import drawdown_details
+
+
+class DrawdownAnalysis(Analysis):
+
+    @staticmethod
+    def drawdown(series):
+        drawdown = series.to_drawdown_series()
+        drawdown_obj = {
+                'values': drawdown.values.tolist(),
+                'index': drawdown.index.values.tolist()
+                }
+
+        drawdown_result = drawdown_details(drawdown)
+
+        if drawdown_result is None:
+            drawdown_result = pd.DataFrame(columns=("Start", "End", "Length", "drawdown"))
+        
+        details = (drawdown_result
+            .assign(Start=lambda df: df.Start.astype(str).str.split(' ').str[0])
+            .assign(End=lambda df: df.Start.astype(str).str.split(' ').str[0])
+            .set_index('Start')
+            )
+
+        longest_drawdown_details = (details
+            .sort_values('Length')
+            .tail(5)
+            .to_dict('index'))
+
+        max_drawdown_details = (details
+            .sort_values('drawdown')
+            .head(5)
+            .to_dict('index'))
+
+        return {'drawdown': drawdown_obj, 'longest_drawdown': longest_drawdown_details, 
+                'largest_drawdown':max_drawdown_details}
+
+    def analyze(self, report):
+        return {
+            'strategy': self.drawdown(report.daily_creturn),
+            'benchmark': self.drawdown(report.daily_benchmark)
+        }
```

## finlab/analysis/inequalityAnalysis.py

 * *Ordering differences only*

```diff
@@ -1,155 +1,155 @@
-from finlab.analysis import Analysis
-from finlab import data
-from finlab.dataframe import FinlabDataFrame
-import pandas as pd
-import numpy as np
-
-
-class InequalityAnalysis(Analysis):
-
-  def __init__(self, name, df=None, date_type='entry_sig_date', target='return'):
-
-    """Analyze return of trades with condition inequality
-    
-    Args:
-        name (str): name of the condition
-        df (pd.DataFrame or None): value used in condition. If df is None, `data.get(name)` will be automatically perform to fetch the values.
-        date_type (str): can be either `entry_date`, `entry_sig_date`, `exit_date`, `exit_sig_date`.
-        target (str): the target to optimize. Any column name in report.get_trades()
-
-    Examples:
-        ``` py
-        report.run_analysis('InequalityAnalysis', name='price_earning_ratio:股價淨值比')
-        ```
-    """
-
-    self._name = name
-    self._date_type = date_type
-    self._target = target
-    self._result = None
-    self._min_samples = 50
-    self._outlier_std = 3
-    self._df = data.get(name) if df is None else df
-
-    if isinstance(self._df, FinlabDataFrame):
-        self._df = self._df.index_str_to_date()
-
-    if not isinstance(self._df, pd.DataFrame) and not isinstance(self._df, FinlabDataFrame):
-      raise Exception(f"InequalityAnalysis: df type is {type(df)} not supported!")
-
-  def calculate_trade_info(self, report):
-    return [
-      [self._name, self._df, self._date_type]
-    ]
-
-  def analyze(self, report):
-
-    x = f'{self._name}@{self._date_type}'
-    y = self._target
-
-    trades = report.get_trades()
-    if x not in trades.columns:
-      raise Exception(f'InequalityAnalysis: cannot find {x} in report.get_trades()')
-
-    if y not in trades.columns:
-      raise Exception(f'InequalityAnalysis: cannot find {x} in report.get_trades()')
-
-    v = trades[[x, y]].sort_values(x)
-    v = v.reset_index(drop=True)
-    v.columns = ['x', 'y']
-    v = v.dropna(how='any')
-    outlier_std = self._outlier_std
-
-    ymean = v.y.mean()
-    ystd = v.y.std()
-    v['y'] = v.y.clip(ymean - outlier_std * ystd, ymean + outlier_std * ystd)
-
-    y_mean_lx = pd.Series(self.rcummean(v.y).values, index=v.index)
-    y_mean_sx = pd.Series(self.cummean(v.y).values, index=v.index)
-
-    v['y_mean_lx'] = y_mean_lx.values[::-1]
-    v['y_mean_sx'] = y_mean_sx.values
-
-    self._result = v
-    return self._result
-
-  @staticmethod
-  def cummean(s):
-    ret = s.cumsum() / np.arange(1, len(s)+1, 1) - s.mean()
-    return ret
-
-  @staticmethod
-  def rcummean(s):
-    return (s.sum() - s.cumsum()) / np.arange(len(s)+1, 1, -1) - s.mean()
-
-  def display(self):
-
-    from plotly.subplots import make_subplots
-    import plotly.graph_objects as go
-
-    v = self._result
-    x = self._name
-    y = self._target
-    min_samples = self._min_samples
-    outlier_std = self._outlier_std
-
-    if ':' in x:
-      x = x.split(':')[-1]
-
-    def to_xy(s):
-      return {'x': s.index.values, 'y': s.values}
-
-    fig = make_subplots(rows=2, cols=2,
-                        subplot_titles=(f"{x} < x", f"{x} > x", "", ""),
-                        shared_yaxes=True, shared_xaxes=True,
-                        vertical_spacing=0.02, horizontal_spacing=0.02)
-
-    log_scale = (v.x.values >= 0).all() & (np.std(np.log(v.x.values+0.1)) < np.std(v.x.values+0.1))
-
-
-
-    fig.add_trace(
-        go.Scatter(**to_xy(v.y_mean_lx.iloc[min_samples:]), name=f'mean {y} (drop small x)', hovertemplate="%{y:.2%}"),
-        row=1, col=2
-    )
-
-    fig.add_trace(
-            go.Scatter(**to_xy(v.y_mean_lx.rolling(100, min_periods=1, center=True).mean().iloc[min_samples:]), hovertemplate="%{y:.2%}",
-                          name=f'smooth {y} (drop small x)'),
-        row=1, col=2
-    )
-
-    fig.add_trace(
-        go.Scatter(**to_xy(v.x.iloc[min_samples:]),  name=f'trades'),
-        row=2, col=1
-    )
-
-    fig.add_trace(
-        go.Scatter(**to_xy(v.y_mean_sx.iloc[min_samples:]), name=f'mean {y} (drop large x)', hovertemplate="%{y:.2%}"),
-        row=1, col=1
-    )
-
-    fig.add_trace(
-        go.Scatter(**to_xy(v.y_mean_sx.rolling(100, min_periods=1, center=True).mean().iloc[min_samples:]),hovertemplate="%{y:.2%}", name=f'smooth {y} (drop large x)'),
-        row=1, col=1
-    )
-
-    s = v.x.copy()
-    s.index = s.index[::-1]
-
-    fig.add_trace(
-        go.Scatter(**to_xy(s.iloc[:-min_samples]), name=f'trades'),
-        row=2, col=2
-    )
-
-    fig.update_layout(height=500, width=800, title_text=f"Inequality Analysis")
-
-    if log_scale:
-      fig.update_layout(yaxis3=dict(type="log"),yaxis4=dict(type="log"))
-
-    fig.update_layout(yaxis1=dict(title='平均報酬增加'), yaxis3=dict(title=f'{x}'))
-    fig.update_layout(xaxis4=dict(autorange="reversed"))
-    fig.update_layout(hovermode="x")
-    fig.update_layout(xaxis3=dict(title="n trades"),xaxis4=dict(title="n trades"))
-    fig.update_layout(showlegend=False)
-    return fig
+from finlab.analysis import Analysis
+from finlab import data
+from finlab.dataframe import FinlabDataFrame
+import pandas as pd
+import numpy as np
+
+
+class InequalityAnalysis(Analysis):
+
+  def __init__(self, name, df=None, date_type='entry_sig_date', target='return'):
+
+    """Analyze return of trades with condition inequality
+    
+    Args:
+        name (str): name of the condition
+        df (pd.DataFrame or None): value used in condition. If df is None, `data.get(name)` will be automatically perform to fetch the values.
+        date_type (str): can be either `entry_date`, `entry_sig_date`, `exit_date`, `exit_sig_date`.
+        target (str): the target to optimize. Any column name in report.get_trades()
+
+    Examples:
+        ``` py
+        report.run_analysis('InequalityAnalysis', name='price_earning_ratio:股價淨值比')
+        ```
+    """
+
+    self._name = name
+    self._date_type = date_type
+    self._target = target
+    self._result = None
+    self._min_samples = 50
+    self._outlier_std = 3
+    self._df = data.get(name) if df is None else df
+
+    if isinstance(self._df, FinlabDataFrame):
+        self._df = self._df.index_str_to_date()
+
+    if not isinstance(self._df, pd.DataFrame) and not isinstance(self._df, FinlabDataFrame):
+      raise Exception(f"InequalityAnalysis: df type is {type(df)} not supported!")
+
+  def calculate_trade_info(self, report):
+    return [
+      [self._name, self._df, self._date_type]
+    ]
+
+  def analyze(self, report):
+
+    x = f'{self._name}@{self._date_type}'
+    y = self._target
+
+    trades = report.get_trades()
+    if x not in trades.columns:
+      raise Exception(f'InequalityAnalysis: cannot find {x} in report.get_trades()')
+
+    if y not in trades.columns:
+      raise Exception(f'InequalityAnalysis: cannot find {x} in report.get_trades()')
+
+    v = trades[[x, y]].sort_values(x)
+    v = v.reset_index(drop=True)
+    v.columns = ['x', 'y']
+    v = v.dropna(how='any')
+    outlier_std = self._outlier_std
+
+    ymean = v.y.mean()
+    ystd = v.y.std()
+    v['y'] = v.y.clip(ymean - outlier_std * ystd, ymean + outlier_std * ystd)
+
+    y_mean_lx = pd.Series(self.rcummean(v.y).values, index=v.index)
+    y_mean_sx = pd.Series(self.cummean(v.y).values, index=v.index)
+
+    v['y_mean_lx'] = y_mean_lx.values[::-1]
+    v['y_mean_sx'] = y_mean_sx.values
+
+    self._result = v
+    return self._result
+
+  @staticmethod
+  def cummean(s):
+    ret = s.cumsum() / np.arange(1, len(s)+1, 1) - s.mean()
+    return ret
+
+  @staticmethod
+  def rcummean(s):
+    return (s.sum() - s.cumsum()) / np.arange(len(s)+1, 1, -1) - s.mean()
+
+  def display(self):
+
+    from plotly.subplots import make_subplots
+    import plotly.graph_objects as go
+
+    v = self._result
+    x = self._name
+    y = self._target
+    min_samples = self._min_samples
+    outlier_std = self._outlier_std
+
+    if ':' in x:
+      x = x.split(':')[-1]
+
+    def to_xy(s):
+      return {'x': s.index.values, 'y': s.values}
+
+    fig = make_subplots(rows=2, cols=2,
+                        subplot_titles=(f"{x} < x", f"{x} > x", "", ""),
+                        shared_yaxes=True, shared_xaxes=True,
+                        vertical_spacing=0.02, horizontal_spacing=0.02)
+
+    log_scale = (v.x.values >= 0).all() & (np.std(np.log(v.x.values+0.1)) < np.std(v.x.values+0.1))
+
+
+
+    fig.add_trace(
+        go.Scatter(**to_xy(v.y_mean_lx.iloc[min_samples:]), name=f'mean {y} (drop small x)', hovertemplate="%{y:.2%}"),
+        row=1, col=2
+    )
+
+    fig.add_trace(
+            go.Scatter(**to_xy(v.y_mean_lx.rolling(100, min_periods=1, center=True).mean().iloc[min_samples:]), hovertemplate="%{y:.2%}",
+                          name=f'smooth {y} (drop small x)'),
+        row=1, col=2
+    )
+
+    fig.add_trace(
+        go.Scatter(**to_xy(v.x.iloc[min_samples:]),  name=f'trades'),
+        row=2, col=1
+    )
+
+    fig.add_trace(
+        go.Scatter(**to_xy(v.y_mean_sx.iloc[min_samples:]), name=f'mean {y} (drop large x)', hovertemplate="%{y:.2%}"),
+        row=1, col=1
+    )
+
+    fig.add_trace(
+        go.Scatter(**to_xy(v.y_mean_sx.rolling(100, min_periods=1, center=True).mean().iloc[min_samples:]),hovertemplate="%{y:.2%}", name=f'smooth {y} (drop large x)'),
+        row=1, col=1
+    )
+
+    s = v.x.copy()
+    s.index = s.index[::-1]
+
+    fig.add_trace(
+        go.Scatter(**to_xy(s.iloc[:-min_samples]), name=f'trades'),
+        row=2, col=2
+    )
+
+    fig.update_layout(height=500, width=800, title_text=f"Inequality Analysis")
+
+    if log_scale:
+      fig.update_layout(yaxis3=dict(type="log"),yaxis4=dict(type="log"))
+
+    fig.update_layout(yaxis1=dict(title='平均報酬增加'), yaxis3=dict(title=f'{x}'))
+    fig.update_layout(xaxis4=dict(autorange="reversed"))
+    fig.update_layout(hovermode="x")
+    fig.update_layout(xaxis3=dict(title="n trades"),xaxis4=dict(title="n trades"))
+    fig.update_layout(showlegend=False)
+    return fig
```

## finlab/analysis/liquidityAnalysis.py

 * *Ordering differences only*

```diff
@@ -1,137 +1,137 @@
-import pandas as pd
-from finlab import data
-from finlab.analysis import Analysis
-from finlab.market_info import TWMarketInfo
-
-
-class LiquidityAnalysis(Analysis):
-
-  def __init__(self, required_volume=200000, required_turnover=1000000):
-    """分析台股策略流動性風險項目的機率
-
-    !!! note
-        參考[VIP限定文章](https://www.finlab.tw/customized_liquidityanalysis/)更了解流動性檢測內容細節。
-    Args:
-        required_volume (int): 要求進出場時的單日成交股數至少要多少？
-        required_turnover (int): 要求進出場時的單日成交金額至少要多少元？避免成交股數夠，但因低價股因素，造成胃納量仍無法符合資金需求。
-
-    Examples:
-        ``` py
-
-        # better syntax
-        report.run_analysis('LiquidityAnalysis', required_volume=100000)
-
-        # original syntax
-        from finlab.analysis.liquidityAnalysis import LiquidityAnalysis
-        report.run_analysis(LiquidityAnalysis(required_volume=100000))
-        ```
-    """
-
-    self._required_volume = required_volume
-    self._required_turnover = required_turnover
-    self._result = None
-
-  def is_market_info_supported(self, market_info):
-    return 'TWMarketInfo' in str(market_info)
-
-  def calculate_trade_info(self, report):
-
-    # calculate trade bar return
-    adj_trade_price = report.market_info.get_trading_price(report.trade_at, adj=True)
-    adj_previous_close = report.market_info.get_trading_price('close', adj=True).shift()
-
-    # calculate money flow
-    trade_price = report.market_info.get_trading_price(report.trade_at, adj=False)
-    volume = report.market_info.get_price('volume', adj=False)
-
-    signal_dates = ["entry_date", "exit_date"]
-
-    ret = [
-      ["pct_change", adj_trade_price / adj_previous_close - 1, signal_dates],
-      ["turnover", trade_price * volume, signal_dates],
-      ["volume", volume, signal_dates]
-    ]
-
-    is_tw = isinstance(report.market_info, TWMarketInfo)
-
-
-    if is_tw:
-        flagged = data.get('etl:is_flagged_stock')
-        ret += [
-          ["類別", flagged, signal_dates],
-          # ["處置股", ~data.get('etl:disposal_stock_filter').shift(fill_value=False), signal_dates],
-          # ["警示股", ~data.get('etl:disposal_stock_filter').shift(fill_value=False), signal_dates],
-          # ["全額交割股", ~data.get('etl:full_cash_delivery_stock_filter').shift(fill_value=False), signal_dates]
-        ]
-
-    return ret
-
-  def analyze(self, report):
-    trades = report.get_trades()
-
-    if isinstance(report.market_info, TWMarketInfo):
-      entry_pct_range = (trades.entry_date >= '2015-6-1') * 0.03 + 0.07
-      exit_pct_range = (trades.exit_date >= '2015-6-1') * 0.03 + 0.07
-    else:
-      entry_pct_range = 0.1
-      exit_pct_range = 0.1
-
-    long_position = trades.position > 0
-
-    entry_buy_at_top = long_position & (trades['pct_change@entry_date'] > entry_pct_range * 0.95)
-    entry_sell_at_bottom = (~long_position) & (trades['pct_change@entry_date'] < -entry_pct_range * 0.95)
-
-    exit_sell_at_bottom = long_position & (trades['pct_change@exit_date'] < -exit_pct_range * 0.95)
-    exit_buy_at_top = (~long_position) & (trades['pct_change@exit_date'] > exit_pct_range * 0.95)
-
-    trade_pct_count = trades['pct_change@entry_date'].notna() & trades['pct_change@exit_date'].notna()
-
-    ret_dict = {
-      'buy_high': [entry_buy_at_top.mean(), exit_buy_at_top.mean()],
-      'sell_low': [entry_sell_at_bottom.mean(), exit_sell_at_bottom.mean()],
-      'low_volume_stocks': [(trades['volume@entry_date'] < self._required_volume).mean(),
-                     (trades['volume@exit_date'] < self._required_volume).mean()],
-      'low_turnover_stocks': [(trades['turnover@entry_date'] < self._required_turnover).mean(),
-                     (trades['turnover@exit_date'] < self._required_turnover).mean()],
-    }
-
-    is_tw = isinstance(report.market_info, TWMarketInfo)
-    if is_tw:
-        
-        trades['類別@entry_date'] = trades['類別@entry_date'].fillna(0).astype(int)
-        trades['類別@exit_date'] = trades['類別@exit_date'].fillna(0).astype(int)
-        
-        trades['警示股@entry_date'] = (trades['類別@entry_date'] & 0x1) != 0
-        trades['處置股@entry_date'] = (trades['類別@entry_date'] & 0x2) != 0
-        trades['全額交割股@entry_date'] = (trades['類別@entry_date'] & 0x4) != 0
-
-        trades['警示股@exit_date'] = (trades['類別@exit_date'] & 0x1) != 0
-        trades['處置股@exit_date'] = (trades['類別@exit_date'] & 0x2) != 0
-        trades['全額交割股@exit_date'] = (trades['類別@exit_date'] & 0x4) != 0
-
-        trades.drop(columns=['類別@entry_date', '類別@exit_date'], inplace=True)
-
-        ret_dict = {**ret_dict, **{
-            '警示股': [trades['警示股@entry_date'].mean(), trades['警示股@exit_date'].mean()],
-            '處置股': [trades['處置股@entry_date'].mean(), trades['處置股@exit_date'].mean()],
-            '全額交割股':[trades['全額交割股@entry_date'].mean(), trades['全額交割股@exit_date'].mean()]
-        }}
-
-    self._result = pd.DataFrame(ret_dict)
-
-    self._result.index = ['entry', 'exit']
-
-    return self._result.to_dict()
-
-  def display(self):
-
-    def percentage(v):
-        return str(round(v*100, 1)) + '%'
-
-    def make_pretty(styler):
-        styler.set_caption("低流動性交易")
-        styler.format(percentage)
-        styler.background_gradient(axis=None, vmin=0, vmax=0.5, cmap="YlGnBu")
-        return styler
-
-    return self._result.style.pipe(make_pretty)
+import pandas as pd
+from finlab import data
+from finlab.analysis import Analysis
+from finlab.market_info import TWMarketInfo
+
+
+class LiquidityAnalysis(Analysis):
+
+  def __init__(self, required_volume=200000, required_turnover=1000000):
+    """分析台股策略流動性風險項目的機率
+
+    !!! note
+        參考[VIP限定文章](https://www.finlab.tw/customized_liquidityanalysis/)更了解流動性檢測內容細節。
+    Args:
+        required_volume (int): 要求進出場時的單日成交股數至少要多少？
+        required_turnover (int): 要求進出場時的單日成交金額至少要多少元？避免成交股數夠，但因低價股因素，造成胃納量仍無法符合資金需求。
+
+    Examples:
+        ``` py
+
+        # better syntax
+        report.run_analysis('LiquidityAnalysis', required_volume=100000)
+
+        # original syntax
+        from finlab.analysis.liquidityAnalysis import LiquidityAnalysis
+        report.run_analysis(LiquidityAnalysis(required_volume=100000))
+        ```
+    """
+
+    self._required_volume = required_volume
+    self._required_turnover = required_turnover
+    self._result = None
+
+  def is_market_info_supported(self, market_info):
+    return 'TWMarketInfo' in str(market_info)
+
+  def calculate_trade_info(self, report):
+
+    # calculate trade bar return
+    adj_trade_price = report.market_info.get_trading_price(report.trade_at, adj=True)
+    adj_previous_close = report.market_info.get_trading_price('close', adj=True).shift()
+
+    # calculate money flow
+    trade_price = report.market_info.get_trading_price(report.trade_at, adj=False)
+    volume = report.market_info.get_price('volume', adj=False)
+
+    signal_dates = ["entry_date", "exit_date"]
+
+    ret = [
+      ["pct_change", adj_trade_price / adj_previous_close - 1, signal_dates],
+      ["turnover", trade_price * volume, signal_dates],
+      ["volume", volume, signal_dates]
+    ]
+
+    is_tw = isinstance(report.market_info, TWMarketInfo)
+
+
+    if is_tw:
+        flagged = data.get('etl:is_flagged_stock')
+        ret += [
+          ["類別", flagged, signal_dates],
+          # ["處置股", ~data.get('etl:disposal_stock_filter').shift(fill_value=False), signal_dates],
+          # ["警示股", ~data.get('etl:disposal_stock_filter').shift(fill_value=False), signal_dates],
+          # ["全額交割股", ~data.get('etl:full_cash_delivery_stock_filter').shift(fill_value=False), signal_dates]
+        ]
+
+    return ret
+
+  def analyze(self, report):
+    trades = report.get_trades()
+
+    if isinstance(report.market_info, TWMarketInfo):
+      entry_pct_range = (trades.entry_date >= '2015-6-1') * 0.03 + 0.07
+      exit_pct_range = (trades.exit_date >= '2015-6-1') * 0.03 + 0.07
+    else:
+      entry_pct_range = 0.1
+      exit_pct_range = 0.1
+
+    long_position = trades.position > 0
+
+    entry_buy_at_top = long_position & (trades['pct_change@entry_date'] > entry_pct_range * 0.95)
+    entry_sell_at_bottom = (~long_position) & (trades['pct_change@entry_date'] < -entry_pct_range * 0.95)
+
+    exit_sell_at_bottom = long_position & (trades['pct_change@exit_date'] < -exit_pct_range * 0.95)
+    exit_buy_at_top = (~long_position) & (trades['pct_change@exit_date'] > exit_pct_range * 0.95)
+
+    trade_pct_count = trades['pct_change@entry_date'].notna() & trades['pct_change@exit_date'].notna()
+
+    ret_dict = {
+      'buy_high': [entry_buy_at_top.mean(), exit_buy_at_top.mean()],
+      'sell_low': [entry_sell_at_bottom.mean(), exit_sell_at_bottom.mean()],
+      'low_volume_stocks': [(trades['volume@entry_date'] < self._required_volume).mean(),
+                     (trades['volume@exit_date'] < self._required_volume).mean()],
+      'low_turnover_stocks': [(trades['turnover@entry_date'] < self._required_turnover).mean(),
+                     (trades['turnover@exit_date'] < self._required_turnover).mean()],
+    }
+
+    is_tw = isinstance(report.market_info, TWMarketInfo)
+    if is_tw:
+        
+        trades['類別@entry_date'] = trades['類別@entry_date'].fillna(0).astype(int)
+        trades['類別@exit_date'] = trades['類別@exit_date'].fillna(0).astype(int)
+        
+        trades['警示股@entry_date'] = (trades['類別@entry_date'] & 0x1) != 0
+        trades['處置股@entry_date'] = (trades['類別@entry_date'] & 0x2) != 0
+        trades['全額交割股@entry_date'] = (trades['類別@entry_date'] & 0x4) != 0
+
+        trades['警示股@exit_date'] = (trades['類別@exit_date'] & 0x1) != 0
+        trades['處置股@exit_date'] = (trades['類別@exit_date'] & 0x2) != 0
+        trades['全額交割股@exit_date'] = (trades['類別@exit_date'] & 0x4) != 0
+
+        trades.drop(columns=['類別@entry_date', '類別@exit_date'], inplace=True)
+
+        ret_dict = {**ret_dict, **{
+            '警示股': [trades['警示股@entry_date'].mean(), trades['警示股@exit_date'].mean()],
+            '處置股': [trades['處置股@entry_date'].mean(), trades['處置股@exit_date'].mean()],
+            '全額交割股':[trades['全額交割股@entry_date'].mean(), trades['全額交割股@exit_date'].mean()]
+        }}
+
+    self._result = pd.DataFrame(ret_dict)
+
+    self._result.index = ['entry', 'exit']
+
+    return self._result.to_dict()
+
+  def display(self):
+
+    def percentage(v):
+        return str(round(v*100, 1)) + '%'
+
+    def make_pretty(styler):
+        styler.set_caption("低流動性交易")
+        styler.format(percentage)
+        styler.background_gradient(axis=None, vmin=0, vmax=0.5, cmap="YlGnBu")
+        return styler
+
+    return self._result.style.pipe(make_pretty)
```

## finlab/analysis/maeMfeAnalysis.py

 * *Ordering differences only*

```diff
@@ -1,269 +1,269 @@
-import numpy as np
-import pandas as pd
-from finlab.analysis import Analysis
-
-
-class MaeMfeAnalysis(Analysis):
-
-    def __init__(self, violinmode='group', mfe_scatter_x='mae', **kwargs):
-        self.violinmode = violinmode
-        self.mfe_scatter_x = mfe_scatter_x
-        self.kwargs = kwargs
-
-    @staticmethod
-    def calc_edge_ratio(report):
-        mae_mfe = report.mae_mfe
-        mae_mfe_window_col = [i for i in list(set(mae_mfe.columns.get_level_values(0))) if
-                              ('exit' not in str(i)) and (i != 0)]
-
-        if len(mae_mfe_window_col) == 0:
-            edge_ratio = pd.DataFrame({'time_scale': [1], 'mean_edge_ratio': [1]})
-
-        else:
-            edge_ratio = pd.DataFrame(
-                [{'time_scale': m, 
-                  'mean_edge_ratio': (
-                      (mae_mfe[m]['gmfe']).sum()) / (abs(mae_mfe[m]['mae']).sum())} 
-                        for m in mae_mfe_window_col])
-        return edge_ratio
-
-    def analyze(self, report):
-        self.report = report
-
-        ret_dist = {}
-        for col in ['return', 'mae', 'bmfe', 'gmfe', 'mdd', 'pdays']:
-
-            # profit and loss
-            sp = report.trades[col].loc[report.trades['return'] > 0].dropna()
-            hist_p = pd.DataFrame(np.histogram(sp, bins=20)).T.set_index(1).squeeze().fillna(0)
-
-            sl = report.trades[col].loc[report.trades['return'] < 0].dropna()
-            hist_l = pd.DataFrame(np.histogram(sl, bins=20)).T.set_index(1).squeeze().fillna(0)
-
-            ret_dist[col] = {
-                'p_values': hist_p.values.tolist(),
-                'p_index': hist_p.index.values.tolist(),
-                'p_stats': sp.describe().to_dict(),
-                'l_values': hist_l.values.tolist(),
-                'l_index': hist_l.index.values.tolist(),
-                'l_stats': sl.describe().to_dict()
-                }
-
-        ret = {
-            'stats': ret_dist,
-            'edge_ratio': self.calc_edge_ratio(report).to_dict(orient='list')
-        }
-
-        return ret
-
-    def display(self):
-        import plotly.express as px
-        import plotly.graph_objects as go
-        from plotly.subplots import make_subplots
-        import plotly.figure_factory as ff
-
-        violinmode = self.violinmode
-        mfe_scatter_x = self.mfe_scatter_x
-        kwargs = self.kwargs
-        report = self.report
-        stats = report.get_stats()
-        trade_record = report.get_trades().copy().dropna(
-                subset=['mae', 'mdd', 'bmfe', 'gmfe', 'pdays', 'return'])
-        trade_record['entry_date'] = trade_record['entry_date'].dt.strftime('%Y-%m-%d')
-        trade_record.loc[:, ['return']] = round(trade_record[['return']] * 100, 2)
-        trade_record.loc[:, ['pdays_ratio']] = trade_record['pdays'] / trade_record['period']
-        trade_record.loc[:, ['mae', 'mdd', 'bmfe', 'gmfe', 'pdays_ratio'], ] = round(
-            abs(trade_record[['mae', 'mdd', 'bmfe', 'gmfe', 'pdays_ratio']] * 100), 2)
-        trade_record.loc[:, ['profit_loss']] = trade_record['return'].apply(lambda s: 'profit' if s > 0 else 'loss')
-        trade_record.loc[:, ['size']] = abs(trade_record['return'])
-        win_ratio = round(stats['win_ratio']*100, 1)
-        stats = {g[0]: g[1].describe().to_dict() for g in trade_record.groupby('profit_loss')}
-
-        # calculate edge_ratio
-        mae_mfe = report.mae_mfe
-        mae_mfe_window_col = [i for i in list(set(mae_mfe.columns.get_level_values(0))) if
-                              ('exit' not in str(i)) and (i != 0)]
-        if len(mae_mfe_window_col) == 0:
-            edge_ratio = pd.DataFrame({'time_scale': [1], 'mean_edge_ratio': [1]})
-        else:
-            edge_ratio = pd.DataFrame(
-                [{'time_scale': m, 
-                  'mean_edge_ratio': (
-                      (mae_mfe[m]['gmfe']).sum()) / (abs(mae_mfe[m]['mae']).sum())} 
-                        for m in mae_mfe_window_col]).sort_values(['time_scale'])
-
-        # mdd_gmfe:use for trailing stop
-        mdd_gmfe = trade_record[(trade_record['mdd'] > trade_record['gmfe'])]
-        pl_count = trade_record.groupby(['profit_loss'])['mdd'].count()
-        breakeven_safe_pct = abs(round((len(mdd_gmfe) / len(trade_record) - 1) * 100))
-        missed_profits_pct = round(len(mdd_gmfe[mdd_gmfe['profit_loss'] == 'profit']) / pl_count['profit'] * 100)
-
-        # plot
-        fig = make_subplots(rows=4, cols=6,
-                            specs=[[{"colspan": 2}, None, {"colspan": 2}, None, {"colspan": 2}, None],
-                                   [{"colspan": 2}, None, {"colspan": 2}, None, {"colspan": 2}, None],
-                                   [{"colspan": 2}, None, {"colspan": 2}, None, {"colspan": 2}, None],
-                                   [{"colspan": 6}, None, None, None, None, None], ],
-                            vertical_spacing=0.1,
-                            horizontal_spacing=0.1,
-                            subplot_titles=[f"Win Ratio:{win_ratio}%", "Edge Ratio", "MAE/Return",
-                                            f"GMFE/{mfe_scatter_x.capitalize()}", f"BMFE/{mfe_scatter_x.capitalize()}",
-                                            f"Missed Win-profits PCT:{missed_profits_pct}%<br>Breakeven Safe PCT:{breakeven_safe_pct}%",
-                                            "MAE Distribution", "BMFE Distribution", "GMFE Distribution",
-                                            "Indices Stats"])
-
-        colors = {'profit': '#69b0ea', 'loss': '#F66095'}
-
-        def set_fig_data_color(fig_data, color_set=colors):
-            fig_data['marker']['color'] = color_set.get(fig_data['legendgroup'], colors['loss'])
-            return fig_data
-
-        # Return histogram
-        fig_return_hist = px.histogram(trade_record, x="return", color="profit_loss")
-        for f_data in fig_return_hist.data:
-            fig.add_trace(set_fig_data_color(f_data), row=1, col=1)
-
-        return_mean = round(trade_record['return'].mean(), 2)
-        fig.add_vline(x=return_mean, line_width=2, line_dash="dash", line_color="green",
-                      annotation_position="top right",
-                      annotation_text=f'  avg:{return_mean}%',
-                      row=1, col=1)
-
-        # "Edge Ratio"
-        fig_edge_ratio = px.line(edge_ratio, x='time_scale', y='mean_edge_ratio')
-        for f_data in fig_edge_ratio.data:
-            fig.add_trace(set_fig_data_color(f_data), row=1, col=3)
-
-        # MAE/Return
-        px_fig = px.scatter(trade_record, x="return", y="mae", color="profit_loss",
-                            size='size', hover_data=['stock_id', 'entry_date'])
-        for f_data in px_fig.data:
-            fig.add_trace(set_fig_data_color(f_data), row=1, col=5)
-        for pl, color in colors.items():
-            y = stats[pl]['mae']['75%']
-            fig.add_hline(y=y, line_width=2, line_dash="dash", annotation_text=f' Q3:{round(y, 2)}%', line_color=color,
-                          row=1, col=5)
-
-        # GMFE/MAE,BMFE/MAE
-        for name, col in zip(['gmfe', 'bmfe'], [1, 3]):
-            px_fig = px.scatter(trade_record, x=mfe_scatter_x, y=name, color="profit_loss",
-                                size='size', hover_data=['stock_id', 'entry_date'])
-            for f_data in px_fig.data:
-                fig.add_trace(set_fig_data_color(f_data), row=2, col=col)
-            for pl, color in colors.items():
-                y = stats[pl][name]['75%']
-                fig.add_hline(y=y, line_width=2, line_dash="dash", annotation_text=f' Q3:{round(y, 2)}%', line_color=color,
-                              row=2, col=col)
-
-        # MDD/GMFE
-        px_fig = px.scatter(trade_record, x="gmfe", y="mdd", color="profit_loss",
-                            size='size', hover_data=['stock_id', 'entry_date'])
-        for f_data in px_fig.data:
-            fig.add_trace(set_fig_data_color(f_data), row=2, col=5)
-
-        # MDD/GMFE benchmark
-        max_gmfe = trade_record['gmfe'].max()
-        fig.add_trace(go.Scatter(x=[0, max_gmfe * 1.1], y=[0, max_gmfe * 1.01],
-                                 mode='lines', name='mdd/mfe_benchmark', line_color="orange", line_width=3), row=2, col=5)
-        # distributions
-        group_labels = list(colors.keys())
-
-        def create_distplot_data(index='mae'):
-            hist_data = [trade_record[(trade_record['profit_loss'] == g)][index].values for g in
-                         group_labels]
-            distplot = ff.create_distplot(hist_data, group_labels, bin_size=1)
-            return distplot['data']
-
-        for name, col in zip(['mae', 'bmfe', 'gmfe'], [1, 3, 5]):
-            plot = create_distplot_data(name)
-            for data_num in range(0, 2):
-                fig.add_trace(go.Histogram(plot[data_num],
-                                           marker_color=colors[group_labels[data_num % 2]]
-                                           ), row=3, col=col)
-                fig.add_trace(go.Scatter(plot[data_num + 2],
-                                         line=dict(color=colors[group_labels[data_num % 2]], width=3)
-                                         ), row=3, col=col)
-            for pl, color in colors.items():
-                x = stats[pl][name]['75%']
-                fig.add_vline(x=x, annotation=dict(text=f' Q3:{round(x, 2)}%', textangle=-90), line_width=2,
-                              line_dash="dash",
-                              line_color=color, row=3, col=col)
-
-        violin_columns = ['return', 'mae', 'bmfe', 'gmfe', 'mdd', 'pdays_ratio']
-        tr_melt_df = pd.melt(trade_record, id_vars=['entry_sig_date', 'exit_sig_date', 'stock_id', 'profit_loss'],
-                             value_vars=violin_columns)
-
-        if violinmode == 'overlay':
-            for v in violin_columns:
-                fig.add_trace(go.Violin(x=tr_melt_df['variable'][tr_melt_df['variable'] == v],
-                                        y=tr_melt_df['value'][tr_melt_df['variable'] == v],
-                                        name=v, box_visible=True, meanline_visible=True), row=4, col=1)
-        elif violinmode == 'group':
-            for group, color in colors.items():
-                fig.add_trace(go.Violin(x=tr_melt_df['variable'][tr_melt_df['profit_loss'] == group],
-                                        y=tr_melt_df['value'][tr_melt_df['profit_loss'] == group], line_color=color,
-                                        legendgroup=group, scalegroup=group, name=group, box_visible=False,
-                                        meanline_visible=True,
-                                        opacity=0.6), row=4, col=1
-                              )
-
-        fig.update_layout(
-            height=1200, width=1200,
-            title={
-                'text': "MAE/MFE Analysis",
-                'x': 0.46,
-                'y': 0.98,
-                'xanchor': 'center',
-                'yanchor': 'top'
-            },
-            violinmode=violinmode,
-            yaxis=dict(
-                title='count',
-            ),
-            yaxis2=dict(
-                title='edge ratio',
-                showgrid=False,
-            ),
-            yaxis3=dict(
-                title='mae(%)',
-            ),
-            yaxis4=dict(
-                title='gmfe(%)',
-            ),
-            yaxis5=dict(
-                title='bmfe(%)',
-            ),
-            yaxis6=dict(
-                title='mdd(%)',
-            ),
-            xaxis=dict(
-                title='return(%)',
-            ),
-            xaxis2=dict(
-                title='time_scale',
-            ),
-            xaxis3=dict(
-                title='return(%)',
-            ),
-            xaxis4=dict(
-                title=f'{mfe_scatter_x}(%)',
-            ),
-            xaxis5=dict(
-                title=f'{mfe_scatter_x}(%)',
-            ),
-            xaxis6=dict(
-                title='gmfe(%)',
-            ),
-            xaxis7=dict(
-                title='mae(%)',
-            ),
-            xaxis8=dict(
-                title='bmfe(%)',
-            ),
-            xaxis9=dict(
-                title='gmfe(%)',
-            ),
-            **kwargs
-        )
-        return fig
-
+import numpy as np
+import pandas as pd
+from finlab.analysis import Analysis
+
+
+class MaeMfeAnalysis(Analysis):
+
+    def __init__(self, violinmode='group', mfe_scatter_x='mae', **kwargs):
+        self.violinmode = violinmode
+        self.mfe_scatter_x = mfe_scatter_x
+        self.kwargs = kwargs
+
+    @staticmethod
+    def calc_edge_ratio(report):
+        mae_mfe = report.mae_mfe
+        mae_mfe_window_col = [i for i in list(set(mae_mfe.columns.get_level_values(0))) if
+                              ('exit' not in str(i)) and (i != 0)]
+
+        if len(mae_mfe_window_col) == 0:
+            edge_ratio = pd.DataFrame({'time_scale': [1], 'mean_edge_ratio': [1]})
+
+        else:
+            edge_ratio = pd.DataFrame(
+                [{'time_scale': m, 
+                  'mean_edge_ratio': (
+                      (mae_mfe[m]['gmfe']).sum()) / (abs(mae_mfe[m]['mae']).sum())} 
+                        for m in mae_mfe_window_col])
+        return edge_ratio
+
+    def analyze(self, report):
+        self.report = report
+
+        ret_dist = {}
+        for col in ['return', 'mae', 'bmfe', 'gmfe', 'mdd', 'pdays']:
+
+            # profit and loss
+            sp = report.trades[col].loc[report.trades['return'] > 0].dropna()
+            hist_p = pd.DataFrame(np.histogram(sp, bins=20)).T.set_index(1).squeeze().fillna(0)
+
+            sl = report.trades[col].loc[report.trades['return'] < 0].dropna()
+            hist_l = pd.DataFrame(np.histogram(sl, bins=20)).T.set_index(1).squeeze().fillna(0)
+
+            ret_dist[col] = {
+                'p_values': hist_p.values.tolist(),
+                'p_index': hist_p.index.values.tolist(),
+                'p_stats': sp.describe().to_dict(),
+                'l_values': hist_l.values.tolist(),
+                'l_index': hist_l.index.values.tolist(),
+                'l_stats': sl.describe().to_dict()
+                }
+
+        ret = {
+            'stats': ret_dist,
+            'edge_ratio': self.calc_edge_ratio(report).to_dict(orient='list')
+        }
+
+        return ret
+
+    def display(self):
+        import plotly.express as px
+        import plotly.graph_objects as go
+        from plotly.subplots import make_subplots
+        import plotly.figure_factory as ff
+
+        violinmode = self.violinmode
+        mfe_scatter_x = self.mfe_scatter_x
+        kwargs = self.kwargs
+        report = self.report
+        stats = report.get_stats()
+        trade_record = report.get_trades().copy().dropna(
+                subset=['mae', 'mdd', 'bmfe', 'gmfe', 'pdays', 'return'])
+        trade_record['entry_date'] = trade_record['entry_date'].dt.strftime('%Y-%m-%d')
+        trade_record.loc[:, ['return']] = round(trade_record[['return']] * 100, 2)
+        trade_record.loc[:, ['pdays_ratio']] = trade_record['pdays'] / trade_record['period']
+        trade_record.loc[:, ['mae', 'mdd', 'bmfe', 'gmfe', 'pdays_ratio'], ] = round(
+            abs(trade_record[['mae', 'mdd', 'bmfe', 'gmfe', 'pdays_ratio']] * 100), 2)
+        trade_record.loc[:, ['profit_loss']] = trade_record['return'].apply(lambda s: 'profit' if s > 0 else 'loss')
+        trade_record.loc[:, ['size']] = abs(trade_record['return'])
+        win_ratio = round(stats['win_ratio']*100, 1)
+        stats = {g[0]: g[1].describe().to_dict() for g in trade_record.groupby('profit_loss')}
+
+        # calculate edge_ratio
+        mae_mfe = report.mae_mfe
+        mae_mfe_window_col = [i for i in list(set(mae_mfe.columns.get_level_values(0))) if
+                              ('exit' not in str(i)) and (i != 0)]
+        if len(mae_mfe_window_col) == 0:
+            edge_ratio = pd.DataFrame({'time_scale': [1], 'mean_edge_ratio': [1]})
+        else:
+            edge_ratio = pd.DataFrame(
+                [{'time_scale': m, 
+                  'mean_edge_ratio': (
+                      (mae_mfe[m]['gmfe']).sum()) / (abs(mae_mfe[m]['mae']).sum())} 
+                        for m in mae_mfe_window_col]).sort_values(['time_scale'])
+
+        # mdd_gmfe:use for trailing stop
+        mdd_gmfe = trade_record[(trade_record['mdd'] > trade_record['gmfe'])]
+        pl_count = trade_record.groupby(['profit_loss'])['mdd'].count()
+        breakeven_safe_pct = abs(round((len(mdd_gmfe) / len(trade_record) - 1) * 100))
+        missed_profits_pct = round(len(mdd_gmfe[mdd_gmfe['profit_loss'] == 'profit']) / pl_count['profit'] * 100)
+
+        # plot
+        fig = make_subplots(rows=4, cols=6,
+                            specs=[[{"colspan": 2}, None, {"colspan": 2}, None, {"colspan": 2}, None],
+                                   [{"colspan": 2}, None, {"colspan": 2}, None, {"colspan": 2}, None],
+                                   [{"colspan": 2}, None, {"colspan": 2}, None, {"colspan": 2}, None],
+                                   [{"colspan": 6}, None, None, None, None, None], ],
+                            vertical_spacing=0.1,
+                            horizontal_spacing=0.1,
+                            subplot_titles=[f"Win Ratio:{win_ratio}%", "Edge Ratio", "MAE/Return",
+                                            f"GMFE/{mfe_scatter_x.capitalize()}", f"BMFE/{mfe_scatter_x.capitalize()}",
+                                            f"Missed Win-profits PCT:{missed_profits_pct}%<br>Breakeven Safe PCT:{breakeven_safe_pct}%",
+                                            "MAE Distribution", "BMFE Distribution", "GMFE Distribution",
+                                            "Indices Stats"])
+
+        colors = {'profit': '#69b0ea', 'loss': '#F66095'}
+
+        def set_fig_data_color(fig_data, color_set=colors):
+            fig_data['marker']['color'] = color_set.get(fig_data['legendgroup'], colors['loss'])
+            return fig_data
+
+        # Return histogram
+        fig_return_hist = px.histogram(trade_record, x="return", color="profit_loss")
+        for f_data in fig_return_hist.data:
+            fig.add_trace(set_fig_data_color(f_data), row=1, col=1)
+
+        return_mean = round(trade_record['return'].mean(), 2)
+        fig.add_vline(x=return_mean, line_width=2, line_dash="dash", line_color="green",
+                      annotation_position="top right",
+                      annotation_text=f'  avg:{return_mean}%',
+                      row=1, col=1)
+
+        # "Edge Ratio"
+        fig_edge_ratio = px.line(edge_ratio, x='time_scale', y='mean_edge_ratio')
+        for f_data in fig_edge_ratio.data:
+            fig.add_trace(set_fig_data_color(f_data), row=1, col=3)
+
+        # MAE/Return
+        px_fig = px.scatter(trade_record, x="return", y="mae", color="profit_loss",
+                            size='size', hover_data=['stock_id', 'entry_date'])
+        for f_data in px_fig.data:
+            fig.add_trace(set_fig_data_color(f_data), row=1, col=5)
+        for pl, color in colors.items():
+            y = stats[pl]['mae']['75%']
+            fig.add_hline(y=y, line_width=2, line_dash="dash", annotation_text=f' Q3:{round(y, 2)}%', line_color=color,
+                          row=1, col=5)
+
+        # GMFE/MAE,BMFE/MAE
+        for name, col in zip(['gmfe', 'bmfe'], [1, 3]):
+            px_fig = px.scatter(trade_record, x=mfe_scatter_x, y=name, color="profit_loss",
+                                size='size', hover_data=['stock_id', 'entry_date'])
+            for f_data in px_fig.data:
+                fig.add_trace(set_fig_data_color(f_data), row=2, col=col)
+            for pl, color in colors.items():
+                y = stats[pl][name]['75%']
+                fig.add_hline(y=y, line_width=2, line_dash="dash", annotation_text=f' Q3:{round(y, 2)}%', line_color=color,
+                              row=2, col=col)
+
+        # MDD/GMFE
+        px_fig = px.scatter(trade_record, x="gmfe", y="mdd", color="profit_loss",
+                            size='size', hover_data=['stock_id', 'entry_date'])
+        for f_data in px_fig.data:
+            fig.add_trace(set_fig_data_color(f_data), row=2, col=5)
+
+        # MDD/GMFE benchmark
+        max_gmfe = trade_record['gmfe'].max()
+        fig.add_trace(go.Scatter(x=[0, max_gmfe * 1.1], y=[0, max_gmfe * 1.01],
+                                 mode='lines', name='mdd/mfe_benchmark', line_color="orange", line_width=3), row=2, col=5)
+        # distributions
+        group_labels = list(colors.keys())
+
+        def create_distplot_data(index='mae'):
+            hist_data = [trade_record[(trade_record['profit_loss'] == g)][index].values for g in
+                         group_labels]
+            distplot = ff.create_distplot(hist_data, group_labels, bin_size=1)
+            return distplot['data']
+
+        for name, col in zip(['mae', 'bmfe', 'gmfe'], [1, 3, 5]):
+            plot = create_distplot_data(name)
+            for data_num in range(0, 2):
+                fig.add_trace(go.Histogram(plot[data_num],
+                                           marker_color=colors[group_labels[data_num % 2]]
+                                           ), row=3, col=col)
+                fig.add_trace(go.Scatter(plot[data_num + 2],
+                                         line=dict(color=colors[group_labels[data_num % 2]], width=3)
+                                         ), row=3, col=col)
+            for pl, color in colors.items():
+                x = stats[pl][name]['75%']
+                fig.add_vline(x=x, annotation=dict(text=f' Q3:{round(x, 2)}%', textangle=-90), line_width=2,
+                              line_dash="dash",
+                              line_color=color, row=3, col=col)
+
+        violin_columns = ['return', 'mae', 'bmfe', 'gmfe', 'mdd', 'pdays_ratio']
+        tr_melt_df = pd.melt(trade_record, id_vars=['entry_sig_date', 'exit_sig_date', 'stock_id', 'profit_loss'],
+                             value_vars=violin_columns)
+
+        if violinmode == 'overlay':
+            for v in violin_columns:
+                fig.add_trace(go.Violin(x=tr_melt_df['variable'][tr_melt_df['variable'] == v],
+                                        y=tr_melt_df['value'][tr_melt_df['variable'] == v],
+                                        name=v, box_visible=True, meanline_visible=True), row=4, col=1)
+        elif violinmode == 'group':
+            for group, color in colors.items():
+                fig.add_trace(go.Violin(x=tr_melt_df['variable'][tr_melt_df['profit_loss'] == group],
+                                        y=tr_melt_df['value'][tr_melt_df['profit_loss'] == group], line_color=color,
+                                        legendgroup=group, scalegroup=group, name=group, box_visible=False,
+                                        meanline_visible=True,
+                                        opacity=0.6), row=4, col=1
+                              )
+
+        fig.update_layout(
+            height=1200, width=1200,
+            title={
+                'text': "MAE/MFE Analysis",
+                'x': 0.46,
+                'y': 0.98,
+                'xanchor': 'center',
+                'yanchor': 'top'
+            },
+            violinmode=violinmode,
+            yaxis=dict(
+                title='count',
+            ),
+            yaxis2=dict(
+                title='edge ratio',
+                showgrid=False,
+            ),
+            yaxis3=dict(
+                title='mae(%)',
+            ),
+            yaxis4=dict(
+                title='gmfe(%)',
+            ),
+            yaxis5=dict(
+                title='bmfe(%)',
+            ),
+            yaxis6=dict(
+                title='mdd(%)',
+            ),
+            xaxis=dict(
+                title='return(%)',
+            ),
+            xaxis2=dict(
+                title='time_scale',
+            ),
+            xaxis3=dict(
+                title='return(%)',
+            ),
+            xaxis4=dict(
+                title=f'{mfe_scatter_x}(%)',
+            ),
+            xaxis5=dict(
+                title=f'{mfe_scatter_x}(%)',
+            ),
+            xaxis6=dict(
+                title='gmfe(%)',
+            ),
+            xaxis7=dict(
+                title='mae(%)',
+            ),
+            xaxis8=dict(
+                title='bmfe(%)',
+            ),
+            xaxis9=dict(
+                title='gmfe(%)',
+            ),
+            **kwargs
+        )
+        return fig
+
```

## finlab/analysis/periodStatsAnalysis.py

 * *Ordering differences only*

```diff
@@ -1,180 +1,180 @@
-import numpy as np
-import pandas as pd
-from finlab.analysis import Analysis
-
-class PeriodStatsAnalysis(Analysis):
-
-    def __init__(self):
-        """分析台股策略的不同時期與大盤指標作比較
-
-        Examples:
-            可以執行以下程式碼來產生分析結果：
-
-            ``` py
-            report.run_analysis('PeriodStatsAnalysis')
-            ```
-
-            產生的結果：
-
-            
-            |                                      |   benchmark |   strategy |
-            |:-------------------------------------|------------:|-----------:|
-            | ('overall_daily', 'calmar_ratio')    |   0.149192  |  0.0655645 |
-            | ('overall_daily', 'sortino_ratio')   |   0.677986  |  0.447837  |
-            | ('overall_daily', 'sharpe_ratio')    |   0.532014  |  0.306351  |
-            | ('overall_daily', 'profit_factor')   |   1.20022   |  1.07741   |
-            | ('overall_daily', 'tail_ratio')      |   0.914881  |  0.987751  |
-            | ('overall_daily', 'return')          |   0.0835801 |  0.0478957 |
-            | ('overall_daily', 'volatility')      |   0.182167  |  0.312543  |
-            | ('overall_monthly', 'calmar_ratio')  |   0.155321  |  0.0731378 |
-            | ('overall_monthly', 'sortino_ratio') |   0.697382  |  0.439003  |
-            | ('overall_monthly', 'sharpe_ratio')  |   0.524943  |  0.307292  |
-            | ('overall_monthly', 'profit_factor') |   1.75714   |  1.27059   |
-            | ('overall_monthly', 'tail_ratio')    |   1.03322   |  0.903335  |
-            | ('overall_monthly', 'return')        |   0.0836545 |  0.0479377 |
-            | ('overall_monthly', 'volatility')    |   0.186989  |  0.316178  |
-            | ('overall_yearly', 'calmar_ratio')   |   0.436075  |  0.127784  |
-            | ('overall_yearly', 'sortino_ratio')  |   0.738327  |  0.694786  |
-            | ('overall_yearly', 'sharpe_ratio')   |   0.407324  |  0.350986  |
-            | ('overall_yearly', 'profit_factor')  |   2.2       |  1.66667   |
-            | ('overall_yearly', 'tail_ratio')     |   1.71647   |  1.359     |
-            | ('overall_yearly', 'return')         |   0.0814469 |  0.0663674 |
-            | ('overall_yearly', 'volatility')     |   0.284742  |  0.419087  |
-        """
-        self.results = None
-
-        def safe_division(n, d):
-            return n / d if d else 0
-
-        calc_cagr = (
-            lambda s: (s.add(1).prod()) ** safe_division(365.25, (s.index[-1] - s.index[0]).days) - 1 
-            if len(s) > 1 else 0)
-
-        def calc_calmar_ratio(pct):
-            s = pct.add(1).cumprod().iloc[1:]
-            return safe_division(calc_cagr(pct), abs(s.calc_max_drawdown()))
-
-        self.metrics = [
-                ("calmar_ratio", calc_calmar_ratio),
-                ('sortino_ratio', lambda s: safe_division(s.mean(), s[s < 0].std())
-                    * (safe_division(len(s), (s.index[-1] - s.index[0]).days) * 365) ** 0.5),
-                ('sharpe_ratio', lambda s: safe_division(s.mean(), s.std())
-                    * (safe_division(len(s), (s.index[-1] - s.index[0]).days) * 365) ** 0.5),
-                ('profit_factor', lambda s: safe_division((s > 0).sum(), (s < 0).sum())),
-                ('tail_ratio', lambda s: -safe_division(s.quantile(0.95), (s.quantile(0.05)))),
-                ('return', lambda s: calc_cagr(s)),
-                ('volatility', lambda s: s.std() * np.sqrt(safe_division(len(s), (s.index[-1] - s.index[0]).days) * 365)),
-                ]
-
-    def calc_stats(self, series):
-
-        ########################################
-        # calculate yearly metric performance
-        ########################################
-        pct = series.pct_change().fillna(0)
-
-        def eval_f(m, s):
-            if isinstance(m, str):
-                return getattr(s, m)()
-            else:
-                return m[1](s)
-
-
-        yearly = {}
-
-        for m in self.metrics:
-
-            name = m if isinstance(m, str) else m[0]
-            s = pct.groupby(pct.index.year).apply(lambda s: eval_f(m, s))
-            yearly[name] = s.values.tolist()
-
-        yearly['year'] = s.index.values.tolist()
-
-        ########################################
-        # calculate recent days performance
-        ########################################
-        recent_days = [20, 60, 120, 252, 756]
-        recent = {}
-        for m in self.metrics:
-            name = m if isinstance(m, str) else m[0]
-            recent[name] = []
-            for d in recent_days:
-                recent[name].append(eval_f(m, pct.iloc[-d:]))
-
-        recent['days'] = recent_days
-
-        ########################################
-        # calculate overall performance
-        ########################################
-        overall_daily = {}
-        overall_monthly = {}
-        overall_yearly = {}
-
-        pct_m = series.resample('M').last().dropna().pct_change().iloc[1:]
-        pct_y = series.resample('Y').last().dropna().pct_change().iloc[1:]
-
-        for m in self.metrics:
-            name = m if isinstance(m, str) else m[0]
-            overall_daily[name] = eval_f(m, pct)
-            overall_monthly[name] = eval_f(m, pct_m) if len(pct_m) > 1 else 0
-            overall_yearly[name] = eval_f(m, pct_y) if len(pct_y) > 1 else 0
-
-        return {'yearly': yearly, 
-                'recent': recent, 
-                'overall_daily': overall_daily, 
-                'overall_monthly': overall_monthly, 
-                'overall_yearly': overall_yearly}
-
-    def analyze(self, report):
-
-        ret = {}
-        ret['strategy'] = self.calc_stats(report.daily_creturn)
-        ret['benchmark'] = self.calc_stats(report.daily_benchmark)
-
-        self.results = ret
-
-        return ret
-
-    def display(self):
-
-        if self.results is None:
-            return
-
-        from IPython.display import HTML
-
-        t = ''
-        result = self.results
-        result['benchmark']['recent']['days'] = ['M', 'Q', 'HY', 'Y', '3Y']
-        result['strategy']['recent']['days'] = ['M', 'Q', 'HY', 'Y', '3Y']
-
-        df = pd.DataFrame({'benchmark': pd.DataFrame({cat: result['benchmark'][cat] for cat in ['overall_daily', 'overall_monthly', 'overall_yearly']}).unstack(),
-        'strategy': pd.DataFrame({cat: result['strategy'][cat] for cat in ['overall_daily', 'overall_monthly', 'overall_yearly']}).unstack()})
-
-        def highlight_max(s, props=''):
-            return np.where(s == np.nanmax(s.values), props, '')
-
-        t += df.style.apply(highlight_max, props='color:white;color:blue', axis=1).to_html()
-
-        for cat in ['yearly', 'recent']:
-
-            metric_names = result['strategy'][cat].keys()
-
-            index_name = {
-                'yearly': 'year',
-                'recent': 'days',
-            }[cat]
-
-            for mname in metric_names:
-
-                if mname == index_name:
-                    continue
-
-                df = pd.DataFrame([result['strategy'][cat][mname], result['benchmark'][cat][mname]], columns=result['strategy'][cat][index_name], index=['strategy', 'benchmark'])
-
-                def make_pretty(styler, df, title):
-                    styler.set_caption(title)
-                    styler.background_gradient(axis=None, vmin=df.min().min(), vmax=df.max().max(), cmap="YlGnBu")
-                    return styler
-
-                t += df.style.format(precision=2).pipe(lambda v: make_pretty(v, df, mname)).to_html() + '<br />'
-        return HTML(t)
+import numpy as np
+import pandas as pd
+from finlab.analysis import Analysis
+
+class PeriodStatsAnalysis(Analysis):
+
+    def __init__(self):
+        """分析台股策略的不同時期與大盤指標作比較
+
+        Examples:
+            可以執行以下程式碼來產生分析結果：
+
+            ``` py
+            report.run_analysis('PeriodStatsAnalysis')
+            ```
+
+            產生的結果：
+
+            
+            |                                      |   benchmark |   strategy |
+            |:-------------------------------------|------------:|-----------:|
+            | ('overall_daily', 'calmar_ratio')    |   0.149192  |  0.0655645 |
+            | ('overall_daily', 'sortino_ratio')   |   0.677986  |  0.447837  |
+            | ('overall_daily', 'sharpe_ratio')    |   0.532014  |  0.306351  |
+            | ('overall_daily', 'profit_factor')   |   1.20022   |  1.07741   |
+            | ('overall_daily', 'tail_ratio')      |   0.914881  |  0.987751  |
+            | ('overall_daily', 'return')          |   0.0835801 |  0.0478957 |
+            | ('overall_daily', 'volatility')      |   0.182167  |  0.312543  |
+            | ('overall_monthly', 'calmar_ratio')  |   0.155321  |  0.0731378 |
+            | ('overall_monthly', 'sortino_ratio') |   0.697382  |  0.439003  |
+            | ('overall_monthly', 'sharpe_ratio')  |   0.524943  |  0.307292  |
+            | ('overall_monthly', 'profit_factor') |   1.75714   |  1.27059   |
+            | ('overall_monthly', 'tail_ratio')    |   1.03322   |  0.903335  |
+            | ('overall_monthly', 'return')        |   0.0836545 |  0.0479377 |
+            | ('overall_monthly', 'volatility')    |   0.186989  |  0.316178  |
+            | ('overall_yearly', 'calmar_ratio')   |   0.436075  |  0.127784  |
+            | ('overall_yearly', 'sortino_ratio')  |   0.738327  |  0.694786  |
+            | ('overall_yearly', 'sharpe_ratio')   |   0.407324  |  0.350986  |
+            | ('overall_yearly', 'profit_factor')  |   2.2       |  1.66667   |
+            | ('overall_yearly', 'tail_ratio')     |   1.71647   |  1.359     |
+            | ('overall_yearly', 'return')         |   0.0814469 |  0.0663674 |
+            | ('overall_yearly', 'volatility')     |   0.284742  |  0.419087  |
+        """
+        self.results = None
+
+        def safe_division(n, d):
+            return n / d if d else 0
+
+        calc_cagr = (
+            lambda s: (s.add(1).prod()) ** safe_division(365.25, (s.index[-1] - s.index[0]).days) - 1 
+            if len(s) > 1 else 0)
+
+        def calc_calmar_ratio(pct):
+            s = pct.add(1).cumprod().iloc[1:]
+            return safe_division(calc_cagr(pct), abs(s.calc_max_drawdown()))
+
+        self.metrics = [
+                ("calmar_ratio", calc_calmar_ratio),
+                ('sortino_ratio', lambda s: safe_division(s.mean(), s[s < 0].std())
+                    * (safe_division(len(s), (s.index[-1] - s.index[0]).days) * 365) ** 0.5),
+                ('sharpe_ratio', lambda s: safe_division(s.mean(), s.std())
+                    * (safe_division(len(s), (s.index[-1] - s.index[0]).days) * 365) ** 0.5),
+                ('profit_factor', lambda s: safe_division((s > 0).sum(), (s < 0).sum())),
+                ('tail_ratio', lambda s: -safe_division(s.quantile(0.95), (s.quantile(0.05)))),
+                ('return', lambda s: calc_cagr(s)),
+                ('volatility', lambda s: s.std() * np.sqrt(safe_division(len(s), (s.index[-1] - s.index[0]).days) * 365)),
+                ]
+
+    def calc_stats(self, series):
+
+        ########################################
+        # calculate yearly metric performance
+        ########################################
+        pct = series.pct_change().fillna(0)
+
+        def eval_f(m, s):
+            if isinstance(m, str):
+                return getattr(s, m)()
+            else:
+                return m[1](s)
+
+
+        yearly = {}
+
+        for m in self.metrics:
+
+            name = m if isinstance(m, str) else m[0]
+            s = pct.groupby(pct.index.year).apply(lambda s: eval_f(m, s))
+            yearly[name] = s.values.tolist()
+
+        yearly['year'] = s.index.values.tolist()
+
+        ########################################
+        # calculate recent days performance
+        ########################################
+        recent_days = [20, 60, 120, 252, 756]
+        recent = {}
+        for m in self.metrics:
+            name = m if isinstance(m, str) else m[0]
+            recent[name] = []
+            for d in recent_days:
+                recent[name].append(eval_f(m, pct.iloc[-d:]))
+
+        recent['days'] = recent_days
+
+        ########################################
+        # calculate overall performance
+        ########################################
+        overall_daily = {}
+        overall_monthly = {}
+        overall_yearly = {}
+
+        pct_m = series.resample('M').last().dropna().pct_change().iloc[1:]
+        pct_y = series.resample('Y').last().dropna().pct_change().iloc[1:]
+
+        for m in self.metrics:
+            name = m if isinstance(m, str) else m[0]
+            overall_daily[name] = eval_f(m, pct)
+            overall_monthly[name] = eval_f(m, pct_m) if len(pct_m) > 1 else 0
+            overall_yearly[name] = eval_f(m, pct_y) if len(pct_y) > 1 else 0
+
+        return {'yearly': yearly, 
+                'recent': recent, 
+                'overall_daily': overall_daily, 
+                'overall_monthly': overall_monthly, 
+                'overall_yearly': overall_yearly}
+
+    def analyze(self, report):
+
+        ret = {}
+        ret['strategy'] = self.calc_stats(report.daily_creturn)
+        ret['benchmark'] = self.calc_stats(report.daily_benchmark)
+
+        self.results = ret
+
+        return ret
+
+    def display(self):
+
+        if self.results is None:
+            return
+
+        from IPython.display import HTML
+
+        t = ''
+        result = self.results
+        result['benchmark']['recent']['days'] = ['M', 'Q', 'HY', 'Y', '3Y']
+        result['strategy']['recent']['days'] = ['M', 'Q', 'HY', 'Y', '3Y']
+
+        df = pd.DataFrame({'benchmark': pd.DataFrame({cat: result['benchmark'][cat] for cat in ['overall_daily', 'overall_monthly', 'overall_yearly']}).unstack(),
+        'strategy': pd.DataFrame({cat: result['strategy'][cat] for cat in ['overall_daily', 'overall_monthly', 'overall_yearly']}).unstack()})
+
+        def highlight_max(s, props=''):
+            return np.where(s == np.nanmax(s.values), props, '')
+
+        t += df.style.apply(highlight_max, props='color:white;color:blue', axis=1).to_html()
+
+        for cat in ['yearly', 'recent']:
+
+            metric_names = result['strategy'][cat].keys()
+
+            index_name = {
+                'yearly': 'year',
+                'recent': 'days',
+            }[cat]
+
+            for mname in metric_names:
+
+                if mname == index_name:
+                    continue
+
+                df = pd.DataFrame([result['strategy'][cat][mname], result['benchmark'][cat][mname]], columns=result['strategy'][cat][index_name], index=['strategy', 'benchmark'])
+
+                def make_pretty(styler, df, title):
+                    styler.set_caption(title)
+                    styler.background_gradient(axis=None, vmin=df.min().min(), vmax=df.max().max(), cmap="YlGnBu")
+                    return styler
+
+                t += df.style.format(precision=2).pipe(lambda v: make_pretty(v, df, mname)).to_html() + '<br />'
+        return HTML(t)
```

## finlab/core/__init__.py

```diff
@@ -1 +1 @@
-00000000: 0d0a                                     ..
+00000000: 0a                                       .
```

## finlab/core/everything.js

### js-beautify {}

```diff
@@ -1,35199 +1,35199 @@
-var __defProp = Object.defineProperty;
-var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
-    enumerable: true,
-    configurable: true,
-    writable: true,
-    value
-}) : obj[key] = value;
-var __publicField = (obj, key, value) => {
-    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
-    return value;
-};
-
-function t() {}
-const e = (t3) => t3;
-
-function i(t3) {
-    return t3();
-}
-
-function s() {
-    return /* @__PURE__ */ Object.create(null);
-}
-
-function n(t3) {
-    t3.forEach(i);
-}
-
-function r(t3) {
-    return "function" == typeof t3;
-}
-
-function o(t3, e2) {
-    return t3 != t3 ? e2 == e2 : t3 !== e2 || t3 && "object" == typeof t3 || "function" == typeof t3;
-}
-
-function a(e2, i2, s2) {
-    e2.$$.on_destroy.push(function(e3, ...i3) {
-        if (null == e3) {
-            for (const t3 of i3)
-                t3(void 0);
-            return t;
-        }
-        const s3 = e3.subscribe(...i3);
-        return s3.unsubscribe ? () => s3.unsubscribe() : s3;
-    }(i2, s2));
-}
-
-function l(t3, e2, i2, s2) {
-    if (t3) {
-        const n2 = h(t3, e2, i2, s2);
-        return t3[0](n2);
-    }
-}
-
-function h(t3, e2, i2, s2) {
-    return t3[1] && s2 ? function(t4, e3) {
-        for (const i3 in e3)
-            t4[i3] = e3[i3];
-        return t4;
-    }(i2.ctx.slice(), t3[1](s2(e2))) : i2.ctx;
-}
-
-function c(t3, e2, i2, s2) {
-    if (t3[2] && s2) {
-        const n2 = t3[2](s2(i2));
-        if (void 0 === e2.dirty)
-            return n2;
-        if ("object" == typeof n2) {
-            const t4 = [],
-                i3 = Math.max(e2.dirty.length, n2.length);
-            for (let s3 = 0; s3 < i3; s3 += 1)
-                t4[s3] = e2.dirty[s3] | n2[s3];
-            return t4;
-        }
-        return e2.dirty | n2;
-    }
-    return e2.dirty;
-}
-
-function u(t3, e2, i2, s2, n2, r2) {
-    if (n2) {
-        const o2 = h(e2, i2, s2, r2);
-        t3.p(o2, n2);
-    }
-}
-
-function d(t3) {
-    if (t3.ctx.length > 32) {
-        const e2 = [],
-            i2 = t3.ctx.length / 32;
-        for (let t4 = 0; t4 < i2; t4++)
-            e2[t4] = -1;
-        return e2;
-    }
-    return -1;
-}
-
-function f(t3) {
-    return null == t3 ? "" : t3;
-}
-const p = "undefined" != typeof window;
-let m = p ? () => window.performance.now() : () => Date.now(),
-    g = p ? (t3) => requestAnimationFrame(t3) : t;
-const y = /* @__PURE__ */ new Set();
-
-function v(t3) {
-    y.forEach((e2) => {
-        e2.c(t3) || (y.delete(e2), e2.f());
-    }), 0 !== y.size && g(v);
-}
-
-function b(t3) {
-    let e2;
-    return 0 === y.size && g(v), {
-        promise: new Promise((i2) => {
-            y.add(e2 = {
-                c: t3,
-                f: i2
-            });
-        }),
-        abort() {
-            y.delete(e2);
-        }
-    };
-}
-
-function _(t3, e2) {
-    t3.appendChild(e2);
-}
-
-function w(t3, e2, i2) {
-    const s2 = x(t3);
-    if (!s2.getElementById(e2)) {
-        const t4 = P("style");
-        t4.id = e2, t4.textContent = i2, T(s2, t4);
-    }
-}
-
-function x(t3) {
-    if (!t3)
-        return document;
-    const e2 = t3.getRootNode ? t3.getRootNode() : t3.ownerDocument;
-    return e2 && e2.host ? e2 : t3.ownerDocument;
-}
-
-function k(t3) {
-    const e2 = P("style");
-    return e2.textContent = "/* empty */", T(x(t3), e2), e2.sheet;
-}
-
-function T(t3, e2) {
-    return _(t3.head || t3, e2), e2.sheet;
-}
-
-function S(t3, e2, i2) {
-    t3.insertBefore(e2, i2 || null);
-}
-
-function E(t3) {
-    t3.parentNode && t3.parentNode.removeChild(t3);
-}
-
-function C(t3, e2) {
-    for (let i2 = 0; i2 < t3.length; i2 += 1)
-        t3[i2] && t3[i2].d(e2);
-}
-
-function P(t3) {
-    return document.createElement(t3);
-}
-
-function R(t3) {
-    return document.createElementNS("http://www.w3.org/2000/svg", t3);
-}
-
-function D(t3) {
-    return document.createTextNode(t3);
-}
-
-function $() {
-    return D(" ");
-}
-
-function z() {
-    return D("");
-}
-
-function B(t3, e2, i2, s2) {
-    return t3.addEventListener(e2, i2, s2), () => t3.removeEventListener(e2, i2, s2);
-}
-
-function U(t3, e2, i2) {
-    null == i2 ? t3.removeAttribute(e2) : t3.getAttribute(e2) !== i2 && t3.setAttribute(e2, i2);
-}
-
-function j(t3) {
-    return "" === t3 ? null : +t3;
-}
-
-function H(t3, e2) {
-    e2 = "" + e2, t3.data !== e2 && (t3.data = e2);
-}
-
-function q(t3, e2) {
-    t3.value = null == e2 ? "" : e2;
-}
-
-function G(t3, e2, i2, s2) {
-    null == i2 ? t3.style.removeProperty(e2) : t3.style.setProperty(e2, i2, s2 ? "important" : "");
-}
-
-function Y(t3, e2, i2) {
-    t3.classList.toggle(e2, !!i2);
-}
-
-function it(t3, e2, {
-    bubbles: i2 = false,
-    cancelable: s2 = false
-} = {}) {
-    return new CustomEvent(t3, {
-        detail: e2,
-        bubbles: i2,
-        cancelable: s2
-    });
-}
-const st = /* @__PURE__ */ new Map();
-let rt, ht = 0;
-
-function ct(t3, e2, i2, s2, n2, r2, o2, a2 = 0) {
-    const l2 = 16.666 / s2;
-    let h2 = "{\n";
-    for (let t4 = 0; t4 <= 1; t4 += l2) {
-        const s3 = e2 + (i2 - e2) * r2(t4);
-        h2 += 100 * t4 + `%{${o2(s3, 1 - s3)}}
-`;
-    }
-    const c2 = h2 + `100% {${o2(i2, 1 - i2)}}
-}`,
-        u2 = `__svelte_${function(t4) {
-    let e3 = 5381, i3 = t4.length;
-    for (; i3--; )
-      e3 = (e3 << 5) - e3 ^ t4.charCodeAt(i3);
-    return e3 >>> 0;
-  }(c2)}_${a2}`,
-        d2 = x(t3),
-        {
-            stylesheet: f2,
-            rules: p2
-        } = st.get(d2) || function(t4, e3) {
-            const i3 = {
-                stylesheet: k(e3),
-                rules: {}
-            };
-            return st.set(t4, i3), i3;
-        }(d2, t3);
-    p2[u2] || (p2[u2] = true, f2.insertRule(`@keyframes ${u2} ${c2}`, f2.cssRules.length));
-    const m2 = t3.style.animation || "";
-    return t3.style.animation = `${m2 ? `${m2}, ` : ""}${u2} ${s2}ms linear ${n2}ms 1 both`, ht += 1, u2;
-}
-
-function ut(t3, e2) {
-    const i2 = (t3.style.animation || "").split(", "),
-        s2 = i2.filter(e2 ? (t4) => t4.indexOf(e2) < 0 : (t4) => -1 === t4.indexOf("__svelte")),
-        n2 = i2.length - s2.length;
-    n2 && (t3.style.animation = s2.join(", "), ht -= n2, ht || g(() => {
-        ht || (st.forEach((t4) => {
-            const {
-                ownerNode: e3
-            } = t4.stylesheet;
-            e3 && E(e3);
-        }), st.clear());
-    }));
-}
-
-function dt(t3) {
-    rt = t3;
-}
-
-function ft() {
-    if (!rt)
-        throw new Error("Function called outside component initialization");
-    return rt;
-}
-
-function pt(t3) {
-    ft().$$.on_mount.push(t3);
-}
-
-function yt(t3) {
-    ft().$$.on_destroy.push(t3);
-}
-
-function bt() {
-    const t3 = ft();
-    return (e2, i2, {
-        cancelable: s2 = false
-    } = {}) => {
-        const n2 = t3.$$.callbacks[e2];
-        if (n2) {
-            const r2 = it(e2, i2, {
-                cancelable: s2
-            });
-            return n2.slice().forEach((e3) => {
-                e3.call(t3, r2);
-            }), !r2.defaultPrevented;
-        }
-        return true;
-    };
-}
-const _t = [],
-    xt = [];
-let kt = [];
-const St = [],
-    It = Promise.resolve();
-let Mt = false;
-
-function At() {
-    Mt || (Mt = true, It.then(te));
-}
-
-function Lt() {
-    return At(), It;
-}
-
-function Ot(t3) {
-    kt.push(t3);
-}
-const Ht = /* @__PURE__ */ new Set();
-let Qt, Jt = 0;
-
-function te() {
-    if (0 !== Jt)
-        return;
-    const t3 = rt;
-    do {
-        try {
-            for (; Jt < _t.length;) {
-                const t4 = _t[Jt];
-                Jt++, dt(t4), ee(t4.$$);
-            }
-        } catch (t4) {
-            throw _t.length = 0, Jt = 0, t4;
-        }
-        for (dt(null), _t.length = 0, Jt = 0; xt.length;)
-            xt.pop()();
-        for (let t4 = 0; t4 < kt.length; t4 += 1) {
-            const e2 = kt[t4];
-            Ht.has(e2) || (Ht.add(e2), e2());
-        }
-        kt.length = 0;
-    } while (_t.length);
-    for (; St.length;)
-        St.pop()();
-    Mt = false, Ht.clear(), dt(t3);
-}
-
-function ee(t3) {
-    if (null !== t3.fragment) {
-        t3.update(), n(t3.before_update);
-        const e2 = t3.dirty;
-        t3.dirty = [-1], t3.fragment && t3.fragment.p(t3.ctx, e2), t3.after_update.forEach(Ot);
-    }
-}
-
-function ie() {
-    return Qt || (Qt = Promise.resolve(), Qt.then(() => {
-        Qt = null;
-    })), Qt;
-}
-
-function se(t3, e2, i2) {
-    t3.dispatchEvent(it(`${e2 ? "intro" : "outro"}${i2}`));
-}
-const ne = /* @__PURE__ */ new Set();
-let re;
-
-function oe() {
-    re = {
-        r: 0,
-        c: [],
-        p: re
-    };
-}
-
-function ae() {
-    re.r || n(re.c), re = re.p;
-}
-
-function le(t3, e2) {
-    t3 && t3.i && (ne.delete(t3), t3.i(e2));
-}
-
-function he(t3, e2, i2, s2) {
-    if (t3 && t3.o) {
-        if (ne.has(t3))
-            return;
-        ne.add(t3), re.c.push(() => {
-            ne.delete(t3), s2 && (i2 && t3.d(1), s2());
-        }), t3.o(e2);
-    } else
-        s2 && s2();
-}
-const ce = {
-    duration: 0
-};
-
-function ue(t3) {
-    return void 0 !== (t3 == null ? void 0 : t3.length) ? t3 : Array.from(t3);
-}
-
-function de(t3, e2) {
-    t3.d(1), e2.delete(t3.key);
-}
-
-function fe(t3, e2) {
-    he(t3, 1, 1, () => {
-        e2.delete(t3.key);
-    });
-}
-
-function pe(t3, e2, i2, s2, r2, o2, a2, l2, h2, c2, u2, d2) {
-    let f2 = t3.length,
-        p2 = o2.length,
-        m2 = f2;
-    const g2 = {};
-    for (; m2--;)
-        g2[t3[m2].key] = m2;
-    const y2 = [],
-        v2 = /* @__PURE__ */ new Map(),
-        b2 = /* @__PURE__ */ new Map(),
-        _2 = [];
-    for (m2 = p2; m2--;) {
-        const t4 = d2(r2, o2, m2),
-            n2 = i2(t4);
-        let l3 = a2.get(n2);
-        l3 ? s2 && _2.push(() => l3.p(t4, e2)) : (l3 = c2(n2, t4), l3.c()), v2.set(n2, y2[m2] = l3), n2 in g2 && b2.set(n2, Math.abs(m2 - g2[n2]));
-    }
-    const w2 = /* @__PURE__ */ new Set(),
-        x2 = /* @__PURE__ */ new Set();
-
-    function k2(t4) {
-        le(t4, 1), t4.m(l2, u2), a2.set(t4.key, t4), u2 = t4.first, p2--;
-    }
-    for (; f2 && p2;) {
-        const e3 = y2[p2 - 1],
-            i3 = t3[f2 - 1],
-            s3 = e3.key,
-            n2 = i3.key;
-        e3 === i3 ? (u2 = e3.first, f2--, p2--) : v2.has(n2) ? !a2.has(s3) || w2.has(s3) ? k2(e3) : x2.has(n2) ? f2-- : b2.get(s3) > b2.get(n2) ? (x2.add(s3), k2(e3)) : (w2.add(n2), f2--) : (h2(i3, a2), f2--);
-    }
-    for (; f2--;) {
-        const e3 = t3[f2];
-        v2.has(e3.key) || h2(e3, a2);
-    }
-    for (; p2;)
-        k2(y2[p2 - 1]);
-    return n(_2), y2;
-}
-
-function me(t3) {
-    t3 && t3.c();
-}
-
-function ge(t3, e2, s2) {
-    const {
-        fragment: o2,
-        after_update: a2
-    } = t3.$$;
-    o2 && o2.m(e2, s2), Ot(() => {
-        const e3 = t3.$$.on_mount.map(i).filter(r);
-        t3.$$.on_destroy ? t3.$$.on_destroy.push(...e3) : n(e3), t3.$$.on_mount = [];
-    }), a2.forEach(Ot);
-}
-
-function ye(t3, e2) {
-    const i2 = t3.$$;
-    null !== i2.fragment && (! function(t4) {
-        const e3 = [],
-            i3 = [];
-        kt.forEach((s2) => -1 === t4.indexOf(s2) ? e3.push(s2) : i3.push(s2)), i3.forEach((t5) => t5()), kt = e3;
-    }(i2.after_update), n(i2.on_destroy), i2.fragment && i2.fragment.d(e2), i2.on_destroy = i2.fragment = null, i2.ctx = []);
-}
-
-function ve(e2, i2, r2, o2, a2, l2, h2, c2 = [-1]) {
-    const u2 = rt;
-    dt(e2);
-    const d2 = e2.$$ = {
-        fragment: null,
-        ctx: [],
-        props: l2,
-        update: t,
-        not_equal: a2,
-        bound: s(),
-        on_mount: [],
-        on_destroy: [],
-        on_disconnect: [],
-        before_update: [],
-        after_update: [],
-        context: new Map(i2.context || (u2 ? u2.$$.context : [])),
-        callbacks: s(),
-        dirty: c2,
-        skip_bound: false,
-        root: i2.target || u2.$$.root
-    };
-    h2 && h2(d2.root);
-    let f2 = false;
-    if (d2.ctx = r2 ? r2(e2, i2.props || {}, (t3, i3, ...s2) => {
-            const n2 = s2.length ? s2[0] : i3;
-            return d2.ctx && a2(d2.ctx[t3], d2.ctx[t3] = n2) && (!d2.skip_bound && d2.bound[t3] && d2.bound[t3](n2), f2 && function(t4, e3) {
-                -1 === t4.$$.dirty[0] && (_t.push(t4), At(), t4.$$.dirty.fill(0)), t4.$$.dirty[e3 / 31 | 0] |= 1 << e3 % 31;
-            }(e2, t3)), i3;
-        }) : [], d2.update(), f2 = true, n(d2.before_update), d2.fragment = !!o2 && o2(d2.ctx), i2.target) {
-        if (i2.hydrate) {
-            const t3 = function(t4) {
-                return Array.from(t4.childNodes);
-            }(i2.target);
-            d2.fragment && d2.fragment.l(t3), t3.forEach(E);
-        } else
-            d2.fragment && d2.fragment.c();
-        i2.intro && le(e2.$$.fragment), ge(e2, i2.target, i2.anchor), te();
-    }
-    dt(u2);
-}
-let be;
-
-function _e(t3, e2, i2, s2) {
-    var _a2;
-    const n2 = (_a2 = i2[t3]) == null ? void 0 : _a2.type;
-    if (e2 = "Boolean" === n2 && "boolean" != typeof e2 ? null != e2 : e2, !s2 || !i2[t3])
-        return e2;
-    if ("toAttribute" === s2)
-        switch (n2) {
-            case "Object":
-            case "Array":
-                return null == e2 ? null : JSON.stringify(e2);
-            case "Boolean":
-                return e2 ? "" : null;
-            case "Number":
-                return null == e2 ? null : e2;
-            default:
-                return e2;
-        }
-    else
-        switch (n2) {
-            case "Object":
-            case "Array":
-                return e2 && JSON.parse(e2);
-            case "Boolean":
-            default:
-                return e2;
-            case "Number":
-                return null != e2 ? +e2 : e2;
-        }
-}
-
-function we(t3, e2, i2, s2, n2) {
-    const r2 = class extends be {
-        constructor() {
-            super(t3, i2, n2), this.$$p_d = e2;
-        }
-        static get observedAttributes() {
-            return Object.keys(e2).map((t4) => (e2[t4].attribute || t4).toLowerCase());
-        }
-    };
-    return Object.keys(e2).forEach((t4) => {
-        Object.defineProperty(r2.prototype, t4, {
-            get() {
-                return this.$$c && t4 in this.$$c ? this.$$c[t4] : this.$$d[t4];
-            },
-            set(i3) {
-                var _a2;
-                i3 = _e(t4, i3, e2), this.$$d[t4] = i3, (_a2 = this.$$c) == null ? void 0 : _a2.$set({
-                    [t4]: i3
-                });
-            }
-        });
-    }), s2.forEach((t4) => {
-        Object.defineProperty(r2.prototype, t4, {
-            get() {
-                var _a2;
-                return (_a2 = this.$$c) == null ? void 0 : _a2[t4];
-            }
-        });
-    }), t3.element = r2, r2;
-}
-"function" == typeof HTMLElement && (be = class extends HTMLElement {
-    constructor(t3, e2, i2) {
-        super();
-        __publicField(this, "$$ctor");
-        __publicField(this, "$$s");
-        __publicField(this, "$$c");
-        __publicField(this, "$$cn", false);
-        __publicField(this, "$$d", {});
-        __publicField(this, "$$r", false);
-        __publicField(this, "$$p_d", {});
-        __publicField(this, "$$l", {});
-        __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
-        this.$$ctor = t3, this.$$s = e2, i2 && this.attachShadow({
-            mode: "open"
-        });
-    }
-    addEventListener(t3, e2, i2) {
-        if (this.$$l[t3] = this.$$l[t3] || [], this.$$l[t3].push(e2), this.$$c) {
-            const i3 = this.$$c.$on(t3, e2);
-            this.$$l_u.set(e2, i3);
-        }
-        super.addEventListener(t3, e2, i2);
-    }
-    removeEventListener(t3, e2, i2) {
-        if (super.removeEventListener(t3, e2, i2), this.$$c) {
-            const t4 = this.$$l_u.get(e2);
-            t4 && (t4(), this.$$l_u.delete(e2));
-        }
-    }
-    async connectedCallback() {
-        if (this.$$cn = true, !this.$$c) {
-            let t3 = function(t4) {
-                return () => {
-                    let e3;
-                    return {
-                        c: function() {
-                            e3 = P("slot"), "default" !== t4 && U(e3, "name", t4);
-                        },
-                        m: function(t5, i3) {
-                            S(t5, e3, i3);
-                        },
-                        d: function(t5) {
-                            t5 && E(e3);
-                        }
-                    };
-                };
-            };
-            if (await Promise.resolve(), !this.$$cn)
-                return;
-            const e2 = {},
-                i2 = function(t4) {
-                    const e3 = {};
-                    return t4.childNodes.forEach((t5) => {
-                        e3[t5.slot || "default"] = true;
-                    }), e3;
-                }(this);
-            for (const n2 of this.$$s)
-                n2 in i2 && (e2[n2] = [t3(n2)]);
-            for (const r2 of this.attributes) {
-                const o2 = this.$$g_p(r2.name);
-                o2 in this.$$d || (this.$$d[o2] = _e(o2, r2.value, this.$$p_d, "toProp"));
-            }
-            this.$$c = new this.$$ctor({
-                target: this.shadowRoot || this,
-                props: {
-                    ...this.$$d,
-                    $$slots: e2,
-                    $$scope: {
-                        ctx: []
-                    }
-                }
-            });
-            const s2 = () => {
-                this.$$r = true;
-                for (const t4 in this.$$p_d)
-                    if (this.$$d[t4] = this.$$c.$$.ctx[this.$$c.$$.props[t4]], this.$$p_d[t4].reflect) {
-                        const e3 = _e(t4, this.$$d[t4], this.$$p_d, "toAttribute");
-                        null == e3 ? this.removeAttribute(t4) : this.setAttribute(this.$$p_d[t4].attribute || t4, e3);
-                    }
-                this.$$r = false;
-            };
-            this.$$c.$$.after_update.push(s2), s2();
-            for (const a2 in this.$$l)
-                for (const l2 of this.$$l[a2]) {
-                    const h2 = this.$$c.$on(a2, l2);
-                    this.$$l_u.set(l2, h2);
-                }
-            this.$$l = {};
-        }
-    }
-    attributeChangedCallback(t3, e2, i2) {
-        var _a2;
-        this.$$r || (t3 = this.$$g_p(t3), this.$$d[t3] = _e(t3, i2, this.$$p_d, "toProp"), (_a2 = this.$$c) == null ? void 0 : _a2.$set({
-            [t3]: this.$$d[t3]
-        }));
-    }
-    disconnectedCallback() {
-        this.$$cn = false, Promise.resolve().then(() => {
-            this.$$cn || (this.$$c.$destroy(), this.$$c = void 0);
-        });
-    }
-    $$g_p(t3) {
-        return Object.keys(this.$$p_d).find((e2) => this.$$p_d[e2].attribute === t3 || !this.$$p_d[e2].attribute && e2.toLowerCase() === t3) || t3;
-    }
-});
-class SvelteComponent {
-    constructor() {
-        __publicField(this, "$$");
-        __publicField(this, "$$set");
-    }
-    $destroy() {
-        ye(this, 1), this.$destroy = t;
-    }
-    $on(e2, i2) {
-        if (!r(i2))
-            return t;
-        const s2 = this.$$.callbacks[e2] || (this.$$.callbacks[e2] = []);
-        return s2.push(i2), () => {
-            const t3 = s2.indexOf(i2); -
-            1 !== t3 && s2.splice(t3, 1);
-        };
-    }
-    $set(t3) {
-        var e2;
-        this.$$set && (e2 = t3, 0 !== Object.keys(e2).length) && (this.$$.skip_bound = true, this.$$set(t3), this.$$.skip_bound = false);
-    }
-}
-"undefined" != typeof window && (window.__svelte || (window.__svelte = {
-    v: /* @__PURE__ */ new Set()
-})).v.add("4");
-const xe = [{
-    backtest: ["startDate", "endDate", "version", "feeRatio", "taxRatio", "tradeAt", "market", "freq", "updateDate", "nextTradingDate", "livePerformanceStart", "stopLoss", "takeProfit"]
-}, {
-    profitability: ["annualReturn", "alpha", "beta", "avgNStock", "maxNStock"]
-}, {
-    risk: ["maxDrawdown", "avgDrawdown", "avgDrawdownDays", "valueAtRisk", "cvalueAtRisk"]
-}, {
-    ratio: ["sharpeRatio", "sortinoRatio", "calmarRatio", "profitFactor", "tailRatio"]
-}, {
-    winrate: ["winRate", "m12WinRate", "expectancy", "mae", "mfe"]
-}, {
-    liquidity: ["capacity", "disposalStockRatio", "warningStockRatio", "fullDeliveryStockRatio", "buyHigh", "sellLow"]
-}];
-
-function ke(t3) {
-    const e2 = {},
-        i2 = xe;
-    for (const s2 of i2)
-        for (const i3 in s2) {
-            e2[i3] = {};
-            for (const n2 of s2[i3])
-                e2[i3][n2] = t3[i3][n2];
-        }
-    return e2;
-}
-const Te = {
-    profitability: {
-        annualReturn: (t3) => t3 > 0.15,
-        alpha: (t3) => t3 > 0.1,
-        beta: (t3) => t3 < 0.8 && t3 > 0,
-        avgNStock: (t3) => t3 >= 5,
-        maxNStock: (t3) => t3 <= 20
-    },
-    risk: {
-        maxDrawdown: (t3) => t3 > -0.3,
-        avgDrawdown: (t3) => t3 > -0.1,
-        avgDrawdownDays: (t3) => t3 < 40,
-        volatility: (t3) => t3 < 0.2,
-        valueAtRisk: (t3) => t3 > -0.07,
-        cvalueAtRisk: (t3) => t3 > -0.1
-    },
-    ratio: {
-        sharpeRatio: (t3) => t3 > 1.3,
-        sortinoRatio: (t3) => t3 > 1.8,
-        calmarRatio: (t3) => t3 > 0.9,
-        profitFactor: (t3) => t3 > 1.5,
-        tailRatio: (t3) => t3 > 1
-    },
-    winrate: {
-        winRate: (t3) => t3 > 0.55,
-        m12WinRate: (t3) => t3 > 0.7,
-        expectancy: (t3) => t3 > 0.02,
-        mae: (t3) => t3 > -0.1,
-        mfe: (t3) => t3 > 0.1
-    },
-    liquidity: {
-        capacity: (t3) => t3 > 5e5,
-        disposalStockRatio: (t3) => t3 < 0.05,
-        warningStockRatio: (t3) => t3 < 0.05,
-        fullDeliveryStockRatio: (t3) => t3 < 0.05,
-        buyHigh: (t3) => t3 < 0.05,
-        sellLow: (t3) => t3 < 0.05
-    }
-};
-
-function Se(t3) {
-    const e2 = {
-        profitability: 0,
-        risk: 0,
-        ratio: 0,
-        winrate: 0,
-        liquidity: 0
-    };
-    for (const i2 in Te)
-        for (const s2 in Te[i2])
-            Te[i2][s2](t3[i2][s2]) && (e2[i2]++, "liquidity" === i2 && "capacity" === s2 && (e2[i2] += 10));
-    for (const t4 in e2) {
-        let i2 = Object.keys(Te[t4]).length;
-        "liquidity" === t4 && (i2 += 10), e2[t4] = e2[t4] / i2;
-    }
-    return e2;
-}
-class MetricDisplay {
-    constructor() {
-        this.percentage = (t3) => (100 * t3).toFixed(1), this.sign = (t3) => "string" == typeof t3 && "-" != t3[0] || "number" == typeof t3 && t3 > 0 ? "+" + String(t3) : String(t3), this.color = (t3) => t3 > 0 ? "text-rise" : "text-fall", this.formatter = {
-            annualReturn: (t3) => this.sign(this.percentage(t3)),
-            alpha: (t3) => this.sign(this.percentage(t3)),
-            avgNStock: (t3) => t3.toFixed(0),
-            maxNStock: (t3) => t3.toFixed(0),
-            maxDrawdown: (t3) => this.sign(this.percentage(t3)),
-            avgDrawdown: (t3) => this.sign(this.percentage(t3)),
-            valueAtRisk: (t3) => this.sign(this.percentage(t3)),
-            cvalueAtRisk: (t3) => this.sign(this.percentage(t3)),
-            winRate: (t3) => this.percentage(t3),
-            m12WinRate: (t3) => this.percentage(t3),
-            expectancy: (t3) => this.sign(this.percentage(t3)),
-            mae: (t3) => this.sign(this.percentage(t3)),
-            mfe: (t3) => this.sign(this.percentage(t3)),
-            smallCapRatio: (t3) => this.percentage(t3),
-            capacity: (t3) => (t3 / 1e4).toFixed(0),
-            disposalStockRatio: (t3) => this.percentage(t3),
-            warningStockRatio: (t3) => this.percentage(t3),
-            fullDeliveryStockRatio: (t3) => this.percentage(t3),
-            buyHigh: (t3) => this.percentage(t3),
-            sellLow: (t3) => this.percentage(t3)
-        }, this.units = {
-            annualReturn: "%",
-            alpha: "%",
-            avgNStock: "檔",
-            maxNStock: "檔",
-            maxDrawdown: "%",
-            avgDrawdown: "%",
-            avgDrawdownDays: "天",
-            valueAtRisk: "%",
-            cvalueAtRisk: "%",
-            winRate: "%",
-            m12WinRate: "%",
-            expectancy: "%",
-            mae: "%",
-            mfe: "%",
-            smallCapRatio: "%",
-            capacity: "萬",
-            disposalStockRatio: "%",
-            warningStockRatio: "%",
-            fullDeliveryStockRatio: "%",
-            buyHigh: "%",
-            sellLow: "%"
-        };
-    }
-    format(t3, e2) {
-        if (t3 in this.formatter)
-            try {
-                return this.formatter[t3](e2);
-            } catch {}
-        try {
-            return String(e2.toFixed(2));
-        } catch {}
-        return String(e2);
-    }
-    getUnit(t3) {
-        return t3 in this.units ? this.units[t3] : "";
-    }
-}
-
-function Ee(t3, e2, i2, s2) {
-    let n2 = e2.length,
-        r2 = void 0 !== i2 ? i2 : 0,
-        o2 = void 0 !== s2 ? s2 : n2 - 1,
-        a2 = r2 + Math.floor((o2 - r2) / 2);
-    0 !== n2 ? t3 >= e2[o2] ? e2.splice(o2 + 1, 0, t3) : t3 < e2[r2] ? e2.splice(r2, 0, t3) : r2 >= o2 || (t3 <= e2[a2] ? Ee(t3, e2, r2, a2) : t3 > e2[a2] && Ee(t3, e2, a2 + 1, o2)) : e2.push(t3);
-}
-
-function Ce(t3, e2, i2) {
-    let s2 = [],
-        n2 = [];
-    t3.slice(0, i2).forEach((t4) => Ee(t4, s2));
-    for (let r2 = i2; r2 < t3.length; r2++)
-        n2.push(s2[Math.floor(i2 * e2)]), s2.splice(s2.indexOf(t3[r2 - i2]), 1), Ee(t3[r2], s2);
-    return n2.push(s2[Math.floor(i2 * e2)]), n2;
-}
-class Report {
-    constructor(t3, e2, i2, s2, n2) {
-        this.timestamps = t3, this.strategy = e2, this.benchmark = i2, this.trades = s2, this.metrics = n2;
-    }
-    createTradingviewSeries(t3, e2 = 0, i2 = -1, s2 = 500) {
-        const n2 = this.timestamps.map((e3, i3) => ({
-                time: e3,
-                value: this[t3][i3]
-            })).slice(this.indexOfTimestamps(e2), this.indexOfTimestamps(i2) + 1),
-            r2 = this.timestamps.map((t4, e3) => 0 === e3 || t4.substring(0, 7) !== this.timestamps[e3 - 1].substring(0, 7)),
-            o2 = Math.round(n2.length / s2);
-        return n2.filter((t4, e3) => e3 % o2 == 0 || e3 === n2.length - 1 || r2[e3]);
-    }
-    indexOfTimestamps(t3) {
-        return "string" == typeof t3 ? function(t4, e2) {
-            let i2 = 0,
-                s2 = t4.length - 1,
-                n2 = -1;
-            for (; i2 <= s2;) {
-                const r2 = Math.ceil((i2 + s2) / 2);
-                if (t4[r2] === e2)
-                    return r2;
-                t4[r2] < e2 ? (n2 = r2, i2 = r2 + 1) : (n2 = r2, s2 = r2 - 1);
-            }
-            return e2 < t4[n2] && (n2 -= 1), n2;
-        }(this.timestamps, t3) : t3 < 0 ? Math.min(Math.max(this.timestamps.length + t3, 0), this.timestamps.length - 1) : t3;
-    }
-    calculateAnnualReturn(t3) {
-        const e2 = {};
-        let i2 = this[t3][0];
-        for (let s2 = 1; s2 < this.timestamps.length; s2++) {
-            const n2 = new Date(this.timestamps[s2]).getFullYear();
-            if (s2 === this.timestamps.length - 1 || new Date(this.timestamps[s2 + 1]).getFullYear() !== n2) {
-                const r2 = this[t3][s2];
-                e2[n2] = r2 / i2 - 1, i2 = r2;
-            }
-        }
-        return e2;
-    }
-    calculateMonthlyReturn(t3) {
-        const e2 = {};
-        let i2 = this[t3][0];
-        for (let s2 = 1; s2 < this.timestamps.length; s2++) {
-            const n2 = new Date(this.timestamps[s2]),
-                r2 = n2.getFullYear(),
-                o2 = n2.getMonth() + 1;
-            if (s2 === this.timestamps.length - 1 || new Date(this.timestamps[s2 + 1]).getMonth() + 1 !== o2) {
-                const n3 = this[t3][s2];
-                e2[`${r2}${o2}`] = n3 / i2 - 1, i2 = n3;
-            }
-        }
-        return e2;
-    }
-    calculateMostRecentNDayReturn(t3, e2) {
-        const i2 = this[t3],
-            s2 = i2.length,
-            n2 = {};
-        for (const t4 of e2) {
-            const e3 = parseInt(t4);
-            if (s2 < e3)
-                continue;
-            const r2 = 100 * (i2[s2 - 1] / i2[s2 - e3 - 1] - 1);
-            n2[t4] = r2;
-        }
-        return n2;
-    }
-    createTradingViewDrawdown(t3, e2 = 100) {
-        let i2 = 100,
-            s2 = [];
-        const n2 = this[t3];
-        for (let t4 = 0; t4 < this.timestamps.length; t4 += 1)
-            i2 = Math.max(n2[t4], i2), s2.push(n2[t4] / i2 * 100 - 100);
-        const r2 = Math.round(s2.length / e2);
-        const o2 = function(t4, e3) {
-            let i3 = [],
-                s3 = [];
-            for (let n3 = 0; n3 < t4.length; n3++) {
-                for (; i3.length > 0 && t4[n3] < t4[i3[i3.length - 1]];)
-                    i3.pop();
-                i3.push(n3), i3[0] < n3 - e3 + 1 && i3.shift(), n3 >= e3 - 1 && s3.push(t4[i3[0]]);
-            }
-            return s3;
-        }(s2, r2);
-        let a2 = this.timestamps.map((t4, e3) => ({
-            time: t4,
-            value: o2[e3]
-        }));
-        return a2.filter((t4, e3) => e3 % r2 == 0 || e3 === a2.length - 1);
-    }
-    calculateDrawdown(t3) {
-        let e2 = 0,
-            i2 = 1,
-            s2 = 1,
-            n2 = 0,
-            r2 = [];
-        const o2 = this[t3];
-        for (let t4 = 0; t4 < this.timestamps.length; t4 += 1) {
-            const a3 = o2[t4];
-            if (a3 > i2)
-                t4 - e2 >= 2 && r2.push({
-                    maxDrawdown: s2 - 1,
-                    start: e2,
-                    end: t4,
-                    at: n2
-                }), e2 = t4, i2 = a3, s2 = 1, n2 = t4;
-            else {
-                const e3 = a3 / i2;
-                s2 > e3 && (s2 = e3, n2 = t4);
-            }
-        }
-        r2.sort((t4, e3) => -(t4.end - t4.start) + (e3.end - e3.start));
-        const a2 = r2.slice(0, 5);
-        r2.sort((t4, e3) => t4.maxDrawdown - e3.maxDrawdown);
-        return [r2.slice(0, 5), a2];
-    }
-    calculateSharpe(t3, e2, i2) {
-        let s2 = [],
-            n2 = 0,
-            r2 = 0,
-            o2 = [],
-            a2 = [];
-        const l2 = this[t3];
-        for (let t4 = 1; t4 < l2.length; t4++) {
-            let h2 = l2[t4] / l2[t4 - 1] - 1;
-            o2.push(h2), n2 += h2;
-            let c2 = n2 / i2,
-                u2 = (h2 - c2) * (h2 - c2);
-            if (a2.push(u2), r2 += u2, t4 >= i2) {
-                n2 -= o2.shift(), r2 -= a2.shift();
-            }
-            if (t4 >= i2 - 1) {
-                let t5 = r2 / i2,
-                    n3 = (c2 - e2) / Math.sqrt(t5);
-                s2.push(n3);
-            }
-        }
-        return s2.map((t4, e3) => ({
-            time: this.timestamps[e3 + i2 - 1],
-            value: t4 * Math.sqrt(i2)
-        }));
-    }
-    calculateSortino(t3, e2, i2) {
-        let s2 = [],
-            n2 = 0,
-            r2 = 0,
-            o2 = [],
-            a2 = [];
-        const l2 = this[t3];
-        for (let t4 = 1; t4 < l2.length; t4++) {
-            let h2 = l2[t4] / l2[t4 - 1] - 1;
-            n2 += h2, o2.push(h2);
-            let c2 = n2 / i2,
-                u2 = (h2 - c2) * (h2 - c2);
-            if (a2.push(u2), h2 < e2 && (r2 += u2), t4 >= i2) {
-                let t5 = o2.shift(),
-                    i3 = a2.shift();
-                n2 -= t5, t5 < e2 && (r2 -= i3);
-            }
-            if (t4 >= i2 - 1) {
-                let t5 = r2 / i2,
-                    n3 = (c2 - e2) / Math.sqrt(t5);
-                s2.push(n3);
-            }
-        }
-        return s2.map((t4, e3) => ({
-            time: this.timestamps[e3 + i2 - 1],
-            value: t4 * Math.sqrt(i2)
-        }));
-    }
-    calculateVolitility(t3, e2, i2) {
-        let s2 = [],
-            n2 = 0,
-            r2 = 0,
-            o2 = [],
-            a2 = [];
-        const l2 = this[t3];
-        for (let t4 = 1; t4 < l2.length; t4++) {
-            let e3 = l2[t4] / l2[t4 - 1] - 1;
-            n2 += e3, o2.push(e3);
-            let h2 = n2 / i2,
-                c2 = (e3 - h2) * (e3 - h2);
-            if (r2 += c2, a2.push(c2), t4 >= i2) {
-                n2 -= o2.shift(), r2 -= a2.shift();
-            }
-            if (t4 >= i2 - 1) {
-                let t5 = r2 / i2,
-                    e4 = Math.sqrt(t5);
-                s2.push(e4);
-            }
-        }
-        return s2.map((t4, e3) => ({
-            time: this.timestamps[e3 + i2 - 1],
-            value: t4 * Math.sqrt(i2)
-        }));
-    }
-    calculateTailRatio(t3, e2) {
-        let i2 = this[t3];
-        i2 = i2.map((t4, e3) => t4 / i2[e3 - 1] - 1), i2[0] = 0;
-        const s2 = Ce(i2, 0.95, e2),
-            n2 = Ce(i2, 0.05, e2);
-        return s2.map((t4, e3) => Math.abs(t4 / n2[e3])).map((t4, i3) => ({
-            time: this.timestamps[i3 + e2 - 1],
-            value: t4
-        }));
-    }
-}
-
-function Ie(t3) {
-    return t3 + 0.5 | 0;
-}
-const Me = (t3, e2, i2) => Math.max(Math.min(t3, i2), e2);
-
-function Pe(t3) {
-    return Me(Ie(2.55 * t3), 0, 255);
-}
-
-function Re(t3) {
-    return Me(Ie(255 * t3), 0, 255);
-}
-
-function Ae(t3) {
-    return Me(Ie(t3 / 2.55) / 100, 0, 1);
-}
-
-function De(t3) {
-    return Me(Ie(100 * t3), 0, 100);
-}
-const Le = {
-        0: 0,
-        1: 1,
-        2: 2,
-        3: 3,
-        4: 4,
-        5: 5,
-        6: 6,
-        7: 7,
-        8: 8,
-        9: 9,
-        A: 10,
-        B: 11,
-        C: 12,
-        D: 13,
-        E: 14,
-        F: 15,
-        a: 10,
-        b: 11,
-        c: 12,
-        d: 13,
-        e: 14,
-        f: 15
-    },
-    Oe = [..."0123456789ABCDEF"],
-    Fe = (t3) => Oe[15 & t3],
-    Ne = (t3) => Oe[(240 & t3) >> 4] + Oe[15 & t3],
-    $e = (t3) => (240 & t3) >> 4 == (15 & t3);
-
-function Ve(t3) {
-    var e2 = ((t4) => $e(t4.r) && $e(t4.g) && $e(t4.b) && $e(t4.a))(t3) ? Fe : Ne;
-    return t3 ? "#" + e2(t3.r) + e2(t3.g) + e2(t3.b) + ((t4, e3) => t4 < 255 ? e3(t4) : "")(t3.a, e2) : void 0;
-}
-const ze = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
-
-function Be(t3, e2, i2) {
-    const s2 = e2 * Math.min(i2, 1 - i2),
-        n2 = (e3, n3 = (e3 + t3 / 30) % 12) => i2 - s2 * Math.max(Math.min(n3 - 3, 9 - n3, 1), -1);
-    return [n2(0), n2(8), n2(4)];
-}
-
-function Ue(t3, e2, i2) {
-    const s2 = (s3, n2 = (s3 + t3 / 60) % 6) => i2 - i2 * e2 * Math.max(Math.min(n2, 4 - n2, 1), 0);
-    return [s2(5), s2(3), s2(1)];
-}
-
-function je(t3, e2, i2) {
-    const s2 = Be(t3, 1, 0.5);
-    let n2;
-    for (e2 + i2 > 1 && (n2 = 1 / (e2 + i2), e2 *= n2, i2 *= n2), n2 = 0; n2 < 3; n2++)
-        s2[n2] *= 1 - e2 - i2, s2[n2] += e2;
-    return s2;
-}
-
-function He(t3) {
-    const e2 = t3.r / 255,
-        i2 = t3.g / 255,
-        s2 = t3.b / 255,
-        n2 = Math.max(e2, i2, s2),
-        r2 = Math.min(e2, i2, s2),
-        o2 = (n2 + r2) / 2;
-    let a2, l2, h2;
-    return n2 !== r2 && (h2 = n2 - r2, l2 = o2 > 0.5 ? h2 / (2 - n2 - r2) : h2 / (n2 + r2), a2 = function(t4, e3, i3, s3, n3) {
-        return t4 === n3 ? (e3 - i3) / s3 + (e3 < i3 ? 6 : 0) : e3 === n3 ? (i3 - t4) / s3 + 2 : (t4 - e3) / s3 + 4;
-    }(e2, i2, s2, h2, n2), a2 = 60 * a2 + 0.5), [0 | a2, l2 || 0, o2];
-}
-
-function We(t3, e2, i2, s2) {
-    return (Array.isArray(e2) ? t3(e2[0], e2[1], e2[2]) : t3(e2, i2, s2)).map(Re);
-}
-
-function qe(t3, e2, i2) {
-    return We(Be, t3, e2, i2);
-}
-
-function Ke(t3) {
-    return (t3 % 360 + 360) % 360;
-}
-
-function Ge(t3) {
-    const e2 = ze.exec(t3);
-    let i2, s2 = 255;
-    if (!e2)
-        return;
-    e2[5] !== i2 && (s2 = e2[6] ? Pe(+e2[5]) : Re(+e2[5]));
-    const n2 = Ke(+e2[2]),
-        r2 = +e2[3] / 100,
-        o2 = +e2[4] / 100;
-    return i2 = "hwb" === e2[1] ? function(t4, e3, i3) {
-        return We(je, t4, e3, i3);
-    }(n2, r2, o2) : "hsv" === e2[1] ? function(t4, e3, i3) {
-        return We(Ue, t4, e3, i3);
-    }(n2, r2, o2) : qe(n2, r2, o2), {
-        r: i2[0],
-        g: i2[1],
-        b: i2[2],
-        a: s2
-    };
-}
-const Ye = {
-        x: "dark",
-        Z: "light",
-        Y: "re",
-        X: "blu",
-        W: "gr",
-        V: "medium",
-        U: "slate",
-        A: "ee",
-        T: "ol",
-        S: "or",
-        B: "ra",
-        C: "lateg",
-        D: "ights",
-        R: "in",
-        Q: "turquois",
-        E: "hi",
-        P: "ro",
-        O: "al",
-        N: "le",
-        M: "de",
-        L: "yello",
-        F: "en",
-        K: "ch",
-        G: "arks",
-        H: "ea",
-        I: "ightg",
-        J: "wh"
-    },
-    Qe = {
-        OiceXe: "f0f8ff",
-        antiquewEte: "faebd7",
-        aqua: "ffff",
-        aquamarRe: "7fffd4",
-        azuY: "f0ffff",
-        beige: "f5f5dc",
-        bisque: "ffe4c4",
-        black: "0",
-        blanKedOmond: "ffebcd",
-        Xe: "ff",
-        XeviTet: "8a2be2",
-        bPwn: "a52a2a",
-        burlywood: "deb887",
-        caMtXe: "5f9ea0",
-        KartYuse: "7fff00",
-        KocTate: "d2691e",
-        cSO: "ff7f50",
-        cSnflowerXe: "6495ed",
-        cSnsilk: "fff8dc",
-        crimson: "dc143c",
-        cyan: "ffff",
-        xXe: "8b",
-        xcyan: "8b8b",
-        xgTMnPd: "b8860b",
-        xWay: "a9a9a9",
-        xgYF: "6400",
-        xgYy: "a9a9a9",
-        xkhaki: "bdb76b",
-        xmagFta: "8b008b",
-        xTivegYF: "556b2f",
-        xSange: "ff8c00",
-        xScEd: "9932cc",
-        xYd: "8b0000",
-        xsOmon: "e9967a",
-        xsHgYF: "8fbc8f",
-        xUXe: "483d8b",
-        xUWay: "2f4f4f",
-        xUgYy: "2f4f4f",
-        xQe: "ced1",
-        xviTet: "9400d3",
-        dAppRk: "ff1493",
-        dApskyXe: "bfff",
-        dimWay: "696969",
-        dimgYy: "696969",
-        dodgerXe: "1e90ff",
-        fiYbrick: "b22222",
-        flSOwEte: "fffaf0",
-        foYstWAn: "228b22",
-        fuKsia: "ff00ff",
-        gaRsbSo: "dcdcdc",
-        ghostwEte: "f8f8ff",
-        gTd: "ffd700",
-        gTMnPd: "daa520",
-        Way: "808080",
-        gYF: "8000",
-        gYFLw: "adff2f",
-        gYy: "808080",
-        honeyMw: "f0fff0",
-        hotpRk: "ff69b4",
-        RdianYd: "cd5c5c",
-        Rdigo: "4b0082",
-        ivSy: "fffff0",
-        khaki: "f0e68c",
-        lavFMr: "e6e6fa",
-        lavFMrXsh: "fff0f5",
-        lawngYF: "7cfc00",
-        NmoncEffon: "fffacd",
-        ZXe: "add8e6",
-        ZcSO: "f08080",
-        Zcyan: "e0ffff",
-        ZgTMnPdLw: "fafad2",
-        ZWay: "d3d3d3",
-        ZgYF: "90ee90",
-        ZgYy: "d3d3d3",
-        ZpRk: "ffb6c1",
-        ZsOmon: "ffa07a",
-        ZsHgYF: "20b2aa",
-        ZskyXe: "87cefa",
-        ZUWay: "778899",
-        ZUgYy: "778899",
-        ZstAlXe: "b0c4de",
-        ZLw: "ffffe0",
-        lime: "ff00",
-        limegYF: "32cd32",
-        lRF: "faf0e6",
-        magFta: "ff00ff",
-        maPon: "800000",
-        VaquamarRe: "66cdaa",
-        VXe: "cd",
-        VScEd: "ba55d3",
-        VpurpN: "9370db",
-        VsHgYF: "3cb371",
-        VUXe: "7b68ee",
-        VsprRggYF: "fa9a",
-        VQe: "48d1cc",
-        VviTetYd: "c71585",
-        midnightXe: "191970",
-        mRtcYam: "f5fffa",
-        mistyPse: "ffe4e1",
-        moccasR: "ffe4b5",
-        navajowEte: "ffdead",
-        navy: "80",
-        Tdlace: "fdf5e6",
-        Tive: "808000",
-        TivedBb: "6b8e23",
-        Sange: "ffa500",
-        SangeYd: "ff4500",
-        ScEd: "da70d6",
-        pOegTMnPd: "eee8aa",
-        pOegYF: "98fb98",
-        pOeQe: "afeeee",
-        pOeviTetYd: "db7093",
-        papayawEp: "ffefd5",
-        pHKpuff: "ffdab9",
-        peru: "cd853f",
-        pRk: "ffc0cb",
-        plum: "dda0dd",
-        powMrXe: "b0e0e6",
-        purpN: "800080",
-        YbeccapurpN: "663399",
-        Yd: "ff0000",
-        Psybrown: "bc8f8f",
-        PyOXe: "4169e1",
-        saddNbPwn: "8b4513",
-        sOmon: "fa8072",
-        sandybPwn: "f4a460",
-        sHgYF: "2e8b57",
-        sHshell: "fff5ee",
-        siFna: "a0522d",
-        silver: "c0c0c0",
-        skyXe: "87ceeb",
-        UXe: "6a5acd",
-        UWay: "708090",
-        UgYy: "708090",
-        snow: "fffafa",
-        sprRggYF: "ff7f",
-        stAlXe: "4682b4",
-        tan: "d2b48c",
-        teO: "8080",
-        tEstN: "d8bfd8",
-        tomato: "ff6347",
-        Qe: "40e0d0",
-        viTet: "ee82ee",
-        JHt: "f5deb3",
-        wEte: "ffffff",
-        wEtesmoke: "f5f5f5",
-        Lw: "ffff00",
-        LwgYF: "9acd32"
-    };
-let Xe;
-
-function Je(t3) {
-    Xe || (Xe = function() {
-        const t4 = {},
-            e3 = Object.keys(Qe),
-            i2 = Object.keys(Ye);
-        let s2, n2, r2, o2, a2;
-        for (s2 = 0; s2 < e3.length; s2++) {
-            for (o2 = a2 = e3[s2], n2 = 0; n2 < i2.length; n2++)
-                r2 = i2[n2], a2 = a2.replace(r2, Ye[r2]);
-            r2 = parseInt(Qe[o2], 16), t4[a2] = [r2 >> 16 & 255, r2 >> 8 & 255, 255 & r2];
-        }
-        return t4;
-    }(), Xe.transparent = [0, 0, 0, 0]);
-    const e2 = Xe[t3.toLowerCase()];
-    return e2 && {
-        r: e2[0],
-        g: e2[1],
-        b: e2[2],
-        a: 4 === e2.length ? e2[3] : 255
-    };
-}
-const Ze = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
-const ti = (t3) => t3 <= 31308e-7 ? 12.92 * t3 : 1.055 * Math.pow(t3, 1 / 2.4) - 0.055,
-    ei = (t3) => t3 <= 0.04045 ? t3 / 12.92 : Math.pow((t3 + 0.055) / 1.055, 2.4);
-
-function si(t3, e2, i2) {
-    if (t3) {
-        let s2 = He(t3);
-        s2[e2] = Math.max(0, Math.min(s2[e2] + s2[e2] * i2, 0 === e2 ? 360 : 1)), s2 = qe(s2), t3.r = s2[0], t3.g = s2[1], t3.b = s2[2];
-    }
-}
-
-function ni(t3, e2) {
-    return t3 ? Object.assign(e2 || {}, t3) : t3;
-}
-
-function ri(t3) {
-    var e2 = {
-        r: 0,
-        g: 0,
-        b: 0,
-        a: 255
-    };
-    return Array.isArray(t3) ? t3.length >= 3 && (e2 = {
-        r: t3[0],
-        g: t3[1],
-        b: t3[2],
-        a: 255
-    }, t3.length > 3 && (e2.a = Re(t3[3]))) : (e2 = ni(t3, {
-        r: 0,
-        g: 0,
-        b: 0,
-        a: 1
-    })).a = Re(e2.a), e2;
-}
-
-function ai(t3) {
-    return "r" === t3.charAt(0) ? function(t4) {
-        const e2 = Ze.exec(t4);
-        let i2, s2, n2, r2 = 255;
-        if (e2) {
-            if (e2[7] !== i2) {
-                const t5 = +e2[7];
-                r2 = e2[8] ? Pe(t5) : Me(255 * t5, 0, 255);
-            }
-            return i2 = +e2[1], s2 = +e2[3], n2 = +e2[5], i2 = 255 & (e2[2] ? Pe(i2) : Me(i2, 0, 255)), s2 = 255 & (e2[4] ? Pe(s2) : Me(s2, 0, 255)), n2 = 255 & (e2[6] ? Pe(n2) : Me(n2, 0, 255)), {
-                r: i2,
-                g: s2,
-                b: n2,
-                a: r2
-            };
-        }
-    }(t3) : Ge(t3);
-}
-class Color {
-    constructor(t3) {
-        if (t3 instanceof Color)
-            return t3;
-        const e2 = typeof t3;
-        let i2;
-        var s2, n2, r2;
-        "object" === e2 ? i2 = ri(t3) : "string" === e2 && (r2 = (s2 = t3).length, "#" === s2[0] && (4 === r2 || 5 === r2 ? n2 = {
-            r: 255 & 17 * Le[s2[1]],
-            g: 255 & 17 * Le[s2[2]],
-            b: 255 & 17 * Le[s2[3]],
-            a: 5 === r2 ? 17 * Le[s2[4]] : 255
-        } : 7 !== r2 && 9 !== r2 || (n2 = {
-            r: Le[s2[1]] << 4 | Le[s2[2]],
-            g: Le[s2[3]] << 4 | Le[s2[4]],
-            b: Le[s2[5]] << 4 | Le[s2[6]],
-            a: 9 === r2 ? Le[s2[7]] << 4 | Le[s2[8]] : 255
-        })), i2 = n2 || Je(t3) || ai(t3)), this._rgb = i2, this._valid = !!i2;
-    }
-    get valid() {
-        return this._valid;
-    }
-    get rgb() {
-        var t3 = ni(this._rgb);
-        return t3 && (t3.a = Ae(t3.a)), t3;
-    }
-    set rgb(t3) {
-        this._rgb = ri(t3);
-    }
-    rgbString() {
-        return this._valid ? function(t3) {
-            return t3 && (t3.a < 255 ? `rgba(${t3.r}, ${t3.g}, ${t3.b}, ${Ae(t3.a)})` : `rgb(${t3.r}, ${t3.g}, ${t3.b})`);
-        }(this._rgb) : void 0;
-    }
-    hexString() {
-        return this._valid ? Ve(this._rgb) : void 0;
-    }
-    hslString() {
-        return this._valid ? function(t3) {
-            if (!t3)
-                return;
-            const e2 = He(t3),
-                i2 = e2[0],
-                s2 = De(e2[1]),
-                n2 = De(e2[2]);
-            return t3.a < 255 ? `hsla(${i2}, ${s2}%, ${n2}%, ${Ae(t3.a)})` : `hsl(${i2}, ${s2}%, ${n2}%)`;
-        }(this._rgb) : void 0;
-    }
-    mix(t3, e2) {
-        if (t3) {
-            const i2 = this.rgb,
-                s2 = t3.rgb;
-            let n2;
-            const r2 = e2 === n2 ? 0.5 : e2,
-                o2 = 2 * r2 - 1,
-                a2 = i2.a - s2.a,
-                l2 = ((o2 * a2 == -1 ? o2 : (o2 + a2) / (1 + o2 * a2)) + 1) / 2;
-            n2 = 1 - l2, i2.r = 255 & l2 * i2.r + n2 * s2.r + 0.5, i2.g = 255 & l2 * i2.g + n2 * s2.g + 0.5, i2.b = 255 & l2 * i2.b + n2 * s2.b + 0.5, i2.a = r2 * i2.a + (1 - r2) * s2.a, this.rgb = i2;
-        }
-        return this;
-    }
-    interpolate(t3, e2) {
-        return t3 && (this._rgb = function(t4, e3, i2) {
-            const s2 = ei(Ae(t4.r)),
-                n2 = ei(Ae(t4.g)),
-                r2 = ei(Ae(t4.b));
-            return {
-                r: Re(ti(s2 + i2 * (ei(Ae(e3.r)) - s2))),
-                g: Re(ti(n2 + i2 * (ei(Ae(e3.g)) - n2))),
-                b: Re(ti(r2 + i2 * (ei(Ae(e3.b)) - r2))),
-                a: t4.a + i2 * (e3.a - t4.a)
-            };
-        }(this._rgb, t3._rgb, e2)), this;
-    }
-    clone() {
-        return new Color(this.rgb);
-    }
-    alpha(t3) {
-        return this._rgb.a = Re(t3), this;
-    }
-    clearer(t3) {
-        return this._rgb.a *= 1 - t3, this;
-    }
-    greyscale() {
-        const t3 = this._rgb,
-            e2 = Ie(0.3 * t3.r + 0.59 * t3.g + 0.11 * t3.b);
-        return t3.r = t3.g = t3.b = e2, this;
-    }
-    opaquer(t3) {
-        return this._rgb.a *= 1 + t3, this;
-    }
-    negate() {
-        const t3 = this._rgb;
-        return t3.r = 255 - t3.r, t3.g = 255 - t3.g, t3.b = 255 - t3.b, this;
-    }
-    lighten(t3) {
-        return si(this._rgb, 2, t3), this;
-    }
-    darken(t3) {
-        return si(this._rgb, 2, -t3), this;
-    }
-    saturate(t3) {
-        return si(this._rgb, 1, t3), this;
-    }
-    desaturate(t3) {
-        return si(this._rgb, 1, -t3), this;
-    }
-    rotate(t3) {
-        return function(t4, e2) {
-            var i2 = He(t4);
-            i2[0] = Ke(i2[0] + e2), i2 = qe(i2), t4.r = i2[0], t4.g = i2[1], t4.b = i2[2];
-        }(this._rgb, t3), this;
-    }
-}
-
-function li() {}
-const hi = (() => {
-    let t3 = 0;
-    return () => t3++;
-})();
-
-function ci(t3) {
-    return null == t3;
-}
-
-function ui(t3) {
-    if (Array.isArray && Array.isArray(t3))
-        return true;
-    const e2 = Object.prototype.toString.call(t3);
-    return "[object" === e2.slice(0, 7) && "Array]" === e2.slice(-6);
-}
-
-function yi(t3) {
-    return null !== t3 && "[object Object]" === Object.prototype.toString.call(t3);
-}
-
-function _i(t3) {
-    return ("number" == typeof t3 || t3 instanceof Number) && isFinite(+t3);
-}
-
-function ki(t3, e2) {
-    return _i(t3) ? t3 : e2;
-}
-
-function Ti(t3, e2) {
-    return void 0 === t3 ? e2 : t3;
-}
-
-function Si(t3, e2, i2) {
-    if (t3 && "function" == typeof t3.call)
-        return t3.apply(i2, e2);
-}
-
-function Ei(t3, e2, i2, s2) {
-    let n2, r2, o2;
-    if (ui(t3))
-        if (r2 = t3.length, s2)
-            for (n2 = r2 - 1; n2 >= 0; n2--)
-                e2.call(i2, t3[n2], n2);
-        else
-            for (n2 = 0; n2 < r2; n2++)
-                e2.call(i2, t3[n2], n2);
-    else if (yi(t3))
-        for (o2 = Object.keys(t3), r2 = o2.length, n2 = 0; n2 < r2; n2++)
-            e2.call(i2, t3[o2[n2]], o2[n2]);
-}
-
-function Ii(t3, e2) {
-    let i2, s2, n2, r2;
-    if (!t3 || !e2 || t3.length !== e2.length)
-        return false;
-    for (i2 = 0, s2 = t3.length; i2 < s2; ++i2)
-        if (n2 = t3[i2], r2 = e2[i2], n2.datasetIndex !== r2.datasetIndex || n2.index !== r2.index)
-            return false;
-    return true;
-}
-
-function Li(t3) {
-    if (ui(t3))
-        return t3.map(Li);
-    if (yi(t3)) {
-        const e2 = /* @__PURE__ */ Object.create(null),
-            i2 = Object.keys(t3),
-            s2 = i2.length;
-        let n2 = 0;
-        for (; n2 < s2; ++n2)
-            e2[i2[n2]] = Li(t3[i2[n2]]);
-        return e2;
-    }
-    return t3;
-}
-
-function Oi(t3) {
-    return -1 === ["__proto__", "prototype", "constructor"].indexOf(t3);
-}
-
-function Fi(t3, e2, i2, s2) {
-    if (!Oi(t3))
-        return;
-    const n2 = e2[t3],
-        r2 = i2[t3];
-    yi(n2) && yi(r2) ? Ni(n2, r2, s2) : e2[t3] = Li(r2);
-}
-
-function Ni(t3, e2, i2) {
-    const s2 = ui(e2) ? e2 : [e2],
-        n2 = s2.length;
-    if (!yi(t3))
-        return t3;
-    const r2 = (i2 = i2 || {}).merger || Fi;
-    let o2;
-    for (let e3 = 0; e3 < n2; ++e3) {
-        if (o2 = s2[e3], !yi(o2))
-            continue;
-        const n3 = Object.keys(o2);
-        for (let e4 = 0, s3 = n3.length; e4 < s3; ++e4)
-            r2(n3[e4], t3, o2, i2);
-    }
-    return t3;
-}
-
-function Vi(t3, e2) {
-    return Ni(t3, e2, {
-        merger: zi
-    });
-}
-
-function zi(t3, e2, i2) {
-    if (!Oi(t3))
-        return;
-    const s2 = e2[t3],
-        n2 = i2[t3];
-    yi(s2) && yi(n2) ? Vi(s2, n2) : Object.prototype.hasOwnProperty.call(e2, t3) || (e2[t3] = Li(n2));
-}
-const Ui = {
-    "": (t3) => t3,
-    x: (t3) => t3.x,
-    y: (t3) => t3.y
-};
-
-function ji(t3, e2) {
-    const i2 = Ui[e2] || (Ui[e2] = function(t4) {
-        const e3 = function(t5) {
-            const e4 = t5.split("."),
-                i3 = [];
-            let s2 = "";
-            for (const t6 of e4)
-                s2 += t6, s2.endsWith("\\") ? s2 = s2.slice(0, -1) + "." : (i3.push(s2), s2 = "");
-            return i3;
-        }(t4);
-        return (t5) => {
-            for (const i3 of e3) {
-                if ("" === i3)
-                    break;
-                t5 = t5 && t5[i3];
-            }
-            return t5;
-        };
-    }(e2));
-    return i2(t3);
-}
-
-function Wi(t3) {
-    return t3.charAt(0).toUpperCase() + t3.slice(1);
-}
-const qi = (t3) => void 0 !== t3,
-    Gi = (t3) => "function" == typeof t3,
-    Yi = (t3, e2) => {
-        if (t3.size !== e2.size)
-            return false;
-        for (const i2 of t3)
-            if (!e2.has(i2))
-                return false;
-        return true;
-    };
-const Qi = Math.PI,
-    Xi = 2 * Qi,
-    Ji = Xi + Qi,
-    ts = Number.POSITIVE_INFINITY,
-    es = Qi / 180,
-    is = Qi / 2,
-    ss = Qi / 4,
-    ns = 2 * Qi / 3,
-    rs = Math.log10,
-    os = Math.sign;
-
-function as(t3, e2, i2) {
-    return Math.abs(t3 - e2) < i2;
-}
-
-function ls(t3) {
-    const e2 = Math.round(t3);
-    t3 = as(t3, e2, t3 / 1e3) ? e2 : t3;
-    const i2 = Math.pow(10, Math.floor(rs(t3))),
-        s2 = t3 / i2;
-    return (s2 <= 1 ? 1 : s2 <= 2 ? 2 : s2 <= 5 ? 5 : 10) * i2;
-}
-
-function hs(t3) {
-    return !isNaN(parseFloat(t3)) && isFinite(t3);
-}
-
-function cs(t3, e2, i2) {
-    let s2, n2, r2;
-    for (s2 = 0, n2 = t3.length; s2 < n2; s2++)
-        r2 = t3[s2][i2], isNaN(r2) || (e2.min = Math.min(e2.min, r2), e2.max = Math.max(e2.max, r2));
-}
-
-function us(t3) {
-    return t3 * (Qi / 180);
-}
-
-function ds(t3) {
-    return t3 * (180 / Qi);
-}
-
-function fs(t3) {
-    if (!_i(t3))
-        return;
-    let e2 = 1,
-        i2 = 0;
-    for (; Math.round(t3 * e2) / e2 !== t3;)
-        e2 *= 10, i2++;
-    return i2;
-}
-
-function ps(t3, e2) {
-    return Math.sqrt(Math.pow(e2.x - t3.x, 2) + Math.pow(e2.y - t3.y, 2));
-}
-
-function ms(t3, e2) {
-    return (t3 - e2 + Ji) % Xi - Qi;
-}
-
-function gs(t3) {
-    return (t3 % Xi + Xi) % Xi;
-}
-
-function ys(t3, e2, i2, s2) {
-    const n2 = gs(t3),
-        r2 = gs(e2),
-        o2 = gs(i2),
-        a2 = gs(r2 - n2),
-        l2 = gs(o2 - n2),
-        h2 = gs(n2 - r2),
-        c2 = gs(n2 - o2);
-    return n2 === r2 || n2 === o2 || s2 && r2 === o2 || a2 > l2 && h2 < c2;
-}
-
-function vs(t3, e2, i2) {
-    return Math.max(e2, Math.min(i2, t3));
-}
-
-function bs(t3, e2, i2, s2 = 1e-6) {
-    return t3 >= Math.min(e2, i2) - s2 && t3 <= Math.max(e2, i2) + s2;
-}
-
-function _s(t3, e2, i2) {
-    i2 = i2 || ((i3) => t3[i3] < e2);
-    let s2, n2 = t3.length - 1,
-        r2 = 0;
-    for (; n2 - r2 > 1;)
-        s2 = r2 + n2 >> 1, i2(s2) ? r2 = s2 : n2 = s2;
-    return {
-        lo: r2,
-        hi: n2
-    };
-}
-const ws = (t3, e2, i2, s2) => _s(t3, i2, s2 ? (s3) => {
-        const n2 = t3[s3][e2];
-        return n2 < i2 || n2 === i2 && t3[s3 + 1][e2] === i2;
-    } : (s3) => t3[s3][e2] < i2),
-    xs = (t3, e2, i2) => _s(t3, i2, (s2) => t3[s2][e2] >= i2);
-const ks = ["push", "pop", "shift", "splice", "unshift"];
-
-function Ts(t3, e2) {
-    const i2 = t3._chartjs;
-    if (!i2)
-        return;
-    const s2 = i2.listeners,
-        n2 = s2.indexOf(e2); -
-    1 !== n2 && s2.splice(n2, 1), s2.length > 0 || (ks.forEach((e3) => {
-        delete t3[e3];
-    }), delete t3._chartjs);
-}
-
-function Es(t3) {
-    const e2 = new Set(t3);
-    return e2.size === t3.length ? t3 : Array.from(e2);
-}
-const Cs = "undefined" == typeof window ? function(t3) {
-    return t3();
-} : window.requestAnimationFrame;
-
-function Is(t3, e2) {
-    let i2 = [],
-        s2 = false;
-    return function(...n2) {
-        i2 = n2, s2 || (s2 = true, Cs.call(window, () => {
-            s2 = false, t3.apply(e2, i2);
-        }));
-    };
-}
-const Ms = (t3, e2, i2) => "start" === t3 ? e2 : "end" === t3 ? i2 : (e2 + i2) / 2;
-const Ps = (t3) => 0 === t3 || 1 === t3,
-    Rs = (t3, e2, i2) => -Math.pow(2, 10 * (t3 -= 1)) * Math.sin((t3 - e2) * Xi / i2),
-    As = (t3, e2, i2) => Math.pow(2, -10 * t3) * Math.sin((t3 - e2) * Xi / i2) + 1,
-    Ds = {
-        linear: (t3) => t3,
-        easeInQuad: (t3) => t3 * t3,
-        easeOutQuad: (t3) => -t3 * (t3 - 2),
-        easeInOutQuad: (t3) => (t3 /= 0.5) < 1 ? 0.5 * t3 * t3 : -0.5 * (--t3 * (t3 - 2) - 1),
-        easeInCubic: (t3) => t3 * t3 * t3,
-        easeOutCubic: (t3) => (t3 -= 1) * t3 * t3 + 1,
-        easeInOutCubic: (t3) => (t3 /= 0.5) < 1 ? 0.5 * t3 * t3 * t3 : 0.5 * ((t3 -= 2) * t3 * t3 + 2),
-        easeInQuart: (t3) => t3 * t3 * t3 * t3,
-        easeOutQuart: (t3) => -((t3 -= 1) * t3 * t3 * t3 - 1),
-        easeInOutQuart: (t3) => (t3 /= 0.5) < 1 ? 0.5 * t3 * t3 * t3 * t3 : -0.5 * ((t3 -= 2) * t3 * t3 * t3 - 2),
-        easeInQuint: (t3) => t3 * t3 * t3 * t3 * t3,
-        easeOutQuint: (t3) => (t3 -= 1) * t3 * t3 * t3 * t3 + 1,
-        easeInOutQuint: (t3) => (t3 /= 0.5) < 1 ? 0.5 * t3 * t3 * t3 * t3 * t3 : 0.5 * ((t3 -= 2) * t3 * t3 * t3 * t3 + 2),
-        easeInSine: (t3) => 1 - Math.cos(t3 * is),
-        easeOutSine: (t3) => Math.sin(t3 * is),
-        easeInOutSine: (t3) => -0.5 * (Math.cos(Qi * t3) - 1),
-        easeInExpo: (t3) => 0 === t3 ? 0 : Math.pow(2, 10 * (t3 - 1)),
-        easeOutExpo: (t3) => 1 === t3 ? 1 : 1 - Math.pow(2, -10 * t3),
-        easeInOutExpo: (t3) => Ps(t3) ? t3 : t3 < 0.5 ? 0.5 * Math.pow(2, 10 * (2 * t3 - 1)) : 0.5 * (2 - Math.pow(2, -10 * (2 * t3 - 1))),
-        easeInCirc: (t3) => t3 >= 1 ? t3 : -(Math.sqrt(1 - t3 * t3) - 1),
-        easeOutCirc: (t3) => Math.sqrt(1 - (t3 -= 1) * t3),
-        easeInOutCirc: (t3) => (t3 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t3 * t3) - 1) : 0.5 * (Math.sqrt(1 - (t3 -= 2) * t3) + 1),
-        easeInElastic: (t3) => Ps(t3) ? t3 : Rs(t3, 0.075, 0.3),
-        easeOutElastic: (t3) => Ps(t3) ? t3 : As(t3, 0.075, 0.3),
-        easeInOutElastic(t3) {
-            const e2 = 0.1125;
-            return Ps(t3) ? t3 : t3 < 0.5 ? 0.5 * Rs(2 * t3, e2, 0.45) : 0.5 + 0.5 * As(2 * t3 - 1, e2, 0.45);
-        },
-        easeInBack(t3) {
-            const e2 = 1.70158;
-            return t3 * t3 * ((e2 + 1) * t3 - e2);
-        },
-        easeOutBack(t3) {
-            const e2 = 1.70158;
-            return (t3 -= 1) * t3 * ((e2 + 1) * t3 + e2) + 1;
-        },
-        easeInOutBack(t3) {
-            let e2 = 1.70158;
-            return (t3 /= 0.5) < 1 ? t3 * t3 * ((1 + (e2 *= 1.525)) * t3 - e2) * 0.5 : 0.5 * ((t3 -= 2) * t3 * ((1 + (e2 *= 1.525)) * t3 + e2) + 2);
-        },
-        easeInBounce: (t3) => 1 - Ds.easeOutBounce(1 - t3),
-        easeOutBounce(t3) {
-            const e2 = 7.5625,
-                i2 = 2.75;
-            return t3 < 1 / i2 ? e2 * t3 * t3 : t3 < 2 / i2 ? e2 * (t3 -= 1.5 / i2) * t3 + 0.75 : t3 < 2.5 / i2 ? e2 * (t3 -= 2.25 / i2) * t3 + 0.9375 : e2 * (t3 -= 2.625 / i2) * t3 + 0.984375;
-        },
-        easeInOutBounce: (t3) => t3 < 0.5 ? 0.5 * Ds.easeInBounce(2 * t3) : 0.5 * Ds.easeOutBounce(2 * t3 - 1) + 0.5
-    };
-
-function Ls(t3) {
-    if (t3 && "object" == typeof t3) {
-        const e2 = t3.toString();
-        return "[object CanvasPattern]" === e2 || "[object CanvasGradient]" === e2;
-    }
-    return false;
-}
-
-function Os(t3) {
-    return Ls(t3) ? t3 : new Color(t3);
-}
-
-function Fs(t3) {
-    return Ls(t3) ? t3 : new Color(t3).saturate(0.5).darken(0.1).hexString();
-}
-const Vs = ["x", "y", "borderWidth", "radius", "tension"],
-    zs = ["color", "borderColor", "backgroundColor"];
-const Bs = /* @__PURE__ */ new Map();
-
-function Us(t3, e2, i2) {
-    return function(t4, e3) {
-        e3 = e3 || {};
-        const i3 = t4 + JSON.stringify(e3);
-        let s2 = Bs.get(i3);
-        return s2 || (s2 = new Intl.NumberFormat(t4, e3), Bs.set(i3, s2)), s2;
-    }(e2, i2).format(t3);
-}
-const Hs = {
-    values: (t3) => ui(t3) ? t3 : "" + t3,
-    numeric(t3, e2, i2) {
-        if (0 === t3)
-            return "0";
-        const s2 = this.chart.options.locale;
-        let n2, r2 = t3;
-        if (i2.length > 1) {
-            const e3 = Math.max(Math.abs(i2[0].value), Math.abs(i2[i2.length - 1].value));
-            (e3 < 1e-4 || e3 > 1e15) && (n2 = "scientific"), r2 = function(t4, e4) {
-                let i3 = e4.length > 3 ? e4[2].value - e4[1].value : e4[1].value - e4[0].value;
-                Math.abs(i3) >= 1 && t4 !== Math.floor(t4) && (i3 = t4 - Math.floor(t4));
-                return i3;
-            }(t3, i2);
-        }
-        const o2 = rs(Math.abs(r2)),
-            a2 = isNaN(o2) ? 1 : Math.max(Math.min(-1 * Math.floor(o2), 20), 0),
-            l2 = {
-                notation: n2,
-                minimumFractionDigits: a2,
-                maximumFractionDigits: a2
-            };
-        return Object.assign(l2, this.options.ticks.format), Us(t3, s2, l2);
-    },
-    logarithmic(t3, e2, i2) {
-        if (0 === t3)
-            return "0";
-        const s2 = i2[e2].significand || t3 / Math.pow(10, Math.floor(rs(t3)));
-        return [1, 2, 3, 5, 10, 15].includes(s2) || e2 > 0.8 * i2.length ? Hs.numeric.call(this, t3, e2, i2) : "";
-    }
-};
-var Ks = {
-    formatters: Hs
-};
-const Gs = /* @__PURE__ */ Object.create(null),
-    Ys = /* @__PURE__ */ Object.create(null);
-
-function Qs(t3, e2) {
-    if (!e2)
-        return t3;
-    const i2 = e2.split(".");
-    for (let e3 = 0, s2 = i2.length; e3 < s2; ++e3) {
-        const s3 = i2[e3];
-        t3 = t3[s3] || (t3[s3] = /* @__PURE__ */ Object.create(null));
-    }
-    return t3;
-}
-
-function Xs(t3, e2, i2) {
-    return "string" == typeof e2 ? Ni(Qs(t3, e2), i2) : Ni(Qs(t3, ""), e2);
-}
-class Defaults {
-    constructor(t3, e2) {
-        this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (t4) => t4.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"], this.font = {
-            family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
-            size: 12,
-            style: "normal",
-            lineHeight: 1.2,
-            weight: null
-        }, this.hover = {}, this.hoverBackgroundColor = (t4, e3) => Fs(e3.backgroundColor), this.hoverBorderColor = (t4, e3) => Fs(e3.borderColor), this.hoverColor = (t4, e3) => Fs(e3.color), this.indexAxis = "x", this.interaction = {
-            mode: "nearest",
-            intersect: true,
-            includeInvisible: false
-        }, this.maintainAspectRatio = true, this.onHover = null, this.onClick = null, this.parsing = true, this.plugins = {}, this.responsive = true, this.scale = void 0, this.scales = {}, this.showLine = true, this.drawActiveElementsOnTop = true, this.describe(t3), this.apply(e2);
-    }
-    set(t3, e2) {
-        return Xs(this, t3, e2);
-    }
-    get(t3) {
-        return Qs(this, t3);
-    }
-    describe(t3, e2) {
-        return Xs(Ys, t3, e2);
-    }
-    override(t3, e2) {
-        return Xs(Gs, t3, e2);
-    }
-    route(t3, e2, i2, s2) {
-        const n2 = Qs(this, t3),
-            r2 = Qs(this, i2),
-            o2 = "_" + e2;
-        Object.defineProperties(n2, {
-            [o2]: {
-                value: n2[e2],
-                writable: true
-            },
-            [e2]: {
-                enumerable: true,
-                get() {
-                    const t4 = this[o2],
-                        e3 = r2[s2];
-                    return yi(t4) ? Object.assign({}, e3, t4) : Ti(t4, e3);
-                },
-                set(t4) {
-                    this[o2] = t4;
-                }
-            }
-        });
-    }
-    apply(t3) {
-        t3.forEach((t4) => t4(this));
-    }
-}
-var Js = new Defaults({
-    _scriptable: (t3) => !t3.startsWith("on"),
-    _indexable: (t3) => "events" !== t3,
-    hover: {
-        _fallback: "interaction"
-    },
-    interaction: {
-        _scriptable: false,
-        _indexable: false
-    }
-}, [function(t3) {
-    t3.set("animation", {
-        delay: void 0,
-        duration: 1e3,
-        easing: "easeOutQuart",
-        fn: void 0,
-        from: void 0,
-        loop: void 0,
-        to: void 0,
-        type: void 0
-    }), t3.describe("animation", {
-        _fallback: false,
-        _indexable: false,
-        _scriptable: (t4) => "onProgress" !== t4 && "onComplete" !== t4 && "fn" !== t4
-    }), t3.set("animations", {
-        colors: {
-            type: "color",
-            properties: zs
-        },
-        numbers: {
-            type: "number",
-            properties: Vs
-        }
-    }), t3.describe("animations", {
-        _fallback: "animation"
-    }), t3.set("transitions", {
-        active: {
-            animation: {
-                duration: 400
-            }
-        },
-        resize: {
-            animation: {
-                duration: 0
-            }
-        },
-        show: {
-            animations: {
-                colors: {
-                    from: "transparent"
-                },
-                visible: {
-                    type: "boolean",
-                    duration: 0
-                }
-            }
-        },
-        hide: {
-            animations: {
-                colors: {
-                    to: "transparent"
-                },
-                visible: {
-                    type: "boolean",
-                    easing: "linear",
-                    fn: (t4) => 0 | t4
-                }
-            }
-        }
-    });
-}, function(t3) {
-    t3.set("layout", {
-        autoPadding: true,
-        padding: {
-            top: 0,
-            right: 0,
-            bottom: 0,
-            left: 0
-        }
-    });
-}, function(t3) {
-    t3.set("scale", {
-        display: true,
-        offset: false,
-        reverse: false,
-        beginAtZero: false,
-        bounds: "ticks",
-        clip: true,
-        grace: 0,
-        grid: {
-            display: true,
-            lineWidth: 1,
-            drawOnChartArea: true,
-            drawTicks: true,
-            tickLength: 8,
-            tickWidth: (t4, e2) => e2.lineWidth,
-            tickColor: (t4, e2) => e2.color,
-            offset: false
-        },
-        border: {
-            display: true,
-            dash: [],
-            dashOffset: 0,
-            width: 1
-        },
-        title: {
-            display: false,
-            text: "",
-            padding: {
-                top: 4,
-                bottom: 4
-            }
-        },
-        ticks: {
-            minRotation: 0,
-            maxRotation: 50,
-            mirror: false,
-            textStrokeWidth: 0,
-            textStrokeColor: "",
-            padding: 3,
-            display: true,
-            autoSkip: true,
-            autoSkipPadding: 3,
-            labelOffset: 0,
-            callback: Ks.formatters.values,
-            minor: {},
-            major: {},
-            align: "center",
-            crossAlign: "near",
-            showLabelBackdrop: false,
-            backdropColor: "rgba(255, 255, 255, 0.75)",
-            backdropPadding: 2
-        }
-    }), t3.route("scale.ticks", "color", "", "color"), t3.route("scale.grid", "color", "", "borderColor"), t3.route("scale.border", "color", "", "borderColor"), t3.route("scale.title", "color", "", "color"), t3.describe("scale", {
-        _fallback: false,
-        _scriptable: (t4) => !t4.startsWith("before") && !t4.startsWith("after") && "callback" !== t4 && "parser" !== t4,
-        _indexable: (t4) => "borderDash" !== t4 && "tickBorderDash" !== t4 && "dash" !== t4
-    }), t3.describe("scales", {
-        _fallback: "scale"
-    }), t3.describe("scale.ticks", {
-        _scriptable: (t4) => "backdropPadding" !== t4 && "callback" !== t4,
-        _indexable: (t4) => "backdropPadding" !== t4
-    });
-}]);
-
-function Zs(t3, e2, i2, s2, n2) {
-    let r2 = e2[n2];
-    return r2 || (r2 = e2[n2] = t3.measureText(n2).width, i2.push(n2)), r2 > s2 && (s2 = r2), s2;
-}
-
-function tn(t3, e2, i2) {
-    const s2 = t3.currentDevicePixelRatio,
-        n2 = 0 !== i2 ? Math.max(i2 / 2, 0.5) : 0;
-    return Math.round((e2 - n2) * s2) / s2 + n2;
-}
-
-function en(t3, e2) {
-    (e2 = e2 || t3.getContext("2d")).save(), e2.resetTransform(), e2.clearRect(0, 0, t3.width, t3.height), e2.restore();
-}
-
-function sn(t3, e2, i2, s2) {
-    ! function(t4, e3, i3, s3, n2) {
-        let r2, o2, a2, l2, h2, c2, u2, d2;
-        const f2 = e3.pointStyle,
-            p2 = e3.rotation,
-            m2 = e3.radius;
-        let g2 = (p2 || 0) * es;
-        if (f2 && "object" == typeof f2 && (r2 = f2.toString(), "[object HTMLImageElement]" === r2 || "[object HTMLCanvasElement]" === r2))
-            return t4.save(), t4.translate(i3, s3), t4.rotate(g2), t4.drawImage(f2, -f2.width / 2, -f2.height / 2, f2.width, f2.height), void t4.restore();
-        if (isNaN(m2) || m2 <= 0)
-            return;
-        switch (t4.beginPath(), f2) {
-            default:
-                n2 ? t4.ellipse(i3, s3, n2 / 2, m2, 0, 0, Xi) : t4.arc(i3, s3, m2, 0, Xi), t4.closePath();
-                break;
-            case "triangle":
-                c2 = n2 ? n2 / 2 : m2, t4.moveTo(i3 + Math.sin(g2) * c2, s3 - Math.cos(g2) * m2), g2 += ns, t4.lineTo(i3 + Math.sin(g2) * c2, s3 - Math.cos(g2) * m2), g2 += ns, t4.lineTo(i3 + Math.sin(g2) * c2, s3 - Math.cos(g2) * m2), t4.closePath();
-                break;
-            case "rectRounded":
-                h2 = 0.516 * m2, l2 = m2 - h2, o2 = Math.cos(g2 + ss) * l2, u2 = Math.cos(g2 + ss) * (n2 ? n2 / 2 - h2 : l2), a2 = Math.sin(g2 + ss) * l2, d2 = Math.sin(g2 + ss) * (n2 ? n2 / 2 - h2 : l2), t4.arc(i3 - u2, s3 - a2, h2, g2 - Qi, g2 - is), t4.arc(i3 + d2, s3 - o2, h2, g2 - is, g2), t4.arc(i3 + u2, s3 + a2, h2, g2, g2 + is), t4.arc(i3 - d2, s3 + o2, h2, g2 + is, g2 + Qi), t4.closePath();
-                break;
-            case "rect":
-                if (!p2) {
-                    l2 = Math.SQRT1_2 * m2, c2 = n2 ? n2 / 2 : l2, t4.rect(i3 - c2, s3 - l2, 2 * c2, 2 * l2);
-                    break;
-                }
-                g2 += ss;
-            case "rectRot":
-                u2 = Math.cos(g2) * (n2 ? n2 / 2 : m2), o2 = Math.cos(g2) * m2, a2 = Math.sin(g2) * m2, d2 = Math.sin(g2) * (n2 ? n2 / 2 : m2), t4.moveTo(i3 - u2, s3 - a2), t4.lineTo(i3 + d2, s3 - o2), t4.lineTo(i3 + u2, s3 + a2), t4.lineTo(i3 - d2, s3 + o2), t4.closePath();
-                break;
-            case "crossRot":
-                g2 += ss;
-            case "cross":
-                u2 = Math.cos(g2) * (n2 ? n2 / 2 : m2), o2 = Math.cos(g2) * m2, a2 = Math.sin(g2) * m2, d2 = Math.sin(g2) * (n2 ? n2 / 2 : m2), t4.moveTo(i3 - u2, s3 - a2), t4.lineTo(i3 + u2, s3 + a2), t4.moveTo(i3 + d2, s3 - o2), t4.lineTo(i3 - d2, s3 + o2);
-                break;
-            case "star":
-                u2 = Math.cos(g2) * (n2 ? n2 / 2 : m2), o2 = Math.cos(g2) * m2, a2 = Math.sin(g2) * m2, d2 = Math.sin(g2) * (n2 ? n2 / 2 : m2), t4.moveTo(i3 - u2, s3 - a2), t4.lineTo(i3 + u2, s3 + a2), t4.moveTo(i3 + d2, s3 - o2), t4.lineTo(i3 - d2, s3 + o2), g2 += ss, u2 = Math.cos(g2) * (n2 ? n2 / 2 : m2), o2 = Math.cos(g2) * m2, a2 = Math.sin(g2) * m2, d2 = Math.sin(g2) * (n2 ? n2 / 2 : m2), t4.moveTo(i3 - u2, s3 - a2), t4.lineTo(i3 + u2, s3 + a2), t4.moveTo(i3 + d2, s3 - o2), t4.lineTo(i3 - d2, s3 + o2);
-                break;
-            case "line":
-                o2 = n2 ? n2 / 2 : Math.cos(g2) * m2, a2 = Math.sin(g2) * m2, t4.moveTo(i3 - o2, s3 - a2), t4.lineTo(i3 + o2, s3 + a2);
-                break;
-            case "dash":
-                t4.moveTo(i3, s3), t4.lineTo(i3 + Math.cos(g2) * (n2 ? n2 / 2 : m2), s3 + Math.sin(g2) * m2);
-                break;
-            case false:
-                t4.closePath();
-        }
-        t4.fill(), e3.borderWidth > 0 && t4.stroke();
-    }(t3, e2, i2, s2, null);
-}
-
-function nn(t3, e2, i2) {
-    return i2 = i2 || 0.5, !e2 || t3 && t3.x > e2.left - i2 && t3.x < e2.right + i2 && t3.y > e2.top - i2 && t3.y < e2.bottom + i2;
-}
-
-function ln(t3, e2) {
-    t3.save(), t3.beginPath(), t3.rect(e2.left, e2.top, e2.right - e2.left, e2.bottom - e2.top), t3.clip();
-}
-
-function un(t3) {
-    t3.restore();
-}
-
-function fn(t3, e2, i2, s2, n2) {
-    if (!e2)
-        return t3.lineTo(i2.x, i2.y);
-    if ("middle" === n2) {
-        const s3 = (e2.x + i2.x) / 2;
-        t3.lineTo(s3, e2.y), t3.lineTo(s3, i2.y);
-    } else
-        "after" === n2 != !!s2 ? t3.lineTo(e2.x, i2.y) : t3.lineTo(i2.x, e2.y);
-    t3.lineTo(i2.x, i2.y);
-}
-
-function pn(t3, e2, i2, s2) {
-    if (!e2)
-        return t3.lineTo(i2.x, i2.y);
-    t3.bezierCurveTo(s2 ? e2.cp1x : e2.cp2x, s2 ? e2.cp1y : e2.cp2y, s2 ? i2.cp2x : i2.cp1x, s2 ? i2.cp2y : i2.cp1y, i2.x, i2.y);
-}
-
-function mn(t3, e2, i2, s2, n2) {
-    if (n2.strikethrough || n2.underline) {
-        const r2 = t3.measureText(s2),
-            o2 = e2 - r2.actualBoundingBoxLeft,
-            a2 = e2 + r2.actualBoundingBoxRight,
-            l2 = i2 - r2.actualBoundingBoxAscent,
-            h2 = i2 + r2.actualBoundingBoxDescent,
-            c2 = n2.strikethrough ? (l2 + h2) / 2 : h2;
-        t3.strokeStyle = t3.fillStyle, t3.beginPath(), t3.lineWidth = n2.decorationWidth || 2, t3.moveTo(o2, c2), t3.lineTo(a2, c2), t3.stroke();
-    }
-}
-
-function yn(t3, e2) {
-    const i2 = t3.fillStyle;
-    t3.fillStyle = e2.color, t3.fillRect(e2.left, e2.top, e2.width, e2.height), t3.fillStyle = i2;
-}
-
-function vn(t3, e2, i2, s2, n2, r2 = {}) {
-    const o2 = ui(e2) ? e2 : [e2],
-        a2 = r2.strokeWidth > 0 && "" !== r2.strokeColor;
-    let l2, h2;
-    for (t3.save(), t3.font = n2.string, function(t4, e3) {
-            e3.translation && t4.translate(e3.translation[0], e3.translation[1]), ci(e3.rotation) || t4.rotate(e3.rotation), e3.color && (t4.fillStyle = e3.color), e3.textAlign && (t4.textAlign = e3.textAlign), e3.textBaseline && (t4.textBaseline = e3.textBaseline);
-        }(t3, r2), l2 = 0; l2 < o2.length; ++l2)
-        h2 = o2[l2], r2.backdrop && yn(t3, r2.backdrop), a2 && (r2.strokeColor && (t3.strokeStyle = r2.strokeColor), ci(r2.strokeWidth) || (t3.lineWidth = r2.strokeWidth), t3.strokeText(h2, i2, s2, r2.maxWidth)), t3.fillText(h2, i2, s2, r2.maxWidth), mn(t3, i2, s2, h2, r2), s2 += Number(n2.lineHeight);
-    t3.restore();
-}
-
-function bn(t3, e2) {
-    const {
-        x: i2,
-        y: s2,
-        w: n2,
-        h: r2,
-        radius: o2
-    } = e2;
-    t3.arc(i2 + o2.topLeft, s2 + o2.topLeft, o2.topLeft, 1.5 * Qi, Qi, true), t3.lineTo(i2, s2 + r2 - o2.bottomLeft), t3.arc(i2 + o2.bottomLeft, s2 + r2 - o2.bottomLeft, o2.bottomLeft, Qi, is, true), t3.lineTo(i2 + n2 - o2.bottomRight, s2 + r2), t3.arc(i2 + n2 - o2.bottomRight, s2 + r2 - o2.bottomRight, o2.bottomRight, is, 0, true), t3.lineTo(i2 + n2, s2 + o2.topRight), t3.arc(i2 + n2 - o2.topRight, s2 + o2.topRight, o2.topRight, 0, -is, true), t3.lineTo(i2 + o2.topLeft, s2);
-}
-const kn = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/,
-    Tn = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
-
-function En(t3, e2) {
-    const i2 = ("" + t3).match(kn);
-    if (!i2 || "normal" === i2[1])
-        return 1.2 * e2;
-    switch (t3 = +i2[2], i2[3]) {
-        case "px":
-            return t3;
-        case "%":
-            t3 /= 100;
-    }
-    return e2 * t3;
-}
-const Cn = (t3) => +t3 || 0;
-
-function Pn(t3, e2) {
-    const i2 = {},
-        s2 = yi(e2),
-        n2 = s2 ? Object.keys(e2) : e2,
-        r2 = yi(t3) ? s2 ? (i3) => Ti(t3[i3], t3[e2[i3]]) : (e3) => t3[e3] : () => t3;
-    for (const t4 of n2)
-        i2[t4] = Cn(r2(t4));
-    return i2;
-}
-
-function Rn(t3) {
-    return Pn(t3, {
-        top: "y",
-        right: "x",
-        bottom: "y",
-        left: "x"
-    });
-}
-
-function Dn(t3) {
-    return Pn(t3, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
-}
-
-function Ln(t3) {
-    const e2 = Rn(t3);
-    return e2.width = e2.left + e2.right, e2.height = e2.top + e2.bottom, e2;
-}
-
-function On(t3, e2) {
-    t3 = t3 || {}, e2 = e2 || Js.font;
-    let i2 = Ti(t3.size, e2.size);
-    "string" == typeof i2 && (i2 = parseInt(i2, 10));
-    let s2 = Ti(t3.style, e2.style);
-    s2 && !("" + s2).match(Tn) && (console.warn('Invalid font style specified: "' + s2 + '"'), s2 = void 0);
-    const n2 = {
-        family: Ti(t3.family, e2.family),
-        lineHeight: En(Ti(t3.lineHeight, e2.lineHeight), i2),
-        size: i2,
-        style: s2,
-        weight: Ti(t3.weight, e2.weight),
-        string: ""
-    };
-    return n2.string = function(t4) {
-        return !t4 || ci(t4.size) || ci(t4.family) ? null : (t4.style ? t4.style + " " : "") + (t4.weight ? t4.weight + " " : "") + t4.size + "px " + t4.family;
-    }(n2), n2;
-}
-
-function Fn(t3, e2, i2, s2) {
-    let n2, r2, o2, a2 = true;
-    for (n2 = 0, r2 = t3.length; n2 < r2; ++n2)
-        if (o2 = t3[n2], void 0 !== o2 && (void 0 !== e2 && "function" == typeof o2 && (o2 = o2(e2), a2 = false), void 0 !== i2 && ui(o2) && (o2 = o2[i2 % o2.length], a2 = false), void 0 !== o2))
-            return s2 && !a2 && (s2.cacheable = false), o2;
-}
-
-function Nn(t3, e2, i2) {
-    const {
-        min: s2,
-        max: n2
-    } = t3, r2 = (a2 = (n2 - s2) / 2, "string" == typeof(o2 = e2) && o2.endsWith("%") ? parseFloat(o2) / 100 * a2 : +o2);
-    var o2, a2;
-    const l2 = (t4, e3) => i2 && 0 === t4 ? 0 : t4 + e3;
-    return {
-        min: l2(s2, -Math.abs(r2)),
-        max: l2(n2, r2)
-    };
-}
-
-function $n(t3, e2) {
-    return Object.assign(Object.create(t3), e2);
-}
-
-function Vn(t3, e2 = [""], i2, s2, n2 = () => t3[0]) {
-    const r2 = i2 || t3;
-    void 0 === s2 && (s2 = er("_fallback", t3));
-    const o2 = {
-        [Symbol.toStringTag]: "Object",
-        _cacheable: true,
-        _scopes: t3,
-        _rootScopes: r2,
-        _fallback: s2,
-        _getTarget: n2,
-        override: (i3) => Vn([i3, ...t3], e2, r2, s2)
-    };
-    return new Proxy(o2, {
-        deleteProperty: (e3, i3) => (delete e3[i3], delete e3._keys, delete t3[0][i3], true),
-        get: (i3, s3) => Hn(i3, s3, () => function(t4, e3, i4, s4) {
-            let n3;
-            for (const r3 of e3)
-                if (n3 = er(Un(r3, t4), i4), void 0 !== n3)
-                    return jn(t4, n3) ? Zn(i4, s4, t4, n3) : n3;
-        }(s3, e2, t3, i3)),
-        getOwnPropertyDescriptor: (t4, e3) => Reflect.getOwnPropertyDescriptor(t4._scopes[0], e3),
-        getPrototypeOf: () => Reflect.getPrototypeOf(t3[0]),
-        has: (t4, e3) => ir(t4).includes(e3),
-        ownKeys: (t4) => ir(t4),
-        set(t4, e3, i3) {
-            const s3 = t4._storage || (t4._storage = n2());
-            return t4[e3] = s3[e3] = i3, delete t4._keys, true;
-        }
-    });
-}
-
-function zn(t3, e2, i2, s2) {
-    const n2 = {
-        _cacheable: false,
-        _proxy: t3,
-        _context: e2,
-        _subProxy: i2,
-        _stack: /* @__PURE__ */ new Set(),
-        _descriptors: Bn(t3, s2),
-        setContext: (e3) => zn(t3, e3, i2, s2),
-        override: (n3) => zn(t3.override(n3), e2, i2, s2)
-    };
-    return new Proxy(n2, {
-        deleteProperty: (e3, i3) => (delete e3[i3], delete t3[i3], true),
-        get: (t4, e3, i3) => Hn(t4, e3, () => function(t5, e4, i4) {
-            const {
-                _proxy: s3,
-                _context: n3,
-                _subProxy: r2,
-                _descriptors: o2
-            } = t5;
-            let a2 = s3[e4];
-            Gi(a2) && o2.isScriptable(e4) && (a2 = function(t6, e5, i5, s4) {
-                const {
-                    _proxy: n4,
-                    _context: r3,
-                    _subProxy: o3,
-                    _stack: a3
-                } = i5;
-                if (a3.has(t6))
-                    throw new Error("Recursion detected: " + Array.from(a3).join("->") + "->" + t6);
-                a3.add(t6);
-                let l2 = e5(r3, o3 || s4);
-                a3.delete(t6), jn(t6, l2) && (l2 = Zn(n4._scopes, n4, t6, l2));
-                return l2;
-            }(e4, a2, t5, i4));
-            ui(a2) && a2.length && (a2 = function(t6, e5, i5, s4) {
-                const {
-                    _proxy: n4,
-                    _context: r3,
-                    _subProxy: o3,
-                    _descriptors: a3
-                } = i5;
-                if (void 0 !== r3.index && s4(t6))
-                    return e5[r3.index % e5.length];
-                if (yi(e5[0])) {
-                    const i6 = e5,
-                        s5 = n4._scopes.filter((t7) => t7 !== i6);
-                    e5 = [];
-                    for (const l2 of i6) {
-                        const i7 = Zn(s5, n4, t6, l2);
-                        e5.push(zn(i7, r3, o3 && o3[t6], a3));
-                    }
-                }
-                return e5;
-            }(e4, a2, t5, o2.isIndexable));
-            jn(e4, a2) && (a2 = zn(a2, n3, r2 && r2[e4], o2));
-            return a2;
-        }(t4, e3, i3)),
-        getOwnPropertyDescriptor: (e3, i3) => e3._descriptors.allKeys ? Reflect.has(t3, i3) ? {
-            enumerable: true,
-            configurable: true
-        } : void 0 : Reflect.getOwnPropertyDescriptor(t3, i3),
-        getPrototypeOf: () => Reflect.getPrototypeOf(t3),
-        has: (e3, i3) => Reflect.has(t3, i3),
-        ownKeys: () => Reflect.ownKeys(t3),
-        set: (e3, i3, s3) => (t3[i3] = s3, delete e3[i3], true)
-    });
-}
-
-function Bn(t3, e2 = {
-    scriptable: true,
-    indexable: true
-}) {
-    const {
-        _scriptable: i2 = e2.scriptable,
-        _indexable: s2 = e2.indexable,
-        _allKeys: n2 = e2.allKeys
-    } = t3;
-    return {
-        allKeys: n2,
-        scriptable: i2,
-        indexable: s2,
-        isScriptable: Gi(i2) ? i2 : () => i2,
-        isIndexable: Gi(s2) ? s2 : () => s2
-    };
-}
-const Un = (t3, e2) => t3 ? t3 + Wi(e2) : e2,
-    jn = (t3, e2) => yi(e2) && "adapters" !== t3 && (null === Object.getPrototypeOf(e2) || e2.constructor === Object);
-
-function Hn(t3, e2, i2) {
-    if (Object.prototype.hasOwnProperty.call(t3, e2))
-        return t3[e2];
-    const s2 = i2();
-    return t3[e2] = s2, s2;
-}
-
-function qn(t3, e2, i2) {
-    return Gi(t3) ? t3(e2, i2) : t3;
-}
-const Gn = (t3, e2) => true === t3 ? e2 : "string" == typeof t3 ? ji(e2, t3) : void 0;
-
-function Jn(t3, e2, i2, s2, n2) {
-    for (const r2 of e2) {
-        const e3 = Gn(i2, r2);
-        if (e3) {
-            t3.add(e3);
-            const r3 = qn(e3._fallback, i2, n2);
-            if (void 0 !== r3 && r3 !== i2 && r3 !== s2)
-                return r3;
-        } else if (false === e3 && void 0 !== s2 && i2 !== s2)
-            return null;
-    }
-    return false;
-}
-
-function Zn(t3, e2, i2, s2) {
-    const n2 = e2._rootScopes,
-        r2 = qn(e2._fallback, i2, s2),
-        o2 = [...t3, ...n2],
-        a2 = /* @__PURE__ */ new Set();
-    a2.add(s2);
-    let l2 = tr(a2, o2, i2, r2 || i2, s2);
-    return null !== l2 && ((void 0 === r2 || r2 === i2 || (l2 = tr(a2, o2, r2, l2, s2), null !== l2)) && Vn(Array.from(a2), [""], n2, r2, () => function(t4, e3, i3) {
-        const s3 = t4._getTarget();
-        e3 in s3 || (s3[e3] = {});
-        const n3 = s3[e3];
-        if (ui(n3) && yi(i3))
-            return i3;
-        return n3 || {};
-    }(e2, i2, s2)));
-}
-
-function tr(t3, e2, i2, s2, n2) {
-    for (; i2;)
-        i2 = Jn(t3, e2, i2, s2, n2);
-    return i2;
-}
-
-function er(t3, e2) {
-    for (const i2 of e2) {
-        if (!i2)
-            continue;
-        const e3 = i2[t3];
-        if (void 0 !== e3)
-            return e3;
-    }
-}
-
-function ir(t3) {
-    let e2 = t3._keys;
-    return e2 || (e2 = t3._keys = function(t4) {
-        const e3 = /* @__PURE__ */ new Set();
-        for (const i2 of t4)
-            for (const t5 of Object.keys(i2).filter((t6) => !t6.startsWith("_")))
-                e3.add(t5);
-        return Array.from(e3);
-    }(t3._scopes)), e2;
-}
-const sr = Number.EPSILON || 1e-14,
-    nr = (t3, e2) => e2 < t3.length && !t3[e2].skip && t3[e2],
-    rr = (t3) => "x" === t3 ? "y" : "x";
-
-function or(t3, e2, i2, s2) {
-    const n2 = t3.skip ? e2 : t3,
-        r2 = e2,
-        o2 = i2.skip ? e2 : i2,
-        a2 = ps(r2, n2),
-        l2 = ps(o2, r2);
-    let h2 = a2 / (a2 + l2),
-        c2 = l2 / (a2 + l2);
-    h2 = isNaN(h2) ? 0 : h2, c2 = isNaN(c2) ? 0 : c2;
-    const u2 = s2 * h2,
-        d2 = s2 * c2;
-    return {
-        previous: {
-            x: r2.x - u2 * (o2.x - n2.x),
-            y: r2.y - u2 * (o2.y - n2.y)
-        },
-        next: {
-            x: r2.x + d2 * (o2.x - n2.x),
-            y: r2.y + d2 * (o2.y - n2.y)
-        }
-    };
-}
-
-function ar(t3, e2 = "x") {
-    const i2 = rr(e2),
-        s2 = t3.length,
-        n2 = Array(s2).fill(0),
-        r2 = Array(s2);
-    let o2, a2, l2, h2 = nr(t3, 0);
-    for (o2 = 0; o2 < s2; ++o2)
-        if (a2 = l2, l2 = h2, h2 = nr(t3, o2 + 1), l2) {
-            if (h2) {
-                const t4 = h2[e2] - l2[e2];
-                n2[o2] = 0 !== t4 ? (h2[i2] - l2[i2]) / t4 : 0;
-            }
-            r2[o2] = a2 ? h2 ? os(n2[o2 - 1]) !== os(n2[o2]) ? 0 : (n2[o2 - 1] + n2[o2]) / 2 : n2[o2 - 1] : n2[o2];
-        }!
-    function(t4, e3, i3) {
-        const s3 = t4.length;
-        let n3, r3, o3, a3, l3, h3 = nr(t4, 0);
-        for (let c2 = 0; c2 < s3 - 1; ++c2)
-            l3 = h3, h3 = nr(t4, c2 + 1), l3 && h3 && (as(e3[c2], 0, sr) ? i3[c2] = i3[c2 + 1] = 0 : (n3 = i3[c2] / e3[c2], r3 = i3[c2 + 1] / e3[c2], a3 = Math.pow(n3, 2) + Math.pow(r3, 2), a3 <= 9 || (o3 = 3 / Math.sqrt(a3), i3[c2] = n3 * o3 * e3[c2], i3[c2 + 1] = r3 * o3 * e3[c2])));
-    }(t3, n2, r2),
-    function(t4, e3, i3 = "x") {
-        const s3 = rr(i3),
-            n3 = t4.length;
-        let r3, o3, a3, l3 = nr(t4, 0);
-        for (let h3 = 0; h3 < n3; ++h3) {
-            if (o3 = a3, a3 = l3, l3 = nr(t4, h3 + 1), !a3)
-                continue;
-            const n4 = a3[i3],
-                c2 = a3[s3];
-            o3 && (r3 = (n4 - o3[i3]) / 3, a3[`cp1${i3}`] = n4 - r3, a3[`cp1${s3}`] = c2 - r3 * e3[h3]), l3 && (r3 = (l3[i3] - n4) / 3, a3[`cp2${i3}`] = n4 + r3, a3[`cp2${s3}`] = c2 + r3 * e3[h3]);
-        }
-    }(t3, r2, e2);
-}
-
-function lr(t3, e2, i2) {
-    return Math.max(Math.min(t3, i2), e2);
-}
-
-function hr(t3, e2, i2, s2, n2) {
-    let r2, o2, a2, l2;
-    if (e2.spanGaps && (t3 = t3.filter((t4) => !t4.skip)), "monotone" === e2.cubicInterpolationMode)
-        ar(t3, n2);
-    else {
-        let i3 = s2 ? t3[t3.length - 1] : t3[0];
-        for (r2 = 0, o2 = t3.length; r2 < o2; ++r2)
-            a2 = t3[r2], l2 = or(i3, a2, t3[Math.min(r2 + 1, o2 - (s2 ? 0 : 1)) % o2], e2.tension), a2.cp1x = l2.previous.x, a2.cp1y = l2.previous.y, a2.cp2x = l2.next.x, a2.cp2y = l2.next.y, i3 = a2;
-    }
-    e2.capBezierPoints && function(t4, e3) {
-        let i3, s3, n3, r3, o3, a3 = nn(t4[0], e3);
-        for (i3 = 0, s3 = t4.length; i3 < s3; ++i3)
-            o3 = r3, r3 = a3, a3 = i3 < s3 - 1 && nn(t4[i3 + 1], e3), r3 && (n3 = t4[i3], o3 && (n3.cp1x = lr(n3.cp1x, e3.left, e3.right), n3.cp1y = lr(n3.cp1y, e3.top, e3.bottom)), a3 && (n3.cp2x = lr(n3.cp2x, e3.left, e3.right), n3.cp2y = lr(n3.cp2y, e3.top, e3.bottom)));
-    }(t3, i2);
-}
-
-function cr() {
-    return "undefined" != typeof window && "undefined" != typeof document;
-}
-
-function ur(t3) {
-    let e2 = t3.parentNode;
-    return e2 && "[object ShadowRoot]" === e2.toString() && (e2 = e2.host), e2;
-}
-
-function dr(t3, e2, i2) {
-    let s2;
-    return "string" == typeof t3 ? (s2 = parseInt(t3, 10), -1 !== t3.indexOf("%") && (s2 = s2 / 100 * e2.parentNode[i2])) : s2 = t3, s2;
-}
-const fr = (t3) => t3.ownerDocument.defaultView.getComputedStyle(t3, null);
-const pr = ["top", "right", "bottom", "left"];
-
-function mr(t3, e2, i2) {
-    const s2 = {};
-    i2 = i2 ? "-" + i2 : "";
-    for (let n2 = 0; n2 < 4; n2++) {
-        const r2 = pr[n2];
-        s2[r2] = parseFloat(t3[e2 + "-" + r2 + i2]) || 0;
-    }
-    return s2.width = s2.left + s2.right, s2.height = s2.top + s2.bottom, s2;
-}
-const gr = (t3, e2, i2) => (t3 > 0 || e2 > 0) && (!i2 || !i2.shadowRoot);
-
-function yr(t3, e2) {
-    if ("native" in t3)
-        return t3;
-    const {
-        canvas: i2,
-        currentDevicePixelRatio: s2
-    } = e2, n2 = fr(i2), r2 = "border-box" === n2.boxSizing, o2 = mr(n2, "padding"), a2 = mr(n2, "border", "width"), {
-        x: l2,
-        y: h2,
-        box: c2
-    } = function(t4, e3) {
-        const i3 = t4.touches,
-            s3 = i3 && i3.length ? i3[0] : t4,
-            {
-                offsetX: n3,
-                offsetY: r3
-            } = s3;
-        let o3, a3, l3 = false;
-        if (gr(n3, r3, t4.target))
-            o3 = n3, a3 = r3;
-        else {
-            const t5 = e3.getBoundingClientRect();
-            o3 = s3.clientX - t5.left, a3 = s3.clientY - t5.top, l3 = true;
-        }
-        return {
-            x: o3,
-            y: a3,
-            box: l3
-        };
-    }(t3, i2), u2 = o2.left + (c2 && a2.left), d2 = o2.top + (c2 && a2.top);
-    let {
-        width: f2,
-        height: p2
-    } = e2;
-    return r2 && (f2 -= o2.width + a2.width, p2 -= o2.height + a2.height), {
-        x: Math.round((l2 - u2) / f2 * i2.width / s2),
-        y: Math.round((h2 - d2) / p2 * i2.height / s2)
-    };
-}
-const vr = (t3) => Math.round(10 * t3) / 10;
-
-function br(t3, e2, i2, s2) {
-    const n2 = fr(t3),
-        r2 = mr(n2, "margin"),
-        o2 = dr(n2.maxWidth, t3, "clientWidth") || ts,
-        a2 = dr(n2.maxHeight, t3, "clientHeight") || ts,
-        l2 = function(t4, e3, i3) {
-            let s3, n3;
-            if (void 0 === e3 || void 0 === i3) {
-                const r3 = ur(t4);
-                if (r3) {
-                    const t5 = r3.getBoundingClientRect(),
-                        o3 = fr(r3),
-                        a3 = mr(o3, "border", "width"),
-                        l3 = mr(o3, "padding");
-                    e3 = t5.width - l3.width - a3.width, i3 = t5.height - l3.height - a3.height, s3 = dr(o3.maxWidth, r3, "clientWidth"), n3 = dr(o3.maxHeight, r3, "clientHeight");
-                } else
-                    e3 = t4.clientWidth, i3 = t4.clientHeight;
-            }
-            return {
-                width: e3,
-                height: i3,
-                maxWidth: s3 || ts,
-                maxHeight: n3 || ts
-            };
-        }(t3, e2, i2);
-    let {
-        width: h2,
-        height: c2
-    } = l2;
-    if ("content-box" === n2.boxSizing) {
-        const t4 = mr(n2, "border", "width"),
-            e3 = mr(n2, "padding");
-        h2 -= e3.width + t4.width, c2 -= e3.height + t4.height;
-    }
-    h2 = Math.max(0, h2 - r2.width), c2 = Math.max(0, s2 ? h2 / s2 : c2 - r2.height), h2 = vr(Math.min(h2, o2, l2.maxWidth)), c2 = vr(Math.min(c2, a2, l2.maxHeight)), h2 && !c2 && (c2 = vr(h2 / 2));
-    return (void 0 !== e2 || void 0 !== i2) && s2 && l2.height && c2 > l2.height && (c2 = l2.height, h2 = vr(Math.floor(c2 * s2))), {
-        width: h2,
-        height: c2
-    };
-}
-
-function _r(t3, e2, i2) {
-    const s2 = e2 || 1,
-        n2 = Math.floor(t3.height * s2),
-        r2 = Math.floor(t3.width * s2);
-    t3.height = Math.floor(t3.height), t3.width = Math.floor(t3.width);
-    const o2 = t3.canvas;
-    return o2.style && (i2 || !o2.style.height && !o2.style.width) && (o2.style.height = `${t3.height}px`, o2.style.width = `${t3.width}px`), (t3.currentDevicePixelRatio !== s2 || o2.height !== n2 || o2.width !== r2) && (t3.currentDevicePixelRatio = s2, o2.height = n2, o2.width = r2, t3.ctx.setTransform(s2, 0, 0, s2, 0, 0), true);
-}
-const wr = function() {
-    let t3 = false;
-    try {
-        const e2 = {
-            get passive() {
-                return t3 = true, false;
-            }
-        };
-        window.addEventListener("test", null, e2), window.removeEventListener("test", null, e2);
-    } catch (t4) {}
-    return t3;
-}();
-
-function xr(t3, e2) {
-    const i2 = function(t4, e3) {
-            return fr(t4).getPropertyValue(e3);
-        }(t3, e2),
-        s2 = i2 && i2.match(/^(\d+)(\.\d+)?px$/);
-    return s2 ? +s2[1] : void 0;
-}
-
-function kr(t3, e2, i2, s2) {
-    return {
-        x: t3.x + i2 * (e2.x - t3.x),
-        y: t3.y + i2 * (e2.y - t3.y)
-    };
-}
-
-function Tr(t3, e2, i2, s2) {
-    return {
-        x: t3.x + i2 * (e2.x - t3.x),
-        y: "middle" === s2 ? i2 < 0.5 ? t3.y : e2.y : "after" === s2 ? i2 < 1 ? t3.y : e2.y : i2 > 0 ? e2.y : t3.y
-    };
-}
-
-function Sr(t3, e2, i2, s2) {
-    const n2 = {
-            x: t3.cp2x,
-            y: t3.cp2y
-        },
-        r2 = {
-            x: e2.cp1x,
-            y: e2.cp1y
-        },
-        o2 = kr(t3, n2, i2),
-        a2 = kr(n2, r2, i2),
-        l2 = kr(r2, e2, i2),
-        h2 = kr(o2, a2, i2),
-        c2 = kr(a2, l2, i2);
-    return kr(h2, c2, i2);
-}
-
-function Er(t3, e2, i2) {
-    return t3 ? function(t4, e3) {
-        return {
-            x: (i3) => t4 + t4 + e3 - i3,
-            setWidth(t5) {
-                e3 = t5;
-            },
-            textAlign: (t5) => "center" === t5 ? t5 : "right" === t5 ? "left" : "right",
-            xPlus: (t5, e4) => t5 - e4,
-            leftForLtr: (t5, e4) => t5 - e4
-        };
-    }(e2, i2) : {
-        x: (t4) => t4,
-        setWidth(t4) {},
-        textAlign: (t4) => t4,
-        xPlus: (t4, e3) => t4 + e3,
-        leftForLtr: (t4, e3) => t4
-    };
-}
-
-function Cr(t3) {
-    return "angle" === t3 ? {
-        between: ys,
-        compare: ms,
-        normalize: gs
-    } : {
-        between: bs,
-        compare: (t4, e2) => t4 - e2,
-        normalize: (t4) => t4
-    };
-}
-
-function Ir({
-    start: t3,
-    end: e2,
-    count: i2,
-    loop: s2,
-    style: n2
-}) {
-    return {
-        start: t3 % i2,
-        end: e2 % i2,
-        loop: s2 && (e2 - t3 + 1) % i2 == 0,
-        style: n2
-    };
-}
-
-function Mr(t3, e2, i2) {
-    if (!i2)
-        return [t3];
-    const {
-        property: s2,
-        start: n2,
-        end: r2
-    } = i2, o2 = e2.length, {
-        compare: a2,
-        between: l2,
-        normalize: h2
-    } = Cr(s2), {
-        start: c2,
-        end: u2,
-        loop: d2,
-        style: f2
-    } = function(t4, e3, i3) {
-        const {
-            property: s3,
-            start: n3,
-            end: r3
-        } = i3, {
-            between: o3,
-            normalize: a3
-        } = Cr(s3), l3 = e3.length;
-        let h3, c3, {
-            start: u3,
-            end: d3,
-            loop: f3
-        } = t4;
-        if (f3) {
-            for (u3 += l3, d3 += l3, h3 = 0, c3 = l3; h3 < c3 && o3(a3(e3[u3 % l3][s3]), n3, r3); ++h3)
-                u3--, d3--;
-            u3 %= l3, d3 %= l3;
-        }
-        return d3 < u3 && (d3 += l3), {
-            start: u3,
-            end: d3,
-            loop: f3,
-            style: t4.style
-        };
-    }(t3, e2, i2), p2 = [];
-    let m2, g2, y2, v2 = false,
-        b2 = null;
-    const _2 = () => v2 || l2(n2, y2, m2) && 0 !== a2(n2, y2),
-        w2 = () => !v2 || 0 === a2(r2, m2) || l2(r2, y2, m2);
-    for (let t4 = c2, i3 = c2; t4 <= u2; ++t4)
-        g2 = e2[t4 % o2], g2.skip || (m2 = h2(g2[s2]), m2 !== y2 && (v2 = l2(m2, n2, r2), null === b2 && _2() && (b2 = 0 === a2(m2, n2) ? t4 : i3), null !== b2 && w2() && (p2.push(Ir({
-            start: b2,
-            end: t4,
-            loop: d2,
-            count: o2,
-            style: f2
-        })), b2 = null), i3 = t4, y2 = m2));
-    return null !== b2 && p2.push(Ir({
-        start: b2,
-        end: u2,
-        loop: d2,
-        count: o2,
-        style: f2
-    })), p2;
-}
-
-function Pr(t3, e2, i2, s2) {
-    return s2 && s2.setContext && i2 ? function(t4, e3, i3, s3) {
-        const n2 = t4._chart.getContext(),
-            r2 = Rr(t4.options),
-            {
-                _datasetIndex: o2,
-                options: {
-                    spanGaps: a2
-                }
-            } = t4,
-            l2 = i3.length,
-            h2 = [];
-        let c2 = r2,
-            u2 = e3[0].start,
-            d2 = u2;
-
-        function f2(t5, e4, s4, n3) {
-            const r3 = a2 ? -1 : 1;
-            if (t5 !== e4) {
-                for (t5 += l2; i3[t5 % l2].skip;)
-                    t5 -= r3;
-                for (; i3[e4 % l2].skip;)
-                    e4 += r3;
-                t5 % l2 != e4 % l2 && (h2.push({
-                    start: t5 % l2,
-                    end: e4 % l2,
-                    loop: s4,
-                    style: n3
-                }), c2 = n3, u2 = e4 % l2);
-            }
-        }
-        for (const t5 of e3) {
-            u2 = a2 ? u2 : t5.start;
-            let e4, r3 = i3[u2 % l2];
-            for (d2 = u2 + 1; d2 <= t5.end; d2++) {
-                const a3 = i3[d2 % l2];
-                e4 = Rr(s3.setContext($n(n2, {
-                    type: "segment",
-                    p0: r3,
-                    p1: a3,
-                    p0DataIndex: (d2 - 1) % l2,
-                    p1DataIndex: d2 % l2,
-                    datasetIndex: o2
-                }))), Ar(e4, c2) && f2(u2, d2 - 1, t5.loop, c2), r3 = a3, c2 = e4;
-            }
-            u2 < d2 - 1 && f2(u2, d2 - 1, t5.loop, c2);
-        }
-        return h2;
-    }(t3, e2, i2, s2) : e2;
-}
-
-function Rr(t3) {
-    return {
-        backgroundColor: t3.backgroundColor,
-        borderCapStyle: t3.borderCapStyle,
-        borderDash: t3.borderDash,
-        borderDashOffset: t3.borderDashOffset,
-        borderJoinStyle: t3.borderJoinStyle,
-        borderWidth: t3.borderWidth,
-        borderColor: t3.borderColor
-    };
-}
-
-function Ar(t3, e2) {
-    if (!e2)
-        return false;
-    const i2 = [],
-        s2 = function(t4, e3) {
-            return Ls(e3) ? (i2.includes(e3) || i2.push(e3), i2.indexOf(e3)) : e3;
-        };
-    return JSON.stringify(t3, s2) !== JSON.stringify(e2, s2);
-}
-class Animator {
-    constructor() {
-        this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = false, this._lastDate = void 0;
-    }
-    _notify(t3, e2, i2, s2) {
-        const n2 = e2.listeners[s2],
-            r2 = e2.duration;
-        n2.forEach((s3) => s3({
-            chart: t3,
-            initial: e2.initial,
-            numSteps: r2,
-            currentStep: Math.min(i2 - e2.start, r2)
-        }));
-    }
-    _refresh() {
-        this._request || (this._running = true, this._request = Cs.call(window, () => {
-            this._update(), this._request = null, this._running && this._refresh();
-        }));
-    }
-    _update(t3 = Date.now()) {
-        let e2 = 0;
-        this._charts.forEach((i2, s2) => {
-            if (!i2.running || !i2.items.length)
-                return;
-            const n2 = i2.items;
-            let r2, o2 = n2.length - 1,
-                a2 = false;
-            for (; o2 >= 0; --o2)
-                r2 = n2[o2], r2._active ? (r2._total > i2.duration && (i2.duration = r2._total), r2.tick(t3), a2 = true) : (n2[o2] = n2[n2.length - 1], n2.pop());
-            a2 && (s2.draw(), this._notify(s2, i2, t3, "progress")), n2.length || (i2.running = false, this._notify(s2, i2, t3, "complete"), i2.initial = false), e2 += n2.length;
-        }), this._lastDate = t3, 0 === e2 && (this._running = false);
-    }
-    _getAnims(t3) {
-        const e2 = this._charts;
-        let i2 = e2.get(t3);
-        return i2 || (i2 = {
-            running: false,
-            initial: true,
-            items: [],
-            listeners: {
-                complete: [],
-                progress: []
-            }
-        }, e2.set(t3, i2)), i2;
-    }
-    listen(t3, e2, i2) {
-        this._getAnims(t3).listeners[e2].push(i2);
-    }
-    add(t3, e2) {
-        e2 && e2.length && this._getAnims(t3).items.push(...e2);
-    }
-    has(t3) {
-        return this._getAnims(t3).items.length > 0;
-    }
-    start(t3) {
-        const e2 = this._charts.get(t3);
-        e2 && (e2.running = true, e2.start = Date.now(), e2.duration = e2.items.reduce((t4, e3) => Math.max(t4, e3._duration), 0), this._refresh());
-    }
-    running(t3) {
-        if (!this._running)
-            return false;
-        const e2 = this._charts.get(t3);
-        return !!(e2 && e2.running && e2.items.length);
-    }
-    stop(t3) {
-        const e2 = this._charts.get(t3);
-        if (!e2 || !e2.items.length)
-            return;
-        const i2 = e2.items;
-        let s2 = i2.length - 1;
-        for (; s2 >= 0; --s2)
-            i2[s2].cancel();
-        e2.items = [], this._notify(t3, e2, Date.now(), "complete");
-    }
-    remove(t3) {
-        return this._charts.delete(t3);
-    }
-}
-var Dr = new Animator();
-const Lr = "transparent",
-    Or = {
-        boolean: (t3, e2, i2) => i2 > 0.5 ? e2 : t3,
-        color(t3, e2, i2) {
-            const s2 = Os(t3 || Lr),
-                n2 = s2.valid && Os(e2 || Lr);
-            return n2 && n2.valid ? n2.mix(s2, i2).hexString() : e2;
-        },
-        number: (t3, e2, i2) => t3 + (e2 - t3) * i2
-    };
-class Animation {
-    constructor(t3, e2, i2, s2) {
-        const n2 = e2[i2];
-        s2 = Fn([t3.to, s2, n2, t3.from]);
-        const r2 = Fn([t3.from, n2, s2]);
-        this._active = true, this._fn = t3.fn || Or[t3.type || typeof r2], this._easing = Ds[t3.easing] || Ds.linear, this._start = Math.floor(Date.now() + (t3.delay || 0)), this._duration = this._total = Math.floor(t3.duration), this._loop = !!t3.loop, this._target = e2, this._prop = i2, this._from = r2, this._to = s2, this._promises = void 0;
-    }
-    active() {
-        return this._active;
-    }
-    update(t3, e2, i2) {
-        if (this._active) {
-            this._notify(false);
-            const s2 = this._target[this._prop],
-                n2 = i2 - this._start,
-                r2 = this._duration - n2;
-            this._start = i2, this._duration = Math.floor(Math.max(r2, t3.duration)), this._total += n2, this._loop = !!t3.loop, this._to = Fn([t3.to, e2, s2, t3.from]), this._from = Fn([t3.from, s2, e2]);
-        }
-    }
-    cancel() {
-        this._active && (this.tick(Date.now()), this._active = false, this._notify(false));
-    }
-    tick(t3) {
-        const e2 = t3 - this._start,
-            i2 = this._duration,
-            s2 = this._prop,
-            n2 = this._from,
-            r2 = this._loop,
-            o2 = this._to;
-        let a2;
-        if (this._active = n2 !== o2 && (r2 || e2 < i2), !this._active)
-            return this._target[s2] = o2, void this._notify(true);
-        e2 < 0 ? this._target[s2] = n2 : (a2 = e2 / i2 % 2, a2 = r2 && a2 > 1 ? 2 - a2 : a2, a2 = this._easing(Math.min(1, Math.max(0, a2))), this._target[s2] = this._fn(n2, o2, a2));
-    }
-    wait() {
-        const t3 = this._promises || (this._promises = []);
-        return new Promise((e2, i2) => {
-            t3.push({
-                res: e2,
-                rej: i2
-            });
-        });
-    }
-    _notify(t3) {
-        const e2 = t3 ? "res" : "rej",
-            i2 = this._promises || [];
-        for (let t4 = 0; t4 < i2.length; t4++)
-            i2[t4][e2]();
-    }
-}
-class Animations {
-    constructor(t3, e2) {
-        this._chart = t3, this._properties = /* @__PURE__ */ new Map(), this.configure(e2);
-    }
-    configure(t3) {
-        if (!yi(t3))
-            return;
-        const e2 = Object.keys(Js.animation),
-            i2 = this._properties;
-        Object.getOwnPropertyNames(t3).forEach((s2) => {
-            const n2 = t3[s2];
-            if (!yi(n2))
-                return;
-            const r2 = {};
-            for (const t4 of e2)
-                r2[t4] = n2[t4];
-            (ui(n2.properties) && n2.properties || [s2]).forEach((t4) => {
-                t4 !== s2 && i2.has(t4) || i2.set(t4, r2);
-            });
-        });
-    }
-    _animateOptions(t3, e2) {
-        const i2 = e2.options,
-            s2 = function(t4, e3) {
-                if (!e3)
-                    return;
-                let i3 = t4.options;
-                if (!i3)
-                    return void(t4.options = e3);
-                i3.$shared && (t4.options = i3 = Object.assign({}, i3, {
-                    $shared: false,
-                    $animations: {}
-                }));
-                return i3;
-            }(t3, i2);
-        if (!s2)
-            return [];
-        const n2 = this._createAnimations(s2, i2);
-        return i2.$shared && function(t4, e3) {
-            const i3 = [],
-                s3 = Object.keys(e3);
-            for (let e4 = 0; e4 < s3.length; e4++) {
-                const n3 = t4[s3[e4]];
-                n3 && n3.active() && i3.push(n3.wait());
-            }
-            return Promise.all(i3);
-        }(t3.options.$animations, i2).then(() => {
-            t3.options = i2;
-        }, () => {}), n2;
-    }
-    _createAnimations(t3, e2) {
-        const i2 = this._properties,
-            s2 = [],
-            n2 = t3.$animations || (t3.$animations = {}),
-            r2 = Object.keys(e2),
-            o2 = Date.now();
-        let a2;
-        for (a2 = r2.length - 1; a2 >= 0; --a2) {
-            const l2 = r2[a2];
-            if ("$" === l2.charAt(0))
-                continue;
-            if ("options" === l2) {
-                s2.push(...this._animateOptions(t3, e2));
-                continue;
-            }
-            const h2 = e2[l2];
-            let c2 = n2[l2];
-            const u2 = i2.get(l2);
-            if (c2) {
-                if (u2 && c2.active()) {
-                    c2.update(u2, h2, o2);
-                    continue;
-                }
-                c2.cancel();
-            }
-            u2 && u2.duration ? (n2[l2] = c2 = new Animation(u2, t3, l2, h2), s2.push(c2)) : t3[l2] = h2;
-        }
-        return s2;
-    }
-    update(t3, e2) {
-        if (0 === this._properties.size)
-            return void Object.assign(t3, e2);
-        const i2 = this._createAnimations(t3, e2);
-        return i2.length ? (Dr.add(this._chart, i2), true) : void 0;
-    }
-}
-
-function Fr(t3, e2) {
-    const i2 = t3 && t3.options || {},
-        s2 = i2.reverse,
-        n2 = void 0 === i2.min ? e2 : 0,
-        r2 = void 0 === i2.max ? e2 : 0;
-    return {
-        start: s2 ? r2 : n2,
-        end: s2 ? n2 : r2
-    };
-}
-
-function Nr(t3, e2) {
-    const i2 = [],
-        s2 = t3._getSortedDatasetMetas(e2);
-    let n2, r2;
-    for (n2 = 0, r2 = s2.length; n2 < r2; ++n2)
-        i2.push(s2[n2].index);
-    return i2;
-}
-
-function $r(t3, e2, i2, s2 = {}) {
-    const n2 = t3.keys,
-        r2 = "single" === s2.mode;
-    let o2, a2, l2, h2;
-    if (null !== e2) {
-        for (o2 = 0, a2 = n2.length; o2 < a2; ++o2) {
-            if (l2 = +n2[o2], l2 === i2) {
-                if (s2.all)
-                    continue;
-                break;
-            }
-            h2 = t3.values[l2], _i(h2) && (r2 || 0 === e2 || os(e2) === os(h2)) && (e2 += h2);
-        }
-        return e2;
-    }
-}
-
-function Vr(t3, e2) {
-    const i2 = t3 && t3.options.stacked;
-    return i2 || void 0 === i2 && void 0 !== e2.stack;
-}
-
-function zr(t3, e2, i2) {
-    const s2 = t3[e2] || (t3[e2] = {});
-    return s2[i2] || (s2[i2] = {});
-}
-
-function Br(t3, e2, i2, s2) {
-    for (const n2 of e2.getMatchingVisibleMetas(s2).reverse()) {
-        const e3 = t3[n2.index];
-        if (i2 && e3 > 0 || !i2 && e3 < 0)
-            return n2.index;
-    }
-    return null;
-}
-
-function Ur(t3, e2) {
-    const {
-        chart: i2,
-        _cachedMeta: s2
-    } = t3, n2 = i2._stacks || (i2._stacks = {}), {
-        iScale: r2,
-        vScale: o2,
-        index: a2
-    } = s2, l2 = r2.axis, h2 = o2.axis, c2 = function(t4, e3, i3) {
-        return `${t4.id}.${e3.id}.${i3.stack || i3.type}`;
-    }(r2, o2, s2), u2 = e2.length;
-    let d2;
-    for (let t4 = 0; t4 < u2; ++t4) {
-        const i3 = e2[t4],
-            {
-                [l2]: r3,
-                [h2]: u3
-            } = i3;
-        d2 = (i3._stacks || (i3._stacks = {}))[h2] = zr(n2, c2, r3), d2[a2] = u3, d2._top = Br(d2, o2, true, s2.type), d2._bottom = Br(d2, o2, false, s2.type);
-        (d2._visualValues || (d2._visualValues = {}))[a2] = u3;
-    }
-}
-
-function jr(t3, e2) {
-    const i2 = t3.scales;
-    return Object.keys(i2).filter((t4) => i2[t4].axis === e2).shift();
-}
-
-function Hr(t3, e2) {
-    const i2 = t3.controller.index,
-        s2 = t3.vScale && t3.vScale.axis;
-    if (s2) {
-        e2 = e2 || t3._parsed;
-        for (const t4 of e2) {
-            const e3 = t4._stacks;
-            if (!e3 || void 0 === e3[s2] || void 0 === e3[s2][i2])
-                return;
-            delete e3[s2][i2], void 0 !== e3[s2]._visualValues && void 0 !== e3[s2]._visualValues[i2] && delete e3[s2]._visualValues[i2];
-        }
-    }
-}
-const Wr = (t3) => "reset" === t3 || "none" === t3,
-    qr = (t3, e2) => e2 ? t3 : Object.assign({}, t3);
-class DatasetController {
-    constructor(t3, e2) {
-        this.chart = t3, this._ctx = t3.ctx, this.index = e2, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = false, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = false, this.supportsDecimation = false, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();
-    }
-    initialize() {
-        const t3 = this._cachedMeta;
-        this.configure(), this.linkScales(), t3._stacked = Vr(t3.vScale, t3), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
-    }
-    updateIndex(t3) {
-        this.index !== t3 && Hr(this._cachedMeta), this.index = t3;
-    }
-    linkScales() {
-        const t3 = this.chart,
-            e2 = this._cachedMeta,
-            i2 = this.getDataset(),
-            s2 = (t4, e3, i3, s3) => "x" === t4 ? e3 : "r" === t4 ? s3 : i3,
-            n2 = e2.xAxisID = Ti(i2.xAxisID, jr(t3, "x")),
-            r2 = e2.yAxisID = Ti(i2.yAxisID, jr(t3, "y")),
-            o2 = e2.rAxisID = Ti(i2.rAxisID, jr(t3, "r")),
-            a2 = e2.indexAxis,
-            l2 = e2.iAxisID = s2(a2, n2, r2, o2),
-            h2 = e2.vAxisID = s2(a2, r2, n2, o2);
-        e2.xScale = this.getScaleForId(n2), e2.yScale = this.getScaleForId(r2), e2.rScale = this.getScaleForId(o2), e2.iScale = this.getScaleForId(l2), e2.vScale = this.getScaleForId(h2);
-    }
-    getDataset() {
-        return this.chart.data.datasets[this.index];
-    }
-    getMeta() {
-        return this.chart.getDatasetMeta(this.index);
-    }
-    getScaleForId(t3) {
-        return this.chart.scales[t3];
-    }
-    _getOtherScale(t3) {
-        const e2 = this._cachedMeta;
-        return t3 === e2.iScale ? e2.vScale : e2.iScale;
-    }
-    reset() {
-        this._update("reset");
-    }
-    _destroy() {
-        const t3 = this._cachedMeta;
-        this._data && Ts(this._data, this), t3._stacked && Hr(t3);
-    }
-    _dataCheck() {
-        const t3 = this.getDataset(),
-            e2 = t3.data || (t3.data = []),
-            i2 = this._data;
-        if (yi(e2))
-            this._data = function(t4) {
-                const e3 = Object.keys(t4),
-                    i3 = new Array(e3.length);
-                let s3, n3, r2;
-                for (s3 = 0, n3 = e3.length; s3 < n3; ++s3)
-                    r2 = e3[s3], i3[s3] = {
-                        x: r2,
-                        y: t4[r2]
-                    };
-                return i3;
-            }(e2);
-        else if (i2 !== e2) {
-            if (i2) {
-                Ts(i2, this);
-                const t4 = this._cachedMeta;
-                Hr(t4), t4._parsed = [];
-            }
-            e2 && Object.isExtensible(e2) && (n2 = this, (s2 = e2)._chartjs ? s2._chartjs.listeners.push(n2) : (Object.defineProperty(s2, "_chartjs", {
-                configurable: true,
-                enumerable: false,
-                value: {
-                    listeners: [n2]
-                }
-            }), ks.forEach((t4) => {
-                const e3 = "_onData" + Wi(t4),
-                    i3 = s2[t4];
-                Object.defineProperty(s2, t4, {
-                    configurable: true,
-                    enumerable: false,
-                    value(...t5) {
-                        const n3 = i3.apply(this, t5);
-                        return s2._chartjs.listeners.forEach((i4) => {
-                            "function" == typeof i4[e3] && i4[e3](...t5);
-                        }), n3;
-                    }
-                });
-            }))), this._syncList = [], this._data = e2;
-        }
-        var s2, n2;
-    }
-    addElements() {
-        const t3 = this._cachedMeta;
-        this._dataCheck(), this.datasetElementType && (t3.dataset = new this.datasetElementType());
-    }
-    buildOrUpdateElements(t3) {
-        const e2 = this._cachedMeta,
-            i2 = this.getDataset();
-        let s2 = false;
-        this._dataCheck();
-        const n2 = e2._stacked;
-        e2._stacked = Vr(e2.vScale, e2), e2.stack !== i2.stack && (s2 = true, Hr(e2), e2.stack = i2.stack), this._resyncElements(t3), (s2 || n2 !== e2._stacked) && Ur(this, e2._parsed);
-    }
-    configure() {
-        const t3 = this.chart.config,
-            e2 = t3.datasetScopeKeys(this._type),
-            i2 = t3.getOptionScopes(this.getDataset(), e2, true);
-        this.options = t3.createResolver(i2, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
-    }
-    parse(t3, e2) {
-        const {
-            _cachedMeta: i2,
-            _data: s2
-        } = this, {
-            iScale: n2,
-            _stacked: r2
-        } = i2, o2 = n2.axis;
-        let a2, l2, h2, c2 = 0 === t3 && e2 === s2.length || i2._sorted,
-            u2 = t3 > 0 && i2._parsed[t3 - 1];
-        if (false === this._parsing)
-            i2._parsed = s2, i2._sorted = true, h2 = s2;
-        else {
-            h2 = ui(s2[t3]) ? this.parseArrayData(i2, s2, t3, e2) : yi(s2[t3]) ? this.parseObjectData(i2, s2, t3, e2) : this.parsePrimitiveData(i2, s2, t3, e2);
-            const n3 = () => null === l2[o2] || u2 && l2[o2] < u2[o2];
-            for (a2 = 0; a2 < e2; ++a2)
-                i2._parsed[a2 + t3] = l2 = h2[a2], c2 && (n3() && (c2 = false), u2 = l2);
-            i2._sorted = c2;
-        }
-        r2 && Ur(this, h2);
-    }
-    parsePrimitiveData(t3, e2, i2, s2) {
-        const {
-            iScale: n2,
-            vScale: r2
-        } = t3, o2 = n2.axis, a2 = r2.axis, l2 = n2.getLabels(), h2 = n2 === r2, c2 = new Array(s2);
-        let u2, d2, f2;
-        for (u2 = 0, d2 = s2; u2 < d2; ++u2)
-            f2 = u2 + i2, c2[u2] = {
-                [o2]: h2 || n2.parse(l2[f2], f2),
-                [a2]: r2.parse(e2[f2], f2)
-            };
-        return c2;
-    }
-    parseArrayData(t3, e2, i2, s2) {
-        const {
-            xScale: n2,
-            yScale: r2
-        } = t3, o2 = new Array(s2);
-        let a2, l2, h2, c2;
-        for (a2 = 0, l2 = s2; a2 < l2; ++a2)
-            h2 = a2 + i2, c2 = e2[h2], o2[a2] = {
-                x: n2.parse(c2[0], h2),
-                y: r2.parse(c2[1], h2)
-            };
-        return o2;
-    }
-    parseObjectData(t3, e2, i2, s2) {
-        const {
-            xScale: n2,
-            yScale: r2
-        } = t3, {
-            xAxisKey: o2 = "x",
-            yAxisKey: a2 = "y"
-        } = this._parsing, l2 = new Array(s2);
-        let h2, c2, u2, d2;
-        for (h2 = 0, c2 = s2; h2 < c2; ++h2)
-            u2 = h2 + i2, d2 = e2[u2], l2[h2] = {
-                x: n2.parse(ji(d2, o2), u2),
-                y: r2.parse(ji(d2, a2), u2)
-            };
-        return l2;
-    }
-    getParsed(t3) {
-        return this._cachedMeta._parsed[t3];
-    }
-    getDataElement(t3) {
-        return this._cachedMeta.data[t3];
-    }
-    applyStack(t3, e2, i2) {
-        const s2 = this.chart,
-            n2 = this._cachedMeta,
-            r2 = e2[t3.axis];
-        return $r({
-            keys: Nr(s2, true),
-            values: e2._stacks[t3.axis]._visualValues
-        }, r2, n2.index, {
-            mode: i2
-        });
-    }
-    updateRangeFromParsed(t3, e2, i2, s2) {
-        const n2 = i2[e2.axis];
-        let r2 = null === n2 ? NaN : n2;
-        const o2 = s2 && i2._stacks[e2.axis];
-        s2 && o2 && (s2.values = o2, r2 = $r(s2, n2, this._cachedMeta.index)), t3.min = Math.min(t3.min, r2), t3.max = Math.max(t3.max, r2);
-    }
-    getMinMax(t3, e2) {
-        const i2 = this._cachedMeta,
-            s2 = i2._parsed,
-            n2 = i2._sorted && t3 === i2.iScale,
-            r2 = s2.length,
-            o2 = this._getOtherScale(t3),
-            a2 = ((t4, e3, i3) => t4 && !e3.hidden && e3._stacked && {
-                keys: Nr(i3, true),
-                values: null
-            })(e2, i2, this.chart),
-            l2 = {
-                min: Number.POSITIVE_INFINITY,
-                max: Number.NEGATIVE_INFINITY
-            },
-            {
-                min: h2,
-                max: c2
-            } = function(t4) {
-                const {
-                    min: e3,
-                    max: i3,
-                    minDefined: s3,
-                    maxDefined: n3
-                } = t4.getUserBounds();
-                return {
-                    min: s3 ? e3 : Number.NEGATIVE_INFINITY,
-                    max: n3 ? i3 : Number.POSITIVE_INFINITY
-                };
-            }(o2);
-        let u2, d2;
-
-        function f2() {
-            d2 = s2[u2];
-            const e3 = d2[o2.axis];
-            return !_i(d2[t3.axis]) || h2 > e3 || c2 < e3;
-        }
-        for (u2 = 0; u2 < r2 && (f2() || (this.updateRangeFromParsed(l2, t3, d2, a2), !n2)); ++u2)
-        ;
-        if (n2) {
-            for (u2 = r2 - 1; u2 >= 0; --u2)
-                if (!f2()) {
-                    this.updateRangeFromParsed(l2, t3, d2, a2);
-                    break;
-                }
-        }
-        return l2;
-    }
-    getAllParsedValues(t3) {
-        const e2 = this._cachedMeta._parsed,
-            i2 = [];
-        let s2, n2, r2;
-        for (s2 = 0, n2 = e2.length; s2 < n2; ++s2)
-            r2 = e2[s2][t3.axis], _i(r2) && i2.push(r2);
-        return i2;
-    }
-    getMaxOverflow() {
-        return false;
-    }
-    getLabelAndValue(t3) {
-        const e2 = this._cachedMeta,
-            i2 = e2.iScale,
-            s2 = e2.vScale,
-            n2 = this.getParsed(t3);
-        return {
-            label: i2 ? "" + i2.getLabelForValue(n2[i2.axis]) : "",
-            value: s2 ? "" + s2.getLabelForValue(n2[s2.axis]) : ""
-        };
-    }
-    _update(t3) {
-        const e2 = this._cachedMeta;
-        this.update(t3 || "default"), e2._clip = function(t4) {
-            let e3, i2, s2, n2;
-            return yi(t4) ? (e3 = t4.top, i2 = t4.right, s2 = t4.bottom, n2 = t4.left) : e3 = i2 = s2 = n2 = t4, {
-                top: e3,
-                right: i2,
-                bottom: s2,
-                left: n2,
-                disabled: false === t4
-            };
-        }(Ti(this.options.clip, function(t4, e3, i2) {
-            if (false === i2)
-                return false;
-            const s2 = Fr(t4, i2),
-                n2 = Fr(e3, i2);
-            return {
-                top: n2.end,
-                right: s2.end,
-                bottom: n2.start,
-                left: s2.start
-            };
-        }(e2.xScale, e2.yScale, this.getMaxOverflow())));
-    }
-    update(t3) {}
-    draw() {
-        const t3 = this._ctx,
-            e2 = this.chart,
-            i2 = this._cachedMeta,
-            s2 = i2.data || [],
-            n2 = e2.chartArea,
-            r2 = [],
-            o2 = this._drawStart || 0,
-            a2 = this._drawCount || s2.length - o2,
-            l2 = this.options.drawActiveElementsOnTop;
-        let h2;
-        for (i2.dataset && i2.dataset.draw(t3, n2, o2, a2), h2 = o2; h2 < o2 + a2; ++h2) {
-            const e3 = s2[h2];
-            e3.hidden || (e3.active && l2 ? r2.push(e3) : e3.draw(t3, n2));
-        }
-        for (h2 = 0; h2 < r2.length; ++h2)
-            r2[h2].draw(t3, n2);
-    }
-    getStyle(t3, e2) {
-        const i2 = e2 ? "active" : "default";
-        return void 0 === t3 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(i2) : this.resolveDataElementOptions(t3 || 0, i2);
-    }
-    getContext(t3, e2, i2) {
-        const s2 = this.getDataset();
-        let n2;
-        if (t3 >= 0 && t3 < this._cachedMeta.data.length) {
-            const e3 = this._cachedMeta.data[t3];
-            n2 = e3.$context || (e3.$context = function(t4, e4, i3) {
-                return $n(t4, {
-                    active: false,
-                    dataIndex: e4,
-                    parsed: void 0,
-                    raw: void 0,
-                    element: i3,
-                    index: e4,
-                    mode: "default",
-                    type: "data"
-                });
-            }(this.getContext(), t3, e3)), n2.parsed = this.getParsed(t3), n2.raw = s2.data[t3], n2.index = n2.dataIndex = t3;
-        } else
-            n2 = this.$context || (this.$context = function(t4, e3) {
-                return $n(t4, {
-                    active: false,
-                    dataset: void 0,
-                    datasetIndex: e3,
-                    index: e3,
-                    mode: "default",
-                    type: "dataset"
-                });
-            }(this.chart.getContext(), this.index)), n2.dataset = s2, n2.index = n2.datasetIndex = this.index;
-        return n2.active = !!e2, n2.mode = i2, n2;
-    }
-    resolveDatasetElementOptions(t3) {
-        return this._resolveElementOptions(this.datasetElementType.id, t3);
-    }
-    resolveDataElementOptions(t3, e2) {
-        return this._resolveElementOptions(this.dataElementType.id, e2, t3);
-    }
-    _resolveElementOptions(t3, e2 = "default", i2) {
-        const s2 = "active" === e2,
-            n2 = this._cachedDataOpts,
-            r2 = t3 + "-" + e2,
-            o2 = n2[r2],
-            a2 = this.enableOptionSharing && qi(i2);
-        if (o2)
-            return qr(o2, a2);
-        const l2 = this.chart.config,
-            h2 = l2.datasetElementScopeKeys(this._type, t3),
-            c2 = s2 ? [`${t3}Hover`, "hover", t3, ""] : [t3, ""],
-            u2 = l2.getOptionScopes(this.getDataset(), h2),
-            d2 = Object.keys(Js.elements[t3]),
-            f2 = l2.resolveNamedOptions(u2, d2, () => this.getContext(i2, s2, e2), c2);
-        return f2.$shared && (f2.$shared = a2, n2[r2] = Object.freeze(qr(f2, a2))), f2;
-    }
-    _resolveAnimations(t3, e2, i2) {
-        const s2 = this.chart,
-            n2 = this._cachedDataOpts,
-            r2 = `animation-${e2}`,
-            o2 = n2[r2];
-        if (o2)
-            return o2;
-        let a2;
-        if (false !== s2.options.animation) {
-            const s3 = this.chart.config,
-                n3 = s3.datasetAnimationScopeKeys(this._type, e2),
-                r3 = s3.getOptionScopes(this.getDataset(), n3);
-            a2 = s3.createResolver(r3, this.getContext(t3, i2, e2));
-        }
-        const l2 = new Animations(s2, a2 && a2.animations);
-        return a2 && a2._cacheable && (n2[r2] = Object.freeze(l2)), l2;
-    }
-    getSharedOptions(t3) {
-        if (t3.$shared)
-            return this._sharedOptions || (this._sharedOptions = Object.assign({}, t3));
-    }
-    includeOptions(t3, e2) {
-        return !e2 || Wr(t3) || this.chart._animationsDisabled;
-    }
-    _getSharedOptions(t3, e2) {
-        const i2 = this.resolveDataElementOptions(t3, e2),
-            s2 = this._sharedOptions,
-            n2 = this.getSharedOptions(i2),
-            r2 = this.includeOptions(e2, n2) || n2 !== s2;
-        return this.updateSharedOptions(n2, e2, i2), {
-            sharedOptions: n2,
-            includeOptions: r2
-        };
-    }
-    updateElement(t3, e2, i2, s2) {
-        Wr(s2) ? Object.assign(t3, i2) : this._resolveAnimations(e2, s2).update(t3, i2);
-    }
-    updateSharedOptions(t3, e2, i2) {
-        t3 && !Wr(e2) && this._resolveAnimations(void 0, e2).update(t3, i2);
-    }
-    _setStyle(t3, e2, i2, s2) {
-        t3.active = s2;
-        const n2 = this.getStyle(e2, s2);
-        this._resolveAnimations(e2, i2, s2).update(t3, {
-            options: !s2 && this.getSharedOptions(n2) || n2
-        });
-    }
-    removeHoverStyle(t3, e2, i2) {
-        this._setStyle(t3, i2, "active", false);
-    }
-    setHoverStyle(t3, e2, i2) {
-        this._setStyle(t3, i2, "active", true);
-    }
-    _removeDatasetHoverStyle() {
-        const t3 = this._cachedMeta.dataset;
-        t3 && this._setStyle(t3, void 0, "active", false);
-    }
-    _setDatasetHoverStyle() {
-        const t3 = this._cachedMeta.dataset;
-        t3 && this._setStyle(t3, void 0, "active", true);
-    }
-    _resyncElements(t3) {
-        const e2 = this._data,
-            i2 = this._cachedMeta.data;
-        for (const [t4, e3, i3] of this._syncList)
-            this[t4](e3, i3);
-        this._syncList = [];
-        const s2 = i2.length,
-            n2 = e2.length,
-            r2 = Math.min(n2, s2);
-        r2 && this.parse(0, r2), n2 > s2 ? this._insertElements(s2, n2 - s2, t3) : n2 < s2 && this._removeElements(n2, s2 - n2);
-    }
-    _insertElements(t3, e2, i2 = true) {
-        const s2 = this._cachedMeta,
-            n2 = s2.data,
-            r2 = t3 + e2;
-        let o2;
-        const a2 = (t4) => {
-            for (t4.length += e2, o2 = t4.length - 1; o2 >= r2; o2--)
-                t4[o2] = t4[o2 - e2];
-        };
-        for (a2(n2), o2 = t3; o2 < r2; ++o2)
-            n2[o2] = new this.dataElementType();
-        this._parsing && a2(s2._parsed), this.parse(t3, e2), i2 && this.updateElements(n2, t3, e2, "reset");
-    }
-    updateElements(t3, e2, i2, s2) {}
-    _removeElements(t3, e2) {
-        const i2 = this._cachedMeta;
-        if (this._parsing) {
-            const s2 = i2._parsed.splice(t3, e2);
-            i2._stacked && Hr(i2, s2);
-        }
-        i2.data.splice(t3, e2);
-    }
-    _sync(t3) {
-        if (this._parsing)
-            this._syncList.push(t3);
-        else {
-            const [e2, i2, s2] = t3;
-            this[e2](i2, s2);
-        }
-        this.chart._dataChanges.push([this.index, ...t3]);
-    }
-    _onDataPush() {
-        const t3 = arguments.length;
-        this._sync(["_insertElements", this.getDataset().data.length - t3, t3]);
-    }
-    _onDataPop() {
-        this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]);
-    }
-    _onDataShift() {
-        this._sync(["_removeElements", 0, 1]);
-    }
-    _onDataSplice(t3, e2) {
-        e2 && this._sync(["_removeElements", t3, e2]);
-        const i2 = arguments.length - 2;
-        i2 && this._sync(["_insertElements", t3, i2]);
-    }
-    _onDataUnshift() {
-        this._sync(["_insertElements", 0, arguments.length]);
-    }
-}
-__publicField(DatasetController, "defaults", {});
-__publicField(DatasetController, "datasetElementType", null);
-__publicField(DatasetController, "dataElementType", null);
-
-function Kr(t3) {
-    const e2 = t3.iScale,
-        i2 = function(t4, e3) {
-            if (!t4._cache.$bar) {
-                const i3 = t4.getMatchingVisibleMetas(e3);
-                let s3 = [];
-                for (let e4 = 0, n3 = i3.length; e4 < n3; e4++)
-                    s3 = s3.concat(i3[e4].controller.getAllParsedValues(t4));
-                t4._cache.$bar = Es(s3.sort((t5, e4) => t5 - e4));
-            }
-            return t4._cache.$bar;
-        }(e2, t3.type);
-    let s2, n2, r2, o2, a2 = e2._length;
-    const l2 = () => {
-        32767 !== r2 && -32768 !== r2 && (qi(o2) && (a2 = Math.min(a2, Math.abs(r2 - o2) || a2)), o2 = r2);
-    };
-    for (s2 = 0, n2 = i2.length; s2 < n2; ++s2)
-        r2 = e2.getPixelForValue(i2[s2]), l2();
-    for (o2 = void 0, s2 = 0, n2 = e2.ticks.length; s2 < n2; ++s2)
-        r2 = e2.getPixelForTick(s2), l2();
-    return a2;
-}
-
-function Gr(t3, e2, i2, s2) {
-    return ui(t3) ? function(t4, e3, i3, s3) {
-        const n2 = i3.parse(t4[0], s3),
-            r2 = i3.parse(t4[1], s3),
-            o2 = Math.min(n2, r2),
-            a2 = Math.max(n2, r2);
-        let l2 = o2,
-            h2 = a2;
-        Math.abs(o2) > Math.abs(a2) && (l2 = a2, h2 = o2), e3[i3.axis] = h2, e3._custom = {
-            barStart: l2,
-            barEnd: h2,
-            start: n2,
-            end: r2,
-            min: o2,
-            max: a2
-        };
-    }(t3, e2, i2, s2) : e2[i2.axis] = i2.parse(t3, s2), e2;
-}
-
-function Yr(t3, e2, i2, s2) {
-    const n2 = t3.iScale,
-        r2 = t3.vScale,
-        o2 = n2.getLabels(),
-        a2 = n2 === r2,
-        l2 = [];
-    let h2, c2, u2, d2;
-    for (h2 = i2, c2 = i2 + s2; h2 < c2; ++h2)
-        d2 = e2[h2], u2 = {}, u2[n2.axis] = a2 || n2.parse(o2[h2], h2), l2.push(Gr(d2, u2, r2, h2));
-    return l2;
-}
-
-function Qr(t3) {
-    return t3 && void 0 !== t3.barStart && void 0 !== t3.barEnd;
-}
-
-function Xr(t3, e2, i2, s2) {
-    let n2 = e2.borderSkipped;
-    const r2 = {};
-    if (!n2)
-        return void(t3.borderSkipped = r2);
-    if (true === n2)
-        return void(t3.borderSkipped = {
-            top: true,
-            right: true,
-            bottom: true,
-            left: true
-        });
-    const {
-        start: o2,
-        end: a2,
-        reverse: l2,
-        top: h2,
-        bottom: c2
-    } = function(t4) {
-        let e3, i3, s3, n3, r3;
-        return t4.horizontal ? (e3 = t4.base > t4.x, i3 = "left", s3 = "right") : (e3 = t4.base < t4.y, i3 = "bottom", s3 = "top"), e3 ? (n3 = "end", r3 = "start") : (n3 = "start", r3 = "end"), {
-            start: i3,
-            end: s3,
-            reverse: e3,
-            top: n3,
-            bottom: r3
-        };
-    }(t3);
-    "middle" === n2 && i2 && (t3.enableBorderRadius = true, (i2._top || 0) === s2 ? n2 = h2 : (i2._bottom || 0) === s2 ? n2 = c2 : (r2[Jr(c2, o2, a2, l2)] = true, n2 = h2)), r2[Jr(n2, o2, a2, l2)] = true, t3.borderSkipped = r2;
-}
-
-function Jr(t3, e2, i2, s2) {
-    var n2, r2, o2;
-    return s2 ? (o2 = i2, t3 = Zr(t3 = (n2 = t3) === (r2 = e2) ? o2 : n2 === o2 ? r2 : n2, i2, e2)) : t3 = Zr(t3, e2, i2), t3;
-}
-
-function Zr(t3, e2, i2) {
-    return "start" === t3 ? e2 : "end" === t3 ? i2 : t3;
-}
-
-function to(t3, {
-    inflateAmount: e2
-}, i2) {
-    t3.inflateAmount = "auto" === e2 ? 1 === i2 ? 0.33 : 0 : e2;
-}
-class BarController extends DatasetController {
-    parsePrimitiveData(t3, e2, i2, s2) {
-        return Yr(t3, e2, i2, s2);
-    }
-    parseArrayData(t3, e2, i2, s2) {
-        return Yr(t3, e2, i2, s2);
-    }
-    parseObjectData(t3, e2, i2, s2) {
-        const {
-            iScale: n2,
-            vScale: r2
-        } = t3, {
-            xAxisKey: o2 = "x",
-            yAxisKey: a2 = "y"
-        } = this._parsing, l2 = "x" === n2.axis ? o2 : a2, h2 = "x" === r2.axis ? o2 : a2, c2 = [];
-        let u2, d2, f2, p2;
-        for (u2 = i2, d2 = i2 + s2; u2 < d2; ++u2)
-            p2 = e2[u2], f2 = {}, f2[n2.axis] = n2.parse(ji(p2, l2), u2), c2.push(Gr(ji(p2, h2), f2, r2, u2));
-        return c2;
-    }
-    updateRangeFromParsed(t3, e2, i2, s2) {
-        super.updateRangeFromParsed(t3, e2, i2, s2);
-        const n2 = i2._custom;
-        n2 && e2 === this._cachedMeta.vScale && (t3.min = Math.min(t3.min, n2.min), t3.max = Math.max(t3.max, n2.max));
-    }
-    getMaxOverflow() {
-        return 0;
-    }
-    getLabelAndValue(t3) {
-        const e2 = this._cachedMeta,
-            {
-                iScale: i2,
-                vScale: s2
-            } = e2,
-            n2 = this.getParsed(t3),
-            r2 = n2._custom,
-            o2 = Qr(r2) ? "[" + r2.start + ", " + r2.end + "]" : "" + s2.getLabelForValue(n2[s2.axis]);
-        return {
-            label: "" + i2.getLabelForValue(n2[i2.axis]),
-            value: o2
-        };
-    }
-    initialize() {
-        this.enableOptionSharing = true, super.initialize();
-        this._cachedMeta.stack = this.getDataset().stack;
-    }
-    update(t3) {
-        const e2 = this._cachedMeta;
-        this.updateElements(e2.data, 0, e2.data.length, t3);
-    }
-    updateElements(t3, e2, i2, s2) {
-        const n2 = "reset" === s2,
-            {
-                index: r2,
-                _cachedMeta: {
-                    vScale: o2
-                }
-            } = this,
-            a2 = o2.getBasePixel(),
-            l2 = o2.isHorizontal(),
-            h2 = this._getRuler(),
-            {
-                sharedOptions: c2,
-                includeOptions: u2
-            } = this._getSharedOptions(e2, s2);
-        for (let d2 = e2; d2 < e2 + i2; d2++) {
-            const e3 = this.getParsed(d2),
-                i3 = n2 || ci(e3[o2.axis]) ? {
-                    base: a2,
-                    head: a2
-                } : this._calculateBarValuePixels(d2),
-                f2 = this._calculateBarIndexPixels(d2, h2),
-                p2 = (e3._stacks || {})[o2.axis],
-                m2 = {
-                    horizontal: l2,
-                    base: i3.base,
-                    enableBorderRadius: !p2 || Qr(e3._custom) || r2 === p2._top || r2 === p2._bottom,
-                    x: l2 ? i3.head : f2.center,
-                    y: l2 ? f2.center : i3.head,
-                    height: l2 ? f2.size : Math.abs(i3.size),
-                    width: l2 ? Math.abs(i3.size) : f2.size
-                };
-            u2 && (m2.options = c2 || this.resolveDataElementOptions(d2, t3[d2].active ? "active" : s2));
-            const g2 = m2.options || t3[d2].options;
-            Xr(m2, g2, p2, r2), to(m2, g2, h2.ratio), this.updateElement(t3[d2], d2, m2, s2);
-        }
-    }
-    _getStacks(t3, e2) {
-        const {
-            iScale: i2
-        } = this._cachedMeta, s2 = i2.getMatchingVisibleMetas(this._type).filter((t4) => t4.controller.options.grouped), n2 = i2.options.stacked, r2 = [], o2 = (t4) => {
-            const i3 = t4.controller.getParsed(e2),
-                s3 = i3 && i3[t4.vScale.axis];
-            if (ci(s3) || isNaN(s3))
-                return true;
-        };
-        for (const i3 of s2)
-            if ((void 0 === e2 || !o2(i3)) && ((false === n2 || -1 === r2.indexOf(i3.stack) || void 0 === n2 && void 0 === i3.stack) && r2.push(i3.stack), i3.index === t3))
-                break;
-        return r2.length || r2.push(void 0), r2;
-    }
-    _getStackCount(t3) {
-        return this._getStacks(void 0, t3).length;
-    }
-    _getStackIndex(t3, e2, i2) {
-        const s2 = this._getStacks(t3, i2),
-            n2 = void 0 !== e2 ? s2.indexOf(e2) : -1;
-        return -1 === n2 ? s2.length - 1 : n2;
-    }
-    _getRuler() {
-        const t3 = this.options,
-            e2 = this._cachedMeta,
-            i2 = e2.iScale,
-            s2 = [];
-        let n2, r2;
-        for (n2 = 0, r2 = e2.data.length; n2 < r2; ++n2)
-            s2.push(i2.getPixelForValue(this.getParsed(n2)[i2.axis], n2));
-        const o2 = t3.barThickness;
-        return {
-            min: o2 || Kr(e2),
-            pixels: s2,
-            start: i2._startPixel,
-            end: i2._endPixel,
-            stackCount: this._getStackCount(),
-            scale: i2,
-            grouped: t3.grouped,
-            ratio: o2 ? 1 : t3.categoryPercentage * t3.barPercentage
-        };
-    }
-    _calculateBarValuePixels(t3) {
-        const {
-            _cachedMeta: {
-                vScale: e2,
-                _stacked: i2,
-                index: s2
-            },
-            options: {
-                base: n2,
-                minBarLength: r2
-            }
-        } = this, o2 = n2 || 0, a2 = this.getParsed(t3), l2 = a2._custom, h2 = Qr(l2);
-        let c2, u2, d2 = a2[e2.axis],
-            f2 = 0,
-            p2 = i2 ? this.applyStack(e2, a2, i2) : d2;
-        p2 !== d2 && (f2 = p2 - d2, p2 = d2), h2 && (d2 = l2.barStart, p2 = l2.barEnd - l2.barStart, 0 !== d2 && os(d2) !== os(l2.barEnd) && (f2 = 0), f2 += d2);
-        const m2 = ci(n2) || h2 ? f2 : n2;
-        let g2 = e2.getPixelForValue(m2);
-        if (c2 = this.chart.getDataVisibility(t3) ? e2.getPixelForValue(f2 + p2) : g2, u2 = c2 - g2, Math.abs(u2) < r2) {
-            u2 = function(t5, e3, i3) {
-                return 0 !== t5 ? os(t5) : (e3.isHorizontal() ? 1 : -1) * (e3.min >= i3 ? 1 : -1);
-            }(u2, e2, o2) * r2, d2 === o2 && (g2 -= u2 / 2);
-            const t4 = e2.getPixelForDecimal(0),
-                n3 = e2.getPixelForDecimal(1),
-                l3 = Math.min(t4, n3),
-                f3 = Math.max(t4, n3);
-            g2 = Math.max(Math.min(g2, f3), l3), c2 = g2 + u2, i2 && !h2 && (a2._stacks[e2.axis]._visualValues[s2] = e2.getValueForPixel(c2) - e2.getValueForPixel(g2));
-        }
-        if (g2 === e2.getPixelForValue(o2)) {
-            const t4 = os(u2) * e2.getLineWidthForValue(o2) / 2;
-            g2 += t4, u2 -= t4;
-        }
-        return {
-            size: u2,
-            base: g2,
-            head: c2,
-            center: c2 + u2 / 2
-        };
-    }
-    _calculateBarIndexPixels(t3, e2) {
-        const i2 = e2.scale,
-            s2 = this.options,
-            n2 = s2.skipNull,
-            r2 = Ti(s2.maxBarThickness, 1 / 0);
-        let o2, a2;
-        if (e2.grouped) {
-            const i3 = n2 ? this._getStackCount(t3) : e2.stackCount,
-                l2 = "flex" === s2.barThickness ? function(t4, e3, i4, s3) {
-                    const n3 = e3.pixels,
-                        r3 = n3[t4];
-                    let o3 = t4 > 0 ? n3[t4 - 1] : null,
-                        a3 = t4 < n3.length - 1 ? n3[t4 + 1] : null;
-                    const l3 = i4.categoryPercentage;
-                    null === o3 && (o3 = r3 - (null === a3 ? e3.end - e3.start : a3 - r3)), null === a3 && (a3 = r3 + r3 - o3);
-                    const h3 = r3 - (r3 - Math.min(o3, a3)) / 2 * l3;
-                    return {
-                        chunk: Math.abs(a3 - o3) / 2 * l3 / s3,
-                        ratio: i4.barPercentage,
-                        start: h3
-                    };
-                }(t3, e2, s2, i3) : function(t4, e3, i4, s3) {
-                    const n3 = i4.barThickness;
-                    let r3, o3;
-                    return ci(n3) ? (r3 = e3.min * i4.categoryPercentage, o3 = i4.barPercentage) : (r3 = n3 * s3, o3 = 1), {
-                        chunk: r3 / s3,
-                        ratio: o3,
-                        start: e3.pixels[t4] - r3 / 2
-                    };
-                }(t3, e2, s2, i3),
-                h2 = this._getStackIndex(this.index, this._cachedMeta.stack, n2 ? t3 : void 0);
-            o2 = l2.start + l2.chunk * h2 + l2.chunk / 2, a2 = Math.min(r2, l2.chunk * l2.ratio);
-        } else
-            o2 = i2.getPixelForValue(this.getParsed(t3)[i2.axis], t3), a2 = Math.min(r2, e2.min * e2.ratio);
-        return {
-            base: o2 - a2 / 2,
-            head: o2 + a2 / 2,
-            center: o2,
-            size: a2
-        };
-    }
-    draw() {
-        const t3 = this._cachedMeta,
-            e2 = t3.vScale,
-            i2 = t3.data,
-            s2 = i2.length;
-        let n2 = 0;
-        for (; n2 < s2; ++n2)
-            null !== this.getParsed(n2)[e2.axis] && i2[n2].draw(this._ctx);
-    }
-}
-__publicField(BarController, "id", "bar");
-__publicField(BarController, "defaults", {
-    datasetElementType: false,
-    dataElementType: "bar",
-    categoryPercentage: 0.8,
-    barPercentage: 0.9,
-    grouped: true,
-    animations: {
-        numbers: {
-            type: "number",
-            properties: ["x", "y", "base", "width", "height"]
-        }
-    }
-});
-__publicField(BarController, "overrides", {
-    scales: {
-        _index_: {
-            type: "category",
-            offset: true,
-            grid: {
-                offset: true
-            }
-        },
-        _value_: {
-            type: "linear",
-            beginAtZero: true
-        }
-    }
-});
-class BubbleController extends DatasetController {
-    initialize() {
-        this.enableOptionSharing = true, super.initialize();
-    }
-    parsePrimitiveData(t3, e2, i2, s2) {
-        const n2 = super.parsePrimitiveData(t3, e2, i2, s2);
-        for (let t4 = 0; t4 < n2.length; t4++)
-            n2[t4]._custom = this.resolveDataElementOptions(t4 + i2).radius;
-        return n2;
-    }
-    parseArrayData(t3, e2, i2, s2) {
-        const n2 = super.parseArrayData(t3, e2, i2, s2);
-        for (let t4 = 0; t4 < n2.length; t4++) {
-            const s3 = e2[i2 + t4];
-            n2[t4]._custom = Ti(s3[2], this.resolveDataElementOptions(t4 + i2).radius);
-        }
-        return n2;
-    }
-    parseObjectData(t3, e2, i2, s2) {
-        const n2 = super.parseObjectData(t3, e2, i2, s2);
-        for (let t4 = 0; t4 < n2.length; t4++) {
-            const s3 = e2[i2 + t4];
-            n2[t4]._custom = Ti(s3 && s3.r && +s3.r, this.resolveDataElementOptions(t4 + i2).radius);
-        }
-        return n2;
-    }
-    getMaxOverflow() {
-        const t3 = this._cachedMeta.data;
-        let e2 = 0;
-        for (let i2 = t3.length - 1; i2 >= 0; --i2)
-            e2 = Math.max(e2, t3[i2].size(this.resolveDataElementOptions(i2)) / 2);
-        return e2 > 0 && e2;
-    }
-    getLabelAndValue(t3) {
-        const e2 = this._cachedMeta,
-            i2 = this.chart.data.labels || [],
-            {
-                xScale: s2,
-                yScale: n2
-            } = e2,
-            r2 = this.getParsed(t3),
-            o2 = s2.getLabelForValue(r2.x),
-            a2 = n2.getLabelForValue(r2.y),
-            l2 = r2._custom;
-        return {
-            label: i2[t3] || "",
-            value: "(" + o2 + ", " + a2 + (l2 ? ", " + l2 : "") + ")"
-        };
-    }
-    update(t3) {
-        const e2 = this._cachedMeta.data;
-        this.updateElements(e2, 0, e2.length, t3);
-    }
-    updateElements(t3, e2, i2, s2) {
-        const n2 = "reset" === s2,
-            {
-                iScale: r2,
-                vScale: o2
-            } = this._cachedMeta,
-            {
-                sharedOptions: a2,
-                includeOptions: l2
-            } = this._getSharedOptions(e2, s2),
-            h2 = r2.axis,
-            c2 = o2.axis;
-        for (let u2 = e2; u2 < e2 + i2; u2++) {
-            const e3 = t3[u2],
-                i3 = !n2 && this.getParsed(u2),
-                d2 = {},
-                f2 = d2[h2] = n2 ? r2.getPixelForDecimal(0.5) : r2.getPixelForValue(i3[h2]),
-                p2 = d2[c2] = n2 ? o2.getBasePixel() : o2.getPixelForValue(i3[c2]);
-            d2.skip = isNaN(f2) || isNaN(p2), l2 && (d2.options = a2 || this.resolveDataElementOptions(u2, e3.active ? "active" : s2), n2 && (d2.options.radius = 0)), this.updateElement(e3, u2, d2, s2);
-        }
-    }
-    resolveDataElementOptions(t3, e2) {
-        const i2 = this.getParsed(t3);
-        let s2 = super.resolveDataElementOptions(t3, e2);
-        s2.$shared && (s2 = Object.assign({}, s2, {
-            $shared: false
-        }));
-        const n2 = s2.radius;
-        return "active" !== e2 && (s2.radius = 0), s2.radius += Ti(i2 && i2._custom, n2), s2;
-    }
-}
-__publicField(BubbleController, "id", "bubble");
-__publicField(BubbleController, "defaults", {
-    datasetElementType: false,
-    dataElementType: "point",
-    animations: {
-        numbers: {
-            type: "number",
-            properties: ["x", "y", "borderWidth", "radius"]
-        }
-    }
-});
-__publicField(BubbleController, "overrides", {
-    scales: {
-        x: {
-            type: "linear"
-        },
-        y: {
-            type: "linear"
-        }
-    }
-});
-class LineController extends DatasetController {
-    initialize() {
-        this.enableOptionSharing = true, this.supportsDecimation = true, super.initialize();
-    }
-    update(t3) {
-        const e2 = this._cachedMeta,
-            {
-                dataset: i2,
-                data: s2 = [],
-                _dataset: n2
-            } = e2,
-            r2 = this.chart._animationsDisabled;
-        let {
-            start: o2,
-            count: a2
-        } = function(t4, e3, i3) {
-            const s3 = e3.length;
-            let n3 = 0,
-                r3 = s3;
-            if (t4._sorted) {
-                const {
-                    iScale: o3,
-                    _parsed: a3
-                } = t4, l3 = o3.axis, {
-                    min: h2,
-                    max: c2,
-                    minDefined: u2,
-                    maxDefined: d2
-                } = o3.getUserBounds();
-                u2 && (n3 = vs(Math.min(ws(a3, l3, h2).lo, i3 ? s3 : ws(e3, l3, o3.getPixelForValue(h2)).lo), 0, s3 - 1)), r3 = d2 ? vs(Math.max(ws(a3, o3.axis, c2, true).hi + 1, i3 ? 0 : ws(e3, l3, o3.getPixelForValue(c2), true).hi + 1), n3, s3) - n3 : s3 - n3;
-            }
-            return {
-                start: n3,
-                count: r3
-            };
-        }(e2, s2, r2);
-        this._drawStart = o2, this._drawCount = a2,
-            function(t4) {
-                const {
-                    xScale: e3,
-                    yScale: i3,
-                    _scaleRanges: s3
-                } = t4, n3 = {
-                    xmin: e3.min,
-                    xmax: e3.max,
-                    ymin: i3.min,
-                    ymax: i3.max
-                };
-                if (!s3)
-                    return t4._scaleRanges = n3, true;
-                const r3 = s3.xmin !== e3.min || s3.xmax !== e3.max || s3.ymin !== i3.min || s3.ymax !== i3.max;
-                return Object.assign(s3, n3), r3;
-            }(e2) && (o2 = 0, a2 = s2.length), i2._chart = this.chart, i2._datasetIndex = this.index, i2._decimated = !!n2._decimated, i2.points = s2;
-        const l2 = this.resolveDatasetElementOptions(t3);
-        this.options.showLine || (l2.borderWidth = 0), l2.segment = this.options.segment, this.updateElement(i2, void 0, {
-            animated: !r2,
-            options: l2
-        }, t3), this.updateElements(s2, o2, a2, t3);
-    }
-    updateElements(t3, e2, i2, s2) {
-        const n2 = "reset" === s2,
-            {
-                iScale: r2,
-                vScale: o2,
-                _stacked: a2,
-                _dataset: l2
-            } = this._cachedMeta,
-            {
-                sharedOptions: h2,
-                includeOptions: c2
-            } = this._getSharedOptions(e2, s2),
-            u2 = r2.axis,
-            d2 = o2.axis,
-            {
-                spanGaps: f2,
-                segment: p2
-            } = this.options,
-            m2 = hs(f2) ? f2 : Number.POSITIVE_INFINITY,
-            g2 = this.chart._animationsDisabled || n2 || "none" === s2,
-            y2 = e2 + i2,
-            v2 = t3.length;
-        let b2 = e2 > 0 && this.getParsed(e2 - 1);
-        for (let i3 = 0; i3 < v2; ++i3) {
-            const f3 = t3[i3],
-                v3 = g2 ? f3 : {};
-            if (i3 < e2 || i3 >= y2) {
-                v3.skip = true;
-                continue;
-            }
-            const _2 = this.getParsed(i3),
-                w2 = ci(_2[d2]),
-                x2 = v3[u2] = r2.getPixelForValue(_2[u2], i3),
-                k2 = v3[d2] = n2 || w2 ? o2.getBasePixel() : o2.getPixelForValue(a2 ? this.applyStack(o2, _2, a2) : _2[d2], i3);
-            v3.skip = isNaN(x2) || isNaN(k2) || w2, v3.stop = i3 > 0 && Math.abs(_2[u2] - b2[u2]) > m2, p2 && (v3.parsed = _2, v3.raw = l2.data[i3]), c2 && (v3.options = h2 || this.resolveDataElementOptions(i3, f3.active ? "active" : s2)), g2 || this.updateElement(f3, i3, v3, s2), b2 = _2;
-        }
-    }
-    getMaxOverflow() {
-        const t3 = this._cachedMeta,
-            e2 = t3.dataset,
-            i2 = e2.options && e2.options.borderWidth || 0,
-            s2 = t3.data || [];
-        if (!s2.length)
-            return i2;
-        const n2 = s2[0].size(this.resolveDataElementOptions(0)),
-            r2 = s2[s2.length - 1].size(this.resolveDataElementOptions(s2.length - 1));
-        return Math.max(i2, n2, r2) / 2;
-    }
-    draw() {
-        const t3 = this._cachedMeta;
-        t3.dataset.updateControlPoints(this.chart.chartArea, t3.iScale.axis), super.draw();
-    }
-}
-__publicField(LineController, "id", "line");
-__publicField(LineController, "defaults", {
-    datasetElementType: "line",
-    dataElementType: "point",
-    showLine: true,
-    spanGaps: false
-});
-__publicField(LineController, "overrides", {
-    scales: {
-        _index_: {
-            type: "category"
-        },
-        _value_: {
-            type: "linear"
-        }
-    }
-});
-
-function eo(t3, e2, i2, s2) {
-    const {
-        controller: n2,
-        data: r2,
-        _sorted: o2
-    } = t3, a2 = n2._cachedMeta.iScale;
-    if (a2 && e2 === a2.axis && "r" !== e2 && o2 && r2.length) {
-        const t4 = a2._reversePixels ? xs : ws;
-        if (!s2)
-            return t4(r2, e2, i2);
-        if (n2._sharedOptions) {
-            const s3 = r2[0],
-                n3 = "function" == typeof s3.getRange && s3.getRange(e2);
-            if (n3) {
-                const s4 = t4(r2, e2, i2 - n3),
-                    o3 = t4(r2, e2, i2 + n3);
-                return {
-                    lo: s4.lo,
-                    hi: o3.hi
-                };
-            }
-        }
-    }
-    return {
-        lo: 0,
-        hi: r2.length - 1
-    };
-}
-
-function io(t3, e2, i2, s2, n2) {
-    const r2 = t3.getSortedVisibleDatasetMetas(),
-        o2 = i2[e2];
-    for (let t4 = 0, i3 = r2.length; t4 < i3; ++t4) {
-        const {
-            index: i4,
-            data: a2
-        } = r2[t4], {
-            lo: l2,
-            hi: h2
-        } = eo(r2[t4], e2, o2, n2);
-        for (let t5 = l2; t5 <= h2; ++t5) {
-            const e3 = a2[t5];
-            e3.skip || s2(e3, i4, t5);
-        }
-    }
-}
-
-function so(t3, e2, i2, s2, n2) {
-    const r2 = [];
-    if (!n2 && !t3.isPointInArea(e2))
-        return r2;
-    return io(t3, i2, e2, function(i3, o2, a2) {
-        (n2 || nn(i3, t3.chartArea, 0)) && i3.inRange(e2.x, e2.y, s2) && r2.push({
-            element: i3,
-            datasetIndex: o2,
-            index: a2
-        });
-    }, true), r2;
-}
-
-function no(t3, e2, i2, s2) {
-    let n2 = [];
-    return io(t3, i2, e2, function(t4, i3, r2) {
-        const {
-            startAngle: o2,
-            endAngle: a2
-        } = t4.getProps(["startAngle", "endAngle"], s2), {
-            angle: l2
-        } = function(t5, e3) {
-            const i4 = e3.x - t5.x,
-                s3 = e3.y - t5.y,
-                n3 = Math.sqrt(i4 * i4 + s3 * s3);
-            let r3 = Math.atan2(s3, i4);
-            return r3 < -0.5 * Qi && (r3 += Xi), {
-                angle: r3,
-                distance: n3
-            };
-        }(t4, {
-            x: e2.x,
-            y: e2.y
-        });
-        ys(l2, o2, a2) && n2.push({
-            element: t4,
-            datasetIndex: i3,
-            index: r2
-        });
-    }), n2;
-}
-
-function ro(t3, e2, i2, s2, n2, r2) {
-    let o2 = [];
-    const a2 = function(t4) {
-        const e3 = -1 !== t4.indexOf("x"),
-            i3 = -1 !== t4.indexOf("y");
-        return function(t5, s3) {
-            const n3 = e3 ? Math.abs(t5.x - s3.x) : 0,
-                r3 = i3 ? Math.abs(t5.y - s3.y) : 0;
-            return Math.sqrt(Math.pow(n3, 2) + Math.pow(r3, 2));
-        };
-    }(i2);
-    let l2 = Number.POSITIVE_INFINITY;
-    return io(t3, i2, e2, function(i3, h2, c2) {
-        const u2 = i3.inRange(e2.x, e2.y, n2);
-        if (s2 && !u2)
-            return;
-        const d2 = i3.getCenterPoint(n2);
-        if (!(!!r2 || t3.isPointInArea(d2)) && !u2)
-            return;
-        const f2 = a2(e2, d2);
-        f2 < l2 ? (o2 = [{
-            element: i3,
-            datasetIndex: h2,
-            index: c2
-        }], l2 = f2) : f2 === l2 && o2.push({
-            element: i3,
-            datasetIndex: h2,
-            index: c2
-        });
-    }), o2;
-}
-
-function oo(t3, e2, i2, s2, n2, r2) {
-    return r2 || t3.isPointInArea(e2) ? "r" !== i2 || s2 ? ro(t3, e2, i2, s2, n2, r2) : no(t3, e2, i2, n2) : [];
-}
-
-function ao(t3, e2, i2, s2, n2) {
-    const r2 = [],
-        o2 = "x" === i2 ? "inXRange" : "inYRange";
-    let a2 = false;
-    return io(t3, i2, e2, (t4, s3, l2) => {
-        t4[o2](e2[i2], n2) && (r2.push({
-            element: t4,
-            datasetIndex: s3,
-            index: l2
-        }), a2 = a2 || t4.inRange(e2.x, e2.y, n2));
-    }), s2 && !a2 ? [] : r2;
-}
-var lo = {
-    evaluateInteractionItems: io,
-    modes: {
-        index(t3, e2, i2, s2) {
-            const n2 = yr(e2, t3),
-                r2 = i2.axis || "x",
-                o2 = i2.includeInvisible || false,
-                a2 = i2.intersect ? so(t3, n2, r2, s2, o2) : oo(t3, n2, r2, false, s2, o2),
-                l2 = [];
-            return a2.length ? (t3.getSortedVisibleDatasetMetas().forEach((t4) => {
-                const e3 = a2[0].index,
-                    i3 = t4.data[e3];
-                i3 && !i3.skip && l2.push({
-                    element: i3,
-                    datasetIndex: t4.index,
-                    index: e3
-                });
-            }), l2) : [];
-        },
-        dataset(t3, e2, i2, s2) {
-            const n2 = yr(e2, t3),
-                r2 = i2.axis || "xy",
-                o2 = i2.includeInvisible || false;
-            let a2 = i2.intersect ? so(t3, n2, r2, s2, o2) : oo(t3, n2, r2, false, s2, o2);
-            if (a2.length > 0) {
-                const e3 = a2[0].datasetIndex,
-                    i3 = t3.getDatasetMeta(e3).data;
-                a2 = [];
-                for (let t4 = 0; t4 < i3.length; ++t4)
-                    a2.push({
-                        element: i3[t4],
-                        datasetIndex: e3,
-                        index: t4
-                    });
-            }
-            return a2;
-        },
-        point: (t3, e2, i2, s2) => so(t3, yr(e2, t3), i2.axis || "xy", s2, i2.includeInvisible || false),
-        nearest(t3, e2, i2, s2) {
-            const n2 = yr(e2, t3),
-                r2 = i2.axis || "xy",
-                o2 = i2.includeInvisible || false;
-            return oo(t3, n2, r2, i2.intersect, s2, o2);
-        },
-        x: (t3, e2, i2, s2) => ao(t3, yr(e2, t3), "x", i2.intersect, s2),
-        y: (t3, e2, i2, s2) => ao(t3, yr(e2, t3), "y", i2.intersect, s2)
-    }
-};
-const ho = ["left", "top", "right", "bottom"];
-
-function co(t3, e2) {
-    return t3.filter((t4) => t4.pos === e2);
-}
-
-function uo(t3, e2) {
-    return t3.filter((t4) => -1 === ho.indexOf(t4.pos) && t4.box.axis === e2);
-}
-
-function fo(t3, e2) {
-    return t3.sort((t4, i2) => {
-        const s2 = e2 ? i2 : t4,
-            n2 = e2 ? t4 : i2;
-        return s2.weight === n2.weight ? s2.index - n2.index : s2.weight - n2.weight;
-    });
-}
-
-function po(t3, e2) {
-    const i2 = function(t4) {
-            const e3 = {};
-            for (const i3 of t4) {
-                const {
-                    stack: t5,
-                    pos: s3,
-                    stackWeight: n3
-                } = i3;
-                if (!t5 || !ho.includes(s3))
-                    continue;
-                const r3 = e3[t5] || (e3[t5] = {
-                    count: 0,
-                    placed: 0,
-                    weight: 0,
-                    size: 0
-                });
-                r3.count++, r3.weight += n3;
-            }
-            return e3;
-        }(t3),
-        {
-            vBoxMaxWidth: s2,
-            hBoxMaxHeight: n2
-        } = e2;
-    let r2, o2, a2;
-    for (r2 = 0, o2 = t3.length; r2 < o2; ++r2) {
-        a2 = t3[r2];
-        const {
-            fullSize: o3
-        } = a2.box, l2 = i2[a2.stack], h2 = l2 && a2.stackWeight / l2.weight;
-        a2.horizontal ? (a2.width = h2 ? h2 * s2 : o3 && e2.availableWidth, a2.height = n2) : (a2.width = s2, a2.height = h2 ? h2 * n2 : o3 && e2.availableHeight);
-    }
-    return i2;
-}
-
-function mo(t3, e2, i2, s2) {
-    return Math.max(t3[i2], e2[i2]) + Math.max(t3[s2], e2[s2]);
-}
-
-function go(t3, e2) {
-    t3.top = Math.max(t3.top, e2.top), t3.left = Math.max(t3.left, e2.left), t3.bottom = Math.max(t3.bottom, e2.bottom), t3.right = Math.max(t3.right, e2.right);
-}
-
-function yo(t3, e2, i2, s2) {
-    const {
-        pos: n2,
-        box: r2
-    } = i2, o2 = t3.maxPadding;
-    if (!yi(n2)) {
-        i2.size && (t3[n2] -= i2.size);
-        const e3 = s2[i2.stack] || {
-            size: 0,
-            count: 1
-        };
-        e3.size = Math.max(e3.size, i2.horizontal ? r2.height : r2.width), i2.size = e3.size / e3.count, t3[n2] += i2.size;
-    }
-    r2.getPadding && go(o2, r2.getPadding());
-    const a2 = Math.max(0, e2.outerWidth - mo(o2, t3, "left", "right")),
-        l2 = Math.max(0, e2.outerHeight - mo(o2, t3, "top", "bottom")),
-        h2 = a2 !== t3.w,
-        c2 = l2 !== t3.h;
-    return t3.w = a2, t3.h = l2, i2.horizontal ? {
-        same: h2,
-        other: c2
-    } : {
-        same: c2,
-        other: h2
-    };
-}
-
-function vo(t3, e2) {
-    const i2 = e2.maxPadding;
-
-    function s2(t4) {
-        const s3 = {
-            left: 0,
-            top: 0,
-            right: 0,
-            bottom: 0
-        };
-        return t4.forEach((t5) => {
-            s3[t5] = Math.max(e2[t5], i2[t5]);
-        }), s3;
-    }
-    return s2(t3 ? ["left", "right"] : ["top", "bottom"]);
-}
-
-function bo(t3, e2, i2, s2) {
-    const n2 = [];
-    let r2, o2, a2, l2, h2, c2;
-    for (r2 = 0, o2 = t3.length, h2 = 0; r2 < o2; ++r2) {
-        a2 = t3[r2], l2 = a2.box, l2.update(a2.width || e2.w, a2.height || e2.h, vo(a2.horizontal, e2));
-        const {
-            same: o3,
-            other: u2
-        } = yo(e2, i2, a2, s2);
-        h2 |= o3 && n2.length, c2 = c2 || u2, l2.fullSize || n2.push(a2);
-    }
-    return h2 && bo(n2, e2, i2, s2) || c2;
-}
-
-function _o(t3, e2, i2, s2, n2) {
-    t3.top = i2, t3.left = e2, t3.right = e2 + s2, t3.bottom = i2 + n2, t3.width = s2, t3.height = n2;
-}
-
-function wo(t3, e2, i2, s2) {
-    const n2 = i2.padding;
-    let {
-        x: r2,
-        y: o2
-    } = e2;
-    for (const a2 of t3) {
-        const t4 = a2.box,
-            l2 = s2[a2.stack] || {
-                count: 1,
-                placed: 0,
-                weight: 1
-            },
-            h2 = a2.stackWeight / l2.weight || 1;
-        if (a2.horizontal) {
-            const s3 = e2.w * h2,
-                r3 = l2.size || t4.height;
-            qi(l2.start) && (o2 = l2.start), t4.fullSize ? _o(t4, n2.left, o2, i2.outerWidth - n2.right - n2.left, r3) : _o(t4, e2.left + l2.placed, o2, s3, r3), l2.start = o2, l2.placed += s3, o2 = t4.bottom;
-        } else {
-            const s3 = e2.h * h2,
-                o3 = l2.size || t4.width;
-            qi(l2.start) && (r2 = l2.start), t4.fullSize ? _o(t4, r2, n2.top, o3, i2.outerHeight - n2.bottom - n2.top) : _o(t4, r2, e2.top + l2.placed, o3, s3), l2.start = r2, l2.placed += s3, r2 = t4.right;
-        }
-    }
-    e2.x = r2, e2.y = o2;
-}
-var xo = {
-    addBox(t3, e2) {
-        t3.boxes || (t3.boxes = []), e2.fullSize = e2.fullSize || false, e2.position = e2.position || "top", e2.weight = e2.weight || 0, e2._layers = e2._layers || function() {
-            return [{
-                z: 0,
-                draw(t4) {
-                    e2.draw(t4);
-                }
-            }];
-        }, t3.boxes.push(e2);
-    },
-    removeBox(t3, e2) {
-        const i2 = t3.boxes ? t3.boxes.indexOf(e2) : -1; -
-        1 !== i2 && t3.boxes.splice(i2, 1);
-    },
-    configure(t3, e2, i2) {
-        e2.fullSize = i2.fullSize, e2.position = i2.position, e2.weight = i2.weight;
-    },
-    update(t3, e2, i2, s2) {
-        if (!t3)
-            return;
-        const n2 = Ln(t3.options.layout.padding),
-            r2 = Math.max(e2 - n2.width, 0),
-            o2 = Math.max(i2 - n2.height, 0),
-            a2 = function(t4) {
-                const e3 = function(t5) {
-                        const e4 = [];
-                        let i4, s4, n4, r4, o4, a4;
-                        for (i4 = 0, s4 = (t5 || []).length; i4 < s4; ++i4)
-                            n4 = t5[i4], {
-                                position: r4,
-                                options: {
-                                    stack: o4,
-                                    stackWeight: a4 = 1
-                                }
-                            } = n4, e4.push({
-                                index: i4,
-                                box: n4,
-                                pos: r4,
-                                horizontal: n4.isHorizontal(),
-                                weight: n4.weight,
-                                stack: o4 && r4 + o4,
-                                stackWeight: a4
-                            });
-                        return e4;
-                    }(t4),
-                    i3 = fo(e3.filter((t5) => t5.box.fullSize), true),
-                    s3 = fo(co(e3, "left"), true),
-                    n3 = fo(co(e3, "right")),
-                    r3 = fo(co(e3, "top"), true),
-                    o3 = fo(co(e3, "bottom")),
-                    a3 = uo(e3, "x"),
-                    l3 = uo(e3, "y");
-                return {
-                    fullSize: i3,
-                    leftAndTop: s3.concat(r3),
-                    rightAndBottom: n3.concat(l3).concat(o3).concat(a3),
-                    chartArea: co(e3, "chartArea"),
-                    vertical: s3.concat(n3).concat(l3),
-                    horizontal: r3.concat(o3).concat(a3)
-                };
-            }(t3.boxes),
-            l2 = a2.vertical,
-            h2 = a2.horizontal;
-        Ei(t3.boxes, (t4) => {
-            "function" == typeof t4.beforeLayout && t4.beforeLayout();
-        });
-        const c2 = l2.reduce((t4, e3) => e3.box.options && false === e3.box.options.display ? t4 : t4 + 1, 0) || 1,
-            u2 = Object.freeze({
-                outerWidth: e2,
-                outerHeight: i2,
-                padding: n2,
-                availableWidth: r2,
-                availableHeight: o2,
-                vBoxMaxWidth: r2 / 2 / c2,
-                hBoxMaxHeight: o2 / 2
-            }),
-            d2 = Object.assign({}, n2);
-        go(d2, Ln(s2));
-        const f2 = Object.assign({
-                maxPadding: d2,
-                w: r2,
-                h: o2,
-                x: n2.left,
-                y: n2.top
-            }, n2),
-            p2 = po(l2.concat(h2), u2);
-        bo(a2.fullSize, f2, u2, p2), bo(l2, f2, u2, p2), bo(h2, f2, u2, p2) && bo(l2, f2, u2, p2),
-            function(t4) {
-                const e3 = t4.maxPadding;
-
-                function i3(i4) {
-                    const s3 = Math.max(e3[i4] - t4[i4], 0);
-                    return t4[i4] += s3, s3;
-                }
-                t4.y += i3("top"), t4.x += i3("left"), i3("right"), i3("bottom");
-            }(f2), wo(a2.leftAndTop, f2, u2, p2), f2.x += f2.w, f2.y += f2.h, wo(a2.rightAndBottom, f2, u2, p2), t3.chartArea = {
-                left: f2.left,
-                top: f2.top,
-                right: f2.left + f2.w,
-                bottom: f2.top + f2.h,
-                height: f2.h,
-                width: f2.w
-            }, Ei(a2.chartArea, (e3) => {
-                const i3 = e3.box;
-                Object.assign(i3, t3.chartArea), i3.update(f2.w, f2.h, {
-                    left: 0,
-                    top: 0,
-                    right: 0,
-                    bottom: 0
-                });
-            });
-    }
-};
-class BasePlatform {
-    acquireContext(t3, e2) {}
-    releaseContext(t3) {
-        return false;
-    }
-    addEventListener(t3, e2, i2) {}
-    removeEventListener(t3, e2, i2) {}
-    getDevicePixelRatio() {
-        return 1;
-    }
-    getMaximumSize(t3, e2, i2, s2) {
-        return e2 = Math.max(0, e2 || t3.width), i2 = i2 || t3.height, {
-            width: e2,
-            height: Math.max(0, s2 ? Math.floor(e2 / s2) : i2)
-        };
-    }
-    isAttached(t3) {
-        return true;
-    }
-    updateConfig(t3) {}
-}
-class BasicPlatform extends BasePlatform {
-    acquireContext(t3) {
-        return t3 && t3.getContext && t3.getContext("2d") || null;
-    }
-    updateConfig(t3) {
-        t3.options.animation = false;
-    }
-}
-const ko = "$chartjs",
-    To = {
-        touchstart: "mousedown",
-        touchmove: "mousemove",
-        touchend: "mouseup",
-        pointerenter: "mouseenter",
-        pointerdown: "mousedown",
-        pointermove: "mousemove",
-        pointerup: "mouseup",
-        pointerleave: "mouseout",
-        pointerout: "mouseout"
-    },
-    So = (t3) => null === t3 || "" === t3;
-const Eo = !!wr && {
-    passive: true
-};
-
-function Co(t3, e2, i2) {
-    t3.canvas.removeEventListener(e2, i2, Eo);
-}
-
-function Io(t3, e2) {
-    for (const i2 of t3)
-        if (i2 === e2 || i2.contains(e2))
-            return true;
-}
-
-function Mo(t3, e2, i2) {
-    const s2 = t3.canvas,
-        n2 = new MutationObserver((t4) => {
-            let e3 = false;
-            for (const i3 of t4)
-                e3 = e3 || Io(i3.addedNodes, s2), e3 = e3 && !Io(i3.removedNodes, s2);
-            e3 && i2();
-        });
-    return n2.observe(document, {
-        childList: true,
-        subtree: true
-    }), n2;
-}
-
-function Po(t3, e2, i2) {
-    const s2 = t3.canvas,
-        n2 = new MutationObserver((t4) => {
-            let e3 = false;
-            for (const i3 of t4)
-                e3 = e3 || Io(i3.removedNodes, s2), e3 = e3 && !Io(i3.addedNodes, s2);
-            e3 && i2();
-        });
-    return n2.observe(document, {
-        childList: true,
-        subtree: true
-    }), n2;
-}
-const Ro = /* @__PURE__ */ new Map();
-let Ao = 0;
-
-function Do() {
-    const t3 = window.devicePixelRatio;
-    t3 !== Ao && (Ao = t3, Ro.forEach((e2, i2) => {
-        i2.currentDevicePixelRatio !== t3 && e2();
-    }));
-}
-
-function Lo(t3, e2, i2) {
-    const s2 = t3.canvas,
-        n2 = s2 && ur(s2);
-    if (!n2)
-        return;
-    const r2 = Is((t4, e3) => {
-            const s3 = n2.clientWidth;
-            i2(t4, e3), s3 < n2.clientWidth && i2();
-        }, window),
-        o2 = new ResizeObserver((t4) => {
-            const e3 = t4[0],
-                i3 = e3.contentRect.width,
-                s3 = e3.contentRect.height;
-            0 === i3 && 0 === s3 || r2(i3, s3);
-        });
-    return o2.observe(n2),
-        function(t4, e3) {
-            Ro.size || window.addEventListener("resize", Do), Ro.set(t4, e3);
-        }(t3, r2), o2;
-}
-
-function Oo(t3, e2, i2) {
-    i2 && i2.disconnect(), "resize" === e2 && function(t4) {
-        Ro.delete(t4), Ro.size || window.removeEventListener("resize", Do);
-    }(t3);
-}
-
-function Fo(t3, e2, i2) {
-    const s2 = t3.canvas,
-        n2 = Is((e3) => {
-            null !== t3.ctx && i2(function(t4, e4) {
-                const i3 = To[t4.type] || t4.type,
-                    {
-                        x: s3,
-                        y: n3
-                    } = yr(t4, e4);
-                return {
-                    type: i3,
-                    chart: e4,
-                    native: t4,
-                    x: void 0 !== s3 ? s3 : null,
-                    y: void 0 !== n3 ? n3 : null
-                };
-            }(e3, t3));
-        }, t3);
-    return function(t4, e3, i3) {
-        t4.addEventListener(e3, i3, Eo);
-    }(s2, e2, n2), n2;
-}
-class DomPlatform extends BasePlatform {
-    acquireContext(t3, e2) {
-        const i2 = t3 && t3.getContext && t3.getContext("2d");
-        return i2 && i2.canvas === t3 ? (function(t4, e3) {
-            const i3 = t4.style,
-                s2 = t4.getAttribute("height"),
-                n2 = t4.getAttribute("width");
-            if (t4[ko] = {
-                    initial: {
-                        height: s2,
-                        width: n2,
-                        style: {
-                            display: i3.display,
-                            height: i3.height,
-                            width: i3.width
-                        }
-                    }
-                }, i3.display = i3.display || "block", i3.boxSizing = i3.boxSizing || "border-box", So(n2)) {
-                const e4 = xr(t4, "width");
-                void 0 !== e4 && (t4.width = e4);
-            }
-            if (So(s2))
-                if ("" === t4.style.height)
-                    t4.height = t4.width / (e3 || 2);
-                else {
-                    const e4 = xr(t4, "height");
-                    void 0 !== e4 && (t4.height = e4);
-                }
-        }(t3, e2), i2) : null;
-    }
-    releaseContext(t3) {
-        const e2 = t3.canvas;
-        if (!e2[ko])
-            return false;
-        const i2 = e2[ko].initial;
-        ["height", "width"].forEach((t4) => {
-            const s3 = i2[t4];
-            ci(s3) ? e2.removeAttribute(t4) : e2.setAttribute(t4, s3);
-        });
-        const s2 = i2.style || {};
-        return Object.keys(s2).forEach((t4) => {
-            e2.style[t4] = s2[t4];
-        }), e2.width = e2.width, delete e2[ko], true;
-    }
-    addEventListener(t3, e2, i2) {
-        this.removeEventListener(t3, e2);
-        const s2 = t3.$proxies || (t3.$proxies = {}),
-            n2 = {
-                attach: Mo,
-                detach: Po,
-                resize: Lo
-            } [e2] || Fo;
-        s2[e2] = n2(t3, e2, i2);
-    }
-    removeEventListener(t3, e2) {
-        const i2 = t3.$proxies || (t3.$proxies = {}),
-            s2 = i2[e2];
-        if (!s2)
-            return;
-        ({
-            attach: Oo,
-            detach: Oo,
-            resize: Oo
-        } [e2] || Co)(t3, e2, s2), i2[e2] = void 0;
-    }
-    getDevicePixelRatio() {
-        return window.devicePixelRatio;
-    }
-    getMaximumSize(t3, e2, i2, s2) {
-        return br(t3, e2, i2, s2);
-    }
-    isAttached(t3) {
-        const e2 = ur(t3);
-        return !(!e2 || !e2.isConnected);
-    }
-}
-class Element {
-    constructor() {
-        __publicField(this, "x");
-        __publicField(this, "y");
-        __publicField(this, "active", false);
-        __publicField(this, "options");
-        __publicField(this, "$animations");
-    }
-    tooltipPosition(t3) {
-        const {
-            x: e2,
-            y: i2
-        } = this.getProps(["x", "y"], t3);
-        return {
-            x: e2,
-            y: i2
-        };
-    }
-    hasValue() {
-        return hs(this.x) && hs(this.y);
-    }
-    getProps(t3, e2) {
-        const i2 = this.$animations;
-        if (!e2 || !i2)
-            return this;
-        const s2 = {};
-        return t3.forEach((t4) => {
-            s2[t4] = i2[t4] && i2[t4].active() ? i2[t4]._to : this[t4];
-        }), s2;
-    }
-}
-__publicField(Element, "defaults", {});
-__publicField(Element, "defaultRoutes");
-
-function No(t3, e2) {
-    const i2 = t3.options.ticks,
-        s2 = function(t4) {
-            const e3 = t4.options.offset,
-                i3 = t4._tickSize(),
-                s3 = t4._length / i3 + (e3 ? 0 : 1),
-                n3 = t4._maxLength / i3;
-            return Math.floor(Math.min(s3, n3));
-        }(t3),
-        n2 = Math.min(i2.maxTicksLimit || s2, s2),
-        r2 = i2.major.enabled ? function(t4) {
-            const e3 = [];
-            let i3, s3;
-            for (i3 = 0, s3 = t4.length; i3 < s3; i3++)
-                t4[i3].major && e3.push(i3);
-            return e3;
-        }(e2) : [],
-        o2 = r2.length,
-        a2 = r2[0],
-        l2 = r2[o2 - 1],
-        h2 = [];
-    if (o2 > n2)
-        return function(t4, e3, i3, s3) {
-            let n3, r3 = 0,
-                o3 = i3[0];
-            for (s3 = Math.ceil(s3), n3 = 0; n3 < t4.length; n3++)
-                n3 === o3 && (e3.push(t4[n3]), r3++, o3 = i3[r3 * s3]);
-        }(e2, h2, r2, o2 / n2), h2;
-    const c2 = function(t4, e3, i3) {
-        const s3 = function(t5) {
-                const e4 = t5.length;
-                let i4, s4;
-                if (e4 < 2)
-                    return false;
-                for (s4 = t5[0], i4 = 1; i4 < e4; ++i4)
-                    if (t5[i4] - t5[i4 - 1] !== s4)
-                        return false;
-                return s4;
-            }(t4),
-            n3 = e3.length / i3;
-        if (!s3)
-            return Math.max(n3, 1);
-        const r3 = function(t5) {
-            const e4 = [],
-                i4 = Math.sqrt(t5);
-            let s4;
-            for (s4 = 1; s4 < i4; s4++)
-                t5 % s4 == 0 && (e4.push(s4), e4.push(t5 / s4));
-            return i4 === (0 | i4) && e4.push(i4), e4.sort((t6, e5) => t6 - e5).pop(), e4;
-        }(s3);
-        for (let t5 = 0, e4 = r3.length - 1; t5 < e4; t5++) {
-            const e5 = r3[t5];
-            if (e5 > n3)
-                return e5;
-        }
-        return Math.max(n3, 1);
-    }(r2, e2, n2);
-    if (o2 > 0) {
-        let t4, i3;
-        const s3 = o2 > 1 ? Math.round((l2 - a2) / (o2 - 1)) : null;
-        for ($o(e2, h2, c2, ci(s3) ? 0 : a2 - s3, a2), t4 = 0, i3 = o2 - 1; t4 < i3; t4++)
-            $o(e2, h2, c2, r2[t4], r2[t4 + 1]);
-        return $o(e2, h2, c2, l2, ci(s3) ? e2.length : l2 + s3), h2;
-    }
-    return $o(e2, h2, c2), h2;
-}
-
-function $o(t3, e2, i2, s2, n2) {
-    const r2 = Ti(s2, 0),
-        o2 = Math.min(Ti(n2, t3.length), t3.length);
-    let a2, l2, h2, c2 = 0;
-    for (i2 = Math.ceil(i2), n2 && (a2 = n2 - s2, i2 = a2 / Math.floor(a2 / i2)), h2 = r2; h2 < 0;)
-        c2++, h2 = Math.round(r2 + c2 * i2);
-    for (l2 = Math.max(r2, 0); l2 < o2; l2++)
-        l2 === h2 && (e2.push(t3[l2]), c2++, h2 = Math.round(r2 + c2 * i2));
-}
-const Vo = (t3, e2, i2) => "top" === e2 || "left" === e2 ? t3[e2] + i2 : t3[e2] - i2,
-    zo = (t3, e2) => Math.min(e2 || t3, t3);
-
-function Bo(t3, e2) {
-    const i2 = [],
-        s2 = t3.length / e2,
-        n2 = t3.length;
-    let r2 = 0;
-    for (; r2 < n2; r2 += s2)
-        i2.push(t3[Math.floor(r2)]);
-    return i2;
-}
-
-function Uo(t3, e2, i2) {
-    const s2 = t3.ticks.length,
-        n2 = Math.min(e2, s2 - 1),
-        r2 = t3._startPixel,
-        o2 = t3._endPixel,
-        a2 = 1e-6;
-    let l2, h2 = t3.getPixelForTick(n2);
-    if (!(i2 && (l2 = 1 === s2 ? Math.max(h2 - r2, o2 - h2) : 0 === e2 ? (t3.getPixelForTick(1) - h2) / 2 : (h2 - t3.getPixelForTick(n2 - 1)) / 2, h2 += n2 < e2 ? l2 : -l2, h2 < r2 - a2 || h2 > o2 + a2)))
-        return h2;
-}
-
-function jo(t3) {
-    return t3.drawTicks ? t3.tickLength : 0;
-}
-
-function Ho(t3, e2) {
-    if (!t3.display)
-        return 0;
-    const i2 = On(t3.font, e2),
-        s2 = Ln(t3.padding);
-    return (ui(t3.text) ? t3.text.length : 1) * i2.lineHeight + s2.height;
-}
-
-function Wo(t3, e2, i2) {
-    let s2 = ((t4) => "start" === t4 ? "left" : "end" === t4 ? "right" : "center")(t3);
-    return (i2 && "right" !== e2 || !i2 && "right" === e2) && (s2 = ((t4) => "left" === t4 ? "right" : "right" === t4 ? "left" : t4)(s2)), s2;
-}
-class Scale extends Element {
-    constructor(t3) {
-        super(), this.id = t3.id, this.type = t3.type, this.options = void 0, this.ctx = t3.ctx, this.chart = t3.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
-            left: 0,
-            right: 0,
-            top: 0,
-            bottom: 0
-        }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = false, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = false, this.$context = void 0;
-    }
-    init(t3) {
-        this.options = t3.setContext(this.getContext()), this.axis = t3.axis, this._userMin = this.parse(t3.min), this._userMax = this.parse(t3.max), this._suggestedMin = this.parse(t3.suggestedMin), this._suggestedMax = this.parse(t3.suggestedMax);
-    }
-    parse(t3, e2) {
-        return t3;
-    }
-    getUserBounds() {
-        let {
-            _userMin: t3,
-            _userMax: e2,
-            _suggestedMin: i2,
-            _suggestedMax: s2
-        } = this;
-        return t3 = ki(t3, Number.POSITIVE_INFINITY), e2 = ki(e2, Number.NEGATIVE_INFINITY), i2 = ki(i2, Number.POSITIVE_INFINITY), s2 = ki(s2, Number.NEGATIVE_INFINITY), {
-            min: ki(t3, i2),
-            max: ki(e2, s2),
-            minDefined: _i(t3),
-            maxDefined: _i(e2)
-        };
-    }
-    getMinMax(t3) {
-        let e2, {
-            min: i2,
-            max: s2,
-            minDefined: n2,
-            maxDefined: r2
-        } = this.getUserBounds();
-        if (n2 && r2)
-            return {
-                min: i2,
-                max: s2
-            };
-        const o2 = this.getMatchingVisibleMetas();
-        for (let a2 = 0, l2 = o2.length; a2 < l2; ++a2)
-            e2 = o2[a2].controller.getMinMax(this, t3), n2 || (i2 = Math.min(i2, e2.min)), r2 || (s2 = Math.max(s2, e2.max));
-        return i2 = r2 && i2 > s2 ? s2 : i2, s2 = n2 && i2 > s2 ? i2 : s2, {
-            min: ki(i2, ki(s2, i2)),
-            max: ki(s2, ki(i2, s2))
-        };
-    }
-    getPadding() {
-        return {
-            left: this.paddingLeft || 0,
-            top: this.paddingTop || 0,
-            right: this.paddingRight || 0,
-            bottom: this.paddingBottom || 0
-        };
-    }
-    getTicks() {
-        return this.ticks;
-    }
-    getLabels() {
-        const t3 = this.chart.data;
-        return this.options.labels || (this.isHorizontal() ? t3.xLabels : t3.yLabels) || t3.labels || [];
-    }
-    getLabelItems(t3 = this.chart.chartArea) {
-        return this._labelItems || (this._labelItems = this._computeLabelItems(t3));
-    }
-    beforeLayout() {
-        this._cache = {}, this._dataLimitsCached = false;
-    }
-    beforeUpdate() {
-        Si(this.options.beforeUpdate, [this]);
-    }
-    update(t3, e2, i2) {
-        const {
-            beginAtZero: s2,
-            grace: n2,
-            ticks: r2
-        } = this.options, o2 = r2.sampleSize;
-        this.beforeUpdate(), this.maxWidth = t3, this.maxHeight = e2, this._margins = i2 = Object.assign({
-            left: 0,
-            right: 0,
-            top: 0,
-            bottom: 0
-        }, i2), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + i2.left + i2.right : this.height + i2.top + i2.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = Nn(this, n2, s2), this._dataLimitsCached = true), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
-        const a2 = o2 < this.ticks.length;
-        this._convertTicksToLabels(a2 ? Bo(this.ticks, o2) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), r2.display && (r2.autoSkip || "auto" === r2.source) && (this.ticks = No(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), a2 && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
-    }
-    configure() {
-        let t3, e2, i2 = this.options.reverse;
-        this.isHorizontal() ? (t3 = this.left, e2 = this.right) : (t3 = this.top, e2 = this.bottom, i2 = !i2), this._startPixel = t3, this._endPixel = e2, this._reversePixels = i2, this._length = e2 - t3, this._alignToPixels = this.options.alignToPixels;
-    }
-    afterUpdate() {
-        Si(this.options.afterUpdate, [this]);
-    }
-    beforeSetDimensions() {
-        Si(this.options.beforeSetDimensions, [this]);
-    }
-    setDimensions() {
-        this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
-    }
-    afterSetDimensions() {
-        Si(this.options.afterSetDimensions, [this]);
-    }
-    _callHooks(t3) {
-        this.chart.notifyPlugins(t3, this.getContext()), Si(this.options[t3], [this]);
-    }
-    beforeDataLimits() {
-        this._callHooks("beforeDataLimits");
-    }
-    determineDataLimits() {}
-    afterDataLimits() {
-        this._callHooks("afterDataLimits");
-    }
-    beforeBuildTicks() {
-        this._callHooks("beforeBuildTicks");
-    }
-    buildTicks() {
-        return [];
-    }
-    afterBuildTicks() {
-        this._callHooks("afterBuildTicks");
-    }
-    beforeTickToLabelConversion() {
-        Si(this.options.beforeTickToLabelConversion, [this]);
-    }
-    generateTickLabels(t3) {
-        const e2 = this.options.ticks;
-        let i2, s2, n2;
-        for (i2 = 0, s2 = t3.length; i2 < s2; i2++)
-            n2 = t3[i2], n2.label = Si(e2.callback, [n2.value, i2, t3], this);
-    }
-    afterTickToLabelConversion() {
-        Si(this.options.afterTickToLabelConversion, [this]);
-    }
-    beforeCalculateLabelRotation() {
-        Si(this.options.beforeCalculateLabelRotation, [this]);
-    }
-    calculateLabelRotation() {
-        const t3 = this.options,
-            e2 = t3.ticks,
-            i2 = zo(this.ticks.length, t3.ticks.maxTicksLimit),
-            s2 = e2.minRotation || 0,
-            n2 = e2.maxRotation;
-        let r2, o2, a2, l2 = s2;
-        if (!this._isVisible() || !e2.display || s2 >= n2 || i2 <= 1 || !this.isHorizontal())
-            return void(this.labelRotation = s2);
-        const h2 = this._getLabelSizes(),
-            c2 = h2.widest.width,
-            u2 = h2.highest.height,
-            d2 = vs(this.chart.width - c2, 0, this.maxWidth);
-        r2 = t3.offset ? this.maxWidth / i2 : d2 / (i2 - 1), c2 + 6 > r2 && (r2 = d2 / (i2 - (t3.offset ? 0.5 : 1)), o2 = this.maxHeight - jo(t3.grid) - e2.padding - Ho(t3.title, this.chart.options.font), a2 = Math.sqrt(c2 * c2 + u2 * u2), l2 = ds(Math.min(Math.asin(vs((h2.highest.height + 6) / r2, -1, 1)), Math.asin(vs(o2 / a2, -1, 1)) - Math.asin(vs(u2 / a2, -1, 1)))), l2 = Math.max(s2, Math.min(n2, l2))), this.labelRotation = l2;
-    }
-    afterCalculateLabelRotation() {
-        Si(this.options.afterCalculateLabelRotation, [this]);
-    }
-    afterAutoSkip() {}
-    beforeFit() {
-        Si(this.options.beforeFit, [this]);
-    }
-    fit() {
-        const t3 = {
-                width: 0,
-                height: 0
-            },
-            {
-                chart: e2,
-                options: {
-                    ticks: i2,
-                    title: s2,
-                    grid: n2
-                }
-            } = this,
-            r2 = this._isVisible(),
-            o2 = this.isHorizontal();
-        if (r2) {
-            const r3 = Ho(s2, e2.options.font);
-            if (o2 ? (t3.width = this.maxWidth, t3.height = jo(n2) + r3) : (t3.height = this.maxHeight, t3.width = jo(n2) + r3), i2.display && this.ticks.length) {
-                const {
-                    first: e3,
-                    last: s3,
-                    widest: n3,
-                    highest: r4
-                } = this._getLabelSizes(), a2 = 2 * i2.padding, l2 = us(this.labelRotation), h2 = Math.cos(l2), c2 = Math.sin(l2);
-                if (o2) {
-                    const e4 = i2.mirror ? 0 : c2 * n3.width + h2 * r4.height;
-                    t3.height = Math.min(this.maxHeight, t3.height + e4 + a2);
-                } else {
-                    const e4 = i2.mirror ? 0 : h2 * n3.width + c2 * r4.height;
-                    t3.width = Math.min(this.maxWidth, t3.width + e4 + a2);
-                }
-                this._calculatePadding(e3, s3, c2, h2);
-            }
-        }
-        this._handleMargins(), o2 ? (this.width = this._length = e2.width - this._margins.left - this._margins.right, this.height = t3.height) : (this.width = t3.width, this.height = this._length = e2.height - this._margins.top - this._margins.bottom);
-    }
-    _calculatePadding(t3, e2, i2, s2) {
-        const {
-            ticks: {
-                align: n2,
-                padding: r2
-            },
-            position: o2
-        } = this.options, a2 = 0 !== this.labelRotation, l2 = "top" !== o2 && "x" === this.axis;
-        if (this.isHorizontal()) {
-            const o3 = this.getPixelForTick(0) - this.left,
-                h2 = this.right - this.getPixelForTick(this.ticks.length - 1);
-            let c2 = 0,
-                u2 = 0;
-            a2 ? l2 ? (c2 = s2 * t3.width, u2 = i2 * e2.height) : (c2 = i2 * t3.height, u2 = s2 * e2.width) : "start" === n2 ? u2 = e2.width : "end" === n2 ? c2 = t3.width : "inner" !== n2 && (c2 = t3.width / 2, u2 = e2.width / 2), this.paddingLeft = Math.max((c2 - o3 + r2) * this.width / (this.width - o3), 0), this.paddingRight = Math.max((u2 - h2 + r2) * this.width / (this.width - h2), 0);
-        } else {
-            let i3 = e2.height / 2,
-                s3 = t3.height / 2;
-            "start" === n2 ? (i3 = 0, s3 = t3.height) : "end" === n2 && (i3 = e2.height, s3 = 0), this.paddingTop = i3 + r2, this.paddingBottom = s3 + r2;
-        }
-    }
-    _handleMargins() {
-        this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
-    }
-    afterFit() {
-        Si(this.options.afterFit, [this]);
-    }
-    isHorizontal() {
-        const {
-            axis: t3,
-            position: e2
-        } = this.options;
-        return "top" === e2 || "bottom" === e2 || "x" === t3;
-    }
-    isFullSize() {
-        return this.options.fullSize;
-    }
-    _convertTicksToLabels(t3) {
-        let e2, i2;
-        for (this.beforeTickToLabelConversion(), this.generateTickLabels(t3), e2 = 0, i2 = t3.length; e2 < i2; e2++)
-            ci(t3[e2].label) && (t3.splice(e2, 1), i2--, e2--);
-        this.afterTickToLabelConversion();
-    }
-    _getLabelSizes() {
-        let t3 = this._labelSizes;
-        if (!t3) {
-            const e2 = this.options.ticks.sampleSize;
-            let i2 = this.ticks;
-            e2 < i2.length && (i2 = Bo(i2, e2)), this._labelSizes = t3 = this._computeLabelSizes(i2, i2.length, this.options.ticks.maxTicksLimit);
-        }
-        return t3;
-    }
-    _computeLabelSizes(t3, e2, i2) {
-        const {
-            ctx: s2,
-            _longestTextCache: n2
-        } = this, r2 = [], o2 = [], a2 = Math.floor(e2 / zo(e2, i2));
-        let l2, h2, c2, u2, d2, f2, p2, m2, g2, y2, v2, b2 = 0,
-            _2 = 0;
-        for (l2 = 0; l2 < e2; l2 += a2) {
-            if (u2 = t3[l2].label, d2 = this._resolveTickFontOptions(l2), s2.font = f2 = d2.string, p2 = n2[f2] = n2[f2] || {
-                    data: {},
-                    gc: []
-                }, m2 = d2.lineHeight, g2 = y2 = 0, ci(u2) || ui(u2)) {
-                if (ui(u2))
-                    for (h2 = 0, c2 = u2.length; h2 < c2; ++h2)
-                        v2 = u2[h2], ci(v2) || ui(v2) || (g2 = Zs(s2, p2.data, p2.gc, g2, v2), y2 += m2);
-            } else
-                g2 = Zs(s2, p2.data, p2.gc, g2, u2), y2 = m2;
-            r2.push(g2), o2.push(y2), b2 = Math.max(g2, b2), _2 = Math.max(y2, _2);
-        }! function(t4, e3) {
-            Ei(t4, (t5) => {
-                const i3 = t5.gc,
-                    s3 = i3.length / 2;
-                let n3;
-                if (s3 > e3) {
-                    for (n3 = 0; n3 < s3; ++n3)
-                        delete t5.data[i3[n3]];
-                    i3.splice(0, s3);
-                }
-            });
-        }(n2, e2);
-        const w2 = r2.indexOf(b2),
-            x2 = o2.indexOf(_2),
-            k2 = (t4) => ({
-                width: r2[t4] || 0,
-                height: o2[t4] || 0
-            });
-        return {
-            first: k2(0),
-            last: k2(e2 - 1),
-            widest: k2(w2),
-            highest: k2(x2),
-            widths: r2,
-            heights: o2
-        };
-    }
-    getLabelForValue(t3) {
-        return t3;
-    }
-    getPixelForValue(t3, e2) {
-        return NaN;
-    }
-    getValueForPixel(t3) {}
-    getPixelForTick(t3) {
-        const e2 = this.ticks;
-        return t3 < 0 || t3 > e2.length - 1 ? null : this.getPixelForValue(e2[t3].value);
-    }
-    getPixelForDecimal(t3) {
-        this._reversePixels && (t3 = 1 - t3);
-        const e2 = this._startPixel + t3 * this._length;
-        return vs(this._alignToPixels ? tn(this.chart, e2, 0) : e2, -32768, 32767);
-    }
-    getDecimalForPixel(t3) {
-        const e2 = (t3 - this._startPixel) / this._length;
-        return this._reversePixels ? 1 - e2 : e2;
-    }
-    getBasePixel() {
-        return this.getPixelForValue(this.getBaseValue());
-    }
-    getBaseValue() {
-        const {
-            min: t3,
-            max: e2
-        } = this;
-        return t3 < 0 && e2 < 0 ? e2 : t3 > 0 && e2 > 0 ? t3 : 0;
-    }
-    getContext(t3) {
-        const e2 = this.ticks || [];
-        if (t3 >= 0 && t3 < e2.length) {
-            const i2 = e2[t3];
-            return i2.$context || (i2.$context = function(t4, e3, i3) {
-                return $n(t4, {
-                    tick: i3,
-                    index: e3,
-                    type: "tick"
-                });
-            }(this.getContext(), t3, i2));
-        }
-        return this.$context || (this.$context = function(t4, e3) {
-            return $n(t4, {
-                scale: e3,
-                type: "scale"
-            });
-        }(this.chart.getContext(), this));
-    }
-    _tickSize() {
-        const t3 = this.options.ticks,
-            e2 = us(this.labelRotation),
-            i2 = Math.abs(Math.cos(e2)),
-            s2 = Math.abs(Math.sin(e2)),
-            n2 = this._getLabelSizes(),
-            r2 = t3.autoSkipPadding || 0,
-            o2 = n2 ? n2.widest.width + r2 : 0,
-            a2 = n2 ? n2.highest.height + r2 : 0;
-        return this.isHorizontal() ? a2 * i2 > o2 * s2 ? o2 / i2 : a2 / s2 : a2 * s2 < o2 * i2 ? a2 / i2 : o2 / s2;
-    }
-    _isVisible() {
-        const t3 = this.options.display;
-        return "auto" !== t3 ? !!t3 : this.getMatchingVisibleMetas().length > 0;
-    }
-    _computeGridLineItems(t3) {
-        const e2 = this.axis,
-            i2 = this.chart,
-            s2 = this.options,
-            {
-                grid: n2,
-                position: r2,
-                border: o2
-            } = s2,
-            a2 = n2.offset,
-            l2 = this.isHorizontal(),
-            h2 = this.ticks.length + (a2 ? 1 : 0),
-            c2 = jo(n2),
-            u2 = [],
-            d2 = o2.setContext(this.getContext()),
-            f2 = d2.display ? d2.width : 0,
-            p2 = f2 / 2,
-            m2 = function(t4) {
-                return tn(i2, t4, f2);
-            };
-        let g2, y2, v2, b2, _2, w2, x2, k2, T2, S2, E2, C2;
-        if ("top" === r2)
-            g2 = m2(this.bottom), w2 = this.bottom - c2, k2 = g2 - p2, S2 = m2(t3.top) + p2, C2 = t3.bottom;
-        else if ("bottom" === r2)
-            g2 = m2(this.top), S2 = t3.top, C2 = m2(t3.bottom) - p2, w2 = g2 + p2, k2 = this.top + c2;
-        else if ("left" === r2)
-            g2 = m2(this.right), _2 = this.right - c2, x2 = g2 - p2, T2 = m2(t3.left) + p2, E2 = t3.right;
-        else if ("right" === r2)
-            g2 = m2(this.left), T2 = t3.left, E2 = m2(t3.right) - p2, _2 = g2 + p2, x2 = this.left + c2;
-        else if ("x" === e2) {
-            if ("center" === r2)
-                g2 = m2((t3.top + t3.bottom) / 2 + 0.5);
-            else if (yi(r2)) {
-                const t4 = Object.keys(r2)[0],
-                    e3 = r2[t4];
-                g2 = m2(this.chart.scales[t4].getPixelForValue(e3));
-            }
-            S2 = t3.top, C2 = t3.bottom, w2 = g2 + p2, k2 = w2 + c2;
-        } else if ("y" === e2) {
-            if ("center" === r2)
-                g2 = m2((t3.left + t3.right) / 2);
-            else if (yi(r2)) {
-                const t4 = Object.keys(r2)[0],
-                    e3 = r2[t4];
-                g2 = m2(this.chart.scales[t4].getPixelForValue(e3));
-            }
-            _2 = g2 - p2, x2 = _2 - c2, T2 = t3.left, E2 = t3.right;
-        }
-        const P2 = Ti(s2.ticks.maxTicksLimit, h2),
-            R2 = Math.max(1, Math.ceil(h2 / P2));
-        for (y2 = 0; y2 < h2; y2 += R2) {
-            const t4 = this.getContext(y2),
-                e3 = n2.setContext(t4),
-                s3 = o2.setContext(t4),
-                r3 = e3.lineWidth,
-                h3 = e3.color,
-                c3 = s3.dash || [],
-                d3 = s3.dashOffset,
-                f3 = e3.tickWidth,
-                p3 = e3.tickColor,
-                m3 = e3.tickBorderDash || [],
-                g3 = e3.tickBorderDashOffset;
-            v2 = Uo(this, y2, a2), void 0 !== v2 && (b2 = tn(i2, v2, r3), l2 ? _2 = x2 = T2 = E2 = b2 : w2 = k2 = S2 = C2 = b2, u2.push({
-                tx1: _2,
-                ty1: w2,
-                tx2: x2,
-                ty2: k2,
-                x1: T2,
-                y1: S2,
-                x2: E2,
-                y2: C2,
-                width: r3,
-                color: h3,
-                borderDash: c3,
-                borderDashOffset: d3,
-                tickWidth: f3,
-                tickColor: p3,
-                tickBorderDash: m3,
-                tickBorderDashOffset: g3
-            }));
-        }
-        return this._ticksLength = h2, this._borderValue = g2, u2;
-    }
-    _computeLabelItems(t3) {
-        const e2 = this.axis,
-            i2 = this.options,
-            {
-                position: s2,
-                ticks: n2
-            } = i2,
-            r2 = this.isHorizontal(),
-            o2 = this.ticks,
-            {
-                align: a2,
-                crossAlign: l2,
-                padding: h2,
-                mirror: c2
-            } = n2,
-            u2 = jo(i2.grid),
-            d2 = u2 + h2,
-            f2 = c2 ? -h2 : d2,
-            p2 = -us(this.labelRotation),
-            m2 = [];
-        let g2, y2, v2, b2, _2, w2, x2, k2, T2, S2, E2, C2, P2 = "middle";
-        if ("top" === s2)
-            w2 = this.bottom - f2, x2 = this._getXAxisLabelAlignment();
-        else if ("bottom" === s2)
-            w2 = this.top + f2, x2 = this._getXAxisLabelAlignment();
-        else if ("left" === s2) {
-            const t4 = this._getYAxisLabelAlignment(u2);
-            x2 = t4.textAlign, _2 = t4.x;
-        } else if ("right" === s2) {
-            const t4 = this._getYAxisLabelAlignment(u2);
-            x2 = t4.textAlign, _2 = t4.x;
-        } else if ("x" === e2) {
-            if ("center" === s2)
-                w2 = (t3.top + t3.bottom) / 2 + d2;
-            else if (yi(s2)) {
-                const t4 = Object.keys(s2)[0],
-                    e3 = s2[t4];
-                w2 = this.chart.scales[t4].getPixelForValue(e3) + d2;
-            }
-            x2 = this._getXAxisLabelAlignment();
-        } else if ("y" === e2) {
-            if ("center" === s2)
-                _2 = (t3.left + t3.right) / 2 - d2;
-            else if (yi(s2)) {
-                const t4 = Object.keys(s2)[0],
-                    e3 = s2[t4];
-                _2 = this.chart.scales[t4].getPixelForValue(e3);
-            }
-            x2 = this._getYAxisLabelAlignment(u2).textAlign;
-        }
-        "y" === e2 && ("start" === a2 ? P2 = "top" : "end" === a2 && (P2 = "bottom"));
-        const R2 = this._getLabelSizes();
-        for (g2 = 0, y2 = o2.length; g2 < y2; ++g2) {
-            v2 = o2[g2], b2 = v2.label;
-            const t4 = n2.setContext(this.getContext(g2));
-            k2 = this.getPixelForTick(g2) + n2.labelOffset, T2 = this._resolveTickFontOptions(g2), S2 = T2.lineHeight, E2 = ui(b2) ? b2.length : 1;
-            const e3 = E2 / 2,
-                i3 = t4.color,
-                a3 = t4.textStrokeColor,
-                h3 = t4.textStrokeWidth;
-            let u3, d3 = x2;
-            if (r2 ? (_2 = k2, "inner" === x2 && (d3 = g2 === y2 - 1 ? this.options.reverse ? "left" : "right" : 0 === g2 ? this.options.reverse ? "right" : "left" : "center"), C2 = "top" === s2 ? "near" === l2 || 0 !== p2 ? -E2 * S2 + S2 / 2 : "center" === l2 ? -R2.highest.height / 2 - e3 * S2 + S2 : -R2.highest.height + S2 / 2 : "near" === l2 || 0 !== p2 ? S2 / 2 : "center" === l2 ? R2.highest.height / 2 - e3 * S2 : R2.highest.height - E2 * S2, c2 && (C2 *= -1), 0 === p2 || t4.showLabelBackdrop || (_2 += S2 / 2 * Math.sin(p2))) : (w2 = k2, C2 = (1 - E2) * S2 / 2), t4.showLabelBackdrop) {
-                const e4 = Ln(t4.backdropPadding),
-                    i4 = R2.heights[g2],
-                    s3 = R2.widths[g2];
-                let n3 = C2 - e4.top,
-                    r3 = 0 - e4.left;
-                switch (P2) {
-                    case "middle":
-                        n3 -= i4 / 2;
-                        break;
-                    case "bottom":
-                        n3 -= i4;
-                }
-                switch (x2) {
-                    case "center":
-                        r3 -= s3 / 2;
-                        break;
-                    case "right":
-                        r3 -= s3;
-                }
-                u3 = {
-                    left: r3,
-                    top: n3,
-                    width: s3 + e4.width,
-                    height: i4 + e4.height,
-                    color: t4.backdropColor
-                };
-            }
-            m2.push({
-                label: b2,
-                font: T2,
-                textOffset: C2,
-                options: {
-                    rotation: p2,
-                    color: i3,
-                    strokeColor: a3,
-                    strokeWidth: h3,
-                    textAlign: d3,
-                    textBaseline: P2,
-                    translation: [_2, w2],
-                    backdrop: u3
-                }
-            });
-        }
-        return m2;
-    }
-    _getXAxisLabelAlignment() {
-        const {
-            position: t3,
-            ticks: e2
-        } = this.options;
-        if (-us(this.labelRotation))
-            return "top" === t3 ? "left" : "right";
-        let i2 = "center";
-        return "start" === e2.align ? i2 = "left" : "end" === e2.align ? i2 = "right" : "inner" === e2.align && (i2 = "inner"), i2;
-    }
-    _getYAxisLabelAlignment(t3) {
-        const {
-            position: e2,
-            ticks: {
-                crossAlign: i2,
-                mirror: s2,
-                padding: n2
-            }
-        } = this.options, r2 = t3 + n2, o2 = this._getLabelSizes().widest.width;
-        let a2, l2;
-        return "left" === e2 ? s2 ? (l2 = this.right + n2, "near" === i2 ? a2 = "left" : "center" === i2 ? (a2 = "center", l2 += o2 / 2) : (a2 = "right", l2 += o2)) : (l2 = this.right - r2, "near" === i2 ? a2 = "right" : "center" === i2 ? (a2 = "center", l2 -= o2 / 2) : (a2 = "left", l2 = this.left)) : "right" === e2 ? s2 ? (l2 = this.left + n2, "near" === i2 ? a2 = "right" : "center" === i2 ? (a2 = "center", l2 -= o2 / 2) : (a2 = "left", l2 -= o2)) : (l2 = this.left + r2, "near" === i2 ? a2 = "left" : "center" === i2 ? (a2 = "center", l2 += o2 / 2) : (a2 = "right", l2 = this.right)) : a2 = "right", {
-            textAlign: a2,
-            x: l2
-        };
-    }
-    _computeLabelArea() {
-        if (this.options.ticks.mirror)
-            return;
-        const t3 = this.chart,
-            e2 = this.options.position;
-        return "left" === e2 || "right" === e2 ? {
-            top: 0,
-            left: this.left,
-            bottom: t3.height,
-            right: this.right
-        } : "top" === e2 || "bottom" === e2 ? {
-            top: this.top,
-            left: 0,
-            bottom: this.bottom,
-            right: t3.width
-        } : void 0;
-    }
-    drawBackground() {
-        const {
-            ctx: t3,
-            options: {
-                backgroundColor: e2
-            },
-            left: i2,
-            top: s2,
-            width: n2,
-            height: r2
-        } = this;
-        e2 && (t3.save(), t3.fillStyle = e2, t3.fillRect(i2, s2, n2, r2), t3.restore());
-    }
-    getLineWidthForValue(t3) {
-        const e2 = this.options.grid;
-        if (!this._isVisible() || !e2.display)
-            return 0;
-        const i2 = this.ticks.findIndex((e3) => e3.value === t3);
-        if (i2 >= 0) {
-            return e2.setContext(this.getContext(i2)).lineWidth;
-        }
-        return 0;
-    }
-    drawGrid(t3) {
-        const e2 = this.options.grid,
-            i2 = this.ctx,
-            s2 = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t3));
-        let n2, r2;
-        const o2 = (t4, e3, s3) => {
-            s3.width && s3.color && (i2.save(), i2.lineWidth = s3.width, i2.strokeStyle = s3.color, i2.setLineDash(s3.borderDash || []), i2.lineDashOffset = s3.borderDashOffset, i2.beginPath(), i2.moveTo(t4.x, t4.y), i2.lineTo(e3.x, e3.y), i2.stroke(), i2.restore());
-        };
-        if (e2.display)
-            for (n2 = 0, r2 = s2.length; n2 < r2; ++n2) {
-                const t4 = s2[n2];
-                e2.drawOnChartArea && o2({
-                    x: t4.x1,
-                    y: t4.y1
-                }, {
-                    x: t4.x2,
-                    y: t4.y2
-                }, t4), e2.drawTicks && o2({
-                    x: t4.tx1,
-                    y: t4.ty1
-                }, {
-                    x: t4.tx2,
-                    y: t4.ty2
-                }, {
-                    color: t4.tickColor,
-                    width: t4.tickWidth,
-                    borderDash: t4.tickBorderDash,
-                    borderDashOffset: t4.tickBorderDashOffset
-                });
-            }
-    }
-    drawBorder() {
-        const {
-            chart: t3,
-            ctx: e2,
-            options: {
-                border: i2,
-                grid: s2
-            }
-        } = this, n2 = i2.setContext(this.getContext()), r2 = i2.display ? n2.width : 0;
-        if (!r2)
-            return;
-        const o2 = s2.setContext(this.getContext(0)).lineWidth,
-            a2 = this._borderValue;
-        let l2, h2, c2, u2;
-        this.isHorizontal() ? (l2 = tn(t3, this.left, r2) - r2 / 2, h2 = tn(t3, this.right, o2) + o2 / 2, c2 = u2 = a2) : (c2 = tn(t3, this.top, r2) - r2 / 2, u2 = tn(t3, this.bottom, o2) + o2 / 2, l2 = h2 = a2), e2.save(), e2.lineWidth = n2.width, e2.strokeStyle = n2.color, e2.beginPath(), e2.moveTo(l2, c2), e2.lineTo(h2, u2), e2.stroke(), e2.restore();
-    }
-    drawLabels(t3) {
-        if (!this.options.ticks.display)
-            return;
-        const e2 = this.ctx,
-            i2 = this._computeLabelArea();
-        i2 && ln(e2, i2);
-        const s2 = this.getLabelItems(t3);
-        for (const t4 of s2) {
-            const i3 = t4.options,
-                s3 = t4.font;
-            vn(e2, t4.label, 0, t4.textOffset, s3, i3);
-        }
-        i2 && un(e2);
-    }
-    drawTitle() {
-        const {
-            ctx: t3,
-            options: {
-                position: e2,
-                title: i2,
-                reverse: s2
-            }
-        } = this;
-        if (!i2.display)
-            return;
-        const n2 = On(i2.font),
-            r2 = Ln(i2.padding),
-            o2 = i2.align;
-        let a2 = n2.lineHeight / 2;
-        "bottom" === e2 || "center" === e2 || yi(e2) ? (a2 += r2.bottom, ui(i2.text) && (a2 += n2.lineHeight * (i2.text.length - 1))) : a2 += r2.top;
-        const {
-            titleX: l2,
-            titleY: h2,
-            maxWidth: c2,
-            rotation: u2
-        } = function(t4, e3, i3, s3) {
-            const {
-                top: n3,
-                left: r3,
-                bottom: o3,
-                right: a3,
-                chart: l3
-            } = t4, {
-                chartArea: h3,
-                scales: c3
-            } = l3;
-            let u3, d2, f2, p2 = 0;
-            const m2 = o3 - n3,
-                g2 = a3 - r3;
-            if (t4.isHorizontal()) {
-                if (d2 = Ms(s3, r3, a3), yi(i3)) {
-                    const t5 = Object.keys(i3)[0],
-                        s4 = i3[t5];
-                    f2 = c3[t5].getPixelForValue(s4) + m2 - e3;
-                } else
-                    f2 = "center" === i3 ? (h3.bottom + h3.top) / 2 + m2 - e3 : Vo(t4, i3, e3);
-                u3 = a3 - r3;
-            } else {
-                if (yi(i3)) {
-                    const t5 = Object.keys(i3)[0],
-                        s4 = i3[t5];
-                    d2 = c3[t5].getPixelForValue(s4) - g2 + e3;
-                } else
-                    d2 = "center" === i3 ? (h3.left + h3.right) / 2 - g2 + e3 : Vo(t4, i3, e3);
-                f2 = Ms(s3, o3, n3), p2 = "left" === i3 ? -is : is;
-            }
-            return {
-                titleX: d2,
-                titleY: f2,
-                maxWidth: u3,
-                rotation: p2
-            };
-        }(this, a2, e2, o2);
-        vn(t3, i2.text, 0, 0, n2, {
-            color: i2.color,
-            maxWidth: c2,
-            rotation: u2,
-            textAlign: Wo(o2, e2, s2),
-            textBaseline: "middle",
-            translation: [l2, h2]
-        });
-    }
-    draw(t3) {
-        this._isVisible() && (this.drawBackground(), this.drawGrid(t3), this.drawBorder(), this.drawTitle(), this.drawLabels(t3));
-    }
-    _layers() {
-        const t3 = this.options,
-            e2 = t3.ticks && t3.ticks.z || 0,
-            i2 = Ti(t3.grid && t3.grid.z, -1),
-            s2 = Ti(t3.border && t3.border.z, 0);
-        return this._isVisible() && this.draw === Scale.prototype.draw ? [{
-            z: i2,
-            draw: (t4) => {
-                this.drawBackground(), this.drawGrid(t4), this.drawTitle();
-            }
-        }, {
-            z: s2,
-            draw: () => {
-                this.drawBorder();
-            }
-        }, {
-            z: e2,
-            draw: (t4) => {
-                this.drawLabels(t4);
-            }
-        }] : [{
-            z: e2,
-            draw: (t4) => {
-                this.draw(t4);
-            }
-        }];
-    }
-    getMatchingVisibleMetas(t3) {
-        const e2 = this.chart.getSortedVisibleDatasetMetas(),
-            i2 = this.axis + "AxisID",
-            s2 = [];
-        let n2, r2;
-        for (n2 = 0, r2 = e2.length; n2 < r2; ++n2) {
-            const r3 = e2[n2];
-            r3[i2] !== this.id || t3 && r3.type !== t3 || s2.push(r3);
-        }
-        return s2;
-    }
-    _resolveTickFontOptions(t3) {
-        return On(this.options.ticks.setContext(this.getContext(t3)).font);
-    }
-    _maxDigits() {
-        const t3 = this._resolveTickFontOptions(0).lineHeight;
-        return (this.isHorizontal() ? this.width : this.height) / t3;
-    }
-}
-class TypedRegistry {
-    constructor(t3, e2, i2) {
-        this.type = t3, this.scope = e2, this.override = i2, this.items = /* @__PURE__ */ Object.create(null);
-    }
-    isForType(t3) {
-        return Object.prototype.isPrototypeOf.call(this.type.prototype, t3.prototype);
-    }
-    register(t3) {
-        const e2 = Object.getPrototypeOf(t3);
-        let i2;
-        (function(t4) {
-            return "id" in t4 && "defaults" in t4;
-        })(e2) && (i2 = this.register(e2));
-        const s2 = this.items,
-            n2 = t3.id,
-            r2 = this.scope + "." + n2;
-        if (!n2)
-            throw new Error("class does not have id: " + t3);
-        return n2 in s2 || (s2[n2] = t3, function(t4, e3, i3) {
-            const s3 = Ni( /* @__PURE__ */ Object.create(null), [i3 ? Js.get(i3) : {}, Js.get(e3), t4.defaults]);
-            Js.set(e3, s3), t4.defaultRoutes && function(t5, e4) {
-                Object.keys(e4).forEach((i4) => {
-                    const s4 = i4.split("."),
-                        n3 = s4.pop(),
-                        r3 = [t5].concat(s4).join("."),
-                        o2 = e4[i4].split("."),
-                        a2 = o2.pop(),
-                        l2 = o2.join(".");
-                    Js.route(r3, n3, l2, a2);
-                });
-            }(e3, t4.defaultRoutes);
-            t4.descriptors && Js.describe(e3, t4.descriptors);
-        }(t3, r2, i2), this.override && Js.override(t3.id, t3.overrides)), r2;
-    }
-    get(t3) {
-        return this.items[t3];
-    }
-    unregister(t3) {
-        const e2 = this.items,
-            i2 = t3.id,
-            s2 = this.scope;
-        i2 in e2 && delete e2[i2], s2 && i2 in Js[s2] && (delete Js[s2][i2], this.override && delete Gs[i2]);
-    }
-}
-class Registry {
-    constructor() {
-        this.controllers = new TypedRegistry(DatasetController, "datasets", true), this.elements = new TypedRegistry(Element, "elements"), this.plugins = new TypedRegistry(Object, "plugins"), this.scales = new TypedRegistry(Scale, "scales"), this._typedRegistries = [this.controllers, this.scales, this.elements];
-    }
-    add(...t3) {
-        this._each("register", t3);
-    }
-    remove(...t3) {
-        this._each("unregister", t3);
-    }
-    addControllers(...t3) {
-        this._each("register", t3, this.controllers);
-    }
-    addElements(...t3) {
-        this._each("register", t3, this.elements);
-    }
-    addPlugins(...t3) {
-        this._each("register", t3, this.plugins);
-    }
-    addScales(...t3) {
-        this._each("register", t3, this.scales);
-    }
-    getController(t3) {
-        return this._get(t3, this.controllers, "controller");
-    }
-    getElement(t3) {
-        return this._get(t3, this.elements, "element");
-    }
-    getPlugin(t3) {
-        return this._get(t3, this.plugins, "plugin");
-    }
-    getScale(t3) {
-        return this._get(t3, this.scales, "scale");
-    }
-    removeControllers(...t3) {
-        this._each("unregister", t3, this.controllers);
-    }
-    removeElements(...t3) {
-        this._each("unregister", t3, this.elements);
-    }
-    removePlugins(...t3) {
-        this._each("unregister", t3, this.plugins);
-    }
-    removeScales(...t3) {
-        this._each("unregister", t3, this.scales);
-    }
-    _each(t3, e2, i2) {
-        [...e2].forEach((e3) => {
-            const s2 = i2 || this._getRegistryForType(e3);
-            i2 || s2.isForType(e3) || s2 === this.plugins && e3.id ? this._exec(t3, s2, e3) : Ei(e3, (e4) => {
-                const s3 = i2 || this._getRegistryForType(e4);
-                this._exec(t3, s3, e4);
-            });
-        });
-    }
-    _exec(t3, e2, i2) {
-        const s2 = Wi(t3);
-        Si(i2["before" + s2], [], i2), e2[t3](i2), Si(i2["after" + s2], [], i2);
-    }
-    _getRegistryForType(t3) {
-        for (let e2 = 0; e2 < this._typedRegistries.length; e2++) {
-            const i2 = this._typedRegistries[e2];
-            if (i2.isForType(t3))
-                return i2;
-        }
-        return this.plugins;
-    }
-    _get(t3, e2, i2) {
-        const s2 = e2.get(t3);
-        if (void 0 === s2)
-            throw new Error('"' + t3 + '" is not a registered ' + i2 + ".");
-        return s2;
-    }
-}
-var qo = new Registry();
-class PluginService {
-    constructor() {
-        this._init = [];
-    }
-    notify(t3, e2, i2, s2) {
-        "beforeInit" === e2 && (this._init = this._createDescriptors(t3, true), this._notify(this._init, t3, "install"));
-        const n2 = s2 ? this._descriptors(t3).filter(s2) : this._descriptors(t3),
-            r2 = this._notify(n2, t3, e2, i2);
-        return "afterDestroy" === e2 && (this._notify(n2, t3, "stop"), this._notify(this._init, t3, "uninstall")), r2;
-    }
-    _notify(t3, e2, i2, s2) {
-        s2 = s2 || {};
-        for (const n2 of t3) {
-            const t4 = n2.plugin;
-            if (false === Si(t4[i2], [e2, s2, n2.options], t4) && s2.cancelable)
-                return false;
-        }
-        return true;
-    }
-    invalidate() {
-        ci(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
-    }
-    _descriptors(t3) {
-        if (this._cache)
-            return this._cache;
-        const e2 = this._cache = this._createDescriptors(t3);
-        return this._notifyStateChanges(t3), e2;
-    }
-    _createDescriptors(t3, e2) {
-        const i2 = t3 && t3.config,
-            s2 = Ti(i2.options && i2.options.plugins, {}),
-            n2 = function(t4) {
-                const e3 = {},
-                    i3 = [],
-                    s3 = Object.keys(qo.plugins.items);
-                for (let t5 = 0; t5 < s3.length; t5++)
-                    i3.push(qo.getPlugin(s3[t5]));
-                const n3 = t4.plugins || [];
-                for (let t5 = 0; t5 < n3.length; t5++) {
-                    const s4 = n3[t5]; -
-                    1 === i3.indexOf(s4) && (i3.push(s4), e3[s4.id] = true);
-                }
-                return {
-                    plugins: i3,
-                    localIds: e3
-                };
-            }(i2);
-        return false !== s2 || e2 ? function(t4, {
-            plugins: e3,
-            localIds: i3
-        }, s3, n3) {
-            const r2 = [],
-                o2 = t4.getContext();
-            for (const a2 of e3) {
-                const e4 = a2.id,
-                    l2 = Ko(s3[e4], n3);
-                null !== l2 && r2.push({
-                    plugin: a2,
-                    options: Go(t4.config, {
-                        plugin: a2,
-                        local: i3[e4]
-                    }, l2, o2)
-                });
-            }
-            return r2;
-        }(t3, n2, s2, e2) : [];
-    }
-    _notifyStateChanges(t3) {
-        const e2 = this._oldCache || [],
-            i2 = this._cache,
-            s2 = (t4, e3) => t4.filter((t5) => !e3.some((e4) => t5.plugin.id === e4.plugin.id));
-        this._notify(s2(e2, i2), t3, "stop"), this._notify(s2(i2, e2), t3, "start");
-    }
-}
-
-function Ko(t3, e2) {
-    return e2 || false !== t3 ? true === t3 ? {} : t3 : null;
-}
-
-function Go(t3, {
-    plugin: e2,
-    local: i2
-}, s2, n2) {
-    const r2 = t3.pluginScopeKeys(e2),
-        o2 = t3.getOptionScopes(s2, r2);
-    return i2 && e2.defaults && o2.push(e2.defaults), t3.createResolver(o2, n2, [""], {
-        scriptable: false,
-        indexable: false,
-        allKeys: true
-    });
-}
-
-function Yo(t3, e2) {
-    const i2 = Js.datasets[t3] || {};
-    return ((e2.datasets || {})[t3] || {}).indexAxis || e2.indexAxis || i2.indexAxis || "x";
-}
-
-function Qo(t3) {
-    if ("x" === t3 || "y" === t3 || "r" === t3)
-        return t3;
-}
-
-function Xo(t3) {
-    return "top" === t3 || "bottom" === t3 ? "x" : "left" === t3 || "right" === t3 ? "y" : void 0;
-}
-
-function Jo(t3, ...e2) {
-    if (Qo(t3))
-        return t3;
-    for (const i2 of e2) {
-        const e3 = i2.axis || Xo(i2.position) || t3.length > 1 && Qo(t3[0].toLowerCase());
-        if (e3)
-            return e3;
-    }
-    throw new Error(`Cannot determine type of '${t3}' axis. Please provide 'axis' or 'position' option.`);
-}
-
-function Zo(t3, e2, i2) {
-    if (i2[e2 + "AxisID"] === t3)
-        return {
-            axis: e2
-        };
-}
-
-function ta(t3, e2) {
-    const i2 = Gs[t3.type] || {
-            scales: {}
-        },
-        s2 = e2.scales || {},
-        n2 = Yo(t3.type, e2),
-        r2 = /* @__PURE__ */ Object.create(null);
-    return Object.keys(s2).forEach((e3) => {
-        const o2 = s2[e3];
-        if (!yi(o2))
-            return console.error(`Invalid scale configuration for scale: ${e3}`);
-        if (o2._proxy)
-            return console.warn(`Ignoring resolver passed as options for scale: ${e3}`);
-        const a2 = Jo(e3, o2, function(t4, e4) {
-                if (e4.data && e4.data.datasets) {
-                    const i3 = e4.data.datasets.filter((e5) => e5.xAxisID === t4 || e5.yAxisID === t4);
-                    if (i3.length)
-                        return Zo(t4, "x", i3[0]) || Zo(t4, "y", i3[0]);
-                }
-                return {};
-            }(e3, t3), Js.scales[o2.type]),
-            l2 = function(t4, e4) {
-                return t4 === e4 ? "_index_" : "_value_";
-            }(a2, n2),
-            h2 = i2.scales || {};
-        r2[e3] = Vi( /* @__PURE__ */ Object.create(null), [{
-            axis: a2
-        }, o2, h2[a2], h2[l2]]);
-    }), t3.data.datasets.forEach((i3) => {
-        const n3 = i3.type || t3.type,
-            o2 = i3.indexAxis || Yo(n3, e2),
-            a2 = (Gs[n3] || {}).scales || {};
-        Object.keys(a2).forEach((t4) => {
-            const e3 = function(t5, e4) {
-                    let i4 = t5;
-                    return "_index_" === t5 ? i4 = e4 : "_value_" === t5 && (i4 = "x" === e4 ? "y" : "x"), i4;
-                }(t4, o2),
-                n4 = i3[e3 + "AxisID"] || e3;
-            r2[n4] = r2[n4] || /* @__PURE__ */ Object.create(null), Vi(r2[n4], [{
-                axis: e3
-            }, s2[n4], a2[t4]]);
-        });
-    }), Object.keys(r2).forEach((t4) => {
-        const e3 = r2[t4];
-        Vi(e3, [Js.scales[e3.type], Js.scale]);
-    }), r2;
-}
-
-function ea(t3) {
-    const e2 = t3.options || (t3.options = {});
-    e2.plugins = Ti(e2.plugins, {}), e2.scales = ta(t3, e2);
-}
-
-function ia(t3) {
-    return (t3 = t3 || {}).datasets = t3.datasets || [], t3.labels = t3.labels || [], t3;
-}
-const sa = /* @__PURE__ */ new Map(),
-    na = /* @__PURE__ */ new Set();
-
-function ra(t3, e2) {
-    let i2 = sa.get(t3);
-    return i2 || (i2 = e2(), sa.set(t3, i2), na.add(i2)), i2;
-}
-const oa = (t3, e2, i2) => {
-    const s2 = ji(e2, i2);
-    void 0 !== s2 && t3.add(s2);
-};
-class Config {
-    constructor(t3) {
-        this._config = function(t4) {
-            return (t4 = t4 || {}).data = ia(t4.data), ea(t4), t4;
-        }(t3), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
-    }
-    get platform() {
-        return this._config.platform;
-    }
-    get type() {
-        return this._config.type;
-    }
-    set type(t3) {
-        this._config.type = t3;
-    }
-    get data() {
-        return this._config.data;
-    }
-    set data(t3) {
-        this._config.data = ia(t3);
-    }
-    get options() {
-        return this._config.options;
-    }
-    set options(t3) {
-        this._config.options = t3;
-    }
-    get plugins() {
-        return this._config.plugins;
-    }
-    update() {
-        const t3 = this._config;
-        this.clearCache(), ea(t3);
-    }
-    clearCache() {
-        this._scopeCache.clear(), this._resolverCache.clear();
-    }
-    datasetScopeKeys(t3) {
-        return ra(t3, () => [
-            [`datasets.${t3}`, ""]
-        ]);
-    }
-    datasetAnimationScopeKeys(t3, e2) {
-        return ra(`${t3}.transition.${e2}`, () => [
-            [`datasets.${t3}.transitions.${e2}`, `transitions.${e2}`],
-            [`datasets.${t3}`, ""]
-        ]);
-    }
-    datasetElementScopeKeys(t3, e2) {
-        return ra(`${t3}-${e2}`, () => [
-            [`datasets.${t3}.elements.${e2}`, `datasets.${t3}`, `elements.${e2}`, ""]
-        ]);
-    }
-    pluginScopeKeys(t3) {
-        const e2 = t3.id;
-        return ra(`${this.type}-plugin-${e2}`, () => [
-            [`plugins.${e2}`, ...t3.additionalOptionScopes || []]
-        ]);
-    }
-    _cachedScopes(t3, e2) {
-        const i2 = this._scopeCache;
-        let s2 = i2.get(t3);
-        return s2 && !e2 || (s2 = /* @__PURE__ */ new Map(), i2.set(t3, s2)), s2;
-    }
-    getOptionScopes(t3, e2, i2) {
-        const {
-            options: s2,
-            type: n2
-        } = this, r2 = this._cachedScopes(t3, i2), o2 = r2.get(e2);
-        if (o2)
-            return o2;
-        const a2 = /* @__PURE__ */ new Set();
-        e2.forEach((e3) => {
-            t3 && (a2.add(t3), e3.forEach((e4) => oa(a2, t3, e4))), e3.forEach((t4) => oa(a2, s2, t4)), e3.forEach((t4) => oa(a2, Gs[n2] || {}, t4)), e3.forEach((t4) => oa(a2, Js, t4)), e3.forEach((t4) => oa(a2, Ys, t4));
-        });
-        const l2 = Array.from(a2);
-        return 0 === l2.length && l2.push( /* @__PURE__ */ Object.create(null)), na.has(e2) && r2.set(e2, l2), l2;
-    }
-    chartOptionScopes() {
-        const {
-            options: t3,
-            type: e2
-        } = this;
-        return [t3, Gs[e2] || {}, Js.datasets[e2] || {}, {
-            type: e2
-        }, Js, Ys];
-    }
-    resolveNamedOptions(t3, e2, i2, s2 = [""]) {
-        const n2 = {
-                $shared: true
-            },
-            {
-                resolver: r2,
-                subPrefixes: o2
-            } = aa(this._resolverCache, t3, s2);
-        let a2 = r2;
-        if (function(t4, e3) {
-                const {
-                    isScriptable: i3,
-                    isIndexable: s3
-                } = Bn(t4);
-                for (const n3 of e3) {
-                    const e4 = i3(n3),
-                        r3 = s3(n3),
-                        o3 = (r3 || e4) && t4[n3];
-                    if (e4 && (Gi(o3) || la(o3)) || r3 && ui(o3))
-                        return true;
-                }
-                return false;
-            }(r2, e2)) {
-            n2.$shared = false;
-            a2 = zn(r2, i2 = Gi(i2) ? i2() : i2, this.createResolver(t3, i2, o2));
-        }
-        for (const t4 of e2)
-            n2[t4] = a2[t4];
-        return n2;
-    }
-    createResolver(t3, e2, i2 = [""], s2) {
-        const {
-            resolver: n2
-        } = aa(this._resolverCache, t3, i2);
-        return yi(e2) ? zn(n2, e2, void 0, s2) : n2;
-    }
-}
-
-function aa(t3, e2, i2) {
-    let s2 = t3.get(e2);
-    s2 || (s2 = /* @__PURE__ */ new Map(), t3.set(e2, s2));
-    const n2 = i2.join();
-    let r2 = s2.get(n2);
-    if (!r2) {
-        r2 = {
-            resolver: Vn(e2, i2),
-            subPrefixes: i2.filter((t4) => !t4.toLowerCase().includes("hover"))
-        }, s2.set(n2, r2);
-    }
-    return r2;
-}
-const la = (t3) => yi(t3) && Object.getOwnPropertyNames(t3).reduce((e2, i2) => e2 || Gi(t3[i2]), false);
-const ha = ["top", "bottom", "left", "right", "chartArea"];
-
-function ca(t3, e2) {
-    return "top" === t3 || "bottom" === t3 || -1 === ha.indexOf(t3) && "x" === e2;
-}
-
-function ua(t3, e2) {
-    return function(i2, s2) {
-        return i2[t3] === s2[t3] ? i2[e2] - s2[e2] : i2[t3] - s2[t3];
-    };
-}
-
-function da(t3) {
-    const e2 = t3.chart,
-        i2 = e2.options.animation;
-    e2.notifyPlugins("afterRender"), Si(i2 && i2.onComplete, [t3], e2);
-}
-
-function fa(t3) {
-    const e2 = t3.chart,
-        i2 = e2.options.animation;
-    Si(i2 && i2.onProgress, [t3], e2);
-}
-
-function pa(t3) {
-    return cr() && "string" == typeof t3 ? t3 = document.getElementById(t3) : t3 && t3.length && (t3 = t3[0]), t3 && t3.canvas && (t3 = t3.canvas), t3;
-}
-const ma = {},
-    ga = (t3) => {
-        const e2 = pa(t3);
-        return Object.values(ma).filter((t4) => t4.canvas === e2).pop();
-    };
-
-function ya(t3, e2, i2) {
-    const s2 = Object.keys(t3);
-    for (const n2 of s2) {
-        const s3 = +n2;
-        if (s3 >= e2) {
-            const r2 = t3[n2];
-            delete t3[n2], (i2 > 0 || s3 > e2) && (t3[s3 + i2] = r2);
-        }
-    }
-}
-
-function va(t3, e2, i2) {
-    return t3.options.clip ? t3[i2] : e2[i2];
-}
-class Chart {
-    static register(...t3) {
-        qo.add(...t3), ba();
-    }
-    static unregister(...t3) {
-        qo.remove(...t3), ba();
-    }
-    constructor(t3, e2) {
-        const i2 = this.config = new Config(e2),
-            s2 = pa(t3),
-            n2 = ga(s2);
-        if (n2)
-            throw new Error("Canvas is already in use. Chart with ID '" + n2.id + "' must be destroyed before the canvas with ID '" + n2.canvas.id + "' can be reused.");
-        const r2 = i2.createResolver(i2.chartOptionScopes(), this.getContext());
-        this.platform = new(i2.platform || function(t4) {
-            return !cr() || "undefined" != typeof OffscreenCanvas && t4 instanceof OffscreenCanvas ? BasicPlatform : DomPlatform;
-        }(s2))(), this.platform.updateConfig(i2);
-        const o2 = this.platform.acquireContext(s2, r2.aspectRatio),
-            a2 = o2 && o2.canvas,
-            l2 = a2 && a2.height,
-            h2 = a2 && a2.width;
-        this.id = hi(), this.ctx = o2, this.canvas = a2, this.width = h2, this.height = l2, this._options = r2, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new PluginService(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = false, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = function(t4, e3) {
-            let i3;
-            return function(...s3) {
-                return e3 ? (clearTimeout(i3), i3 = setTimeout(t4, e3, s3)) : t4.apply(this, s3), e3;
-            };
-        }((t4) => this.update(t4), r2.resizeDelay || 0), this._dataChanges = [], ma[this.id] = this, o2 && a2 ? (Dr.listen(this, "complete", da), Dr.listen(this, "progress", fa), this._initialize(), this.attached && this.update()) : console.error("Failed to create chart: can't acquire context from the given item");
-    }
-    get aspectRatio() {
-        const {
-            options: {
-                aspectRatio: t3,
-                maintainAspectRatio: e2
-            },
-            width: i2,
-            height: s2,
-            _aspectRatio: n2
-        } = this;
-        return ci(t3) ? e2 && n2 ? n2 : s2 ? i2 / s2 : null : t3;
-    }
-    get data() {
-        return this.config.data;
-    }
-    set data(t3) {
-        this.config.data = t3;
-    }
-    get options() {
-        return this._options;
-    }
-    set options(t3) {
-        this.config.options = t3;
-    }
-    get registry() {
-        return qo;
-    }
-    _initialize() {
-        return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : _r(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
-    }
-    clear() {
-        return en(this.canvas, this.ctx), this;
-    }
-    stop() {
-        return Dr.stop(this), this;
-    }
-    resize(t3, e2) {
-        Dr.running(this) ? this._resizeBeforeDraw = {
-            width: t3,
-            height: e2
-        } : this._resize(t3, e2);
-    }
-    _resize(t3, e2) {
-        const i2 = this.options,
-            s2 = this.canvas,
-            n2 = i2.maintainAspectRatio && this.aspectRatio,
-            r2 = this.platform.getMaximumSize(s2, t3, e2, n2),
-            o2 = i2.devicePixelRatio || this.platform.getDevicePixelRatio(),
-            a2 = this.width ? "resize" : "attach";
-        this.width = r2.width, this.height = r2.height, this._aspectRatio = this.aspectRatio, _r(this, o2, true) && (this.notifyPlugins("resize", {
-            size: r2
-        }), Si(i2.onResize, [this, r2], this), this.attached && this._doResize(a2) && this.render());
-    }
-    ensureScalesHaveIDs() {
-        Ei(this.options.scales || {}, (t3, e2) => {
-            t3.id = e2;
-        });
-    }
-    buildOrUpdateScales() {
-        const t3 = this.options,
-            e2 = t3.scales,
-            i2 = this.scales,
-            s2 = Object.keys(i2).reduce((t4, e3) => (t4[e3] = false, t4), {});
-        let n2 = [];
-        e2 && (n2 = n2.concat(Object.keys(e2).map((t4) => {
-            const i3 = e2[t4],
-                s3 = Jo(t4, i3),
-                n3 = "r" === s3,
-                r2 = "x" === s3;
-            return {
-                options: i3,
-                dposition: n3 ? "chartArea" : r2 ? "bottom" : "left",
-                dtype: n3 ? "radialLinear" : r2 ? "category" : "linear"
-            };
-        }))), Ei(n2, (e3) => {
-            const n3 = e3.options,
-                r2 = n3.id,
-                o2 = Jo(r2, n3),
-                a2 = Ti(n3.type, e3.dtype);
-            void 0 !== n3.position && ca(n3.position, o2) === ca(e3.dposition) || (n3.position = e3.dposition), s2[r2] = true;
-            let l2 = null;
-            if (r2 in i2 && i2[r2].type === a2)
-                l2 = i2[r2];
-            else {
-                l2 = new(qo.getScale(a2))({
-                    id: r2,
-                    type: a2,
-                    ctx: this.ctx,
-                    chart: this
-                }), i2[l2.id] = l2;
-            }
-            l2.init(n3, t3);
-        }), Ei(s2, (t4, e3) => {
-            t4 || delete i2[e3];
-        }), Ei(i2, (t4) => {
-            xo.configure(this, t4, t4.options), xo.addBox(this, t4);
-        });
-    }
-    _updateMetasets() {
-        const t3 = this._metasets,
-            e2 = this.data.datasets.length,
-            i2 = t3.length;
-        if (t3.sort((t4, e3) => t4.index - e3.index), i2 > e2) {
-            for (let t4 = e2; t4 < i2; ++t4)
-                this._destroyDatasetMeta(t4);
-            t3.splice(e2, i2 - e2);
-        }
-        this._sortedMetasets = t3.slice(0).sort(ua("order", "index"));
-    }
-    _removeUnreferencedMetasets() {
-        const {
-            _metasets: t3,
-            data: {
-                datasets: e2
-            }
-        } = this;
-        t3.length > e2.length && delete this._stacks, t3.forEach((t4, i2) => {
-            0 === e2.filter((e3) => e3 === t4._dataset).length && this._destroyDatasetMeta(i2);
-        });
-    }
-    buildOrUpdateControllers() {
-        const t3 = [],
-            e2 = this.data.datasets;
-        let i2, s2;
-        for (this._removeUnreferencedMetasets(), i2 = 0, s2 = e2.length; i2 < s2; i2++) {
-            const s3 = e2[i2];
-            let n2 = this.getDatasetMeta(i2);
-            const r2 = s3.type || this.config.type;
-            if (n2.type && n2.type !== r2 && (this._destroyDatasetMeta(i2), n2 = this.getDatasetMeta(i2)), n2.type = r2, n2.indexAxis = s3.indexAxis || Yo(r2, this.options), n2.order = s3.order || 0, n2.index = i2, n2.label = "" + s3.label, n2.visible = this.isDatasetVisible(i2), n2.controller)
-                n2.controller.updateIndex(i2), n2.controller.linkScales();
-            else {
-                const e3 = qo.getController(r2),
-                    {
-                        datasetElementType: s4,
-                        dataElementType: o2
-                    } = Js.datasets[r2];
-                Object.assign(e3, {
-                    dataElementType: qo.getElement(o2),
-                    datasetElementType: s4 && qo.getElement(s4)
-                }), n2.controller = new e3(this, i2), t3.push(n2.controller);
-            }
-        }
-        return this._updateMetasets(), t3;
-    }
-    _resetElements() {
-        Ei(this.data.datasets, (t3, e2) => {
-            this.getDatasetMeta(e2).controller.reset();
-        }, this);
-    }
-    reset() {
-        this._resetElements(), this.notifyPlugins("reset");
-    }
-    update(t3) {
-        const e2 = this.config;
-        e2.update();
-        const i2 = this._options = e2.createResolver(e2.chartOptionScopes(), this.getContext()),
-            s2 = this._animationsDisabled = !i2.animation;
-        if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), false === this.notifyPlugins("beforeUpdate", {
-                mode: t3,
-                cancelable: true
-            }))
-            return;
-        const n2 = this.buildOrUpdateControllers();
-        this.notifyPlugins("beforeElementsUpdate");
-        let r2 = 0;
-        for (let t4 = 0, e3 = this.data.datasets.length; t4 < e3; t4++) {
-            const {
-                controller: e4
-            } = this.getDatasetMeta(t4), i3 = !s2 && -1 === n2.indexOf(e4);
-            e4.buildOrUpdateElements(i3), r2 = Math.max(+e4.getMaxOverflow(), r2);
-        }
-        r2 = this._minPadding = i2.layout.autoPadding ? r2 : 0, this._updateLayout(r2), s2 || Ei(n2, (t4) => {
-            t4.reset();
-        }), this._updateDatasets(t3), this.notifyPlugins("afterUpdate", {
-            mode: t3
-        }), this._layers.sort(ua("z", "_idx"));
-        const {
-            _active: o2,
-            _lastEvent: a2
-        } = this;
-        a2 ? this._eventHandler(a2, true) : o2.length && this._updateHoverStyles(o2, o2, true), this.render();
-    }
-    _updateScales() {
-        Ei(this.scales, (t3) => {
-            xo.removeBox(this, t3);
-        }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
-    }
-    _checkEventBindings() {
-        const t3 = this.options,
-            e2 = new Set(Object.keys(this._listeners)),
-            i2 = new Set(t3.events);
-        Yi(e2, i2) && !!this._responsiveListeners === t3.responsive || (this.unbindEvents(), this.bindEvents());
-    }
-    _updateHiddenIndices() {
-        const {
-            _hiddenIndices: t3
-        } = this, e2 = this._getUniformDataChanges() || [];
-        for (const {
-                method: i2,
-                start: s2,
-                count: n2
-            }
-            of e2) {
-            ya(t3, s2, "_removeElements" === i2 ? -n2 : n2);
-        }
-    }
-    _getUniformDataChanges() {
-        const t3 = this._dataChanges;
-        if (!t3 || !t3.length)
-            return;
-        this._dataChanges = [];
-        const e2 = this.data.datasets.length,
-            i2 = (e3) => new Set(t3.filter((t4) => t4[0] === e3).map((t4, e4) => e4 + "," + t4.splice(1).join(","))),
-            s2 = i2(0);
-        for (let t4 = 1; t4 < e2; t4++)
-            if (!Yi(s2, i2(t4)))
-                return;
-        return Array.from(s2).map((t4) => t4.split(",")).map((t4) => ({
-            method: t4[1],
-            start: +t4[2],
-            count: +t4[3]
-        }));
-    }
-    _updateLayout(t3) {
-        if (false === this.notifyPlugins("beforeLayout", {
-                cancelable: true
-            }))
-            return;
-        xo.update(this, this.width, this.height, t3);
-        const e2 = this.chartArea,
-            i2 = e2.width <= 0 || e2.height <= 0;
-        this._layers = [], Ei(this.boxes, (t4) => {
-            i2 && "chartArea" === t4.position || (t4.configure && t4.configure(), this._layers.push(...t4._layers()));
-        }, this), this._layers.forEach((t4, e3) => {
-            t4._idx = e3;
-        }), this.notifyPlugins("afterLayout");
-    }
-    _updateDatasets(t3) {
-        if (false !== this.notifyPlugins("beforeDatasetsUpdate", {
-                mode: t3,
-                cancelable: true
-            })) {
-            for (let t4 = 0, e2 = this.data.datasets.length; t4 < e2; ++t4)
-                this.getDatasetMeta(t4).controller.configure();
-            for (let e2 = 0, i2 = this.data.datasets.length; e2 < i2; ++e2)
-                this._updateDataset(e2, Gi(t3) ? t3({
-                    datasetIndex: e2
-                }) : t3);
-            this.notifyPlugins("afterDatasetsUpdate", {
-                mode: t3
-            });
-        }
-    }
-    _updateDataset(t3, e2) {
-        const i2 = this.getDatasetMeta(t3),
-            s2 = {
-                meta: i2,
-                index: t3,
-                mode: e2,
-                cancelable: true
-            };
-        false !== this.notifyPlugins("beforeDatasetUpdate", s2) && (i2.controller._update(e2), s2.cancelable = false, this.notifyPlugins("afterDatasetUpdate", s2));
-    }
-    render() {
-        false !== this.notifyPlugins("beforeRender", {
-            cancelable: true
-        }) && (Dr.has(this) ? this.attached && !Dr.running(this) && Dr.start(this) : (this.draw(), da({
-            chart: this
-        })));
-    }
-    draw() {
-        let t3;
-        if (this._resizeBeforeDraw) {
-            const {
-                width: t4,
-                height: e3
-            } = this._resizeBeforeDraw;
-            this._resize(t4, e3), this._resizeBeforeDraw = null;
-        }
-        if (this.clear(), this.width <= 0 || this.height <= 0)
-            return;
-        if (false === this.notifyPlugins("beforeDraw", {
-                cancelable: true
-            }))
-            return;
-        const e2 = this._layers;
-        for (t3 = 0; t3 < e2.length && e2[t3].z <= 0; ++t3)
-            e2[t3].draw(this.chartArea);
-        for (this._drawDatasets(); t3 < e2.length; ++t3)
-            e2[t3].draw(this.chartArea);
-        this.notifyPlugins("afterDraw");
-    }
-    _getSortedDatasetMetas(t3) {
-        const e2 = this._sortedMetasets,
-            i2 = [];
-        let s2, n2;
-        for (s2 = 0, n2 = e2.length; s2 < n2; ++s2) {
-            const n3 = e2[s2];
-            t3 && !n3.visible || i2.push(n3);
-        }
-        return i2;
-    }
-    getSortedVisibleDatasetMetas() {
-        return this._getSortedDatasetMetas(true);
-    }
-    _drawDatasets() {
-        if (false === this.notifyPlugins("beforeDatasetsDraw", {
-                cancelable: true
-            }))
-            return;
-        const t3 = this.getSortedVisibleDatasetMetas();
-        for (let e2 = t3.length - 1; e2 >= 0; --e2)
-            this._drawDataset(t3[e2]);
-        this.notifyPlugins("afterDatasetsDraw");
-    }
-    _drawDataset(t3) {
-        const e2 = this.ctx,
-            i2 = t3._clip,
-            s2 = !i2.disabled,
-            n2 = function(t4, e3) {
-                const {
-                    xScale: i3,
-                    yScale: s3
-                } = t4;
-                return i3 && s3 ? {
-                    left: va(i3, e3, "left"),
-                    right: va(i3, e3, "right"),
-                    top: va(s3, e3, "top"),
-                    bottom: va(s3, e3, "bottom")
-                } : e3;
-            }(t3, this.chartArea),
-            r2 = {
-                meta: t3,
-                index: t3.index,
-                cancelable: true
-            };
-        false !== this.notifyPlugins("beforeDatasetDraw", r2) && (s2 && ln(e2, {
-            left: false === i2.left ? 0 : n2.left - i2.left,
-            right: false === i2.right ? this.width : n2.right + i2.right,
-            top: false === i2.top ? 0 : n2.top - i2.top,
-            bottom: false === i2.bottom ? this.height : n2.bottom + i2.bottom
-        }), t3.controller.draw(), s2 && un(e2), r2.cancelable = false, this.notifyPlugins("afterDatasetDraw", r2));
-    }
-    isPointInArea(t3) {
-        return nn(t3, this.chartArea, this._minPadding);
-    }
-    getElementsAtEventForMode(t3, e2, i2, s2) {
-        const n2 = lo.modes[e2];
-        return "function" == typeof n2 ? n2(this, t3, i2, s2) : [];
-    }
-    getDatasetMeta(t3) {
-        const e2 = this.data.datasets[t3],
-            i2 = this._metasets;
-        let s2 = i2.filter((t4) => t4 && t4._dataset === e2).pop();
-        return s2 || (s2 = {
-            type: null,
-            data: [],
-            dataset: null,
-            controller: null,
-            hidden: null,
-            xAxisID: null,
-            yAxisID: null,
-            order: e2 && e2.order || 0,
-            index: t3,
-            _dataset: e2,
-            _parsed: [],
-            _sorted: false
-        }, i2.push(s2)), s2;
-    }
-    getContext() {
-        return this.$context || (this.$context = $n(null, {
-            chart: this,
-            type: "chart"
-        }));
-    }
-    getVisibleDatasetCount() {
-        return this.getSortedVisibleDatasetMetas().length;
-    }
-    isDatasetVisible(t3) {
-        const e2 = this.data.datasets[t3];
-        if (!e2)
-            return false;
-        const i2 = this.getDatasetMeta(t3);
-        return "boolean" == typeof i2.hidden ? !i2.hidden : !e2.hidden;
-    }
-    setDatasetVisibility(t3, e2) {
-        this.getDatasetMeta(t3).hidden = !e2;
-    }
-    toggleDataVisibility(t3) {
-        this._hiddenIndices[t3] = !this._hiddenIndices[t3];
-    }
-    getDataVisibility(t3) {
-        return !this._hiddenIndices[t3];
-    }
-    _updateVisibility(t3, e2, i2) {
-        const s2 = i2 ? "show" : "hide",
-            n2 = this.getDatasetMeta(t3),
-            r2 = n2.controller._resolveAnimations(void 0, s2);
-        qi(e2) ? (n2.data[e2].hidden = !i2, this.update()) : (this.setDatasetVisibility(t3, i2), r2.update(n2, {
-            visible: i2
-        }), this.update((e3) => e3.datasetIndex === t3 ? s2 : void 0));
-    }
-    hide(t3, e2) {
-        this._updateVisibility(t3, e2, false);
-    }
-    show(t3, e2) {
-        this._updateVisibility(t3, e2, true);
-    }
-    _destroyDatasetMeta(t3) {
-        const e2 = this._metasets[t3];
-        e2 && e2.controller && e2.controller._destroy(), delete this._metasets[t3];
-    }
-    _stop() {
-        let t3, e2;
-        for (this.stop(), Dr.remove(this), t3 = 0, e2 = this.data.datasets.length; t3 < e2; ++t3)
-            this._destroyDatasetMeta(t3);
-    }
-    destroy() {
-        this.notifyPlugins("beforeDestroy");
-        const {
-            canvas: t3,
-            ctx: e2
-        } = this;
-        this._stop(), this.config.clearCache(), t3 && (this.unbindEvents(), en(t3, e2), this.platform.releaseContext(e2), this.canvas = null, this.ctx = null), delete ma[this.id], this.notifyPlugins("afterDestroy");
-    }
-    toBase64Image(...t3) {
-        return this.canvas.toDataURL(...t3);
-    }
-    bindEvents() {
-        this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = true;
-    }
-    bindUserEvents() {
-        const t3 = this._listeners,
-            e2 = this.platform,
-            i2 = (i3, s3) => {
-                e2.addEventListener(this, i3, s3), t3[i3] = s3;
-            },
-            s2 = (t4, e3, i3) => {
-                t4.offsetX = e3, t4.offsetY = i3, this._eventHandler(t4);
-            };
-        Ei(this.options.events, (t4) => i2(t4, s2));
-    }
-    bindResponsiveEvents() {
-        this._responsiveListeners || (this._responsiveListeners = {});
-        const t3 = this._responsiveListeners,
-            e2 = this.platform,
-            i2 = (i3, s3) => {
-                e2.addEventListener(this, i3, s3), t3[i3] = s3;
-            },
-            s2 = (i3, s3) => {
-                t3[i3] && (e2.removeEventListener(this, i3, s3), delete t3[i3]);
-            },
-            n2 = (t4, e3) => {
-                this.canvas && this.resize(t4, e3);
-            };
-        let r2;
-        const o2 = () => {
-            s2("attach", o2), this.attached = true, this.resize(), i2("resize", n2), i2("detach", r2);
-        };
-        r2 = () => {
-            this.attached = false, s2("resize", n2), this._stop(), this._resize(0, 0), i2("attach", o2);
-        }, e2.isAttached(this.canvas) ? o2() : r2();
-    }
-    unbindEvents() {
-        Ei(this._listeners, (t3, e2) => {
-            this.platform.removeEventListener(this, e2, t3);
-        }), this._listeners = {}, Ei(this._responsiveListeners, (t3, e2) => {
-            this.platform.removeEventListener(this, e2, t3);
-        }), this._responsiveListeners = void 0;
-    }
-    updateHoverStyle(t3, e2, i2) {
-        const s2 = i2 ? "set" : "remove";
-        let n2, r2, o2, a2;
-        for ("dataset" === e2 && (n2 = this.getDatasetMeta(t3[0].datasetIndex), n2.controller["_" + s2 + "DatasetHoverStyle"]()), o2 = 0, a2 = t3.length; o2 < a2; ++o2) {
-            r2 = t3[o2];
-            const e3 = r2 && this.getDatasetMeta(r2.datasetIndex).controller;
-            e3 && e3[s2 + "HoverStyle"](r2.element, r2.datasetIndex, r2.index);
-        }
-    }
-    getActiveElements() {
-        return this._active || [];
-    }
-    setActiveElements(t3) {
-        const e2 = this._active || [],
-            i2 = t3.map(({
-                datasetIndex: t4,
-                index: e3
-            }) => {
-                const i3 = this.getDatasetMeta(t4);
-                if (!i3)
-                    throw new Error("No dataset found at index " + t4);
-                return {
-                    datasetIndex: t4,
-                    element: i3.data[e3],
-                    index: e3
-                };
-            });
-        !Ii(i2, e2) && (this._active = i2, this._lastEvent = null, this._updateHoverStyles(i2, e2));
-    }
-    notifyPlugins(t3, e2, i2) {
-        return this._plugins.notify(this, t3, e2, i2);
-    }
-    isPluginEnabled(t3) {
-        return 1 === this._plugins._cache.filter((e2) => e2.plugin.id === t3).length;
-    }
-    _updateHoverStyles(t3, e2, i2) {
-        const s2 = this.options.hover,
-            n2 = (t4, e3) => t4.filter((t5) => !e3.some((e4) => t5.datasetIndex === e4.datasetIndex && t5.index === e4.index)),
-            r2 = n2(e2, t3),
-            o2 = i2 ? t3 : n2(t3, e2);
-        r2.length && this.updateHoverStyle(r2, s2.mode, false), o2.length && s2.mode && this.updateHoverStyle(o2, s2.mode, true);
-    }
-    _eventHandler(t3, e2) {
-        const i2 = {
-                event: t3,
-                replay: e2,
-                cancelable: true,
-                inChartArea: this.isPointInArea(t3)
-            },
-            s2 = (e3) => (e3.options.events || this.options.events).includes(t3.native.type);
-        if (false === this.notifyPlugins("beforeEvent", i2, s2))
-            return;
-        const n2 = this._handleEvent(t3, e2, i2.inChartArea);
-        return i2.cancelable = false, this.notifyPlugins("afterEvent", i2, s2), (n2 || i2.changed) && this.render(), this;
-    }
-    _handleEvent(t3, e2, i2) {
-        const {
-            _active: s2 = [],
-            options: n2
-        } = this, r2 = e2, o2 = this._getActiveElements(t3, s2, i2, r2), a2 = function(t4) {
-            return "mouseup" === t4.type || "click" === t4.type || "contextmenu" === t4.type;
-        }(t3), l2 = function(t4, e3, i3, s3) {
-            return i3 && "mouseout" !== t4.type ? s3 ? e3 : t4 : null;
-        }(t3, this._lastEvent, i2, a2);
-        i2 && (this._lastEvent = null, Si(n2.onHover, [t3, o2, this], this), a2 && Si(n2.onClick, [t3, o2, this], this));
-        const h2 = !Ii(o2, s2);
-        return (h2 || e2) && (this._active = o2, this._updateHoverStyles(o2, s2, e2)), this._lastEvent = l2, h2;
-    }
-    _getActiveElements(t3, e2, i2, s2) {
-        if ("mouseout" === t3.type)
-            return [];
-        if (!i2)
-            return e2;
-        const n2 = this.options.hover;
-        return this.getElementsAtEventForMode(t3, n2.mode, n2, s2);
-    }
-}
-__publicField(Chart, "defaults", Js);
-__publicField(Chart, "instances", ma);
-__publicField(Chart, "overrides", Gs);
-__publicField(Chart, "registry", qo);
-__publicField(Chart, "version", "4.4.0");
-__publicField(Chart, "getChart", ga);
-
-function ba() {
-    return Ei(Chart.instances, (t3) => t3._plugins.invalidate());
-}
-
-function _a(t3, e2, i2 = e2) {
-    t3.lineCap = Ti(i2.borderCapStyle, e2.borderCapStyle), t3.setLineDash(Ti(i2.borderDash, e2.borderDash)), t3.lineDashOffset = Ti(i2.borderDashOffset, e2.borderDashOffset), t3.lineJoin = Ti(i2.borderJoinStyle, e2.borderJoinStyle), t3.lineWidth = Ti(i2.borderWidth, e2.borderWidth), t3.strokeStyle = Ti(i2.borderColor, e2.borderColor);
-}
-
-function wa(t3, e2, i2) {
-    t3.lineTo(i2.x, i2.y);
-}
-
-function xa(t3, e2, i2 = {}) {
-    const s2 = t3.length,
-        {
-            start: n2 = 0,
-            end: r2 = s2 - 1
-        } = i2,
-        {
-            start: o2,
-            end: a2
-        } = e2,
-        l2 = Math.max(n2, o2),
-        h2 = Math.min(r2, a2),
-        c2 = n2 < o2 && r2 < o2 || n2 > a2 && r2 > a2;
-    return {
-        count: s2,
-        start: l2,
-        loop: e2.loop,
-        ilen: h2 < l2 && !c2 ? s2 + h2 - l2 : h2 - l2
-    };
-}
-
-function ka(t3, e2, i2, s2) {
-    const {
-        points: n2,
-        options: r2
-    } = e2, {
-        count: o2,
-        start: a2,
-        loop: l2,
-        ilen: h2
-    } = xa(n2, i2, s2), c2 = function(t4) {
-        return t4.stepped ? fn : t4.tension || "monotone" === t4.cubicInterpolationMode ? pn : wa;
-    }(r2);
-    let u2, d2, f2, {
-        move: p2 = true,
-        reverse: m2
-    } = s2 || {};
-    for (u2 = 0; u2 <= h2; ++u2)
-        d2 = n2[(a2 + (m2 ? h2 - u2 : u2)) % o2], d2.skip || (p2 ? (t3.moveTo(d2.x, d2.y), p2 = false) : c2(t3, f2, d2, m2, r2.stepped), f2 = d2);
-    return l2 && (d2 = n2[(a2 + (m2 ? h2 : 0)) % o2], c2(t3, f2, d2, m2, r2.stepped)), !!l2;
-}
-
-function Ta(t3, e2, i2, s2) {
-    const n2 = e2.points,
-        {
-            count: r2,
-            start: o2,
-            ilen: a2
-        } = xa(n2, i2, s2),
-        {
-            move: l2 = true,
-            reverse: h2
-        } = s2 || {};
-    let c2, u2, d2, f2, p2, m2, g2 = 0,
-        y2 = 0;
-    const v2 = (t4) => (o2 + (h2 ? a2 - t4 : t4)) % r2,
-        b2 = () => {
-            f2 !== p2 && (t3.lineTo(g2, p2), t3.lineTo(g2, f2), t3.lineTo(g2, m2));
-        };
-    for (l2 && (u2 = n2[v2(0)], t3.moveTo(u2.x, u2.y)), c2 = 0; c2 <= a2; ++c2) {
-        if (u2 = n2[v2(c2)], u2.skip)
-            continue;
-        const e3 = u2.x,
-            i3 = u2.y,
-            s3 = 0 | e3;
-        s3 === d2 ? (i3 < f2 ? f2 = i3 : i3 > p2 && (p2 = i3), g2 = (y2 * g2 + e3) / ++y2) : (b2(), t3.lineTo(e3, i3), d2 = s3, y2 = 0, f2 = p2 = i3), m2 = i3;
-    }
-    b2();
-}
-
-function Sa(t3) {
-    const e2 = t3.options,
-        i2 = e2.borderDash && e2.borderDash.length;
-    return !(t3._decimated || t3._loop || e2.tension || "monotone" === e2.cubicInterpolationMode || e2.stepped || i2) ? Ta : ka;
-}
-const Ea = "function" == typeof Path2D;
-
-function Ca(t3, e2, i2, s2) {
-    Ea && !e2.options.segment ? function(t4, e3, i3, s3) {
-        let n2 = e3._path;
-        n2 || (n2 = e3._path = new Path2D(), e3.path(n2, i3, s3) && n2.closePath()), _a(t4, e3.options), t4.stroke(n2);
-    }(t3, e2, i2, s2) : function(t4, e3, i3, s3) {
-        const {
-            segments: n2,
-            options: r2
-        } = e3, o2 = Sa(e3);
-        for (const a2 of n2)
-            _a(t4, r2, a2.style), t4.beginPath(), o2(t4, e3, a2, {
-                start: i3,
-                end: i3 + s3 - 1
-            }) && t4.closePath(), t4.stroke();
-    }(t3, e2, i2, s2);
-}
-class LineElement extends Element {
-    constructor(t3) {
-        super(), this.animated = true, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = false, this._pointsUpdated = false, this._datasetIndex = void 0, t3 && Object.assign(this, t3);
-    }
-    updateControlPoints(t3, e2) {
-        const i2 = this.options;
-        if ((i2.tension || "monotone" === i2.cubicInterpolationMode) && !i2.stepped && !this._pointsUpdated) {
-            const s2 = i2.spanGaps ? this._loop : this._fullLoop;
-            hr(this._points, i2, t3, s2, e2), this._pointsUpdated = true;
-        }
-    }
-    set points(t3) {
-        this._points = t3, delete this._segments, delete this._path, this._pointsUpdated = false;
-    }
-    get points() {
-        return this._points;
-    }
-    get segments() {
-        return this._segments || (this._segments = function(t3, e2) {
-            const i2 = t3.points,
-                s2 = t3.options.spanGaps,
-                n2 = i2.length;
-            if (!n2)
-                return [];
-            const r2 = !!t3._loop,
-                {
-                    start: o2,
-                    end: a2
-                } = function(t4, e3, i3, s3) {
-                    let n3 = 0,
-                        r3 = e3 - 1;
-                    if (i3 && !s3)
-                        for (; n3 < e3 && !t4[n3].skip;)
-                            n3++;
-                    for (; n3 < e3 && t4[n3].skip;)
-                        n3++;
-                    for (n3 %= e3, i3 && (r3 += n3); r3 > n3 && t4[r3 % e3].skip;)
-                        r3--;
-                    return r3 %= e3, {
-                        start: n3,
-                        end: r3
-                    };
-                }(i2, n2, r2, s2);
-            return Pr(t3, true === s2 ? [{
-                start: o2,
-                end: a2,
-                loop: r2
-            }] : function(t4, e3, i3, s3) {
-                const n3 = t4.length,
-                    r3 = [];
-                let o3, a3 = e3,
-                    l2 = t4[e3];
-                for (o3 = e3 + 1; o3 <= i3; ++o3) {
-                    const i4 = t4[o3 % n3];
-                    i4.skip || i4.stop ? l2.skip || (s3 = false, r3.push({
-                        start: e3 % n3,
-                        end: (o3 - 1) % n3,
-                        loop: s3
-                    }), e3 = a3 = i4.stop ? o3 : null) : (a3 = o3, l2.skip && (e3 = o3)), l2 = i4;
-                }
-                return null !== a3 && r3.push({
-                    start: e3 % n3,
-                    end: a3 % n3,
-                    loop: s3
-                }), r3;
-            }(i2, o2, a2 < o2 ? a2 + n2 : a2, !!t3._fullLoop && 0 === o2 && a2 === n2 - 1), i2, e2);
-        }(this, this.options.segment));
-    }
-    first() {
-        const t3 = this.segments,
-            e2 = this.points;
-        return t3.length && e2[t3[0].start];
-    }
-    last() {
-        const t3 = this.segments,
-            e2 = this.points,
-            i2 = t3.length;
-        return i2 && e2[t3[i2 - 1].end];
-    }
-    interpolate(t3, e2) {
-        const i2 = this.options,
-            s2 = t3[e2],
-            n2 = this.points,
-            r2 = function(t4, e3) {
-                const i3 = [],
-                    s3 = t4.segments;
-                for (let n3 = 0; n3 < s3.length; n3++) {
-                    const r3 = Mr(s3[n3], t4.points, e3);
-                    r3.length && i3.push(...r3);
-                }
-                return i3;
-            }(this, {
-                property: e2,
-                start: s2,
-                end: s2
-            });
-        if (!r2.length)
-            return;
-        const o2 = [],
-            a2 = function(t4) {
-                return t4.stepped ? Tr : t4.tension || "monotone" === t4.cubicInterpolationMode ? Sr : kr;
-            }(i2);
-        let l2, h2;
-        for (l2 = 0, h2 = r2.length; l2 < h2; ++l2) {
-            const {
-                start: h3,
-                end: c2
-            } = r2[l2], u2 = n2[h3], d2 = n2[c2];
-            if (u2 === d2) {
-                o2.push(u2);
-                continue;
-            }
-            const f2 = a2(u2, d2, Math.abs((s2 - u2[e2]) / (d2[e2] - u2[e2])), i2.stepped);
-            f2[e2] = t3[e2], o2.push(f2);
-        }
-        return 1 === o2.length ? o2[0] : o2;
-    }
-    pathSegment(t3, e2, i2) {
-        return Sa(this)(t3, this, e2, i2);
-    }
-    path(t3, e2, i2) {
-        const s2 = this.segments,
-            n2 = Sa(this);
-        let r2 = this._loop;
-        e2 = e2 || 0, i2 = i2 || this.points.length - e2;
-        for (const o2 of s2)
-            r2 &= n2(t3, this, o2, {
-                start: e2,
-                end: e2 + i2 - 1
-            });
-        return !!r2;
-    }
-    draw(t3, e2, i2, s2) {
-        const n2 = this.options || {};
-        (this.points || []).length && n2.borderWidth && (t3.save(), Ca(t3, this, i2, s2), t3.restore()), this.animated && (this._pointsUpdated = false, this._path = void 0);
-    }
-}
-__publicField(LineElement, "id", "line");
-__publicField(LineElement, "defaults", {
-    borderCapStyle: "butt",
-    borderDash: [],
-    borderDashOffset: 0,
-    borderJoinStyle: "miter",
-    borderWidth: 3,
-    capBezierPoints: true,
-    cubicInterpolationMode: "default",
-    fill: false,
-    spanGaps: false,
-    stepped: false,
-    tension: 0
-});
-__publicField(LineElement, "defaultRoutes", {
-    backgroundColor: "backgroundColor",
-    borderColor: "borderColor"
-});
-__publicField(LineElement, "descriptors", {
-    _scriptable: true,
-    _indexable: (t3) => "borderDash" !== t3 && "fill" !== t3
-});
-
-function Ia(t3, e2, i2, s2) {
-    const n2 = t3.options,
-        {
-            [i2]: r2
-        } = t3.getProps([i2], s2);
-    return Math.abs(e2 - r2) < n2.radius + n2.hitRadius;
-}
-class PointElement extends Element {
-    constructor(t3) {
-        super();
-        __publicField(this, "parsed");
-        __publicField(this, "skip");
-        __publicField(this, "stop");
-        this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t3 && Object.assign(this, t3);
-    }
-    inRange(t3, e2, i2) {
-        const s2 = this.options,
-            {
-                x: n2,
-                y: r2
-            } = this.getProps(["x", "y"], i2);
-        return Math.pow(t3 - n2, 2) + Math.pow(e2 - r2, 2) < Math.pow(s2.hitRadius + s2.radius, 2);
-    }
-    inXRange(t3, e2) {
-        return Ia(this, t3, "x", e2);
-    }
-    inYRange(t3, e2) {
-        return Ia(this, t3, "y", e2);
-    }
-    getCenterPoint(t3) {
-        const {
-            x: e2,
-            y: i2
-        } = this.getProps(["x", "y"], t3);
-        return {
-            x: e2,
-            y: i2
-        };
-    }
-    size(t3) {
-        let e2 = (t3 = t3 || this.options || {}).radius || 0;
-        e2 = Math.max(e2, e2 && t3.hoverRadius || 0);
-        return 2 * (e2 + (e2 && t3.borderWidth || 0));
-    }
-    draw(t3, e2) {
-        const i2 = this.options;
-        this.skip || i2.radius < 0.1 || !nn(this, e2, this.size(i2) / 2) || (t3.strokeStyle = i2.borderColor, t3.lineWidth = i2.borderWidth, t3.fillStyle = i2.backgroundColor, sn(t3, i2, this.x, this.y));
-    }
-    getRange() {
-        const t3 = this.options || {};
-        return t3.radius + t3.hitRadius;
-    }
-}
-__publicField(PointElement, "id", "point");
-__publicField(PointElement, "defaults", {
-    borderWidth: 1,
-    hitRadius: 1,
-    hoverBorderWidth: 1,
-    hoverRadius: 4,
-    pointStyle: "circle",
-    radius: 3,
-    rotation: 0
-});
-__publicField(PointElement, "defaultRoutes", {
-    backgroundColor: "backgroundColor",
-    borderColor: "borderColor"
-});
-
-function Ma(t3, e2) {
-    const {
-        x: i2,
-        y: s2,
-        base: n2,
-        width: r2,
-        height: o2
-    } = t3.getProps(["x", "y", "base", "width", "height"], e2);
-    let a2, l2, h2, c2, u2;
-    return t3.horizontal ? (u2 = o2 / 2, a2 = Math.min(i2, n2), l2 = Math.max(i2, n2), h2 = s2 - u2, c2 = s2 + u2) : (u2 = r2 / 2, a2 = i2 - u2, l2 = i2 + u2, h2 = Math.min(s2, n2), c2 = Math.max(s2, n2)), {
-        left: a2,
-        top: h2,
-        right: l2,
-        bottom: c2
-    };
-}
-
-function Pa(t3, e2, i2, s2) {
-    return t3 ? 0 : vs(e2, i2, s2);
-}
-
-function Ra(t3) {
-    const e2 = Ma(t3),
-        i2 = e2.right - e2.left,
-        s2 = e2.bottom - e2.top,
-        n2 = function(t4, e3, i3) {
-            const s3 = t4.options.borderWidth,
-                n3 = t4.borderSkipped,
-                r3 = Rn(s3);
-            return {
-                t: Pa(n3.top, r3.top, 0, i3),
-                r: Pa(n3.right, r3.right, 0, e3),
-                b: Pa(n3.bottom, r3.bottom, 0, i3),
-                l: Pa(n3.left, r3.left, 0, e3)
-            };
-        }(t3, i2 / 2, s2 / 2),
-        r2 = function(t4, e3, i3) {
-            const {
-                enableBorderRadius: s3
-            } = t4.getProps(["enableBorderRadius"]), n3 = t4.options.borderRadius, r3 = Dn(n3), o2 = Math.min(e3, i3), a2 = t4.borderSkipped, l2 = s3 || yi(n3);
-            return {
-                topLeft: Pa(!l2 || a2.top || a2.left, r3.topLeft, 0, o2),
-                topRight: Pa(!l2 || a2.top || a2.right, r3.topRight, 0, o2),
-                bottomLeft: Pa(!l2 || a2.bottom || a2.left, r3.bottomLeft, 0, o2),
-                bottomRight: Pa(!l2 || a2.bottom || a2.right, r3.bottomRight, 0, o2)
-            };
-        }(t3, i2 / 2, s2 / 2);
-    return {
-        outer: {
-            x: e2.left,
-            y: e2.top,
-            w: i2,
-            h: s2,
-            radius: r2
-        },
-        inner: {
-            x: e2.left + n2.l,
-            y: e2.top + n2.t,
-            w: i2 - n2.l - n2.r,
-            h: s2 - n2.t - n2.b,
-            radius: {
-                topLeft: Math.max(0, r2.topLeft - Math.max(n2.t, n2.l)),
-                topRight: Math.max(0, r2.topRight - Math.max(n2.t, n2.r)),
-                bottomLeft: Math.max(0, r2.bottomLeft - Math.max(n2.b, n2.l)),
-                bottomRight: Math.max(0, r2.bottomRight - Math.max(n2.b, n2.r))
-            }
-        }
-    };
-}
-
-function Aa(t3, e2, i2, s2) {
-    const n2 = null === e2,
-        r2 = null === i2,
-        o2 = t3 && !(n2 && r2) && Ma(t3, s2);
-    return o2 && (n2 || bs(e2, o2.left, o2.right)) && (r2 || bs(i2, o2.top, o2.bottom));
-}
-
-function Da(t3, e2) {
-    t3.rect(e2.x, e2.y, e2.w, e2.h);
-}
-
-function La(t3, e2, i2 = {}) {
-    const s2 = t3.x !== i2.x ? -e2 : 0,
-        n2 = t3.y !== i2.y ? -e2 : 0,
-        r2 = (t3.x + t3.w !== i2.x + i2.w ? e2 : 0) - s2,
-        o2 = (t3.y + t3.h !== i2.y + i2.h ? e2 : 0) - n2;
-    return {
-        x: t3.x + s2,
-        y: t3.y + n2,
-        w: t3.w + r2,
-        h: t3.h + o2,
-        radius: t3.radius
-    };
-}
-class BarElement extends Element {
-    constructor(t3) {
-        super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t3 && Object.assign(this, t3);
-    }
-    draw(t3) {
-        const {
-            inflateAmount: e2,
-            options: {
-                borderColor: i2,
-                backgroundColor: s2
-            }
-        } = this, {
-            inner: n2,
-            outer: r2
-        } = Ra(this), o2 = (a2 = r2.radius).topLeft || a2.topRight || a2.bottomLeft || a2.bottomRight ? bn : Da;
-        var a2;
-        t3.save(), r2.w === n2.w && r2.h === n2.h || (t3.beginPath(), o2(t3, La(r2, e2, n2)), t3.clip(), o2(t3, La(n2, -e2, r2)), t3.fillStyle = i2, t3.fill("evenodd")), t3.beginPath(), o2(t3, La(n2, e2)), t3.fillStyle = s2, t3.fill(), t3.restore();
-    }
-    inRange(t3, e2, i2) {
-        return Aa(this, t3, e2, i2);
-    }
-    inXRange(t3, e2) {
-        return Aa(this, t3, null, e2);
-    }
-    inYRange(t3, e2) {
-        return Aa(this, null, t3, e2);
-    }
-    getCenterPoint(t3) {
-        const {
-            x: e2,
-            y: i2,
-            base: s2,
-            horizontal: n2
-        } = this.getProps(["x", "y", "base", "horizontal"], t3);
-        return {
-            x: n2 ? (e2 + s2) / 2 : e2,
-            y: n2 ? i2 : (i2 + s2) / 2
-        };
-    }
-    getRange(t3) {
-        return "x" === t3 ? this.width / 2 : this.height / 2;
-    }
-}
-__publicField(BarElement, "id", "bar");
-__publicField(BarElement, "defaults", {
-    borderSkipped: "start",
-    borderWidth: 0,
-    borderRadius: 0,
-    inflateAmount: "auto",
-    pointStyle: void 0
-});
-__publicField(BarElement, "defaultRoutes", {
-    backgroundColor: "backgroundColor",
-    borderColor: "borderColor"
-});
-const Oa = {
-    average(t3) {
-        if (!t3.length)
-            return false;
-        let e2, i2, s2 = 0,
-            n2 = 0,
-            r2 = 0;
-        for (e2 = 0, i2 = t3.length; e2 < i2; ++e2) {
-            const i3 = t3[e2].element;
-            if (i3 && i3.hasValue()) {
-                const t4 = i3.tooltipPosition();
-                s2 += t4.x, n2 += t4.y, ++r2;
-            }
-        }
-        return {
-            x: s2 / r2,
-            y: n2 / r2
-        };
-    },
-    nearest(t3, e2) {
-        if (!t3.length)
-            return false;
-        let i2, s2, n2, r2 = e2.x,
-            o2 = e2.y,
-            a2 = Number.POSITIVE_INFINITY;
-        for (i2 = 0, s2 = t3.length; i2 < s2; ++i2) {
-            const s3 = t3[i2].element;
-            if (s3 && s3.hasValue()) {
-                const t4 = ps(e2, s3.getCenterPoint());
-                t4 < a2 && (a2 = t4, n2 = s3);
-            }
-        }
-        if (n2) {
-            const t4 = n2.tooltipPosition();
-            r2 = t4.x, o2 = t4.y;
-        }
-        return {
-            x: r2,
-            y: o2
-        };
-    }
-};
-
-function Fa(t3, e2) {
-    return e2 && (ui(e2) ? Array.prototype.push.apply(t3, e2) : t3.push(e2)), t3;
-}
-
-function Na(t3) {
-    return ("string" == typeof t3 || t3 instanceof String) && t3.indexOf("\n") > -1 ? t3.split("\n") : t3;
-}
-
-function $a(t3, e2) {
-    const {
-        element: i2,
-        datasetIndex: s2,
-        index: n2
-    } = e2, r2 = t3.getDatasetMeta(s2).controller, {
-        label: o2,
-        value: a2
-    } = r2.getLabelAndValue(n2);
-    return {
-        chart: t3,
-        label: o2,
-        parsed: r2.getParsed(n2),
-        raw: t3.data.datasets[s2].data[n2],
-        formattedValue: a2,
-        dataset: r2.getDataset(),
-        dataIndex: n2,
-        datasetIndex: s2,
-        element: i2
-    };
-}
-
-function Va(t3, e2) {
-    const i2 = t3.chart.ctx,
-        {
-            body: s2,
-            footer: n2,
-            title: r2
-        } = t3,
-        {
-            boxWidth: o2,
-            boxHeight: a2
-        } = e2,
-        l2 = On(e2.bodyFont),
-        h2 = On(e2.titleFont),
-        c2 = On(e2.footerFont),
-        u2 = r2.length,
-        d2 = n2.length,
-        f2 = s2.length,
-        p2 = Ln(e2.padding);
-    let m2 = p2.height,
-        g2 = 0,
-        y2 = s2.reduce((t4, e3) => t4 + e3.before.length + e3.lines.length + e3.after.length, 0);
-    if (y2 += t3.beforeBody.length + t3.afterBody.length, u2 && (m2 += u2 * h2.lineHeight + (u2 - 1) * e2.titleSpacing + e2.titleMarginBottom), y2) {
-        m2 += f2 * (e2.displayColors ? Math.max(a2, l2.lineHeight) : l2.lineHeight) + (y2 - f2) * l2.lineHeight + (y2 - 1) * e2.bodySpacing;
-    }
-    d2 && (m2 += e2.footerMarginTop + d2 * c2.lineHeight + (d2 - 1) * e2.footerSpacing);
-    let v2 = 0;
-    const b2 = function(t4) {
-        g2 = Math.max(g2, i2.measureText(t4).width + v2);
-    };
-    return i2.save(), i2.font = h2.string, Ei(t3.title, b2), i2.font = l2.string, Ei(t3.beforeBody.concat(t3.afterBody), b2), v2 = e2.displayColors ? o2 + 2 + e2.boxPadding : 0, Ei(s2, (t4) => {
-        Ei(t4.before, b2), Ei(t4.lines, b2), Ei(t4.after, b2);
-    }), v2 = 0, i2.font = c2.string, Ei(t3.footer, b2), i2.restore(), g2 += p2.width, {
-        width: g2,
-        height: m2
-    };
-}
-
-function za(t3, e2, i2, s2) {
-    const {
-        x: n2,
-        width: r2
-    } = i2, {
-        width: o2,
-        chartArea: {
-            left: a2,
-            right: l2
-        }
-    } = t3;
-    let h2 = "center";
-    return "center" === s2 ? h2 = n2 <= (a2 + l2) / 2 ? "left" : "right" : n2 <= r2 / 2 ? h2 = "left" : n2 >= o2 - r2 / 2 && (h2 = "right"),
-        function(t4, e3, i3, s3) {
-            const {
-                x: n3,
-                width: r3
-            } = s3, o3 = i3.caretSize + i3.caretPadding;
-            return "left" === t4 && n3 + r3 + o3 > e3.width || "right" === t4 && n3 - r3 - o3 < 0 || void 0;
-        }(h2, t3, e2, i2) && (h2 = "center"), h2;
-}
-
-function Ba(t3, e2, i2) {
-    const s2 = i2.yAlign || e2.yAlign || function(t4, e3) {
-        const {
-            y: i3,
-            height: s3
-        } = e3;
-        return i3 < s3 / 2 ? "top" : i3 > t4.height - s3 / 2 ? "bottom" : "center";
-    }(t3, i2);
-    return {
-        xAlign: i2.xAlign || e2.xAlign || za(t3, e2, i2, s2),
-        yAlign: s2
-    };
-}
-
-function Ua(t3, e2, i2, s2) {
-    const {
-        caretSize: n2,
-        caretPadding: r2,
-        cornerRadius: o2
-    } = t3, {
-        xAlign: a2,
-        yAlign: l2
-    } = i2, h2 = n2 + r2, {
-        topLeft: c2,
-        topRight: u2,
-        bottomLeft: d2,
-        bottomRight: f2
-    } = Dn(o2);
-    let p2 = function(t4, e3) {
-        let {
-            x: i3,
-            width: s3
-        } = t4;
-        return "right" === e3 ? i3 -= s3 : "center" === e3 && (i3 -= s3 / 2), i3;
-    }(e2, a2);
-    const m2 = function(t4, e3, i3) {
-        let {
-            y: s3,
-            height: n3
-        } = t4;
-        return "top" === e3 ? s3 += i3 : s3 -= "bottom" === e3 ? n3 + i3 : n3 / 2, s3;
-    }(e2, l2, h2);
-    return "center" === l2 ? "left" === a2 ? p2 += h2 : "right" === a2 && (p2 -= h2) : "left" === a2 ? p2 -= Math.max(c2, d2) + n2 : "right" === a2 && (p2 += Math.max(u2, f2) + n2), {
-        x: vs(p2, 0, s2.width - e2.width),
-        y: vs(m2, 0, s2.height - e2.height)
-    };
-}
-
-function ja(t3, e2, i2) {
-    const s2 = Ln(i2.padding);
-    return "center" === e2 ? t3.x + t3.width / 2 : "right" === e2 ? t3.x + t3.width - s2.right : t3.x + s2.left;
-}
-
-function Ha(t3) {
-    return Fa([], Na(t3));
-}
-
-function Wa(t3, e2) {
-    const i2 = e2 && e2.dataset && e2.dataset.tooltip && e2.dataset.tooltip.callbacks;
-    return i2 ? t3.override(i2) : t3;
-}
-const qa = {
-    beforeTitle: li,
-    title(t3) {
-        if (t3.length > 0) {
-            const e2 = t3[0],
-                i2 = e2.chart.data.labels,
-                s2 = i2 ? i2.length : 0;
-            if (this && this.options && "dataset" === this.options.mode)
-                return e2.dataset.label || "";
-            if (e2.label)
-                return e2.label;
-            if (s2 > 0 && e2.dataIndex < s2)
-                return i2[e2.dataIndex];
-        }
-        return "";
-    },
-    afterTitle: li,
-    beforeBody: li,
-    beforeLabel: li,
-    label(t3) {
-        if (this && this.options && "dataset" === this.options.mode)
-            return t3.label + ": " + t3.formattedValue || t3.formattedValue;
-        let e2 = t3.dataset.label || "";
-        e2 && (e2 += ": ");
-        const i2 = t3.formattedValue;
-        return ci(i2) || (e2 += i2), e2;
-    },
-    labelColor(t3) {
-        const e2 = t3.chart.getDatasetMeta(t3.datasetIndex).controller.getStyle(t3.dataIndex);
-        return {
-            borderColor: e2.borderColor,
-            backgroundColor: e2.backgroundColor,
-            borderWidth: e2.borderWidth,
-            borderDash: e2.borderDash,
-            borderDashOffset: e2.borderDashOffset,
-            borderRadius: 0
-        };
-    },
-    labelTextColor() {
-        return this.options.bodyColor;
-    },
-    labelPointStyle(t3) {
-        const e2 = t3.chart.getDatasetMeta(t3.datasetIndex).controller.getStyle(t3.dataIndex);
-        return {
-            pointStyle: e2.pointStyle,
-            rotation: e2.rotation
-        };
-    },
-    afterLabel: li,
-    afterBody: li,
-    beforeFooter: li,
-    footer: li,
-    afterFooter: li
-};
-
-function Ka(t3, e2, i2, s2) {
-    const n2 = t3[e2].call(i2, s2);
-    return void 0 === n2 ? qa[e2].call(i2, s2) : n2;
-}
-class Tooltip extends Element {
-    constructor(t3) {
-        super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t3.chart, this.options = t3.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
-    }
-    initialize(t3) {
-        this.options = t3, this._cachedAnimations = void 0, this.$context = void 0;
-    }
-    _resolveAnimations() {
-        const t3 = this._cachedAnimations;
-        if (t3)
-            return t3;
-        const e2 = this.chart,
-            i2 = this.options.setContext(this.getContext()),
-            s2 = i2.enabled && e2.options.animation && i2.animations,
-            n2 = new Animations(this.chart, s2);
-        return s2._cacheable && (this._cachedAnimations = Object.freeze(n2)), n2;
-    }
-    getContext() {
-        return this.$context || (this.$context = function(t3, e2, i2) {
-            return $n(t3, {
-                tooltip: e2,
-                tooltipItems: i2,
-                type: "tooltip"
-            });
-        }(this.chart.getContext(), this, this._tooltipItems));
-    }
-    getTitle(t3, e2) {
-        const {
-            callbacks: i2
-        } = e2, s2 = Ka(i2, "beforeTitle", this, t3), n2 = Ka(i2, "title", this, t3), r2 = Ka(i2, "afterTitle", this, t3);
-        let o2 = [];
-        return o2 = Fa(o2, Na(s2)), o2 = Fa(o2, Na(n2)), o2 = Fa(o2, Na(r2)), o2;
-    }
-    getBeforeBody(t3, e2) {
-        return Ha(Ka(e2.callbacks, "beforeBody", this, t3));
-    }
-    getBody(t3, e2) {
-        const {
-            callbacks: i2
-        } = e2, s2 = [];
-        return Ei(t3, (t4) => {
-            const e3 = {
-                    before: [],
-                    lines: [],
-                    after: []
-                },
-                n2 = Wa(i2, t4);
-            Fa(e3.before, Na(Ka(n2, "beforeLabel", this, t4))), Fa(e3.lines, Ka(n2, "label", this, t4)), Fa(e3.after, Na(Ka(n2, "afterLabel", this, t4))), s2.push(e3);
-        }), s2;
-    }
-    getAfterBody(t3, e2) {
-        return Ha(Ka(e2.callbacks, "afterBody", this, t3));
-    }
-    getFooter(t3, e2) {
-        const {
-            callbacks: i2
-        } = e2, s2 = Ka(i2, "beforeFooter", this, t3), n2 = Ka(i2, "footer", this, t3), r2 = Ka(i2, "afterFooter", this, t3);
-        let o2 = [];
-        return o2 = Fa(o2, Na(s2)), o2 = Fa(o2, Na(n2)), o2 = Fa(o2, Na(r2)), o2;
-    }
-    _createItems(t3) {
-        const e2 = this._active,
-            i2 = this.chart.data,
-            s2 = [],
-            n2 = [],
-            r2 = [];
-        let o2, a2, l2 = [];
-        for (o2 = 0, a2 = e2.length; o2 < a2; ++o2)
-            l2.push($a(this.chart, e2[o2]));
-        return t3.filter && (l2 = l2.filter((e3, s3, n3) => t3.filter(e3, s3, n3, i2))), t3.itemSort && (l2 = l2.sort((e3, s3) => t3.itemSort(e3, s3, i2))), Ei(l2, (e3) => {
-            const i3 = Wa(t3.callbacks, e3);
-            s2.push(Ka(i3, "labelColor", this, e3)), n2.push(Ka(i3, "labelPointStyle", this, e3)), r2.push(Ka(i3, "labelTextColor", this, e3));
-        }), this.labelColors = s2, this.labelPointStyles = n2, this.labelTextColors = r2, this.dataPoints = l2, l2;
-    }
-    update(t3, e2) {
-        const i2 = this.options.setContext(this.getContext()),
-            s2 = this._active;
-        let n2, r2 = [];
-        if (s2.length) {
-            const t4 = Oa[i2.position].call(this, s2, this._eventPosition);
-            r2 = this._createItems(i2), this.title = this.getTitle(r2, i2), this.beforeBody = this.getBeforeBody(r2, i2), this.body = this.getBody(r2, i2), this.afterBody = this.getAfterBody(r2, i2), this.footer = this.getFooter(r2, i2);
-            const e3 = this._size = Va(this, i2),
-                o2 = Object.assign({}, t4, e3),
-                a2 = Ba(this.chart, i2, o2),
-                l2 = Ua(i2, o2, a2, this.chart);
-            this.xAlign = a2.xAlign, this.yAlign = a2.yAlign, n2 = {
-                opacity: 1,
-                x: l2.x,
-                y: l2.y,
-                width: e3.width,
-                height: e3.height,
-                caretX: t4.x,
-                caretY: t4.y
-            };
-        } else
-            0 !== this.opacity && (n2 = {
-                opacity: 0
-            });
-        this._tooltipItems = r2, this.$context = void 0, n2 && this._resolveAnimations().update(this, n2), t3 && i2.external && i2.external.call(this, {
-            chart: this.chart,
-            tooltip: this,
-            replay: e2
-        });
-    }
-    drawCaret(t3, e2, i2, s2) {
-        const n2 = this.getCaretPosition(t3, i2, s2);
-        e2.lineTo(n2.x1, n2.y1), e2.lineTo(n2.x2, n2.y2), e2.lineTo(n2.x3, n2.y3);
-    }
-    getCaretPosition(t3, e2, i2) {
-        const {
-            xAlign: s2,
-            yAlign: n2
-        } = this, {
-            caretSize: r2,
-            cornerRadius: o2
-        } = i2, {
-            topLeft: a2,
-            topRight: l2,
-            bottomLeft: h2,
-            bottomRight: c2
-        } = Dn(o2), {
-            x: u2,
-            y: d2
-        } = t3, {
-            width: f2,
-            height: p2
-        } = e2;
-        let m2, g2, y2, v2, b2, _2;
-        return "center" === n2 ? (b2 = d2 + p2 / 2, "left" === s2 ? (m2 = u2, g2 = m2 - r2, v2 = b2 + r2, _2 = b2 - r2) : (m2 = u2 + f2, g2 = m2 + r2, v2 = b2 - r2, _2 = b2 + r2), y2 = m2) : (g2 = "left" === s2 ? u2 + Math.max(a2, h2) + r2 : "right" === s2 ? u2 + f2 - Math.max(l2, c2) - r2 : this.caretX, "top" === n2 ? (v2 = d2, b2 = v2 - r2, m2 = g2 - r2, y2 = g2 + r2) : (v2 = d2 + p2, b2 = v2 + r2, m2 = g2 + r2, y2 = g2 - r2), _2 = v2), {
-            x1: m2,
-            x2: g2,
-            x3: y2,
-            y1: v2,
-            y2: b2,
-            y3: _2
-        };
-    }
-    drawTitle(t3, e2, i2) {
-        const s2 = this.title,
-            n2 = s2.length;
-        let r2, o2, a2;
-        if (n2) {
-            const l2 = Er(i2.rtl, this.x, this.width);
-            for (t3.x = ja(this, i2.titleAlign, i2), e2.textAlign = l2.textAlign(i2.titleAlign), e2.textBaseline = "middle", r2 = On(i2.titleFont), o2 = i2.titleSpacing, e2.fillStyle = i2.titleColor, e2.font = r2.string, a2 = 0; a2 < n2; ++a2)
-                e2.fillText(s2[a2], l2.x(t3.x), t3.y + r2.lineHeight / 2), t3.y += r2.lineHeight + o2, a2 + 1 === n2 && (t3.y += i2.titleMarginBottom - o2);
-        }
-    }
-    _drawColorBox(t3, e2, i2, s2, n2) {
-        const r2 = this.labelColors[i2],
-            o2 = this.labelPointStyles[i2],
-            {
-                boxHeight: a2,
-                boxWidth: l2
-            } = n2,
-            h2 = On(n2.bodyFont),
-            c2 = ja(this, "left", n2),
-            u2 = s2.x(c2),
-            d2 = a2 < h2.lineHeight ? (h2.lineHeight - a2) / 2 : 0,
-            f2 = e2.y + d2;
-        if (n2.usePointStyle) {
-            const e3 = {
-                    radius: Math.min(l2, a2) / 2,
-                    pointStyle: o2.pointStyle,
-                    rotation: o2.rotation,
-                    borderWidth: 1
-                },
-                i3 = s2.leftForLtr(u2, l2) + l2 / 2,
-                h3 = f2 + a2 / 2;
-            t3.strokeStyle = n2.multiKeyBackground, t3.fillStyle = n2.multiKeyBackground, sn(t3, e3, i3, h3), t3.strokeStyle = r2.borderColor, t3.fillStyle = r2.backgroundColor, sn(t3, e3, i3, h3);
-        } else {
-            t3.lineWidth = yi(r2.borderWidth) ? Math.max(...Object.values(r2.borderWidth)) : r2.borderWidth || 1, t3.strokeStyle = r2.borderColor, t3.setLineDash(r2.borderDash || []), t3.lineDashOffset = r2.borderDashOffset || 0;
-            const e3 = s2.leftForLtr(u2, l2),
-                i3 = s2.leftForLtr(s2.xPlus(u2, 1), l2 - 2),
-                o3 = Dn(r2.borderRadius);
-            Object.values(o3).some((t4) => 0 !== t4) ? (t3.beginPath(), t3.fillStyle = n2.multiKeyBackground, bn(t3, {
-                x: e3,
-                y: f2,
-                w: l2,
-                h: a2,
-                radius: o3
-            }), t3.fill(), t3.stroke(), t3.fillStyle = r2.backgroundColor, t3.beginPath(), bn(t3, {
-                x: i3,
-                y: f2 + 1,
-                w: l2 - 2,
-                h: a2 - 2,
-                radius: o3
-            }), t3.fill()) : (t3.fillStyle = n2.multiKeyBackground, t3.fillRect(e3, f2, l2, a2), t3.strokeRect(e3, f2, l2, a2), t3.fillStyle = r2.backgroundColor, t3.fillRect(i3, f2 + 1, l2 - 2, a2 - 2));
-        }
-        t3.fillStyle = this.labelTextColors[i2];
-    }
-    drawBody(t3, e2, i2) {
-        const {
-            body: s2
-        } = this, {
-            bodySpacing: n2,
-            bodyAlign: r2,
-            displayColors: o2,
-            boxHeight: a2,
-            boxWidth: l2,
-            boxPadding: h2
-        } = i2, c2 = On(i2.bodyFont);
-        let u2 = c2.lineHeight,
-            d2 = 0;
-        const f2 = Er(i2.rtl, this.x, this.width),
-            p2 = function(i3) {
-                e2.fillText(i3, f2.x(t3.x + d2), t3.y + u2 / 2), t3.y += u2 + n2;
-            },
-            m2 = f2.textAlign(r2);
-        let g2, y2, v2, b2, _2, w2, x2;
-        for (e2.textAlign = r2, e2.textBaseline = "middle", e2.font = c2.string, t3.x = ja(this, m2, i2), e2.fillStyle = i2.bodyColor, Ei(this.beforeBody, p2), d2 = o2 && "right" !== m2 ? "center" === r2 ? l2 / 2 + h2 : l2 + 2 + h2 : 0, b2 = 0, w2 = s2.length; b2 < w2; ++b2) {
-            for (g2 = s2[b2], y2 = this.labelTextColors[b2], e2.fillStyle = y2, Ei(g2.before, p2), v2 = g2.lines, o2 && v2.length && (this._drawColorBox(e2, t3, b2, f2, i2), u2 = Math.max(c2.lineHeight, a2)), _2 = 0, x2 = v2.length; _2 < x2; ++_2)
-                p2(v2[_2]), u2 = c2.lineHeight;
-            Ei(g2.after, p2);
-        }
-        d2 = 0, u2 = c2.lineHeight, Ei(this.afterBody, p2), t3.y -= n2;
-    }
-    drawFooter(t3, e2, i2) {
-        const s2 = this.footer,
-            n2 = s2.length;
-        let r2, o2;
-        if (n2) {
-            const a2 = Er(i2.rtl, this.x, this.width);
-            for (t3.x = ja(this, i2.footerAlign, i2), t3.y += i2.footerMarginTop, e2.textAlign = a2.textAlign(i2.footerAlign), e2.textBaseline = "middle", r2 = On(i2.footerFont), e2.fillStyle = i2.footerColor, e2.font = r2.string, o2 = 0; o2 < n2; ++o2)
-                e2.fillText(s2[o2], a2.x(t3.x), t3.y + r2.lineHeight / 2), t3.y += r2.lineHeight + i2.footerSpacing;
-        }
-    }
-    drawBackground(t3, e2, i2, s2) {
-        const {
-            xAlign: n2,
-            yAlign: r2
-        } = this, {
-            x: o2,
-            y: a2
-        } = t3, {
-            width: l2,
-            height: h2
-        } = i2, {
-            topLeft: c2,
-            topRight: u2,
-            bottomLeft: d2,
-            bottomRight: f2
-        } = Dn(s2.cornerRadius);
-        e2.fillStyle = s2.backgroundColor, e2.strokeStyle = s2.borderColor, e2.lineWidth = s2.borderWidth, e2.beginPath(), e2.moveTo(o2 + c2, a2), "top" === r2 && this.drawCaret(t3, e2, i2, s2), e2.lineTo(o2 + l2 - u2, a2), e2.quadraticCurveTo(o2 + l2, a2, o2 + l2, a2 + u2), "center" === r2 && "right" === n2 && this.drawCaret(t3, e2, i2, s2), e2.lineTo(o2 + l2, a2 + h2 - f2), e2.quadraticCurveTo(o2 + l2, a2 + h2, o2 + l2 - f2, a2 + h2), "bottom" === r2 && this.drawCaret(t3, e2, i2, s2), e2.lineTo(o2 + d2, a2 + h2), e2.quadraticCurveTo(o2, a2 + h2, o2, a2 + h2 - d2), "center" === r2 && "left" === n2 && this.drawCaret(t3, e2, i2, s2), e2.lineTo(o2, a2 + c2), e2.quadraticCurveTo(o2, a2, o2 + c2, a2), e2.closePath(), e2.fill(), s2.borderWidth > 0 && e2.stroke();
-    }
-    _updateAnimationTarget(t3) {
-        const e2 = this.chart,
-            i2 = this.$animations,
-            s2 = i2 && i2.x,
-            n2 = i2 && i2.y;
-        if (s2 || n2) {
-            const i3 = Oa[t3.position].call(this, this._active, this._eventPosition);
-            if (!i3)
-                return;
-            const r2 = this._size = Va(this, t3),
-                o2 = Object.assign({}, i3, this._size),
-                a2 = Ba(e2, t3, o2),
-                l2 = Ua(t3, o2, a2, e2);
-            s2._to === l2.x && n2._to === l2.y || (this.xAlign = a2.xAlign, this.yAlign = a2.yAlign, this.width = r2.width, this.height = r2.height, this.caretX = i3.x, this.caretY = i3.y, this._resolveAnimations().update(this, l2));
-        }
-    }
-    _willRender() {
-        return !!this.opacity;
-    }
-    draw(t3) {
-        const e2 = this.options.setContext(this.getContext());
-        let i2 = this.opacity;
-        if (!i2)
-            return;
-        this._updateAnimationTarget(e2);
-        const s2 = {
-                width: this.width,
-                height: this.height
-            },
-            n2 = {
-                x: this.x,
-                y: this.y
-            };
-        i2 = Math.abs(i2) < 1e-3 ? 0 : i2;
-        const r2 = Ln(e2.padding),
-            o2 = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
-        e2.enabled && o2 && (t3.save(), t3.globalAlpha = i2, this.drawBackground(n2, t3, s2, e2), function(t4, e3) {
-            let i3, s3;
-            "ltr" !== e3 && "rtl" !== e3 || (i3 = t4.canvas.style, s3 = [i3.getPropertyValue("direction"), i3.getPropertyPriority("direction")], i3.setProperty("direction", e3, "important"), t4.prevTextDirection = s3);
-        }(t3, e2.textDirection), n2.y += r2.top, this.drawTitle(n2, t3, e2), this.drawBody(n2, t3, e2), this.drawFooter(n2, t3, e2), function(t4, e3) {
-            void 0 !== e3 && (delete t4.prevTextDirection, t4.canvas.style.setProperty("direction", e3[0], e3[1]));
-        }(t3, e2.textDirection), t3.restore());
-    }
-    getActiveElements() {
-        return this._active || [];
-    }
-    setActiveElements(t3, e2) {
-        const i2 = this._active,
-            s2 = t3.map(({
-                datasetIndex: t4,
-                index: e3
-            }) => {
-                const i3 = this.chart.getDatasetMeta(t4);
-                if (!i3)
-                    throw new Error("Cannot find a dataset at index " + t4);
-                return {
-                    datasetIndex: t4,
-                    element: i3.data[e3],
-                    index: e3
-                };
-            }),
-            n2 = !Ii(i2, s2),
-            r2 = this._positionChanged(s2, e2);
-        (n2 || r2) && (this._active = s2, this._eventPosition = e2, this._ignoreReplayEvents = true, this.update(true));
-    }
-    handleEvent(t3, e2, i2 = true) {
-        if (e2 && this._ignoreReplayEvents)
-            return false;
-        this._ignoreReplayEvents = false;
-        const s2 = this.options,
-            n2 = this._active || [],
-            r2 = this._getActiveElements(t3, n2, e2, i2),
-            o2 = this._positionChanged(r2, t3),
-            a2 = e2 || !Ii(r2, n2) || o2;
-        return a2 && (this._active = r2, (s2.enabled || s2.external) && (this._eventPosition = {
-            x: t3.x,
-            y: t3.y
-        }, this.update(true, e2))), a2;
-    }
-    _getActiveElements(t3, e2, i2, s2) {
-        const n2 = this.options;
-        if ("mouseout" === t3.type)
-            return [];
-        if (!s2)
-            return e2;
-        const r2 = this.chart.getElementsAtEventForMode(t3, n2.mode, n2, i2);
-        return n2.reverse && r2.reverse(), r2;
-    }
-    _positionChanged(t3, e2) {
-        const {
-            caretX: i2,
-            caretY: s2,
-            options: n2
-        } = this, r2 = Oa[n2.position].call(this, t3, e2);
-        return false !== r2 && (i2 !== r2.x || s2 !== r2.y);
-    }
-}
-__publicField(Tooltip, "positioners", Oa);
-var Ga = {
-    id: "tooltip",
-    _element: Tooltip,
-    positioners: Oa,
-    afterInit(t3, e2, i2) {
-        i2 && (t3.tooltip = new Tooltip({
-            chart: t3,
-            options: i2
-        }));
-    },
-    beforeUpdate(t3, e2, i2) {
-        t3.tooltip && t3.tooltip.initialize(i2);
-    },
-    reset(t3, e2, i2) {
-        t3.tooltip && t3.tooltip.initialize(i2);
-    },
-    afterDraw(t3) {
-        const e2 = t3.tooltip;
-        if (e2 && e2._willRender()) {
-            const i2 = {
-                tooltip: e2
-            };
-            if (false === t3.notifyPlugins("beforeTooltipDraw", {
-                    ...i2,
-                    cancelable: true
-                }))
-                return;
-            e2.draw(t3.ctx), t3.notifyPlugins("afterTooltipDraw", i2);
-        }
-    },
-    afterEvent(t3, e2) {
-        if (t3.tooltip) {
-            const i2 = e2.replay;
-            t3.tooltip.handleEvent(e2.event, i2, e2.inChartArea) && (e2.changed = true);
-        }
-    },
-    defaults: {
-        enabled: true,
-        external: null,
-        position: "average",
-        backgroundColor: "rgba(0,0,0,0.8)",
-        titleColor: "#fff",
-        titleFont: {
-            weight: "bold"
-        },
-        titleSpacing: 2,
-        titleMarginBottom: 6,
-        titleAlign: "left",
-        bodyColor: "#fff",
-        bodySpacing: 2,
-        bodyFont: {},
-        bodyAlign: "left",
-        footerColor: "#fff",
-        footerSpacing: 2,
-        footerMarginTop: 6,
-        footerFont: {
-            weight: "bold"
-        },
-        footerAlign: "left",
-        padding: 6,
-        caretPadding: 2,
-        caretSize: 5,
-        cornerRadius: 6,
-        boxHeight: (t3, e2) => e2.bodyFont.size,
-        boxWidth: (t3, e2) => e2.bodyFont.size,
-        multiKeyBackground: "#fff",
-        displayColors: true,
-        boxPadding: 0,
-        borderColor: "rgba(0,0,0,0)",
-        borderWidth: 0,
-        animation: {
-            duration: 400,
-            easing: "easeOutQuart"
-        },
-        animations: {
-            numbers: {
-                type: "number",
-                properties: ["x", "y", "width", "height", "caretX", "caretY"]
-            },
-            opacity: {
-                easing: "linear",
-                duration: 200
-            }
-        },
-        callbacks: qa
-    },
-    defaultRoutes: {
-        bodyFont: "font",
-        footerFont: "font",
-        titleFont: "font"
-    },
-    descriptors: {
-        _scriptable: (t3) => "filter" !== t3 && "itemSort" !== t3 && "external" !== t3,
-        _indexable: false,
-        callbacks: {
-            _scriptable: false,
-            _indexable: false
-        },
-        animation: {
-            _fallback: false
-        },
-        animations: {
-            _fallback: "animation"
-        }
-    },
-    additionalOptionScopes: ["interaction"]
-};
-
-function Ya(t3, e2, i2, s2) {
-    const n2 = t3.indexOf(e2);
-    if (-1 === n2)
-        return ((t4, e3, i3, s3) => ("string" == typeof e3 ? (i3 = t4.push(e3) - 1, s3.unshift({
-            index: i3,
-            label: e3
-        })) : isNaN(e3) && (i3 = null), i3))(t3, e2, i2, s2);
-    return n2 !== t3.lastIndexOf(e2) ? i2 : n2;
-}
-
-function Qa(t3) {
-    const e2 = this.getLabels();
-    return t3 >= 0 && t3 < e2.length ? e2[t3] : t3;
-}
-class CategoryScale extends Scale {
-    constructor(t3) {
-        super(t3), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];
-    }
-    init(t3) {
-        const e2 = this._addedLabels;
-        if (e2.length) {
-            const t4 = this.getLabels();
-            for (const {
-                    index: i2,
-                    label: s2
-                }
-                of e2)
-                t4[i2] === s2 && t4.splice(i2, 1);
-            this._addedLabels = [];
-        }
-        super.init(t3);
-    }
-    parse(t3, e2) {
-        if (ci(t3))
-            return null;
-        const i2 = this.getLabels();
-        return ((t4, e3) => null === t4 ? null : vs(Math.round(t4), 0, e3))(e2 = isFinite(e2) && i2[e2] === t3 ? e2 : Ya(i2, t3, Ti(e2, t3), this._addedLabels), i2.length - 1);
-    }
-    determineDataLimits() {
-        const {
-            minDefined: t3,
-            maxDefined: e2
-        } = this.getUserBounds();
-        let {
-            min: i2,
-            max: s2
-        } = this.getMinMax(true);
-        "ticks" === this.options.bounds && (t3 || (i2 = 0), e2 || (s2 = this.getLabels().length - 1)), this.min = i2, this.max = s2;
-    }
-    buildTicks() {
-        const t3 = this.min,
-            e2 = this.max,
-            i2 = this.options.offset,
-            s2 = [];
-        let n2 = this.getLabels();
-        n2 = 0 === t3 && e2 === n2.length - 1 ? n2 : n2.slice(t3, e2 + 1), this._valueRange = Math.max(n2.length - (i2 ? 0 : 1), 1), this._startValue = this.min - (i2 ? 0.5 : 0);
-        for (let i3 = t3; i3 <= e2; i3++)
-            s2.push({
-                value: i3
-            });
-        return s2;
-    }
-    getLabelForValue(t3) {
-        return Qa.call(this, t3);
-    }
-    configure() {
-        super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);
-    }
-    getPixelForValue(t3) {
-        return "number" != typeof t3 && (t3 = this.parse(t3)), null === t3 ? NaN : this.getPixelForDecimal((t3 - this._startValue) / this._valueRange);
-    }
-    getPixelForTick(t3) {
-        const e2 = this.ticks;
-        return t3 < 0 || t3 > e2.length - 1 ? null : this.getPixelForValue(e2[t3].value);
-    }
-    getValueForPixel(t3) {
-        return Math.round(this._startValue + this.getDecimalForPixel(t3) * this._valueRange);
-    }
-    getBasePixel() {
-        return this.bottom;
-    }
-}
-__publicField(CategoryScale, "id", "category");
-__publicField(CategoryScale, "defaults", {
-    ticks: {
-        callback: Qa
-    }
-});
-
-function Xa(t3, e2) {
-    const i2 = [],
-        {
-            bounds: s2,
-            step: n2,
-            min: r2,
-            max: o2,
-            precision: a2,
-            count: l2,
-            maxTicks: h2,
-            maxDigits: c2,
-            includeBounds: u2
-        } = t3,
-        d2 = n2 || 1,
-        f2 = h2 - 1,
-        {
-            min: p2,
-            max: m2
-        } = e2,
-        g2 = !ci(r2),
-        y2 = !ci(o2),
-        v2 = !ci(l2),
-        b2 = (m2 - p2) / (c2 + 1);
-    let _2, w2, x2, k2, T2 = ls((m2 - p2) / f2 / d2) * d2;
-    if (T2 < 1e-14 && !g2 && !y2)
-        return [{
-            value: p2
-        }, {
-            value: m2
-        }];
-    k2 = Math.ceil(m2 / T2) - Math.floor(p2 / T2), k2 > f2 && (T2 = ls(k2 * T2 / f2 / d2) * d2), ci(a2) || (_2 = Math.pow(10, a2), T2 = Math.ceil(T2 * _2) / _2), "ticks" === s2 ? (w2 = Math.floor(p2 / T2) * T2, x2 = Math.ceil(m2 / T2) * T2) : (w2 = p2, x2 = m2), g2 && y2 && n2 && function(t4, e3) {
-        const i3 = Math.round(t4);
-        return i3 - e3 <= t4 && i3 + e3 >= t4;
-    }((o2 - r2) / n2, T2 / 1e3) ? (k2 = Math.round(Math.min((o2 - r2) / T2, h2)), T2 = (o2 - r2) / k2, w2 = r2, x2 = o2) : v2 ? (w2 = g2 ? r2 : w2, x2 = y2 ? o2 : x2, k2 = l2 - 1, T2 = (x2 - w2) / k2) : (k2 = (x2 - w2) / T2, k2 = as(k2, Math.round(k2), T2 / 1e3) ? Math.round(k2) : Math.ceil(k2));
-    const S2 = Math.max(fs(T2), fs(w2));
-    _2 = Math.pow(10, ci(a2) ? S2 : a2), w2 = Math.round(w2 * _2) / _2, x2 = Math.round(x2 * _2) / _2;
-    let E2 = 0;
-    for (g2 && (u2 && w2 !== r2 ? (i2.push({
-            value: r2
-        }), w2 < r2 && E2++, as(Math.round((w2 + E2 * T2) * _2) / _2, r2, Ja(r2, b2, t3)) && E2++) : w2 < r2 && E2++); E2 < k2; ++E2) {
-        const t4 = Math.round((w2 + E2 * T2) * _2) / _2;
-        if (y2 && t4 > o2)
-            break;
-        i2.push({
-            value: t4
-        });
-    }
-    return y2 && u2 && x2 !== o2 ? i2.length && as(i2[i2.length - 1].value, o2, Ja(o2, b2, t3)) ? i2[i2.length - 1].value = o2 : i2.push({
-        value: o2
-    }) : y2 && x2 !== o2 || i2.push({
-        value: x2
-    }), i2;
-}
-
-function Ja(t3, e2, {
-    horizontal: i2,
-    minRotation: s2
-}) {
-    const n2 = us(s2),
-        r2 = (i2 ? Math.sin(n2) : Math.cos(n2)) || 1e-3,
-        o2 = 0.75 * e2 * ("" + t3).length;
-    return Math.min(e2 / r2, o2);
-}
-class LinearScaleBase extends Scale {
-    constructor(t3) {
-        super(t3), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
-    }
-    parse(t3, e2) {
-        return ci(t3) || ("number" == typeof t3 || t3 instanceof Number) && !isFinite(+t3) ? null : +t3;
-    }
-    handleTickRangeOptions() {
-        const {
-            beginAtZero: t3
-        } = this.options, {
-            minDefined: e2,
-            maxDefined: i2
-        } = this.getUserBounds();
-        let {
-            min: s2,
-            max: n2
-        } = this;
-        const r2 = (t4) => s2 = e2 ? s2 : t4,
-            o2 = (t4) => n2 = i2 ? n2 : t4;
-        if (t3) {
-            const t4 = os(s2),
-                e3 = os(n2);
-            t4 < 0 && e3 < 0 ? o2(0) : t4 > 0 && e3 > 0 && r2(0);
-        }
-        if (s2 === n2) {
-            let e3 = 0 === n2 ? 1 : Math.abs(0.05 * n2);
-            o2(n2 + e3), t3 || r2(s2 - e3);
-        }
-        this.min = s2, this.max = n2;
-    }
-    getTickLimit() {
-        const t3 = this.options.ticks;
-        let e2, {
-            maxTicksLimit: i2,
-            stepSize: s2
-        } = t3;
-        return s2 ? (e2 = Math.ceil(this.max / s2) - Math.floor(this.min / s2) + 1, e2 > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${s2} would result generating up to ${e2} ticks. Limiting to 1000.`), e2 = 1e3)) : (e2 = this.computeTickLimit(), i2 = i2 || 11), i2 && (e2 = Math.min(i2, e2)), e2;
-    }
-    computeTickLimit() {
-        return Number.POSITIVE_INFINITY;
-    }
-    buildTicks() {
-        const t3 = this.options,
-            e2 = t3.ticks;
-        let i2 = this.getTickLimit();
-        i2 = Math.max(2, i2);
-        const s2 = Xa({
-            maxTicks: i2,
-            bounds: t3.bounds,
-            min: t3.min,
-            max: t3.max,
-            precision: e2.precision,
-            step: e2.stepSize,
-            count: e2.count,
-            maxDigits: this._maxDigits(),
-            horizontal: this.isHorizontal(),
-            minRotation: e2.minRotation || 0,
-            includeBounds: false !== e2.includeBounds
-        }, this._range || this);
-        return "ticks" === t3.bounds && cs(s2, this, "value"), t3.reverse ? (s2.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), s2;
-    }
-    configure() {
-        const t3 = this.ticks;
-        let e2 = this.min,
-            i2 = this.max;
-        if (super.configure(), this.options.offset && t3.length) {
-            const s2 = (i2 - e2) / Math.max(t3.length - 1, 1) / 2;
-            e2 -= s2, i2 += s2;
-        }
-        this._startValue = e2, this._endValue = i2, this._valueRange = i2 - e2;
-    }
-    getLabelForValue(t3) {
-        return Us(t3, this.chart.options.locale, this.options.ticks.format);
-    }
-}
-class LinearScale extends LinearScaleBase {
-    determineDataLimits() {
-        const {
-            min: t3,
-            max: e2
-        } = this.getMinMax(true);
-        this.min = _i(t3) ? t3 : 0, this.max = _i(e2) ? e2 : 1, this.handleTickRangeOptions();
-    }
-    computeTickLimit() {
-        const t3 = this.isHorizontal(),
-            e2 = t3 ? this.width : this.height,
-            i2 = us(this.options.ticks.minRotation),
-            s2 = (t3 ? Math.sin(i2) : Math.cos(i2)) || 1e-3,
-            n2 = this._resolveTickFontOptions(0);
-        return Math.ceil(e2 / Math.min(40, n2.lineHeight / s2));
-    }
-    getPixelForValue(t3) {
-        return null === t3 ? NaN : this.getPixelForDecimal((t3 - this._startValue) / this._valueRange);
-    }
-    getValueForPixel(t3) {
-        return this._startValue + this.getDecimalForPixel(t3) * this._valueRange;
-    }
-}
-__publicField(LinearScale, "id", "linear");
-__publicField(LinearScale, "defaults", {
-    ticks: {
-        callback: Ks.formatters.numeric
-    }
-});
-Ks.formatters.logarithmic;
-Ks.formatters.numeric;
-const Za = {
-    welcome: "Welcome to inlang",
-    title: "相信數據。科學投資",
-    subtitle: "科技驅動投資革命，數據分析引領市場趨勢，現在就跳上科技潮流，創造真正的被動收入！",
-    actionButton: "我要掀起投資革命",
-    profitability: {
-        historicalReturn: "歷史績效",
-        stockList: "持股報酬",
-        monthlyReturn: "月報酬",
-        monthlyWinRatio: "月勝率",
-        avgMonthlyReturn: "平均月報酬"
-    },
-    "profitability.YearlyCompareWithBenchmark": "與大盤年報酬比較",
-    "profitability.yearlyWinRate": "贏大盤",
-    strategy: "策略",
-    benchmark: "大盤",
-    "profitability.exceedReturn": "超額報酬",
-    average: "平均",
-    "risk.drawdownPercentage": "回檔幅度",
-    "risk.drawdowPeriods": "虧損歷史",
-    tabs: {
-        profitability: "獲利能力",
-        risk: "抗風險能力",
-        ratio: "風險報酬比",
-        winrate: "勝率期望值",
-        liquidity: "交易流動性"
-    },
-    metrics: {
-        backtest: {
-            startDate: "開始日期",
-            endDate: "結束日期",
-            version: "版本",
-            feeRatio: "費用比率",
-            taxRatio: "稅收比率",
-            tradeAt: "交易於（收盤或開盤）",
-            market: "市場",
-            freq: "頻率",
-            updateDate: "更新日期",
-            nextTradingDate: "下一交易日",
-            livePerformanceStart: "實時表現開始日期",
-            stopLoss: "止損百分比",
-            takeProfit: "獲利百分比"
-        },
-        profitability: {
-            annualReturn: "年度回報",
-            alpha: "阿爾法（Alpha）",
-            beta: "貝塔（Beta）",
-            avgNStock: "平均持有股票數",
-            maxNStock: "最大持有股票數"
-        },
-        risk: {
-            maxDrawdown: "最大回檔",
-            avgDrawdown: "平均回檔",
-            avgDrawdownDays: "平均回檔時間（天）",
-            volatility: "波動性",
-            valueAtRisk: "價值風險（VaR）",
-            cvalueAtRisk: "條件價值風險（CVaR）",
-            newHighTimeRank: "再次創新高時間排名",
-            worst10Strategy: "策略前十大",
-            worst10Benchmark: "大盤前十大",
-            days: "days"
-        },
-        ratio: {
-            sharpeRatio: "Sharpe Ratio",
-            sortinoRatio: "Sortino Ratio",
-            calmarRatio: "Calmar Ratio",
-            profitFactor: "Profit Factor",
-            tailRatio: "Tail Ratio",
-            worseThanBenchmark: "小於大盤"
-        },
-        winrate: {
-            winRate: "逐筆交易勝率",
-            m12WinRate: "使用策略12個月勝大盤",
-            expectancy: "期望值",
-            mae: "最大不利偏移",
-            mfe: "最大有利偏移"
-        },
-        liquidity: {
-            smallCapRatio: "小市值比率",
-            capacity: "胃納量",
-            disposalStockRatio: "處置股",
-            warningStockRatio: "警告股",
-            fullDeliveryStockRatio: "全額交付股",
-            buyHigh: "買在漲停",
-            sellLow: "賣在跌停"
-        },
-        stocks: {
-            stockId: "名稱代號",
-            return: "報酬",
-            entry: "進場",
-            exit: "出場",
-            position: "持倉",
-            entryPrice: "進場價格",
-            exitPrice: "出場價格",
-            entrySig: "進場訊號",
-            exitSig: "出場訊號",
-            mae: "不利偏移",
-            gmfe: "有利偏移",
-            bmfe: "虧損前有利偏移",
-            mdd: "最大回檔",
-            pdays: "持倉天数"
-        }
-    },
-    "metrics.ratio.tailRatio": "極端風報比 (Tail Ratio)",
-    "metrics.ratio.sharpeRatio": "夏普比率(Sharpe Ratio)",
-    "notebook.private_draft": "儲存草稿",
-    "notebook.save_draft": "儲存",
-    "notebook.go_public": "準備發布",
-    "notebook.update_public": "更新發布",
-    "notebook.category.python": "Python",
-    "notebook.category.market": "股市",
-    "notebook.category.algorithm": "演算法",
-    "notebook.category.tool": "工具",
-    "notebook.category.metric": "策略指標",
-    "notebook.category.indicator": "財經指標",
-    "notebook.category.ai": "機器學習AI",
-    position: {
-        sl: "停損",
-        tp: "停利",
-        resample: "換股頻率",
-        entryTradePrice: "進場時機",
-        exitTradePrice: "出場時機",
-        scheduled: "預定換股日",
-        dataFreq: "回測頻率",
-        created: "更新時間",
-        entryDate: "進場日期",
-        exitDate: "出場日期",
-        currentPrice: "價格",
-        profit: "盈虧",
-        currentWeight: "持股比例",
-        RSV: "多空力道",
-        resampleValue: {
-            "30M": "每30分鐘",
-            H: "每1小時",
-            "4H": "每4小時",
-            D: "每1天",
-            W: "每1週",
-            "W-Mon": "每週一",
-            "W-Tue": "每週二",
-            "W-Wed": "每週三",
-            "W-Thu": "每週四",
-            "W-Fri": "每週五",
-            M: "每個月",
-            "2M": "每2個月",
-            MRE: "每月收入公佈日",
-            Q: "每1季度",
-            HY: "每半年",
-            Y: "每1年",
-            null: "無"
-        },
-        open: "開盤",
-        close: "收盤",
-        type: {
-            entry: "進場",
-            entry_f: "將進場",
-            exit: "出場",
-            exit_p: "已出場",
-            hold: "持有",
-            sl: "停損",
-            tp: "停利",
-            sl_: "已停損",
-            tp_: "已停利"
-        }
-    },
-    "position.assetName": "標的名稱",
-    "position.action": "動作",
-    "metrics.ratio.yearlySharpeRatio": "每年夏普與大盤比較",
-    "metrics.ratio.betterThanBenchmark": "大於大盤：",
-    "metrics.ratio.year": "年",
-    "metrics.ratio.timeBetterThanBenchmark": "大於大盤的時間：",
-    "metrics.ratio.yearlyTailRatio": "每年極端風報比與大盤比較",
-    "metrics.ratio.volatility": "策略報酬率波動 (Volitility)",
-    "metrics.winrate.returnDistribution": "報酬分布",
-    "metrics.winrate.distributionInfo1": "有 5% 的機率，交易將有",
-    "metrics.winrate.distributionInfo2": " % 以上的虧損",
-    "metrics.winrate.return": "報酬率",
-    "metrics.winrate.maemfe": "交易最大偏移",
-    "metrics.winrate.stoploss": "停損設定：",
-    "metrics.winrate.none": "無",
-    "metrics.winrate.extraProfitLoss": "停損造成的額外盈虧：",
-    "metrics.winrate.stoplossRatio": "停損的交易比例：",
-    "metrics.winrate.maeReturn": "報酬與最大不利偏移",
-    "metrics.winrate.simulatedStopLoss": "模擬停損",
-    "metrics.winrate.simulatedTakeProfit": "模擬停利",
-    "metrics.winrate.takeProfit": "停利設定：",
-    "metrics.winrate.extraProfitLossTakingProfit": "停利造成的額外盈虧：",
-    "metrics.winrate.takeProfitRatio": "停利的交易比例：",
-    "metrics.winrate.mfeReturn": "報酬與最大有利偏移",
-    "metrics.liquidity.portfolioCapacity": "投資組合胃納量",
-    "metrics.liquidity.safeLiquidityTradeRatio": "安全流動性交易的佔比",
-    "metrics.liquidity.averageReturn": "平均報酬",
-    "metrics.liquidity.totalInvestment": "投資總資金",
-    "metrics.liquidity.marketCap": "交易標的的市值",
-    "metrics.liquidity.tradeRatio": "交易的佔比",
-    "metrics.liquidity.tradeRatioMarketCap": "市值門檻",
-    "metrics.liquidity.tradeRatioEntryVolume": "買進成交量門檻",
-    "metrics.liquidity.tradeRatioExitVolume": "交易的佔比",
-    "metrics.liquidity.volumeThreshold": "當天成交量",
-    "metrics.liquidity.exitVolume": "出場當天成交量",
-    "metrics.liquidity.entryVolume": "進場當天成交量",
-    "metrics.liquidity.marketCapThreshold": "市值門檻",
-    "metrics.liquidity.portfolioCapacityDescription": "當資金量達到 {v1} 時，將有 {v2}%的機率，買到流動性低的股票(低成交量、價差大、價格易波動)。",
-    "metrics.liquidity.marketCapDescription": "市值 {v1} 以上的交易佔 {v2}%。",
-    "metrics.liquidity.entryVolumeDescription": "買入當天成交量 {v1} 張以上的交易佔 {v2}%。",
-    "metrics.liquidity.exitVolumeDescription": "賣出當天成交量 {v1} 張以上的交易佔 {v2}%。",
-    "metrics.ratio.rollingTailRatio": "每年極端風報比 (Tail Ratio)",
-    "profitability.yearlyReturn": "年報酬",
-    "profitability.benchmarkYearlyReturn": "大盤年報酬",
-    "profitability.year": "年",
-    "metrics.risk.worstDrawdownPeriod": "跌幅排名",
-    "profitability.all": "全部",
-    "profitability.recent": "近年",
-    "metric.description": {
-        backtest: {
-            startDate: "回測的開始日期",
-            endDate: "回測的結束日期",
-            version: "回測的版本",
-            feeRatio: "交易的手續費比率",
-            taxRatio: "交易的稅率",
-            tradeAt: "交易是在市場收盤還是開盤時執行",
-            market: "進行回測的市場",
-            freq: "回測使用的數據頻率",
-            updateDate: "回測最後更新的日期",
-            nextTradingDate: "回測後的下一個交易日期",
-            livePerformanceStart: "實時性能跟踪開始的日期",
-            stopLoss: "允許的最大損失以停止交易",
-            takeProfit: "退出交易的利潤目標"
-        },
-        profitability: {
-            annualReturn: "策略的年度回報",
-            alpha: "相對於基準的策略的風險調整後表現的衡量",
-            beta: "策略對市場變動的敏感性的衡量",
-            avgNStock: "投資組合中持有的平均股票數",
-            maxNStock: "投資組合中持有的最大股票數"
-        },
-        risk: {
-            maxDrawdown: "從高點到低谷的最大百分比下降",
-            avgDrawdown: "從高點到低谷的平均百分比下降",
-            avgDrawdownDays: "平均回撤天數",
-            volatility: "策略回報的標準差",
-            valueAtRisk: "給定信心區間的指定期間內預期的最大損失",
-            cvalueAtRisk: "發生指定不良事件後的預期損失"
-        },
-        ratio: {
-            sharpeRatio: "風險調整後表現的衡量",
-            sortinoRatio: "只考慮下行波動性的風險調整後表現的衡量",
-            calmarRatio: "年度回報與最大回撤的比率",
-            profitFactor: "總利潤與總損失的比率",
-            tailRatio: "右尾（贏）與左尾（輸）的比率"
-        },
-        winrate: {
-            winRate: "盈利交易的百分比",
-            m12WinRate: "12個月滾動勝率",
-            expectancy: "每筆交易預期贏得（或損失）的平均金額",
-            mae: "最大不利運動，或交易盈利前的最大損失",
-            mfe: "最大有利運動，或交易變成損失前的最大利潤"
-        },
-        liquidity: {
-            capacity: "不影響市場價格可以部署的最大資本金額",
-            disposalStockRatio: "可以輕易出售的股票比率",
-            warningStockRatio: "可能存在流動性問題的股票比率",
-            fullDeliveryStockRatio: "需要全額交付的股票比率",
-            buyHigh: "購買高價股票的傾向",
-            sellLow: "賣出低價股票的傾向"
-        }
-    },
-    "metrics.condition": "達成條件",
-    "strategy.code": "程式碼",
-    "strategy.return": "報酬",
-    "strategy.betterThanBenchmark": "贏大盤",
-    "strategy.worseThanBenchmark": "輸大盤",
-    "strategy.annualReturn": "年度報酬",
-    "strategy.maxDrawdown": "最大回檔",
-    "strategy.sharpeRatio": "夏普比率",
-    "strategy.period": {
-        W: "週",
-        M: "月",
-        Q: "季",
-        HY: "半年",
-        Y: "年",
-        All: "全部"
-    },
-    "strategy.tabs": {
-        position: "選股",
-        analyze: "分析",
-        course: "教學"
-    }
-};
-
-function tl(t3, e2 = "") {
-    let i2 = {};
-    for (let s2 in t3)
-        "object" == typeof t3[s2] && null !== t3[s2] ? Object.assign(i2, tl(t3[s2], e2 + s2 + ".")) : i2[e2 + s2] = t3[s2];
-    return i2;
-}
-const el = tl({
-        welcome: "Welcome to inlang",
-        title: "Data Driven, Scientific Investment",
-        subtitle: "Technology-driven investment revolution. Jump on the tech wave now and create passive income!",
-        actionButton: "start revolution",
-        profitability: {
-            historicalReturn: "Historical Performance",
-            stockList: "Stock Returns",
-            monthlyReturn: "Monthly Return",
-            monthlyWinRatio: "Monthly Win Rate",
-            avgMonthlyReturn: "Average Monthly Return"
-        },
-        "profitability.YearlyCompareWithBenchmark": "Annual Return Relative to the Benchmark",
-        "profitability.yearlyWinRate": "Outperformed Benchmark:",
-        strategy: "Strategy",
-        benchmark: "Benchmark",
-        "profitability.exceedReturn": "Excess Return",
-        average: "Average",
-        "risk.drawdownPercentage": "Historical Drawdown Percentage",
-        "risk.drawdowPeriods": "Loss Historical Performance",
-        tabs: {
-            profitability: "Profitability",
-            risk: "Risk Resistance",
-            ratio: "Risk-Reward Ratio",
-            winrate: "Trade Analaysis",
-            liquidity: "Stock Liquidity"
-        },
-        metrics: {
-            backtest: {
-                startDate: "Start Date",
-                endDate: "End Date",
-                version: "Version",
-                feeRatio: "Fee Ratio",
-                taxRatio: "Tax Ratio",
-                tradeAt: "Trade At (Close or Open)",
-                market: "Market",
-                freq: "Frequency",
-                updateDate: "Update Date",
-                nextTradingDate: "Next Trading Date",
-                livePerformanceStart: "Live Performance Start Date",
-                stopLoss: "Stop Loss Percentage",
-                takeProfit: "Take Profit Percentage"
-            },
-            profitability: {
-                annualReturn: "Annual Return",
-                alpha: "Alpha",
-                beta: "Beta",
-                avgNStock: "Average Stock Count",
-                maxNStock: "Max stocks Count"
-            },
-            risk: {
-                maxDrawdown: "Maximum Drawdown",
-                avgDrawdown: "Average Drawdown",
-                avgDrawdownDays: "Average Days",
-                volatility: "Volatility",
-                valueAtRisk: "Value At Risk (VaR)",
-                cvalueAtRisk: "CVaR",
-                days: "days"
-            },
-            ratio: {
-                sharpeRatio: "Sharpe Ratio",
-                sortinoRatio: "Sortino Ratio",
-                calmarRatio: "Calmar Ratio",
-                profitFactor: "Profit Factor",
-                tailRatio: "Tail Ratio",
-                worseThanBenchmark: "Underperform Benchmark:"
-            },
-            winrate: {
-                winRate: "Win Rate",
-                m12WinRate: "12-Month Win Rate",
-                expectancy: "Expectancy",
-                mae: "MAE",
-                mfe: "MFE"
-            },
-            liquidity: {
-                smallCapRatio: "Small Cap Ratio",
-                capacity: "Capacity",
-                disposalStockRatio: "Disposal Stocks",
-                warningStockRatio: "Warning Stocks",
-                fullDeliveryStockRatio: "Full Delivery Stock",
-                buyHigh: "Buy High",
-                sellLow: "sell Low"
-            },
-            stocks: {
-                stockId: "Stock ID",
-                return: "Return",
-                entry: "Entry",
-                exit: "Exit",
-                position: "Position",
-                entryPrice: "Entry Price",
-                exitPrice: "Exit Price",
-                entrySig: "Entry Signal",
-                exitSig: "Exit Signal",
-                mae: "MAE",
-                gmfe: "MFE",
-                bmfe: "BMFE",
-                mdd: "Maximum Drawdown",
-                pdays: "Holding Days"
-            }
-        },
-        "metrics.risk.worst10Benchmark": "Worst benchmark periods",
-        "metrics.risk.worst10Strategy": "Worst strategy periods",
-        "metrics.risk.newHighTimeRank": "Longest Drawdown Periods",
-        "metrics.ratio.sharpeRatio": "Rolling Sharpe Ratio",
-        position: {
-            sl: "Stop Loss",
-            tp: "Take Profit",
-            resample: "Resample Frequency",
-            entryTradePrice: "Entry Price",
-            exitTradePrice: "Exit Price",
-            scheduled: "Scheduled Resample Date",
-            dataFreq: "Backtest Frequency",
-            created: "Updated Time",
-            entryDate: "Entry Date",
-            exitDate: "Exit Date",
-            currentPrice: "Price",
-            profit: "Profit/Loss",
-            currentWeight: "Holding Percentage",
-            RSV: "Bullish/Bearish Power",
-            resampleValue: {
-                "30M": "Every 30 Minutes",
-                H: "Every 1 Hour",
-                "4H": "Every 4 Hours",
-                D: "Every Day",
-                W: "Every Week",
-                "W-Mon": "Every Monday",
-                "W-Tue": "Every Tuesday",
-                "W-Wed": "Every Wednesday",
-                "W-Thu": "Every Thursday",
-                "W-Fri": "Every Friday",
-                M: "Every Month",
-                "2M": "Every 2 Months",
-                MRE: "Monthly Earnings Release Date",
-                Q: "Every Quarter",
-                HY: "Every Half Year",
-                Y: "Every Year",
-                null: "None"
-            },
-            open: "Open",
-            close: "Close",
-            type: {
-                entry: "Entry",
-                entry_f: "Will Enter",
-                exit: "Exit",
-                exit_p: "Exited",
-                hold: "Hold",
-                sl: "Stop Loss",
-                tp: "Take Profit",
-                sl_: "Stopped Out",
-                tp_: "Took Profit"
-            }
-        },
-        "position.assetName": "Asset Name",
-        "position.action": "Action",
-        "metrics.ratio.yearlySharpeRatio": "Annual Sharpe Ratio Compared to Benchmark",
-        "metrics.ratio.betterThanBenchmark": "Outperformed Benchmark:",
-        "metrics.ratio.year": "Year",
-        "metrics.ratio.timeBetterThanBenchmark": "Outperformed Benchmark:",
-        "metrics.ratio.yearlyTailRatio": "Annual Tail Risk Ratio Compared to Benchmark",
-        "metrics.ratio.volatility": "Strategy Return Volatility",
-        "metrics.winrate.returnDistribution": "Return Distribution",
-        "metrics.winrate.distributionInfo1": "There's a 5% chance that the trade will have",
-        "metrics.winrate.distributionInfo2": " % or more loss",
-        "metrics.winrate.return": "Return Rate",
-        "metrics.winrate.maemfe": "Trade Maximum Excursion",
-        "metrics.winrate.stoploss": "Stop Loss Setting:",
-        "metrics.winrate.none": "None",
-        "metrics.winrate.extraProfitLoss": "Extra Profit/Loss Due to Stop Loss:",
-        "metrics.winrate.stoplossRatio": "Trade Ratio with Stop Loss:",
-        "metrics.winrate.maeReturn": "Return vs. Maximum Adverse Excursion",
-        "metrics.winrate.simulatedStopLoss": "Simulated Stop Loss",
-        "metrics.winrate.simulatedTakeProfit": "Simulated Take Profit",
-        "metrics.winrate.takeProfit": "Take Profit Setting:",
-        "metrics.winrate.extraProfitLossTakingProfit": "Extra Profit/Loss Due to Take Profit:",
-        "metrics.winrate.takeProfitRatio": "Trade Ratio with Take Profit:",
-        "metrics.winrate.mfeReturn": "Return vs. Maximum Favorable Excursion",
-        "metrics.liquidity.portfolioCapacity": "Portfolio Capacity",
-        "metrics.liquidity.safeLiquidityTradeRatio": "Safe Liquidity Trade Ratio",
-        "metrics.liquidity.averageReturn": "Average Return",
-        "metrics.liquidity.totalInvestment": "Total Investment",
-        "metrics.liquidity.marketCap": "Trading Asset Market Cap",
-        "metrics.liquidity.tradeRatio": "Trade Ratio",
-        "metrics.liquidity.tradeRatioMarketCap": "Market Cap Threshold",
-        "metrics.liquidity.tradeRatioEntryVolume": "Entry Volume Threshold",
-        "metrics.liquidity.tradeRatioExitVolume": "Exit Volume Threshold",
-        "metrics.liquidity.volumeThreshold": "Entry Day Volume",
-        "metrics.liquidity.exitVolume": "Exit Day Volume",
-        "metrics.liquidity.entryVolume": "Entry Day Volume",
-        "metrics.liquidity.marketCapThreshold": "Market Cap Threshold",
-        "metrics.liquidity.portfolioCapacityDescription": "When the fund amount reaches {v1}, there's a {v2}% chance of buying stocks with low liquidity (Low daily volume, wide spread, price volatility).",
-        "metrics.liquidity.marketCapDescription": "Trades with a market cap above {v1} account for {v2}%.",
-        "metrics.liquidity.entryVolumeDescription": "Trades with an entry volume above {v1} shares account for {v2}%.",
-        "metrics.liquidity.exitVolumeDescription": "Trades with an exit volume above {v1} shares account for {v2}%.",
-        "metrics.ratio.rollingTailRatio": "Rolling Tail Ratio",
-        "profitability.yearlyReturn": "Yearly Return",
-        "profitability.benchmarkYearlyReturn": "Benchmark Yearly Return",
-        "profitability.year": "years",
-        "metrics.risk.worstDrawdownPeriod": "Worst Drawdown",
-        "profitability.all": "All",
-        "profitability.recent": "Recent",
-        "metric.description": {
-            backtest: {
-                startDate: "The starting date of the backtest",
-                endDate: "The ending date of the backtest",
-                version: "Version of the backtest",
-                feeRatio: "Ratio of fees applied to trades",
-                taxRatio: "Ratio of taxes applied to trades",
-                tradeAt: "Whether trades are executed at the close or open of the market",
-                market: "The market in which the backtest is conducted",
-                freq: "Frequency of data used in the backtest",
-                updateDate: "The date the backtest was last updated",
-                nextTradingDate: "The next trading date after the backtest",
-                livePerformanceStart: "The date when live performance tracking starts",
-                stopLoss: "The maximum loss allowed before stopping a trade",
-                takeProfit: "The profit target to exit a trade"
-            },
-            profitability: {
-                annualReturn: "The yearly return of the strategy",
-                alpha: "Measure of the strategy's performance on a risk-adjusted basis relative to a benchmark",
-                beta: "Measure of the strategy's sensitivity to market movements",
-                avgNStock: "Average number of stocks held in the portfolio",
-                maxNStock: "Maximum number of stocks held in the portfolio"
-            },
-            risk: {
-                maxDrawdown: "The maximum percentage decline from a peak to a trough",
-                avgDrawdown: "The average percentage decline from a peak to a trough",
-                avgDrawdownDays: "Average number of days for a drawdown",
-                volatility: "Standard deviation of the strategy's returns",
-                valueAtRisk: "The maximum loss expected over a specified period for a given confidence interval",
-                cvalueAtRisk: "Conditional Value at Risk, or the expected loss given that a specified bad event has occurred"
-            },
-            ratio: {
-                sharpeRatio: "Measure of risk-adjusted performance",
-                sortinoRatio: "Measure of risk-adjusted performance that only considers downside volatility",
-                calmarRatio: "Ratio of annual return to maximum drawdown",
-                profitFactor: "Ratio of gross profit to gross loss",
-                tailRatio: "Ratio of the right tail (wins) to the left tail (losses)"
-            },
-            winrate: {
-                winRate: "Percentage of trades that were profitable",
-                m12WinRate: "12-month rolling win rate",
-                expectancy: "Average amount that can be expected to be won (or lost) per trade",
-                mae: "Maximum Adverse Excursion, or the maximum loss before a trade becomes profitable",
-                mfe: "Maximum Favorable Excursion, or the maximum profit before a trade turns into a loss"
-            },
-            liquidity: {
-                capacity: "The maximum amount of capital that can be deployed without affecting market prices",
-                disposalStockRatio: "Ratio of stocks that can be easily sold",
-                warningStockRatio: "Ratio of stocks that may present liquidity issues",
-                fullDeliveryStockRatio: "Ratio of stocks that require full delivery",
-                buyHigh: "Measure of the tendency to buy stocks at high prices",
-                sellLow: "Measure of the tendency to sell stocks at low prices"
-            }
-        },
-        "metrics.condition": "Criteria",
-        "strategy.code": "Code",
-        "strategy.return": "Return",
-        "strategy.betterThanBenchmark": "Outperformed Benchmark",
-        "strategy.worseThanBenchmark": "Underperform Benchmark",
-        "strategy.annualReturn": "Annual Return",
-        "strategy.maxDrawdown": "Maximum Drawdown",
-        "strategy.sharpeRatio": "Sharpe Ratio",
-        "strategy.period": {
-            W: "W",
-            M: "M",
-            Q: "Q",
-            HY: "HY",
-            Y: "Y",
-            All: "All"
-        },
-        "strategy.tabs": {
-            position: "Position",
-            analyze: "Analysis",
-            course: "Course"
-        }
-    }),
-    il = tl(Za),
-    sl = (t3) => el[t3],
-    nl = (t3) => il[t3];
-
-function rl(e2) {
-    let i2, s2, n2, r2, o2, a2, l2, h2, c2, u2, d2, f2, p2, m2, g2, y2, v2, b2, w2, x2, k2, T2, C2, R2, z2, B2, j2, q2, G2, Y2, it2, st2, rt2, ht2, ct2, ut2, dt2, ft2, pt2, yt2, bt2, _t2, xt2, kt2, St2, It2, Mt2, At2, Lt2, Ot2, Ht2, Qt2, Jt2, te2, ee2, ie2, se2, ne2, re2, oe2, ae2, le2, he2, ce2, ue2, de2, fe2, pe2, me2, ge2, ye2, ve2, be2, _e2, we2, xe2, ke2, Te2, Se2, Ee2, Ce2, Ie2, Me2, Pe2, Re2 = e2[1]("metrics.liquidity.portfolioCapacity") + "",
-        Ae2 = e2[1]("metrics.liquidity.portfolioCapacityDescription").replace("{v1}", e2[2](Object.keys(e2[3].mean)[1], "zh")).replace("{v2}", (100 * (1 - Object.values(e2[3].portion)[1])).toFixed(1)) + "",
-        De2 = e2[1]("metrics.liquidity.safeLiquidityTradeRatio") + "",
-        Le2 = e2[1]("metrics.liquidity.averageReturn") + "",
-        Oe2 = e2[1]("metrics.liquidity.totalInvestment") + "",
-        Fe2 = e2[1]("metrics.liquidity.marketCap") + "",
-        Ne2 = e2[1]("metrics.liquidity.marketCapDescription").replace("{v1}", e2[2](Object.keys(e2[4].mean)[2], "zh")).replace("{v2}", (100 * Object.values(e2[4].portion)[2]).toFixed(1)) + "",
-        $e2 = e2[1]("metrics.liquidity.tradeRatio") + "",
-        Ve2 = e2[1]("metrics.liquidity.averageReturn") + "",
-        ze2 = e2[1]("metrics.liquidity.marketCapThreshold") + "",
-        Be2 = e2[1]("metrics.liquidity.entryVolume") + "",
-        Ue2 = e2[1]("metrics.liquidity.entryVolumeDescription").replace("{v1}", e2[2](Object.keys(e2[5].mean)[2], "zh")).replace("{v2}", (100 * Object.values(e2[5].portion)[2]).toFixed(1)) + "",
-        je2 = e2[1]("metrics.liquidity.tradeRatio") + "",
-        He2 = e2[1]("metrics.liquidity.averageReturn") + "",
-        We2 = e2[1]("metrics.liquidity.volumeThreshold") + "",
-        qe2 = e2[1]("metrics.liquidity.exitVolume") + "",
-        Ke2 = e2[1]("metrics.liquidity.exitVolumeDescription").replace("{v1}", e2[2](Object.keys(e2[6].mean)[2], "zh")).replace("{v2}", (100 * Object.values(e2[6].portion)[2]).toFixed(1)) + "",
-        Ge2 = e2[1]("metrics.liquidity.tradeRatioExitVolume") + "",
-        Ye2 = e2[1]("metrics.liquidity.averageReturn") + "",
-        Qe2 = e2[1]("metrics.liquidity.volumeThreshold") + "";
-    return {
-        c() {
-            i2 = P("div"), s2 = P("div"), n2 = P("h3"), r2 = D(Re2), o2 = $(), a2 = P("p"), l2 = D(Ae2), h2 = $(), c2 = P("div"), u2 = P("p"), d2 = D(De2), f2 = $(), p2 = P("div"), m2 = $(), g2 = P("p"), y2 = D(Le2), v2 = $(), b2 = P("canvas"), w2 = $(), x2 = P("p"), k2 = D(Oe2), T2 = $(), C2 = P("div"), R2 = P("h3"), z2 = D(Fe2), B2 = $(), j2 = P("p"), q2 = D(Ne2), G2 = $(), Y2 = P("div"), it2 = P("p"), st2 = D($e2), rt2 = $(), ht2 = P("div"), ct2 = $(), ut2 = P("p"), dt2 = D(Ve2), ft2 = $(), pt2 = P("canvas"), yt2 = $(), bt2 = P("p"), _t2 = D(ze2), xt2 = $(), kt2 = P("div"), St2 = P("h3"), It2 = D(Be2), Mt2 = $(), At2 = P("p"), Lt2 = D(Ue2), Ot2 = $(), Ht2 = P("div"), Qt2 = P("p"), Jt2 = D(je2), te2 = $(), ee2 = P("div"), ie2 = $(), se2 = P("p"), ne2 = D(He2), re2 = $(), oe2 = P("canvas"), ae2 = $(), le2 = P("p"), he2 = D(We2), ce2 = $(), ue2 = P("div"), de2 = P("h3"), fe2 = D(qe2), pe2 = $(), me2 = P("p"), ge2 = D(Ke2), ye2 = $(), ve2 = P("div"), be2 = P("p"), _e2 = D(Ge2), we2 = $(), xe2 = P("div"), ke2 = $(), Te2 = P("p"), Se2 = D(Ye2), Ee2 = $(), Ce2 = P("canvas"), Ie2 = $(), Me2 = P("p"), Pe2 = D(Qe2), U(n2, "class", "font-bold text-3xl text-center text-base-content-200"), U(a2, "class", "mt-1 text-center"), U(u2, "class", "text-primary"), U(p2, "class", "flex-grow"), U(g2, "class", "text-secondary"), U(c2, "class", "flex mt-6"), U(b2, "width", "400"), U(b2, "height", "200"), U(x2, "class", "text-center mt-4"), U(s2, "class", "col-span-2 md:col-span-1 p-2 md:p-8 pt-8 md:border rounded-xl"), U(R2, "class", "font-bold text-3xl text-center text-base-content-200"), U(j2, "class", "mt-1 text-center"), U(it2, "class", "text-primary"), U(ht2, "class", "flex-grow"), U(ut2, "class", "text-secondary"), U(Y2, "class", "flex mt-6"), U(pt2, "width", "400"), U(pt2, "height", "200"), U(bt2, "class", "text-center mt-4"), U(C2, "class", "col-span-2 md:col-span-1 p-2 md:p-8 pt-8 md:border rounded-xl"), U(St2, "class", "font-bold text-3xl text-cneter text-center"), U(At2, "class", "mt-1 text-center text-base-content-200"), U(Qt2, "class", "text-primary"), U(ee2, "class", "flex-grow"), U(se2, "class", "text-secondary"), U(Ht2, "class", "flex mt-6"), U(oe2, "width", "400"), U(oe2, "height", "200"), U(le2, "class", "text-center mt-4"), U(kt2, "class", "col-span-2 md:col-span-1 p-2 md:p-8 pt-8 md:border rounded-xl"), U(de2, "class", "font-bold text-3xl text-center text-base-content-200"), U(me2, "class", "mt-1 text-center"), U(be2, "class", "text-primary"), U(xe2, "class", "flex-grow"), U(Te2, "class", "text-secondary"), U(ve2, "class", "flex mt-6"), U(Ce2, "width", "400"), U(Ce2, "height", "200"), U(Me2, "class", "text-center mt-4"), U(ue2, "class", "col-span-2 md:col-span-1 p-2 md:p-8 pt-8 md:border rounded-xl"), U(i2, "class", "grid grid-cols-2 text-base-content-200 gap-4");
-        },
-        m(t3, E2) {
-            S(t3, i2, E2), _(i2, s2), _(s2, n2), _(n2, r2), _(s2, o2), _(s2, a2), _(a2, l2), _(s2, h2), _(s2, c2), _(c2, u2), _(u2, d2), _(c2, f2), _(c2, p2), _(c2, m2), _(c2, g2), _(g2, y2), _(s2, v2), _(s2, b2), e2[12](b2), _(s2, w2), _(s2, x2), _(x2, k2), _(i2, T2), _(i2, C2), _(C2, R2), _(R2, z2), _(C2, B2), _(C2, j2), _(j2, q2), _(C2, G2), _(C2, Y2), _(Y2, it2), _(it2, st2), _(Y2, rt2), _(Y2, ht2), _(Y2, ct2), _(Y2, ut2), _(ut2, dt2), _(C2, ft2), _(C2, pt2), e2[13](pt2), _(C2, yt2), _(C2, bt2), _(bt2, _t2), _(i2, xt2), _(i2, kt2), _(kt2, St2), _(St2, It2), _(kt2, Mt2), _(kt2, At2), _(At2, Lt2), _(kt2, Ot2), _(kt2, Ht2), _(Ht2, Qt2), _(Qt2, Jt2), _(Ht2, te2), _(Ht2, ee2), _(Ht2, ie2), _(Ht2, se2), _(se2, ne2), _(kt2, re2), _(kt2, oe2), e2[14](oe2), _(kt2, ae2), _(kt2, le2), _(le2, he2), _(i2, ce2), _(i2, ue2), _(ue2, de2), _(de2, fe2), _(ue2, pe2), _(ue2, me2), _(me2, ge2), _(ue2, ye2), _(ue2, ve2), _(ve2, be2), _(be2, _e2), _(ve2, we2), _(ve2, xe2), _(ve2, ke2), _(ve2, Te2), _(Te2, Se2), _(ue2, Ee2), _(ue2, Ce2), e2[15](Ce2), _(ue2, Ie2), _(ue2, Me2), _(Me2, Pe2);
-        },
-        p(t3, [e3]) {
-            2 & e3 && Re2 !== (Re2 = t3[1]("metrics.liquidity.portfolioCapacity") + "") && H(r2, Re2), 2 & e3 && Ae2 !== (Ae2 = t3[1]("metrics.liquidity.portfolioCapacityDescription").replace("{v1}", t3[2](Object.keys(t3[3].mean)[1], "zh")).replace("{v2}", (100 * (1 - Object.values(t3[3].portion)[1])).toFixed(1)) + "") && H(l2, Ae2), 2 & e3 && De2 !== (De2 = t3[1]("metrics.liquidity.safeLiquidityTradeRatio") + "") && H(d2, De2), 2 & e3 && Le2 !== (Le2 = t3[1]("metrics.liquidity.averageReturn") + "") && H(y2, Le2), 2 & e3 && Oe2 !== (Oe2 = t3[1]("metrics.liquidity.totalInvestment") + "") && H(k2, Oe2), 2 & e3 && Fe2 !== (Fe2 = t3[1]("metrics.liquidity.marketCap") + "") && H(z2, Fe2), 2 & e3 && Ne2 !== (Ne2 = t3[1]("metrics.liquidity.marketCapDescription").replace("{v1}", t3[2](Object.keys(t3[4].mean)[2], "zh")).replace("{v2}", (100 * Object.values(t3[4].portion)[2]).toFixed(1)) + "") && H(q2, Ne2), 2 & e3 && $e2 !== ($e2 = t3[1]("metrics.liquidity.tradeRatio") + "") && H(st2, $e2), 2 & e3 && Ve2 !== (Ve2 = t3[1]("metrics.liquidity.averageReturn") + "") && H(dt2, Ve2), 2 & e3 && ze2 !== (ze2 = t3[1]("metrics.liquidity.marketCapThreshold") + "") && H(_t2, ze2), 2 & e3 && Be2 !== (Be2 = t3[1]("metrics.liquidity.entryVolume") + "") && H(It2, Be2), 2 & e3 && Ue2 !== (Ue2 = t3[1]("metrics.liquidity.entryVolumeDescription").replace("{v1}", t3[2](Object.keys(t3[5].mean)[2], "zh")).replace("{v2}", (100 * Object.values(t3[5].portion)[2]).toFixed(1)) + "") && H(Lt2, Ue2), 2 & e3 && je2 !== (je2 = t3[1]("metrics.liquidity.tradeRatio") + "") && H(Jt2, je2), 2 & e3 && He2 !== (He2 = t3[1]("metrics.liquidity.averageReturn") + "") && H(ne2, He2), 2 & e3 && We2 !== (We2 = t3[1]("metrics.liquidity.volumeThreshold") + "") && H(he2, We2), 2 & e3 && qe2 !== (qe2 = t3[1]("metrics.liquidity.exitVolume") + "") && H(fe2, qe2), 2 & e3 && Ke2 !== (Ke2 = t3[1]("metrics.liquidity.exitVolumeDescription").replace("{v1}", t3[2](Object.keys(t3[6].mean)[2], "zh")).replace("{v2}", (100 * Object.values(t3[6].portion)[2]).toFixed(1)) + "") && H(ge2, Ke2), 2 & e3 && Ge2 !== (Ge2 = t3[1]("metrics.liquidity.tradeRatioExitVolume") + "") && H(_e2, Ge2), 2 & e3 && Ye2 !== (Ye2 = t3[1]("metrics.liquidity.averageReturn") + "") && H(Se2, Ye2), 2 & e3 && Qe2 !== (Qe2 = t3[1]("metrics.liquidity.volumeThreshold") + "") && H(Pe2, Qe2);
-        },
-        i: t,
-        o: t,
-        d(t3) {
-            t3 && E(i2), e2[12](null), e2[13](null), e2[14](null), e2[15](null);
-        }
-    };
-}
-
-function ol(t3, e2) {
-    const i2 = t3.filter((t4) => null !== t4);
-    if (0 === i2.length)
-        return 0;
-    const s2 = i2.sort((t4, e3) => t4 - e3),
-        n2 = (s2.length - 1) * e2,
-        r2 = Math.floor(n2),
-        o2 = n2 - r2;
-    return void 0 !== s2[r2 + 1] ? s2[r2] + o2 * (s2[r2 + 1] - s2[r2]) : s2[r2];
-}
-
-function al(t3, e2, i2 = 5) {
-    let s2 = {},
-        n2 = {};
-    t3 = t3.filter((t4) => null !== t4[e2] && void 0 !== t4[e2]);
-    for (let r2 of function(t4, e3 = 5) {
-            let i3 = [],
-                s3 = [5, 10];
-            for (; i3.length < t4;) {
-                for (let n3 of s3)
-                    if (i3.push(n3 * Math.pow(10, e3)), i3.length === t4)
-                        break;
-                e3 += 1;
-            }
-            return i3;
-        }(100, i2)) {
-        let i3 = t3.map((t4) => t4[e2]);
-        i3.sort((t4, e3) => t4 - e3);
-        let o2 = i3.findIndex((t4) => t4 > r2) / i3.length,
-            a2 = t3.filter((t4) => t4[e2] > r2).map((t4) => t4.return);
-        if (0 === o2 && (n2 = {}, s2 = {}), n2[r2] = ol(a2, 0.5), s2[r2] = 1 - o2, s2[r2] < 0.2)
-            break;
-    }
-    return {
-        portion: s2,
-        mean: n2
-    };
-}
-
-function ll(t3, e2, i2) {
-    let s2, {
-        lang: n2 = "en"
-    } = e2;
-    Chart.register(LinearScale, BarController, CategoryScale, BarElement, LineController, LineElement, PointElement, Ga), Chart.defaults.font.color = "red";
-    let {
-        browser: r2
-    } = e2, {
-        report: o2
-    } = e2, {
-        theme: a2 = "light"
-    } = e2;
-
-    function l2(t4, e3 = "zh") {
-        return "en" === n2 ? Math.abs(t4) >= 1e9 ? t4 / 1e9 + "B" : Math.abs(t4) >= 1e6 ? t4 / 1e6 + "M" : Math.abs(t4) >= 1e3 ? t4 / 1e3 + "K" : t4 : "zh" === e3 ? Math.abs(t4) >= 1e8 ? t4 / 1e8 + "億" : Math.abs(t4) >= 1e7 ? t4 / 1e7 + "千萬" : Math.abs(t4) >= 1e6 ? t4 / 1e6 + "百萬" : Math.abs(t4) >= 1e4 ? t4 / 1e4 + "萬" : t4 : void 0;
-    }
-
-    function h2(t4, e3, i3) {
-        return new Chart(e3, {
-            type: "bar",
-            data: {
-                labels: Object.keys(t4.portion),
-                datasets: [{
-                    label: "Data",
-                    data: Object.values(t4.portion),
-                    backgroundColor: "light" === a2 ? "#725bf5" : "#7a64f5",
-                    yAxisID: "y-axis-1",
-                    barPercentage: 0.2,
-                    order: 1
-                }, {
-                    label: "Line Data",
-                    data: Object.values(t4.mean),
-                    type: "line",
-                    fill: false,
-                    borderColor: "#f16365",
-                    borderWidth: 5,
-                    pointBackgroundColor: "#f16365",
-                    pointBorderColor: "#f16365",
-                    yAxisID: "y-axis-2",
-                    order: 0
-                }]
-            },
-            options: {
-                responsive: true,
-                maintainAspectRatio: true,
-                scales: {
-                    x: {
-                        type: "category",
-                        ticks: {
-                            color: "light" === a2 ? "#000000aa" : "#FFFFFFaa",
-                            callback: (e4) => l2(Object.keys(t4.portion)[e4], "zh") + i3 + "以上"
-                        },
-                        grid: {
-                            color: "#77777755",
-                            tickBorderDash: [2, 2]
-                        }
-                    },
-                    "y-axis-1": {
-                        display: true,
-                        position: "left",
-                        beginAtZero: true,
-                        ticks: {
-                            callback: (t5) => (100 * t5).toFixed(0) + "%",
-                            color: "light" === a2 ? "#000000aa" : "#FFFFFFaa"
-                        },
-                        grid: {
-                            color: "#77777755",
-                            tickBorderDash: [2, 2]
-                        }
-                    },
-                    "y-axis-2": {
-                        display: true,
-                        position: "right",
-                        ticks: {
-                            callback: (t5) => (100 * t5).toFixed(1) + "%",
-                            color: "light" === a2 ? "#000000aa" : "#FFFFFFaa"
-                        },
-                        grid: {
-                            drawOnChartArea: false,
-                            color: "#77777755",
-                            tickBorderDash: [2, 2]
-                        }
-                    }
-                }
-            }
-        });
-    }
-    o2.trades.forEach((t4) => {
-        t4.acceptMoneyFlow = (0.05 * t4["turnover@entry_date"] / t4.position + 0.05 * t4["turnover@entry_date"] / t4.position) / 2, "zh-tw" === n2 ? (t4["volume_@entry_date"] = t4["volume@entry_date"] / 1e3, t4["volume_@exit_date"] = t4["volume@exit_date"] / 1e3) : (t4["volume_@entry_date"] = t4["volume@entry_date"], t4["volume_@exit_date"] = t4["volume@exit_date"]);
-    });
-    const c2 = al(o2.trades, "acceptMoneyFlow", 5),
-        u2 = al(o2.trades, "market_value@entry_date", 5),
-        d2 = al(o2.trades, "volume_@entry_date", 1),
-        f2 = al(o2.trades, "volume_@exit_date", 1);
-    let p2 = {},
-        m2 = {};
-
-    function g2() {
-        p2.moneyFlow && (p2.moneyFlow.destroy(), delete p2.moneyFlow);
-        const t4 = m2.moneyFlow.getContext("2d");
-        p2.moneyFlow = h2(c2, t4, "元"), p2.marketValue && (p2.marketValue.destroy(), delete p2.marketValue);
-        const e3 = m2.marketValue.getContext("2d");
-        p2.marketValue = h2(u2, e3, "元"), p2.entryVolume && p2.entryVolume.destroy();
-        const i3 = m2.entryVolume.getContext("2d");
-        p2.entryVolume = h2(d2, i3, "張"), p2.exitVolume && p2.exitVolume.destroy();
-        const s3 = m2.exitVolume.getContext("2d");
-        p2.exitVolume = h2(f2, s3, "張");
-    }
-    let y2 = false;
-    return pt(() => {
-        r2 && (g2(), i2(11, y2 = true));
-    }), t3.$$set = (t4) => {
-        "lang" in t4 && i2(7, n2 = t4.lang), "browser" in t4 && i2(8, r2 = t4.browser), "report" in t4 && i2(9, o2 = t4.report), "theme" in t4 && i2(10, a2 = t4.theme);
-    }, t3.$$.update = () => {
-        128 & t3.$$.dirty && i2(1, s2 = (t4) => "en" === n2 ? sl(t4) : nl(t4)), 3072 & t3.$$.dirty && a2 && y2 && g2();
-    }, [m2, s2, l2, c2, u2, d2, f2, n2, r2, o2, a2, y2, function(t4) {
-        xt[t4 ? "unshift" : "push"](() => {
-            m2.moneyFlow = t4, i2(0, m2);
-        });
-    }, function(t4) {
-        xt[t4 ? "unshift" : "push"](() => {
-            m2.marketValue = t4, i2(0, m2);
-        });
-    }, function(t4) {
-        xt[t4 ? "unshift" : "push"](() => {
-            m2.entryVolume = t4, i2(0, m2);
-        });
-    }, function(t4) {
-        xt[t4 ? "unshift" : "push"](() => {
-            m2.exitVolume = t4, i2(0, m2);
-        });
-    }];
-}
-class Liquidity extends SvelteComponent {
-    constructor(t3) {
-        super(), ve(this, t3, ll, rl, o, {
-            lang: 7,
-            browser: 8,
-            report: 9,
-            theme: 10
-        });
-    }
-    get lang() {
-        return this.$$.ctx[7];
-    }
-    set lang(t3) {
-        this.$$set({
-            lang: t3
-        }), te();
-    }
-    get browser() {
-        return this.$$.ctx[8];
-    }
-    set browser(t3) {
-        this.$$set({
-            browser: t3
-        }), te();
-    }
-    get report() {
-        return this.$$.ctx[9];
-    }
-    set report(t3) {
-        this.$$set({
-            report: t3
-        }), te();
-    }
-    get theme() {
-        return this.$$.ctx[10];
-    }
-    set theme(t3) {
-        this.$$set({
-            theme: t3
-        }), te();
-    }
-}
-
-function hl(t3) {
-    var e2 = t3.width,
-        i2 = t3.height;
-    if (e2 < 0)
-        throw new Error("Negative width is not allowed for Size");
-    if (i2 < 0)
-        throw new Error("Negative height is not allowed for Size");
-    return {
-        width: e2,
-        height: i2
-    };
-}
-
-function cl(t3, e2) {
-    return t3.width === e2.width && t3.height === e2.height;
-}
-we(Liquidity, {
-    lang: {},
-    browser: {},
-    report: {},
-    theme: {}
-}, [], [], true);
-var ul = function() {
-    function t3(t4) {
-        var e2 = this;
-        this._resolutionListener = function() {
-            return e2._onResolutionChanged();
-        }, this._resolutionMediaQueryList = null, this._observers = [], this._window = t4, this._installResolutionListener();
-    }
-    return t3.prototype.dispose = function() {
-        this._uninstallResolutionListener(), this._window = null;
-    }, Object.defineProperty(t3.prototype, "value", {
-        get: function() {
-            return this._window.devicePixelRatio;
-        },
-        enumerable: false,
-        configurable: true
-    }), t3.prototype.subscribe = function(t4) {
-        var e2 = this,
-            i2 = {
-                next: t4
-            };
-        return this._observers.push(i2), {
-            unsubscribe: function() {
-                e2._observers = e2._observers.filter(function(t5) {
-                    return t5 !== i2;
-                });
-            }
-        };
-    }, t3.prototype._installResolutionListener = function() {
-        if (null !== this._resolutionMediaQueryList)
-            throw new Error("Resolution listener is already installed");
-        var t4 = this._window.devicePixelRatio;
-        this._resolutionMediaQueryList = this._window.matchMedia("all and (resolution: ".concat(t4, "dppx)")), this._resolutionMediaQueryList.addListener(this._resolutionListener);
-    }, t3.prototype._uninstallResolutionListener = function() {
-        null !== this._resolutionMediaQueryList && (this._resolutionMediaQueryList.removeListener(this._resolutionListener), this._resolutionMediaQueryList = null);
-    }, t3.prototype._reinstallResolutionListener = function() {
-        this._uninstallResolutionListener(), this._installResolutionListener();
-    }, t3.prototype._onResolutionChanged = function() {
-        var t4 = this;
-        this._observers.forEach(function(e2) {
-            return e2.next(t4._window.devicePixelRatio);
-        }), this._reinstallResolutionListener();
-    }, t3;
-}();
-var dl = function() {
-    function t3(t4, e2, i2) {
-        var s2;
-        this._canvasElement = null, this._bitmapSizeChangedListeners = [], this._suggestedBitmapSize = null, this._suggestedBitmapSizeChangedListeners = [], this._devicePixelRatioObservable = null, this._canvasElementResizeObserver = null, this._canvasElement = t4, this._canvasElementClientSize = hl({
-            width: this._canvasElement.clientWidth,
-            height: this._canvasElement.clientHeight
-        }), this._transformBitmapSize = null != e2 ? e2 : function(t5) {
-            return t5;
-        }, this._allowResizeObserver = null === (s2 = null == i2 ? void 0 : i2.allowResizeObserver) || void 0 === s2 || s2, this._chooseAndInitObserver();
-    }
-    return t3.prototype.dispose = function() {
-        var t4, e2;
-        if (null === this._canvasElement)
-            throw new Error("Object is disposed");
-        null === (t4 = this._canvasElementResizeObserver) || void 0 === t4 || t4.disconnect(), this._canvasElementResizeObserver = null, null === (e2 = this._devicePixelRatioObservable) || void 0 === e2 || e2.dispose(), this._devicePixelRatioObservable = null, this._suggestedBitmapSizeChangedListeners.length = 0, this._bitmapSizeChangedListeners.length = 0, this._canvasElement = null;
-    }, Object.defineProperty(t3.prototype, "canvasElement", {
-        get: function() {
-            if (null === this._canvasElement)
-                throw new Error("Object is disposed");
-            return this._canvasElement;
-        },
-        enumerable: false,
-        configurable: true
-    }), Object.defineProperty(t3.prototype, "canvasElementClientSize", {
-        get: function() {
-            return this._canvasElementClientSize;
-        },
-        enumerable: false,
-        configurable: true
-    }), Object.defineProperty(t3.prototype, "bitmapSize", {
-        get: function() {
-            return hl({
-                width: this.canvasElement.width,
-                height: this.canvasElement.height
-            });
-        },
-        enumerable: false,
-        configurable: true
-    }), t3.prototype.resizeCanvasElement = function(t4) {
-        this._canvasElementClientSize = hl(t4), this.canvasElement.style.width = "".concat(this._canvasElementClientSize.width, "px"), this.canvasElement.style.height = "".concat(this._canvasElementClientSize.height, "px"), this._invalidateBitmapSize();
-    }, t3.prototype.subscribeBitmapSizeChanged = function(t4) {
-        this._bitmapSizeChangedListeners.push(t4);
-    }, t3.prototype.unsubscribeBitmapSizeChanged = function(t4) {
-        this._bitmapSizeChangedListeners = this._bitmapSizeChangedListeners.filter(function(e2) {
-            return e2 !== t4;
-        });
-    }, Object.defineProperty(t3.prototype, "suggestedBitmapSize", {
-        get: function() {
-            return this._suggestedBitmapSize;
-        },
-        enumerable: false,
-        configurable: true
-    }), t3.prototype.subscribeSuggestedBitmapSizeChanged = function(t4) {
-        this._suggestedBitmapSizeChangedListeners.push(t4);
-    }, t3.prototype.unsubscribeSuggestedBitmapSizeChanged = function(t4) {
-        this._suggestedBitmapSizeChangedListeners = this._suggestedBitmapSizeChangedListeners.filter(function(e2) {
-            return e2 !== t4;
-        });
-    }, t3.prototype.applySuggestedBitmapSize = function() {
-        if (null !== this._suggestedBitmapSize) {
-            var t4 = this._suggestedBitmapSize;
-            this._suggestedBitmapSize = null, this._resizeBitmap(t4), this._emitSuggestedBitmapSizeChanged(t4, this._suggestedBitmapSize);
-        }
-    }, t3.prototype._resizeBitmap = function(t4) {
-        var e2 = this.bitmapSize;
-        cl(e2, t4) || (this.canvasElement.width = t4.width, this.canvasElement.height = t4.height, this._emitBitmapSizeChanged(e2, t4));
-    }, t3.prototype._emitBitmapSizeChanged = function(t4, e2) {
-        var i2 = this;
-        this._bitmapSizeChangedListeners.forEach(function(s2) {
-            return s2.call(i2, t4, e2);
-        });
-    }, t3.prototype._suggestNewBitmapSize = function(t4) {
-        var e2 = this._suggestedBitmapSize,
-            i2 = hl(this._transformBitmapSize(t4, this._canvasElementClientSize)),
-            s2 = cl(this.bitmapSize, i2) ? null : i2;
-        null === e2 && null === s2 || null !== e2 && null !== s2 && cl(e2, s2) || (this._suggestedBitmapSize = s2, this._emitSuggestedBitmapSizeChanged(e2, s2));
-    }, t3.prototype._emitSuggestedBitmapSizeChanged = function(t4, e2) {
-        var i2 = this;
-        this._suggestedBitmapSizeChangedListeners.forEach(function(s2) {
-            return s2.call(i2, t4, e2);
-        });
-    }, t3.prototype._chooseAndInitObserver = function() {
-        var t4 = this;
-        this._allowResizeObserver ? new Promise(function(t5) {
-            var e2 = new ResizeObserver(function(i2) {
-                t5(i2.every(function(t6) {
-                    return "devicePixelContentBoxSize" in t6;
-                })), e2.disconnect();
-            });
-            e2.observe(document.body, {
-                box: "device-pixel-content-box"
-            });
-        }).catch(function() {
-            return false;
-        }).then(function(e2) {
-            return e2 ? t4._initResizeObserver() : t4._initDevicePixelRatioObservable();
-        }) : this._initDevicePixelRatioObservable();
-    }, t3.prototype._initDevicePixelRatioObservable = function() {
-        var t4 = this;
-        if (null !== this._canvasElement) {
-            var e2 = fl(this._canvasElement);
-            if (null === e2)
-                throw new Error("No window is associated with the canvas");
-            this._devicePixelRatioObservable = function(t5) {
-                return new ul(t5);
-            }(e2), this._devicePixelRatioObservable.subscribe(function() {
-                return t4._invalidateBitmapSize();
-            }), this._invalidateBitmapSize();
-        }
-    }, t3.prototype._invalidateBitmapSize = function() {
-        var t4, e2;
-        if (null !== this._canvasElement) {
-            var i2 = fl(this._canvasElement);
-            if (null !== i2) {
-                var s2 = null !== (e2 = null === (t4 = this._devicePixelRatioObservable) || void 0 === t4 ? void 0 : t4.value) && void 0 !== e2 ? e2 : i2.devicePixelRatio,
-                    n2 = this._canvasElement.getClientRects(),
-                    r2 = void 0 !== n2[0] ? function(t5, e3) {
-                        return hl({
-                            width: Math.round(t5.left * e3 + t5.width * e3) - Math.round(t5.left * e3),
-                            height: Math.round(t5.top * e3 + t5.height * e3) - Math.round(t5.top * e3)
-                        });
-                    }(n2[0], s2) : hl({
-                        width: this._canvasElementClientSize.width * s2,
-                        height: this._canvasElementClientSize.height * s2
-                    });
-                this._suggestNewBitmapSize(r2);
-            }
-        }
-    }, t3.prototype._initResizeObserver = function() {
-        var t4 = this;
-        null !== this._canvasElement && (this._canvasElementResizeObserver = new ResizeObserver(function(e2) {
-            var i2 = e2.find(function(e3) {
-                return e3.target === t4._canvasElement;
-            });
-            if (i2 && i2.devicePixelContentBoxSize && i2.devicePixelContentBoxSize[0]) {
-                var s2 = i2.devicePixelContentBoxSize[0],
-                    n2 = hl({
-                        width: s2.inlineSize,
-                        height: s2.blockSize
-                    });
-                t4._suggestNewBitmapSize(n2);
-            }
-        }), this._canvasElementResizeObserver.observe(this._canvasElement, {
-            box: "device-pixel-content-box"
-        }));
-    }, t3;
-}();
-
-function fl(t3) {
-    return t3.ownerDocument.defaultView;
-}
-var pl, ml, gl, yl = function() {
-    function t3(t4, e2, i2) {
-        if (0 === e2.width || 0 === e2.height)
-            throw new TypeError("Rendering target could only be created on a media with positive width and height");
-        if (this._mediaSize = e2, 0 === i2.width || 0 === i2.height)
-            throw new TypeError("Rendering target could only be created using a bitmap with positive integer width and height");
-        this._bitmapSize = i2, this._context = t4;
-    }
-    return t3.prototype.useMediaCoordinateSpace = function(t4) {
-        try {
-            return this._context.save(), this._context.setTransform(1, 0, 0, 1, 0, 0), this._context.scale(this._horizontalPixelRatio, this._verticalPixelRatio), t4({
-                context: this._context,
-                mediaSize: this._mediaSize
-            });
-        } finally {
-            this._context.restore();
-        }
-    }, t3.prototype.useBitmapCoordinateSpace = function(t4) {
-        try {
-            return this._context.save(), this._context.setTransform(1, 0, 0, 1, 0, 0), t4({
-                context: this._context,
-                mediaSize: this._mediaSize,
-                bitmapSize: this._bitmapSize,
-                horizontalPixelRatio: this._horizontalPixelRatio,
-                verticalPixelRatio: this._verticalPixelRatio
-            });
-        } finally {
-            this._context.restore();
-        }
-    }, Object.defineProperty(t3.prototype, "_horizontalPixelRatio", {
-        get: function() {
-            return this._bitmapSize.width / this._mediaSize.width;
-        },
-        enumerable: false,
-        configurable: true
-    }), Object.defineProperty(t3.prototype, "_verticalPixelRatio", {
-        get: function() {
-            return this._bitmapSize.height / this._mediaSize.height;
-        },
-        enumerable: false,
-        configurable: true
-    }), t3;
-}();
-
-function vl(t3, e2) {
-    var i2 = t3.canvasElementClientSize;
-    if (0 === i2.width || 0 === i2.height)
-        return null;
-    var s2 = t3.bitmapSize;
-    if (0 === s2.width || 0 === s2.height)
-        return null;
-    var n2 = t3.canvasElement.getContext("2d", e2);
-    return null === n2 ? null : new yl(n2, i2, s2);
-}
-
-function bl(t3, e2) {
-    const i2 = {
-        0: [],
-        1: [t3.lineWidth, t3.lineWidth],
-        2: [2 * t3.lineWidth, 2 * t3.lineWidth],
-        3: [6 * t3.lineWidth, 6 * t3.lineWidth],
-        4: [t3.lineWidth, 4 * t3.lineWidth]
-    } [e2];
-    t3.setLineDash(i2);
-}
-
-function _l(t3, e2, i2, s2) {
-    t3.beginPath();
-    const n2 = t3.lineWidth % 2 ? 0.5 : 0;
-    t3.moveTo(i2, e2 + n2), t3.lineTo(s2, e2 + n2), t3.stroke();
-}
-
-function wl(t3, e2) {
-    if (!t3)
-        throw new Error("Assertion failed" + (e2 ? ": " + e2 : ""));
-}
-
-function xl(t3) {
-    if (void 0 === t3)
-        throw new Error("Value is undefined");
-    return t3;
-}
-
-function kl(t3) {
-    if (null === t3)
-        throw new Error("Value is null");
-    return t3;
-}
-
-function Tl(t3) {
-    return kl(xl(t3));
-}
-(gl = pl || (pl = {}))[gl.Simple = 0] = "Simple", gl[gl.WithSteps = 1] = "WithSteps", gl[gl.Curved = 2] = "Curved",
-    function(t3) {
-        t3[t3.Solid = 0] = "Solid", t3[t3.Dotted = 1] = "Dotted", t3[t3.Dashed = 2] = "Dashed", t3[t3.LargeDashed = 3] = "LargeDashed", t3[t3.SparseDotted = 4] = "SparseDotted";
-    }(ml || (ml = {}));
-const Sl = {
-    khaki: "#f0e68c",
-    azure: "#f0ffff",
-    aliceblue: "#f0f8ff",
-    ghostwhite: "#f8f8ff",
-    gold: "#ffd700",
-    goldenrod: "#daa520",
-    gainsboro: "#dcdcdc",
-    gray: "#808080",
-    green: "#008000",
-    honeydew: "#f0fff0",
-    floralwhite: "#fffaf0",
-    lightblue: "#add8e6",
-    lightcoral: "#f08080",
-    lemonchiffon: "#fffacd",
-    hotpink: "#ff69b4",
-    lightyellow: "#ffffe0",
-    greenyellow: "#adff2f",
-    lightgoldenrodyellow: "#fafad2",
-    limegreen: "#32cd32",
-    linen: "#faf0e6",
-    lightcyan: "#e0ffff",
-    magenta: "#f0f",
-    maroon: "#800000",
-    olive: "#808000",
-    orange: "#ffa500",
-    oldlace: "#fdf5e6",
-    mediumblue: "#0000cd",
-    transparent: "#0000",
-    lime: "#0f0",
-    lightpink: "#ffb6c1",
-    mistyrose: "#ffe4e1",
-    moccasin: "#ffe4b5",
-    midnightblue: "#191970",
-    orchid: "#da70d6",
-    mediumorchid: "#ba55d3",
-    mediumturquoise: "#48d1cc",
-    orangered: "#ff4500",
-    royalblue: "#4169e1",
-    powderblue: "#b0e0e6",
-    red: "#f00",
-    coral: "#ff7f50",
-    turquoise: "#40e0d0",
-    white: "#fff",
-    whitesmoke: "#f5f5f5",
-    wheat: "#f5deb3",
-    teal: "#008080",
-    steelblue: "#4682b4",
-    bisque: "#ffe4c4",
-    aquamarine: "#7fffd4",
-    aqua: "#0ff",
-    sienna: "#a0522d",
-    silver: "#c0c0c0",
-    springgreen: "#00ff7f",
-    antiquewhite: "#faebd7",
-    burlywood: "#deb887",
-    brown: "#a52a2a",
-    beige: "#f5f5dc",
-    chocolate: "#d2691e",
-    chartreuse: "#7fff00",
-    cornflowerblue: "#6495ed",
-    cornsilk: "#fff8dc",
-    crimson: "#dc143c",
-    cadetblue: "#5f9ea0",
-    tomato: "#ff6347",
-    fuchsia: "#f0f",
-    blue: "#00f",
-    salmon: "#fa8072",
-    blanchedalmond: "#ffebcd",
-    slateblue: "#6a5acd",
-    slategray: "#708090",
-    thistle: "#d8bfd8",
-    tan: "#d2b48c",
-    cyan: "#0ff",
-    darkblue: "#00008b",
-    darkcyan: "#008b8b",
-    darkgoldenrod: "#b8860b",
-    darkgray: "#a9a9a9",
-    blueviolet: "#8a2be2",
-    black: "#000",
-    darkmagenta: "#8b008b",
-    darkslateblue: "#483d8b",
-    darkkhaki: "#bdb76b",
-    darkorchid: "#9932cc",
-    darkorange: "#ff8c00",
-    darkgreen: "#006400",
-    darkred: "#8b0000",
-    dodgerblue: "#1e90ff",
-    darkslategray: "#2f4f4f",
-    dimgray: "#696969",
-    deepskyblue: "#00bfff",
-    firebrick: "#b22222",
-    forestgreen: "#228b22",
-    indigo: "#4b0082",
-    ivory: "#fffff0",
-    lavenderblush: "#fff0f5",
-    feldspar: "#d19275",
-    indianred: "#cd5c5c",
-    lightgreen: "#90ee90",
-    lightgrey: "#d3d3d3",
-    lightskyblue: "#87cefa",
-    lightslategray: "#789",
-    lightslateblue: "#8470ff",
-    snow: "#fffafa",
-    lightseagreen: "#20b2aa",
-    lightsalmon: "#ffa07a",
-    darksalmon: "#e9967a",
-    darkviolet: "#9400d3",
-    mediumpurple: "#9370d8",
-    mediumaquamarine: "#66cdaa",
-    skyblue: "#87ceeb",
-    lavender: "#e6e6fa",
-    lightsteelblue: "#b0c4de",
-    mediumvioletred: "#c71585",
-    mintcream: "#f5fffa",
-    navajowhite: "#ffdead",
-    navy: "#000080",
-    olivedrab: "#6b8e23",
-    palevioletred: "#d87093",
-    violetred: "#d02090",
-    yellow: "#ff0",
-    yellowgreen: "#9acd32",
-    lawngreen: "#7cfc00",
-    pink: "#ffc0cb",
-    paleturquoise: "#afeeee",
-    palegoldenrod: "#eee8aa",
-    darkolivegreen: "#556b2f",
-    darkseagreen: "#8fbc8f",
-    darkturquoise: "#00ced1",
-    peachpuff: "#ffdab9",
-    deeppink: "#ff1493",
-    violet: "#ee82ee",
-    palegreen: "#98fb98",
-    mediumseagreen: "#3cb371",
-    peru: "#cd853f",
-    saddlebrown: "#8b4513",
-    sandybrown: "#f4a460",
-    rosybrown: "#bc8f8f",
-    purple: "#800080",
-    seagreen: "#2e8b57",
-    seashell: "#fff5ee",
-    papayawhip: "#ffefd5",
-    mediumslateblue: "#7b68ee",
-    plum: "#dda0dd",
-    mediumspringgreen: "#00fa9a"
-};
-
-function El(t3) {
-    return t3 < 0 ? 0 : t3 > 255 ? 255 : Math.round(t3) || 0;
-}
-
-function Cl(t3) {
-    return t3 <= 0 || t3 > 0 ? t3 < 0 ? 0 : t3 > 1 ? 1 : Math.round(1e4 * t3) / 1e4 : 0;
-}
-const Il = /^#([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])?$/i,
-    Ml = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i,
-    Pl = /^rgb\(\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*\)$/,
-    Rl = /^rgba\(\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?[\d]{0,10}(?:\.\d+)?)\s*\)$/;
-
-function Al(t3) {
-    (t3 = t3.toLowerCase()) in Sl && (t3 = Sl[t3]);
-    {
-        const e2 = Rl.exec(t3) || Pl.exec(t3);
-        if (e2)
-            return [El(parseInt(e2[1], 10)), El(parseInt(e2[2], 10)), El(parseInt(e2[3], 10)), Cl(e2.length < 5 ? 1 : parseFloat(e2[4]))];
-    } {
-        const e2 = Ml.exec(t3);
-        if (e2)
-            return [El(parseInt(e2[1], 16)), El(parseInt(e2[2], 16)), El(parseInt(e2[3], 16)), 1];
-    } {
-        const e2 = Il.exec(t3);
-        if (e2)
-            return [El(17 * parseInt(e2[1], 16)), El(17 * parseInt(e2[2], 16)), El(17 * parseInt(e2[3], 16)), 1];
-    }
-    throw new Error(`Cannot parse color: ${t3}`);
-}
-
-function Dl(t3) {
-    const e2 = Al(t3);
-    return {
-        t: `rgb(${e2[0]}, ${e2[1]}, ${e2[2]})`,
-        i: (i2 = e2, 0.199 * i2[0] + 0.687 * i2[1] + 0.114 * i2[2] > 160 ? "black" : "white")
-    };
-    var i2;
-}
-let Ll = class M {
-    constructor() {
-        this.h = [];
-    }
-    l(t3, e2, i2) {
-        const s2 = {
-            o: t3,
-            _: e2,
-            u: true === i2
-        };
-        this.h.push(s2);
-    }
-    p(t3) {
-        const e2 = this.h.findIndex((e3) => t3 === e3.o);
-        e2 > -1 && this.h.splice(e2, 1);
-    }
-    v(t3) {
-        this.h = this.h.filter((e2) => e2._ !== t3);
-    }
-    m(t3, e2, i2) {
-        const s2 = [...this.h];
-        this.h = this.h.filter((t4) => !t4.u), s2.forEach((s3) => s3.o(t3, e2, i2));
-    }
-    g() {
-        return this.h.length > 0;
-    }
-    M() {
-        this.h = [];
-    }
-};
-
-function Ol(t3, ...e2) {
-    for (const i2 of e2)
-        for (const e3 in i2)
-            void 0 !== i2[e3] && ("object" != typeof i2[e3] || void 0 === t3[e3] ? t3[e3] = i2[e3] : Ol(t3[e3], i2[e3]));
-    return t3;
-}
-
-function Fl(t3) {
-    return "number" == typeof t3 && isFinite(t3);
-}
-
-function Nl(t3) {
-    return "number" == typeof t3 && t3 % 1 == 0;
-}
-
-function $l(t3) {
-    return "string" == typeof t3;
-}
-
-function Vl(t3) {
-    return "boolean" == typeof t3;
-}
-
-function zl(t3) {
-    const e2 = t3;
-    if (!e2 || "object" != typeof e2)
-        return e2;
-    let i2, s2, n2;
-    for (s2 in i2 = Array.isArray(e2) ? [] : {}, e2)
-        e2.hasOwnProperty(s2) && (n2 = e2[s2], i2[s2] = n2 && "object" == typeof n2 ? zl(n2) : n2);
-    return i2;
-}
-
-function Bl(t3) {
-    return null !== t3;
-}
-
-function Ul(t3) {
-    return null === t3 ? void 0 : t3;
-}
-const jl = "-apple-system, BlinkMacSystemFont, 'Trebuchet MS', Roboto, Ubuntu, sans-serif";
-
-function Hl(t3, e2, i2) {
-    return void 0 === e2 && (e2 = jl), `${i2 = void 0 !== i2 ? `${i2} ` : ""}${t3}px ${e2}`;
-}
-let Wl = class O {
-    constructor() {
-        this.q = [];
-    }
-    Y(t3) {
-        this.q = t3;
-    }
-    X(t3, e2, i2) {
-        this.q.forEach((s2) => {
-            s2.X(t3, e2, i2);
-        });
-    }
-};
-class L {
-    X(t3, e2, i2) {
-        t3.useMediaCoordinateSpace((t4) => this.Z(t4, e2, i2));
-    }
-    K(t3, e2, i2) {
-        t3.useMediaCoordinateSpace((t4) => this.G(t4, e2, i2));
-    }
-    G(t3, e2, i2) {}
-}
-let ql = class I extends L {
-    constructor() {
-        super(...arguments), this.J = null;
-    }
-    tt(t3) {
-        this.J = t3;
-    }
-    Z({
-        context: t3
-    }) {
-        if (null === this.J || null === this.J.it)
-            return;
-        const e2 = this.J.it,
-            i2 = this.J,
-            s2 = (s3) => {
-                t3.beginPath();
-                for (let n2 = e2.to - 1; n2 >= e2.from; --n2) {
-                    const e3 = i2.nt[n2];
-                    t3.moveTo(e3.st, e3.et), t3.arc(e3.st, e3.et, s3, 0, 2 * Math.PI);
-                }
-                t3.fill();
-            };
-        i2.rt > 0 && (t3.fillStyle = i2.ht, s2(i2.lt + i2.rt)), t3.fillStyle = i2.ot, s2(i2.lt);
-    }
-};
-
-function Kl() {
-    return {
-        nt: [{
-            st: 0,
-            et: 0,
-            _t: 0,
-            ut: 0
-        }],
-        ot: "",
-        ht: "",
-        lt: 0,
-        rt: 0,
-        it: null
-    };
-}
-const Gl = {
-    from: 0,
-    to: 1
-};
-let Yl = class N {
-        X(t3, e2, i2) {
-            t3.useBitmapCoordinateSpace((t4) => this.Z(t4, e2, i2));
-        }
-    },
-    Ql = class F extends Yl {
-        constructor(t3) {
-            super(), this.zt = t3;
-        }
-        Z({
-            context: t3,
-            bitmapSize: e2,
-            horizontalPixelRatio: i2,
-            verticalPixelRatio: s2
-        }) {
-            if (null === this.zt)
-                return;
-            const n2 = this.zt.Vt.Ct,
-                r2 = this.zt.Nt.Ct;
-            if (!n2 && !r2)
-                return;
-            const o2 = Math.round(this.zt.st * i2),
-                a2 = Math.round(this.zt.et * s2);
-            t3.lineCap = "butt", n2 && o2 >= 0 && (t3.lineWidth = Math.floor(this.zt.Vt.rt * i2), t3.strokeStyle = this.zt.Vt.D, t3.fillStyle = this.zt.Vt.D, bl(t3, this.zt.Vt.Ft), function(t4, e3, i3, s3) {
-                t4.beginPath();
-                const n3 = t4.lineWidth % 2 ? 0.5 : 0;
-                t4.moveTo(e3 + n3, 0), t4.lineTo(e3 + n3, s3), t4.stroke();
-            }(t3, o2, 0, e2.height)), r2 && a2 >= 0 && (t3.lineWidth = Math.floor(this.zt.Nt.rt * s2), t3.strokeStyle = this.zt.Nt.D, t3.fillStyle = this.zt.Nt.D, bl(t3, this.zt.Nt.Ft), _l(t3, a2, 0, e2.width));
-        }
-    };
-
-function Xl(t3, e2, i2, s2, n2, r2) {
-    t3.fillRect(e2 + r2, i2, s2 - 2 * r2, r2), t3.fillRect(e2 + r2, i2 + n2 - r2, s2 - 2 * r2, r2), t3.fillRect(e2, i2, r2, n2), t3.fillRect(e2 + s2 - r2, i2, r2, n2);
-}
-
-function Jl(t3, e2, i2, s2, n2, r2) {
-    t3.save(), t3.globalCompositeOperation = "copy", t3.fillStyle = r2, t3.fillRect(e2, i2, s2, n2), t3.restore();
-}
-
-function Zl(t3, e2) {
-    return Array.isArray(t3) ? t3.map((t4) => 0 === t4 ? t4 : t4 + e2) : t3 + e2;
-}
-
-function th(t3, e2, i2, s2, n2, r2) {
-    let o2, a2, l2, h2;
-    if (Array.isArray(r2))
-        if (2 === r2.length) {
-            const t4 = Math.max(0, r2[0]),
-                e3 = Math.max(0, r2[1]);
-            o2 = t4, a2 = t4, l2 = e3, h2 = e3;
-        } else {
-            if (4 !== r2.length)
-                throw new Error("Wrong border radius - it should be like css border radius");
-            o2 = Math.max(0, r2[0]), a2 = Math.max(0, r2[1]), l2 = Math.max(0, r2[2]), h2 = Math.max(0, r2[3]);
-        }
-    else {
-        const t4 = Math.max(0, r2);
-        o2 = t4, a2 = t4, l2 = t4, h2 = t4;
-    }
-    t3.beginPath(), t3.moveTo(e2 + o2, i2), t3.lineTo(e2 + s2 - a2, i2), 0 !== a2 && t3.arcTo(e2 + s2, i2, e2 + s2, i2 + a2, a2), t3.lineTo(e2 + s2, i2 + n2 - l2), 0 !== l2 && t3.arcTo(e2 + s2, i2 + n2, e2 + s2 - l2, i2 + n2, l2), t3.lineTo(e2 + h2, i2 + n2), 0 !== h2 && t3.arcTo(e2, i2 + n2, e2, i2 + n2 - h2, h2), t3.lineTo(e2, i2 + o2), 0 !== o2 && t3.arcTo(e2, i2, e2 + o2, i2, o2);
-}
-
-function eh(t3, e2, i2, s2, n2, r2, o2 = 0, a2 = 0, l2 = "") {
-    if (t3.save(), !o2 || !l2 || l2 === r2)
-        return th(t3, e2, i2, s2, n2, a2), t3.fillStyle = r2, t3.fill(), void t3.restore();
-    const h2 = o2 / 2;
-    "transparent" !== r2 && (th(t3, e2 + o2, i2 + o2, s2 - 2 * o2, n2 - 2 * o2, Zl(a2, -o2)), t3.fillStyle = r2, t3.fill()), "transparent" !== l2 && (th(t3, e2 + h2, i2 + h2, s2 - o2, n2 - o2, Zl(a2, -h2)), t3.lineWidth = o2, t3.strokeStyle = l2, t3.closePath(), t3.stroke()), t3.restore();
-}
-
-function ih(t3, e2, i2, s2, n2, r2, o2) {
-    t3.save(), t3.globalCompositeOperation = "copy";
-    const a2 = t3.createLinearGradient(0, 0, 0, n2);
-    a2.addColorStop(0, r2), a2.addColorStop(1, o2), t3.fillStyle = a2, t3.fillRect(e2, i2, s2, n2), t3.restore();
-}
-let sh = class X {
-        constructor(t3, e2) {
-            this.tt(t3, e2);
-        }
-        tt(t3, e2) {
-            this.zt = t3, this.Kt = e2;
-        }
-        It(t3, e2) {
-            return this.zt.Ct ? t3.T + t3.I + t3.A : 0;
-        }
-        X(t3, e2, i2, s2) {
-            if (!this.zt.Ct || 0 === this.zt.Gt.length)
-                return;
-            const n2 = this.zt.D,
-                r2 = this.Kt.t,
-                o2 = t3.useBitmapCoordinateSpace((t4) => {
-                    const o3 = t4.context;
-                    o3.font = e2.P;
-                    const a2 = this.Jt(t4, e2, i2, s2),
-                        l2 = a2.Qt,
-                        h2 = (t5, e3) => {
-                            a2.ti ? eh(o3, l2.ii, l2.ni, l2.si, l2.ei, t5, l2.ri, [l2.lt, 0, 0, l2.lt], e3) : eh(o3, l2.hi, l2.ni, l2.si, l2.ei, t5, l2.ri, [0, l2.lt, l2.lt, 0], e3);
-                        };
-                    return h2(r2, "transparent"), this.zt.li && (o3.fillStyle = n2, o3.fillRect(l2.hi, l2.ai, l2.oi - l2.hi, l2._i)), h2("transparent", r2), this.zt.ui && (o3.fillStyle = e2.B, o3.fillRect(a2.ti ? l2.ci - l2.ri : 0, l2.ni, l2.ri, l2.di - l2.ni)), a2;
-                });
-            t3.useMediaCoordinateSpace(({
-                context: t4
-            }) => {
-                const i3 = o2.fi;
-                t4.font = e2.P, t4.textAlign = o2.ti ? "right" : "left", t4.textBaseline = "middle", t4.fillStyle = n2, t4.fillText(this.zt.Gt, i3.pi, (i3.ni + i3.di) / 2 + i3.vi);
-            });
-        }
-        Jt(t3, e2, i2, s2) {
-            var n2;
-            const {
-                context: r2,
-                bitmapSize: o2,
-                mediaSize: a2,
-                horizontalPixelRatio: l2,
-                verticalPixelRatio: h2
-            } = t3, c2 = this.zt.li || !this.zt.mi ? e2.C : 0, u2 = this.zt.bi ? e2.k : 0, d2 = e2.I + this.Kt.gi, f2 = e2.A + this.Kt.wi, p2 = e2.O, m2 = e2.L, g2 = this.zt.Gt, y2 = e2.T, v2 = i2.Mi(r2, g2), b2 = Math.ceil(i2.Si(r2, g2)), _2 = y2 + d2 + f2, w2 = e2.k + p2 + m2 + b2 + c2, x2 = Math.max(1, Math.floor(h2));
-            let k2 = Math.round(_2 * h2);
-            k2 % 2 != x2 % 2 && (k2 += 1);
-            const T2 = u2 > 0 ? Math.max(1, Math.floor(u2 * l2)) : 0,
-                S2 = Math.round(w2 * l2),
-                E2 = Math.round(c2 * l2),
-                C2 = null !== (n2 = this.Kt.xi) && void 0 !== n2 ? n2 : this.Kt.yi,
-                P2 = Math.round(C2 * h2) - Math.floor(0.5 * h2),
-                R2 = Math.floor(P2 + x2 / 2 - k2 / 2),
-                D2 = R2 + k2,
-                $2 = "right" === s2,
-                z2 = $2 ? a2.width - u2 : u2,
-                B2 = $2 ? o2.width - T2 : T2;
-            let U2, j2, H2;
-            return $2 ? (U2 = B2 - S2, j2 = B2 - E2, H2 = z2 - c2 - p2 - u2) : (U2 = B2 + S2, j2 = B2 + E2, H2 = z2 + c2 + p2), {
-                ti: $2,
-                Qt: {
-                    ni: R2,
-                    ai: P2,
-                    di: D2,
-                    si: S2,
-                    ei: k2,
-                    lt: 2 * l2,
-                    ri: T2,
-                    ii: U2,
-                    hi: B2,
-                    oi: j2,
-                    _i: x2,
-                    ci: o2.width
-                },
-                fi: {
-                    ni: R2 / h2,
-                    di: D2 / h2,
-                    pi: H2,
-                    vi: v2
-                }
-            };
-        }
-    },
-    nh = class Z {
-        constructor(t3) {
-            this.ki = {
-                yi: 0,
-                t: "#000",
-                wi: 0,
-                gi: 0
-            }, this.Ci = {
-                Gt: "",
-                Ct: false,
-                li: true,
-                mi: false,
-                Ot: "",
-                D: "#FFF",
-                ui: false,
-                bi: false
-            }, this.Ti = {
-                Gt: "",
-                Ct: false,
-                li: false,
-                mi: true,
-                Ot: "",
-                D: "#FFF",
-                ui: true,
-                bi: true
-            }, this.vt = true, this.Pi = new(t3 || sh)(this.Ci, this.ki), this.Ri = new(t3 || sh)(this.Ti, this.ki);
-        }
-        Gt() {
-            return this.Di(), this.Ci.Gt;
-        }
-        yi() {
-            return this.Di(), this.ki.yi;
-        }
-        gt() {
-            this.vt = true;
-        }
-        It(t3, e2 = false) {
-            return Math.max(this.Pi.It(t3, e2), this.Ri.It(t3, e2));
-        }
-        Bi() {
-            return this.ki.xi || 0;
-        }
-        Ai(t3) {
-            this.ki.xi = t3;
-        }
-        Oi() {
-            return this.Di(), this.Ci.Ct || this.Ti.Ct;
-        }
-        Li() {
-            return this.Di(), this.Ci.Ct;
-        }
-        Mt(t3) {
-            return this.Di(), this.Ci.li = this.Ci.li && t3.F().ticksVisible, this.Ti.li = this.Ti.li && t3.F().ticksVisible, this.Pi.tt(this.Ci, this.ki), this.Ri.tt(this.Ti, this.ki), this.Pi;
-        }
-        Ii() {
-            return this.Di(), this.Pi.tt(this.Ci, this.ki), this.Ri.tt(this.Ti, this.ki), this.Ri;
-        }
-        Di() {
-            this.vt && (this.Ci.li = true, this.Ti.li = false, this.Ei(this.Ci, this.Ti, this.ki));
-        }
-    },
-    rh = class K extends nh {
-        constructor(t3, e2, i2) {
-            super(), this.$t = t3, this.zi = e2, this.Vi = i2;
-        }
-        Ei(t3, e2, i2) {
-            t3.Ct = false;
-            const s2 = this.$t.F().horzLine;
-            if (!s2.labelVisible)
-                return;
-            const n2 = this.zi.Tt();
-            if (!this.$t.Ct() || this.zi.Ni() || null === n2)
-                return;
-            const r2 = Dl(s2.labelBackgroundColor);
-            i2.t = r2.t, t3.D = r2.i;
-            const o2 = 2 / 12 * this.zi.T();
-            i2.gi = o2, i2.wi = o2;
-            const a2 = this.Vi(this.zi);
-            i2.yi = a2.yi, t3.Gt = this.zi.Fi(a2.ut, n2), t3.Ct = true;
-        }
-    };
-const oh = /[1-9]/g;
-class tt {
-    constructor() {
-        this.Yi = null, this.Xi = 0;
-    }
-    Zi() {
-        return this.Xi;
-    }
-    Ki(t3) {
-        this.Xi = t3;
-    }
-    Bt() {
-        return this.Yi;
-    }
-    Gi(t3) {
-        this.Yi = t3;
-    }
-    Ji(t3) {
-        return [];
-    }
-    Qi() {
-        return [];
-    }
-    Ct() {
-        return true;
-    }
-}
-var ah;
-! function(t3) {
-    t3[t3.Normal = 0] = "Normal", t3[t3.Magnet = 1] = "Magnet";
-}(ah || (ah = {}));
-class nt extends tt {
-    constructor(t3, e2) {
-        super(), this.tn = null, this.nn = NaN, this.sn = 0, this.en = true, this.rn = /* @__PURE__ */ new Map(), this.hn = false, this.ln = NaN, this.an = NaN, this.on = NaN, this._n = NaN, this.Hi = t3, this.un = e2, this.cn = new class V {
-            constructor(t4, e3) {
-                this.ct = new Wl(), this.dt = [], this.ft = [], this.vt = true, this.N = t4, this.bt = e3, this.ct.Y(this.dt);
-            }
-            gt(t4) {
-                const e3 = this.N.wt();
-                e3.length !== this.dt.length && (this.ft = e3.map(Kl), this.dt = this.ft.map((t5) => {
-                    const e4 = new ql();
-                    return e4.tt(t5), e4;
-                }), this.ct.Y(this.dt)), this.vt = true;
-            }
-            Mt() {
-                return this.vt && (this.St(), this.vt = false), this.ct;
-            }
-            St() {
-                const t4 = this.N.wt(),
-                    e3 = this.bt.xt(),
-                    i3 = this.N.yt();
-                t4.forEach((t5, s2) => {
-                    var n2;
-                    const r2 = this.ft[s2],
-                        o2 = t5.kt(e3);
-                    if (null === o2 || !t5.Ct())
-                        return void(r2.it = null);
-                    const a2 = kl(t5.Tt());
-                    r2.ot = o2.Pt, r2.lt = o2.lt, r2.rt = o2.Rt, r2.nt[0].ut = o2.ut, r2.nt[0].et = t5.Bt().Dt(o2.ut, a2.At), r2.ht = null !== (n2 = o2.Ot) && void 0 !== n2 ? n2 : this.N.Lt(r2.nt[0].et / t5.Bt().It()), r2.nt[0]._t = e3, r2.nt[0].st = i3.Et(e3), r2.it = Gl;
-                });
-            }
-        }(t3, this), this.dn = ((t4, e3) => (i3) => {
-            const s2 = e3(),
-                n2 = t4();
-            if (i3 === kl(this.tn).fn())
-                return {
-                    ut: n2,
-                    yi: s2
-                };
-            {
-                const t5 = kl(i3.Tt());
-                return {
-                    ut: i3.pn(s2, t5),
-                    yi: s2
-                };
-            }
-        })(() => this.nn, () => this.an);
-        const i2 = ((t4, e3) => () => {
-            const i3 = this.Hi.yt().vn(t4()),
-                s2 = e3();
-            return i3 && Number.isFinite(s2) ? {
-                _t: i3,
-                yi: s2
-            } : null;
-        })(() => this.sn, () => this.Xt());
-        this.mn = new class Q {
-            constructor(t4, e3, i3) {
-                this.vt = true, this.jt = new class J {
-                    constructor() {
-                        this.zt = null;
-                    }
-                    tt(t5) {
-                        this.zt = t5;
-                    }
-                    X(t5, e4) {
-                        if (null === this.zt || false === this.zt.Ct || 0 === this.zt.Gt.length)
-                            return;
-                        const i4 = t5.useMediaCoordinateSpace(({
-                            context: t6
-                        }) => (t6.font = e4.P, Math.round(e4.Wi.Si(t6, kl(this.zt).Gt, oh))));
-                        if (i4 <= 0)
-                            return;
-                        const s2 = e4.ji,
-                            n2 = i4 + 2 * s2,
-                            r2 = n2 / 2,
-                            o2 = this.zt.$i;
-                        let a2 = this.zt.yi,
-                            l2 = Math.floor(a2 - r2) + 0.5;
-                        l2 < 0 ? (a2 += Math.abs(0 - l2), l2 = Math.floor(a2 - r2) + 0.5) : l2 + n2 > o2 && (a2 -= Math.abs(o2 - (l2 + n2)), l2 = Math.floor(a2 - r2) + 0.5);
-                        const h2 = l2 + n2,
-                            c2 = Math.ceil(0 + e4.k + e4.C + e4.I + e4.T + e4.A);
-                        t5.useBitmapCoordinateSpace(({
-                            context: t6,
-                            horizontalPixelRatio: i5,
-                            verticalPixelRatio: s3
-                        }) => {
-                            const n3 = kl(this.zt);
-                            t6.fillStyle = n3.t;
-                            const r3 = Math.round(l2 * i5),
-                                o3 = Math.round(0 * s3),
-                                a3 = Math.round(h2 * i5),
-                                u2 = Math.round(c2 * s3),
-                                d2 = Math.round(2 * i5);
-                            if (t6.beginPath(), t6.moveTo(r3, o3), t6.lineTo(r3, u2 - d2), t6.arcTo(r3, u2, r3 + d2, u2, d2), t6.lineTo(a3 - d2, u2), t6.arcTo(a3, u2, a3, u2 - d2, d2), t6.lineTo(a3, o3), t6.fill(), n3.li) {
-                                const r4 = Math.round(n3.yi * i5),
-                                    a4 = o3,
-                                    l3 = Math.round((a4 + e4.C) * s3);
-                                t6.fillStyle = n3.D;
-                                const h3 = Math.max(1, Math.floor(i5)),
-                                    c3 = Math.floor(0.5 * i5);
-                                t6.fillRect(r4 - c3, a4, h3, l3 - a4);
-                            }
-                        }), t5.useMediaCoordinateSpace(({
-                            context: t6
-                        }) => {
-                            const i5 = kl(this.zt),
-                                n3 = 0 + e4.k + e4.C + e4.I + e4.T / 2;
-                            t6.font = e4.P, t6.textAlign = "left", t6.textBaseline = "middle", t6.fillStyle = i5.D;
-                            const r3 = e4.Wi.Mi(t6, "Apr0");
-                            t6.translate(l2 + s2, n3 + r3), t6.fillText(i5.Gt, 0, 0);
-                        });
-                    }
-                }(), this.Wt = {
-                    Ct: false,
-                    t: "#4c525e",
-                    D: "white",
-                    Gt: "",
-                    $i: 0,
-                    yi: NaN,
-                    li: true
-                }, this.bt = t4, this.Hi = e3, this.Vi = i3;
-            }
-            gt() {
-                this.vt = true;
-            }
-            Mt() {
-                return this.vt && (this.St(), this.vt = false), this.jt.tt(this.Wt), this.jt;
-            }
-            St() {
-                const t4 = this.Wt;
-                t4.Ct = false;
-                const e3 = this.bt.F().vertLine;
-                if (!e3.labelVisible)
-                    return;
-                const i3 = this.Hi.yt();
-                if (i3.Ni())
-                    return;
-                t4.$i = i3.$i();
-                const s2 = this.Vi();
-                if (null === s2)
-                    return;
-                t4.yi = s2.yi;
-                const n2 = i3.Ui(this.bt.xt());
-                t4.Gt = i3.qi(kl(n2)), t4.Ct = true;
-                const r2 = Dl(e3.labelBackgroundColor);
-                t4.t = r2.t, t4.D = r2.i, t4.li = i3.F().ticksVisible;
-            }
-        }(this, t3, i2), this.bn = new class W {
-            constructor(t4) {
-                this.vt = true, this.Wt = {
-                    Vt: {
-                        rt: 1,
-                        Ft: 0,
-                        D: "",
-                        Ct: false
-                    },
-                    Nt: {
-                        rt: 1,
-                        Ft: 0,
-                        D: "",
-                        Ct: false
-                    },
-                    st: 0,
-                    et: 0
-                }, this.jt = new Ql(this.Wt), this.$t = t4;
-            }
-            gt() {
-                this.vt = true;
-            }
-            Mt() {
-                return this.vt && (this.St(), this.vt = false), this.jt;
-            }
-            St() {
-                const t4 = this.$t.Ct(),
-                    e3 = kl(this.$t.Ht()),
-                    i3 = e3.Ut().F().crosshair,
-                    s2 = this.Wt;
-                s2.Nt.Ct = t4 && this.$t.qt(e3), s2.Vt.Ct = t4 && this.$t.Yt(), s2.Nt.rt = i3.horzLine.width, s2.Nt.Ft = i3.horzLine.style, s2.Nt.D = i3.horzLine.color, s2.Vt.rt = i3.vertLine.width, s2.Vt.Ft = i3.vertLine.style, s2.Vt.D = i3.vertLine.color, s2.st = this.$t.Xt(), s2.et = this.$t.Zt();
-            }
-        }(this);
-    }
-    F() {
-        return this.un;
-    }
-    gn(t3, e2) {
-        this.on = t3, this._n = e2;
-    }
-    wn() {
-        this.on = NaN, this._n = NaN;
-    }
-    Mn() {
-        return this.on;
-    }
-    Sn() {
-        return this._n;
-    }
-    xn(t3, e2, i2) {
-        this.hn || (this.hn = true), this.en = true, this.yn(t3, e2, i2);
-    }
-    xt() {
-        return this.sn;
-    }
-    Xt() {
-        return this.ln;
-    }
-    Zt() {
-        return this.an;
-    }
-    Ct() {
-        return this.en;
-    }
-    kn() {
-        this.en = false, this.Cn(), this.nn = NaN, this.ln = NaN, this.an = NaN, this.tn = null, this.wn();
-    }
-    Tn(t3) {
-        return null !== this.tn ? [this.bn, this.cn] : [];
-    }
-    qt(t3) {
-        return t3 === this.tn && this.un.horzLine.visible;
-    }
-    Yt() {
-        return this.un.vertLine.visible;
-    }
-    Pn(t3, e2) {
-        this.en && this.tn === t3 || this.rn.clear();
-        const i2 = [];
-        return this.tn === t3 && i2.push(this.Rn(this.rn, e2, this.dn)), i2;
-    }
-    Qi() {
-        return this.en ? [this.mn] : [];
-    }
-    Ht() {
-        return this.tn;
-    }
-    Dn() {
-        this.bn.gt(), this.rn.forEach((t3) => t3.gt()), this.mn.gt(), this.cn.gt();
-    }
-    Bn(t3) {
-        return t3 && !t3.fn().Ni() ? t3.fn() : null;
-    }
-    yn(t3, e2, i2) {
-        this.An(t3, e2, i2) && this.Dn();
-    }
-    An(t3, e2, i2) {
-        const s2 = this.ln,
-            n2 = this.an,
-            r2 = this.nn,
-            o2 = this.sn,
-            a2 = this.tn,
-            l2 = this.Bn(i2);
-        this.sn = t3, this.ln = isNaN(t3) ? NaN : this.Hi.yt().Et(t3), this.tn = i2;
-        const h2 = null !== l2 ? l2.Tt() : null;
-        return null !== l2 && null !== h2 ? (this.nn = e2, this.an = l2.Dt(e2, h2)) : (this.nn = NaN, this.an = NaN), s2 !== this.ln || n2 !== this.an || o2 !== this.sn || r2 !== this.nn || a2 !== this.tn;
-    }
-    Cn() {
-        const t3 = this.Hi.wt().map((t4) => t4.Ln().On()).filter(Bl),
-            e2 = 0 === t3.length ? null : Math.max(...t3);
-        this.sn = null !== e2 ? e2 : NaN;
-    }
-    Rn(t3, e2, i2) {
-        let s2 = t3.get(e2);
-        return void 0 === s2 && (s2 = new rh(this, e2, i2), t3.set(e2, s2)), s2;
-    }
-}
-
-function lh(t3) {
-    return "left" === t3 || "right" === t3;
-}
-class et {
-    constructor(t3) {
-        this.In = /* @__PURE__ */ new Map(), this.En = [], this.zn = t3;
-    }
-    Vn(t3, e2) {
-        const i2 = function(t4, e3) {
-            return void 0 === t4 ? e3 : {
-                Nn: Math.max(t4.Nn, e3.Nn),
-                Fn: t4.Fn || e3.Fn
-            };
-        }(this.In.get(t3), e2);
-        this.In.set(t3, i2);
-    }
-    Wn() {
-        return this.zn;
-    }
-    jn(t3) {
-        const e2 = this.In.get(t3);
-        return void 0 === e2 ? {
-            Nn: this.zn
-        } : {
-            Nn: Math.max(this.zn, e2.Nn),
-            Fn: e2.Fn
-        };
-    }
-    $n() {
-        this.Hn(), this.En = [{
-            Un: 0
-        }];
-    }
-    qn(t3) {
-        this.Hn(), this.En = [{
-            Un: 1,
-            At: t3
-        }];
-    }
-    Yn(t3) {
-        this.Xn(), this.En.push({
-            Un: 5,
-            At: t3
-        });
-    }
-    Hn() {
-        this.Xn(), this.En.push({
-            Un: 6
-        });
-    }
-    Zn() {
-        this.Hn(), this.En = [{
-            Un: 4
-        }];
-    }
-    Kn(t3) {
-        this.Hn(), this.En.push({
-            Un: 2,
-            At: t3
-        });
-    }
-    Gn(t3) {
-        this.Hn(), this.En.push({
-            Un: 3,
-            At: t3
-        });
-    }
-    Jn() {
-        return this.En;
-    }
-    Qn(t3) {
-        for (const e2 of t3.En)
-            this.ts(e2);
-        this.zn = Math.max(this.zn, t3.zn), t3.In.forEach((t4, e2) => {
-            this.Vn(e2, t4);
-        });
-    }
-    static ns() {
-        return new et(2);
-    }
-    static ss() {
-        return new et(3);
-    }
-    ts(t3) {
-        switch (t3.Un) {
-            case 0:
-                this.$n();
-                break;
-            case 1:
-                this.qn(t3.At);
-                break;
-            case 2:
-                this.Kn(t3.At);
-                break;
-            case 3:
-                this.Gn(t3.At);
-                break;
-            case 4:
-                this.Zn();
-                break;
-            case 5:
-                this.Yn(t3.At);
-                break;
-            case 6:
-                this.Xn();
-        }
-    }
-    Xn() {
-        const t3 = this.En.findIndex((t4) => 5 === t4.Un); -
-        1 !== t3 && this.En.splice(t3, 1);
-    }
-}
-
-function hh(t3, e2) {
-    if (!Fl(t3))
-        return "n/a";
-    if (!Nl(e2))
-        throw new TypeError("invalid length");
-    if (e2 < 0 || e2 > 16)
-        throw new TypeError("invalid length");
-    return 0 === e2 ? t3.toString() : ("0000000000000000" + t3.toString()).slice(-e2);
-}
-class lt {
-    constructor(t3, e2) {
-        if (e2 || (e2 = 1), Fl(t3) && Nl(t3) || (t3 = 100), t3 < 0)
-            throw new TypeError("invalid base");
-        this.zi = t3, this.es = e2, this.rs();
-    }
-    format(t3) {
-        const e2 = t3 < 0 ? "−" : "";
-        return t3 = Math.abs(t3), e2 + this.hs(t3);
-    }
-    rs() {
-        if (this.ls = 0, this.zi > 0 && this.es > 0) {
-            let t3 = this.zi;
-            for (; t3 > 1;)
-                t3 /= 10, this.ls++;
-        }
-    }
-    hs(t3) {
-        const e2 = this.zi / this.es;
-        let i2 = Math.floor(t3),
-            s2 = "";
-        const n2 = void 0 !== this.ls ? this.ls : NaN;
-        if (e2 > 1) {
-            let r2 = +(Math.round(t3 * e2) - i2 * e2).toFixed(this.ls);
-            r2 >= e2 && (r2 -= e2, i2 += 1), s2 = "." + hh(+r2.toFixed(this.ls) * this.es, n2);
-        } else
-            i2 = Math.round(i2 * e2) / e2, n2 > 0 && (s2 = "." + hh(0, n2));
-        return i2.toFixed(0) + s2;
-    }
-}
-class at extends lt {
-    constructor(t3 = 100) {
-        super(t3);
-    }
-    format(t3) {
-        return `${super.format(t3)}%`;
-    }
-}
-class ot {
-    constructor(t3) {
-        this.os = t3;
-    }
-    format(t3) {
-        let e2 = "";
-        return t3 < 0 && (e2 = "-", t3 = -t3), t3 < 995 ? e2 + this._s(t3) : t3 < 999995 ? e2 + this._s(t3 / 1e3) + "K" : t3 < 999999995 ? (t3 = 1e3 * Math.round(t3 / 1e3), e2 + this._s(t3 / 1e6) + "M") : (t3 = 1e6 * Math.round(t3 / 1e6), e2 + this._s(t3 / 1e9) + "B");
-    }
-    _s(t3) {
-        let e2;
-        const i2 = Math.pow(10, this.os);
-        return e2 = (t3 = Math.round(t3 * i2) / i2) >= 1e-15 && t3 < 1 ? t3.toFixed(this.os).replace(/\.?0+$/, "") : String(t3), e2.replace(/(\.[1-9]*)0+$/, (t4, e3) => e3);
-    }
-}
-
-function ch(t3, e2, i2, s2, n2, r2, o2) {
-    if (0 === e2.length || s2.from >= e2.length || s2.to <= 0)
-        return;
-    const a2 = t3.context,
-        l2 = e2[s2.from];
-    let h2 = r2(t3, l2),
-        c2 = l2;
-    if (s2.to - s2.from < 2) {
-        const t4 = n2 / 2;
-        a2.beginPath();
-        const e3 = {
-                st: l2.st - t4,
-                et: l2.et
-            },
-            i3 = {
-                st: l2.st + t4,
-                et: l2.et
-            };
-        return a2.moveTo(e3.st, e3.et), a2.lineTo(i3.st, i3.et), void o2(a2, h2, e3, i3);
-    }
-    const u2 = (t4, e3) => {
-        o2(a2, h2, c2, e3), a2.beginPath(), h2 = t4, c2 = e3;
-    };
-    let d2 = c2;
-    a2.beginPath(), a2.moveTo(l2.st, l2.et);
-    for (let n3 = s2.from + 1; n3 < s2.to; ++n3) {
-        d2 = e2[n3];
-        const s3 = r2(t3, d2);
-        switch (i2) {
-            case 0:
-                a2.lineTo(d2.st, d2.et);
-                break;
-            case 1:
-                a2.lineTo(d2.st, e2[n3 - 1].et), s3 !== h2 && (u2(s3, d2), a2.lineTo(d2.st, e2[n3 - 1].et)), a2.lineTo(d2.st, d2.et);
-                break;
-            case 2: {
-                const [t4, i3] = ph(e2, n3 - 1, n3);
-                a2.bezierCurveTo(t4.st, t4.et, i3.st, i3.et, d2.st, d2.et);
-                break;
-            }
-        }
-        1 !== i2 && s3 !== h2 && (u2(s3, d2), a2.moveTo(d2.st, d2.et));
-    }
-    (c2 !== d2 || c2 === d2 && 1 === i2) && o2(a2, h2, c2, d2);
-}
-const uh = 6;
-
-function dh(t3, e2) {
-    return {
-        st: t3.st - e2.st,
-        et: t3.et - e2.et
-    };
-}
-
-function fh(t3, e2) {
-    return {
-        st: t3.st / e2,
-        et: t3.et / e2
-    };
-}
-
-function ph(t3, e2, i2) {
-    const s2 = Math.max(0, e2 - 1),
-        n2 = Math.min(t3.length - 1, i2 + 1);
-    var r2, o2;
-    return [(r2 = t3[e2], o2 = fh(dh(t3[i2], t3[s2]), uh), {
-        st: r2.st + o2.st,
-        et: r2.et + o2.et
-    }), dh(t3[i2], fh(dh(t3[n2], t3[e2]), uh))];
-}
-
-function mh(t3, e2, i2, s2, n2) {
-    e2.lineTo(n2.st, t3), e2.lineTo(s2.st, t3), e2.closePath(), e2.fillStyle = i2, e2.fill();
-}
-class vt extends L {
-    constructor() {
-        super(...arguments), this.J = null;
-    }
-    tt(t3) {
-        this.J = t3;
-    }
-    Z(t3) {
-        var e2;
-        if (null === this.J)
-            return;
-        const {
-            nt: i2,
-            it: s2,
-            us: n2,
-            rt: r2,
-            Ft: o2,
-            cs: a2
-        } = this.J, l2 = null !== (e2 = this.J.ds) && void 0 !== e2 ? e2 : this.J.fs ? 0 : t3.mediaSize.height;
-        if (null === s2)
-            return;
-        const h2 = t3.context;
-        h2.lineCap = "butt", h2.lineJoin = "round", h2.lineWidth = r2, bl(h2, o2), h2.lineWidth = 1, ch(t3, i2, a2, s2, n2, this.ps.bind(this), mh.bind(null, l2));
-    }
-}
-class mt extends vt {
-    constructor() {
-        super(...arguments), this.vs = null;
-    }
-    ps(t3, e2) {
-        const {
-            context: i2,
-            mediaSize: s2
-        } = t3, {
-            bs: n2,
-            gs: r2
-        } = e2, o2 = s2.height;
-        if (null !== this.vs && this.vs.topColor === n2 && this.vs.bottomColor === r2 && this.vs.bottom === o2)
-            return this.vs.fillStyle;
-        const a2 = i2.createLinearGradient(0, 0, 0, o2);
-        return a2.addColorStop(0, n2), a2.addColorStop(1, r2), this.vs = {
-            topColor: n2,
-            bottomColor: r2,
-            fillStyle: a2,
-            bottom: o2
-        }, a2;
-    }
-}
-
-function gh(t3, e2) {
-    t3.strokeStyle = e2, t3.stroke();
-}
-class gt extends L {
-    constructor() {
-        super(...arguments), this.J = null;
-    }
-    tt(t3) {
-        this.J = t3;
-    }
-    Z(t3) {
-        if (null === this.J)
-            return;
-        const {
-            nt: e2,
-            it: i2,
-            us: s2,
-            cs: n2,
-            rt: r2,
-            Ft: o2
-        } = this.J;
-        if (null === i2)
-            return;
-        const a2 = t3.context;
-        a2.lineCap = "butt", a2.lineWidth = r2, bl(a2, o2), a2.lineJoin = "round", ch(t3, e2, n2, i2, s2, this.ws.bind(this), gh);
-    }
-}
-class wt extends gt {
-    ws(t3, e2) {
-        return e2.ot;
-    }
-}
-
-function yh(t3, e2, i2, s2 = 0, n2 = t3.length) {
-    let r2 = n2 - s2;
-    for (; 0 < r2;) {
-        const n3 = r2 >> 1,
-            o2 = s2 + n3;
-        i2(t3[o2], e2) ? (s2 = o2 + 1, r2 -= n3 + 1) : r2 = n3;
-    }
-    return s2;
-}
-
-function vh(t3, e2, i2, s2 = 0, n2 = t3.length) {
-    let r2 = n2 - s2;
-    for (; 0 < r2;) {
-        const n3 = r2 >> 1,
-            o2 = s2 + n3;
-        i2(e2, t3[o2]) ? r2 = n3 : (s2 = o2 + 1, r2 -= n3 + 1);
-    }
-    return s2;
-}
-
-function bh(t3, e2) {
-    return t3._t < e2;
-}
-
-function _h(t3, e2) {
-    return t3 < e2._t;
-}
-
-function wh(t3, e2, i2) {
-    const s2 = e2.Ms(),
-        n2 = e2.ci(),
-        r2 = yh(t3, s2, bh),
-        o2 = vh(t3, n2, _h);
-    if (!i2)
-        return {
-            from: r2,
-            to: o2
-        };
-    let a2 = r2,
-        l2 = o2;
-    return r2 > 0 && r2 < t3.length && t3[r2]._t >= s2 && (a2 = r2 - 1), o2 > 0 && o2 < t3.length && t3[o2 - 1]._t <= n2 && (l2 = o2 + 1), {
-        from: a2,
-        to: l2
-    };
-}
-class Ct {
-    constructor(t3, e2, i2) {
-        this.Ss = true, this.xs = true, this.ys = true, this.ks = [], this.Cs = null, this.Ts = t3, this.Ps = e2, this.Rs = i2;
-    }
-    gt(t3) {
-        this.Ss = true, "data" === t3 && (this.xs = true), "options" === t3 && (this.ys = true);
-    }
-    Mt() {
-        return this.Ts.Ct() ? (this.Ds(), null === this.Cs ? null : this.Bs) : null;
-    }
-    As() {
-        this.ks = this.ks.map((t3) => Object.assign(Object.assign({}, t3), this.Ts.Ls().Os(t3._t)));
-    }
-    Is() {
-        this.Cs = null;
-    }
-    Ds() {
-        this.xs && (this.Es(), this.xs = false), this.ys && (this.As(), this.ys = false), this.Ss && (this.zs(), this.Ss = false);
-    }
-    zs() {
-        const t3 = this.Ts.Bt(),
-            e2 = this.Ps.yt();
-        if (this.Is(), e2.Ni() || t3.Ni())
-            return;
-        const i2 = e2.Vs();
-        if (null === i2)
-            return;
-        if (0 === this.Ts.Ln().Ns())
-            return;
-        const s2 = this.Ts.Tt();
-        null !== s2 && (this.Cs = wh(this.ks, i2, this.Rs), this.Fs(t3, e2, s2.At), this.Ws());
-    }
-}
-class Tt extends Ct {
-    constructor(t3, e2) {
-        super(t3, e2, true);
-    }
-    Fs(t3, e2, i2) {
-        e2.js(this.ks, Ul(this.Cs)), t3.$s(this.ks, i2, Ul(this.Cs));
-    }
-    Hs(t3, e2) {
-        return {
-            _t: t3,
-            ut: e2,
-            st: NaN,
-            et: NaN
-        };
-    }
-    Es() {
-        const t3 = this.Ts.Ls();
-        this.ks = this.Ts.Ln().Us().map((e2) => {
-            const i2 = e2.At[3];
-            return this.qs(e2.Ys, i2, t3);
-        });
-    }
-}
-class Pt extends Tt {
-    constructor(t3, e2) {
-        super(t3, e2), this.Bs = new Wl(), this.Xs = new mt(), this.Zs = new wt(), this.Bs.Y([this.Xs, this.Zs]);
-    }
-    qs(t3, e2, i2) {
-        return Object.assign(Object.assign({}, this.Hs(t3, e2)), i2.Os(t3));
-    }
-    Ws() {
-        const t3 = this.Ts.F();
-        this.Xs.tt({
-            cs: t3.lineType,
-            nt: this.ks,
-            Ft: t3.lineStyle,
-            rt: t3.lineWidth,
-            ds: null,
-            fs: t3.invertFilledArea,
-            it: this.Cs,
-            us: this.Ps.yt().Ks()
-        }), this.Zs.tt({
-            cs: t3.lineType,
-            nt: this.ks,
-            Ft: t3.lineStyle,
-            rt: t3.lineWidth,
-            it: this.Cs,
-            us: this.Ps.yt().Ks()
-        });
-    }
-}
-class Rt extends Yl {
-    constructor() {
-        super(...arguments), this.zt = null, this.Gs = 0, this.Js = 0;
-    }
-    tt(t3) {
-        this.zt = t3;
-    }
-    Z({
-        context: t3,
-        horizontalPixelRatio: e2,
-        verticalPixelRatio: i2
-    }) {
-        if (null === this.zt || 0 === this.zt.Ln.length || null === this.zt.it)
-            return;
-        this.Gs = this.Qs(e2), this.Gs >= 2 && Math.max(1, Math.floor(e2)) % 2 != this.Gs % 2 && this.Gs--, this.Js = this.zt.te ? Math.min(this.Gs, Math.floor(e2)) : this.Gs;
-        let s2 = null;
-        const n2 = this.Js <= this.Gs && this.zt.Ks >= Math.floor(1.5 * e2);
-        for (let r2 = this.zt.it.from; r2 < this.zt.it.to; ++r2) {
-            const o2 = this.zt.Ln[r2];
-            s2 !== o2.ie && (t3.fillStyle = o2.ie, s2 = o2.ie);
-            const a2 = Math.floor(0.5 * this.Js),
-                l2 = Math.round(o2.st * e2),
-                h2 = l2 - a2,
-                c2 = this.Js,
-                u2 = h2 + c2 - 1,
-                d2 = Math.min(o2.ne, o2.se),
-                f2 = Math.max(o2.ne, o2.se),
-                p2 = Math.round(d2 * i2) - a2,
-                m2 = Math.round(f2 * i2) + a2,
-                g2 = Math.max(m2 - p2, this.Js);
-            t3.fillRect(h2, p2, c2, g2);
-            const y2 = Math.ceil(1.5 * this.Gs);
-            if (n2) {
-                if (this.zt.ee) {
-                    const e4 = l2 - y2;
-                    let s4 = Math.max(p2, Math.round(o2.re * i2) - a2),
-                        n4 = s4 + c2 - 1;
-                    n4 > p2 + g2 - 1 && (n4 = p2 + g2 - 1, s4 = n4 - c2 + 1), t3.fillRect(e4, s4, h2 - e4, n4 - s4 + 1);
-                }
-                const e3 = l2 + y2;
-                let s3 = Math.max(p2, Math.round(o2.he * i2) - a2),
-                    n3 = s3 + c2 - 1;
-                n3 > p2 + g2 - 1 && (n3 = p2 + g2 - 1, s3 = n3 - c2 + 1), t3.fillRect(u2 + 1, s3, e3 - u2, n3 - s3 + 1);
-            }
-        }
-    }
-    Qs(t3) {
-        const e2 = Math.floor(t3);
-        return Math.max(e2, Math.floor(function(t4, e3) {
-            return Math.floor(0.3 * t4 * e3);
-        }(kl(this.zt).Ks, t3)));
-    }
-}
-class Dt extends Ct {
-    constructor(t3, e2) {
-        super(t3, e2, false);
-    }
-    Fs(t3, e2, i2) {
-        e2.js(this.ks, Ul(this.Cs)), t3.le(this.ks, i2, Ul(this.Cs));
-    }
-    ae(t3, e2, i2) {
-        return {
-            _t: t3,
-            oe: e2.At[0],
-            _e: e2.At[1],
-            ue: e2.At[2],
-            ce: e2.At[3],
-            st: NaN,
-            re: NaN,
-            ne: NaN,
-            se: NaN,
-            he: NaN
-        };
-    }
-    Es() {
-        const t3 = this.Ts.Ls();
-        this.ks = this.Ts.Ln().Us().map((e2) => this.qs(e2.Ys, e2, t3));
-    }
-}
-class Bt extends Dt {
-    constructor() {
-        super(...arguments), this.Bs = new Rt();
-    }
-    qs(t3, e2, i2) {
-        return Object.assign(Object.assign({}, this.ae(t3, e2, i2)), i2.Os(t3));
-    }
-    Ws() {
-        const t3 = this.Ts.F();
-        this.Bs.tt({
-            Ln: this.ks,
-            Ks: this.Ps.yt().Ks(),
-            ee: t3.openVisible,
-            te: t3.thinBars,
-            it: this.Cs
-        });
-    }
-}
-
-function xh(t3, e2, i2) {
-    return Math.min(Math.max(t3, e2), i2);
-}
-
-function kh(t3, e2, i2) {
-    return e2 - t3 <= i2;
-}
-
-function Th(t3) {
-    return t3 <= 0 ? NaN : Math.log(t3) / Math.log(10);
-}
-
-function Sh(t3) {
-    const e2 = Math.ceil(t3);
-    return e2 % 2 == 0 ? e2 - 1 : e2;
-}
-class Et extends vt {
-    constructor() {
-        super(...arguments), this.vs = null;
-    }
-    ps(t3, e2) {
-        var i2;
-        const {
-            context: s2,
-            mediaSize: n2
-        } = t3, r2 = this.J, {
-            de: o2,
-            fe: a2,
-            pe: l2,
-            ve: h2
-        } = e2, c2 = null !== (i2 = r2.ds) && void 0 !== i2 ? i2 : n2.height, u2 = n2.height;
-        if (null !== this.vs && this.vs.topFillColor1 === o2 && this.vs.topFillColor2 === a2 && this.vs.bottomFillColor1 === l2 && this.vs.bottomFillColor2 === h2 && this.vs.baseLevelCoordinate === c2 && this.vs.bottom === u2)
-            return this.vs.fillStyle;
-        const d2 = s2.createLinearGradient(0, 0, 0, u2),
-            f2 = xh(c2 / u2, 0, 1);
-        return d2.addColorStop(0, o2), d2.addColorStop(f2, a2), d2.addColorStop(f2, l2), d2.addColorStop(1, h2), this.vs = {
-            topFillColor1: o2,
-            topFillColor2: a2,
-            bottomFillColor1: l2,
-            bottomFillColor2: h2,
-            fillStyle: d2,
-            baseLevelCoordinate: c2,
-            bottom: u2
-        }, d2;
-    }
-}
-class zt extends gt {
-    constructor() {
-        super(...arguments), this.me = null;
-    }
-    ws(t3, e2) {
-        const {
-            context: i2,
-            mediaSize: s2
-        } = t3, n2 = this.J, {
-            be: r2,
-            ge: o2
-        } = e2, {
-            ds: a2
-        } = n2, l2 = s2.height;
-        if (null !== this.me && this.me.topLineColor === r2 && this.me.bottomLineColor === o2 && this.me.baseLevelCoordinate === a2 && this.me.bottom === l2)
-            return this.me.strokeStyle;
-        const h2 = i2.createLinearGradient(0, 0, 0, l2),
-            c2 = xh(a2 / l2, 0, 1);
-        return h2.addColorStop(0, r2), h2.addColorStop(c2, r2), h2.addColorStop(c2, o2), h2.addColorStop(1, o2), this.me = {
-            topLineColor: r2,
-            bottomLineColor: o2,
-            strokeStyle: h2,
-            baseLevelCoordinate: a2,
-            bottom: l2
-        }, h2;
-    }
-}
-class Vt extends Tt {
-    constructor(t3, e2) {
-        super(t3, e2), this.Bs = new Wl(), this.we = new Et(), this.Me = new zt(), this.Bs.Y([this.we, this.Me]);
-    }
-    qs(t3, e2, i2) {
-        return Object.assign(Object.assign({}, this.Hs(t3, e2)), i2.Os(t3));
-    }
-    Ws() {
-        const t3 = this.Ts.Tt();
-        if (null === t3)
-            return;
-        const e2 = this.Ts.F(),
-            i2 = this.Ts.Bt().Dt(e2.baseValue.price, t3.At),
-            s2 = this.Ps.yt().Ks();
-        this.we.tt({
-            nt: this.ks,
-            rt: e2.lineWidth,
-            Ft: e2.lineStyle,
-            cs: e2.lineType,
-            ds: i2,
-            fs: false,
-            it: this.Cs,
-            us: s2
-        }), this.Me.tt({
-            nt: this.ks,
-            rt: e2.lineWidth,
-            Ft: e2.lineStyle,
-            cs: e2.lineType,
-            ds: i2,
-            it: this.Cs,
-            us: s2
-        });
-    }
-}
-class Nt extends Yl {
-    constructor() {
-        super(...arguments), this.zt = null, this.Gs = 0;
-    }
-    tt(t3) {
-        this.zt = t3;
-    }
-    Z(t3) {
-        if (null === this.zt || 0 === this.zt.Ln.length || null === this.zt.it)
-            return;
-        const {
-            horizontalPixelRatio: e2
-        } = t3;
-        this.Gs = function(t4, e3) {
-            if (t4 >= 2.5 && t4 <= 4)
-                return Math.floor(3 * e3);
-            const i3 = 1 - 0.2 * Math.atan(Math.max(4, t4) - 4) / (0.5 * Math.PI),
-                s3 = Math.floor(t4 * i3 * e3),
-                n2 = Math.floor(t4 * e3),
-                r2 = Math.min(s3, n2);
-            return Math.max(Math.floor(e3), r2);
-        }(this.zt.Ks, e2), this.Gs >= 2 && Math.floor(e2) % 2 != this.Gs % 2 && this.Gs--;
-        const i2 = this.zt.Ln;
-        this.zt.Se && this.xe(t3, i2, this.zt.it), this.zt.ui && this.ye(t3, i2, this.zt.it);
-        const s2 = this.ke(e2);
-        (!this.zt.ui || this.Gs > 2 * s2) && this.Ce(t3, i2, this.zt.it);
-    }
-    xe(t3, e2, i2) {
-        if (null === this.zt)
-            return;
-        const {
-            context: s2,
-            horizontalPixelRatio: n2,
-            verticalPixelRatio: r2
-        } = t3;
-        let o2 = "",
-            a2 = Math.min(Math.floor(n2), Math.floor(this.zt.Ks * n2));
-        a2 = Math.max(Math.floor(n2), Math.min(a2, this.Gs));
-        const l2 = Math.floor(0.5 * a2);
-        let h2 = null;
-        for (let t4 = i2.from; t4 < i2.to; t4++) {
-            const i3 = e2[t4];
-            i3.Te !== o2 && (s2.fillStyle = i3.Te, o2 = i3.Te);
-            const c2 = Math.round(Math.min(i3.re, i3.he) * r2),
-                u2 = Math.round(Math.max(i3.re, i3.he) * r2),
-                d2 = Math.round(i3.ne * r2),
-                f2 = Math.round(i3.se * r2);
-            let p2 = Math.round(n2 * i3.st) - l2;
-            const m2 = p2 + a2 - 1;
-            null !== h2 && (p2 = Math.max(h2 + 1, p2), p2 = Math.min(p2, m2));
-            const g2 = m2 - p2 + 1;
-            s2.fillRect(p2, d2, g2, c2 - d2), s2.fillRect(p2, u2 + 1, g2, f2 - u2), h2 = m2;
-        }
-    }
-    ke(t3) {
-        let e2 = Math.floor(1 * t3);
-        this.Gs <= 2 * e2 && (e2 = Math.floor(0.5 * (this.Gs - 1)));
-        const i2 = Math.max(Math.floor(t3), e2);
-        return this.Gs <= 2 * i2 ? Math.max(Math.floor(t3), Math.floor(1 * t3)) : i2;
-    }
-    ye(t3, e2, i2) {
-        if (null === this.zt)
-            return;
-        const {
-            context: s2,
-            horizontalPixelRatio: n2,
-            verticalPixelRatio: r2
-        } = t3;
-        let o2 = "";
-        const a2 = this.ke(n2);
-        let l2 = null;
-        for (let t4 = i2.from; t4 < i2.to; t4++) {
-            const i3 = e2[t4];
-            i3.Pe !== o2 && (s2.fillStyle = i3.Pe, o2 = i3.Pe);
-            let h2 = Math.round(i3.st * n2) - Math.floor(0.5 * this.Gs);
-            const c2 = h2 + this.Gs - 1,
-                u2 = Math.round(Math.min(i3.re, i3.he) * r2),
-                d2 = Math.round(Math.max(i3.re, i3.he) * r2);
-            if (null !== l2 && (h2 = Math.max(l2 + 1, h2), h2 = Math.min(h2, c2)), this.zt.Ks * n2 > 2 * a2)
-                Xl(s2, h2, u2, c2 - h2 + 1, d2 - u2 + 1, a2);
-            else {
-                const t5 = c2 - h2 + 1;
-                s2.fillRect(h2, u2, t5, d2 - u2 + 1);
-            }
-            l2 = c2;
-        }
-    }
-    Ce(t3, e2, i2) {
-        if (null === this.zt)
-            return;
-        const {
-            context: s2,
-            horizontalPixelRatio: n2,
-            verticalPixelRatio: r2
-        } = t3;
-        let o2 = "";
-        const a2 = this.ke(n2);
-        for (let t4 = i2.from; t4 < i2.to; t4++) {
-            const i3 = e2[t4];
-            let l2 = Math.round(Math.min(i3.re, i3.he) * r2),
-                h2 = Math.round(Math.max(i3.re, i3.he) * r2),
-                c2 = Math.round(i3.st * n2) - Math.floor(0.5 * this.Gs),
-                u2 = c2 + this.Gs - 1;
-            if (i3.ie !== o2) {
-                const t5 = i3.ie;
-                s2.fillStyle = t5, o2 = t5;
-            }
-            this.zt.ui && (c2 += a2, l2 += a2, u2 -= a2, h2 -= a2), l2 > h2 || s2.fillRect(c2, l2, u2 - c2 + 1, h2 - l2 + 1);
-        }
-    }
-}
-class Ft extends Dt {
-    constructor() {
-        super(...arguments), this.Bs = new Nt();
-    }
-    qs(t3, e2, i2) {
-        return Object.assign(Object.assign({}, this.ae(t3, e2, i2)), i2.Os(t3));
-    }
-    Ws() {
-        const t3 = this.Ts.F();
-        this.Bs.tt({
-            Ln: this.ks,
-            Ks: this.Ps.yt().Ks(),
-            Se: t3.wickVisible,
-            ui: t3.borderVisible,
-            it: this.Cs
-        });
-    }
-}
-class Wt extends Yl {
-    constructor() {
-        super(...arguments), this.zt = null, this.Re = [];
-    }
-    tt(t3) {
-        this.zt = t3, this.Re = [];
-    }
-    Z({
-        context: t3,
-        horizontalPixelRatio: e2,
-        verticalPixelRatio: i2
-    }) {
-        if (null === this.zt || 0 === this.zt.nt.length || null === this.zt.it)
-            return;
-        this.Re.length || this.De(e2);
-        const s2 = Math.max(1, Math.floor(i2)),
-            n2 = Math.round(this.zt.Be * i2) - Math.floor(s2 / 2),
-            r2 = n2 + s2;
-        for (let e3 = this.zt.it.from; e3 < this.zt.it.to; e3++) {
-            const o2 = this.zt.nt[e3],
-                a2 = this.Re[e3 - this.zt.it.from],
-                l2 = Math.round(o2.et * i2);
-            let h2, c2;
-            t3.fillStyle = o2.ie, l2 <= n2 ? (h2 = l2, c2 = r2) : (h2 = n2, c2 = l2 - Math.floor(s2 / 2) + s2), t3.fillRect(a2.Ms, h2, a2.ci - a2.Ms + 1, c2 - h2);
-        }
-    }
-    De(t3) {
-        if (null === this.zt || 0 === this.zt.nt.length || null === this.zt.it)
-            return void(this.Re = []);
-        const e2 = Math.ceil(this.zt.Ks * t3) <= 1 ? 0 : Math.max(1, Math.floor(t3)),
-            i2 = Math.round(this.zt.Ks * t3) - e2;
-        this.Re = new Array(this.zt.it.to - this.zt.it.from);
-        for (let e3 = this.zt.it.from; e3 < this.zt.it.to; e3++) {
-            const s3 = this.zt.nt[e3],
-                n2 = Math.round(s3.st * t3);
-            let r2, o2;
-            if (i2 % 2) {
-                const t4 = (i2 - 1) / 2;
-                r2 = n2 - t4, o2 = n2 + t4;
-            } else {
-                const t4 = i2 / 2;
-                r2 = n2 - t4, o2 = n2 + t4 - 1;
-            }
-            this.Re[e3 - this.zt.it.from] = {
-                Ms: r2,
-                ci: o2,
-                Ae: n2,
-                Oe: s3.st * t3,
-                _t: s3._t
-            };
-        }
-        for (let t4 = this.zt.it.from + 1; t4 < this.zt.it.to; t4++) {
-            const i3 = this.Re[t4 - this.zt.it.from],
-                s3 = this.Re[t4 - this.zt.it.from - 1];
-            i3._t === s3._t + 1 && i3.Ms - s3.ci !== e2 + 1 && (s3.Ae > s3.Oe ? s3.ci = i3.Ms - e2 - 1 : i3.Ms = s3.ci + e2 + 1);
-        }
-        let s2 = Math.ceil(this.zt.Ks * t3);
-        for (let t4 = this.zt.it.from; t4 < this.zt.it.to; t4++) {
-            const e3 = this.Re[t4 - this.zt.it.from];
-            e3.ci < e3.Ms && (e3.ci = e3.Ms);
-            const i3 = e3.ci - e3.Ms + 1;
-            s2 = Math.min(i3, s2);
-        }
-        if (e2 > 0 && s2 < 4)
-            for (let t4 = this.zt.it.from; t4 < this.zt.it.to; t4++) {
-                const e3 = this.Re[t4 - this.zt.it.from];
-                e3.ci - e3.Ms + 1 > s2 && (e3.Ae > e3.Oe ? e3.ci -= 1 : e3.Ms += 1);
-            }
-    }
-}
-class jt extends Tt {
-    constructor() {
-        super(...arguments), this.Bs = new Wt();
-    }
-    qs(t3, e2, i2) {
-        return Object.assign(Object.assign({}, this.Hs(t3, e2)), i2.Os(t3));
-    }
-    Ws() {
-        const t3 = {
-            nt: this.ks,
-            Ks: this.Ps.yt().Ks(),
-            it: this.Cs,
-            Be: this.Ts.Bt().Dt(this.Ts.F().base, kl(this.Ts.Tt()).At)
-        };
-        this.Bs.tt(t3);
-    }
-}
-class $t extends Tt {
-    constructor() {
-        super(...arguments), this.Bs = new wt();
-    }
-    qs(t3, e2, i2) {
-        return Object.assign(Object.assign({}, this.Hs(t3, e2)), i2.Os(t3));
-    }
-    Ws() {
-        const t3 = this.Ts.F(),
-            e2 = {
-                nt: this.ks,
-                Ft: t3.lineStyle,
-                cs: t3.lineType,
-                rt: t3.lineWidth,
-                it: this.Cs,
-                us: this.Ps.yt().Ks()
-            };
-        this.Bs.tt(e2);
-    }
-}
-const Eh = /[2-9]/g;
-class Ut {
-    constructor(t3 = 50) {
-        this.Le = 0, this.Ie = 1, this.Ee = 1, this.ze = {}, this.Ve = /* @__PURE__ */ new Map(), this.Ne = t3;
-    }
-    Fe() {
-        this.Le = 0, this.Ve.clear(), this.Ie = 1, this.Ee = 1, this.ze = {};
-    }
-    Si(t3, e2, i2) {
-        return this.We(t3, e2, i2).width;
-    }
-    Mi(t3, e2, i2) {
-        const s2 = this.We(t3, e2, i2);
-        return ((s2.actualBoundingBoxAscent || 0) - (s2.actualBoundingBoxDescent || 0)) / 2;
-    }
-    We(t3, e2, i2) {
-        const s2 = i2 || Eh,
-            n2 = String(e2).replace(s2, "0");
-        if (this.Ve.has(n2))
-            return xl(this.Ve.get(n2)).je;
-        if (this.Le === this.Ne) {
-            const t4 = this.ze[this.Ee];
-            delete this.ze[this.Ee], this.Ve.delete(t4), this.Ee++, this.Le--;
-        }
-        t3.save(), t3.textBaseline = "middle";
-        const r2 = t3.measureText(n2);
-        return t3.restore(), 0 === r2.width && e2.length || (this.Ve.set(n2, {
-            je: r2,
-            $e: this.Ie
-        }), this.ze[this.Ie] = n2, this.Le++, this.Ie++), r2;
-    }
-}
-class qt {
-    constructor(t3) {
-        this.He = null, this.S = null, this.Ue = "right", this.qe = t3;
-    }
-    Ye(t3, e2, i2) {
-        this.He = t3, this.S = e2, this.Ue = i2;
-    }
-    X(t3) {
-        null !== this.S && null !== this.He && this.He.X(t3, this.S, this.qe, this.Ue);
-    }
-}
-class Yt {
-    constructor(t3, e2, i2) {
-        this.Xe = t3, this.qe = new Ut(50), this.Ze = e2, this.N = i2, this.W = -1, this.jt = new qt(this.qe);
-    }
-    Mt() {
-        const t3 = this.N.Ke(this.Ze);
-        if (null === t3)
-            return null;
-        const e2 = t3.Ge(this.Ze) ? t3.Je() : this.Ze.Bt();
-        if (null === e2)
-            return null;
-        const i2 = t3.Qe(e2);
-        if ("overlay" === i2)
-            return null;
-        const s2 = this.N.tr();
-        return s2.T !== this.W && (this.W = s2.T, this.qe.Fe()), this.jt.Ye(this.Xe.Ii(), s2, i2), this.jt;
-    }
-}
-class Xt extends Yl {
-    constructor() {
-        super(...arguments), this.zt = null;
-    }
-    tt(t3) {
-        this.zt = t3;
-    }
-    ir(t3, e2) {
-        var i2;
-        if (!(null === (i2 = this.zt) || void 0 === i2 ? void 0 : i2.Ct))
-            return null;
-        const {
-            et: s2,
-            rt: n2,
-            nr: r2
-        } = this.zt;
-        return e2 >= s2 - n2 - 7 && e2 <= s2 + n2 + 7 ? {
-            sr: this.zt,
-            nr: r2
-        } : null;
-    }
-    Z({
-        context: t3,
-        bitmapSize: e2,
-        horizontalPixelRatio: i2,
-        verticalPixelRatio: s2
-    }) {
-        if (null === this.zt)
-            return;
-        if (false === this.zt.Ct)
-            return;
-        const n2 = Math.round(this.zt.et * s2);
-        n2 < 0 || n2 > e2.height || (t3.lineCap = "butt", t3.strokeStyle = this.zt.D, t3.lineWidth = Math.floor(this.zt.rt * i2), bl(t3, this.zt.Ft), _l(t3, n2, 0, e2.width));
-    }
-}
-class Zt {
-    constructor(t3) {
-        this.er = {
-            et: 0,
-            D: "rgba(0, 0, 0, 0)",
-            rt: 1,
-            Ft: 0,
-            Ct: false
-        }, this.rr = new Xt(), this.vt = true, this.Ts = t3, this.Ps = t3.Ut(), this.rr.tt(this.er);
-    }
-    gt() {
-        this.vt = true;
-    }
-    Mt() {
-        return this.Ts.Ct() ? (this.vt && (this.hr(), this.vt = false), this.rr) : null;
-    }
-}
-class Kt extends Zt {
-    constructor(t3) {
-        super(t3);
-    }
-    hr() {
-        this.er.Ct = false;
-        const t3 = this.Ts.Bt(),
-            e2 = t3.lr().lr;
-        if (2 !== e2 && 3 !== e2)
-            return;
-        const i2 = this.Ts.F();
-        if (!i2.baseLineVisible || !this.Ts.Ct())
-            return;
-        const s2 = this.Ts.Tt();
-        null !== s2 && (this.er.Ct = true, this.er.et = t3.Dt(s2.At, s2.At), this.er.D = i2.baseLineColor, this.er.rt = i2.baseLineWidth, this.er.Ft = i2.baseLineStyle);
-    }
-}
-class Gt extends Yl {
-    constructor() {
-        super(...arguments), this.zt = null;
-    }
-    tt(t3) {
-        this.zt = t3;
-    }
-    ar() {
-        return this.zt;
-    }
-    Z({
-        context: t3,
-        horizontalPixelRatio: e2,
-        verticalPixelRatio: i2
-    }) {
-        const s2 = this.zt;
-        if (null === s2)
-            return;
-        const n2 = Math.max(1, Math.floor(e2)),
-            r2 = n2 % 2 / 2,
-            o2 = Math.round(s2.Oe.x * e2) + r2,
-            a2 = s2.Oe.y * i2;
-        t3.fillStyle = s2._r, t3.beginPath();
-        const l2 = Math.max(2, 1.5 * s2.ur) * e2;
-        t3.arc(o2, a2, l2, 0, 2 * Math.PI, false), t3.fill(), t3.fillStyle = s2.cr, t3.beginPath(), t3.arc(o2, a2, s2.lt * e2, 0, 2 * Math.PI, false), t3.fill(), t3.lineWidth = n2, t3.strokeStyle = s2.dr, t3.beginPath(), t3.arc(o2, a2, s2.lt * e2 + n2 / 2, 0, 2 * Math.PI, false), t3.stroke();
-    }
-}
-const Ch = [{
-    pr: 0,
-    vr: 0.25,
-    mr: 4,
-    br: 10,
-    gr: 0.25,
-    wr: 0,
-    Mr: 0.4,
-    Sr: 0.8
-}, {
-    pr: 0.25,
-    vr: 0.525,
-    mr: 10,
-    br: 14,
-    gr: 0,
-    wr: 0,
-    Mr: 0.8,
-    Sr: 0
-}, {
-    pr: 0.525,
-    vr: 1,
-    mr: 14,
-    br: 14,
-    gr: 0,
-    wr: 0,
-    Mr: 0,
-    Sr: 0
-}];
-
-function Ih(t3, e2, i2, s2) {
-    return function(t4, e3) {
-        if ("transparent" === t4)
-            return t4;
-        const i3 = Al(t4),
-            s3 = i3[3];
-        return `rgba(${i3[0]}, ${i3[1]}, ${i3[2]}, ${e3 * s3})`;
-    }(t3, i2 + (s2 - i2) * e2);
-}
-
-function Mh(t3, e2) {
-    const i2 = t3 % 2600 / 2600;
-    let s2;
-    for (const t4 of Ch)
-        if (i2 >= t4.pr && i2 <= t4.vr) {
-            s2 = t4;
-            break;
-        }
-    wl(void 0 !== s2, "Last price animation internal logic error");
-    const n2 = (i2 - s2.pr) / (s2.vr - s2.pr);
-    return {
-        cr: Ih(e2, n2, s2.gr, s2.wr),
-        dr: Ih(e2, n2, s2.Mr, s2.Sr),
-        lt: (r2 = n2, o2 = s2.mr, a2 = s2.br, o2 + (a2 - o2) * r2)
-    };
-    var r2, o2, a2;
-}
-class ii {
-    constructor(t3) {
-        this.jt = new Gt(), this.vt = true, this.yr = true, this.kr = performance.now(), this.Cr = this.kr - 1, this.Tr = t3;
-    }
-    Pr() {
-        this.Cr = this.kr - 1, this.gt();
-    }
-    Rr() {
-        if (this.gt(), 2 === this.Tr.F().lastPriceAnimation) {
-            const t3 = performance.now(),
-                e2 = this.Cr - t3;
-            if (e2 > 0)
-                return void(e2 < 650 && (this.Cr += 2600));
-            this.kr = t3, this.Cr = t3 + 2600;
-        }
-    }
-    gt() {
-        this.vt = true;
-    }
-    Dr() {
-        this.yr = true;
-    }
-    Ct() {
-        return 0 !== this.Tr.F().lastPriceAnimation;
-    }
-    Br() {
-        switch (this.Tr.F().lastPriceAnimation) {
-            case 0:
-                return false;
-            case 1:
-                return true;
-            case 2:
-                return performance.now() <= this.Cr;
-        }
-    }
-    Mt() {
-        return this.vt ? (this.St(), this.vt = false, this.yr = false) : this.yr && (this.Ar(), this.yr = false), this.jt;
-    }
-    St() {
-        this.jt.tt(null);
-        const t3 = this.Tr.Ut().yt(),
-            e2 = t3.Vs(),
-            i2 = this.Tr.Tt();
-        if (null === e2 || null === i2)
-            return;
-        const s2 = this.Tr.Or(true);
-        if (s2.Lr || !e2.Ir(s2.Ys))
-            return;
-        const n2 = {
-                x: t3.Et(s2.Ys),
-                y: this.Tr.Bt().Dt(s2.ut, i2.At)
-            },
-            r2 = s2.D,
-            o2 = this.Tr.F().lineWidth,
-            a2 = Mh(this.Er(), r2);
-        this.jt.tt({
-            _r: r2,
-            ur: o2,
-            cr: a2.cr,
-            dr: a2.dr,
-            lt: a2.lt,
-            Oe: n2
-        });
-    }
-    Ar() {
-        const t3 = this.jt.ar();
-        if (null !== t3) {
-            const e2 = Mh(this.Er(), t3._r);
-            t3.cr = e2.cr, t3.dr = e2.dr, t3.lt = e2.lt;
-        }
-    }
-    Er() {
-        return this.Br() ? performance.now() - this.kr : 2599;
-    }
-}
-
-function Ph(t3, e2) {
-    return Sh(Math.min(Math.max(t3, 12), 30) * e2);
-}
-
-function Rh(t3, e2) {
-    switch (t3) {
-        case "arrowDown":
-        case "arrowUp":
-            return Ph(e2, 1);
-        case "circle":
-            return Ph(e2, 0.8);
-        case "square":
-            return Ph(e2, 0.7);
-    }
-}
-
-function Ah(t3) {
-    return function(t4) {
-        const e2 = Math.ceil(t4);
-        return e2 % 2 != 0 ? e2 - 1 : e2;
-    }(Ph(t3, 1));
-}
-
-function Dh(t3) {
-    return Math.max(Ph(t3, 0.1), 3);
-}
-
-function Lh(t3, e2, i2, s2, n2) {
-    const r2 = Rh("square", i2),
-        o2 = (r2 - 1) / 2,
-        a2 = t3 - o2,
-        l2 = e2 - o2;
-    return s2 >= a2 && s2 <= a2 + r2 && n2 >= l2 && n2 <= l2 + r2;
-}
-
-function Oh(t3, e2, i2, s2, n2) {
-    const r2 = (Rh("arrowUp", n2) - 1) / 2,
-        o2 = (Sh(n2 / 2) - 1) / 2;
-    e2.beginPath(), t3 ? (e2.moveTo(i2 - r2, s2), e2.lineTo(i2, s2 - r2), e2.lineTo(i2 + r2, s2), e2.lineTo(i2 + o2, s2), e2.lineTo(i2 + o2, s2 + r2), e2.lineTo(i2 - o2, s2 + r2), e2.lineTo(i2 - o2, s2)) : (e2.moveTo(i2 - r2, s2), e2.lineTo(i2, s2 + r2), e2.lineTo(i2 + r2, s2), e2.lineTo(i2 + o2, s2), e2.lineTo(i2 + o2, s2 - r2), e2.lineTo(i2 - o2, s2 - r2), e2.lineTo(i2 - o2, s2)), e2.fill();
-}
-class oi extends L {
-    constructor() {
-        super(...arguments), this.zt = null, this.qe = new Ut(), this.W = -1, this.j = "", this.zr = "";
-    }
-    tt(t3) {
-        this.zt = t3;
-    }
-    Ye(t3, e2) {
-        this.W === t3 && this.j === e2 || (this.W = t3, this.j = e2, this.zr = Hl(t3, e2), this.qe.Fe());
-    }
-    ir(t3, e2) {
-        if (null === this.zt || null === this.zt.it)
-            return null;
-        for (let i2 = this.zt.it.from; i2 < this.zt.it.to; i2++) {
-            const s2 = this.zt.nt[i2];
-            if (Nh(s2, t3, e2))
-                return {
-                    sr: s2.Vr,
-                    nr: s2.nr
-                };
-        }
-        return null;
-    }
-    Z({
-        context: t3
-    }, e2, i2) {
-        if (null !== this.zt && null !== this.zt.it) {
-            t3.textBaseline = "middle", t3.font = this.zr;
-            for (let e3 = this.zt.it.from; e3 < this.zt.it.to; e3++) {
-                const i3 = this.zt.nt[e3];
-                void 0 !== i3.Gt && (i3.Gt.$i = this.qe.Si(t3, i3.Gt.Nr), i3.Gt.It = this.W, i3.Gt.st = i3.st - i3.Gt.$i / 2), Fh(i3, t3);
-            }
-        }
-    }
-}
-
-function Fh(t3, e2) {
-    e2.fillStyle = t3.D, void 0 !== t3.Gt && function(t4, e3, i2, s2) {
-            t4.fillText(e3, i2, s2);
-        }(e2, t3.Gt.Nr, t3.Gt.st, t3.Gt.et),
-        function(t4, e3) {
-            if (0 !== t4.Ns) {
-                switch (t4.Fr) {
-                    case "arrowDown":
-                        return void Oh(false, e3, t4.st, t4.et, t4.Ns);
-                    case "arrowUp":
-                        return void Oh(true, e3, t4.st, t4.et, t4.Ns);
-                    case "circle":
-                        return void
-                        function(t5, e4, i2, s2) {
-                            const n2 = (Rh("circle", s2) - 1) / 2;
-                            t5.beginPath(), t5.arc(e4, i2, n2, 0, 2 * Math.PI, false), t5.fill();
-                        }(e3, t4.st, t4.et, t4.Ns);
-                    case "square":
-                        return void
-                        function(t5, e4, i2, s2) {
-                            const n2 = Rh("square", s2),
-                                r2 = (n2 - 1) / 2,
-                                o2 = e4 - r2,
-                                a2 = i2 - r2;
-                            t5.fillRect(o2, a2, n2, n2);
-                        }(e3, t4.st, t4.et, t4.Ns);
-                }
-                t4.Fr;
-            }
-        }(t3, e2);
-}
-
-function Nh(t3, e2, i2) {
-    return !(void 0 === t3.Gt || ! function(t4, e3, i3, s2, n2, r2) {
-        const o2 = s2 / 2;
-        return n2 >= t4 && n2 <= t4 + i3 && r2 >= e3 - o2 && r2 <= e3 + o2;
-    }(t3.Gt.st, t3.Gt.et, t3.Gt.$i, t3.Gt.It, e2, i2)) || function(t4, e3, i3) {
-        if (0 === t4.Ns)
-            return false;
-        switch (t4.Fr) {
-            case "arrowDown":
-            case "arrowUp":
-                return function(t5, e4, i4, s2, n2, r2) {
-                    return Lh(e4, i4, s2, n2, r2);
-                }(0, t4.st, t4.et, t4.Ns, e3, i3);
-            case "circle":
-                return function(t5, e4, i4, s2, n2) {
-                    const r2 = 2 + Rh("circle", i4) / 2,
-                        o2 = t5 - s2,
-                        a2 = e4 - n2;
-                    return Math.sqrt(o2 * o2 + a2 * a2) <= r2;
-                }(t4.st, t4.et, t4.Ns, e3, i3);
-            case "square":
-                return Lh(t4.st, t4.et, t4.Ns, e3, i3);
-        }
-    }(t3, e2, i2);
-}
-
-function $h(t3, e2, i2, s2, n2, r2, o2, a2, l2) {
-    const h2 = Fl(i2) ? i2 : i2.ce,
-        c2 = Fl(i2) ? i2 : i2._e,
-        u2 = Fl(i2) ? i2 : i2.ue,
-        d2 = Fl(e2.size) ? Math.max(e2.size, 0) : 1,
-        f2 = Ah(a2.Ks()) * d2,
-        p2 = f2 / 2;
-    switch (t3.Ns = f2, e2.position) {
-        case "inBar":
-            return t3.et = o2.Dt(h2, l2), void(void 0 !== t3.Gt && (t3.Gt.et = t3.et + p2 + r2 + 0.6 * n2));
-        case "aboveBar":
-            return t3.et = o2.Dt(c2, l2) - p2 - s2.Wr, void 0 !== t3.Gt && (t3.Gt.et = t3.et - p2 - 0.6 * n2, s2.Wr += 1.2 * n2), void(s2.Wr += f2 + r2);
-        case "belowBar":
-            return t3.et = o2.Dt(u2, l2) + p2 + s2.jr, void 0 !== t3.Gt && (t3.Gt.et = t3.et + p2 + r2 + 0.6 * n2, s2.jr += 1.2 * n2), void(s2.jr += f2 + r2);
-    }
-    e2.position;
-}
-class di {
-    constructor(t3, e2) {
-        this.vt = true, this.$r = true, this.Hr = true, this.Ur = null, this.jt = new oi(), this.Tr = t3, this.Hi = e2, this.zt = {
-            nt: [],
-            it: null
-        };
-    }
-    gt(t3) {
-        this.vt = true, this.Hr = true, "data" === t3 && (this.$r = true);
-    }
-    Mt(t3) {
-        if (!this.Tr.Ct())
-            return null;
-        this.vt && this.qr();
-        const e2 = this.Hi.F().layout;
-        return this.jt.Ye(e2.fontSize, e2.fontFamily), this.jt.tt(this.zt), this.jt;
-    }
-    Yr() {
-        if (this.Hr) {
-            if (this.Tr.Xr().length > 0) {
-                const t3 = this.Hi.yt().Ks(),
-                    e2 = Dh(t3),
-                    i2 = 1.5 * Ah(t3) + 2 * e2;
-                this.Ur = {
-                    above: i2,
-                    below: i2
-                };
-            } else
-                this.Ur = null;
-            this.Hr = false;
-        }
-        return this.Ur;
-    }
-    qr() {
-        const t3 = this.Tr.Bt(),
-            e2 = this.Hi.yt(),
-            i2 = this.Tr.Xr();
-        this.$r && (this.zt.nt = i2.map((t4) => ({
-            _t: t4.time,
-            st: 0,
-            et: 0,
-            Ns: 0,
-            Fr: t4.shape,
-            D: t4.color,
-            Vr: t4.internalId,
-            nr: t4.id,
-            Gt: void 0
-        })), this.$r = false);
-        const s2 = this.Hi.F().layout;
-        this.zt.it = null;
-        const n2 = e2.Vs();
-        if (null === n2)
-            return;
-        const r2 = this.Tr.Tt();
-        if (null === r2)
-            return;
-        if (0 === this.zt.nt.length)
-            return;
-        let o2 = NaN;
-        const a2 = Dh(e2.Ks()),
-            l2 = {
-                Wr: a2,
-                jr: a2
-            };
-        this.zt.it = wh(this.zt.nt, n2, true);
-        for (let n3 = this.zt.it.from; n3 < this.zt.it.to; n3++) {
-            const h2 = i2[n3];
-            h2.time !== o2 && (l2.Wr = a2, l2.jr = a2, o2 = h2.time);
-            const c2 = this.zt.nt[n3];
-            c2.st = e2.Et(h2.time), void 0 !== h2.text && h2.text.length > 0 && (c2.Gt = {
-                Nr: h2.text,
-                st: 0,
-                et: 0,
-                $i: 0,
-                It: 0
-            });
-            const u2 = this.Tr.Zr(h2.time);
-            null !== u2 && $h(c2, h2, u2, l2, s2.fontSize, a2, t3, e2, r2.At);
-        }
-        this.vt = false;
-    }
-}
-class fi extends Zt {
-    constructor(t3) {
-        super(t3);
-    }
-    hr() {
-        const t3 = this.er;
-        t3.Ct = false;
-        const e2 = this.Ts.F();
-        if (!e2.priceLineVisible || !this.Ts.Ct())
-            return;
-        const i2 = this.Ts.Or(0 === e2.priceLineSource);
-        i2.Lr || (t3.Ct = true, t3.et = i2.yi, t3.D = this.Ts.Kr(i2.D), t3.rt = e2.priceLineWidth, t3.Ft = e2.priceLineStyle);
-    }
-}
-class pi extends nh {
-    constructor(t3) {
-        super(), this.$t = t3;
-    }
-    Ei(t3, e2, i2) {
-        t3.Ct = false, e2.Ct = false;
-        const s2 = this.$t;
-        if (!s2.Ct())
-            return;
-        const n2 = s2.F(),
-            r2 = n2.lastValueVisible,
-            o2 = "" !== s2.Gr(),
-            a2 = 0 === n2.seriesLastValueMode,
-            l2 = s2.Or(false);
-        if (l2.Lr)
-            return;
-        r2 && (t3.Gt = this.Jr(l2, r2, a2), t3.Ct = 0 !== t3.Gt.length), (o2 || a2) && (e2.Gt = this.Qr(l2, r2, o2, a2), e2.Ct = e2.Gt.length > 0);
-        const h2 = s2.Kr(l2.D),
-            c2 = Dl(h2);
-        i2.t = c2.t, i2.yi = l2.yi, e2.Ot = s2.Ut().Lt(l2.yi / s2.Bt().It()), t3.Ot = h2, t3.D = c2.i, e2.D = c2.i;
-    }
-    Qr(t3, e2, i2, s2) {
-        let n2 = "";
-        const r2 = this.$t.Gr();
-        return i2 && 0 !== r2.length && (n2 += `${r2} `), e2 && s2 && (n2 += this.$t.Bt().th() ? t3.ih : t3.nh), n2.trim();
-    }
-    Jr(t3, e2, i2) {
-        return e2 ? i2 ? this.$t.Bt().th() ? t3.nh : t3.ih : t3.Gt : "";
-    }
-}
-class vi {
-    constructor(t3, e2) {
-        this.sh = t3, this.eh = e2;
-    }
-    rh(t3) {
-        return null !== t3 && this.sh === t3.sh && this.eh === t3.eh;
-    }
-    hh() {
-        return new vi(this.sh, this.eh);
-    }
-    lh() {
-        return this.sh;
-    }
-    ah() {
-        return this.eh;
-    }
-    oh() {
-        return this.eh - this.sh;
-    }
-    Ni() {
-        return this.eh === this.sh || Number.isNaN(this.eh) || Number.isNaN(this.sh);
-    }
-    Qn(t3) {
-        return null === t3 ? this : new vi(Math.min(this.lh(), t3.lh()), Math.max(this.ah(), t3.ah()));
-    }
-    _h(t3) {
-        if (!Fl(t3))
-            return;
-        if (0 == this.eh - this.sh)
-            return;
-        const e2 = 0.5 * (this.eh + this.sh);
-        let i2 = this.eh - e2,
-            s2 = this.sh - e2;
-        i2 *= t3, s2 *= t3, this.eh = e2 + i2, this.sh = e2 + s2;
-    }
-    uh(t3) {
-        Fl(t3) && (this.eh += t3, this.sh += t3);
-    }
-    dh() {
-        return {
-            minValue: this.sh,
-            maxValue: this.eh
-        };
-    }
-    static fh(t3) {
-        return null === t3 ? null : new vi(t3.minValue, t3.maxValue);
-    }
-}
-class mi {
-    constructor(t3, e2) {
-        this.ph = t3, this.mh = e2 || null;
-    }
-    bh() {
-        return this.ph;
-    }
-    gh() {
-        return this.mh;
-    }
-    dh() {
-        return null === this.ph ? null : {
-            priceRange: this.ph.dh(),
-            margins: this.mh || void 0
-        };
-    }
-    static fh(t3) {
-        return null === t3 ? null : new mi(vi.fh(t3.priceRange), t3.margins);
-    }
-}
-class bi extends Zt {
-    constructor(t3, e2) {
-        super(t3), this.wh = e2;
-    }
-    hr() {
-        const t3 = this.er;
-        t3.Ct = false;
-        const e2 = this.wh.F();
-        if (!this.Ts.Ct() || !e2.lineVisible)
-            return;
-        const i2 = this.wh.Mh();
-        null !== i2 && (t3.Ct = true, t3.et = i2, t3.D = e2.color, t3.rt = e2.lineWidth, t3.Ft = e2.lineStyle, t3.nr = this.wh.F().id);
-    }
-}
-class gi extends nh {
-    constructor(t3, e2) {
-        super(), this.Tr = t3, this.wh = e2;
-    }
-    Ei(t3, e2, i2) {
-        t3.Ct = false, e2.Ct = false;
-        const s2 = this.wh.F(),
-            n2 = s2.axisLabelVisible,
-            r2 = "" !== s2.title,
-            o2 = this.Tr;
-        if (!n2 || !o2.Ct())
-            return;
-        const a2 = this.wh.Mh();
-        if (null === a2)
-            return;
-        r2 && (e2.Gt = s2.title, e2.Ct = true), e2.Ot = o2.Ut().Lt(a2 / o2.Bt().It()), t3.Gt = this.Sh(s2.price), t3.Ct = true;
-        const l2 = Dl(s2.axisLabelColor || s2.color);
-        i2.t = l2.t;
-        const h2 = s2.axisLabelTextColor || l2.i;
-        t3.D = h2, e2.D = h2, i2.yi = a2;
-    }
-    Sh(t3) {
-        const e2 = this.Tr.Tt();
-        return null === e2 ? "" : this.Tr.Bt().Fi(t3, e2.At);
-    }
-}
-class wi {
-    constructor(t3, e2) {
-        this.Tr = t3, this.un = e2, this.xh = new bi(t3, this), this.Xe = new gi(t3, this), this.yh = new Yt(this.Xe, t3, t3.Ut());
-    }
-    kh(t3) {
-        Ol(this.un, t3), this.gt(), this.Tr.Ut().Ch();
-    }
-    F() {
-        return this.un;
-    }
-    Th() {
-        return this.xh;
-    }
-    Ph() {
-        return this.yh;
-    }
-    Rh() {
-        return this.Xe;
-    }
-    gt() {
-        this.xh.gt(), this.Xe.gt();
-    }
-    Mh() {
-        const t3 = this.Tr,
-            e2 = t3.Bt();
-        if (t3.Ut().yt().Ni() || e2.Ni())
-            return null;
-        const i2 = t3.Tt();
-        return null === i2 ? null : e2.Dt(this.un.price, i2.At);
-    }
-}
-class Mi extends tt {
-    constructor(t3) {
-        super(), this.Hi = t3;
-    }
-    Ut() {
-        return this.Hi;
-    }
-}
-const Vh = {
-    Bar: (t3, e2, i2, s2) => {
-        var n2;
-        const r2 = e2.upColor,
-            o2 = e2.downColor,
-            a2 = kl(t3(i2, s2)),
-            l2 = Tl(a2.At[0]) <= Tl(a2.At[3]);
-        return {
-            ie: null !== (n2 = a2.D) && void 0 !== n2 ? n2 : l2 ? r2 : o2
-        };
-    },
-    Candlestick: (t3, e2, i2, s2) => {
-        var n2, r2, o2;
-        const a2 = e2.upColor,
-            l2 = e2.downColor,
-            h2 = e2.borderUpColor,
-            c2 = e2.borderDownColor,
-            u2 = e2.wickUpColor,
-            d2 = e2.wickDownColor,
-            f2 = kl(t3(i2, s2)),
-            p2 = Tl(f2.At[0]) <= Tl(f2.At[3]);
-        return {
-            ie: null !== (n2 = f2.D) && void 0 !== n2 ? n2 : p2 ? a2 : l2,
-            Pe: null !== (r2 = f2.Ot) && void 0 !== r2 ? r2 : p2 ? h2 : c2,
-            Te: null !== (o2 = f2.Dh) && void 0 !== o2 ? o2 : p2 ? u2 : d2
-        };
-    },
-    Area: (t3, e2, i2, s2) => {
-        var n2, r2, o2, a2;
-        const l2 = kl(t3(i2, s2));
-        return {
-            ie: null !== (n2 = l2.ot) && void 0 !== n2 ? n2 : e2.lineColor,
-            ot: null !== (r2 = l2.ot) && void 0 !== r2 ? r2 : e2.lineColor,
-            bs: null !== (o2 = l2.bs) && void 0 !== o2 ? o2 : e2.topColor,
-            gs: null !== (a2 = l2.gs) && void 0 !== a2 ? a2 : e2.bottomColor
-        };
-    },
-    Baseline: (t3, e2, i2, s2) => {
-        var n2, r2, o2, a2, l2, h2;
-        const c2 = kl(t3(i2, s2));
-        return {
-            ie: c2.At[3] >= e2.baseValue.price ? e2.topLineColor : e2.bottomLineColor,
-            be: null !== (n2 = c2.be) && void 0 !== n2 ? n2 : e2.topLineColor,
-            ge: null !== (r2 = c2.ge) && void 0 !== r2 ? r2 : e2.bottomLineColor,
-            de: null !== (o2 = c2.de) && void 0 !== o2 ? o2 : e2.topFillColor1,
-            fe: null !== (a2 = c2.fe) && void 0 !== a2 ? a2 : e2.topFillColor2,
-            pe: null !== (l2 = c2.pe) && void 0 !== l2 ? l2 : e2.bottomFillColor1,
-            ve: null !== (h2 = c2.ve) && void 0 !== h2 ? h2 : e2.bottomFillColor2
-        };
-    },
-    Line: (t3, e2, i2, s2) => {
-        var n2, r2;
-        const o2 = kl(t3(i2, s2));
-        return {
-            ie: null !== (n2 = o2.D) && void 0 !== n2 ? n2 : e2.color,
-            ot: null !== (r2 = o2.D) && void 0 !== r2 ? r2 : e2.color
-        };
-    },
-    Histogram: (t3, e2, i2, s2) => {
-        var n2;
-        return {
-            ie: null !== (n2 = kl(t3(i2, s2)).D) && void 0 !== n2 ? n2 : e2.color
-        };
-    }
-};
-class xi {
-    constructor(t3) {
-        this.Bh = (t4, e2) => void 0 !== e2 ? e2.At : this.Tr.Ln().Ah(t4), this.Tr = t3, this.Oh = Vh[t3.Lh()];
-    }
-    Os(t3, e2) {
-        return this.Oh(this.Bh, this.Tr.F(), t3, e2);
-    }
-}
-var zh;
-! function(t3) {
-    t3[t3.NearestLeft = -1] = "NearestLeft", t3[t3.None = 0] = "None", t3[t3.NearestRight = 1] = "NearestRight";
-}(zh || (zh = {}));
-const Bh = 30;
-class Ci {
-    constructor() {
-        this.Ih = [], this.Eh = /* @__PURE__ */ new Map(), this.zh = /* @__PURE__ */ new Map();
-    }
-    Vh() {
-        return this.Ns() > 0 ? this.Ih[this.Ih.length - 1] : null;
-    }
-    Nh() {
-        return this.Ns() > 0 ? this.Fh(0) : null;
-    }
-    On() {
-        return this.Ns() > 0 ? this.Fh(this.Ih.length - 1) : null;
-    }
-    Ns() {
-        return this.Ih.length;
-    }
-    Ni() {
-        return 0 === this.Ns();
-    }
-    Ir(t3) {
-        return null !== this.Wh(t3, 0);
-    }
-    Ah(t3) {
-        return this.jh(t3);
-    }
-    jh(t3, e2 = 0) {
-        const i2 = this.Wh(t3, e2);
-        return null === i2 ? null : Object.assign(Object.assign({}, this.$h(i2)), {
-            Ys: this.Fh(i2)
-        });
-    }
-    Us() {
-        return this.Ih;
-    }
-    Hh(t3, e2, i2) {
-        if (this.Ni())
-            return null;
-        let s2 = null;
-        for (const n2 of i2)
-            s2 = Uh(s2, this.Uh(t3, e2, n2));
-        return s2;
-    }
-    tt(t3) {
-        this.zh.clear(), this.Eh.clear(), this.Ih = t3;
-    }
-    Fh(t3) {
-        return this.Ih[t3].Ys;
-    }
-    $h(t3) {
-        return this.Ih[t3];
-    }
-    Wh(t3, e2) {
-        const i2 = this.qh(t3);
-        if (null === i2 && 0 !== e2)
-            switch (e2) {
-                case -1:
-                    return this.Yh(t3);
-                case 1:
-                    return this.Xh(t3);
-                default:
-                    throw new TypeError("Unknown search mode");
-            }
-        return i2;
-    }
-    Yh(t3) {
-        let e2 = this.Zh(t3);
-        return e2 > 0 && (e2 -= 1), e2 !== this.Ih.length && this.Fh(e2) < t3 ? e2 : null;
-    }
-    Xh(t3) {
-        const e2 = this.Kh(t3);
-        return e2 !== this.Ih.length && t3 < this.Fh(e2) ? e2 : null;
-    }
-    qh(t3) {
-        const e2 = this.Zh(t3);
-        return e2 === this.Ih.length || t3 < this.Ih[e2].Ys ? null : e2;
-    }
-    Zh(t3) {
-        return yh(this.Ih, t3, (t4, e2) => t4.Ys < e2);
-    }
-    Kh(t3) {
-        return vh(this.Ih, t3, (t4, e2) => e2.Ys > t4);
-    }
-    Gh(t3, e2, i2) {
-        let s2 = null;
-        for (let n2 = t3; n2 < e2; n2++) {
-            const t4 = this.Ih[n2].At[i2];
-            Number.isNaN(t4) || (null === s2 ? s2 = {
-                Jh: t4,
-                Qh: t4
-            } : (t4 < s2.Jh && (s2.Jh = t4), t4 > s2.Qh && (s2.Qh = t4)));
-        }
-        return s2;
-    }
-    Uh(t3, e2, i2) {
-        if (this.Ni())
-            return null;
-        let s2 = null;
-        const n2 = kl(this.Nh()),
-            r2 = kl(this.On()),
-            o2 = Math.max(t3, n2),
-            a2 = Math.min(e2, r2),
-            l2 = Math.ceil(o2 / Bh) * Bh,
-            h2 = Math.max(l2, Math.floor(a2 / Bh) * Bh);
-        {
-            const t4 = this.Zh(o2),
-                n3 = this.Kh(Math.min(a2, l2, e2));
-            s2 = Uh(s2, this.Gh(t4, n3, i2));
-        }
-        let c2 = this.Eh.get(i2);
-        void 0 === c2 && (c2 = /* @__PURE__ */ new Map(), this.Eh.set(i2, c2));
-        for (let t4 = Math.max(l2 + 1, o2); t4 < h2; t4 += Bh) {
-            const e3 = Math.floor(t4 / Bh);
-            let n3 = c2.get(e3);
-            if (void 0 === n3) {
-                const t5 = this.Zh(e3 * Bh),
-                    s3 = this.Kh((e3 + 1) * Bh - 1);
-                n3 = this.Gh(t5, s3, i2), c2.set(e3, n3);
-            }
-            s2 = Uh(s2, n3);
-        } {
-            const t4 = this.Zh(h2),
-                e3 = this.Kh(a2);
-            s2 = Uh(s2, this.Gh(t4, e3, i2));
-        }
-        return s2;
-    }
-}
-
-function Uh(t3, e2) {
-    return null === t3 ? e2 : null === e2 ? t3 : {
-        Jh: Math.min(t3.Jh, e2.Jh),
-        Qh: Math.max(t3.Qh, e2.Qh)
-    };
-}
-class Pi extends Mi {
-    constructor(t3, e2, i2) {
-        super(t3), this.zt = new Ci(), this.xh = new fi(this), this.tl = [], this.il = new Kt(this), this.nl = null, this.sl = null, this.el = [], this.rl = [], this.hl = null, this.un = e2, this.ll = i2;
-        const s2 = new pi(this);
-        this.rn = [s2], this.yh = new Yt(s2, this, t3), "Area" !== i2 && "Line" !== i2 && "Baseline" !== i2 || (this.nl = new ii(this)), this.al(), this.ol();
-    }
-    M() {
-        null !== this.hl && clearTimeout(this.hl);
-    }
-    Kr(t3) {
-        return this.un.priceLineColor || t3;
-    }
-    Or(t3) {
-        const e2 = {
-                Lr: true
-            },
-            i2 = this.Bt();
-        if (this.Ut().yt().Ni() || i2.Ni() || this.zt.Ni())
-            return e2;
-        const s2 = this.Ut().yt().Vs(),
-            n2 = this.Tt();
-        if (null === s2 || null === n2)
-            return e2;
-        let r2, o2;
-        if (t3) {
-            const t4 = this.zt.Vh();
-            if (null === t4)
-                return e2;
-            r2 = t4, o2 = t4.Ys;
-        } else {
-            const t4 = this.zt.jh(s2.ci(), -1);
-            if (null === t4)
-                return e2;
-            if (r2 = this.zt.Ah(t4.Ys), null === r2)
-                return e2;
-            o2 = t4.Ys;
-        }
-        const a2 = r2.At[3],
-            l2 = this.Ls().Os(o2, {
-                At: r2
-            }),
-            h2 = i2.Dt(a2, n2.At);
-        return {
-            Lr: false,
-            ut: a2,
-            Gt: i2.Fi(a2, n2.At),
-            ih: i2._l(a2),
-            nh: i2.ul(a2, n2.At),
-            D: l2.ie,
-            yi: h2,
-            Ys: o2
-        };
-    }
-    Ls() {
-        return null !== this.sl || (this.sl = new xi(this)), this.sl;
-    }
-    F() {
-        return this.un;
-    }
-    kh(t3) {
-        const e2 = t3.priceScaleId;
-        void 0 !== e2 && e2 !== this.un.priceScaleId && this.Ut().cl(this, e2), Ol(this.un, t3), void 0 !== t3.priceFormat && (this.al(), this.Ut().dl()), this.Ut().fl(this), this.Ut().pl(), this.bn.gt("options");
-    }
-    tt(t3, e2) {
-        this.zt.tt(t3), this.vl(), this.bn.gt("data"), this.cn.gt("data"), null !== this.nl && (e2 && e2.ml ? this.nl.Rr() : 0 === t3.length && this.nl.Pr());
-        const i2 = this.Ut().Ke(this);
-        this.Ut().bl(i2), this.Ut().fl(this), this.Ut().pl(), this.Ut().Ch();
-    }
-    gl(t3) {
-        this.el = t3, this.vl();
-        const e2 = this.Ut().Ke(this);
-        this.cn.gt("data"), this.Ut().bl(e2), this.Ut().fl(this), this.Ut().pl(), this.Ut().Ch();
-    }
-    wl() {
-        return this.el;
-    }
-    Xr() {
-        return this.rl;
-    }
-    Ml(t3) {
-        const e2 = new wi(this, t3);
-        return this.tl.push(e2), this.Ut().fl(this), e2;
-    }
-    Sl(t3) {
-        const e2 = this.tl.indexOf(t3); -
-        1 !== e2 && this.tl.splice(e2, 1), this.Ut().fl(this);
-    }
-    Lh() {
-        return this.ll;
-    }
-    Tt() {
-        const t3 = this.xl();
-        return null === t3 ? null : {
-            At: t3.At[3],
-            yl: t3._t
-        };
-    }
-    xl() {
-        const t3 = this.Ut().yt().Vs();
-        if (null === t3)
-            return null;
-        const e2 = t3.Ms();
-        return this.zt.jh(e2, 1);
-    }
-    Ln() {
-        return this.zt;
-    }
-    Zr(t3) {
-        const e2 = this.zt.Ah(t3);
-        return null === e2 ? null : "Bar" === this.ll || "Candlestick" === this.ll ? {
-            oe: e2.At[0],
-            _e: e2.At[1],
-            ue: e2.At[2],
-            ce: e2.At[3]
-        } : e2.At[3];
-    }
-    kl(t3) {
-        const e2 = this.nl;
-        return null !== e2 && e2.Ct() ? (null === this.hl && e2.Br() && (this.hl = setTimeout(() => {
-            this.hl = null, this.Ut().Cl();
-        }, 0)), e2.Dr(), [e2]) : [];
-    }
-    Tn() {
-        const t3 = [];
-        this.Tl() || t3.push(this.il), t3.push(this.bn, this.xh, this.cn);
-        const e2 = this.tl.map((t4) => t4.Th());
-        return t3.push(...e2), t3;
-    }
-    Ji(t3) {
-        return [this.yh, ...this.tl.map((t4) => t4.Ph())];
-    }
-    Pn(t3, e2) {
-        if (e2 !== this.Yi && !this.Tl())
-            return [];
-        const i2 = [...this.rn];
-        for (const t4 of this.tl)
-            i2.push(t4.Rh());
-        return i2;
-    }
-    Pl(t3, e2) {
-        if (void 0 !== this.un.autoscaleInfoProvider) {
-            const i2 = this.un.autoscaleInfoProvider(() => {
-                const i3 = this.Rl(t3, e2);
-                return null === i3 ? null : i3.dh();
-            });
-            return mi.fh(i2);
-        }
-        return this.Rl(t3, e2);
-    }
-    Dl() {
-        return this.un.priceFormat.minMove;
-    }
-    Bl() {
-        return this.Al;
-    }
-    Dn() {
-        var t3;
-        this.bn.gt(), this.cn.gt();
-        for (const t4 of this.rn)
-            t4.gt();
-        for (const t4 of this.tl)
-            t4.gt();
-        this.xh.gt(), this.il.gt(), null === (t3 = this.nl) || void 0 === t3 || t3.gt();
-    }
-    Bt() {
-        return kl(super.Bt());
-    }
-    kt(t3) {
-        if ("Line" !== this.ll && "Area" !== this.ll && "Baseline" !== this.ll || !this.un.crosshairMarkerVisible)
-            return null;
-        const e2 = this.zt.Ah(t3);
-        return null === e2 ? null : {
-            ut: e2.At[3],
-            lt: this.Ol(),
-            Ot: this.Ll(),
-            Rt: this.Il(),
-            Pt: this.El(t3)
-        };
-    }
-    Gr() {
-        return this.un.title;
-    }
-    Ct() {
-        return this.un.visible;
-    }
-    Tl() {
-        return !lh(this.Bt().zl());
-    }
-    Rl(t3, e2) {
-        if (!Nl(t3) || !Nl(e2) || this.zt.Ni())
-            return null;
-        const i2 = "Line" === this.ll || "Area" === this.ll || "Baseline" === this.ll || "Histogram" === this.ll ? [3] : [2, 1],
-            s2 = this.zt.Hh(t3, e2, i2);
-        let n2 = null !== s2 ? new vi(s2.Jh, s2.Qh) : null;
-        if ("Histogram" === this.Lh()) {
-            const t4 = this.un.base,
-                e3 = new vi(t4, t4);
-            n2 = null !== n2 ? n2.Qn(e3) : e3;
-        }
-        return new mi(n2, this.cn.Yr());
-    }
-    Ol() {
-        switch (this.ll) {
-            case "Line":
-            case "Area":
-            case "Baseline":
-                return this.un.crosshairMarkerRadius;
-        }
-        return 0;
-    }
-    Ll() {
-        switch (this.ll) {
-            case "Line":
-            case "Area":
-            case "Baseline": {
-                const t3 = this.un.crosshairMarkerBorderColor;
-                if (0 !== t3.length)
-                    return t3;
-            }
-        }
-        return null;
-    }
-    Il() {
-        switch (this.ll) {
-            case "Line":
-            case "Area":
-            case "Baseline":
-                return this.un.crosshairMarkerBorderWidth;
-        }
-        return 0;
-    }
-    El(t3) {
-        switch (this.ll) {
-            case "Line":
-            case "Area":
-            case "Baseline": {
-                const t4 = this.un.crosshairMarkerBackgroundColor;
-                if (0 !== t4.length)
-                    return t4;
-            }
-        }
-        return this.Ls().Os(t3).ie;
-    }
-    al() {
-        switch (this.un.priceFormat.type) {
-            case "custom":
-                this.Al = {
-                    format: this.un.priceFormat.formatter
-                };
-                break;
-            case "volume":
-                this.Al = new ot(this.un.priceFormat.precision);
-                break;
-            case "percent":
-                this.Al = new at(this.un.priceFormat.precision);
-                break;
-            default: {
-                const t3 = Math.pow(10, this.un.priceFormat.precision);
-                this.Al = new lt(t3, this.un.priceFormat.minMove * t3);
-            }
-        }
-        null !== this.Yi && this.Yi.Vl();
-    }
-    vl() {
-        const t3 = this.Ut().yt();
-        if (!t3.Nl() || this.zt.Ni())
-            return void(this.rl = []);
-        const e2 = kl(this.zt.Nh());
-        this.rl = this.el.map((i2, s2) => {
-            const n2 = kl(t3.Fl(i2.time, true)),
-                r2 = n2 < e2 ? 1 : -1;
-            return {
-                time: kl(this.zt.jh(n2, r2)).Ys,
-                position: i2.position,
-                shape: i2.shape,
-                color: i2.color,
-                id: i2.id,
-                internalId: s2,
-                text: i2.text,
-                size: i2.size
-            };
-        });
-    }
-    ol() {
-        switch (this.cn = new di(this, this.Ut()), this.ll) {
-            case "Bar":
-                this.bn = new Bt(this, this.Ut());
-                break;
-            case "Candlestick":
-                this.bn = new Ft(this, this.Ut());
-                break;
-            case "Line":
-                this.bn = new $t(this, this.Ut());
-                break;
-            case "Area":
-                this.bn = new Pt(this, this.Ut());
-                break;
-            case "Baseline":
-                this.bn = new Vt(this, this.Ut());
-                break;
-            case "Histogram":
-                this.bn = new jt(this, this.Ut());
-                break;
-            default:
-                throw Error("Unknown chart style assigned: " + this.ll);
-        }
-    }
-}
-class Ri {
-    constructor(t3) {
-        this.un = t3;
-    }
-    Wl(t3, e2, i2) {
-        let s2 = t3;
-        if (0 === this.un.mode)
-            return s2;
-        const n2 = i2.fn(),
-            r2 = n2.Tt();
-        if (null === r2)
-            return s2;
-        const o2 = n2.Dt(t3, r2),
-            a2 = i2.jl().filter((t4) => t4 instanceof Pi).reduce((t4, s3) => {
-                if (i2.Ge(s3) || !s3.Ct())
-                    return t4;
-                const n3 = s3.Bt(),
-                    r3 = s3.Ln();
-                if (n3.Ni() || !r3.Ir(e2))
-                    return t4;
-                const o3 = r3.Ah(e2);
-                if (null === o3)
-                    return t4;
-                const a3 = Tl(s3.Tt());
-                return t4.concat([n3.Dt(o3.At[3], a3.At)]);
-            }, []);
-        if (0 === a2.length)
-            return s2;
-        a2.sort((t4, e3) => Math.abs(t4 - o2) - Math.abs(e3 - o2));
-        const l2 = a2[0];
-        return s2 = n2.pn(l2, r2), s2;
-    }
-}
-class Di extends Yl {
-    constructor() {
-        super(...arguments), this.zt = null;
-    }
-    tt(t3) {
-        this.zt = t3;
-    }
-    Z({
-        context: t3,
-        bitmapSize: e2,
-        horizontalPixelRatio: i2,
-        verticalPixelRatio: s2
-    }) {
-        if (null === this.zt)
-            return;
-        const n2 = Math.max(1, Math.floor(i2));
-        t3.lineWidth = n2,
-            function(t4, e3) {
-                t4.save(), t4.lineWidth % 2 && t4.translate(0.5, 0.5), e3(), t4.restore();
-            }(t3, () => {
-                const r2 = kl(this.zt);
-                if (r2.$l) {
-                    t3.strokeStyle = r2.Hl, bl(t3, r2.Ul), t3.beginPath();
-                    for (const s3 of r2.ql) {
-                        const r3 = Math.round(s3.Yl * i2);
-                        t3.moveTo(r3, -n2), t3.lineTo(r3, e2.height + n2);
-                    }
-                    t3.stroke();
-                }
-                if (r2.Xl) {
-                    t3.strokeStyle = r2.Zl, bl(t3, r2.Kl), t3.beginPath();
-                    for (const i3 of r2.Gl) {
-                        const r3 = Math.round(i3.Yl * s2);
-                        t3.moveTo(-n2, r3), t3.lineTo(e2.width + n2, r3);
-                    }
-                    t3.stroke();
-                }
-            });
-    }
-}
-class Bi {
-    constructor(t3) {
-        this.jt = new Di(), this.vt = true, this.tn = t3;
-    }
-    gt() {
-        this.vt = true;
-    }
-    Mt() {
-        if (this.vt) {
-            const t3 = this.tn.Ut().F().grid,
-                e2 = {
-                    Xl: t3.horzLines.visible,
-                    $l: t3.vertLines.visible,
-                    Zl: t3.horzLines.color,
-                    Hl: t3.vertLines.color,
-                    Kl: t3.horzLines.style,
-                    Ul: t3.vertLines.style,
-                    Gl: this.tn.fn().Jl(),
-                    ql: this.tn.Ut().yt().Jl() || []
-                };
-            this.jt.tt(e2), this.vt = false;
-        }
-        return this.jt;
-    }
-}
-class Ai {
-    constructor(t3) {
-        this.bn = new Bi(t3);
-    }
-    Th() {
-        return this.bn;
-    }
-}
-const jh = {
-    Ql: 4,
-    ta: 1e-4
-};
-
-function Hh(t3, e2) {
-    const i2 = 100 * (t3 - e2) / e2;
-    return e2 < 0 ? -i2 : i2;
-}
-
-function Wh(t3, e2) {
-    const i2 = Hh(t3.lh(), e2),
-        s2 = Hh(t3.ah(), e2);
-    return new vi(i2, s2);
-}
-
-function qh(t3, e2) {
-    const i2 = 100 * (t3 - e2) / e2 + 100;
-    return e2 < 0 ? -i2 : i2;
-}
-
-function Kh(t3, e2) {
-    const i2 = qh(t3.lh(), e2),
-        s2 = qh(t3.ah(), e2);
-    return new vi(i2, s2);
-}
-
-function Gh(t3, e2) {
-    const i2 = Math.abs(t3);
-    if (i2 < 1e-15)
-        return 0;
-    const s2 = Th(i2 + e2.ta) + e2.Ql;
-    return t3 < 0 ? -s2 : s2;
-}
-
-function Yh(t3, e2) {
-    const i2 = Math.abs(t3);
-    if (i2 < 1e-15)
-        return 0;
-    const s2 = Math.pow(10, i2 - e2.Ql) - e2.ta;
-    return t3 < 0 ? -s2 : s2;
-}
-
-function Qh(t3, e2) {
-    if (null === t3)
-        return null;
-    const i2 = Gh(t3.lh(), e2),
-        s2 = Gh(t3.ah(), e2);
-    return new vi(i2, s2);
-}
-
-function Xh(t3, e2) {
-    if (null === t3)
-        return null;
-    const i2 = Yh(t3.lh(), e2),
-        s2 = Yh(t3.ah(), e2);
-    return new vi(i2, s2);
-}
-
-function Jh(t3) {
-    if (null === t3)
-        return jh;
-    const e2 = Math.abs(t3.ah() - t3.lh());
-    if (e2 >= 1 || e2 < 1e-15)
-        return jh;
-    const i2 = Math.ceil(Math.abs(Math.log10(e2))),
-        s2 = jh.Ql + i2;
-    return {
-        Ql: s2,
-        ta: 1 / Math.pow(10, s2)
-    };
-}
-class $i {
-    constructor(t3, e2) {
-        if (this.ia = t3, this.na = e2, function(t4) {
-                if (t4 < 0)
-                    return false;
-                for (let e3 = t4; e3 > 1; e3 /= 10)
-                    if (e3 % 10 != 0)
-                        return false;
-                return true;
-            }(this.ia))
-            this.sa = [2, 2.5, 2];
-        else {
-            this.sa = [];
-            for (let t4 = this.ia; 1 !== t4;) {
-                if (t4 % 2 == 0)
-                    this.sa.push(2), t4 /= 2;
-                else {
-                    if (t4 % 5 != 0)
-                        throw new Error("unexpected base");
-                    this.sa.push(2, 2.5), t4 /= 5;
-                }
-                if (this.sa.length > 100)
-                    throw new Error("something wrong with base");
-            }
-        }
-    }
-    ea(t3, e2, i2) {
-        const s2 = 0 === this.ia ? 0 : 1 / this.ia;
-        let n2 = Math.pow(10, Math.max(0, Math.ceil(Th(t3 - e2)))),
-            r2 = 0,
-            o2 = this.na[0];
-        for (;;) {
-            const t4 = kh(n2, s2, 1e-14) && n2 > s2 + 1e-14,
-                e3 = kh(n2, i2 * o2, 1e-14),
-                a3 = kh(n2, 1, 1e-14);
-            if (!(t4 && e3 && a3))
-                break;
-            n2 /= o2, o2 = this.na[++r2 % this.na.length];
-        }
-        if (n2 <= s2 + 1e-14 && (n2 = s2), n2 = Math.max(1, n2), this.sa.length > 0 && (a2 = n2, 1, 1e-14, Math.abs(a2 - 1) < 1e-14))
-            for (r2 = 0, o2 = this.sa[0]; kh(n2, i2 * o2, 1e-14) && n2 > s2 + 1e-14;)
-                n2 /= o2, o2 = this.sa[++r2 % this.sa.length];
-        var a2;
-        return n2;
-    }
-}
-class Hi {
-    constructor(t3, e2, i2, s2) {
-        this.ra = [], this.zi = t3, this.ia = e2, this.ha = i2, this.la = s2;
-    }
-    ea(t3, e2) {
-        if (t3 < e2)
-            throw new Error("high < low");
-        const i2 = this.zi.It(),
-            s2 = (t3 - e2) * this.aa() / i2,
-            n2 = new $i(this.ia, [2, 2.5, 2]),
-            r2 = new $i(this.ia, [2, 2, 2.5]),
-            o2 = new $i(this.ia, [2.5, 2, 2]),
-            a2 = [];
-        return a2.push(n2.ea(t3, e2, s2), r2.ea(t3, e2, s2), o2.ea(t3, e2, s2)),
-            function(t4) {
-                if (t4.length < 1)
-                    throw Error("array is empty");
-                let e3 = t4[0];
-                for (let i3 = 1; i3 < t4.length; ++i3)
-                    t4[i3] < e3 && (e3 = t4[i3]);
-                return e3;
-            }(a2);
-    }
-    oa() {
-        const t3 = this.zi,
-            e2 = t3.Tt();
-        if (null === e2)
-            return void(this.ra = []);
-        const i2 = t3.It(),
-            s2 = this.ha(i2 - 1, e2),
-            n2 = this.ha(0, e2),
-            r2 = this.zi.F().entireTextOnly ? this._a() / 2 : 0,
-            o2 = r2,
-            a2 = i2 - 1 - r2,
-            l2 = Math.max(s2, n2),
-            h2 = Math.min(s2, n2);
-        if (l2 === h2)
-            return void(this.ra = []);
-        let c2 = this.ea(l2, h2),
-            u2 = l2 % c2;
-        u2 += u2 < 0 ? c2 : 0;
-        const d2 = l2 >= h2 ? 1 : -1;
-        let f2 = null,
-            p2 = 0;
-        for (let i3 = l2 - u2; i3 > h2; i3 -= c2) {
-            const s3 = this.la(i3, e2, true);
-            null !== f2 && Math.abs(s3 - f2) < this.aa() || s3 < o2 || s3 > a2 || (p2 < this.ra.length ? (this.ra[p2].Yl = s3, this.ra[p2].ua = t3.ca(i3)) : this.ra.push({
-                Yl: s3,
-                ua: t3.ca(i3)
-            }), p2++, f2 = s3, t3.da() && (c2 = this.ea(i3 * d2, h2)));
-        }
-        this.ra.length = p2;
-    }
-    Jl() {
-        return this.ra;
-    }
-    _a() {
-        return this.zi.T();
-    }
-    aa() {
-        return Math.ceil(2.5 * this._a());
-    }
-}
-
-function Zh(t3) {
-    return t3.slice().sort((t4, e2) => kl(t4.Zi()) - kl(e2.Zi()));
-}
-var tc;
-! function(t3) {
-    t3[t3.Normal = 0] = "Normal", t3[t3.Logarithmic = 1] = "Logarithmic", t3[t3.Percentage = 2] = "Percentage", t3[t3.IndexedTo100 = 3] = "IndexedTo100";
-}(tc || (tc = {}));
-const ec = new at(),
-    ic = new lt(100, 1);
-class Zi {
-    constructor(t3, e2, i2, s2) {
-        this.fa = 0, this.pa = null, this.ph = null, this.va = null, this.ma = {
-            ba: false,
-            ga: null
-        }, this.wa = 0, this.Ma = 0, this.Sa = new Ll(), this.xa = new Ll(), this.ya = [], this.ka = null, this.Ca = null, this.Ta = null, this.Pa = null, this.Al = ic, this.Ra = Jh(null), this.Da = t3, this.un = e2, this.Ba = i2, this.Aa = s2, this.Oa = new Hi(this, 100, this.La.bind(this), this.Ia.bind(this));
-    }
-    zl() {
-        return this.Da;
-    }
-    F() {
-        return this.un;
-    }
-    kh(t3) {
-        if (Ol(this.un, t3), this.Vl(), void 0 !== t3.mode && this.Ea({
-                lr: t3.mode
-            }), void 0 !== t3.scaleMargins) {
-            const e2 = xl(t3.scaleMargins.top),
-                i2 = xl(t3.scaleMargins.bottom);
-            if (e2 < 0 || e2 > 1)
-                throw new Error(`Invalid top margin - expect value between 0 and 1, given=${e2}`);
-            if (i2 < 0 || i2 > 1 || e2 + i2 > 1)
-                throw new Error(`Invalid bottom margin - expect value between 0 and 1, given=${i2}`);
-            if (e2 + i2 > 1)
-                throw new Error(`Invalid margins - sum of margins must be less than 1, given=${e2 + i2}`);
-            this.za(), this.Ca = null;
-        }
-    }
-    Va() {
-        return this.un.autoScale;
-    }
-    da() {
-        return 1 === this.un.mode;
-    }
-    th() {
-        return 2 === this.un.mode;
-    }
-    Na() {
-        return 3 === this.un.mode;
-    }
-    lr() {
-        return {
-            Fn: this.un.autoScale,
-            Fa: this.un.invertScale,
-            lr: this.un.mode
-        };
-    }
-    Ea(t3) {
-        const e2 = this.lr();
-        let i2 = null;
-        void 0 !== t3.Fn && (this.un.autoScale = t3.Fn), void 0 !== t3.lr && (this.un.mode = t3.lr, 2 !== t3.lr && 3 !== t3.lr || (this.un.autoScale = true), this.ma.ba = false), 1 === e2.lr && t3.lr !== e2.lr && (function(t4, e3) {
-            if (null === t4)
-                return false;
-            const i3 = Yh(t4.lh(), e3),
-                s3 = Yh(t4.ah(), e3);
-            return isFinite(i3) && isFinite(s3);
-        }(this.ph, this.Ra) ? (i2 = Xh(this.ph, this.Ra), null !== i2 && this.Wa(i2)) : this.un.autoScale = true), 1 === t3.lr && t3.lr !== e2.lr && (i2 = Qh(this.ph, this.Ra), null !== i2 && this.Wa(i2));
-        const s2 = e2.lr !== this.un.mode;
-        s2 && (2 === e2.lr || this.th()) && this.Vl(), s2 && (3 === e2.lr || this.Na()) && this.Vl(), void 0 !== t3.Fa && e2.Fa !== t3.Fa && (this.un.invertScale = t3.Fa, this.ja()), this.xa.m(e2, this.lr());
-    }
-    $a() {
-        return this.xa;
-    }
-    T() {
-        return this.Ba.fontSize;
-    }
-    It() {
-        return this.fa;
-    }
-    Ha(t3) {
-        this.fa !== t3 && (this.fa = t3, this.za(), this.Ca = null);
-    }
-    Ua() {
-        if (this.pa)
-            return this.pa;
-        const t3 = this.It() - this.qa() - this.Ya();
-        return this.pa = t3, t3;
-    }
-    bh() {
-        return this.Xa(), this.ph;
-    }
-    Wa(t3, e2) {
-        const i2 = this.ph;
-        (e2 || null === i2 && null !== t3 || null !== i2 && !i2.rh(t3)) && (this.Ca = null, this.ph = t3);
-    }
-    Ni() {
-        return this.Xa(), 0 === this.fa || !this.ph || this.ph.Ni();
-    }
-    Za(t3) {
-        return this.Fa() ? t3 : this.It() - 1 - t3;
-    }
-    Dt(t3, e2) {
-        return this.th() ? t3 = Hh(t3, e2) : this.Na() && (t3 = qh(t3, e2)), this.Ia(t3, e2);
-    }
-    $s(t3, e2, i2) {
-        this.Xa();
-        const s2 = this.Ya(),
-            n2 = kl(this.bh()),
-            r2 = n2.lh(),
-            o2 = n2.ah(),
-            a2 = this.Ua() - 1,
-            l2 = this.Fa(),
-            h2 = a2 / (o2 - r2),
-            c2 = void 0 === i2 ? 0 : i2.from,
-            u2 = void 0 === i2 ? t3.length : i2.to,
-            d2 = this.Ka();
-        for (let i3 = c2; i3 < u2; i3++) {
-            const n3 = t3[i3],
-                o3 = n3.ut;
-            if (isNaN(o3))
-                continue;
-            let a3 = o3;
-            null !== d2 && (a3 = d2(n3.ut, e2));
-            const c3 = s2 + h2 * (a3 - r2),
-                u3 = l2 ? c3 : this.fa - 1 - c3;
-            n3.et = u3;
-        }
-    }
-    le(t3, e2, i2) {
-        this.Xa();
-        const s2 = this.Ya(),
-            n2 = kl(this.bh()),
-            r2 = n2.lh(),
-            o2 = n2.ah(),
-            a2 = this.Ua() - 1,
-            l2 = this.Fa(),
-            h2 = a2 / (o2 - r2),
-            c2 = void 0 === i2 ? 0 : i2.from,
-            u2 = void 0 === i2 ? t3.length : i2.to,
-            d2 = this.Ka();
-        for (let i3 = c2; i3 < u2; i3++) {
-            const n3 = t3[i3];
-            let o3 = n3.oe,
-                a3 = n3._e,
-                c3 = n3.ue,
-                u3 = n3.ce;
-            null !== d2 && (o3 = d2(n3.oe, e2), a3 = d2(n3._e, e2), c3 = d2(n3.ue, e2), u3 = d2(n3.ce, e2));
-            let f2 = s2 + h2 * (o3 - r2),
-                p2 = l2 ? f2 : this.fa - 1 - f2;
-            n3.re = p2, f2 = s2 + h2 * (a3 - r2), p2 = l2 ? f2 : this.fa - 1 - f2, n3.ne = p2, f2 = s2 + h2 * (c3 - r2), p2 = l2 ? f2 : this.fa - 1 - f2, n3.se = p2, f2 = s2 + h2 * (u3 - r2), p2 = l2 ? f2 : this.fa - 1 - f2, n3.he = p2;
-        }
-    }
-    pn(t3, e2) {
-        const i2 = this.La(t3, e2);
-        return this.Ga(i2, e2);
-    }
-    Ga(t3, e2) {
-        let i2 = t3;
-        return this.th() ? i2 = function(t4, e3) {
-            return e3 < 0 && (t4 = -t4), t4 / 100 * e3 + e3;
-        }(i2, e2) : this.Na() && (i2 = function(t4, e3) {
-            return t4 -= 100, e3 < 0 && (t4 = -t4), t4 / 100 * e3 + e3;
-        }(i2, e2)), i2;
-    }
-    jl() {
-        return this.ya;
-    }
-    Ja() {
-        if (this.ka)
-            return this.ka;
-        let t3 = [];
-        for (let e2 = 0; e2 < this.ya.length; e2++) {
-            const i2 = this.ya[e2];
-            null === i2.Zi() && i2.Ki(e2 + 1), t3.push(i2);
-        }
-        return t3 = Zh(t3), this.ka = t3, this.ka;
-    }
-    Qa(t3) {
-        -1 === this.ya.indexOf(t3) && (this.ya.push(t3), this.Vl(), this.io());
-    }
-    no(t3) {
-        const e2 = this.ya.indexOf(t3);
-        if (-1 === e2)
-            throw new Error("source is not attached to scale");
-        this.ya.splice(e2, 1), 0 === this.ya.length && (this.Ea({
-            Fn: true
-        }), this.Wa(null)), this.Vl(), this.io();
-    }
-    Tt() {
-        let t3 = null;
-        for (const e2 of this.ya) {
-            const i2 = e2.Tt();
-            null !== i2 && (null === t3 || i2.yl < t3.yl) && (t3 = i2);
-        }
-        return null === t3 ? null : t3.At;
-    }
-    Fa() {
-        return this.un.invertScale;
-    }
-    Jl() {
-        const t3 = null === this.Tt();
-        if (null !== this.Ca && (t3 || this.Ca.so === t3))
-            return this.Ca.Jl;
-        this.Oa.oa();
-        const e2 = this.Oa.Jl();
-        return this.Ca = {
-            Jl: e2,
-            so: t3
-        }, this.Sa.m(), e2;
-    }
-    eo() {
-        return this.Sa;
-    }
-    ro(t3) {
-        this.th() || this.Na() || null === this.Ta && null === this.va && (this.Ni() || (this.Ta = this.fa - t3, this.va = kl(this.bh()).hh()));
-    }
-    ho(t3) {
-        if (this.th() || this.Na())
-            return;
-        if (null === this.Ta)
-            return;
-        this.Ea({
-            Fn: false
-        }), (t3 = this.fa - t3) < 0 && (t3 = 0);
-        let e2 = (this.Ta + 0.2 * (this.fa - 1)) / (t3 + 0.2 * (this.fa - 1));
-        const i2 = kl(this.va).hh();
-        e2 = Math.max(e2, 0.1), i2._h(e2), this.Wa(i2);
-    }
-    lo() {
-        this.th() || this.Na() || (this.Ta = null, this.va = null);
-    }
-    ao(t3) {
-        this.Va() || null === this.Pa && null === this.va && (this.Ni() || (this.Pa = t3, this.va = kl(this.bh()).hh()));
-    }
-    oo(t3) {
-        if (this.Va())
-            return;
-        if (null === this.Pa)
-            return;
-        const e2 = kl(this.bh()).oh() / (this.Ua() - 1);
-        let i2 = t3 - this.Pa;
-        this.Fa() && (i2 *= -1);
-        const s2 = i2 * e2,
-            n2 = kl(this.va).hh();
-        n2.uh(s2), this.Wa(n2, true), this.Ca = null;
-    }
-    _o() {
-        this.Va() || null !== this.Pa && (this.Pa = null, this.va = null);
-    }
-    Bl() {
-        return this.Al || this.Vl(), this.Al;
-    }
-    Fi(t3, e2) {
-        switch (this.un.mode) {
-            case 2:
-                return this.Bl().format(Hh(t3, e2));
-            case 3:
-                return this.Bl().format(qh(t3, e2));
-            default:
-                return this.Sh(t3);
-        }
-    }
-    ca(t3) {
-        switch (this.un.mode) {
-            case 2:
-            case 3:
-                return this.Bl().format(t3);
-            default:
-                return this.Sh(t3);
-        }
-    }
-    _l(t3) {
-        return this.Sh(t3, kl(this.uo()).Bl());
-    }
-    ul(t3, e2) {
-        return t3 = Hh(t3, e2), ec.format(t3);
-    }
-    co() {
-        return this.ya;
-    }
-    do(t3) {
-        this.ma = {
-            ga: t3,
-            ba: false
-        };
-    }
-    Dn() {
-        this.ya.forEach((t3) => t3.Dn());
-    }
-    Vl() {
-        this.Ca = null;
-        const t3 = this.uo();
-        let e2 = 100;
-        null !== t3 && (e2 = Math.round(1 / t3.Dl())), this.Al = ic, this.th() ? (this.Al = ec, e2 = 100) : this.Na() ? (this.Al = new lt(100, 1), e2 = 100) : null !== t3 && (this.Al = t3.Bl()), this.Oa = new Hi(this, e2, this.La.bind(this), this.Ia.bind(this)), this.Oa.oa();
-    }
-    io() {
-        this.ka = null;
-    }
-    uo() {
-        return this.ya[0] || null;
-    }
-    qa() {
-        return this.Fa() ? this.un.scaleMargins.bottom * this.It() + this.Ma : this.un.scaleMargins.top * this.It() + this.wa;
-    }
-    Ya() {
-        return this.Fa() ? this.un.scaleMargins.top * this.It() + this.wa : this.un.scaleMargins.bottom * this.It() + this.Ma;
-    }
-    Xa() {
-        this.ma.ba || (this.ma.ba = true, this.fo());
-    }
-    za() {
-        this.pa = null;
-    }
-    Ia(t3, e2) {
-        if (this.Xa(), this.Ni())
-            return 0;
-        t3 = this.da() && t3 ? Gh(t3, this.Ra) : t3;
-        const i2 = kl(this.bh()),
-            s2 = this.Ya() + (this.Ua() - 1) * (t3 - i2.lh()) / i2.oh();
-        return this.Za(s2);
-    }
-    La(t3, e2) {
-        if (this.Xa(), this.Ni())
-            return 0;
-        const i2 = this.Za(t3),
-            s2 = kl(this.bh()),
-            n2 = s2.lh() + s2.oh() * ((i2 - this.Ya()) / (this.Ua() - 1));
-        return this.da() ? Yh(n2, this.Ra) : n2;
-    }
-    ja() {
-        this.Ca = null, this.Oa.oa();
-    }
-    fo() {
-        const t3 = this.ma.ga;
-        if (null === t3)
-            return;
-        let e2 = null;
-        const i2 = this.co();
-        let s2 = 0,
-            n2 = 0;
-        for (const r3 of i2) {
-            if (!r3.Ct())
-                continue;
-            const i3 = r3.Tt();
-            if (null === i3)
-                continue;
-            const o3 = r3.Pl(t3.Ms(), t3.ci());
-            let a2 = o3 && o3.bh();
-            if (null !== a2) {
-                switch (this.un.mode) {
-                    case 1:
-                        a2 = Qh(a2, this.Ra);
-                        break;
-                    case 2:
-                        a2 = Wh(a2, i3.At);
-                        break;
-                    case 3:
-                        a2 = Kh(a2, i3.At);
-                }
-                if (e2 = null === e2 ? a2 : e2.Qn(kl(a2)), null !== o3) {
-                    const t4 = o3.gh();
-                    null !== t4 && (s2 = Math.max(s2, t4.above), n2 = Math.max(s2, t4.below));
-                }
-            }
-        }
-        if (s2 === this.wa && n2 === this.Ma || (this.wa = s2, this.Ma = n2, this.Ca = null, this.za()), null !== e2) {
-            if (e2.lh() === e2.ah()) {
-                const t4 = this.uo(),
-                    i3 = 5 * (null === t4 || this.th() || this.Na() ? 1 : t4.Dl());
-                this.da() && (e2 = Xh(e2, this.Ra)), e2 = new vi(e2.lh() - i3, e2.ah() + i3), this.da() && (e2 = Qh(e2, this.Ra));
-            }
-            if (this.da()) {
-                const t4 = Xh(e2, this.Ra),
-                    i3 = Jh(t4);
-                if (r2 = i3, o2 = this.Ra, r2.Ql !== o2.Ql || r2.ta !== o2.ta) {
-                    const s3 = null !== this.va ? Xh(this.va, this.Ra) : null;
-                    this.Ra = i3, e2 = Qh(t4, i3), null !== s3 && (this.va = Qh(s3, i3));
-                }
-            }
-            this.Wa(e2);
-        } else
-            null === this.ph && (this.Wa(new vi(-0.5, 0.5)), this.Ra = Jh(null));
-        var r2, o2;
-        this.ma.ba = true;
-    }
-    Ka() {
-        return this.th() ? Hh : this.Na() ? qh : this.da() ? (t3) => Gh(t3, this.Ra) : null;
-    }
-    Sh(t3, e2) {
-        return void 0 === this.Aa.priceFormatter ? (void 0 === e2 && (e2 = this.Bl()), e2.format(t3)) : this.Aa.priceFormatter(t3);
-    }
-}
-class Ki {
-    constructor(t3, e2) {
-        this.ya = [], this.po = /* @__PURE__ */ new Map(), this.fa = 0, this.vo = 0, this.mo = 1e3, this.ka = null, this.bo = new Ll(), this.wo = t3, this.Hi = e2, this.Mo = new Ai(this);
-        const i2 = e2.F();
-        this.So = this.xo("left", i2.leftPriceScale), this.yo = this.xo("right", i2.rightPriceScale), this.So.$a().l(this.ko.bind(this, this.So), this), this.yo.$a().l(this.ko.bind(this, this.yo), this), this.Co(i2);
-    }
-    Co(t3) {
-        if (t3.leftPriceScale && this.So.kh(t3.leftPriceScale), t3.rightPriceScale && this.yo.kh(t3.rightPriceScale), t3.localization && (this.So.Vl(), this.yo.Vl()), t3.overlayPriceScales) {
-            const e2 = Array.from(this.po.values());
-            for (const i2 of e2) {
-                const e3 = kl(i2[0].Bt());
-                e3.kh(t3.overlayPriceScales), t3.localization && e3.Vl();
-            }
-        }
-    }
-    To(t3) {
-        switch (t3) {
-            case "left":
-                return this.So;
-            case "right":
-                return this.yo;
-        }
-        return this.po.has(t3) ? xl(this.po.get(t3))[0].Bt() : null;
-    }
-    M() {
-        this.Ut().Po().v(this), this.So.$a().v(this), this.yo.$a().v(this), this.ya.forEach((t3) => {
-            t3.M && t3.M();
-        }), this.bo.m();
-    }
-    Ro() {
-        return this.mo;
-    }
-    Do(t3) {
-        this.mo = t3;
-    }
-    Ut() {
-        return this.Hi;
-    }
-    $i() {
-        return this.vo;
-    }
-    It() {
-        return this.fa;
-    }
-    Bo(t3) {
-        this.vo = t3, this.Ao();
-    }
-    Ha(t3) {
-        this.fa = t3, this.So.Ha(t3), this.yo.Ha(t3), this.ya.forEach((e2) => {
-            if (this.Ge(e2)) {
-                const i2 = e2.Bt();
-                null !== i2 && i2.Ha(t3);
-            }
-        }), this.Ao();
-    }
-    jl() {
-        return this.ya;
-    }
-    Ge(t3) {
-        const e2 = t3.Bt();
-        return null === e2 || this.So !== e2 && this.yo !== e2;
-    }
-    Qa(t3, e2, i2) {
-        const s2 = void 0 !== i2 ? i2 : this.Lo().Oo + 1;
-        this.Io(t3, e2, s2);
-    }
-    no(t3) {
-        const e2 = this.ya.indexOf(t3);
-        wl(-1 !== e2, "removeDataSource: invalid data source"), this.ya.splice(e2, 1);
-        const i2 = kl(t3.Bt()).zl();
-        if (this.po.has(i2)) {
-            const e3 = xl(this.po.get(i2)),
-                s3 = e3.indexOf(t3); -
-            1 !== s3 && (e3.splice(s3, 1), 0 === e3.length && this.po.delete(i2));
-        }
-        const s2 = t3.Bt();
-        s2 && s2.jl().indexOf(t3) >= 0 && s2.no(t3), null !== s2 && (s2.io(), this.Eo(s2)), this.ka = null;
-    }
-    Qe(t3) {
-        return t3 === this.So ? "left" : t3 === this.yo ? "right" : "overlay";
-    }
-    zo() {
-        return this.So;
-    }
-    Vo() {
-        return this.yo;
-    }
-    No(t3, e2) {
-        t3.ro(e2);
-    }
-    Fo(t3, e2) {
-        t3.ho(e2), this.Ao();
-    }
-    Wo(t3) {
-        t3.lo();
-    }
-    jo(t3, e2) {
-        t3.ao(e2);
-    }
-    $o(t3, e2) {
-        t3.oo(e2), this.Ao();
-    }
-    Ho(t3) {
-        t3._o();
-    }
-    Ao() {
-        this.ya.forEach((t3) => {
-            t3.Dn();
-        });
-    }
-    fn() {
-        let t3 = null;
-        return this.Hi.F().rightPriceScale.visible && 0 !== this.yo.jl().length ? t3 = this.yo : this.Hi.F().leftPriceScale.visible && 0 !== this.So.jl().length ? t3 = this.So : 0 !== this.ya.length && (t3 = this.ya[0].Bt()), null === t3 && (t3 = this.yo), t3;
-    }
-    Je() {
-        let t3 = null;
-        return this.Hi.F().rightPriceScale.visible ? t3 = this.yo : this.Hi.F().leftPriceScale.visible && (t3 = this.So), t3;
-    }
-    Eo(t3) {
-        null !== t3 && t3.Va() && this.Uo(t3);
-    }
-    qo(t3) {
-        const e2 = this.wo.Vs();
-        t3.Ea({
-            Fn: true
-        }), null !== e2 && t3.do(e2), this.Ao();
-    }
-    Yo() {
-        this.Uo(this.So), this.Uo(this.yo);
-    }
-    Xo() {
-        this.Eo(this.So), this.Eo(this.yo), this.ya.forEach((t3) => {
-            this.Ge(t3) && this.Eo(t3.Bt());
-        }), this.Ao(), this.Hi.Ch();
-    }
-    Ja() {
-        return null === this.ka && (this.ka = Zh(this.ya)), this.ka;
-    }
-    Zo() {
-        return this.bo;
-    }
-    Ko() {
-        return this.Mo;
-    }
-    Uo(t3) {
-        const e2 = t3.co();
-        if (e2 && e2.length > 0 && !this.wo.Ni()) {
-            const e3 = this.wo.Vs();
-            null !== e3 && t3.do(e3);
-        }
-        t3.Dn();
-    }
-    Lo() {
-        const t3 = this.Ja();
-        if (0 === t3.length)
-            return {
-                Go: 0,
-                Oo: 0
-            };
-        let e2 = 0,
-            i2 = 0;
-        for (let s2 = 0; s2 < t3.length; s2++) {
-            const n2 = t3[s2].Zi();
-            null !== n2 && (n2 < e2 && (e2 = n2), n2 > i2 && (i2 = n2));
-        }
-        return {
-            Go: e2,
-            Oo: i2
-        };
-    }
-    Io(t3, e2, i2) {
-        let s2 = this.To(e2);
-        if (null === s2 && (s2 = this.xo(e2, this.Hi.F().overlayPriceScales)), this.ya.push(t3), !lh(e2)) {
-            const i3 = this.po.get(e2) || [];
-            i3.push(t3), this.po.set(e2, i3);
-        }
-        s2.Qa(t3), t3.Gi(s2), t3.Ki(i2), this.Eo(s2), this.ka = null;
-    }
-    ko(t3, e2, i2) {
-        e2.lr !== i2.lr && this.Uo(t3);
-    }
-    xo(t3, e2) {
-        const i2 = Object.assign({
-                visible: true,
-                autoScale: true
-            }, zl(e2)),
-            s2 = new Zi(t3, i2, this.Hi.F().layout, this.Hi.F().localization);
-        return s2.Ha(this.It()), s2;
-    }
-}
-const sc = (t3) => t3.getUTCFullYear();
-class rn {
-    constructor(t3 = "yyyy-MM-dd", e2 = "default") {
-        this.Jo = t3, this.Qo = e2;
-    }
-    t_(t3) {
-        return function(t4, e2, i2) {
-            return e2.replace(/yyyy/g, ((t5) => hh(sc(t5), 4))(t4)).replace(/yy/g, ((t5) => hh(sc(t5) % 100, 2))(t4)).replace(/MMMM/g, ((t5, e3) => new Date(t5.getUTCFullYear(), t5.getUTCMonth(), 1).toLocaleString(e3, {
-                month: "long"
-            }))(t4, i2)).replace(/MMM/g, ((t5, e3) => new Date(t5.getUTCFullYear(), t5.getUTCMonth(), 1).toLocaleString(e3, {
-                month: "short"
-            }))(t4, i2)).replace(/MM/g, ((t5) => hh(((t6) => t6.getUTCMonth() + 1)(t5), 2))(t4)).replace(/dd/g, ((t5) => hh(((t6) => t6.getUTCDate())(t5), 2))(t4));
-        }(t3, this.Jo, this.Qo);
-    }
-}
-class hn {
-    constructor(t3) {
-        this.i_ = t3 || "%h:%m:%s";
-    }
-    t_(t3) {
-        return this.i_.replace("%h", hh(t3.getUTCHours(), 2)).replace("%m", hh(t3.getUTCMinutes(), 2)).replace("%s", hh(t3.getUTCSeconds(), 2));
-    }
-}
-const nc = {
-    n_: "yyyy-MM-dd",
-    s_: "%h:%m:%s",
-    e_: " ",
-    r_: "default"
-};
-class an {
-    constructor(t3 = {}) {
-        const e2 = Object.assign(Object.assign({}, nc), t3);
-        this.h_ = new rn(e2.n_, e2.r_), this.l_ = new hn(e2.s_), this.a_ = e2.e_;
-    }
-    t_(t3) {
-        return `${this.h_.t_(t3)}${this.a_}${this.l_.t_(t3)}`;
-    }
-}
-class on {
-    constructor(t3, e2 = 50) {
-        this.Le = 0, this.Ie = 1, this.Ee = 1, this.Ve = /* @__PURE__ */ new Map(), this.ze = /* @__PURE__ */ new Map(), this.o_ = t3, this.Ne = e2;
-    }
-    t_(t3) {
-        const e2 = t3._t,
-            i2 = void 0 === e2.__ ? new Date(1e3 * e2.u_).getTime() : new Date(Date.UTC(e2.__.year, e2.__.month - 1, e2.__.day)).getTime(),
-            s2 = this.Ve.get(i2);
-        if (void 0 !== s2)
-            return s2.c_;
-        if (this.Le === this.Ne) {
-            const t4 = this.ze.get(this.Ee);
-            this.ze.delete(this.Ee), this.Ve.delete(xl(t4)), this.Ee++, this.Le--;
-        }
-        const n2 = this.o_(t3);
-        return this.Ve.set(i2, {
-            c_: n2,
-            $e: this.Ie
-        }), this.ze.set(this.Ie, i2), this.Le++, this.Ie++, n2;
-    }
-}
-class _n {
-    constructor(t3, e2) {
-        wl(t3 <= e2, "right should be >= left"), this.d_ = t3, this.f_ = e2;
-    }
-    Ms() {
-        return this.d_;
-    }
-    ci() {
-        return this.f_;
-    }
-    p_() {
-        return this.f_ - this.d_ + 1;
-    }
-    Ir(t3) {
-        return this.d_ <= t3 && t3 <= this.f_;
-    }
-    rh(t3) {
-        return this.d_ === t3.Ms() && this.f_ === t3.ci();
-    }
-}
-
-function rc(t3, e2) {
-    return null === t3 || null === e2 ? t3 === e2 : t3.rh(e2);
-}
-class cn {
-    constructor() {
-        this.v_ = /* @__PURE__ */ new Map(), this.Ve = null;
-    }
-    m_(t3, e2) {
-        this.b_(e2), this.Ve = null;
-        for (let i2 = e2; i2 < t3.length; ++i2) {
-            const e3 = t3[i2];
-            let s2 = this.v_.get(e3.g_);
-            void 0 === s2 && (s2 = [], this.v_.set(e3.g_, s2)), s2.push({
-                Ys: i2,
-                _t: e3._t,
-                w_: e3.g_,
-                M_: e3.M_
-            });
-        }
-    }
-    S_(t3, e2) {
-        const i2 = Math.ceil(e2 / t3);
-        return null !== this.Ve && this.Ve.x_ === i2 || (this.Ve = {
-            Jl: this.y_(i2),
-            x_: i2
-        }), this.Ve.Jl;
-    }
-    b_(t3) {
-        if (0 === t3)
-            return void this.v_.clear();
-        const e2 = [];
-        this.v_.forEach((i2, s2) => {
-            t3 <= i2[0].Ys ? e2.push(s2) : i2.splice(yh(i2, t3, (e3) => e3.Ys < t3), 1 / 0);
-        });
-        for (const t4 of e2)
-            this.v_.delete(t4);
-    }
-    y_(t3) {
-        let e2 = [];
-        for (const i2 of Array.from(this.v_.keys()).sort((t4, e3) => e3 - t4)) {
-            if (!this.v_.get(i2))
-                continue;
-            const s2 = e2;
-            e2 = [];
-            const n2 = s2.length;
-            let r2 = 0;
-            const o2 = xl(this.v_.get(i2)),
-                a2 = o2.length;
-            let l2 = 1 / 0,
-                h2 = -1 / 0;
-            for (let i3 = 0; i3 < a2; i3++) {
-                const a3 = o2[i3],
-                    c2 = a3.Ys;
-                for (; r2 < n2;) {
-                    const t4 = s2[r2],
-                        i4 = t4.Ys;
-                    if (!(i4 < c2)) {
-                        l2 = i4;
-                        break;
-                    }
-                    r2++, e2.push(t4), h2 = i4, l2 = 1 / 0;
-                }
-                l2 - c2 >= t3 && c2 - h2 >= t3 && (e2.push(a3), h2 = c2);
-            }
-            for (; r2 < n2; r2++)
-                e2.push(s2[r2]);
-        }
-        return e2;
-    }
-}
-class dn {
-    constructor(t3) {
-        this.k_ = t3;
-    }
-    C_() {
-        return null === this.k_ ? null : new _n(Math.floor(this.k_.Ms()), Math.ceil(this.k_.ci()));
-    }
-    T_() {
-        return this.k_;
-    }
-    static P_() {
-        return new dn(null);
-    }
-}
-var oc, ac, lc, hc, cc;
-! function(t3) {
-    t3[t3.Year = 0] = "Year", t3[t3.Month = 1] = "Month", t3[t3.DayOfMonth = 2] = "DayOfMonth", t3[t3.Time = 3] = "Time", t3[t3.TimeWithSeconds = 4] = "TimeWithSeconds";
-}(oc || (oc = {}));
-class gn {
-    constructor(t3, e2, i2) {
-        this.vo = 0, this.R_ = null, this.D_ = [], this.Pa = null, this.Ta = null, this.B_ = new cn(), this.A_ = /* @__PURE__ */ new Map(), this.O_ = dn.P_(), this.L_ = true, this.I_ = new Ll(), this.E_ = new Ll(), this.z_ = new Ll(), this.V_ = null, this.N_ = null, this.F_ = [], this.un = e2, this.Aa = i2, this.W_ = e2.rightOffset, this.j_ = e2.barSpacing, this.Hi = t3, this.H_();
-    }
-    F() {
-        return this.un;
-    }
-    U_(t3) {
-        Ol(this.Aa, t3), this.q_(), this.H_();
-    }
-    kh(t3, e2) {
-        var i2;
-        Ol(this.un, t3), this.un.fixLeftEdge && this.Y_(), this.un.fixRightEdge && this.X_(), void 0 !== t3.barSpacing && this.Hi.Kn(t3.barSpacing), void 0 !== t3.rightOffset && this.Hi.Gn(t3.rightOffset), void 0 !== t3.minBarSpacing && this.Hi.Kn(null !== (i2 = t3.barSpacing) && void 0 !== i2 ? i2 : this.j_), this.q_(), this.H_(), this.z_.m();
-    }
-    vn(t3) {
-        var e2, i2;
-        return null !== (i2 = null === (e2 = this.D_[t3]) || void 0 === e2 ? void 0 : e2._t) && void 0 !== i2 ? i2 : null;
-    }
-    Ui(t3) {
-        var e2;
-        return null !== (e2 = this.D_[t3]) && void 0 !== e2 ? e2 : null;
-    }
-    Fl(t3, e2) {
-        if (this.D_.length < 1)
-            return null;
-        if (t3.u_ > this.D_[this.D_.length - 1]._t.u_)
-            return e2 ? this.D_.length - 1 : null;
-        const i2 = yh(this.D_, t3.u_, (t4, e3) => t4._t.u_ < e3);
-        return t3.u_ < this.D_[i2]._t.u_ ? e2 ? i2 : null : i2;
-    }
-    Ni() {
-        return 0 === this.vo || 0 === this.D_.length || null === this.R_;
-    }
-    Nl() {
-        return this.D_.length > 0;
-    }
-    Vs() {
-        return this.Z_(), this.O_.C_();
-    }
-    K_() {
-        return this.Z_(), this.O_.T_();
-    }
-    G_() {
-        const t3 = this.Vs();
-        if (null === t3)
-            return null;
-        const e2 = {
-            from: t3.Ms(),
-            to: t3.ci()
-        };
-        return this.J_(e2);
-    }
-    J_(t3) {
-        const e2 = Math.round(t3.from),
-            i2 = Math.round(t3.to),
-            s2 = kl(this.Q_()),
-            n2 = kl(this.tu());
-        return {
-            from: kl(this.vn(Math.max(s2, e2))),
-            to: kl(this.vn(Math.min(n2, i2)))
-        };
-    }
-    iu(t3) {
-        return {
-            from: kl(this.Fl(t3.from, true)),
-            to: kl(this.Fl(t3.to, true))
-        };
-    }
-    $i() {
-        return this.vo;
-    }
-    Bo(t3) {
-        if (!isFinite(t3) || t3 <= 0)
-            return;
-        if (this.vo === t3)
-            return;
-        const e2 = this.K_(),
-            i2 = this.vo;
-        if (this.vo = t3, this.L_ = true, this.un.lockVisibleTimeRangeOnResize && 0 !== i2) {
-            const e3 = this.j_ * t3 / i2;
-            this.j_ = e3;
-        }
-        if (this.un.fixLeftEdge && null !== e2 && e2.Ms() <= 0) {
-            const e3 = i2 - t3;
-            this.W_ -= Math.round(e3 / this.j_) + 1, this.L_ = true;
-        }
-        this.nu(), this.su();
-    }
-    Et(t3) {
-        if (this.Ni() || !Nl(t3))
-            return 0;
-        const e2 = this.eu() + this.W_ - t3;
-        return this.vo - (e2 + 0.5) * this.j_ - 1;
-    }
-    js(t3, e2) {
-        const i2 = this.eu(),
-            s2 = void 0 === e2 ? 0 : e2.from,
-            n2 = void 0 === e2 ? t3.length : e2.to;
-        for (let e3 = s2; e3 < n2; e3++) {
-            const s3 = t3[e3]._t,
-                n3 = i2 + this.W_ - s3,
-                r2 = this.vo - (n3 + 0.5) * this.j_ - 1;
-            t3[e3].st = r2;
-        }
-    }
-    ru(t3) {
-        return Math.ceil(this.hu(t3));
-    }
-    Gn(t3) {
-        this.L_ = true, this.W_ = t3, this.su(), this.Hi.lu(), this.Hi.Ch();
-    }
-    Ks() {
-        return this.j_;
-    }
-    Kn(t3) {
-        this.au(t3), this.su(), this.Hi.lu(), this.Hi.Ch();
-    }
-    ou() {
-        return this.W_;
-    }
-    Jl() {
-        if (this.Ni())
-            return null;
-        if (null !== this.N_)
-            return this.N_;
-        const t3 = this.j_,
-            e2 = 5 * (this.Hi.F().layout.fontSize + 4),
-            i2 = Math.round(e2 / t3),
-            s2 = kl(this.Vs()),
-            n2 = Math.max(s2.Ms(), s2.Ms() - i2),
-            r2 = Math.max(s2.ci(), s2.ci() - i2),
-            o2 = this.B_.S_(t3, e2),
-            a2 = this.Q_() + i2,
-            l2 = this.tu() - i2,
-            h2 = this._u(),
-            c2 = this.un.fixLeftEdge || h2,
-            u2 = this.un.fixRightEdge || h2;
-        let d2 = 0;
-        for (const t4 of o2) {
-            if (!(n2 <= t4.Ys && t4.Ys <= r2))
-                continue;
-            let i3;
-            d2 < this.F_.length ? (i3 = this.F_[d2], i3.Yl = this.Et(t4.Ys), i3.ua = this.uu(t4), i3.w_ = t4.w_) : (i3 = {
-                cu: false,
-                Yl: this.Et(t4.Ys),
-                ua: this.uu(t4),
-                w_: t4.w_
-            }, this.F_.push(i3)), this.j_ > e2 / 2 && !h2 ? i3.cu = false : i3.cu = c2 && t4.Ys <= a2 || u2 && t4.Ys >= l2, d2++;
-        }
-        return this.F_.length = d2, this.N_ = this.F_, this.F_;
-    }
-    du() {
-        this.L_ = true, this.Kn(this.un.barSpacing), this.Gn(this.un.rightOffset);
-    }
-    fu(t3) {
-        this.L_ = true, this.R_ = t3, this.su(), this.Y_();
-    }
-    pu(t3, e2) {
-        const i2 = this.hu(t3),
-            s2 = this.Ks(),
-            n2 = s2 + e2 * (s2 / 10);
-        this.Kn(n2), this.un.rightBarStaysOnScroll || this.Gn(this.ou() + (i2 - this.hu(t3)));
-    }
-    ro(t3) {
-        this.Pa && this._o(), null === this.Ta && null === this.V_ && (this.Ni() || (this.Ta = t3, this.vu()));
-    }
-    ho(t3) {
-        if (null === this.V_)
-            return;
-        const e2 = xh(this.vo - t3, 0, this.vo),
-            i2 = xh(this.vo - kl(this.Ta), 0, this.vo);
-        0 !== e2 && 0 !== i2 && this.Kn(this.V_.Ks * e2 / i2);
-    }
-    lo() {
-        null !== this.Ta && (this.Ta = null, this.mu());
-    }
-    ao(t3) {
-        null === this.Pa && null === this.V_ && (this.Ni() || (this.Pa = t3, this.vu()));
-    }
-    oo(t3) {
-        if (null === this.Pa)
-            return;
-        const e2 = (this.Pa - t3) / this.Ks();
-        this.W_ = kl(this.V_).ou + e2, this.L_ = true, this.su();
-    }
-    _o() {
-        null !== this.Pa && (this.Pa = null, this.mu());
-    }
-    bu() {
-        this.gu(this.un.rightOffset);
-    }
-    gu(t3, e2 = 400) {
-        if (!isFinite(t3))
-            throw new RangeError("offset is required and must be finite number");
-        if (!isFinite(e2) || e2 <= 0)
-            throw new RangeError("animationDuration (optional) must be finite positive number");
-        const i2 = this.W_,
-            s2 = performance.now();
-        this.Hi.Yn({
-            wu: (t4) => (t4 - s2) / e2 >= 1,
-            Mu: (n2) => {
-                const r2 = (n2 - s2) / e2;
-                return r2 >= 1 ? t3 : i2 + (t3 - i2) * r2;
-            }
-        });
-    }
-    gt(t3, e2) {
-        this.L_ = true, this.D_ = t3, this.B_.m_(t3, e2), this.su();
-    }
-    Su() {
-        return this.I_;
-    }
-    xu() {
-        return this.E_;
-    }
-    yu() {
-        return this.z_;
-    }
-    eu() {
-        return this.R_ || 0;
-    }
-    ku(t3) {
-        const e2 = t3.p_();
-        this.au(this.vo / e2), this.W_ = t3.ci() - this.eu(), this.su(), this.L_ = true, this.Hi.lu(), this.Hi.Ch();
-    }
-    Cu() {
-        const t3 = this.Q_(),
-            e2 = this.tu();
-        null !== t3 && null !== e2 && this.ku(new _n(t3, e2 + this.un.rightOffset));
-    }
-    Tu(t3) {
-        const e2 = new _n(t3.from, t3.to);
-        this.ku(e2);
-    }
-    qi(t3) {
-        return void 0 !== this.Aa.timeFormatter ? this.Aa.timeFormatter(t3.M_) : this.Pu.t_(new Date(1e3 * t3._t.u_));
-    }
-    _u() {
-        const {
-            handleScroll: t3,
-            handleScale: e2
-        } = this.Hi.F();
-        return !(t3.horzTouchDrag || t3.mouseWheel || t3.pressedMouseMove || t3.vertTouchDrag || e2.axisDoubleClickReset.time || e2.axisPressedMouseMove.time || e2.mouseWheel || e2.pinch);
-    }
-    Q_() {
-        return 0 === this.D_.length ? null : 0;
-    }
-    tu() {
-        return 0 === this.D_.length ? null : this.D_.length - 1;
-    }
-    Ru(t3) {
-        return (this.vo - 1 - t3) / this.j_;
-    }
-    hu(t3) {
-        const e2 = this.Ru(t3),
-            i2 = this.eu() + this.W_ - e2;
-        return Math.round(1e6 * i2) / 1e6;
-    }
-    au(t3) {
-        const e2 = this.j_;
-        this.j_ = t3, this.nu(), e2 !== this.j_ && (this.L_ = true, this.Du());
-    }
-    Z_() {
-        if (!this.L_)
-            return;
-        if (this.L_ = false, this.Ni())
-            return void this.Bu(dn.P_());
-        const t3 = this.eu(),
-            e2 = this.vo / this.j_,
-            i2 = this.W_ + t3,
-            s2 = new _n(i2 - e2 + 1, i2);
-        this.Bu(new dn(s2));
-    }
-    nu() {
-        const t3 = this.Au();
-        if (this.j_ < t3 && (this.j_ = t3, this.L_ = true), 0 !== this.vo) {
-            const t4 = 0.5 * this.vo;
-            this.j_ > t4 && (this.j_ = t4, this.L_ = true);
-        }
-    }
-    Au() {
-        return this.un.fixLeftEdge && this.un.fixRightEdge && 0 !== this.D_.length ? this.vo / this.D_.length : this.un.minBarSpacing;
-    }
-    su() {
-        const t3 = this.Ou();
-        this.W_ > t3 && (this.W_ = t3, this.L_ = true);
-        const e2 = this.Lu();
-        null !== e2 && this.W_ < e2 && (this.W_ = e2, this.L_ = true);
-    }
-    Lu() {
-        const t3 = this.Q_(),
-            e2 = this.R_;
-        return null === t3 || null === e2 ? null : t3 - e2 - 1 + (this.un.fixLeftEdge ? this.vo / this.j_ : Math.min(2, this.D_.length));
-    }
-    Ou() {
-        return this.un.fixRightEdge ? 0 : this.vo / this.j_ - Math.min(2, this.D_.length);
-    }
-    vu() {
-        this.V_ = {
-            Ks: this.Ks(),
-            ou: this.ou()
-        };
-    }
-    mu() {
-        this.V_ = null;
-    }
-    uu(t3) {
-        let e2 = this.A_.get(t3.w_);
-        return void 0 === e2 && (e2 = new on((t4) => this.Iu(t4)), this.A_.set(t3.w_, e2)), e2.t_(t3);
-    }
-    Iu(t3) {
-        const e2 = function(t4, e3, i2) {
-            switch (t4) {
-                case 0:
-                case 10:
-                    return e3 ? i2 ? 4 : 3 : 2;
-                case 20:
-                case 21:
-                case 22:
-                case 30:
-                case 31:
-                case 32:
-                case 33:
-                    return e3 ? 3 : 2;
-                case 50:
-                    return 2;
-                case 60:
-                    return 1;
-                case 70:
-                    return 0;
-            }
-        }(t3.w_, this.un.timeVisible, this.un.secondsVisible);
-        if (void 0 !== this.un.tickMarkFormatter) {
-            const i2 = this.un.tickMarkFormatter(t3.M_, e2, this.Aa.locale);
-            if (null !== i2)
-                return i2;
-        }
-        return function(t4, e3, i2) {
-            const s2 = {};
-            switch (e3) {
-                case 0:
-                    s2.year = "numeric";
-                    break;
-                case 1:
-                    s2.month = "short";
-                    break;
-                case 2:
-                    s2.day = "numeric";
-                    break;
-                case 3:
-                    s2.hour12 = false, s2.hour = "2-digit", s2.minute = "2-digit";
-                    break;
-                case 4:
-                    s2.hour12 = false, s2.hour = "2-digit", s2.minute = "2-digit", s2.second = "2-digit";
-            }
-            const n2 = void 0 === t4.__ ? new Date(1e3 * t4.u_) : new Date(Date.UTC(t4.__.year, t4.__.month - 1, t4.__.day));
-            return new Date(n2.getUTCFullYear(), n2.getUTCMonth(), n2.getUTCDate(), n2.getUTCHours(), n2.getUTCMinutes(), n2.getUTCSeconds(), n2.getUTCMilliseconds()).toLocaleString(i2, s2);
-        }(t3._t, e2, this.Aa.locale);
-    }
-    Bu(t3) {
-        const e2 = this.O_;
-        this.O_ = t3, rc(e2.C_(), this.O_.C_()) || this.I_.m(), rc(e2.T_(), this.O_.T_()) || this.E_.m(), this.Du();
-    }
-    Du() {
-        this.N_ = null;
-    }
-    q_() {
-        this.Du(), this.A_.clear();
-    }
-    H_() {
-        const t3 = this.Aa.dateFormat;
-        this.un.timeVisible ? this.Pu = new an({
-            n_: t3,
-            s_: this.un.secondsVisible ? "%h:%m:%s" : "%h:%m",
-            e_: "   ",
-            r_: this.Aa.locale
-        }) : this.Pu = new rn(t3, this.Aa.locale);
-    }
-    Y_() {
-        if (!this.un.fixLeftEdge)
-            return;
-        const t3 = this.Q_();
-        if (null === t3)
-            return;
-        const e2 = this.Vs();
-        if (null === e2)
-            return;
-        const i2 = e2.Ms() - t3;
-        if (i2 < 0) {
-            const t4 = this.W_ - i2 - 1;
-            this.Gn(t4);
-        }
-        this.nu();
-    }
-    X_() {
-        this.su(), this.nu();
-    }
-}
-class wn extends L {
-    constructor(t3) {
-        super(), this.Eu = /* @__PURE__ */ new Map(), this.zt = t3;
-    }
-    Z(t3) {}
-    G(t3) {
-        if (!this.zt.Ct)
-            return;
-        const {
-            context: e2,
-            mediaSize: i2
-        } = t3;
-        let s2 = 0;
-        for (const t4 of this.zt.zu) {
-            if (0 === t4.Gt.length)
-                continue;
-            e2.font = t4.P;
-            const n3 = this.Vu(e2, t4.Gt);
-            n3 > i2.width ? t4.pu = i2.width / n3 : t4.pu = 1, s2 += t4.Nu * t4.pu;
-        }
-        let n2 = 0;
-        switch (this.zt.Fu) {
-            case "top":
-                n2 = 0;
-                break;
-            case "center":
-                n2 = Math.max((i2.height - s2) / 2, 0);
-                break;
-            case "bottom":
-                n2 = Math.max(i2.height - s2, 0);
-        }
-        e2.fillStyle = this.zt.D;
-        for (const t4 of this.zt.zu) {
-            e2.save();
-            let s3 = 0;
-            switch (this.zt.Wu) {
-                case "left":
-                    e2.textAlign = "left", s3 = t4.Nu / 2;
-                    break;
-                case "center":
-                    e2.textAlign = "center", s3 = i2.width / 2;
-                    break;
-                case "right":
-                    e2.textAlign = "right", s3 = i2.width - 1 - t4.Nu / 2;
-            }
-            e2.translate(s3, n2), e2.textBaseline = "top", e2.font = t4.P, e2.scale(t4.pu, t4.pu), e2.fillText(t4.Gt, 0, t4.ju), e2.restore(), n2 += t4.Nu * t4.pu;
-        }
-    }
-    Vu(t3, e2) {
-        const i2 = this.$u(t3.font);
-        let s2 = i2.get(e2);
-        return void 0 === s2 && (s2 = t3.measureText(e2).width, i2.set(e2, s2)), s2;
-    }
-    $u(t3) {
-        let e2 = this.Eu.get(t3);
-        return void 0 === e2 && (e2 = /* @__PURE__ */ new Map(), this.Eu.set(t3, e2)), e2;
-    }
-}
-class Mn {
-    constructor(t3) {
-        this.vt = true, this.Wt = {
-            Ct: false,
-            D: "",
-            zu: [],
-            Fu: "center",
-            Wu: "center"
-        }, this.jt = new wn(this.Wt), this.$t = t3;
-    }
-    gt() {
-        this.vt = true;
-    }
-    Mt() {
-        return this.vt && (this.St(), this.vt = false), this.jt;
-    }
-    St() {
-        const t3 = this.$t.F(),
-            e2 = this.Wt;
-        e2.Ct = t3.visible, e2.Ct && (e2.D = t3.color, e2.Wu = t3.horzAlign, e2.Fu = t3.vertAlign, e2.zu = [{
-            Gt: t3.text,
-            P: Hl(t3.fontSize, t3.fontFamily, t3.fontStyle),
-            Nu: 1.2 * t3.fontSize,
-            ju: 0,
-            pu: 0
-        }]);
-    }
-}
-class Sn extends tt {
-    constructor(t3, e2) {
-        super(), this.un = e2, this.bn = new Mn(this);
-    }
-    Pn() {
-        return [];
-    }
-    Tn() {
-        return [this.bn];
-    }
-    F() {
-        return this.un;
-    }
-    Dn() {
-        this.bn.gt();
-    }
-}! function(t3) {
-    t3[t3.OnTouchEnd = 0] = "OnTouchEnd", t3[t3.OnNextTap = 1] = "OnNextTap";
-}(ac || (ac = {}));
-class xn {
-    constructor(t3, e2) {
-        this.Hu = [], this.Uu = [], this.vo = 0, this.qu = null, this.Yu = new Ll(), this.Xu = new Ll(), this.Zu = null, this.Ku = t3, this.un = e2, this.Gu = new class A {
-            constructor(t4) {
-                this.S = {
-                    k: 1,
-                    C: 5,
-                    T: NaN,
-                    P: "",
-                    R: "",
-                    D: "",
-                    B: "",
-                    A: 0,
-                    O: 0,
-                    L: 0,
-                    I: 0,
-                    V: 0
-                }, this.N = t4;
-            }
-            F() {
-                const t4 = this.S,
-                    e3 = this.W(),
-                    i2 = this.j();
-                return t4.T === e3 && t4.R === i2 || (t4.T = e3, t4.R = i2, t4.P = Hl(e3, i2), t4.I = 2.5 / 12 * e3, t4.A = t4.I, t4.O = e3 / 12 * t4.C, t4.L = e3 / 12 * t4.C, t4.V = 0), t4.D = this.$(), t4.B = this.H(), this.S;
-            }
-            $() {
-                return this.N.F().layout.textColor;
-            }
-            H() {
-                return this.N.U();
-            }
-            W() {
-                return this.N.F().layout.fontSize;
-            }
-            j() {
-                return this.N.F().layout.fontFamily;
-            }
-        }(this), this.wo = new gn(this, e2.timeScale, this.un.localization), this.bt = new nt(this, e2.crosshair), this.Ju = new Ri(e2.crosshair), this.Qu = new Sn(this, e2.watermark), this.tc(), this.Hu[0].Do(2e3), this.ic = this.nc(0), this.sc = this.nc(1);
-    }
-    dl() {
-        this.ec(et.ss());
-    }
-    Ch() {
-        this.ec(et.ns());
-    }
-    Cl() {
-        this.ec(new et(1));
-    }
-    fl(t3) {
-        const e2 = this.rc(t3);
-        this.ec(e2);
-    }
-    hc() {
-        return this.qu;
-    }
-    lc(t3) {
-        const e2 = this.qu;
-        this.qu = t3, null !== e2 && this.fl(e2.ac), null !== t3 && this.fl(t3.ac);
-    }
-    F() {
-        return this.un;
-    }
-    kh(t3) {
-        Ol(this.un, t3), this.Hu.forEach((e2) => e2.Co(t3)), void 0 !== t3.timeScale && this.wo.kh(t3.timeScale), void 0 !== t3.localization && this.wo.U_(t3.localization), (t3.leftPriceScale || t3.rightPriceScale) && this.Yu.m(), this.ic = this.nc(0), this.sc = this.nc(1), this.dl();
-    }
-    oc(t3, e2) {
-        if ("left" === t3)
-            return void this.kh({
-                leftPriceScale: e2
-            });
-        if ("right" === t3)
-            return void this.kh({
-                rightPriceScale: e2
-            });
-        const i2 = this._c(t3);
-        null !== i2 && (i2.Bt.kh(e2), this.Yu.m());
-    }
-    _c(t3) {
-        for (const e2 of this.Hu) {
-            const i2 = e2.To(t3);
-            if (null !== i2)
-                return {
-                    Ht: e2,
-                    Bt: i2
-                };
-        }
-        return null;
-    }
-    yt() {
-        return this.wo;
-    }
-    uc() {
-        return this.Hu;
-    }
-    cc() {
-        return this.Qu;
-    }
-    dc() {
-        return this.bt;
-    }
-    fc() {
-        return this.Xu;
-    }
-    vc(t3, e2) {
-        t3.Ha(e2), this.lu();
-    }
-    Bo(t3) {
-        this.vo = t3, this.wo.Bo(this.vo), this.Hu.forEach((e2) => e2.Bo(t3)), this.lu();
-    }
-    tc(t3) {
-        const e2 = new Ki(this.wo, this);
-        void 0 !== t3 ? this.Hu.splice(t3, 0, e2) : this.Hu.push(e2);
-        const i2 = void 0 === t3 ? this.Hu.length - 1 : t3,
-            s2 = et.ss();
-        return s2.Vn(i2, {
-            Nn: 0,
-            Fn: true
-        }), this.ec(s2), e2;
-    }
-    No(t3, e2, i2) {
-        t3.No(e2, i2);
-    }
-    Fo(t3, e2, i2) {
-        t3.Fo(e2, i2), this.pl(), this.ec(this.mc(t3, 2));
-    }
-    Wo(t3, e2) {
-        t3.Wo(e2), this.ec(this.mc(t3, 2));
-    }
-    jo(t3, e2, i2) {
-        e2.Va() || t3.jo(e2, i2);
-    }
-    $o(t3, e2, i2) {
-        e2.Va() || (t3.$o(e2, i2), this.pl(), this.ec(this.mc(t3, 2)));
-    }
-    Ho(t3, e2) {
-        e2.Va() || (t3.Ho(e2), this.ec(this.mc(t3, 2)));
-    }
-    qo(t3, e2) {
-        t3.qo(e2), this.ec(this.mc(t3, 2));
-    }
-    bc(t3) {
-        this.wo.ro(t3);
-    }
-    gc(t3, e2) {
-        const i2 = this.yt();
-        if (i2.Ni() || 0 === e2)
-            return;
-        const s2 = i2.$i();
-        t3 = Math.max(1, Math.min(t3, s2)), i2.pu(t3, e2), this.lu();
-    }
-    wc(t3) {
-        this.Mc(0), this.Sc(t3), this.xc();
-    }
-    yc(t3) {
-        this.wo.ho(t3), this.lu();
-    }
-    kc() {
-        this.wo.lo(), this.Ch();
-    }
-    Mc(t3) {
-        this.wo.ao(t3);
-    }
-    Sc(t3) {
-        this.wo.oo(t3), this.lu();
-    }
-    xc() {
-        this.wo._o(), this.Ch();
-    }
-    wt() {
-        return this.Uu;
-    }
-    Cc(t3, e2, i2, s2) {
-        this.bt.gn(t3, e2);
-        let n2 = NaN,
-            r2 = this.wo.ru(t3);
-        const o2 = this.wo.Vs();
-        null !== o2 && (r2 = Math.min(Math.max(o2.Ms(), r2), o2.ci()));
-        const a2 = s2.fn(),
-            l2 = a2.Tt();
-        null !== l2 && (n2 = a2.pn(e2, l2)), n2 = this.Ju.Wl(n2, r2, s2), this.bt.xn(r2, n2, s2), this.Cl(), this.Xu.m(this.bt.xt(), {
-            x: t3,
-            y: e2
-        }, i2);
-    }
-    Tc() {
-        this.dc().kn(), this.Cl(), this.Xu.m(null, null, null);
-    }
-    pl() {
-        const t3 = this.bt.Ht();
-        if (null !== t3) {
-            const e2 = this.bt.Mn(),
-                i2 = this.bt.Sn();
-            this.Cc(e2, i2, null, t3);
-        }
-        this.bt.Dn();
-    }
-    Pc(t3, e2, i2) {
-        const s2 = this.wo.vn(0);
-        void 0 !== e2 && void 0 !== i2 && this.wo.gt(e2, i2);
-        const n2 = this.wo.vn(0),
-            r2 = this.wo.eu(),
-            o2 = this.wo.Vs();
-        if (null !== o2 && null !== s2 && null !== n2) {
-            const e3 = o2.Ir(r2),
-                i3 = s2.u_ > n2.u_,
-                a2 = null !== t3 && t3 > r2 && !i3,
-                l2 = e3 && this.wo.F().shiftVisibleRangeOnNewBar;
-            if (a2 && !l2) {
-                const e4 = t3 - r2;
-                this.wo.Gn(this.wo.ou() - e4);
-            }
-        }
-        this.wo.fu(t3);
-    }
-    bl(t3) {
-        null !== t3 && t3.Xo();
-    }
-    Ke(t3) {
-        const e2 = this.Hu.find((e3) => e3.Ja().includes(t3));
-        return void 0 === e2 ? null : e2;
-    }
-    lu() {
-        this.Qu.Dn(), this.Hu.forEach((t3) => t3.Xo()), this.pl();
-    }
-    M() {
-        this.Hu.forEach((t3) => t3.M()), this.Hu.length = 0, this.un.localization.priceFormatter = void 0, this.un.localization.timeFormatter = void 0;
-    }
-    Rc() {
-        return this.Gu;
-    }
-    tr() {
-        return this.Gu.F();
-    }
-    Po() {
-        return this.Yu;
-    }
-    Dc(t3, e2) {
-        const i2 = this.Hu[0],
-            s2 = this.Bc(e2, t3, i2);
-        return this.Uu.push(s2), 1 === this.Uu.length ? this.dl() : this.Ch(), s2;
-    }
-    Ac(t3) {
-        const e2 = this.Ke(t3),
-            i2 = this.Uu.indexOf(t3);
-        wl(-1 !== i2, "Series not found"), this.Uu.splice(i2, 1), kl(e2).no(t3), t3.M && t3.M();
-    }
-    cl(t3, e2) {
-        const i2 = kl(this.Ke(t3));
-        i2.no(t3);
-        const s2 = this._c(e2);
-        if (null === s2) {
-            const s3 = t3.Zi();
-            i2.Qa(t3, e2, s3);
-        } else {
-            const n2 = s2.Ht === i2 ? t3.Zi() : void 0;
-            s2.Ht.Qa(t3, e2, n2);
-        }
-    }
-    Cu() {
-        const t3 = et.ns();
-        t3.$n(), this.ec(t3);
-    }
-    Oc(t3) {
-        const e2 = et.ns();
-        e2.qn(t3), this.ec(e2);
-    }
-    Zn() {
-        const t3 = et.ns();
-        t3.Zn(), this.ec(t3);
-    }
-    Kn(t3) {
-        const e2 = et.ns();
-        e2.Kn(t3), this.ec(e2);
-    }
-    Gn(t3) {
-        const e2 = et.ns();
-        e2.Gn(t3), this.ec(e2);
-    }
-    Yn(t3) {
-        const e2 = et.ns();
-        e2.Yn(t3), this.ec(e2);
-    }
-    Hn() {
-        const t3 = et.ns();
-        t3.Hn(), this.ec(t3);
-    }
-    Lc() {
-        return this.un.rightPriceScale.visible ? "right" : "left";
-    }
-    Ic() {
-        return this.sc;
-    }
-    U() {
-        return this.ic;
-    }
-    Lt(t3) {
-        const e2 = this.sc,
-            i2 = this.ic;
-        if (e2 === i2)
-            return e2;
-        if (t3 = Math.max(0, Math.min(100, Math.round(100 * t3))), null === this.Zu || this.Zu.bs !== i2 || this.Zu.gs !== e2)
-            this.Zu = {
-                bs: i2,
-                gs: e2,
-                Ec: /* @__PURE__ */ new Map()
-            };
-        else {
-            const e3 = this.Zu.Ec.get(t3);
-            if (void 0 !== e3)
-                return e3;
-        }
-        const s2 = function(t4, e3, i3) {
-            const [s3, n2, r2, o2] = Al(t4), [a2, l2, h2, c2] = Al(e3), u2 = [El(s3 + i3 * (a2 - s3)), El(n2 + i3 * (l2 - n2)), El(r2 + i3 * (h2 - r2)), Cl(o2 + i3 * (c2 - o2))];
-            return `rgba(${u2[0]}, ${u2[1]}, ${u2[2]}, ${u2[3]})`;
-        }(i2, e2, t3 / 100);
-        return this.Zu.Ec.set(t3, s2), s2;
-    }
-    mc(t3, e2) {
-        const i2 = new et(e2);
-        if (null !== t3) {
-            const s2 = this.Hu.indexOf(t3);
-            i2.Vn(s2, {
-                Nn: e2
-            });
-        }
-        return i2;
-    }
-    rc(t3, e2) {
-        return void 0 === e2 && (e2 = 2), this.mc(this.Ke(t3), e2);
-    }
-    ec(t3) {
-        this.Ku && this.Ku(t3), this.Hu.forEach((t4) => t4.Ko().Th().gt());
-    }
-    Bc(t3, e2, i2) {
-        const s2 = new Pi(this, t3, e2),
-            n2 = void 0 !== t3.priceScaleId ? t3.priceScaleId : this.Lc();
-        return i2.Qa(s2, n2), lh(n2) || s2.kh(t3), s2;
-    }
-    nc(t3) {
-        const e2 = this.un.layout;
-        return "gradient" === e2.background.type ? 0 === t3 ? e2.background.topColor : e2.background.bottomColor : e2.background.color;
-    }
-}
-
-function uc(t3) {
-    return !Fl(t3) && !$l(t3);
-}
-
-function dc(t3) {
-    return Fl(t3);
-}! function(t3) {
-    t3[t3.Disabled = 0] = "Disabled", t3[t3.Continuous = 1] = "Continuous", t3[t3.OnDataUpdate = 2] = "OnDataUpdate";
-}(lc || (lc = {})),
-function(t3) {
-    t3[t3.LastBar = 0] = "LastBar", t3[t3.LastVisible = 1] = "LastVisible";
-}(hc || (hc = {})),
-function(t3) {
-    t3.Solid = "solid", t3.VerticalGradient = "gradient";
-}(cc || (cc = {}));
-const fc = "undefined" != typeof window;
-
-function pc() {
-    return !!fc && window.navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
-}
-
-function mc() {
-    return !!fc && /iPhone|iPad|iPod/.test(window.navigator.platform);
-}
-
-function gc(t3) {
-    return t3 + t3 % 2;
-}
-
-function yc(t3, e2) {
-    return t3.zc - e2.zc;
-}
-
-function vc(t3, e2, i2) {
-    const s2 = (t3.zc - e2.zc) / (t3._t - e2._t);
-    return Math.sign(s2) * Math.min(Math.abs(s2), i2);
-}
-class An {
-    constructor(t3, e2, i2, s2) {
-        this.Vc = null, this.Nc = null, this.Fc = null, this.Wc = null, this.jc = null, this.$c = 0, this.Hc = 0, this.Uc = t3, this.qc = e2, this.Yc = i2, this.es = s2;
-    }
-    Xc(t3, e2) {
-        if (null !== this.Vc) {
-            if (this.Vc._t === e2)
-                return void(this.Vc.zc = t3);
-            if (Math.abs(this.Vc.zc - t3) < this.es)
-                return;
-        }
-        this.Wc = this.Fc, this.Fc = this.Nc, this.Nc = this.Vc, this.Vc = {
-            _t: e2,
-            zc: t3
-        };
-    }
-    pr(t3, e2) {
-        if (null === this.Vc || null === this.Nc)
-            return;
-        if (e2 - this.Vc._t > 50)
-            return;
-        let i2 = 0;
-        const s2 = vc(this.Vc, this.Nc, this.qc),
-            n2 = yc(this.Vc, this.Nc),
-            r2 = [s2],
-            o2 = [n2];
-        if (i2 += n2, null !== this.Fc) {
-            const t4 = vc(this.Nc, this.Fc, this.qc);
-            if (Math.sign(t4) === Math.sign(s2)) {
-                const e3 = yc(this.Nc, this.Fc);
-                if (r2.push(t4), o2.push(e3), i2 += e3, null !== this.Wc) {
-                    const t5 = vc(this.Fc, this.Wc, this.qc);
-                    if (Math.sign(t5) === Math.sign(s2)) {
-                        const e4 = yc(this.Fc, this.Wc);
-                        r2.push(t5), o2.push(e4), i2 += e4;
-                    }
-                }
-            }
-        }
-        let a2 = 0;
-        for (let t4 = 0; t4 < r2.length; ++t4)
-            a2 += o2[t4] / i2 * r2[t4];
-        Math.abs(a2) < this.Uc || (this.jc = {
-            zc: t3,
-            _t: e2
-        }, this.Hc = a2, this.$c = function(t4, e3) {
-            const i3 = Math.log(e3);
-            return Math.log(1 * i3 / -t4) / i3;
-        }(Math.abs(a2), this.Yc));
-    }
-    Mu(t3) {
-        const e2 = kl(this.jc),
-            i2 = t3 - e2._t;
-        return e2.zc + this.Hc * (Math.pow(this.Yc, i2) - 1) / Math.log(this.Yc);
-    }
-    wu(t3) {
-        return null === this.jc || this.Zc(t3) === this.$c;
-    }
-    Zc(t3) {
-        const e2 = t3 - kl(this.jc)._t;
-        return Math.min(e2, this.$c);
-    }
-}
-
-function bc(t3, e2) {
-    const i2 = kl(t3.ownerDocument).createElement("canvas");
-    t3.appendChild(i2);
-    const s2 = function(t4, e3) {
-        if ("device-pixel-content-box" === e3.type)
-            return new dl(t4, e3.transform, e3.options);
-        throw new Error("Unsupported binding target");
-    }(i2, {
-        type: "device-pixel-content-box",
-        options: {
-            allowResizeObserver: false
-        },
-        transform: (t4, e3) => ({
-            width: Math.max(t4.width, e3.width),
-            height: Math.max(t4.height, e3.height)
-        })
-    });
-    return s2.resizeCanvasElement(e2), s2;
-}
-class In {
-    constructor(t3, e2, i2) {
-        this.Kc = 0, this.Gc = null, this.Jc = {
-            st: Number.NEGATIVE_INFINITY,
-            et: Number.POSITIVE_INFINITY
-        }, this.Qc = 0, this.td = null, this.nd = {
-            st: Number.NEGATIVE_INFINITY,
-            et: Number.POSITIVE_INFINITY
-        }, this.sd = null, this.ed = false, this.rd = null, this.hd = null, this.ld = false, this.ad = false, this.od = false, this._d = null, this.ud = null, this.dd = null, this.fd = null, this.pd = null, this.vd = null, this.md = null, this.bd = 0, this.gd = false, this.wd = false, this.Md = false, this.Sd = 0, this.xd = null, this.yd = !mc(), this.kd = (t4) => {
-            this.Cd(t4);
-        }, this.Td = (t4) => {
-            if (this.Pd(t4)) {
-                const e3 = this.Rd(t4);
-                if (++this.Qc, this.td && this.Qc > 1) {
-                    const {
-                        Dd: i3
-                    } = this.Bd(xc(t4), this.nd);
-                    i3 < 30 && !this.od && this.Ad(e3, this.Ld.Od), this.Id();
-                }
-            } else {
-                const e3 = this.Rd(t4);
-                if (++this.Kc, this.Gc && this.Kc > 1) {
-                    const {
-                        Dd: i3
-                    } = this.Bd(xc(t4), this.Jc);
-                    i3 < 5 && !this.ad && this.Ed(e3, this.Ld.zd), this.Vd();
-                }
-            }
-        }, this.Nd = t3, this.Ld = e2, this.un = i2, this.Fd();
-    }
-    M() {
-        null !== this._d && (this._d(), this._d = null), null !== this.ud && (this.ud(), this.ud = null), null !== this.fd && (this.fd(), this.fd = null), null !== this.pd && (this.pd(), this.pd = null), null !== this.vd && (this.vd(), this.vd = null), null !== this.dd && (this.dd(), this.dd = null), this.Wd(), this.Vd();
-    }
-    jd(t3) {
-        this.fd && this.fd();
-        const e2 = this.$d.bind(this);
-        if (this.fd = () => {
-                this.Nd.removeEventListener("mousemove", e2);
-            }, this.Nd.addEventListener("mousemove", e2), this.Pd(t3))
-            return;
-        const i2 = this.Rd(t3);
-        this.Ed(i2, this.Ld.Hd), this.yd = true;
-    }
-    Vd() {
-        null !== this.Gc && clearTimeout(this.Gc), this.Kc = 0, this.Gc = null, this.Jc = {
-            st: Number.NEGATIVE_INFINITY,
-            et: Number.POSITIVE_INFINITY
-        };
-    }
-    Id() {
-        null !== this.td && clearTimeout(this.td), this.Qc = 0, this.td = null, this.nd = {
-            st: Number.NEGATIVE_INFINITY,
-            et: Number.POSITIVE_INFINITY
-        };
-    }
-    $d(t3) {
-        if (this.Md || null !== this.hd)
-            return;
-        if (this.Pd(t3))
-            return;
-        const e2 = this.Rd(t3);
-        this.Ed(e2, this.Ld.Ud), this.yd = true;
-    }
-    qd(t3) {
-        const e2 = Tc(t3.changedTouches, kl(this.xd));
-        if (null === e2)
-            return;
-        if (this.Sd = kc(t3), null !== this.md)
-            return;
-        if (this.wd)
-            return;
-        this.gd = true;
-        const i2 = this.Bd(xc(e2), kl(this.hd)),
-            {
-                Yd: s2,
-                Xd: n2,
-                Dd: r2
-            } = i2;
-        if (this.ld || !(r2 < 5)) {
-            if (!this.ld) {
-                const t4 = 0.5 * s2,
-                    e3 = n2 >= t4 && !this.un.Zd(),
-                    i3 = t4 > n2 && !this.un.Kd();
-                e3 || i3 || (this.wd = true), this.ld = true, this.od = true, this.Wd(), this.Id();
-            }
-            if (!this.wd) {
-                const i3 = this.Rd(t3, e2);
-                this.Ad(i3, this.Ld.Gd), wc(t3);
-            }
-        }
-    }
-    Jd(t3) {
-        if (0 !== t3.button)
-            return;
-        const e2 = this.Bd(xc(t3), kl(this.rd)),
-            {
-                Dd: i2
-            } = e2;
-        if (i2 >= 5 && (this.ad = true, this.Vd()), this.ad) {
-            const e3 = this.Rd(t3);
-            this.Ed(e3, this.Ld.Qd);
-        }
-    }
-    Bd(t3, e2) {
-        const i2 = Math.abs(e2.st - t3.st),
-            s2 = Math.abs(e2.et - t3.et);
-        return {
-            Yd: i2,
-            Xd: s2,
-            Dd: i2 + s2
-        };
-    }
-    tf(t3) {
-        let e2 = Tc(t3.changedTouches, kl(this.xd));
-        if (null === e2 && 0 === t3.touches.length && (e2 = t3.changedTouches[0]), null === e2)
-            return;
-        this.xd = null, this.Sd = kc(t3), this.Wd(), this.hd = null, this.vd && (this.vd(), this.vd = null);
-        const i2 = this.Rd(t3, e2);
-        if (this.Ad(i2, this.Ld.if), ++this.Qc, this.td && this.Qc > 1) {
-            const {
-                Dd: t4
-            } = this.Bd(xc(e2), this.nd);
-            t4 < 30 && !this.od && this.Ad(i2, this.Ld.Od), this.Id();
-        } else
-            this.od || (this.Ad(i2, this.Ld.nf), this.Ld.nf && wc(t3));
-        0 === this.Qc && wc(t3), 0 === t3.touches.length && this.ed && (this.ed = false, wc(t3));
-    }
-    Cd(t3) {
-        if (0 !== t3.button)
-            return;
-        const e2 = this.Rd(t3);
-        if (this.rd = null, this.Md = false, this.pd && (this.pd(), this.pd = null), pc() && this.Nd.ownerDocument.documentElement.removeEventListener("mouseleave", this.kd), !this.Pd(t3))
-            if (this.Ed(e2, this.Ld.sf), ++this.Kc, this.Gc && this.Kc > 1) {
-                const {
-                    Dd: i2
-                } = this.Bd(xc(t3), this.Jc);
-                i2 < 5 && !this.ad && this.Ed(e2, this.Ld.zd), this.Vd();
-            } else
-                this.ad || this.Ed(e2, this.Ld.ef);
-    }
-    Wd() {
-        null !== this.sd && (clearTimeout(this.sd), this.sd = null);
-    }
-    rf(t3) {
-        if (null !== this.xd)
-            return;
-        const e2 = t3.changedTouches[0];
-        this.xd = e2.identifier, this.Sd = kc(t3);
-        const i2 = this.Nd.ownerDocument.documentElement;
-        this.od = false, this.ld = false, this.wd = false, this.hd = xc(e2), this.vd && (this.vd(), this.vd = null);
-        {
-            const e3 = this.qd.bind(this),
-                s3 = this.tf.bind(this);
-            this.vd = () => {
-                i2.removeEventListener("touchmove", e3), i2.removeEventListener("touchend", s3);
-            }, i2.addEventListener("touchmove", e3, {
-                passive: false
-            }), i2.addEventListener("touchend", s3, {
-                passive: false
-            }), this.Wd(), this.sd = setTimeout(this.hf.bind(this, t3), 240);
-        }
-        const s2 = this.Rd(t3, e2);
-        this.Ad(s2, this.Ld.lf), this.td || (this.Qc = 0, this.td = setTimeout(this.Id.bind(this), 500), this.nd = xc(e2));
-    }
-    af(t3) {
-        if (0 !== t3.button)
-            return;
-        const e2 = this.Nd.ownerDocument.documentElement;
-        pc() && e2.addEventListener("mouseleave", this.kd), this.ad = false, this.rd = xc(t3), this.pd && (this.pd(), this.pd = null);
-        {
-            const t4 = this.Jd.bind(this),
-                i3 = this.Cd.bind(this);
-            this.pd = () => {
-                e2.removeEventListener("mousemove", t4), e2.removeEventListener("mouseup", i3);
-            }, e2.addEventListener("mousemove", t4), e2.addEventListener("mouseup", i3);
-        }
-        if (this.Md = true, this.Pd(t3))
-            return;
-        const i2 = this.Rd(t3);
-        this.Ed(i2, this.Ld._f), this.Gc || (this.Kc = 0, this.Gc = setTimeout(this.Vd.bind(this), 500), this.Jc = xc(t3));
-    }
-    Fd() {
-        this.Nd.addEventListener("mouseenter", this.jd.bind(this)), this.Nd.addEventListener("touchcancel", this.Wd.bind(this));
-        {
-            const t3 = this.Nd.ownerDocument,
-                e2 = (t4) => {
-                    this.Ld.uf && (t4.composed && this.Nd.contains(t4.composedPath()[0]) || t4.target && this.Nd.contains(t4.target) || this.Ld.uf());
-                };
-            this.ud = () => {
-                t3.removeEventListener("touchstart", e2);
-            }, this._d = () => {
-                t3.removeEventListener("mousedown", e2);
-            }, t3.addEventListener("mousedown", e2), t3.addEventListener("touchstart", e2, {
-                passive: true
-            });
-        }
-        mc() && (this.dd = () => {
-                this.Nd.removeEventListener("dblclick", this.Td);
-            }, this.Nd.addEventListener("dblclick", this.Td)), this.Nd.addEventListener("mouseleave", this.cf.bind(this)), this.Nd.addEventListener("touchstart", this.rf.bind(this), {
-                passive: true
-            }),
-            function(t3) {
-                fc && void 0 !== window.chrome && t3.addEventListener("mousedown", (t4) => {
-                    if (1 === t4.button)
-                        return t4.preventDefault(), false;
-                });
-            }(this.Nd), this.Nd.addEventListener("mousedown", this.af.bind(this)), this.df(), this.Nd.addEventListener("touchmove", () => {}, {
-                passive: false
-            });
-    }
-    df() {
-        void 0 === this.Ld.ff && void 0 === this.Ld.pf && void 0 === this.Ld.vf || (this.Nd.addEventListener("touchstart", (t3) => this.mf(t3.touches), {
-            passive: true
-        }), this.Nd.addEventListener("touchmove", (t3) => {
-            if (2 === t3.touches.length && null !== this.md && void 0 !== this.Ld.pf) {
-                const e2 = _c(t3.touches[0], t3.touches[1]) / this.bd;
-                this.Ld.pf(this.md, e2), wc(t3);
-            }
-        }, {
-            passive: false
-        }), this.Nd.addEventListener("touchend", (t3) => {
-            this.mf(t3.touches);
-        }));
-    }
-    mf(t3) {
-        1 === t3.length && (this.gd = false), 2 !== t3.length || this.gd || this.ed ? this.bf() : this.gf(t3);
-    }
-    gf(t3) {
-        const e2 = this.Nd.getBoundingClientRect() || {
-            left: 0,
-            top: 0
-        };
-        this.md = {
-            st: (t3[0].clientX - e2.left + (t3[1].clientX - e2.left)) / 2,
-            et: (t3[0].clientY - e2.top + (t3[1].clientY - e2.top)) / 2
-        }, this.bd = _c(t3[0], t3[1]), void 0 !== this.Ld.ff && this.Ld.ff(), this.Wd();
-    }
-    bf() {
-        null !== this.md && (this.md = null, void 0 !== this.Ld.vf && this.Ld.vf());
-    }
-    cf(t3) {
-        if (this.fd && this.fd(), this.Pd(t3))
-            return;
-        if (!this.yd)
-            return;
-        const e2 = this.Rd(t3);
-        this.Ed(e2, this.Ld.wf), this.yd = !mc();
-    }
-    hf(t3) {
-        const e2 = Tc(t3.touches, kl(this.xd));
-        if (null === e2)
-            return;
-        const i2 = this.Rd(t3, e2);
-        this.Ad(i2, this.Ld.Mf), this.od = true, this.ed = true;
-    }
-    Pd(t3) {
-        return t3.sourceCapabilities && void 0 !== t3.sourceCapabilities.firesTouchEvents ? t3.sourceCapabilities.firesTouchEvents : kc(t3) < this.Sd + 500;
-    }
-    Ad(t3, e2) {
-        e2 && e2.call(this.Ld, t3);
-    }
-    Ed(t3, e2) {
-        e2 && e2.call(this.Ld, t3);
-    }
-    Rd(t3, e2) {
-        const i2 = e2 || t3,
-            s2 = this.Nd.getBoundingClientRect() || {
-                left: 0,
-                top: 0
-            };
-        return {
-            clientX: i2.clientX,
-            clientY: i2.clientY,
-            pageX: i2.pageX,
-            pageY: i2.pageY,
-            screenX: i2.screenX,
-            screenY: i2.screenY,
-            localX: i2.clientX - s2.left,
-            localY: i2.clientY - s2.top,
-            ctrlKey: t3.ctrlKey,
-            altKey: t3.altKey,
-            shiftKey: t3.shiftKey,
-            metaKey: t3.metaKey,
-            Sf: !t3.type.startsWith("mouse") && "contextmenu" !== t3.type && "click" !== t3.type,
-            xf: t3.type,
-            yf: i2.target,
-            kf: t3.view,
-            Cf: () => {
-                "touchstart" !== t3.type && wc(t3);
-            }
-        };
-    }
-}
-
-function _c(t3, e2) {
-    const i2 = t3.clientX - e2.clientX,
-        s2 = t3.clientY - e2.clientY;
-    return Math.sqrt(i2 * i2 + s2 * s2);
-}
-
-function wc(t3) {
-    t3.cancelable && t3.preventDefault();
-}
-
-function xc(t3) {
-    return {
-        st: t3.pageX,
-        et: t3.pageY
-    };
-}
-
-function kc(t3) {
-    return t3.timeStamp || performance.now();
-}
-
-function Tc(t3, e2) {
-    for (let i2 = 0; i2 < t3.length; ++i2)
-        if (t3[i2].identifier === e2)
-            return t3[i2];
-    return null;
-}
-class Wn {
-    constructor(t3, e2, i2, s2) {
-        this.zi = null, this.Tf = null, this.Pf = false, this.Rf = new Ut(200), this.zr = null, this.Df = 0, this.Bf = false, this.Af = () => {
-            this.Bf || this.tn.Of().Ut().Ch();
-        }, this.Lf = () => {
-            this.Bf || this.tn.Of().Ut().Ch();
-        }, this.tn = t3, this.un = e2, this.Ba = e2.layout, this.Gu = i2, this.If = "left" === s2, this.Ef = document.createElement("div"), this.Ef.style.height = "100%", this.Ef.style.overflow = "hidden", this.Ef.style.width = "25px", this.Ef.style.left = "0", this.Ef.style.position = "relative", this.zf = bc(this.Ef, hl({
-            width: 16,
-            height: 16
-        })), this.zf.subscribeSuggestedBitmapSizeChanged(this.Af);
-        const n2 = this.zf.canvasElement;
-        n2.style.position = "absolute", n2.style.zIndex = "1", n2.style.left = "0", n2.style.top = "0", this.Vf = bc(this.Ef, hl({
-            width: 16,
-            height: 16
-        })), this.Vf.subscribeSuggestedBitmapSizeChanged(this.Lf);
-        const r2 = this.Vf.canvasElement;
-        r2.style.position = "absolute", r2.style.zIndex = "2", r2.style.left = "0", r2.style.top = "0";
-        const o2 = {
-            _f: this.Nf.bind(this),
-            lf: this.Nf.bind(this),
-            Qd: this.Ff.bind(this),
-            Gd: this.Ff.bind(this),
-            uf: this.Wf.bind(this),
-            sf: this.jf.bind(this),
-            if: this.jf.bind(this),
-            zd: this.$f.bind(this),
-            Od: this.$f.bind(this),
-            Hd: this.Hf.bind(this),
-            wf: this.Uf.bind(this)
-        };
-        this.qf = new In(this.Vf.canvasElement, o2, {
-            Zd: () => false,
-            Kd: () => true
-        });
-    }
-    M() {
-        this.qf.M(), this.Vf.unsubscribeSuggestedBitmapSizeChanged(this.Lf), this.Vf.dispose(), this.zf.unsubscribeSuggestedBitmapSizeChanged(this.Af), this.zf.dispose(), null !== this.zi && this.zi.eo().v(this), this.zi = null;
-    }
-    Yf() {
-        return this.Ef;
-    }
-    T() {
-        return this.Ba.fontSize;
-    }
-    Xf() {
-        const t3 = this.Gu.F();
-        return this.zr !== t3.P && (this.Rf.Fe(), this.zr = t3.P), t3;
-    }
-    Zf() {
-        if (null === this.zi)
-            return 0;
-        let t3 = 0;
-        const e2 = this.Xf(),
-            i2 = kl(this.zf.canvasElement.getContext("2d"));
-        i2.save();
-        const s2 = this.zi.Jl();
-        i2.font = this.Kf(), s2.length > 0 && (t3 = Math.max(this.Rf.Si(i2, s2[0].ua), this.Rf.Si(i2, s2[s2.length - 1].ua)));
-        const n2 = this.Gf();
-        for (let e3 = n2.length; e3--;) {
-            const s3 = this.Rf.Si(i2, n2[e3].Gt());
-            s3 > t3 && (t3 = s3);
-        }
-        const r2 = this.zi.Tt();
-        if (null !== r2 && null !== this.Tf) {
-            const e3 = this.zi.pn(1, r2),
-                s3 = this.zi.pn(this.Tf.height - 2, r2);
-            t3 = Math.max(t3, this.Rf.Si(i2, this.zi.Fi(Math.floor(Math.min(e3, s3)) + 0.11111111111111, r2)), this.Rf.Si(i2, this.zi.Fi(Math.ceil(Math.max(e3, s3)) - 0.11111111111111, r2)));
-        }
-        i2.restore();
-        const o2 = t3 || 34;
-        return gc(Math.ceil(e2.k + e2.C + e2.O + e2.L + 5 + o2));
-    }
-    Jf(t3) {
-        null !== this.Tf && cl(this.Tf, t3) || (this.Tf = t3, this.Bf = true, this.zf.resizeCanvasElement(t3), this.Vf.resizeCanvasElement(t3), this.Bf = false, this.Ef.style.width = `${t3.width}px`, this.Ef.style.height = `${t3.height}px`);
-    }
-    Qf() {
-        return kl(this.Tf).width;
-    }
-    Gi(t3) {
-        this.zi !== t3 && (null !== this.zi && this.zi.eo().v(this), this.zi = t3, t3.eo().l(this.Sa.bind(this), this));
-    }
-    Bt() {
-        return this.zi;
-    }
-    Fe() {
-        const t3 = this.tn.tp();
-        this.tn.Of().Ut().qo(t3, kl(this.Bt()));
-    }
-    ip(t3) {
-        if (null === this.Tf)
-            return;
-        if (1 !== t3) {
-            this.np(), this.zf.applySuggestedBitmapSize();
-            const t4 = vl(this.zf);
-            null !== t4 && (t4.useBitmapCoordinateSpace((t5) => {
-                this.sp(t5), this.ye(t5);
-            }), this.ep(t4), this.rp(t4));
-        }
-        this.Vf.applySuggestedBitmapSize();
-        const e2 = vl(this.Vf);
-        null !== e2 && (e2.useBitmapCoordinateSpace(({
-            context: t4,
-            bitmapSize: e3
-        }) => {
-            t4.clearRect(0, 0, e3.width, e3.height);
-        }), this.hp(e2));
-    }
-    lp() {
-        return this.zf.bitmapSize;
-    }
-    ap(t3, e2, i2) {
-        const s2 = this.lp();
-        s2.width > 0 && s2.height > 0 && t3.drawImage(this.zf.canvasElement, e2, i2);
-    }
-    gt() {
-        var t3;
-        null === (t3 = this.zi) || void 0 === t3 || t3.Jl();
-    }
-    Nf(t3) {
-        if (null === this.zi || this.zi.Ni() || !this.un.handleScale.axisPressedMouseMove.price)
-            return;
-        const e2 = this.tn.Of().Ut(),
-            i2 = this.tn.tp();
-        this.Pf = true, e2.No(i2, this.zi, t3.localY);
-    }
-    Ff(t3) {
-        if (null === this.zi || !this.un.handleScale.axisPressedMouseMove.price)
-            return;
-        const e2 = this.tn.Of().Ut(),
-            i2 = this.tn.tp(),
-            s2 = this.zi;
-        e2.Fo(i2, s2, t3.localY);
-    }
-    Wf() {
-        if (null === this.zi || !this.un.handleScale.axisPressedMouseMove.price)
-            return;
-        const t3 = this.tn.Of().Ut(),
-            e2 = this.tn.tp(),
-            i2 = this.zi;
-        this.Pf && (this.Pf = false, t3.Wo(e2, i2));
-    }
-    jf(t3) {
-        if (null === this.zi || !this.un.handleScale.axisPressedMouseMove.price)
-            return;
-        const e2 = this.tn.Of().Ut(),
-            i2 = this.tn.tp();
-        this.Pf = false, e2.Wo(i2, this.zi);
-    }
-    $f(t3) {
-        this.un.handleScale.axisDoubleClickReset.price && this.Fe();
-    }
-    Hf(t3) {
-        null !== this.zi && (!this.tn.Of().Ut().F().handleScale.axisPressedMouseMove.price || this.zi.th() || this.zi.Na() || this.op(1));
-    }
-    Uf(t3) {
-        this.op(0);
-    }
-    Gf() {
-        const t3 = [],
-            e2 = null === this.zi ? void 0 : this.zi;
-        return ((i2) => {
-            for (let s2 = 0; s2 < i2.length; ++s2) {
-                const n2 = i2[s2].Pn(this.tn.tp(), e2);
-                for (let e3 = 0; e3 < n2.length; e3++)
-                    t3.push(n2[e3]);
-            }
-        })(this.tn.tp().Ja()), t3;
-    }
-    sp({
-        context: t3,
-        bitmapSize: e2
-    }) {
-        const {
-            width: i2,
-            height: s2
-        } = e2, n2 = this.tn.tp().Ut(), r2 = n2.U(), o2 = n2.Ic();
-        r2 === o2 ? Jl(t3, 0, 0, i2, s2, r2) : ih(t3, 0, 0, i2, s2, r2, o2);
-    }
-    ye({
-        context: t3,
-        bitmapSize: e2,
-        horizontalPixelRatio: i2
-    }) {
-        if (null === this.Tf || null === this.zi || !this.zi.F().borderVisible)
-            return;
-        t3.fillStyle = this.zi.F().borderColor;
-        const s2 = Math.max(1, Math.floor(this.Xf().k * i2));
-        let n2;
-        n2 = this.If ? e2.width - s2 : 0, t3.fillRect(n2, 0, s2, e2.height);
-    }
-    ep(t3) {
-        if (null === this.Tf || null === this.zi)
-            return;
-        const e2 = this.zi.Jl(),
-            i2 = this.zi.F(),
-            s2 = this.Xf(),
-            n2 = this.If ? this.Tf.width - s2.C : 0;
-        i2.borderVisible && i2.ticksVisible && t3.useBitmapCoordinateSpace(({
-            context: t4,
-            horizontalPixelRatio: r2,
-            verticalPixelRatio: o2
-        }) => {
-            t4.fillStyle = i2.borderColor;
-            const a2 = Math.max(1, Math.floor(o2)),
-                l2 = Math.floor(0.5 * o2),
-                h2 = Math.round(s2.C * r2);
-            t4.beginPath();
-            for (const i3 of e2)
-                t4.rect(Math.floor(n2 * r2), Math.round(i3.Yl * o2) - l2, h2, a2);
-            t4.fill();
-        }), t3.useMediaCoordinateSpace(({
-            context: t4
-        }) => {
-            var r2;
-            t4.font = this.Kf(), t4.fillStyle = null !== (r2 = i2.textColor) && void 0 !== r2 ? r2 : this.Ba.textColor, t4.textAlign = this.If ? "right" : "left", t4.textBaseline = "middle";
-            const o2 = this.If ? Math.round(n2 - s2.O) : Math.round(n2 + s2.C + s2.O),
-                a2 = e2.map((e3) => this.Rf.Mi(t4, e3.ua));
-            for (let i3 = e2.length; i3--;) {
-                const s3 = e2[i3];
-                t4.fillText(s3.ua, o2, s3.Yl + a2[i3]);
-            }
-        });
-    }
-    np() {
-        if (null === this.Tf || null === this.zi)
-            return;
-        let t3 = this.Tf.height / 2;
-        const e2 = [],
-            i2 = this.zi.Ja().slice(),
-            s2 = this.tn.tp(),
-            n2 = this.Xf();
-        this.zi === s2.Je() && this.tn.tp().Ja().forEach((t4) => {
-            s2.Ge(t4) && i2.push(t4);
-        });
-        const r2 = this.zi.jl()[0],
-            o2 = this.zi;
-        i2.forEach((i3) => {
-            const n3 = i3.Pn(s2, o2);
-            n3.forEach((t4) => {
-                t4.Ai(null), t4.Oi() && e2.push(t4);
-            }), r2 === i3 && n3.length > 0 && (t3 = n3[0].yi());
-        }), e2.forEach((t4) => t4.Ai(t4.yi())), this.zi.F().alignLabels && this._p(e2, n2, t3);
-    }
-    _p(t3, e2, i2) {
-        if (null === this.Tf)
-            return;
-        const s2 = t3.filter((t4) => t4.yi() <= i2),
-            n2 = t3.filter((t4) => t4.yi() > i2);
-        s2.sort((t4, e3) => e3.yi() - t4.yi()), s2.length && n2.length && n2.push(s2[0]), n2.sort((t4, e3) => t4.yi() - e3.yi());
-        for (const i3 of t3) {
-            const t4 = Math.floor(i3.It(e2) / 2),
-                s3 = i3.yi();
-            s3 > -t4 && s3 < t4 && i3.Ai(t4), s3 > this.Tf.height - t4 && s3 < this.Tf.height + t4 && i3.Ai(this.Tf.height - t4);
-        }
-        for (let t4 = 1; t4 < s2.length; t4++) {
-            const i3 = s2[t4],
-                n3 = s2[t4 - 1],
-                r2 = n3.It(e2, false),
-                o2 = i3.yi(),
-                a2 = n3.Bi();
-            o2 > a2 - r2 && i3.Ai(a2 - r2);
-        }
-        for (let t4 = 1; t4 < n2.length; t4++) {
-            const i3 = n2[t4],
-                s3 = n2[t4 - 1],
-                r2 = s3.It(e2, true),
-                o2 = i3.yi(),
-                a2 = s3.Bi();
-            o2 < a2 + r2 && i3.Ai(a2 + r2);
-        }
-    }
-    rp(t3) {
-        if (null === this.Tf)
-            return;
-        const e2 = this.Gf(),
-            i2 = this.Xf(),
-            s2 = this.If ? "right" : "left";
-        e2.forEach((e3) => {
-            e3.Li() && e3.Mt(kl(this.zi)).X(t3, i2, this.Rf, s2);
-        });
-    }
-    hp(t3) {
-        if (null === this.Tf || null === this.zi)
-            return;
-        const e2 = this.tn.Of().Ut(),
-            i2 = [],
-            s2 = this.tn.tp(),
-            n2 = e2.dc().Pn(s2, this.zi);
-        n2.length && i2.push(n2);
-        const r2 = this.Xf(),
-            o2 = this.If ? "right" : "left";
-        i2.forEach((e3) => {
-            e3.forEach((e4) => {
-                e4.Mt(kl(this.zi)).X(t3, r2, this.Rf, o2);
-            });
-        });
-    }
-    op(t3) {
-        this.Ef.style.cursor = 1 === t3 ? "ns-resize" : "default";
-    }
-    Sa() {
-        const t3 = this.Zf();
-        this.Df < t3 && this.tn.Of().Ut().dl(), this.Df = t3;
-    }
-    Kf() {
-        return Hl(this.Ba.fontSize, this.Ba.fontFamily);
-    }
-}
-
-function Sc(t3, e2, i2, s2) {
-    t3.K && t3.K(e2, i2, s2);
-}
-
-function Ec(t3, e2, i2, s2) {
-    t3.X(e2, i2, s2);
-}
-
-function Cc(t3, e2) {
-    return t3.Tn(e2);
-}
-
-function Ic(t3, e2) {
-    return t3.Ji(e2);
-}
-
-function Mc(t3, e2) {
-    return void 0 !== t3.kl ? t3.kl(e2) : [];
-}
-class Yn {
-    constructor(t3, e2) {
-        this.Tf = hl({
-            width: 0,
-            height: 0
-        }), this.up = null, this.cp = null, this.dp = null, this.fp = false, this.pp = new Ll(), this.vp = 0, this.mp = false, this.bp = null, this.gp = false, this.wp = null, this.Mp = null, this.Bf = false, this.Af = () => {
-            this.Bf || null === this.Sp || this.Hi().Ch();
-        }, this.Lf = () => {
-            this.Bf || null === this.Sp || this.Hi().Ch();
-        }, this.xp = t3, this.Sp = e2, this.Sp.Zo().l(this.yp.bind(this), this, true), this.kp = document.createElement("td"), this.kp.style.padding = "0", this.kp.style.position = "relative";
-        const i2 = document.createElement("div");
-        i2.style.width = "100%", i2.style.height = "100%", i2.style.position = "relative", i2.style.overflow = "hidden", this.Cp = document.createElement("td"), this.Cp.style.padding = "0", this.Tp = document.createElement("td"), this.Tp.style.padding = "0", this.kp.appendChild(i2), this.zf = bc(i2, hl({
-            width: 16,
-            height: 16
-        })), this.zf.subscribeSuggestedBitmapSizeChanged(this.Af);
-        const s2 = this.zf.canvasElement;
-        s2.style.position = "absolute", s2.style.zIndex = "1", s2.style.left = "0", s2.style.top = "0", this.Vf = bc(i2, hl({
-            width: 16,
-            height: 16
-        })), this.Vf.subscribeSuggestedBitmapSizeChanged(this.Lf);
-        const n2 = this.Vf.canvasElement;
-        n2.style.position = "absolute", n2.style.zIndex = "2", n2.style.left = "0", n2.style.top = "0", this.Pp = document.createElement("tr"), this.Pp.appendChild(this.Cp), this.Pp.appendChild(this.kp), this.Pp.appendChild(this.Tp), this.Rp(), this.qf = new In(this.Vf.canvasElement, this, {
-            Zd: () => null === this.bp && !this.xp.F().handleScroll.vertTouchDrag,
-            Kd: () => null === this.bp && !this.xp.F().handleScroll.horzTouchDrag
-        });
-    }
-    M() {
-        null !== this.up && this.up.M(), null !== this.cp && this.cp.M(), this.Vf.unsubscribeSuggestedBitmapSizeChanged(this.Lf), this.Vf.dispose(), this.zf.unsubscribeSuggestedBitmapSizeChanged(this.Af), this.zf.dispose(), null !== this.Sp && this.Sp.Zo().v(this), this.qf.M();
-    }
-    tp() {
-        return kl(this.Sp);
-    }
-    Dp(t3) {
-        null !== this.Sp && this.Sp.Zo().v(this), this.Sp = t3, null !== this.Sp && this.Sp.Zo().l(Yn.prototype.yp.bind(this), this, true), this.Rp();
-    }
-    Of() {
-        return this.xp;
-    }
-    Yf() {
-        return this.Pp;
-    }
-    Rp() {
-        if (null !== this.Sp && (this.Bp(), 0 !== this.Hi().wt().length)) {
-            if (null !== this.up) {
-                const t3 = this.Sp.zo();
-                this.up.Gi(kl(t3));
-            }
-            if (null !== this.cp) {
-                const t3 = this.Sp.Vo();
-                this.cp.Gi(kl(t3));
-            }
-        }
-    }
-    Ap() {
-        null !== this.up && this.up.gt(), null !== this.cp && this.cp.gt();
-    }
-    Ro() {
-        return null !== this.Sp ? this.Sp.Ro() : 0;
-    }
-    Do(t3) {
-        this.Sp && this.Sp.Do(t3);
-    }
-    Hd(t3) {
-        if (!this.Sp)
-            return;
-        this.Op();
-        const e2 = t3.localX,
-            i2 = t3.localY;
-        this.Lp(e2, i2, t3);
-    }
-    _f(t3) {
-        this.Op(), this.Ip(), this.Lp(t3.localX, t3.localY, t3);
-    }
-    Ud(t3) {
-        if (!this.Sp)
-            return;
-        this.Op();
-        const e2 = t3.localX,
-            i2 = t3.localY;
-        this.Lp(e2, i2, t3);
-        const s2 = this.ir(e2, i2);
-        this.Hi().lc(s2 && {
-            ac: s2.ac,
-            Ep: s2.Ep
-        });
-    }
-    ef(t3) {
-        null !== this.Sp && (this.Op(), this.zp(t3));
-    }
-    Qd(t3) {
-        this.Op(), this.Vp(t3), this.Lp(t3.localX, t3.localY, t3);
-    }
-    sf(t3) {
-        null !== this.Sp && (this.Op(), this.mp = false, this.Np(t3));
-    }
-    nf(t3) {
-        null !== this.Sp && this.zp(t3);
-    }
-    Mf(t3) {
-        if (this.mp = true, null === this.bp) {
-            const e2 = {
-                x: t3.localX,
-                y: t3.localY
-            };
-            this.Fp(e2, e2, t3);
-        }
-    }
-    wf(t3) {
-        null !== this.Sp && (this.Op(), this.Sp.Ut().lc(null), this.Wp());
-    }
-    jp() {
-        return this.pp;
-    }
-    ff() {
-        this.vp = 1, this.Hi().Hn();
-    }
-    pf(t3, e2) {
-        if (!this.xp.F().handleScale.pinch)
-            return;
-        const i2 = 5 * (e2 - this.vp);
-        this.vp = e2, this.Hi().gc(t3.st, i2);
-    }
-    lf(t3) {
-        if (this.mp = false, this.gp = null !== this.bp, this.Ip(), null !== this.bp) {
-            const e2 = this.Hi().dc();
-            this.wp = {
-                x: e2.Xt(),
-                y: e2.Zt()
-            }, this.bp = {
-                x: t3.localX,
-                y: t3.localY
-            };
-        }
-    }
-    Gd(t3) {
-        if (null === this.Sp)
-            return;
-        const e2 = t3.localX,
-            i2 = t3.localY;
-        if (null === this.bp)
-            this.Vp(t3);
-        else {
-            this.gp = false;
-            const s2 = kl(this.wp),
-                n2 = s2.x + (e2 - this.bp.x),
-                r2 = s2.y + (i2 - this.bp.y);
-            this.Lp(n2, r2, t3);
-        }
-    }
-    if (t3) {
-        0 === this.Of().F().trackingMode.exitMode && (this.gp = true), this.$p(), this.Np(t3);
-    }
-    ir(t3, e2) {
-        const i2 = this.Sp;
-        if (null === i2)
-            return null;
-        const s2 = i2.Ja();
-        for (const n2 of s2) {
-            const s3 = this.Hp(n2.Tn(i2), t3, e2);
-            if (null !== s3)
-                return {
-                    ac: n2,
-                    kf: s3.kf,
-                    Ep: s3.Ep
-                };
-        }
-        return null;
-    }
-    Up(t3, e2) {
-        kl("left" === e2 ? this.up : this.cp).Jf(hl({
-            width: t3,
-            height: this.Tf.height
-        }));
-    }
-    qp() {
-        return this.Tf;
-    }
-    Jf(t3) {
-        cl(this.Tf, t3) || (this.Tf = t3, this.Bf = true, this.zf.resizeCanvasElement(t3), this.Vf.resizeCanvasElement(t3), this.Bf = false, this.kp.style.width = t3.width + "px", this.kp.style.height = t3.height + "px");
-    }
-    Yp() {
-        const t3 = kl(this.Sp);
-        t3.Eo(t3.zo()), t3.Eo(t3.Vo());
-        for (const e2 of t3.jl())
-            if (t3.Ge(e2)) {
-                const i2 = e2.Bt();
-                null !== i2 && t3.Eo(i2), e2.Dn();
-            }
-    }
-    lp() {
-        return this.zf.bitmapSize;
-    }
-    ap(t3, e2, i2) {
-        const s2 = this.lp();
-        s2.width > 0 && s2.height > 0 && t3.drawImage(this.zf.canvasElement, e2, i2);
-    }
-    ip(t3) {
-        if (0 === t3)
-            return;
-        if (null === this.Sp)
-            return;
-        if (t3 > 1 && this.Yp(), null !== this.up && this.up.ip(t3), null !== this.cp && this.cp.ip(t3), 1 !== t3) {
-            this.zf.applySuggestedBitmapSize();
-            const t4 = vl(this.zf);
-            null !== t4 && (t4.useBitmapCoordinateSpace((t5) => {
-                this.sp(t5);
-            }), this.Sp && (this.Xp(t4), this.Zp(t4), this.Kp(t4, Cc), this.Kp(t4, Ic)));
-        }
-        this.Vf.applySuggestedBitmapSize();
-        const e2 = vl(this.Vf);
-        null !== e2 && (e2.useBitmapCoordinateSpace(({
-            context: t4,
-            bitmapSize: e3
-        }) => {
-            t4.clearRect(0, 0, e3.width, e3.height);
-        }), this.Kp(e2, Mc), this.Gp(e2));
-    }
-    Jp() {
-        return this.up;
-    }
-    Qp() {
-        return this.cp;
-    }
-    yp() {
-        null !== this.Sp && this.Sp.Zo().v(this), this.Sp = null;
-    }
-    zp(t3) {
-        const e2 = t3.localX,
-            i2 = t3.localY;
-        this.pp.g() && this.pp.m(this.Hi().yt().ru(e2), {
-            x: e2,
-            y: i2
-        }, t3);
-    }
-    sp({
-        context: t3,
-        bitmapSize: e2
-    }) {
-        const {
-            width: i2,
-            height: s2
-        } = e2, n2 = this.Hi(), r2 = n2.U(), o2 = n2.Ic();
-        r2 === o2 ? Jl(t3, 0, 0, i2, s2, o2) : ih(t3, 0, 0, i2, s2, r2, o2);
-    }
-    Xp(t3) {
-        const e2 = kl(this.Sp).Ko().Th().Mt();
-        null !== e2 && e2.X(t3, false);
-    }
-    Zp(t3) {
-        const e2 = this.Hi().cc();
-        this.tv(t3, Cc, Sc, e2), this.tv(t3, Cc, Ec, e2);
-    }
-    Gp(t3) {
-        this.tv(t3, Cc, Ec, this.Hi().dc());
-    }
-    Kp(t3, e2) {
-        const i2 = kl(this.Sp).Ja();
-        for (const s2 of i2)
-            this.tv(t3, e2, Sc, s2);
-        for (const s2 of i2)
-            this.tv(t3, e2, Ec, s2);
-    }
-    tv(t3, e2, i2, s2) {
-        const n2 = kl(this.Sp),
-            r2 = e2(s2, n2),
-            o2 = n2.Ut().hc(),
-            a2 = null !== o2 && o2.ac === s2,
-            l2 = null !== o2 && a2 && void 0 !== o2.Ep ? o2.Ep.sr : void 0;
-        for (const e3 of r2) {
-            const s3 = e3.Mt();
-            null !== s3 && i2(s3, t3, a2, l2);
-        }
-    }
-    Hp(t3, e2, i2) {
-        for (const s2 of t3) {
-            const t4 = s2.Mt();
-            if (null !== t4 && t4.ir) {
-                const n2 = t4.ir(e2, i2);
-                if (null !== n2)
-                    return {
-                        kf: s2,
-                        Ep: n2
-                    };
-            }
-        }
-        return null;
-    }
-    Bp() {
-        if (null === this.Sp)
-            return;
-        const t3 = this.xp,
-            e2 = this.Sp.zo().F().visible,
-            i2 = this.Sp.Vo().F().visible;
-        e2 || null === this.up || (this.Cp.removeChild(this.up.Yf()), this.up.M(), this.up = null), i2 || null === this.cp || (this.Tp.removeChild(this.cp.Yf()), this.cp.M(), this.cp = null);
-        const s2 = t3.Ut().Rc();
-        e2 && null === this.up && (this.up = new Wn(this, t3.F(), s2, "left"), this.Cp.appendChild(this.up.Yf())), i2 && null === this.cp && (this.cp = new Wn(this, t3.F(), s2, "right"), this.Tp.appendChild(this.cp.Yf()));
-    }
-    iv(t3) {
-        return t3.Sf && this.mp || null !== this.bp;
-    }
-    nv(t3) {
-        return Math.max(0, Math.min(t3, this.Tf.width - 1));
-    }
-    sv(t3) {
-        return Math.max(0, Math.min(t3, this.Tf.height - 1));
-    }
-    Lp(t3, e2, i2) {
-        this.Hi().Cc(this.nv(t3), this.sv(e2), i2, kl(this.Sp));
-    }
-    Wp() {
-        this.Hi().Tc();
-    }
-    $p() {
-        this.gp && (this.bp = null, this.Wp());
-    }
-    Fp(t3, e2, i2) {
-        this.bp = t3, this.gp = false, this.Lp(e2.x, e2.y, i2);
-        const s2 = this.Hi().dc();
-        this.wp = {
-            x: s2.Xt(),
-            y: s2.Zt()
-        };
-    }
-    Hi() {
-        return this.xp.Ut();
-    }
-    Np(t3) {
-        if (!this.fp)
-            return;
-        const e2 = this.Hi(),
-            i2 = this.tp();
-        if (e2.Ho(i2, i2.fn()), this.dp = null, this.fp = false, e2.xc(), null !== this.Mp) {
-            const t4 = performance.now(),
-                i3 = e2.yt();
-            this.Mp.pr(i3.ou(), t4), this.Mp.wu(t4) || e2.Yn(this.Mp);
-        }
-    }
-    Op() {
-        this.bp = null;
-    }
-    Ip() {
-        if (this.Sp) {
-            if (this.Hi().Hn(), document.activeElement !== document.body && document.activeElement !== document.documentElement)
-                kl(document.activeElement).blur();
-            else {
-                const t3 = document.getSelection();
-                null !== t3 && t3.removeAllRanges();
-            }!this.Sp.fn().Ni() && this.Hi().yt().Ni();
-        }
-    }
-    Vp(t3) {
-        if (null === this.Sp)
-            return;
-        const e2 = this.Hi(),
-            i2 = e2.yt();
-        if (i2.Ni())
-            return;
-        const s2 = this.xp.F(),
-            n2 = s2.handleScroll,
-            r2 = s2.kineticScroll;
-        if ((!n2.pressedMouseMove || t3.Sf) && (!n2.horzTouchDrag && !n2.vertTouchDrag || !t3.Sf))
-            return;
-        const o2 = this.Sp.fn(),
-            a2 = performance.now();
-        if (null !== this.dp || this.iv(t3) || (this.dp = {
-                x: t3.clientX,
-                y: t3.clientY,
-                u_: a2,
-                ev: t3.localX,
-                rv: t3.localY
-            }), null !== this.dp && !this.fp && (this.dp.x !== t3.clientX || this.dp.y !== t3.clientY)) {
-            if (t3.Sf && r2.touch || !t3.Sf && r2.mouse) {
-                const t4 = i2.Ks();
-                this.Mp = new An(0.2 / t4, 7 / t4, 0.997, 15 / t4), this.Mp.Xc(i2.ou(), this.dp.u_);
-            } else
-                this.Mp = null;
-            o2.Ni() || e2.jo(this.Sp, o2, t3.localY), e2.Mc(t3.localX), this.fp = true;
-        }
-        this.fp && (o2.Ni() || e2.$o(this.Sp, o2, t3.localY), e2.Sc(t3.localX), null !== this.Mp && this.Mp.Xc(i2.ou(), a2));
-    }
-}
-class Xn {
-    constructor(t3, e2, i2, s2, n2) {
-        this.vt = true, this.Tf = hl({
-            width: 0,
-            height: 0
-        }), this.Af = () => this.ip(3), this.If = "left" === t3, this.Gu = i2.Rc, this.un = e2, this.hv = s2, this.lv = n2, this.Ef = document.createElement("div"), this.Ef.style.width = "25px", this.Ef.style.height = "100%", this.Ef.style.overflow = "hidden", this.zf = bc(this.Ef, hl({
-            width: 16,
-            height: 16
-        })), this.zf.subscribeSuggestedBitmapSizeChanged(this.Af);
-    }
-    M() {
-        this.zf.unsubscribeSuggestedBitmapSizeChanged(this.Af), this.zf.dispose();
-    }
-    Yf() {
-        return this.Ef;
-    }
-    qp() {
-        return this.Tf;
-    }
-    Jf(t3) {
-        cl(this.Tf, t3) || (this.Tf = t3, this.zf.resizeCanvasElement(t3), this.Ef.style.width = `${t3.width}px`, this.Ef.style.height = `${t3.height}px`, this.vt = true);
-    }
-    ip(t3) {
-        if (t3 < 3 && !this.vt)
-            return;
-        if (0 === this.Tf.width || 0 === this.Tf.height)
-            return;
-        this.vt = false, this.zf.applySuggestedBitmapSize();
-        const e2 = vl(this.zf);
-        null !== e2 && e2.useBitmapCoordinateSpace((t4) => {
-            this.sp(t4), this.ye(t4);
-        });
-    }
-    lp() {
-        return this.zf.bitmapSize;
-    }
-    ap(t3, e2, i2) {
-        const s2 = this.lp();
-        s2.width > 0 && s2.height > 0 && t3.drawImage(this.zf.canvasElement, e2, i2);
-    }
-    ye({
-        context: t3,
-        bitmapSize: e2,
-        horizontalPixelRatio: i2,
-        verticalPixelRatio: s2
-    }) {
-        if (!this.hv())
-            return;
-        t3.fillStyle = this.un.timeScale.borderColor;
-        const n2 = Math.floor(this.Gu.F().k * i2),
-            r2 = Math.floor(this.Gu.F().k * s2),
-            o2 = this.If ? e2.width - n2 : 0;
-        t3.fillRect(o2, 0, n2, r2);
-    }
-    sp({
-        context: t3,
-        bitmapSize: e2
-    }) {
-        Jl(t3, 0, 0, e2.width, e2.height, this.lv());
-    }
-}
-
-function Pc(t3, e2) {
-    return t3.w_ > e2.w_ ? t3 : e2;
-}
-class Kn {
-    constructor(t3) {
-        this.av = null, this.ov = null, this.S = null, this._v = false, this.Tf = hl({
-            width: 0,
-            height: 0
-        }), this.uv = new Ll(), this.Rf = new Ut(5), this.Bf = false, this.Af = () => {
-            this.Bf || this.xp.Ut().Ch();
-        }, this.Lf = () => {
-            this.Bf || this.xp.Ut().Ch();
-        }, this.xp = t3, this.un = t3.F().layout, this.cv = document.createElement("tr"), this.dv = document.createElement("td"), this.dv.style.padding = "0", this.fv = document.createElement("td"), this.fv.style.padding = "0", this.Ef = document.createElement("td"), this.Ef.style.height = "25px", this.Ef.style.padding = "0", this.pv = document.createElement("div"), this.pv.style.width = "100%", this.pv.style.height = "100%", this.pv.style.position = "relative", this.pv.style.overflow = "hidden", this.Ef.appendChild(this.pv), this.zf = bc(this.pv, hl({
-            width: 16,
-            height: 16
-        })), this.zf.subscribeSuggestedBitmapSizeChanged(this.Af);
-        const e2 = this.zf.canvasElement;
-        e2.style.position = "absolute", e2.style.zIndex = "1", e2.style.left = "0", e2.style.top = "0", this.Vf = bc(this.pv, hl({
-            width: 16,
-            height: 16
-        })), this.Vf.subscribeSuggestedBitmapSizeChanged(this.Lf);
-        const i2 = this.Vf.canvasElement;
-        i2.style.position = "absolute", i2.style.zIndex = "2", i2.style.left = "0", i2.style.top = "0", this.cv.appendChild(this.dv), this.cv.appendChild(this.Ef), this.cv.appendChild(this.fv), this.vv(), this.xp.Ut().Po().l(this.vv.bind(this), this), this.qf = new In(this.Vf.canvasElement, this, {
-            Zd: () => true,
-            Kd: () => false
-        });
-    }
-    M() {
-        this.qf.M(), null !== this.av && this.av.M(), null !== this.ov && this.ov.M(), this.Vf.unsubscribeSuggestedBitmapSizeChanged(this.Lf), this.Vf.dispose(), this.zf.unsubscribeSuggestedBitmapSizeChanged(this.Af), this.zf.dispose();
-    }
-    Yf() {
-        return this.cv;
-    }
-    mv() {
-        return this.av;
-    }
-    bv() {
-        return this.ov;
-    }
-    _f(t3) {
-        if (this._v)
-            return;
-        this._v = true;
-        const e2 = this.xp.Ut();
-        !e2.yt().Ni() && this.xp.F().handleScale.axisPressedMouseMove.time && e2.bc(t3.localX);
-    }
-    lf(t3) {
-        this._f(t3);
-    }
-    uf() {
-        const t3 = this.xp.Ut();
-        !t3.yt().Ni() && this._v && (this._v = false, this.xp.F().handleScale.axisPressedMouseMove.time && t3.kc());
-    }
-    Qd(t3) {
-        const e2 = this.xp.Ut();
-        !e2.yt().Ni() && this.xp.F().handleScale.axisPressedMouseMove.time && e2.yc(t3.localX);
-    }
-    Gd(t3) {
-        this.Qd(t3);
-    }
-    sf() {
-        this._v = false;
-        const t3 = this.xp.Ut();
-        t3.yt().Ni() && !this.xp.F().handleScale.axisPressedMouseMove.time || t3.kc();
-    }
-    if () {
-        this.sf();
-    }
-    zd() {
-        this.xp.F().handleScale.axisDoubleClickReset.time && this.xp.Ut().Zn();
-    }
-    Od() {
-        this.zd();
-    }
-    Hd() {
-        this.xp.Ut().F().handleScale.axisPressedMouseMove.time && this.op(1);
-    }
-    wf() {
-        this.op(0);
-    }
-    qp() {
-        return this.Tf;
-    }
-    gv() {
-        return this.uv;
-    }
-    wv(t3, e2, i2) {
-        cl(this.Tf, t3) || (this.Tf = t3, this.Bf = true, this.zf.resizeCanvasElement(t3), this.Vf.resizeCanvasElement(t3), this.Bf = false, this.Ef.style.width = `${t3.width}px`, this.Ef.style.height = `${t3.height}px`, this.uv.m(t3)), null !== this.av && this.av.Jf(hl({
-            width: e2,
-            height: t3.height
-        })), null !== this.ov && this.ov.Jf(hl({
-            width: i2,
-            height: t3.height
-        }));
-    }
-    Mv() {
-        const t3 = this.Sv();
-        return Math.ceil(t3.k + t3.C + t3.T + t3.I + t3.A + t3.xv);
-    }
-    gt() {
-        this.xp.Ut().yt().Jl();
-    }
-    lp() {
-        return this.zf.bitmapSize;
-    }
-    ap(t3, e2, i2) {
-        const s2 = this.lp();
-        s2.width > 0 && s2.height > 0 && t3.drawImage(this.zf.canvasElement, e2, i2);
-    }
-    ip(t3) {
-        if (0 === t3)
-            return;
-        if (1 !== t3) {
-            this.zf.applySuggestedBitmapSize();
-            const e3 = vl(this.zf);
-            null !== e3 && (e3.useBitmapCoordinateSpace((t4) => {
-                this.sp(t4), this.ye(t4);
-            }), this.ep(e3)), null !== this.av && this.av.ip(t3), null !== this.ov && this.ov.ip(t3);
-        }
-        this.Vf.applySuggestedBitmapSize();
-        const e2 = vl(this.Vf);
-        null !== e2 && (e2.useBitmapCoordinateSpace(({
-            context: t4,
-            bitmapSize: e3
-        }) => {
-            t4.clearRect(0, 0, e3.width, e3.height);
-        }), this.yv([this.xp.Ut().dc()], e2));
-    }
-    sp({
-        context: t3,
-        bitmapSize: e2
-    }) {
-        Jl(t3, 0, 0, e2.width, e2.height, this.xp.Ut().Ic());
-    }
-    ye({
-        context: t3,
-        bitmapSize: e2,
-        verticalPixelRatio: i2
-    }) {
-        if (this.xp.F().timeScale.borderVisible) {
-            t3.fillStyle = this.kv();
-            const s2 = Math.max(1, Math.floor(this.Sv().k * i2));
-            t3.fillRect(0, 0, e2.width, s2);
-        }
-    }
-    ep(t3) {
-        const e2 = this.xp.Ut().yt(),
-            i2 = e2.Jl();
-        if (!i2 || 0 === i2.length)
-            return;
-        let s2 = i2.reduce(Pc, i2[0]).w_;
-        s2 > 30 && s2 < 50 && (s2 = 30);
-        const n2 = this.Sv(),
-            r2 = e2.F();
-        r2.borderVisible && r2.ticksVisible && t3.useBitmapCoordinateSpace(({
-            context: t4,
-            horizontalPixelRatio: e3,
-            verticalPixelRatio: s3
-        }) => {
-            t4.strokeStyle = this.kv(), t4.fillStyle = this.kv();
-            const r3 = Math.max(1, Math.floor(e3)),
-                o2 = Math.floor(0.5 * e3);
-            t4.beginPath();
-            const a2 = Math.round(n2.C * s3);
-            for (let s4 = i2.length; s4--;) {
-                const n3 = Math.round(i2[s4].Yl * e3);
-                t4.rect(n3 - o2, 0, r3, a2);
-            }
-            t4.fill();
-        }), t3.useMediaCoordinateSpace(({
-            context: t4
-        }) => {
-            const e3 = n2.k + n2.C + n2.I + n2.T / 2;
-            t4.textAlign = "center", t4.textBaseline = "middle", t4.fillStyle = this.$(), t4.font = this.Kf();
-            for (const n3 of i2)
-                if (n3.w_ < s2) {
-                    const i3 = n3.cu ? this.Cv(t4, n3.Yl, n3.ua) : n3.Yl;
-                    t4.fillText(n3.ua, i3, e3);
-                }
-            t4.font = this.Tv();
-            for (const n3 of i2)
-                if (n3.w_ >= s2) {
-                    const i3 = n3.cu ? this.Cv(t4, n3.Yl, n3.ua) : n3.Yl;
-                    t4.fillText(n3.ua, i3, e3);
-                }
-        });
-    }
-    Cv(t3, e2, i2) {
-        const s2 = this.Rf.Si(t3, i2),
-            n2 = s2 / 2,
-            r2 = Math.floor(e2 - n2) + 0.5;
-        return r2 < 0 ? e2 += Math.abs(0 - r2) : r2 + s2 > this.Tf.width && (e2 -= Math.abs(this.Tf.width - (r2 + s2))), e2;
-    }
-    yv(t3, e2) {
-        const i2 = this.Sv();
-        for (const s2 of t3)
-            for (const t4 of s2.Qi())
-                t4.Mt().X(e2, i2);
-    }
-    kv() {
-        return this.xp.F().timeScale.borderColor;
-    }
-    $() {
-        return this.un.textColor;
-    }
-    W() {
-        return this.un.fontSize;
-    }
-    Kf() {
-        return Hl(this.W(), this.un.fontFamily);
-    }
-    Tv() {
-        return Hl(this.W(), this.un.fontFamily, "bold");
-    }
-    Sv() {
-        null === this.S && (this.S = {
-            k: 1,
-            V: NaN,
-            I: NaN,
-            A: NaN,
-            ji: NaN,
-            C: 5,
-            T: NaN,
-            P: "",
-            Wi: new Ut(),
-            xv: 0
-        });
-        const t3 = this.S,
-            e2 = this.Kf();
-        if (t3.P !== e2) {
-            const i2 = this.W();
-            t3.T = i2, t3.P = e2, t3.I = 3 * i2 / 12, t3.A = 3 * i2 / 12, t3.ji = 9 * i2 / 12, t3.V = 0, t3.xv = 4 * i2 / 12, t3.Wi.Fe();
-        }
-        return this.S;
-    }
-    op(t3) {
-        this.Ef.style.cursor = 1 === t3 ? "ew-resize" : "default";
-    }
-    vv() {
-        const t3 = this.xp.Ut(),
-            e2 = t3.F();
-        e2.leftPriceScale.visible || null === this.av || (this.dv.removeChild(this.av.Yf()), this.av.M(), this.av = null), e2.rightPriceScale.visible || null === this.ov || (this.fv.removeChild(this.ov.Yf()), this.ov.M(), this.ov = null);
-        const i2 = {
-                Rc: this.xp.Ut().Rc()
-            },
-            s2 = () => e2.leftPriceScale.borderVisible && t3.yt().F().borderVisible,
-            n2 = () => t3.Ic();
-        e2.leftPriceScale.visible && null === this.av && (this.av = new Xn("left", e2, i2, s2, n2), this.dv.appendChild(this.av.Yf())), e2.rightPriceScale.visible && null === this.ov && (this.ov = new Xn("right", e2, i2, s2, n2), this.fv.appendChild(this.ov.Yf()));
-    }
-}
-const Rc = !!fc && !!navigator.userAgentData && navigator.userAgentData.brands.some((t3) => t3.brand.includes("Chromium")) && !!fc && ((null === (Ac = null === navigator || void 0 === navigator ? void 0 : navigator.userAgentData) || void 0 === Ac ? void 0 : Ac.platform) ? "Windows" === navigator.userAgentData.platform : navigator.userAgent.toLowerCase().indexOf("win") >= 0);
-var Ac;
-class Qn {
-    constructor(t3, e2) {
-        var i2;
-        this.Pv = [], this.Rv = 0, this.fa = 0, this.vo = 0, this.Dv = 0, this.Bv = 0, this.Av = null, this.Ov = false, this.pp = new Ll(), this.Xu = new Ll(), this.Lv = null, this.Iv = t3, this.un = e2, this.cv = document.createElement("div"), this.cv.classList.add("tv-lightweight-charts"), this.cv.style.overflow = "hidden", this.cv.style.width = "100%", this.cv.style.height = "100%", (i2 = this.cv).style.userSelect = "none", i2.style.webkitUserSelect = "none", i2.style.msUserSelect = "none", i2.style.MozUserSelect = "none", i2.style.webkitTapHighlightColor = "transparent", this.Ev = document.createElement("table"), this.Ev.setAttribute("cellspacing", "0"), this.cv.appendChild(this.Ev), this.zv = this.Vv.bind(this), Dc(this.un) && this.Nv(true), this.Hi = new xn(this.Ku.bind(this), this.un), this.Ut().fc().l(this.Fv.bind(this), this), this.Wv = new Kn(this), this.Ev.appendChild(this.Wv.Yf());
-        const s2 = e2.autoSize && this.jv();
-        let n2 = this.un.width,
-            r2 = this.un.height;
-        if (s2 || 0 === n2 || 0 === r2) {
-            const e3 = t3.getBoundingClientRect();
-            n2 = n2 || e3.width, r2 = r2 || e3.height;
-        }
-        this.$v(n2, r2), this.Hv(), t3.appendChild(this.cv), this.Uv(), this.Hi.yt().yu().l(this.Hi.dl.bind(this.Hi), this), this.Hi.Po().l(this.Hi.dl.bind(this.Hi), this);
-    }
-    Ut() {
-        return this.Hi;
-    }
-    F() {
-        return this.un;
-    }
-    qv() {
-        return this.Pv;
-    }
-    Yv() {
-        return this.Wv;
-    }
-    M() {
-        this.Nv(false), 0 !== this.Rv && window.cancelAnimationFrame(this.Rv), this.Hi.fc().v(this), this.Hi.yt().yu().v(this), this.Hi.Po().v(this), this.Hi.M();
-        for (const t3 of this.Pv)
-            this.Ev.removeChild(t3.Yf()), t3.jp().v(this), t3.M();
-        this.Pv = [], kl(this.Wv).M(), null !== this.cv.parentElement && this.cv.parentElement.removeChild(this.cv), this.Xu.M(), this.pp.M(), this.Xv();
-    }
-    $v(t3, e2, i2 = false) {
-        if (this.fa === e2 && this.vo === t3)
-            return;
-        const s2 = function(t4) {
-            const e3 = Math.floor(t4.width),
-                i3 = Math.floor(t4.height);
-            return hl({
-                width: e3 - e3 % 2,
-                height: i3 - i3 % 2
-            });
-        }(hl({
-            width: t3,
-            height: e2
-        }));
-        this.fa = s2.height, this.vo = s2.width;
-        const n2 = this.fa + "px",
-            r2 = this.vo + "px";
-        kl(this.cv).style.height = n2, kl(this.cv).style.width = r2, this.Ev.style.height = n2, this.Ev.style.width = r2, i2 ? this.Zv(et.ss(), performance.now()) : this.Hi.dl();
-    }
-    ip(t3) {
-        void 0 === t3 && (t3 = et.ss());
-        for (let e2 = 0; e2 < this.Pv.length; e2++)
-            this.Pv[e2].ip(t3.jn(e2).Nn);
-        this.un.timeScale.visible && this.Wv.ip(t3.Wn());
-    }
-    kh(t3) {
-        const e2 = Dc(this.un);
-        this.Hi.kh(t3);
-        const i2 = Dc(this.un);
-        i2 !== e2 && this.Nv(i2), this.Uv(), this.Kv(t3);
-    }
-    jp() {
-        return this.pp;
-    }
-    fc() {
-        return this.Xu;
-    }
-    Gv() {
-        null !== this.Av && (this.Zv(this.Av, performance.now()), this.Av = null);
-        const t3 = this.Jv(null),
-            e2 = document.createElement("canvas");
-        e2.width = t3.width, e2.height = t3.height;
-        const i2 = kl(e2.getContext("2d"));
-        return this.Jv(i2), e2;
-    }
-    Qv(t3) {
-        return ("left" !== t3 || this.tm()) && ("right" !== t3 || this.im()) ? 0 === this.Pv.length ? 0 : kl("left" === t3 ? this.Pv[0].Jp() : this.Pv[0].Qp()).Qf() : 0;
-    }
-    nm() {
-        return this.un.autoSize && null !== this.Lv;
-    }
-    Kv(t3) {
-        (void 0 !== t3.autoSize || !this.Lv || void 0 === t3.width && void 0 === t3.height) && (t3.autoSize && !this.Lv && this.jv(), false === t3.autoSize && null !== this.Lv && this.Xv(), t3.autoSize || void 0 === t3.width && void 0 === t3.height || this.$v(t3.width || this.vo, t3.height || this.fa));
-    }
-    Jv(t3) {
-        let e2 = 0,
-            i2 = 0;
-        const s2 = this.Pv[0],
-            n2 = (e3, i3) => {
-                let s3 = 0;
-                for (let n3 = 0; n3 < this.Pv.length; n3++) {
-                    const r3 = this.Pv[n3],
-                        o2 = kl("left" === e3 ? r3.Jp() : r3.Qp()),
-                        a2 = o2.lp();
-                    null !== t3 && o2.ap(t3, i3, s3), s3 += a2.height;
-                }
-            };
-        this.tm() && (n2("left", 0), e2 += kl(s2.Jp()).lp().width);
-        for (let s3 = 0; s3 < this.Pv.length; s3++) {
-            const n3 = this.Pv[s3],
-                r3 = n3.lp();
-            null !== t3 && n3.ap(t3, e2, i2), i2 += r3.height;
-        }
-        e2 += s2.lp().width, this.im() && (n2("right", e2), e2 += kl(s2.Qp()).lp().width);
-        const r2 = (e3, i3, s3) => {
-            kl("left" === e3 ? this.Wv.mv() : this.Wv.bv()).ap(kl(t3), i3, s3);
-        };
-        if (this.un.timeScale.visible) {
-            const e3 = this.Wv.lp();
-            if (null !== t3) {
-                let n3 = 0;
-                this.tm() && (r2("left", n3, i2), n3 = kl(s2.Jp()).lp().width), this.Wv.ap(t3, n3, i2), n3 += e3.width, this.im() && r2("right", n3, i2);
-            }
-            i2 += e3.height;
-        }
-        return hl({
-            width: e2,
-            height: i2
-        });
-    }
-    sm() {
-        let t3 = 0,
-            e2 = 0,
-            i2 = 0;
-        for (const s3 of this.Pv)
-            this.tm() && (e2 = Math.max(e2, kl(s3.Jp()).Zf())), this.im() && (i2 = Math.max(i2, kl(s3.Qp()).Zf())), t3 += s3.Ro();
-        e2 = gc(e2), i2 = gc(i2);
-        const s2 = this.vo,
-            n2 = this.fa,
-            r2 = Math.max(s2 - e2 - i2, 0),
-            o2 = this.un.timeScale.visible;
-        let a2 = o2 ? this.Wv.Mv() : 0;
-        var l2;
-        a2 = (l2 = a2) + l2 % 2;
-        const h2 = 0 + a2,
-            c2 = n2 < h2 ? 0 : n2 - h2,
-            u2 = c2 / t3;
-        let d2 = 0;
-        for (let t4 = 0; t4 < this.Pv.length; ++t4) {
-            const s3 = this.Pv[t4];
-            s3.Dp(this.Hi.uc()[t4]);
-            let n3 = 0,
-                o3 = 0;
-            o3 = t4 === this.Pv.length - 1 ? c2 - d2 : Math.round(s3.Ro() * u2), n3 = Math.max(o3, 2), d2 += n3, s3.Jf(hl({
-                width: r2,
-                height: n3
-            })), this.tm() && s3.Up(e2, "left"), this.im() && s3.Up(i2, "right"), s3.tp() && this.Hi.vc(s3.tp(), n3);
-        }
-        this.Wv.wv(hl({
-            width: o2 ? r2 : 0,
-            height: a2
-        }), o2 ? e2 : 0, o2 ? i2 : 0), this.Hi.Bo(r2), this.Dv !== e2 && (this.Dv = e2), this.Bv !== i2 && (this.Bv = i2);
-    }
-    Nv(t3) {
-        t3 ? this.cv.addEventListener("wheel", this.zv, {
-            passive: false
-        }) : this.cv.removeEventListener("wheel", this.zv);
-    }
-    rm(t3) {
-        switch (t3.deltaMode) {
-            case t3.DOM_DELTA_PAGE:
-                return 120;
-            case t3.DOM_DELTA_LINE:
-                return 32;
-        }
-        return Rc ? 1 / window.devicePixelRatio : 1;
-    }
-    Vv(t3) {
-        if (!(0 !== t3.deltaX && this.un.handleScroll.mouseWheel || 0 !== t3.deltaY && this.un.handleScale.mouseWheel))
-            return;
-        const e2 = this.rm(t3),
-            i2 = e2 * t3.deltaX / 100,
-            s2 = -e2 * t3.deltaY / 100;
-        if (t3.cancelable && t3.preventDefault(), 0 !== s2 && this.un.handleScale.mouseWheel) {
-            const e3 = Math.sign(s2) * Math.min(1, Math.abs(s2)),
-                i3 = t3.clientX - this.cv.getBoundingClientRect().left;
-            this.Ut().gc(i3, e3);
-        }
-        0 !== i2 && this.un.handleScroll.mouseWheel && this.Ut().wc(-80 * i2);
-    }
-    Zv(t3, e2) {
-        var i2;
-        const s2 = t3.Wn();
-        3 === s2 && this.hm(), 3 !== s2 && 2 !== s2 || (this.lm(t3), this.am(t3, e2), this.Wv.gt(), this.Pv.forEach((t4) => {
-            t4.Ap();
-        }), 3 === (null === (i2 = this.Av) || void 0 === i2 ? void 0 : i2.Wn()) && (this.Av.Qn(t3), this.hm(), this.lm(this.Av), this.am(this.Av, e2), t3 = this.Av, this.Av = null)), this.ip(t3);
-    }
-    am(t3, e2) {
-        for (const i2 of t3.Jn())
-            this.ts(i2, e2);
-    }
-    lm(t3) {
-        const e2 = this.Hi.uc();
-        for (let i2 = 0; i2 < e2.length; i2++)
-            t3.jn(i2).Fn && e2[i2].Yo();
-    }
-    ts(t3, e2) {
-        const i2 = this.Hi.yt();
-        switch (t3.Un) {
-            case 0:
-                i2.Cu();
-                break;
-            case 1:
-                i2.Tu(t3.At);
-                break;
-            case 2:
-                i2.Kn(t3.At);
-                break;
-            case 3:
-                i2.Gn(t3.At);
-                break;
-            case 4:
-                i2.du();
-                break;
-            case 5:
-                t3.At.wu(e2) || i2.Gn(t3.At.Mu(e2));
-        }
-    }
-    Ku(t3) {
-        null !== this.Av ? this.Av.Qn(t3) : this.Av = t3, this.Ov || (this.Ov = true, this.Rv = window.requestAnimationFrame((t4) => {
-            if (this.Ov = false, this.Rv = 0, null !== this.Av) {
-                const e2 = this.Av;
-                this.Av = null, this.Zv(e2, t4);
-                for (const i2 of e2.Jn())
-                    if (5 === i2.Un && !i2.At.wu(t4)) {
-                        this.Ut().Yn(i2.At);
-                        break;
-                    }
-            }
-        }));
-    }
-    hm() {
-        this.Hv();
-    }
-    Hv() {
-        const t3 = this.Hi.uc(),
-            e2 = t3.length,
-            i2 = this.Pv.length;
-        for (let t4 = e2; t4 < i2; t4++) {
-            const t5 = xl(this.Pv.pop());
-            this.Ev.removeChild(t5.Yf()), t5.jp().v(this), t5.M();
-        }
-        for (let s2 = i2; s2 < e2; s2++) {
-            const e3 = new Yn(this, t3[s2]);
-            e3.jp().l(this.om.bind(this), this), this.Pv.push(e3), this.Ev.insertBefore(e3.Yf(), this.Wv.Yf());
-        }
-        for (let i3 = 0; i3 < e2; i3++) {
-            const e3 = t3[i3],
-                s2 = this.Pv[i3];
-            s2.tp() !== e3 ? s2.Dp(e3) : s2.Rp();
-        }
-        this.Uv(), this.sm();
-    }
-    _m(t3, e2, i2) {
-        var s2;
-        const n2 = /* @__PURE__ */ new Map();
-        let r2;
-        if (null !== t3 && this.Hi.wt().forEach((e3) => {
-                const i3 = e3.Ln().jh(t3);
-                null !== i3 && n2.set(e3, i3);
-            }), null !== t3) {
-            const e3 = null === (s2 = this.Hi.yt().Ui(t3)) || void 0 === s2 ? void 0 : s2.M_;
-            void 0 !== e3 && (r2 = e3);
-        }
-        const o2 = this.Ut().hc(),
-            a2 = null !== o2 && o2.ac instanceof Pi ? o2.ac : void 0,
-            l2 = null !== o2 && void 0 !== o2.Ep ? o2.Ep.nr : void 0;
-        return {
-            _t: r2,
-            Ys: null != t3 ? t3 : void 0,
-            um: null != e2 ? e2 : void 0,
-            dm: a2,
-            fm: n2,
-            pm: l2,
-            vm: null != i2 ? i2 : void 0
-        };
-    }
-    om(t3, e2, i2) {
-        this.pp.m(() => this._m(t3, e2, i2));
-    }
-    Fv(t3, e2, i2) {
-        this.Xu.m(() => this._m(t3, e2, i2));
-    }
-    Uv() {
-        const t3 = this.un.timeScale.visible ? "" : "none";
-        this.Wv.Yf().style.display = t3;
-    }
-    tm() {
-        return this.Pv[0].tp().zo().F().visible;
-    }
-    im() {
-        return this.Pv[0].tp().Vo().F().visible;
-    }
-    jv() {
-        return "ResizeObserver" in window && (this.Lv = new ResizeObserver((t3) => {
-            const e2 = t3.find((t4) => t4.target === this.Iv);
-            e2 && this.$v(e2.contentRect.width, e2.contentRect.height);
-        }), this.Lv.observe(this.Iv, {
-            box: "border-box"
-        }), true);
-    }
-    Xv() {
-        null !== this.Lv && this.Lv.disconnect();
-    }
-}
-
-function Dc(t3) {
-    return Boolean(t3.handleScroll.mouseWheel || t3.handleScale.mouseWheel);
-}
-
-function Lc(t3, e2, i2, s2) {
-    const n2 = i2.value,
-        r2 = {
-            Ys: e2,
-            _t: t3,
-            At: [n2, n2, n2, n2],
-            M_: s2
-        };
-    return void 0 !== i2.color && (r2.D = i2.color), r2;
-}
-
-function Oc(t3) {
-    return void 0 !== t3.At;
-}
-
-function Fc(t3) {
-    return (e2, i2, s2, n2) => {
-        return void 0 === (r2 = s2).open && void 0 === r2.value ? {
-            _t: e2,
-            Ys: i2,
-            M_: n2
-        } : t3(e2, i2, s2, n2);
-        var r2;
-    };
-}
-const Nc = {
-    Candlestick: Fc(function(t3, e2, i2, s2) {
-        const n2 = {
-            Ys: e2,
-            _t: t3,
-            At: [i2.open, i2.high, i2.low, i2.close],
-            M_: s2
-        };
-        return void 0 !== i2.color && (n2.D = i2.color), void 0 !== i2.borderColor && (n2.Ot = i2.borderColor), void 0 !== i2.wickColor && (n2.Dh = i2.wickColor), n2;
-    }),
-    Bar: Fc(function(t3, e2, i2, s2) {
-        const n2 = {
-            Ys: e2,
-            _t: t3,
-            At: [i2.open, i2.high, i2.low, i2.close],
-            M_: s2
-        };
-        return void 0 !== i2.color && (n2.D = i2.color), n2;
-    }),
-    Area: Fc(function(t3, e2, i2, s2) {
-        const n2 = i2.value,
-            r2 = {
-                Ys: e2,
-                _t: t3,
-                At: [n2, n2, n2, n2],
-                M_: s2
-            };
-        return void 0 !== i2.lineColor && (r2.ot = i2.lineColor), void 0 !== i2.topColor && (r2.bs = i2.topColor), void 0 !== i2.bottomColor && (r2.gs = i2.bottomColor), r2;
-    }),
-    Baseline: Fc(function(t3, e2, i2, s2) {
-        const n2 = i2.value,
-            r2 = {
-                Ys: e2,
-                _t: t3,
-                At: [n2, n2, n2, n2],
-                M_: s2
-            };
-        return void 0 !== i2.topLineColor && (r2.be = i2.topLineColor), void 0 !== i2.bottomLineColor && (r2.ge = i2.bottomLineColor), void 0 !== i2.topFillColor1 && (r2.de = i2.topFillColor1), void 0 !== i2.topFillColor2 && (r2.fe = i2.topFillColor2), void 0 !== i2.bottomFillColor1 && (r2.pe = i2.bottomFillColor1), void 0 !== i2.bottomFillColor2 && (r2.ve = i2.bottomFillColor2), r2;
-    }),
-    Histogram: Fc(Lc),
-    Line: Fc(Lc)
-};
-
-function $c(t3) {
-    return Nc[t3];
-}
-
-function Vc(t3) {
-    return 60 * t3 * 60 * 1e3;
-}
-
-function zc(t3) {
-    return 60 * t3 * 1e3;
-}
-const Bc = [{
-    bm: (1, 1e3),
-    w_: 10
-}, {
-    bm: zc(1),
-    w_: 20
-}, {
-    bm: zc(5),
-    w_: 21
-}, {
-    bm: zc(30),
-    w_: 22
-}, {
-    bm: Vc(1),
-    w_: 30
-}, {
-    bm: Vc(3),
-    w_: 31
-}, {
-    bm: Vc(6),
-    w_: 32
-}, {
-    bm: Vc(12),
-    w_: 33
-}];
-
-function Uc(t3, e2) {
-    if (t3.getUTCFullYear() !== e2.getUTCFullYear())
-        return 70;
-    if (t3.getUTCMonth() !== e2.getUTCMonth())
-        return 60;
-    if (t3.getUTCDate() !== e2.getUTCDate())
-        return 50;
-    for (let i2 = Bc.length - 1; i2 >= 0; --i2)
-        if (Math.floor(e2.getTime() / Bc[i2].bm) !== Math.floor(t3.getTime() / Bc[i2].bm))
-            return Bc[i2].w_;
-    return 0;
-}
-
-function jc(t3, e2 = 0) {
-    if (0 === t3.length)
-        return;
-    let i2 = 0 === e2 ? null : t3[e2 - 1]._t.u_,
-        s2 = null !== i2 ? new Date(1e3 * i2) : null,
-        n2 = 0;
-    for (let r2 = e2; r2 < t3.length; ++r2) {
-        const e3 = t3[r2],
-            o2 = new Date(1e3 * e3._t.u_);
-        null !== s2 && (e3.g_ = Uc(o2, s2)), n2 += e3._t.u_ - (i2 || e3._t.u_), i2 = e3._t.u_, s2 = o2;
-    }
-    if (0 === e2 && t3.length > 1) {
-        const e3 = Math.ceil(n2 / (t3.length - 1)),
-            i3 = new Date(1e3 * (t3[0]._t.u_ - e3));
-        t3[0].g_ = Uc(new Date(1e3 * t3[0]._t.u_), i3);
-    }
-}
-
-function Hc(t3) {
-    if (!uc(t3))
-        throw new Error("time must be of type BusinessDay");
-    const e2 = new Date(Date.UTC(t3.year, t3.month - 1, t3.day, 0, 0, 0, 0));
-    return {
-        u_: Math.round(e2.getTime() / 1e3),
-        __: t3
-    };
-}
-
-function Wc(t3) {
-    if (!dc(t3))
-        throw new Error("time must be of type isUTCTimestamp");
-    return {
-        u_: t3
-    };
-}
-
-function qc(t3) {
-    return 0 === t3.length ? null : uc(t3[0].time) ? Hc : Wc;
-}
-
-function Kc(t3) {
-    return dc(t3) ? Wc(t3) : uc(t3) ? Hc(t3) : Hc(Gc(t3));
-}
-
-function Gc(t3) {
-    const e2 = new Date(t3);
-    if (isNaN(e2.getTime()))
-        throw new Error(`Invalid date string=${t3}, expected format=yyyy-mm-dd`);
-    return {
-        day: e2.getUTCDate(),
-        month: e2.getUTCMonth() + 1,
-        year: e2.getUTCFullYear()
-    };
-}
-
-function Yc(t3) {
-    $l(t3.time) && (t3.time = Gc(t3.time));
-}
-
-function Qc(t3) {
-    return {
-        Ys: 0,
-        gm: /* @__PURE__ */ new Map(),
-        yl: t3
-    };
-}
-
-function Xc(t3) {
-    if (void 0 !== t3 && 0 !== t3.length)
-        return {
-            wm: t3[0]._t.u_,
-            Mm: t3[t3.length - 1]._t.u_
-        };
-}
-
-function Jc(t3) {
-    let e2;
-    return t3.forEach((t4) => {
-        void 0 === e2 && (e2 = t4.M_);
-    }), xl(e2);
-}
-
-function Zc(t3) {
-    void 0 === t3.M_ && (t3.M_ = t3.time);
-}
-class Ss {
-    constructor() {
-        this.Sm = /* @__PURE__ */ new Map(), this.xm = /* @__PURE__ */ new Map(), this.ym = /* @__PURE__ */ new Map(), this.km = [];
-    }
-    M() {
-        this.Sm.clear(), this.xm.clear(), this.ym.clear(), this.km = [];
-    }
-    Cm(t3, e2) {
-        let i2 = 0 !== this.Sm.size,
-            s2 = false;
-        const n2 = this.xm.get(t3);
-        if (void 0 !== n2)
-            if (1 === this.xm.size)
-                i2 = false, s2 = true, this.Sm.clear();
-            else
-                for (const e3 of this.km)
-                    e3.pointData.gm.delete(t3) && (s2 = true);
-        let r2 = [];
-        if (0 !== e2.length) {
-            const i3 = e2;
-            i3.forEach((t4) => Zc(t4)),
-                function(t4) {
-                    t4.forEach(Yc);
-                }(e2);
-            const n3 = kl(qc(e2)),
-                o3 = $c(t3.Lh());
-            r2 = i3.map((e3) => {
-                const i4 = n3(e3.time);
-                let r3 = this.Sm.get(i4.u_);
-                void 0 === r3 && (r3 = Qc(i4), this.Sm.set(i4.u_, r3), s2 = true);
-                const a2 = o3(i4, r3.Ys, e3, e3.M_);
-                return r3.gm.set(t3, a2), a2;
-            });
-        }
-        i2 && this.Tm(), this.Pm(t3, r2);
-        let o2 = -1;
-        if (s2) {
-            const t4 = [];
-            this.Sm.forEach((e3) => {
-                t4.push({
-                    g_: 0,
-                    _t: e3.yl,
-                    pointData: e3,
-                    M_: Jc(e3.gm)
-                });
-            }), t4.sort((t5, e3) => t5._t.u_ - e3._t.u_), o2 = this.Rm(t4);
-        }
-        return this.Dm(t3, o2, function(t4, e3) {
-            const i3 = Xc(t4),
-                s3 = Xc(e3);
-            if (void 0 !== i3 && void 0 !== s3)
-                return {
-                    ml: i3.Mm >= s3.Mm && i3.wm >= s3.wm
-                };
-        }(this.xm.get(t3), n2));
-    }
-    Ac(t3) {
-        return this.Cm(t3, []);
-    }
-    Bm(t3, e2) {
-        const i2 = e2;
-        Zc(i2), Yc(e2);
-        const s2 = kl(qc([e2]))(e2.time),
-            n2 = this.ym.get(t3);
-        if (void 0 !== n2 && s2.u_ < n2.u_)
-            throw new Error(`Cannot update oldest data, last time=${n2.u_}, new time=${s2.u_}`);
-        let r2 = this.Sm.get(s2.u_);
-        const o2 = void 0 === r2;
-        void 0 === r2 && (r2 = Qc(s2), this.Sm.set(s2.u_, r2));
-        const a2 = $c(t3.Lh())(s2, r2.Ys, e2, i2.M_);
-        r2.gm.set(t3, a2), this.Am(t3, a2);
-        const l2 = {
-            ml: Oc(a2)
-        };
-        if (!o2)
-            return this.Dm(t3, -1, l2);
-        const h2 = {
-                g_: 0,
-                _t: r2.yl,
-                pointData: r2,
-                M_: Jc(r2.gm)
-            },
-            c2 = yh(this.km, h2._t.u_, (t4, e3) => t4._t.u_ < e3);
-        this.km.splice(c2, 0, h2);
-        for (let t4 = c2; t4 < this.km.length; ++t4)
-            tu(this.km[t4].pointData, t4);
-        return jc(this.km, c2), this.Dm(t3, c2, l2);
-    }
-    Am(t3, e2) {
-        let i2 = this.xm.get(t3);
-        void 0 === i2 && (i2 = [], this.xm.set(t3, i2));
-        const s2 = 0 !== i2.length ? i2[i2.length - 1] : null;
-        null === s2 || e2._t.u_ > s2._t.u_ ? Oc(e2) && i2.push(e2) : Oc(e2) ? i2[i2.length - 1] = e2 : i2.splice(-1, 1), this.ym.set(t3, e2._t);
-    }
-    Pm(t3, e2) {
-        0 !== e2.length ? (this.xm.set(t3, e2.filter(Oc)), this.ym.set(t3, e2[e2.length - 1]._t)) : (this.xm.delete(t3), this.ym.delete(t3));
-    }
-    Tm() {
-        for (const t3 of this.km)
-            0 === t3.pointData.gm.size && this.Sm.delete(t3._t.u_);
-    }
-    Rm(t3) {
-        let e2 = -1;
-        for (let i2 = 0; i2 < this.km.length && i2 < t3.length; ++i2) {
-            const s2 = this.km[i2],
-                n2 = t3[i2];
-            if (s2._t.u_ !== n2._t.u_) {
-                e2 = i2;
-                break;
-            }
-            n2.g_ = s2.g_, tu(n2.pointData, i2);
-        }
-        if (-1 === e2 && this.km.length !== t3.length && (e2 = Math.min(this.km.length, t3.length)), -1 === e2)
-            return -1;
-        for (let i2 = e2; i2 < t3.length; ++i2)
-            tu(t3[i2].pointData, i2);
-        return jc(t3, e2), this.km = t3, e2;
-    }
-    Om() {
-        if (0 === this.xm.size)
-            return null;
-        let t3 = 0;
-        return this.xm.forEach((e2) => {
-            0 !== e2.length && (t3 = Math.max(t3, e2[e2.length - 1].Ys));
-        }), t3;
-    }
-    Dm(t3, e2, i2) {
-        const s2 = {
-            Lm: /* @__PURE__ */ new Map(),
-            yt: {
-                eu: this.Om()
-            }
-        };
-        if (-1 !== e2)
-            this.xm.forEach((e3, n2) => {
-                s2.Lm.set(n2, {
-                    ar: e3,
-                    Im: n2 === t3 ? i2 : void 0
-                });
-            }), this.xm.has(t3) || s2.Lm.set(t3, {
-                ar: [],
-                Im: i2
-            }), s2.yt.Em = this.km, s2.yt.zm = e2;
-        else {
-            const e3 = this.xm.get(t3);
-            s2.Lm.set(t3, {
-                ar: e3 || [],
-                Im: i2
-            });
-        }
-        return s2;
-    }
-}
-
-function tu(t3, e2) {
-    t3.Ys = e2, t3.gm.forEach((t4) => {
-        t4.Ys = e2;
-    });
-}
-
-function eu(t3) {
-    return {
-        value: t3.At[3],
-        time: t3.M_
-    };
-}
-
-function iu(t3) {
-    const e2 = eu(t3);
-    return void 0 !== t3.D && (e2.color = t3.D), e2;
-}
-
-function su(t3) {
-    return {
-        open: t3.At[0],
-        high: t3.At[1],
-        low: t3.At[2],
-        close: t3.At[3],
-        time: t3.M_
-    };
-}
-const nu = {
-    Area: function(t3) {
-        const e2 = eu(t3);
-        return void 0 !== t3.ot && (e2.lineColor = t3.ot), void 0 !== t3.bs && (e2.topColor = t3.bs), void 0 !== t3.gs && (e2.bottomColor = t3.gs), e2;
-    },
-    Line: iu,
-    Baseline: function(t3) {
-        const e2 = eu(t3);
-        return void 0 !== t3.be && (e2.topLineColor = t3.be), void 0 !== t3.ge && (e2.bottomLineColor = t3.ge), void 0 !== t3.de && (e2.topFillColor1 = t3.de), void 0 !== t3.fe && (e2.topFillColor2 = t3.fe), void 0 !== t3.pe && (e2.bottomFillColor1 = t3.pe), void 0 !== t3.ve && (e2.bottomFillColor2 = t3.ve), e2;
-    },
-    Histogram: iu,
-    Bar: function(t3) {
-        const e2 = su(t3);
-        return void 0 !== t3.D && (e2.color = t3.D), e2;
-    },
-    Candlestick: function(t3) {
-        const e2 = su(t3),
-            {
-                D: i2,
-                Ot: s2,
-                Dh: n2
-            } = t3;
-        return void 0 !== i2 && (e2.color = i2), void 0 !== s2 && (e2.borderColor = s2), void 0 !== n2 && (e2.wickColor = n2), e2;
-    }
-};
-
-function ru(t3) {
-    return nu[t3];
-}
-const ou = {
-        autoScale: true,
-        mode: 0,
-        invertScale: false,
-        alignLabels: true,
-        borderVisible: true,
-        borderColor: "#2B2B43",
-        entireTextOnly: false,
-        visible: false,
-        ticksVisible: false,
-        scaleMargins: {
-            bottom: 0.1,
-            top: 0.2
-        }
-    },
-    au = {
-        color: "rgba(0, 0, 0, 0)",
-        visible: false,
-        fontSize: 48,
-        fontFamily: jl,
-        fontStyle: "",
-        text: "",
-        horzAlign: "center",
-        vertAlign: "center"
-    },
-    lu = {
-        width: 0,
-        height: 0,
-        autoSize: false,
-        layout: {
-            background: {
-                type: "solid",
-                color: "#FFFFFF"
-            },
-            textColor: "#191919",
-            fontSize: 12,
-            fontFamily: jl
-        },
-        crosshair: {
-            vertLine: {
-                color: "#9598A1",
-                width: 1,
-                style: 3,
-                visible: true,
-                labelVisible: true,
-                labelBackgroundColor: "#131722"
-            },
-            horzLine: {
-                color: "#9598A1",
-                width: 1,
-                style: 3,
-                visible: true,
-                labelVisible: true,
-                labelBackgroundColor: "#131722"
-            },
-            mode: 1
-        },
-        grid: {
-            vertLines: {
-                color: "#D6DCDE",
-                style: 0,
-                visible: true
-            },
-            horzLines: {
-                color: "#D6DCDE",
-                style: 0,
-                visible: true
-            }
-        },
-        overlayPriceScales: Object.assign({}, ou),
-        leftPriceScale: Object.assign(Object.assign({}, ou), {
-            visible: false
-        }),
-        rightPriceScale: Object.assign(Object.assign({}, ou), {
-            visible: true
-        }),
-        timeScale: {
-            rightOffset: 0,
-            barSpacing: 6,
-            minBarSpacing: 0.5,
-            fixLeftEdge: false,
-            fixRightEdge: false,
-            lockVisibleTimeRangeOnResize: false,
-            rightBarStaysOnScroll: false,
-            borderVisible: true,
-            borderColor: "#2B2B43",
-            visible: true,
-            timeVisible: false,
-            secondsVisible: true,
-            shiftVisibleRangeOnNewBar: true,
-            ticksVisible: false
-        },
-        watermark: au,
-        localization: {
-            locale: fc ? navigator.language : "",
-            dateFormat: "dd MMM 'yy"
-        },
-        handleScroll: {
-            mouseWheel: true,
-            pressedMouseMove: true,
-            horzTouchDrag: true,
-            vertTouchDrag: true
-        },
-        handleScale: {
-            axisPressedMouseMove: {
-                time: true,
-                price: true
-            },
-            axisDoubleClickReset: {
-                time: true,
-                price: true
-            },
-            mouseWheel: true,
-            pinch: true
-        },
-        kineticScroll: {
-            mouse: false,
-            touch: true
-        },
-        trackingMode: {
-            exitMode: 1
-        }
-    },
-    hu = {
-        upColor: "#26a69a",
-        downColor: "#ef5350",
-        wickVisible: true,
-        borderVisible: true,
-        borderColor: "#378658",
-        borderUpColor: "#26a69a",
-        borderDownColor: "#ef5350",
-        wickColor: "#737375",
-        wickUpColor: "#26a69a",
-        wickDownColor: "#ef5350"
-    },
-    cu = {
-        upColor: "#26a69a",
-        downColor: "#ef5350",
-        openVisible: true,
-        thinBars: true
-    },
-    uu = {
-        color: "#2196f3",
-        lineStyle: 0,
-        lineWidth: 3,
-        lineType: 0,
-        crosshairMarkerVisible: true,
-        crosshairMarkerRadius: 4,
-        crosshairMarkerBorderColor: "",
-        crosshairMarkerBorderWidth: 2,
-        crosshairMarkerBackgroundColor: "",
-        lastPriceAnimation: 0
-    },
-    du = {
-        topColor: "rgba( 46, 220, 135, 0.4)",
-        bottomColor: "rgba( 40, 221, 100, 0)",
-        invertFilledArea: false,
-        lineColor: "#33D778",
-        lineStyle: 0,
-        lineWidth: 3,
-        lineType: 0,
-        crosshairMarkerVisible: true,
-        crosshairMarkerRadius: 4,
-        crosshairMarkerBorderColor: "",
-        crosshairMarkerBorderWidth: 2,
-        crosshairMarkerBackgroundColor: "",
-        lastPriceAnimation: 0
-    },
-    fu = {
-        baseValue: {
-            type: "price",
-            price: 0
-        },
-        topFillColor1: "rgba(38, 166, 154, 0.28)",
-        topFillColor2: "rgba(38, 166, 154, 0.05)",
-        topLineColor: "rgba(38, 166, 154, 1)",
-        bottomFillColor1: "rgba(239, 83, 80, 0.05)",
-        bottomFillColor2: "rgba(239, 83, 80, 0.28)",
-        bottomLineColor: "rgba(239, 83, 80, 1)",
-        lineWidth: 3,
-        lineStyle: 0,
-        lineType: 0,
-        crosshairMarkerVisible: true,
-        crosshairMarkerRadius: 4,
-        crosshairMarkerBorderColor: "",
-        crosshairMarkerBorderWidth: 2,
-        crosshairMarkerBackgroundColor: "",
-        lastPriceAnimation: 0
-    },
-    pu = {
-        color: "#26a69a",
-        base: 0
-    },
-    mu = {
-        title: "",
-        visible: true,
-        lastValueVisible: true,
-        priceLineVisible: true,
-        priceLineSource: 0,
-        priceLineWidth: 1,
-        priceLineColor: "",
-        priceLineStyle: 2,
-        baseLineVisible: true,
-        baseLineWidth: 1,
-        baseLineColor: "#B2B5BE",
-        baseLineStyle: 0,
-        priceFormat: {
-            type: "price",
-            precision: 2,
-            minMove: 0.01
-        }
-    };
-class Ns {
-    constructor(t3, e2) {
-        this.Vm = t3, this.Nm = e2;
-    }
-    applyOptions(t3) {
-        this.Vm.Ut().oc(this.Nm, t3);
-    }
-    options() {
-        return this.zi().F();
-    }
-    width() {
-        return lh(this.Nm) ? this.Vm.Qv(this.Nm) : 0;
-    }
-    zi() {
-        return kl(this.Vm.Ut()._c(this.Nm)).Bt;
-    }
-}
-const gu = {
-    color: "#FF0000",
-    price: 0,
-    lineStyle: 2,
-    lineWidth: 1,
-    lineVisible: true,
-    axisLabelVisible: true,
-    title: "",
-    axisLabelColor: "",
-    axisLabelTextColor: ""
-};
-class Ws {
-    constructor(t3) {
-        this.wh = t3;
-    }
-    applyOptions(t3) {
-        this.wh.kh(t3);
-    }
-    options() {
-        return this.wh.F();
-    }
-    Fm() {
-        return this.wh;
-    }
-}
-class js {
-    constructor(t3, e2, i2) {
-        this.Ts = t3, this.Wm = e2, this.jm = i2;
-    }
-    priceFormatter() {
-        return this.Ts.Bl();
-    }
-    priceToCoordinate(t3) {
-        const e2 = this.Ts.Tt();
-        return null === e2 ? null : this.Ts.Bt().Dt(t3, e2.At);
-    }
-    coordinateToPrice(t3) {
-        const e2 = this.Ts.Tt();
-        return null === e2 ? null : this.Ts.Bt().pn(t3, e2.At);
-    }
-    barsInLogicalRange(t3) {
-        if (null === t3)
-            return null;
-        const e2 = new dn(new _n(t3.from, t3.to)).C_(),
-            i2 = this.Ts.Ln();
-        if (i2.Ni())
-            return null;
-        const s2 = i2.jh(e2.Ms(), 1),
-            n2 = i2.jh(e2.ci(), -1),
-            r2 = kl(i2.Nh()),
-            o2 = kl(i2.On());
-        if (null !== s2 && null !== n2 && s2.Ys > n2.Ys)
-            return {
-                barsBefore: t3.from - r2,
-                barsAfter: o2 - t3.to
-            };
-        const a2 = {
-            barsBefore: null === s2 || s2.Ys === r2 ? t3.from - r2 : s2.Ys - r2,
-            barsAfter: null === n2 || n2.Ys === o2 ? o2 - t3.to : o2 - n2.Ys
-        };
-        return null !== s2 && null !== n2 && (a2.from = s2._t.__ || s2._t.u_, a2.to = n2._t.__ || n2._t.u_), a2;
-    }
-    setData(t3) {
-        this.Ts.Lh(), this.Wm.$m(this.Ts, t3);
-    }
-    update(t3) {
-        this.Ts.Lh(), this.Wm.Hm(this.Ts, t3);
-    }
-    dataByIndex(t3, e2) {
-        const i2 = this.Ts.Ln().jh(t3, e2);
-        return null === i2 ? null : ru(this.seriesType())(i2);
-    }
-    setMarkers(t3) {
-        const e2 = t3.map((t4) => Object.assign(Object.assign({}, t4), {
-            originalTime: t4.time,
-            time: Kc(t4.time)
-        }));
-        this.Ts.gl(e2);
-    }
-    markers() {
-        return this.Ts.wl().map((t3) => {
-            const {
-                originalTime: e2,
-                time: i2
-            } = t3, s2 = function(t4, e3) {
-                var i3 = {};
-                for (var s3 in t4)
-                    Object.prototype.hasOwnProperty.call(t4, s3) && e3.indexOf(s3) < 0 && (i3[s3] = t4[s3]);
-                if (null != t4 && "function" == typeof Object.getOwnPropertySymbols) {
-                    var n2 = 0;
-                    for (s3 = Object.getOwnPropertySymbols(t4); n2 < s3.length; n2++)
-                        e3.indexOf(s3[n2]) < 0 && Object.prototype.propertyIsEnumerable.call(t4, s3[n2]) && (i3[s3[n2]] = t4[s3[n2]]);
-                }
-                return i3;
-            }(t3, ["originalTime", "time"]);
-            return Object.assign({
-                time: e2
-            }, s2);
-        });
-    }
-    applyOptions(t3) {
-        this.Ts.kh(t3);
-    }
-    options() {
-        return zl(this.Ts.F());
-    }
-    priceScale() {
-        return this.jm.priceScale(this.Ts.Bt().zl());
-    }
-    createPriceLine(t3) {
-        const e2 = Ol(zl(gu), t3),
-            i2 = this.Ts.Ml(e2);
-        return new Ws(i2);
-    }
-    removePriceLine(t3) {
-        this.Ts.Sl(t3.Fm());
-    }
-    seriesType() {
-        return this.Ts.Lh();
-    }
-}
-class $s {
-    constructor(t3, e2) {
-        this.Um = new Ll(), this.E_ = new Ll(), this.uv = new Ll(), this.Hi = t3, this.wo = t3.yt(), this.Wv = e2, this.wo.Su().l(this.qm.bind(this)), this.wo.xu().l(this.Ym.bind(this)), this.Wv.gv().l(this.Xm.bind(this));
-    }
-    M() {
-        this.wo.Su().v(this), this.wo.xu().v(this), this.Wv.gv().v(this), this.Um.M(), this.E_.M(), this.uv.M();
-    }
-    scrollPosition() {
-        return this.wo.ou();
-    }
-    scrollToPosition(t3, e2) {
-        e2 ? this.wo.gu(t3, 1e3) : this.Hi.Gn(t3);
-    }
-    scrollToRealTime() {
-        this.wo.bu();
-    }
-    getVisibleRange() {
-        var t3, e2;
-        const i2 = this.wo.G_();
-        return null === i2 ? null : {
-            from: null !== (t3 = i2.from.__) && void 0 !== t3 ? t3 : i2.from.u_,
-            to: null !== (e2 = i2.to.__) && void 0 !== e2 ? e2 : i2.to.u_
-        };
-    }
-    setVisibleRange(t3) {
-        const e2 = {
-                from: Kc(t3.from),
-                to: Kc(t3.to)
-            },
-            i2 = this.wo.iu(e2);
-        this.Hi.Oc(i2);
-    }
-    getVisibleLogicalRange() {
-        const t3 = this.wo.K_();
-        return null === t3 ? null : {
-            from: t3.Ms(),
-            to: t3.ci()
-        };
-    }
-    setVisibleLogicalRange(t3) {
-        wl(t3.from <= t3.to, "The from index cannot be after the to index."), this.Hi.Oc(t3);
-    }
-    resetTimeScale() {
-        this.Hi.Zn();
-    }
-    fitContent() {
-        this.Hi.Cu();
-    }
-    logicalToCoordinate(t3) {
-        const e2 = this.Hi.yt();
-        return e2.Ni() ? null : e2.Et(t3);
-    }
-    coordinateToLogical(t3) {
-        return this.wo.Ni() ? null : this.wo.ru(t3);
-    }
-    timeToCoordinate(t3) {
-        const e2 = Kc(t3),
-            i2 = this.wo.Fl(e2, false);
-        return null === i2 ? null : this.wo.Et(i2);
-    }
-    coordinateToTime(t3) {
-        var e2;
-        const i2 = this.Hi.yt(),
-            s2 = i2.ru(t3),
-            n2 = i2.vn(s2);
-        return null === n2 ? null : null !== (e2 = n2.__) && void 0 !== e2 ? e2 : n2.u_;
-    }
-    width() {
-        return this.Wv.qp().width;
-    }
-    height() {
-        return this.Wv.qp().height;
-    }
-    subscribeVisibleTimeRangeChange(t3) {
-        this.Um.l(t3);
-    }
-    unsubscribeVisibleTimeRangeChange(t3) {
-        this.Um.p(t3);
-    }
-    subscribeVisibleLogicalRangeChange(t3) {
-        this.E_.l(t3);
-    }
-    unsubscribeVisibleLogicalRangeChange(t3) {
-        this.E_.p(t3);
-    }
-    subscribeSizeChange(t3) {
-        this.uv.l(t3);
-    }
-    unsubscribeSizeChange(t3) {
-        this.uv.p(t3);
-    }
-    applyOptions(t3) {
-        this.wo.kh(t3);
-    }
-    options() {
-        return zl(this.wo.F());
-    }
-    qm() {
-        this.Um.g() && this.Um.m(this.getVisibleRange());
-    }
-    Ym() {
-        this.E_.g() && this.E_.m(this.getVisibleLogicalRange());
-    }
-    Xm(t3) {
-        this.uv.m(t3.width, t3.height);
-    }
-}
-
-function yu(t3) {
-    return function(t4) {
-        if (Vl(t4.handleScale)) {
-            const e3 = t4.handleScale;
-            t4.handleScale = {
-                axisDoubleClickReset: {
-                    time: e3,
-                    price: e3
-                },
-                axisPressedMouseMove: {
-                    time: e3,
-                    price: e3
-                },
-                mouseWheel: e3,
-                pinch: e3
-            };
-        } else if (void 0 !== t4.handleScale) {
-            const {
-                axisPressedMouseMove: e3,
-                axisDoubleClickReset: i2
-            } = t4.handleScale;
-            Vl(e3) && (t4.handleScale.axisPressedMouseMove = {
-                time: e3,
-                price: e3
-            }), Vl(i2) && (t4.handleScale.axisDoubleClickReset = {
-                time: i2,
-                price: i2
-            });
-        }
-        const e2 = t4.handleScroll;
-        Vl(e2) && (t4.handleScroll = {
-            horzTouchDrag: e2,
-            vertTouchDrag: e2,
-            mouseWheel: e2,
-            pressedMouseMove: e2
-        });
-    }(t3), t3;
-}
-class qs {
-    constructor(t3, e2) {
-        this.Zm = new Ss(), this.Km = /* @__PURE__ */ new Map(), this.Gm = /* @__PURE__ */ new Map(), this.Jm = new Ll(), this.Qm = new Ll();
-        const i2 = void 0 === e2 ? zl(lu) : Ol(zl(lu), yu(e2));
-        this.Vm = new Qn(t3, i2), this.Vm.jp().l((t4) => {
-            this.Jm.g() && this.Jm.m(this.tb(t4()));
-        }, this), this.Vm.fc().l((t4) => {
-            this.Qm.g() && this.Qm.m(this.tb(t4()));
-        }, this);
-        const s2 = this.Vm.Ut();
-        this.ib = new $s(s2, this.Vm.Yv());
-    }
-    remove() {
-        this.Vm.jp().v(this), this.Vm.fc().v(this), this.ib.M(), this.Vm.M(), this.Km.clear(), this.Gm.clear(), this.Jm.M(), this.Qm.M(), this.Zm.M();
-    }
-    resize(t3, e2, i2) {
-        this.autoSizeActive() || this.Vm.$v(t3, e2, i2);
-    }
-    addAreaSeries(t3) {
-        return this.nb("Area", du, t3);
-    }
-    addBaselineSeries(t3) {
-        return this.nb("Baseline", fu, t3);
-    }
-    addBarSeries(t3) {
-        return this.nb("Bar", cu, t3);
-    }
-    addCandlestickSeries(t3 = {}) {
-        return function(t4) {
-            void 0 !== t4.borderColor && (t4.borderUpColor = t4.borderColor, t4.borderDownColor = t4.borderColor), void 0 !== t4.wickColor && (t4.wickUpColor = t4.wickColor, t4.wickDownColor = t4.wickColor);
-        }(t3), this.nb("Candlestick", hu, t3);
-    }
-    addHistogramSeries(t3) {
-        return this.nb("Histogram", pu, t3);
-    }
-    addLineSeries(t3) {
-        return this.nb("Line", uu, t3);
-    }
-    removeSeries(t3) {
-        const e2 = xl(this.Km.get(t3)),
-            i2 = this.Zm.Ac(e2);
-        this.Vm.Ut().Ac(e2), this.sb(i2), this.Km.delete(t3), this.Gm.delete(e2);
-    }
-    $m(t3, e2) {
-        this.sb(this.Zm.Cm(t3, e2));
-    }
-    Hm(t3, e2) {
-        this.sb(this.Zm.Bm(t3, e2));
-    }
-    subscribeClick(t3) {
-        this.Jm.l(t3);
-    }
-    unsubscribeClick(t3) {
-        this.Jm.p(t3);
-    }
-    subscribeCrosshairMove(t3) {
-        this.Qm.l(t3);
-    }
-    unsubscribeCrosshairMove(t3) {
-        this.Qm.p(t3);
-    }
-    priceScale(t3) {
-        return new Ns(this.Vm, t3);
-    }
-    timeScale() {
-        return this.ib;
-    }
-    applyOptions(t3) {
-        this.Vm.kh(yu(t3));
-    }
-    options() {
-        return this.Vm.F();
-    }
-    takeScreenshot() {
-        return this.Vm.Gv();
-    }
-    autoSizeActive() {
-        return this.Vm.nm();
-    }
-    nb(t3, e2, i2 = {}) {
-        ! function(t4) {
-            if (void 0 === t4 || "custom" === t4.type)
-                return;
-            const e3 = t4;
-            void 0 !== e3.minMove && void 0 === e3.precision && (e3.precision = function(t5) {
-                if (t5 >= 1)
-                    return 0;
-                let e4 = 0;
-                for (; e4 < 8; e4++) {
-                    const i3 = Math.round(t5);
-                    if (Math.abs(i3 - t5) < 1e-8)
-                        return e4;
-                    t5 *= 10;
-                }
-                return e4;
-            }(e3.minMove));
-        }(i2.priceFormat);
-        const s2 = Ol(zl(mu), zl(e2), i2),
-            n2 = this.Vm.Ut().Dc(t3, s2),
-            r2 = new js(n2, this, this);
-        return this.Km.set(r2, n2), this.Gm.set(n2, r2), r2;
-    }
-    sb(t3) {
-        const e2 = this.Vm.Ut();
-        e2.Pc(t3.yt.eu, t3.yt.Em, t3.yt.zm), t3.Lm.forEach((t4, e3) => e3.tt(t4.ar, t4.Im)), e2.lu();
-    }
-    eb(t3) {
-        return xl(this.Gm.get(t3));
-    }
-    tb(t3) {
-        const e2 = /* @__PURE__ */ new Map();
-        t3.fm.forEach((t4, i3) => {
-            const s2 = ru(i3.Lh())(t4);
-            wl(function(t5) {
-                return void 0 !== t5.open || void 0 !== t5.value;
-            }(s2)), e2.set(this.eb(i3), s2);
-        });
-        const i2 = void 0 === t3.dm ? void 0 : this.eb(t3.dm);
-        return {
-            time: t3._t,
-            logical: t3.Ys,
-            point: t3.um,
-            hoveredSeries: i2,
-            hoveredObjectId: t3.pm,
-            seriesData: e2,
-            sourceEvent: t3.vm
-        };
-    }
-}
-class TwChart {
-    constructor(t3, e2) {
-        this.series = [], this.colors = ["#725bf5", "#777777", "#1dcdbc", "#2b3440", "#ffffff", "#3abff8", "#36d399", "#fbbd23", "#f87272"], this.lightTheme = {
-            layout: {
-                textColor: "rgba(0, 0, 0, 0.5)"
-            }
-        }, this.darkTheme = {
-            layout: {
-                textColor: "rgba(255, 255, 255, 0.3)"
-            }
-        }, this.selectTheme = {
-            light: this.lightTheme,
-            dark: this.darkTheme
-        }, this.candlestickSeries = null, this.htmlEle = t3, this.series = [];
-        let i2 = {
-            autoSize: true,
-            localization: {
-                locale: "zh-TW",
-                dateFormat: "yyyy-MM-dd",
-                priceFormatter: (t4) => t4.toFixed(1)
-            },
-            rightPriceScale: {
-                scaleMargins: {
-                    top: 0.1,
-                    bottom: 0.1
-                },
-                mode: tc.Percentage,
-                borderVisible: false,
-                ticksVisible: true,
-                borderColor: "rgba(197, 203, 206, 1)"
-            },
-            timeScale: {
-                borderColor: "rgba(197, 203, 206, 1)",
-                borderVisible: false
-            },
-            handleScroll: {
-                pressedMouseMove: true,
-                mouseWheel: false
-            },
-            handleScale: {
-                mouseWheel: false,
-                pinch: true
-            },
-            layout: {
-                background: {
-                    type: cc.Solid,
-                    color: "transparent"
-                },
-                textColor: "black"
-            },
-            grid: {
-                vertLines: {
-                    color: "rgba(197, 203, 206, 0.0)",
-                    style: ml.Dotted,
-                    visible: false
-                },
-                horzLines: {
-                    color: "rgba(197, 203, 206, 0.0)",
-                    style: ml.Dotted,
-                    visible: false
-                }
-            },
-            crosshair: {
-                horzLine: {
-                    visible: false,
-                    labelVisible: true
-                },
-                vertLine: {
-                    visible: false,
-                    style: 0,
-                    width: 2,
-                    color: "rgba(32, 38, 46, 0.1)",
-                    labelVisible: true
-                }
-            }
-        };
-        e2 || (i2.rightPriceScale.mode = tc.Normal), this.chart = function(t4, e3) {
-            let i3;
-            if ($l(t4)) {
-                const e4 = document.getElementById(t4);
-                wl(null !== e4, `Cannot find element in DOM with id=${t4}`), i3 = e4;
-            } else
-                i3 = t4;
-            return new qs(i3, e3);
-        }(this.htmlEle, i2);
-    }
-    setTheme(t3) {
-        t3 && this.chart.applyOptions(this.selectTheme[t3]);
-    }
-    resetAreaSeries(t3) {
-        this.series[t3] && this.chart.removeSeries(this.series[t3]);
-        const e2 = this.colors[t3];
-        this.series[t3] = this.chart.addAreaSeries({
-            lineColor: e2,
-            topColor: e2 + "77",
-            bottomColor: e2 + "00",
-            priceLineVisible: false
-        });
-    }
-    setTimeScale(t3, e2) {
-        this.chart.timeScale().setVisibleRange({
-            from: t3.getTime() / 1e3,
-            to: e2.getTime() / 1e3
-        });
-    }
-    addCandlestickSeries() {
-        this.candlestickSeries && this.chart.removeSeries(this.candlestickSeries), this.candlestickSeries = this.chart.addCandlestickSeries({
-            upColor: "#4caf50",
-            downColor: "#f44336",
-            borderDownColor: "#f44336",
-            borderUpColor: "#4caf50",
-            wickDownColor: "#f44336",
-            wickUpColor: "#4caf50"
-        });
-    }
-    updateCandlestickSeriesData(t3) {
-        if (this.candlestickSeries) {
-            const e2 = t3.map((t4) => {
-                let e3;
-                return "string" != typeof t4.time ? null : (e3 = t4.time, {
-                    time: e3,
-                    open: t4.open,
-                    high: t4.high,
-                    low: t4.low,
-                    close: t4.close
-                });
-            }).filter((t4) => null !== t4);
-            this.candlestickSeries.setData(e2);
-        }
-    }
-}
-
-function vu(t3) {
-    return "red" === (t3 || "red") ? "#f16365" : "#1dcdbc";
-}
-
-function bu(t3) {
-    return "red" === (t3 || "red") ? "#1dcdbc" : "#f16365";
-}
-
-function _u(t3, e2, i2) {
-    const s2 = t3.slice();
-    return s2[19] = e2[i2], s2;
-}
-
-function wu(t3, e2, i2) {
-    const s2 = t3.slice();
-    return s2[22] = e2[i2], s2;
-}
-
-function xu(t3, e2, i2) {
-    const s2 = t3.slice();
-    return s2[22] = e2[i2], s2;
-}
-
-function ku(t3) {
-    let e2, i2, s2, n2, r2, o2, a2 = ue(t3[8]),
-        l2 = [];
-    for (let e3 = 0; e3 < a2.length; e3 += 1)
-        l2[e3] = Eu(xu(t3, a2, e3));
-    let h2 = ue(t3[4]),
-        c2 = [];
-    for (let e3 = 0; e3 < h2.length; e3 += 1)
-        c2[e3] = Iu(_u(t3, h2, e3));
-    return {
-        c() {
-            e2 = P("div"), i2 = P("table"), s2 = P("thead"), n2 = P("tr");
-            for (let t4 = 0; t4 < l2.length; t4 += 1)
-                l2[t4].c();
-            r2 = $(), o2 = P("tbody");
-            for (let t4 = 0; t4 < c2.length; t4 += 1)
-                c2[t4].c();
-            U(s2, "class", "sticky top-0 z-20"), U(o2, "class", "w-full overflow-x-scroll"), U(i2, "class", "table divide-y divide-gray-400 max-h-full overflow-x-auto"), U(e2, "class", "");
-        },
-        m(t4, a3) {
-            S(t4, e2, a3), _(e2, i2), _(i2, s2), _(s2, n2);
-            for (let t5 = 0; t5 < l2.length; t5 += 1)
-                l2[t5] && l2[t5].m(n2, null);
-            _(i2, r2), _(i2, o2);
-            for (let t5 = 0; t5 < c2.length; t5 += 1)
-                c2[t5] && c2[t5].m(o2, null);
-        },
-        p(t4, e3) {
-            if (302 & e3) {
-                let i3;
-                for (a2 = ue(t4[8]), i3 = 0; i3 < a2.length; i3 += 1) {
-                    const s3 = xu(t4, a2, i3);
-                    l2[i3] ? l2[i3].p(s3, e3) : (l2[i3] = Eu(s3), l2[i3].c(), l2[i3].m(n2, null));
-                }
-                for (; i3 < l2.length; i3 += 1)
-                    l2[i3].d(1);
-                l2.length = a2.length;
-            }
-            if (464 & e3) {
-                let i3;
-                for (h2 = ue(t4[4]), i3 = 0; i3 < h2.length; i3 += 1) {
-                    const s3 = _u(t4, h2, i3);
-                    c2[i3] ? c2[i3].p(s3, e3) : (c2[i3] = Iu(s3), c2[i3].c(), c2[i3].m(o2, null));
-                }
-                for (; i3 < c2.length; i3 += 1)
-                    c2[i3].d(1);
-                c2.length = h2.length;
-            }
-        },
-        d(t4) {
-            t4 && E(e2), C(l2, t4), C(c2, t4);
-        }
-    };
-}
-
-function Tu(t3) {
-    let e2, i2, s2, n2, r2, o2, a2, l2;
-    return {
-        c() {
-            e2 = R("svg"), i2 = R("g"), s2 = R("g"), n2 = R("g"), r2 = R("path"), a2 = R("path"), U(i2, "id", "SVGRepo_bgCarrier"), U(i2, "stroke-width", "0"), U(s2, "id", "SVGRepo_tracerCarrier"), U(s2, "stroke-linecap", "round"), U(s2, "stroke-linejoin", "round"), U(r2, "d", "M4 2C3.44772 2 3 2.44772 3 3C3 3.55228 3.44772 4 4 4H20C20.5523 4 21 3.55228 21 3C21 2.44772 20.5523 2 20 2H4Z"), U(r2, "fill", o2 = "dark" === t3[1] ? "#ffffff" : "black"), U(a2, "d", "M7.70711 15.2929L11 18.5858L11 8C11 7.44771 11.4477 7 12 7C12.5523 7 13 7.44771 13 8L13 18.5858L16.2929 15.2929C16.6834 14.9024 17.3166 14.9024 17.7071 15.2929C18.0976 15.6834 18.0976 16.3166 17.7071 16.7071L12.7071 21.7071C12.3166 22.0976 11.6834 22.0976 11.2929 21.7071L6.29289 16.7071C5.90237 16.3166 5.90237 15.6834 6.29289 15.2929C6.68342 14.9024 7.31658 14.9024 7.70711 15.2929Z"), U(a2, "fill", l2 = "dark" === t3[1] ? "#ffffff" : "black"), U(n2, "id", "SVGRepo_iconCarrier"), U(e2, "width", "12px"), U(e2, "height", "12px"), U(e2, "viewBox", "0 0 24 24"), U(e2, "fill", "none"), U(e2, "xmlns", "http://www.w3.org/2000/svg");
-        },
-        m(t4, o3) {
-            S(t4, e2, o3), _(e2, i2), _(e2, s2), _(e2, n2), _(n2, r2), _(n2, a2);
-        },
-        p(t4, e3) {
-            2 & e3 && o2 !== (o2 = "dark" === t4[1] ? "#ffffff" : "black") && U(r2, "fill", o2), 2 & e3 && l2 !== (l2 = "dark" === t4[1] ? "#ffffff" : "black") && U(a2, "fill", l2);
-        },
-        d(t4) {
-            t4 && E(e2);
-        }
-    };
-}
-
-function Su(t3) {
-    let e2, i2, s2, n2, r2, o2, a2, l2;
-    return {
-        c() {
-            e2 = R("svg"), i2 = R("g"), s2 = R("g"), n2 = R("g"), r2 = R("path"), a2 = R("path"), U(i2, "id", "SVGRepo_bgCarrier"), U(i2, "stroke-width", "0"), U(s2, "id", "SVGRepo_tracerCarrier"), U(r2, "d", "M6.29289 8.70711C6.68342 9.09763 7.31658 9.09763 7.70711 8.70711L11 5.41421L11 16C11 16.5523 11.4477 17 12 17C12.5523 17 13 16.5523 13 16L13 5.41421L16.2929 8.70711C16.6834 9.09763 17.3166 9.09763 17.7071 8.70711C18.0976 8.31658 18.0976 7.68342 17.7071 7.29289L12.7071 2.29289C12.3166 1.90237 11.6834 1.90237 11.2929 2.29289L6.29289 7.29289C5.90237 7.68342 5.90237 8.31658 6.29289 8.70711Z"), U(r2, "fill", o2 = "dark" === t3[1] ? "#ffffff" : "black"), U(a2, "d", "M4 22C3.44772 22 3 21.5523 3 21C3 20.4477 3.44772 20 4 20H20C20.5523 20 21 20.4477 21 21C21 21.5523 20.5523 22 20 22H4Z"), U(a2, "fill", l2 = "dark" === t3[1] ? "#ffffff" : "black"), U(n2, "id", "SVGRepo_iconCarrier"), U(e2, "width", "12px"), U(e2, "height", "12px"), U(e2, "viewBox", "0 0 24 24"), U(e2, "fill", "none"), U(e2, "xmlns", "http://www.w3.org/2000/svg");
-        },
-        m(t4, o3) {
-            S(t4, e2, o3), _(e2, i2), _(e2, s2), _(e2, n2), _(n2, r2), _(n2, a2);
-        },
-        p(t4, e3) {
-            2 & e3 && o2 !== (o2 = "dark" === t4[1] ? "#ffffff" : "black") && U(r2, "fill", o2), 2 & e3 && l2 !== (l2 = "dark" === t4[1] ? "#ffffff" : "black") && U(a2, "fill", l2);
-        },
-        d(t4) {
-            t4 && E(e2);
-        }
-    };
-}
-
-function Eu(t3) {
-    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2 = t3[5]("metrics.stocks." + t3[22]) + "";
-
-    function u2(t4, e3) {
-        return "dn" === t4[3] && t4[2] === t4[22] ? Su : "up" === t4[3] && t4[2] === t4[22] ? Tu : void 0;
-    }
-    let d2 = u2(t3),
-        f2 = d2 && d2(t3);
-
-    function p2() {
-        return t3[14](t3[22]);
-    }
-    return {
-        c() {
-            e2 = P("th"), i2 = P("button"), s2 = P("span"), n2 = D(c2), r2 = $(), o2 = P("span"), f2 && f2.c(), a2 = $(), U(o2, "class", "ml-1"), U(s2, "class", "break-keep flex cursor-pointer"), U(i2, "class", "badge badge-xs border-0 select-none hover:badge-primary hover:text-white p-3 ml-0 m-3 cursor-pointer rounded-md"), U(e2, "class", "whitespace-nowrap p-0 bg-base-200 " + ("stockId" === t3[22] ? "text-left sticky left-0" : "text-center"));
-        },
-        m(t4, c3) {
-            S(t4, e2, c3), _(e2, i2), _(i2, s2), _(s2, n2), _(s2, r2), _(s2, o2), f2 && f2.m(o2, null), _(e2, a2), l2 || (h2 = B(i2, "click", p2), l2 = true);
-        },
-        p(e3, i3) {
-            t3 = e3, 32 & i3 && c2 !== (c2 = t3[5]("metrics.stocks." + t3[22]) + "") && H(n2, c2), d2 === (d2 = u2(t3)) && f2 ? f2.p(t3, i3) : (f2 && f2.d(1), f2 = d2 && d2(t3), f2 && (f2.c(), f2.m(o2, null)));
-        },
-        d(t4) {
-            t4 && E(e2), f2 && f2.d(), l2 = false, h2();
-        }
-    };
-}
-
-function Cu(t3) {
-    let e2, i2, s2, n2 = (t3[22] in t3[6] ? t3[6][t3[22]](t3[19][t3[22]]) : t3[19][t3[22]]) + "";
-    return {
-        c() {
-            e2 = P("td"), i2 = D(n2), U(e2, "class", `whitespace-nowrap w-24 pr-2 py-1 p-0 ${"stockId" === t3[22] ? "text-left sticky left-0 z-10 bg-base-200" : "text-center"} `), U(e2, "style", s2 = `color: ${t3[22] in t3[7] ? t3[7][t3[22]](t3[19][t3[22]]) : ""}`);
-        },
-        m(t4, s3) {
-            S(t4, e2, s3), _(e2, i2);
-        },
-        p(t4, r2) {
-            16 & r2 && n2 !== (n2 = (t4[22] in t4[6] ? t4[6][t4[22]](t4[19][t4[22]]) : t4[19][t4[22]]) + "") && H(i2, n2), 16 & r2 && s2 !== (s2 = `color: ${t4[22] in t4[7] ? t4[7][t4[22]](t4[19][t4[22]]) : ""}`) && U(e2, "style", s2);
-        },
-        d(t4) {
-            t4 && E(e2);
-        }
-    };
-}
-
-function Iu(t3) {
-    let e2, i2, s2 = ue(t3[8]),
-        n2 = [];
-    for (let e3 = 0; e3 < s2.length; e3 += 1)
-        n2[e3] = Cu(wu(t3, s2, e3));
-    return {
-        c() {
-            e2 = P("tr");
-            for (let t4 = 0; t4 < n2.length; t4 += 1)
-                n2[t4].c();
-            i2 = $(), U(e2, "class", "hover py-0 pl-0");
-        },
-        m(t4, s3) {
-            S(t4, e2, s3);
-            for (let t5 = 0; t5 < n2.length; t5 += 1)
-                n2[t5] && n2[t5].m(e2, null);
-            _(e2, i2);
-        },
-        p(t4, r2) {
-            if (464 & r2) {
-                let o2;
-                for (s2 = ue(t4[8]), o2 = 0; o2 < s2.length; o2 += 1) {
-                    const a2 = wu(t4, s2, o2);
-                    n2[o2] ? n2[o2].p(a2, r2) : (n2[o2] = Cu(a2), n2[o2].c(), n2[o2].m(e2, i2));
-                }
-                for (; o2 < n2.length; o2 += 1)
-                    n2[o2].d(1);
-                n2.length = s2.length;
-            }
-        },
-        d(t4) {
-            t4 && E(e2), C(n2, t4);
-        }
-    };
-}
-
-function Mu(e2) {
-    let i2, s2 = e2[0] && 0 != e2[0].trades.length && ku(e2);
-    return {
-        c() {
-            s2 && s2.c(), i2 = z();
-        },
-        m(t3, e3) {
-            s2 && s2.m(t3, e3), S(t3, i2, e3);
-        },
-        p(t3, [e3]) {
-            t3[0] && 0 != t3[0].trades.length ? s2 ? s2.p(t3, e3) : (s2 = ku(t3), s2.c(), s2.m(i2.parentNode, i2)) : s2 && (s2.d(1), s2 = null);
-        },
-        i: t,
-        o: t,
-        d(t3) {
-            t3 && E(i2), s2 && s2.d(t3);
-        }
-    };
-}
-
-function Pu(t3, e2, i2) {
-    let s2, {
-            lang: n2 = "en"
-        } = e2,
-        {
-            browser: r2
-        } = e2,
-        {
-            report: o2
-        } = e2,
-        {
-            theme: a2 = "light"
-        } = e2,
-        {
-            candle: l2 = "red"
-        } = e2,
-        {
-            tstart: h2 = null
-        } = e2,
-        {
-            tend: c2 = null
-        } = e2;
-    pt(() => {});
-    const u2 = (t4) => t4 ? t4 == null ? void 0 : t4.toLocaleDateString() : null,
-        d2 = (t4) => (100 * t4).toFixed(1) + "%",
-        f2 = {
-            entry: u2,
-            exit: u2,
-            entrySig: u2,
-            exitSig: u2,
-            position: d2,
-            return: d2,
-            mae: d2,
-            gmfe: d2,
-            bmfe: d2,
-            mdd: d2
-        },
-        p2 = (t4) => t4 > 0 ? vu(l2) : bu(l2),
-        m2 = (t4) => h2 <= t4 && t4 <= c2 ? "underline" : "",
-        g2 = {
-            entry: m2,
-            exit: m2,
-            position: p2,
-            return: p2,
-            mae: p2,
-            mfe: p2,
-            mdd: p2,
-            gmfe: p2,
-            bmfe: p2
-        };
-    let y2 = "entry",
-        v2 = "dn",
-        b2 = [];
-    return t3.$$set = (t4) => {
-        "lang" in t4 && i2(9, n2 = t4.lang), "browser" in t4 && i2(10, r2 = t4.browser), "report" in t4 && i2(0, o2 = t4.report), "theme" in t4 && i2(1, a2 = t4.theme), "candle" in t4 && i2(11, l2 = t4.candle), "tstart" in t4 && i2(12, h2 = t4.tstart), "tend" in t4 && i2(13, c2 = t4.tend);
-    }, t3.$$.update = () => {
-        512 & t3.$$.dirty && i2(5, s2 = (t4) => "en" === n2 ? sl(t4) : nl(t4)), 12317 & t3.$$.dirty && (o2 || h2 || c2) && (i2(4, b2 = o2.trades.sort((t4, e3) => "up" === v2 ? t4[y2] > e3[y2] ? 1 : -1 : t4[y2] < e3[y2] ? 1 : -1)), h2 && c2 && i2(4, b2 = b2.filter((t4) => t4.entry && t4.exit && (t4.entry <= h2 && h2 <= t4.exit || t4.entry <= c2 && c2 <= t4.exit))), i2(4, b2 = b2.slice(0, 50).filter((t4) => Object.values(t4).every((t5) => null !== t5))));
-    }, [o2, a2, y2, v2, b2, s2, f2, g2, ["stockId", "return", "entry", "exit", "position", "entryPrice", "exitPrice", "entrySig", "exitSig", "mae", "gmfe", "bmfe", "mdd"], n2, r2, l2, h2, c2, (t4) => {
-        y2 !== t4 ? i2(2, y2 = t4) : i2(3, v2 = {
-            up: "dn",
-            dn: "up"
-        } [v2]);
-    }];
-}
-class Stocks extends SvelteComponent {
-    constructor(t3) {
-        super(), ve(this, t3, Pu, Mu, o, {
-            lang: 9,
-            browser: 10,
-            report: 0,
-            theme: 1,
-            candle: 11,
-            tstart: 12,
-            tend: 13
-        });
-    }
-    get lang() {
-        return this.$$.ctx[9];
-    }
-    set lang(t3) {
-        this.$$set({
-            lang: t3
-        }), te();
-    }
-    get browser() {
-        return this.$$.ctx[10];
-    }
-    set browser(t3) {
-        this.$$set({
-            browser: t3
-        }), te();
-    }
-    get report() {
-        return this.$$.ctx[0];
-    }
-    set report(t3) {
-        this.$$set({
-            report: t3
-        }), te();
-    }
-    get theme() {
-        return this.$$.ctx[1];
-    }
-    set theme(t3) {
-        this.$$set({
-            theme: t3
-        }), te();
-    }
-    get candle() {
-        return this.$$.ctx[11];
-    }
-    set candle(t3) {
-        this.$$set({
-            candle: t3
-        }), te();
-    }
-    get tstart() {
-        return this.$$.ctx[12];
-    }
-    set tstart(t3) {
-        this.$$set({
-            tstart: t3
-        }), te();
-    }
-    get tend() {
-        return this.$$.ctx[13];
-    }
-    set tend(t3) {
-        this.$$set({
-            tend: t3
-        }), te();
-    }
-}
-
-function Ru(e2) {
-    let i2, s2;
-    return {
-        c() {
-            i2 = R("svg"), s2 = R("use"), U(s2, "href", e2[3]), U(s2, "fill", e2[0]), U(s2, "stroke", e2[1]), U(i2, "class", e2[2]), U(i2, "aria-hidden", "true");
-        },
-        m(t3, e3) {
-            S(t3, i2, e3), _(i2, s2);
-        },
-        p(t3, [e3]) {
-            8 & e3 && U(s2, "href", t3[3]), 1 & e3 && U(s2, "fill", t3[0]), 2 & e3 && U(s2, "stroke", t3[1]), 4 & e3 && U(i2, "class", t3[2]);
-        },
-        i: t,
-        o: t,
-        d(t3) {
-            t3 && E(i2);
-        }
-    };
-}
-
-function Au(t3, e2, i2) {
-    let s2, {
-            prefix: n2 = "icon"
-        } = e2,
-        {
-            name: r2 = ""
-        } = e2,
-        {
-            color: o2 = "#333"
-        } = e2,
-        {
-            strokeColor: a2 = ""
-        } = e2,
-        {
-            className: l2 = ""
-        } = e2;
-    return t3.$$set = (t4) => {
-        "prefix" in t4 && i2(4, n2 = t4.prefix), "name" in t4 && i2(5, r2 = t4.name), "color" in t4 && i2(0, o2 = t4.color), "strokeColor" in t4 && i2(1, a2 = t4.strokeColor), "className" in t4 && i2(2, l2 = t4.className);
-    }, t3.$$.update = () => {
-        48 & t3.$$.dirty && i2(3, s2 = `#${n2}-${r2}`);
-    }, [o2, a2, l2, s2, n2, r2];
-}
-we(Stocks, {
-    lang: {},
-    browser: {},
-    report: {},
-    theme: {},
-    candle: {},
-    tstart: {},
-    tend: {}
-}, [], [], true);
-let Du = class Svgicon extends SvelteComponent {
-    constructor(t3) {
-        super(), ve(this, t3, Au, Ru, o, {
-            prefix: 4,
-            name: 5,
-            color: 0,
-            strokeColor: 1,
-            className: 2
-        });
-    }
-    get prefix() {
-        return this.$$.ctx[4];
-    }
-    set prefix(t3) {
-        this.$$set({
-            prefix: t3
-        }), te();
-    }
-    get name() {
-        return this.$$.ctx[5];
-    }
-    set name(t3) {
-        this.$$set({
-            name: t3
-        }), te();
-    }
-    get color() {
-        return this.$$.ctx[0];
-    }
-    set color(t3) {
-        this.$$set({
-            color: t3
-        }), te();
-    }
-    get strokeColor() {
-        return this.$$.ctx[1];
-    }
-    set strokeColor(t3) {
-        this.$$set({
-            strokeColor: t3
-        }), te();
-    }
-    get className() {
-        return this.$$.ctx[2];
-    }
-    set className(t3) {
-        this.$$set({
-            className: t3
-        }), te();
-    }
-};
-
-function Lu() {
-    const t3 = navigator.userAgent || navigator.vendor;
-    return /iPad|iPhone|iPod|android/i.test(t3);
-}
-
-function Ou() {
-    return window.self !== window.top;
-}
-
-function Fu(t3) {
-    w(t3, "svelte-13tqbdu", ".grid-cols-14.svelte-13tqbdu{grid-template-columns:repeat(14, minmax(0, 1fr))}");
-}
-
-function Nu(t3, e2, i2) {
-    const s2 = t3.slice();
-    return s2[50] = e2[i2], s2;
-}
-
-function $u(t3, e2, i2) {
-    const s2 = t3.slice();
-    return s2[53] = e2[i2], s2;
-}
-
-function Vu(t3, e2, i2) {
-    const s2 = t3.slice();
-    return s2[53] = e2[i2], s2;
-}
-
-function zu(t3, e2, i2) {
-    const s2 = t3.slice();
-    return s2[50] = e2[i2], s2;
-}
-
-function Bu(t3) {
-    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2 = t3[50] + "",
-        d2 = (100 * t3[6][t3[50]] || 0).toFixed(1) + "";
-
-    function f2() {
-        return t3[35](t3[50]);
-    }
-    return {
-        c() {
-            e2 = P("div"), i2 = P("span"), s2 = D(u2), n2 = $(), r2 = P("button"), o2 = D(d2), a2 = D("%"), U(i2, "class", "text-sm border-l pl-1"), U(r2, "class", "w-full py-1 px-2 text-sm"), U(r2, "style", l2 = `background:${t3[13][`${t3[50]}`]}`), U(e2, "class", "flex-l");
-        },
-        m(t4, l3) {
-            S(t4, e2, l3), _(e2, i2), _(i2, s2), _(e2, n2), _(e2, r2), _(r2, o2), _(r2, a2), h2 || (c2 = B(r2, "click", f2), h2 = true);
-        },
-        p(e3, i3) {
-            t3 = e3, 50331648 & i3[0] && u2 !== (u2 = t3[50] + "") && H(s2, u2), 50331712 & i3[0] && d2 !== (d2 = (100 * t3[6][t3[50]] || 0).toFixed(1) + "") && H(o2, d2), 50339840 & i3[0] && l2 !== (l2 = `background:${t3[13][`${t3[50]}`]}`) && U(r2, "style", l2);
-        },
-        d(t4) {
-            t4 && E(e2), h2 = false, c2();
-        }
-    };
-}
-
-function Uu(e2) {
-    let i2;
-    return {
-        c() {
-            i2 = P("div"), i2.textContent = `${e2[53]} 月`, U(i2, "class", "flex justify-center items-center");
-        },
-        m(t3, e3) {
-            S(t3, i2, e3);
-        },
-        p: t,
-        d(t3) {
-            t3 && E(i2);
-        }
-    };
-}
-
-function ju(t3) {
-    let e2, i2, s2, n2, r2, o2, a2, l2 = Ku((100 * (t3[7][`${t3[50]}${t3[53]}`] || 0)).toFixed(1)) + "";
-
-    function h2() {
-        return t3[37](t3[50], t3[53]);
-    }
-    return {
-        c() {
-            e2 = P("div"), i2 = D(l2), s2 = D("%"), U(e2, "class", n2 = f(`cursor-pointer flex justify-center items-center hover:text-base-content-300 hover:z-20 hover:outline hover:shadow-primary hover:outline-2 hover:outline-primary hover:border-none hover:rounded-lg hover:font-bold hover:text-2xl hover:-m-3 hover:shadow-lg 
-								${t3[50] === t3[10] ? "border-t-2 border-b-2 border-primary" : ""} 								${t3[50] === t3[10] && 1 == t3[53] ? "border-l-2 border-primary rounded-l-lg" : ""} 								${t3[50] === t3[10] && 12 == t3[53] ? "border-r-2 border-primary rounded-r-lg" : ""} 								${t3[53] === t3[9] && t3[50] === t3[10] ? "text-base-content-300 text-2xl -m-4 font-bold outline shadow-primary outline-2 outline-primary border-none rounded-lg z-20 shadow-2xl" : ""}`) + " svelte-13tqbdu"), U(e2, "style", r2 = `background:${t3[12][`${t3[50]}${t3[53]}`]}`);
-        },
-        m(t4, n3) {
-            S(t4, e2, n3), _(e2, i2), _(e2, s2), o2 || (a2 = B(e2, "click", h2), o2 = true);
-        },
-        p(s3, o3) {
-            t3 = s3, 50331776 & o3[0] && l2 !== (l2 = Ku((100 * (t3[7][`${t3[50]}${t3[53]}`] || 0)).toFixed(1)) + "") && H(i2, l2), 50333184 & o3[0] && n2 !== (n2 = f(`cursor-pointer flex justify-center items-center hover:text-base-content-300 hover:z-20 hover:outline hover:shadow-primary hover:outline-2 hover:outline-primary hover:border-none hover:rounded-lg hover:font-bold hover:text-2xl hover:-m-3 hover:shadow-lg 
-								${t3[50] === t3[10] ? "border-t-2 border-b-2 border-primary" : ""} 								${t3[50] === t3[10] && 1 == t3[53] ? "border-l-2 border-primary rounded-l-lg" : ""} 								${t3[50] === t3[10] && 12 == t3[53] ? "border-r-2 border-primary rounded-r-lg" : ""} 								${t3[53] === t3[9] && t3[50] === t3[10] ? "text-base-content-300 text-2xl -m-4 font-bold outline shadow-primary outline-2 outline-primary border-none rounded-lg z-20 shadow-2xl" : ""}`) + " svelte-13tqbdu") && U(e2, "class", n2), 50335744 & o3[0] && r2 !== (r2 = `background:${t3[12][`${t3[50]}${t3[53]}`]}`) && U(e2, "style", r2);
-        },
-        d(t4) {
-            t4 && E(e2), o2 = false, a2();
-        }
-    };
-}
-
-function Hu(t3) {
-    let e2, i2, s2, n2, r2, o2, a2, l2 = t3[50] + "",
-        h2 = t3[50] + "",
-        c2 = ue([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]),
-        u2 = [];
-    for (let e3 = 0; e3 < 12; e3 += 1)
-        u2[e3] = ju($u(t3, c2, e3));
-    return {
-        c() {
-            e2 = P("div"), i2 = D(l2), s2 = $();
-            for (let t4 = 0; t4 < 12; t4 += 1)
-                u2[t4].c();
-            n2 = $(), r2 = P("div"), o2 = D(h2), a2 = $(), U(e2, "class", "h-7 md:h-10 flex justify-start items-center"), U(r2, "class", "flex justify-center items-center border border-base-content/0");
-        },
-        m(t4, l3) {
-            S(t4, e2, l3), _(e2, i2), S(t4, s2, l3);
-            for (let e3 = 0; e3 < 12; e3 += 1)
-                u2[e3] && u2[e3].m(t4, l3);
-            S(t4, n2, l3), S(t4, r2, l3), _(r2, o2), _(r2, a2);
-        },
-        p(t4, e3) {
-            if (50331648 & e3[0] && l2 !== (l2 = t4[50] + "") && H(i2, l2), 520099504 & e3[0]) {
-                let i3;
-                for (c2 = ue([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]), i3 = 0; i3 < 12; i3 += 1) {
-                    const s3 = $u(t4, c2, i3);
-                    u2[i3] ? u2[i3].p(s3, e3) : (u2[i3] = ju(s3), u2[i3].c(), u2[i3].m(n2.parentNode, n2));
-                }
-                for (; i3 < 12; i3 += 1)
-                    u2[i3].d(1);
-            }
-            50331648 & e3[0] && h2 !== (h2 = t4[50] + "") && H(o2, h2);
-        },
-        d(t4) {
-            t4 && (E(e2), E(s2), E(n2), E(r2)), C(u2, t4);
-        }
-    };
-}
-
-function Wu(t3) {
-    var _a2, _b2;
-    let e2, i2, s2, n2 = ((_a2 = t3[23]) == null ? void 0 : _a2.toLocaleDateString()) + "",
-        r2 = ((_b2 = t3[22]) == null ? void 0 : _b2.toLocaleDateString()) + "";
-    return {
-        c() {
-            e2 = D(n2), i2 = D("~"), s2 = D(r2);
-        },
-        m(t4, n3) {
-            S(t4, e2, n3), S(t4, i2, n3), S(t4, s2, n3);
-        },
-        p(t4, i3) {
-            var _a3, _b3;
-            8388608 & i3[0] && n2 !== (n2 = ((_a3 = t4[23]) == null ? void 0 : _a3.toLocaleDateString()) + "") && H(e2, n2), 4194304 & i3[0] && r2 !== (r2 = ((_b3 = t4[22]) == null ? void 0 : _b3.toLocaleDateString()) + "") && H(s2, r2);
-        },
-        d(t4) {
-            t4 && (E(e2), E(i2), E(s2));
-        }
-    };
-}
-
-function qu(t3) {
-    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2, d2, p2, m2, g2, y2, v2, b2, w2, x2, k2, T2, R2, z2, j2, q2, Y2, it2, st2, rt2, ht2, ct2, ut2, dt2, ft2, pt2, yt2, bt2, _t2, xt2, kt2, St2, It2, Mt2, At2, Lt2, Ot2, Ht2, Qt2, Jt2, te2, ee2, ie2, se2, ne2, re2, oe2, ae2, ce2, de2, fe2, pe2, ve2, be2, _e2, we2, xe2, ke2, Te2, Se2, Ee2, Ce2, Ie2, Me2, Pe2, Re2, Ae2, De2, Le2, Oe2, Fe2, Ne2, $e2, Ve2, ze2, Be2, Ue2, je2, He2, We2, qe2, Ke2, Ge2, Ye2, Qe2, Xe2, Je2, Ze2, ti2, ei2, si2 = t3[19]("profitability.historicalReturn") + "",
-        ni2 = (t3[4] < 10 ? "0" + t3[4] : t3[4]) + "",
-        ri2 = t3[19]("profitability.monthlyReturn") + "",
-        ai2 = t3[19]("profitability.avgMonthlyReturn") + "",
-        li2 = Ku((100 * t3[21]).toFixed(2)) + "",
-        hi2 = t3[19]("profitability.monthlyWinRatio") + "",
-        ci2 = t3[20].toFixed(1) + "",
-        ui2 = t3[19]("profitability.monthlyReturn") + "",
-        yi2 = t3[19]("profitability.stockList") + "",
-        _i2 = t3[19]("profitability.YearlyCompareWithBenchmark") + "",
-        ki2 = t3[19]("profitability.yearlyWinRate") + "",
-        Ti2 = t3[15] + t3[16] + "",
-        Si2 = t3[19]("profitability.year") + "",
-        Ei2 = t3[19]("strategy") + "",
-        Ii2 = t3[19]("benchmark") + "",
-        Li2 = t3[19]("profitability.exceedReturn") + "",
-        Oi2 = t3[19]("average") + "",
-        Fi2 = Ku((100 * t3[14]).toFixed(2)) + "",
-        Ni2 = t3[19]("strategy") + "",
-        Vi2 = ue(Array.from(Array(t3[24] + 1).keys()).slice(t3[25])),
-        zi2 = [];
-    for (let e3 = 0; e3 < Vi2.length; e3 += 1)
-        zi2[e3] = Bu(zu(t3, Vi2, e3));
-    let Ui2 = ue([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]),
-        ji2 = [];
-    for (let e3 = 0; e3 < 12; e3 += 1)
-        ji2[e3] = Uu(Vu(t3, Ui2, e3));
-    let Wi2 = ue(Array.from(Array(t3[24] + 1).keys()).slice(t3[25])),
-        qi2 = [];
-    for (let e3 = 0; e3 < Wi2.length; e3 += 1)
-        qi2[e3] = Hu(Nu(t3, Wi2, e3));
-    let Gi2 = t3[5] && Wu(t3);
-    return re2 = new Stocks({
-        props: {
-            lang: t3[3],
-            report: t3[1],
-            theme: t3[2],
-            browser: t3[0],
-            tstart: t3[23],
-            tend: t3[22]
-        }
-    }), {
-        c() {
-            e2 = P("div"), i2 = P("div"), s2 = P("div"), n2 = P("h3"), r2 = D(si2), o2 = $(), a2 = P("div"), l2 = P("div"), h2 = $(), c2 = P("div"), u2 = D(t3[5]), d2 = D("-"), p2 = D(ni2), m2 = $(), g2 = P("div"), y2 = P("div");
-            for (let t4 = 0; t4 < zi2.length; t4 += 1)
-                zi2[t4].c();
-            v2 = $(), b2 = P("div"), w2 = P("button"), w2.textContent = "reset", x2 = $(), k2 = P("div"), T2 = P("h3"), R2 = D(ri2), z2 = $(), j2 = P("div"), q2 = P("span"), Y2 = D(ai2), it2 = D("："), st2 = D(li2), rt2 = D("%"), ht2 = $(), ct2 = P("span"), ut2 = D(hi2), dt2 = D("："), ft2 = D(ci2), pt2 = D("%"), yt2 = $(), bt2 = P("div"), _t2 = P("div"), xt2 = P("div"), kt2 = P("div"), St2 = D(ui2), It2 = $();
-            for (let t4 = 0; t4 < 12; t4 += 1)
-                ji2[t4].c();
-            Mt2 = $(), At2 = P("div"), Lt2 = $();
-            for (let t4 = 0; t4 < qi2.length; t4 += 1)
-                qi2[t4].c();
-            Ot2 = $(), Ht2 = P("div"), Qt2 = P("h3"), Jt2 = D(yi2), te2 = $(), ee2 = P("h4"), Gi2 && Gi2.c(), ie2 = $(), se2 = P("div"), ne2 = P("div"), me(re2.$$.fragment), oe2 = $(), ae2 = P("div"), ce2 = P("h3"), de2 = D(_i2), fe2 = $(), pe2 = P("div"), ve2 = P("span"), be2 = D(ki2), _e2 = D("："), we2 = $(), xe2 = D(t3[15]), ke2 = D(" / "), Te2 = D(Ti2), Se2 = $(), Ee2 = D(Si2), Ce2 = $(), Ie2 = P("div"), Me2 = P("div"), Pe2 = P("div"), Re2 = D(Ei2), Ae2 = $(), De2 = P("div"), Le2 = D(Ii2), Oe2 = $(), Fe2 = P("canvas"), Ne2 = $(), $e2 = P("div"), Ve2 = P("h3"), ze2 = D(Li2), Be2 = $(), Ue2 = P("div"), je2 = P("span"), He2 = D(Oi2), We2 = D("："), qe2 = D(Fi2), Ke2 = D("%\n			"), Ge2 = P("div"), Ye2 = P("div"), Qe2 = D(Ni2), Xe2 = $(), Je2 = P("canvas"), U(n2, "class", "text-2xl font-bold text-base-content-200"), U(l2, "class", "text-primary h-64 z-0"), U(c2, "class", "absolute bg-primary/10 rounded-lg font-bold text-center whitespace-nowrap text-base-content-100 text-sm flex justify-center items-start pt-2"), U(a2, "class", "relative overflow-hidden -mt-8"), U(w2, "class", "mt-6 py-1 px-2 bg-base-100"), U(b2, "class", "flex-l text-center text-sm"), U(y2, "class", "flex text-base-content-300 my-6"), U(g2, "class", "relative w-full overflow-x-auto no-scrollbar"), U(s2, "class", ""), U(i2, "class", "col-span-6 md:col-span-6 md:p-8 pt-8 md:border rounded-xl"), U(T2, "class", "text-base-content-200 text-2xl font-bold"), U(ct2, "class", "ml-4"), U(j2, "class", "flex mt-2 text-base-content-100"), U(kt2, "class", "h-5 md:h-10 flex justify-start items-center"), U(At2, "class", "flex justify-center items-center"), U(xt2, "class", "grid grid-cols-14 mt-3 text-xs text-base-content-200 rounded-xl min-w-[640px] pb-4 overflow-y-hidden svelte-13tqbdu"), U(_t2, "class", f(`overflow-x-auto
-				${Lu() ? "no-scrollbar" : "show-scrollbar"}
-			`) + " svelte-13tqbdu"), U(bt2, "class", "relative"), U(k2, "class", "col-span-6 md:col-span-6 md:p-8 pt-8 md:border sm:rounded-xl"), U(Qt2, "class", "text-base-content-200 text-2xl font-bold md:text-center"), U(ee2, "class", "mt-2 text-base-content-100 md:text-center"), U(ne2, "class", f(`overflow-auto max-h-72 text-base-content
-				${Lu() ? "no-scrollbar" : "show-scrollbar"}
-				`) + " svelte-13tqbdu"), U(se2, "class", "relative"), U(Ht2, "class", "col-span-6 md:col-span-6 md:p-8 pt-8 md:border sm:rounded-xl"), U(ce2, "class", "text-base-content-200 text-2xl font-bold md:text-center"), U(pe2, "class", "mt-2 text-base-content-100 md:text-center"), U(Pe2, "class", "badge rounded bg-primary text-white mr-2"), U(De2, "class", "badge rounded bg-gray-500 text-white"), U(Me2, "class", "text-sm mt-2 flex md:justify-center"), U(Fe2, "class", "h-48 mt-4"), G(Fe2, "width", "580px"), U(ae2, "class", "col-span-6 md:col-span-3 md:p-8 pt-8 md:border sm:rounded-xl"), U(Ve2, "class", "text-base-content-200 text-2xl font-bold md:text-center"), U(Ye2, "class", "badge rounded badge-primary text-white"), U(Ge2, "class", "text-sm mt-2 flex md:justify-center"), U(Je2, "class", "h-48 mt-4"), G(Je2, "width", "580px"), U(Ue2, "class", "mt-2 text-base-content-100 md:text-center"), U($e2, "class", "col-span-6 md:col-span-3 md:p-8 pt-8 md:border sm:rounded-xl"), U(e2, "class", "grid grid-cols-6 mb-2 gap-4");
-        },
-        m(f2, E2) {
-            S(f2, e2, E2), _(e2, i2), _(i2, s2), _(s2, n2), _(n2, r2), _(s2, o2), _(s2, a2), _(a2, l2), t3[33](l2), _(a2, h2), _(a2, c2), _(c2, u2), _(c2, d2), _(c2, p2), t3[34](c2), _(s2, m2), _(s2, g2), _(g2, y2);
-            for (let t4 = 0; t4 < zi2.length; t4 += 1)
-                zi2[t4] && zi2[t4].m(y2, null);
-            _(y2, v2), _(y2, b2), _(b2, w2), _(e2, x2), _(e2, k2), _(k2, T2), _(T2, R2), _(k2, z2), _(k2, j2), _(j2, q2), _(q2, Y2), _(q2, it2), _(q2, st2), _(q2, rt2), _(j2, ht2), _(j2, ct2), _(ct2, ut2), _(ct2, dt2), _(ct2, ft2), _(ct2, pt2), _(k2, yt2), _(k2, bt2), _(bt2, _t2), _(_t2, xt2), _(xt2, kt2), _(kt2, St2), _(xt2, It2);
-            for (let t4 = 0; t4 < 12; t4 += 1)
-                ji2[t4] && ji2[t4].m(xt2, null);
-            _(xt2, Mt2), _(xt2, At2), _(xt2, Lt2);
-            for (let t4 = 0; t4 < qi2.length; t4 += 1)
-                qi2[t4] && qi2[t4].m(xt2, null);
-            _(e2, Ot2), _(e2, Ht2), _(Ht2, Qt2), _(Qt2, Jt2), _(Ht2, te2), _(Ht2, ee2), Gi2 && Gi2.m(ee2, null), _(Ht2, ie2), _(Ht2, se2), _(se2, ne2), ge(re2, ne2, null), _(e2, oe2), _(e2, ae2), _(ae2, ce2), _(ce2, de2), _(ae2, fe2), _(ae2, pe2), _(pe2, ve2), _(ve2, be2), _(ve2, _e2), _(pe2, we2), _(pe2, xe2), _(pe2, ke2), _(pe2, Te2), _(pe2, Se2), _(pe2, Ee2), _(ae2, Ce2), _(ae2, Ie2), _(Ie2, Me2), _(Me2, Pe2), _(Pe2, Re2), _(Me2, Ae2), _(Me2, De2), _(De2, Le2), _(Ie2, Oe2), _(Ie2, Fe2), t3[38](Fe2), _(e2, Ne2), _(e2, $e2), _($e2, Ve2), _(Ve2, ze2), _($e2, Be2), _($e2, Ue2), _(Ue2, je2), _(je2, He2), _(je2, We2), _(Ue2, qe2), _(Ue2, Ke2), _(Ue2, Ge2), _(Ge2, Ye2), _(Ye2, Qe2), _(Ue2, Xe2), _(Ue2, Je2), t3[39](Je2), Ze2 = true, ti2 || (ei2 = B(w2, "click", t3[36]), ti2 = true);
-        },
-        p(t4, e3) {
-            if ((!Ze2 || 524288 & e3[0]) && si2 !== (si2 = t4[19]("profitability.historicalReturn") + "") && H(r2, si2), (!Ze2 || 32 & e3[0]) && H(u2, t4[5]), (!Ze2 || 16 & e3[0]) && ni2 !== (ni2 = (t4[4] < 10 ? "0" + t4[4] : t4[4]) + "") && H(p2, ni2), 452994112 & e3[0]) {
-                let i4;
-                for (Vi2 = ue(Array.from(Array(t4[24] + 1).keys()).slice(t4[25])), i4 = 0; i4 < Vi2.length; i4 += 1) {
-                    const s3 = zu(t4, Vi2, i4);
-                    zi2[i4] ? zi2[i4].p(s3, e3) : (zi2[i4] = Bu(s3), zi2[i4].c(), zi2[i4].m(y2, v2));
-                }
-                for (; i4 < zi2.length; i4 += 1)
-                    zi2[i4].d(1);
-                zi2.length = Vi2.length;
-            }
-            if ((!Ze2 || 524288 & e3[0]) && ri2 !== (ri2 = t4[19]("profitability.monthlyReturn") + "") && H(R2, ri2), (!Ze2 || 524288 & e3[0]) && ai2 !== (ai2 = t4[19]("profitability.avgMonthlyReturn") + "") && H(Y2, ai2), (!Ze2 || 2097152 & e3[0]) && li2 !== (li2 = Ku((100 * t4[21]).toFixed(2)) + "") && H(st2, li2), (!Ze2 || 524288 & e3[0]) && hi2 !== (hi2 = t4[19]("profitability.monthlyWinRatio") + "") && H(ut2, hi2), (!Ze2 || 1048576 & e3[0]) && ci2 !== (ci2 = t4[20].toFixed(1) + "") && H(ft2, ci2), (!Ze2 || 524288 & e3[0]) && ui2 !== (ui2 = t4[19]("profitability.monthlyReturn") + "") && H(St2, ui2), 520099504 & e3[0]) {
-                let i4;
-                for (Wi2 = ue(Array.from(Array(t4[24] + 1).keys()).slice(t4[25])), i4 = 0; i4 < Wi2.length; i4 += 1) {
-                    const s3 = Nu(t4, Wi2, i4);
-                    qi2[i4] ? qi2[i4].p(s3, e3) : (qi2[i4] = Hu(s3), qi2[i4].c(), qi2[i4].m(xt2, null));
-                }
-                for (; i4 < qi2.length; i4 += 1)
-                    qi2[i4].d(1);
-                qi2.length = Wi2.length;
-            }
-            (!Ze2 || 524288 & e3[0]) && yi2 !== (yi2 = t4[19]("profitability.stockList") + "") && H(Jt2, yi2), t4[5] ? Gi2 ? Gi2.p(t4, e3) : (Gi2 = Wu(t4), Gi2.c(), Gi2.m(ee2, null)) : Gi2 && (Gi2.d(1), Gi2 = null);
-            const i3 = {};
-            8 & e3[0] && (i3.lang = t4[3]), 2 & e3[0] && (i3.report = t4[1]), 4 & e3[0] && (i3.theme = t4[2]), 1 & e3[0] && (i3.browser = t4[0]), 8388608 & e3[0] && (i3.tstart = t4[23]), 4194304 & e3[0] && (i3.tend = t4[22]), re2.$set(i3), (!Ze2 || 524288 & e3[0]) && _i2 !== (_i2 = t4[19]("profitability.YearlyCompareWithBenchmark") + "") && H(de2, _i2), (!Ze2 || 524288 & e3[0]) && ki2 !== (ki2 = t4[19]("profitability.yearlyWinRate") + "") && H(be2, ki2), (!Ze2 || 32768 & e3[0]) && H(xe2, t4[15]), (!Ze2 || 98304 & e3[0]) && Ti2 !== (Ti2 = t4[15] + t4[16] + "") && H(Te2, Ti2), (!Ze2 || 524288 & e3[0]) && Si2 !== (Si2 = t4[19]("profitability.year") + "") && H(Ee2, Si2), (!Ze2 || 524288 & e3[0]) && Ei2 !== (Ei2 = t4[19]("strategy") + "") && H(Re2, Ei2), (!Ze2 || 524288 & e3[0]) && Ii2 !== (Ii2 = t4[19]("benchmark") + "") && H(Le2, Ii2), (!Ze2 || 524288 & e3[0]) && Li2 !== (Li2 = t4[19]("profitability.exceedReturn") + "") && H(ze2, Li2), (!Ze2 || 524288 & e3[0]) && Oi2 !== (Oi2 = t4[19]("average") + "") && H(He2, Oi2), (!Ze2 || 16384 & e3[0]) && Fi2 !== (Fi2 = Ku((100 * t4[14]).toFixed(2)) + "") && H(qe2, Fi2), (!Ze2 || 524288 & e3[0]) && Ni2 !== (Ni2 = t4[19]("strategy") + "") && H(Qe2, Ni2);
-        },
-        i(t4) {
-            Ze2 || (le(re2.$$.fragment, t4), Ze2 = true);
-        },
-        o(t4) {
-            he(re2.$$.fragment, t4), Ze2 = false;
-        },
-        d(i3) {
-            i3 && E(e2), t3[33](null), t3[34](null), C(zi2, i3), C(ji2, i3), C(qi2, i3), Gi2 && Gi2.d(), ye(re2), t3[38](null), t3[39](null), ti2 = false, ei2();
-        }
-    };
-}
-
-function Ku(t3) {
-    return t3 > 0 ? "+" + String(t3) : t3;
-}
-
-function Gu(t3) {
-    return 0 === t3.length ? 0 : t3[0] + Gu(t3.slice(1));
-}
-
-function Yu(t3, e2, i2) {
-    let s2, n2, r2, o2, a2, l2, h2, c2, u2, d2, f2, p2, m2, g2, y2, v2;
-    Chart.register(LinearScale, BarController, CategoryScale, BarElement, Ga);
-    let b2, {
-            browser: _2
-        } = e2,
-        {
-            report: w2
-        } = e2,
-        {
-            theme: x2 = "light"
-        } = e2,
-        {
-            showAll: k2 = true
-        } = e2,
-        {
-            lang: T2 = "en"
-        } = e2;
-    void 0 !== window && (window.report = w2);
-    let S2 = null;
-    pt(() => {
-        B2("all"), ut2();
-    }), yt(() => {
-        ht2 && ht2.destroy(), ct2 && ct2.destroy();
-    });
-    let E2, C2 = null,
-        P2 = null,
-        R2 = null,
-        D2 = k2 ? null : r2;
-
-    function $2() {
-        if (R2 && D2 && w2 && S2 && b2) {
-            const t4 = `${D2}-${R2 < 10 ? `0${R2}` : String(R2)}-01`,
-                e3 = `${D2}-${R2 + 1 < 10 ? `0${R2 + 1}` : String(R2 + 1)}-01`,
-                s3 = w2.indexOfTimestamps(t4),
-                n3 = w2.indexOfTimestamps(e3);
-            if (!w2.timestamps[s3] | !w2.timestamps[n3])
-                return;
-            const r3 = S2.chart.timeScale().timeToCoordinate(w2.timestamps[s3]),
-                o3 = S2.chart.timeScale().timeToCoordinate(w2.timestamps[n3]);
-            r3 && o3 && (i2(11, E2.style.height = "80%", E2), i2(11, E2.style.width = o3 - r3 + "px", E2), i2(11, E2.style.left = r3 + "px", E2), i2(11, E2.style.top = "0", E2));
-        }
-    }
-    async function z2(t4, e3) {
-        if (!S2)
-            return;
-        const i3 = w2.indexOfTimestamps(t4),
-            s3 = w2.indexOfTimestamps(e3);
-        S2.setTimeScale(new Date(w2.timestamps[i3]), new Date(w2.timestamps[s3]));
-    }
-
-    function B2(t4) {
-        S2 || i2(30, S2 = new TwChart(b2, true)), S2.setTheme(x2);
-        const e3 = "all" === t4 ? w2.timestamps.length : 100,
-            s3 = w2.timestamps.length / (e3 / 100),
-            n3 = w2.createTradingviewSeries("strategy", 0, -1, s3),
-            r3 = w2.createTradingviewSeries("benchmark", 0, -1, s3);
-        S2.resetAreaSeries(0), S2.resetAreaSeries(1), S2.series[0].setData(n3), S2.series[1].setData(r3), S2.chart.subscribeCrosshairMove((t5) => {
-            const e4 = new Date(t5.time);
-            i2(9, C2 = e4.getMonth() + 1), i2(10, P2 = e4.getFullYear() || P2);
-        }), S2.chart.subscribeClick((t5) => {
-            const e4 = new Date(t5.time);
-            i2(4, R2 = e4.getMonth() + 1), i2(5, D2 = e4.getFullYear()), $2();
-        }), S2.chart.timeScale().subscribeVisibleTimeRangeChange((t5) => {
-            $2();
-        }), "all" === t4 && S2.setTimeScale(new Date(w2.timestamps[0]), new Date(w2.timestamps[w2.timestamps.length - 1]));
-    }
-    let U2 = null,
-        j2 = null;
-
-    function H2(t4) {
-        if (!t4 || 0 == t4)
-            return "rgba(0,0,0,0)";
-        const e3 = "dark" === x2 ? 20 : 255;
-        let i3 = t4 > 0 ? t4 / c2 : t4 / u2;
-        i3 = Math.min(0.6, i3);
-        const [s3, n3, r3] = t4 > 0 ? [255, 56, 156] : [99, 102, 241], [o3, a3, l3] = [s3 * i3 + e3 * (1 - i3), n3 * i3 + e3 * (1 - i3), r3 * i3 + e3 * (1 - i3)];
-        return `rgb(${o3},${a3},${l3})`;
-    }
-
-    function q2(t4) {
-        if (!t4 || 0 == t4)
-            return "rgba(0,0,0,0)";
-        const e3 = "dark" === x2 ? 20 : 255;
-        let i3 = t4 > 0 ? t4 / y2 : t4 / g2;
-        i3 = Math.min(0.6, i3);
-        const [s3, n3, r3] = t4 > 0 ? [255, 56, 156] : [99, 102, 241], [o3, a3, l3] = [s3 * i3 + e3 * (1 - i3), n3 * i3 + e3 * (1 - i3), r3 * i3 + e3 * (1 - i3)];
-        return `rgb(${o3},${a3},${l3})`;
-    }
-    let G2, Y2, it2 = null,
-        st2 = null,
-        rt2 = null,
-        ht2 = null,
-        ct2 = null;
-
-    function ut2() {
-        if (!_2)
-            return;
-        if (!p2)
-            return;
-        if (!v2)
-            return;
-        ht2 && ht2.destroy(), ct2 && ct2.destroy();
-        const t4 = function(t5, e4) {
-            const i3 = Object.keys(t5),
-                s3 = {},
-                n4 = i3.reduce((i4, n5) => {
-                    const r4 = t5[n5] - e4[n5];
-                    return s3[n5] = r4, i4 + r4;
-                }, 0) / i3.length;
-            return {
-                result: s3,
-                mean: n4
-            };
-        }(p2, v2);
-        i2(14, it2 = t4.mean), i2(15, st2 = Object.values(t4.result).filter((t5) => t5 > 0).length), i2(16, rt2 = Object.values(t4.result).length - st2);
-        const e3 = Object.keys(p2),
-            n3 = G2.getContext("2d");
-        ht2 = new Chart(n3, {
-            type: "bar",
-            data: {
-                labels: e3,
-                datasets: [{
-                    label: s2("profitability.yearlyReturn"),
-                    data: Object.values(p2),
-                    backgroundColor: "light" === x2 ? "#725bf5" : "#7a64f5",
-                    borderWidth: 0
-                }, {
-                    label: s2("profitability.benchmarkYearlyReturn"),
-                    data: Object.values(v2),
-                    backgroundColor: "#777777AA",
-                    borderWidth: 0
-                }]
-            },
-            options: {
-                responsive: true,
-                maintainAspectRatio: true,
-                scales: {
-                    y: {
-                        beginAtZero: true,
-                        ticks: {
-                            callback: (t5, e4, i3) => (100 * t5).toFixed() + "%",
-                            color: "light" === x2 ? "#000000aa" : "#FFFFFFaa"
-                        },
-                        grid: {
-                            color: "#77777755",
-                            tickBorderDash: [2, 2]
-                        }
-                    },
-                    x: {
-                        ticks: {
-                            color: "light" === x2 ? "#000000aa" : "#FFFFFFaa"
-                        },
-                        grid: {
-                            color: "#77777755",
-                            tickBorderDash: [2, 2]
-                        }
-                    }
-                }
-            }
-        });
-        const r3 = Y2.getContext("2d");
-        ct2 = new Chart(r3, {
-            type: "bar",
-            data: {
-                labels: e3,
-                datasets: [{
-                    label: s2("profitability.exceedReturn"),
-                    data: Object.values(t4.result),
-                    backgroundColor: "light" === x2 ? "#725bf5" : "#7a64f5",
-                    borderColor: "#725bf5",
-                    borderWidth: 1,
-                    barPercentage: 0.5
-                }]
-            },
-            options: {
-                responsive: true,
-                maintainAspectRatio: true,
-                scales: {
-                    y: {
-                        beginAtZero: true,
-                        ticks: {
-                            callback: (t5, e4, i3) => (100 * t5).toFixed() + "%",
-                            color: "light" === x2 ? "#000000aa" : "#FFFFFFaa"
-                        },
-                        grid: {
-                            color: "#77777755",
-                            tickBorderDash: [2, 2]
-                        }
-                    },
-                    x: {
-                        ticks: {
-                            color: "light" === x2 ? "#000000aa" : "#FFFFFFaa"
-                        },
-                        grid: {
-                            color: "#77777755",
-                            tickBorderDash: [2, 2]
-                        }
-                    }
-                }
-            }
-        });
-    }
-    return t3.$$set = (t4) => {
-        "browser" in t4 && i2(0, _2 = t4.browser), "report" in t4 && i2(1, w2 = t4.report), "theme" in t4 && i2(2, x2 = t4.theme), "showAll" in t4 && i2(29, k2 = t4.showAll), "lang" in t4 && i2(3, T2 = t4.lang);
-    }, t3.$$.update = () => {
-        8 & t3.$$.dirty[0] && i2(19, s2 = (t4) => "en" === T2 ? sl(t4) : nl(t4)), 4 & t3.$$.dirty[0] && x2 && ut2(), 2 & t3.$$.dirty[0] && i2(25, n2 = new Date(w2.timestamps[0]).getFullYear()), 2 & t3.$$.dirty[0] && i2(24, r2 = new Date(w2.timestamps[w2.timestamps.length - 1]).getFullYear()), 48 & t3.$$.dirty[0] && i2(23, o2 = D2 ? new Date(new Date(D2, (R2 || 1) - 1)) : null), 48 & t3.$$.dirty[0] && i2(22, a2 = D2 ? new Date(new Date(D2, R2 || 12) - 864e5) : null), 1073741828 & t3.$$.dirty[0] && S2 && S2.setTheme(x2), 2 & t3.$$.dirty[0] && i2(7, l2 = w2.calculateMonthlyReturn("strategy")), 128 & t3.$$.dirty[0] && i2(32, h2 = Object.values(l2).filter((t4) => t4 == t4)), 2 & t3.$$.dirty[1] && (c2 = Math.max(...h2)), 2 & t3.$$.dirty[1] && (u2 = Math.min(...h2)), 2 & t3.$$.dirty[1] && i2(21, d2 = Gu(h2) / h2.length), 2 & t3.$$.dirty[1] && i2(20, f2 = h2.filter((t4) => t4 > 0).length / h2.length * 100), 2 & t3.$$.dirty[0] && i2(6, p2 = w2.calculateAnnualReturn("strategy")), 64 & t3.$$.dirty[0] && i2(31, m2 = Object.values(p2).filter((t4) => t4 == t4)), 1 & t3.$$.dirty[1] && (g2 = Math.min(...m2)), 1 & t3.$$.dirty[1] && (y2 = Math.max(...m2)), 2 & t3.$$.dirty[0] && (v2 = w2.calculateAnnualReturn("benchmark")), 132 & t3.$$.dirty[0] && (l2 || x2) && i2(12, U2 = Object.fromEntries(Object.keys(l2).map((t4) => [t4, H2(l2[t4])]))), 68 & t3.$$.dirty[0] && (p2 || x2) && i2(13, j2 = Object.fromEntries(Object.keys(p2).map((t4) => [t4, q2(p2[t4])])));
-    }, [_2, w2, x2, T2, R2, D2, p2, l2, b2, C2, P2, E2, U2, j2, it2, st2, rt2, G2, Y2, s2, f2, d2, a2, o2, r2, n2, $2, z2, B2, k2, S2, m2, h2, function(t4) {
-        xt[t4 ? "unshift" : "push"](() => {
-            b2 = t4, i2(8, b2);
-        });
-    }, function(t4) {
-        xt[t4 ? "unshift" : "push"](() => {
-            E2 = t4, i2(11, E2);
-        });
-    }, (t4) => {
-        B2("year"), z2(t4 - 1 + "-12-31", `${t4}-12-31`), i2(10, P2 = t4);
-    }, () => {
-        B2("all"), z2(0, -1), i2(10, P2 = null);
-    }, (t4, e3) => {
-        B2("year"), z2(t4 - 1 + "-12-31", `${t4}-12-31`), i2(10, P2 = t4), i2(5, D2 = t4), i2(4, R2 = e3), $2();
-    }, function(t4) {
-        xt[t4 ? "unshift" : "push"](() => {
-            G2 = t4, i2(17, G2);
-        });
-    }, function(t4) {
-        xt[t4 ? "unshift" : "push"](() => {
-            Y2 = t4, i2(18, Y2);
-        });
-    }];
-}
-we(Du, {
-    prefix: {},
-    name: {},
-    color: {},
-    strokeColor: {},
-    className: {}
-}, [], [], true);
-class Profitability extends SvelteComponent {
-    constructor(t3) {
-        super(), ve(this, t3, Yu, qu, o, {
-            browser: 0,
-            report: 1,
-            theme: 2,
-            showAll: 29,
-            lang: 3
-        }, Fu, [-1, -1]);
-    }
-    get browser() {
-        return this.$$.ctx[0];
-    }
-    set browser(t3) {
-        this.$$set({
-            browser: t3
-        }), te();
-    }
-    get report() {
-        return this.$$.ctx[1];
-    }
-    set report(t3) {
-        this.$$set({
-            report: t3
-        }), te();
-    }
-    get theme() {
-        return this.$$.ctx[2];
-    }
-    set theme(t3) {
-        this.$$set({
-            theme: t3
-        }), te();
-    }
-    get showAll() {
-        return this.$$.ctx[29];
-    }
-    set showAll(t3) {
-        this.$$set({
-            showAll: t3
-        }), te();
-    }
-    get lang() {
-        return this.$$.ctx[3];
-    }
-    set lang(t3) {
-        this.$$set({
-            lang: t3
-        }), te();
-    }
-}
-
-function Qu(e2) {
-    let i2, s2, n2, r2, o2, a2, l2, h2, c2, u2, d2, f2, p2, m2, g2, y2, v2, b2, w2, x2, k2, T2, C2, R2, z2, B2, j2, q2, Y2, it2, st2, rt2, ht2, ct2, ut2, dt2, ft2, pt2, yt2, bt2, _t2, xt2, kt2, St2, It2, Mt2, At2, Lt2, Ot2, Ht2, Qt2, Jt2, te2, ee2, ie2, se2, ne2, re2, oe2, ae2, le2, he2, ce2, ue2, de2, fe2, pe2, me2, ge2, ye2, ve2, be2, _e2, we2, xe2, ke2, Te2, Se2, Ee2, Ce2, Ie2, Me2, Pe2, Re2, Ae2, De2, Le2, Oe2, Fe2, Ne2, $e2, Ve2 = e2[6]("metrics.ratio.sharpeRatio") + "",
-        ze2 = e2[6]("metrics.ratio.timeBetterThanBenchmark") + "",
-        Be2 = (100 * e2[7]).toFixed(2) + "",
-        Ue2 = e2[6]("metrics.ratio.yearlySharpeRatio") + "",
-        je2 = e2[6]("metrics.ratio.timeBetterThanBenchmark") + "",
-        He2 = e2[10].length + "",
-        We2 = e2[6]("metrics.ratio.year") + "",
-        qe2 = e2[6]("strategy") + "",
-        Ke2 = e2[6]("benchmark") + "",
-        Ge2 = e2[6]("metrics.ratio.worseThanBenchmark") + "",
-        Ye2 = e2[6]("metrics.ratio.rollingTailRatio") + "",
-        Qe2 = e2[6]("metrics.ratio.timeBetterThanBenchmark") + "",
-        Xe2 = (100 * e2[9]).toFixed(2) + "",
-        Je2 = e2[6]("metrics.ratio.yearlyTailRatio") + "",
-        Ze2 = e2[6]("metrics.ratio.timeBetterThanBenchmark") + "",
-        ti2 = e2[10].length + "",
-        ei2 = e2[6]("metrics.ratio.year") + "",
-        si2 = e2[6]("strategy") + "",
-        ni2 = e2[6]("benchmark") + "",
-        ri2 = e2[6]("metrics.ratio.worseThanBenchmark") + "",
-        ai2 = e2[6]("metrics.ratio.volatility") + "",
-        li2 = e2[6]("metrics.ratio.timeBetterThanBenchmark") + "",
-        hi2 = (100 * e2[8]).toFixed(2) + "";
-    return {
-        c() {
-            i2 = P("div"), s2 = P("div"), n2 = P("h3"), r2 = D(Ve2), o2 = $(), a2 = P("span"), l2 = D(ze2), h2 = $(), c2 = D(Be2), u2 = D("％"), d2 = $(), f2 = P("div"), p2 = $(), m2 = P("div"), g2 = P("h3"), y2 = D(Ue2), v2 = $(), b2 = P("span"), w2 = D(je2), x2 = $(), k2 = D(e2[11]), T2 = D(" / "), C2 = D(He2), R2 = $(), z2 = D(We2), B2 = $(), j2 = P("div"), q2 = P("div"), Y2 = P("div"), it2 = D(qe2), st2 = $(), rt2 = P("div"), ht2 = D(Ke2), ct2 = $(), ut2 = P("div"), dt2 = D(Ge2), ft2 = $(), pt2 = P("canvas"), yt2 = $(), bt2 = P("div"), _t2 = P("div"), xt2 = $(), kt2 = P("div"), St2 = P("h3"), It2 = D(Ye2), Mt2 = $(), At2 = P("span"), Lt2 = D(Qe2), Ot2 = $(), Ht2 = D(Xe2), Qt2 = D("％"), Jt2 = $(), te2 = P("div"), ee2 = $(), ie2 = P("div"), se2 = P("h3"), ne2 = D(Je2), re2 = $(), oe2 = P("span"), ae2 = D(Ze2), le2 = $(), he2 = D(e2[12]), ce2 = D(" / "), ue2 = D(ti2), de2 = $(), fe2 = D(ei2), pe2 = $(), me2 = P("div"), ge2 = P("div"), ye2 = P("div"), ve2 = D(si2), be2 = $(), _e2 = P("div"), we2 = D(ni2), xe2 = $(), ke2 = P("div"), Te2 = D(ri2), Se2 = $(), Ee2 = P("canvas"), Ce2 = $(), Ie2 = P("div"), Me2 = P("h3"), Pe2 = D(ai2), Re2 = $(), Ae2 = P("span"), De2 = D(li2), Le2 = $(), Oe2 = D(hi2), Fe2 = D("％"), Ne2 = $(), $e2 = P("div"), U(n2, "class", "text-2xl font-bold mb-1 text-base-content-200"), U(f2, "class", "h-48 mt-6"), U(s2, "class", "col-span-6 md:col-span-3 p-2 md:p-8 pt-8 md:border rounded-xl"), U(g2, "class", "text-2xl font-bold mb-1 text-base-content-200"), U(Y2, "class", "badge rounded bg-primary text-white"), U(rt2, "class", "badge rounded bg-gray-500 text-white"), U(ut2, "class", "badge rounded bg-[rgba(241,99,102,1)] text-white"), U(q2, "class", "text-sm mt-2 flex gap-2"), U(pt2, "class", "h-48 mt-4"), G(pt2, "width", "580px"), U(j2, "class", "w-full overflow-x-auto relative"), U(m2, "class", "col-span-6 md:col-span-3 p-2 md:p-8 pt-8 md:border rounded-xl"), U(_t2, "class", "h-48 hidden"), U(bt2, "class", "col-span-6 md:col-span-3 pt-8 md:p-8 hidden"), U(St2, "class", "text-2xl font-bold mb-1 text-base-content-200"), U(te2, "class", "h-48 mt-6"), U(kt2, "class", "col-span-6 md:col-span-3 p-2 md:p-8 pt-8 md:border rounded-xl"), U(se2, "class", "text-2xl font-bold mb-1 text-base-content-200"), U(ye2, "class", "badge rounded badge-primary text-white"), U(_e2, "class", "badge rounded bg-gray-500 text-white"), U(ke2, "class", "badge rounded bg-[rgba(241,99,102,1)] text-white"), U(ge2, "class", "text-sm mt-2 flex gap-2"), U(Ee2, "class", "h-48 mt-4"), G(Ee2, "width", "580px"), U(me2, "class", "w-full overflow-x-auto relative"), U(ie2, "class", "col-span-6 md:col-span-3 p-2 md:p-8 pt-8 md:border rounded-xl"), U(Me2, "class", "text-2xl font-bold mb-1 text-base-content-200"), U($e2, "class", "h-48 mt-6"), U(Ie2, "class", "col-span-6 p-2 md:p-8 pt-8 md:border rounded-xl"), U(i2, "class", "grid grid-cols-6 gap-4 text-base-content-200");
-        },
-        m(t3, E2) {
-            S(t3, i2, E2), _(i2, s2), _(s2, n2), _(n2, r2), _(s2, o2), _(s2, a2), _(a2, l2), _(a2, h2), _(a2, c2), _(a2, u2), _(s2, d2), _(s2, f2), e2[17](f2), _(i2, p2), _(i2, m2), _(m2, g2), _(g2, y2), _(m2, v2), _(m2, b2), _(b2, w2), _(b2, x2), _(b2, k2), _(b2, T2), _(b2, C2), _(b2, R2), _(b2, z2), _(m2, B2), _(m2, j2), _(j2, q2), _(q2, Y2), _(Y2, it2), _(q2, st2), _(q2, rt2), _(rt2, ht2), _(q2, ct2), _(q2, ut2), _(ut2, dt2), _(j2, ft2), _(j2, pt2), e2[18](pt2), _(i2, yt2), _(i2, bt2), _(bt2, _t2), e2[19](_t2), _(i2, xt2), _(i2, kt2), _(kt2, St2), _(St2, It2), _(kt2, Mt2), _(kt2, At2), _(At2, Lt2), _(At2, Ot2), _(At2, Ht2), _(At2, Qt2), _(kt2, Jt2), _(kt2, te2), e2[20](te2), _(i2, ee2), _(i2, ie2), _(ie2, se2), _(se2, ne2), _(ie2, re2), _(ie2, oe2), _(oe2, ae2), _(oe2, le2), _(oe2, he2), _(oe2, ce2), _(oe2, ue2), _(oe2, de2), _(oe2, fe2), _(ie2, pe2), _(ie2, me2), _(me2, ge2), _(ge2, ye2), _(ye2, ve2), _(ge2, be2), _(ge2, _e2), _(_e2, we2), _(ge2, xe2), _(ge2, ke2), _(ke2, Te2), _(me2, Se2), _(me2, Ee2), e2[21](Ee2), _(i2, Ce2), _(i2, Ie2), _(Ie2, Me2), _(Me2, Pe2), _(Ie2, Re2), _(Ie2, Ae2), _(Ae2, De2), _(Ae2, Le2), _(Ae2, Oe2), _(Ae2, Fe2), _(Ie2, Ne2), _(Ie2, $e2), e2[22]($e2);
-        },
-        p(t3, e3) {
-            64 & e3[0] && Ve2 !== (Ve2 = t3[6]("metrics.ratio.sharpeRatio") + "") && H(r2, Ve2), 64 & e3[0] && ze2 !== (ze2 = t3[6]("metrics.ratio.timeBetterThanBenchmark") + "") && H(l2, ze2), 64 & e3[0] && Ue2 !== (Ue2 = t3[6]("metrics.ratio.yearlySharpeRatio") + "") && H(y2, Ue2), 64 & e3[0] && je2 !== (je2 = t3[6]("metrics.ratio.timeBetterThanBenchmark") + "") && H(w2, je2), 64 & e3[0] && We2 !== (We2 = t3[6]("metrics.ratio.year") + "") && H(z2, We2), 64 & e3[0] && qe2 !== (qe2 = t3[6]("strategy") + "") && H(it2, qe2), 64 & e3[0] && Ke2 !== (Ke2 = t3[6]("benchmark") + "") && H(ht2, Ke2), 64 & e3[0] && Ge2 !== (Ge2 = t3[6]("metrics.ratio.worseThanBenchmark") + "") && H(dt2, Ge2), 64 & e3[0] && Ye2 !== (Ye2 = t3[6]("metrics.ratio.rollingTailRatio") + "") && H(It2, Ye2), 64 & e3[0] && Qe2 !== (Qe2 = t3[6]("metrics.ratio.timeBetterThanBenchmark") + "") && H(Lt2, Qe2), 64 & e3[0] && Je2 !== (Je2 = t3[6]("metrics.ratio.yearlyTailRatio") + "") && H(ne2, Je2), 64 & e3[0] && Ze2 !== (Ze2 = t3[6]("metrics.ratio.timeBetterThanBenchmark") + "") && H(ae2, Ze2), 64 & e3[0] && ei2 !== (ei2 = t3[6]("metrics.ratio.year") + "") && H(fe2, ei2), 64 & e3[0] && si2 !== (si2 = t3[6]("strategy") + "") && H(ve2, si2), 64 & e3[0] && ni2 !== (ni2 = t3[6]("benchmark") + "") && H(we2, ni2), 64 & e3[0] && ri2 !== (ri2 = t3[6]("metrics.ratio.worseThanBenchmark") + "") && H(Te2, ri2), 64 & e3[0] && ai2 !== (ai2 = t3[6]("metrics.ratio.volatility") + "") && H(Pe2, ai2), 64 & e3[0] && li2 !== (li2 = t3[6]("metrics.ratio.timeBetterThanBenchmark") + "") && H(De2, li2);
-        },
-        i: t,
-        o: t,
-        d(t3) {
-            t3 && E(i2), e2[17](null), e2[18](null), e2[19](null), e2[20](null), e2[21](null), e2[22](null);
-        }
-    };
-}
-
-function Xu(t3, e2) {
-    let i2 = 0;
-    for (let s2 = 0; s2 < t3.length; s2++)
-        t3[s2] > e2[s2] && i2++;
-    return i2 / t3.length;
-}
-
-function Ju(t3, e2, i2) {
-    let s2;
-    Chart.register(LinearScale, BarController, CategoryScale, BarElement, Ga);
-    let {
-        browser: n2
-    } = e2, {
-        report: r2
-    } = e2, {
-        theme: o2
-    } = e2, {
-        lang: a2 = "en"
-    } = e2;
-    const l2 = r2.calculateSharpe("strategy", 0, 250),
-        h2 = r2.calculateSharpe("benchmark", 0, 250),
-        c2 = Xu(l2.map((t4) => t4.value), h2.map((t4) => t4.value));
-    let u2, d2, f2 = null,
-        p2 = null;
-    const m2 = r2.calculateSortino("strategy", 0, 250),
-        g2 = r2.calculateSortino("benchmark", 0, 250);
-    let y2, v2 = null;
-    const b2 = r2.calculateVolitility("strategy", 0, 10).slice(-m2.length),
-        _2 = r2.calculateVolitility("benchmark", 0, 10).slice(-m2.length),
-        w2 = Xu(b2.map((t4) => t4.value), _2.map((t4) => t4.value));
-    let x2, k2 = null;
-    const T2 = r2.calculateTailRatio("strategy", 250),
-        S2 = r2.calculateTailRatio("benchmark", 250),
-        E2 = Xu(T2.map((t4) => t4.value), S2.map((t4) => t4.value));
-    let C2, P2, R2 = null,
-        D2 = null;
-    const $2 = parseInt(l2[0].time.slice(0, 4)),
-        z2 = parseInt(l2[l2.length - 1].time.slice(0, 4)),
-        B2 = Array.from(Array(z2 + 1).keys()).slice($2),
-        U2 = B2.map((t4) => Math.max(Math.min(r2.indexOfTimestamps(t4 + "-12-31") - 249, l2.length - 1), 0));
-
-    function j2(t4, e3) {
-        return U2.map((i3) => {
-            const s3 = t4[i3].value,
-                n3 = e3[i3].value;
-            return s3 > n3 ? 1 : s3 < n3 ? 0 : 0.5;
-        }).reduce((t5, e4) => t5 + e4, 0);
-    }
-    const H2 = j2(l2, h2),
-        q2 = j2(T2, S2);
-
-    function G2(t4, e3) {
-        return t4.map((t5, i3) => t5 < e3[i3] ? "rgba(241, 99, 102, 1)" : "light" === o2 ? "#725bf5" : "#7a64f5");
-    }
-
-    function Y2() {
-        if (void 0 !== d2) {
-            p2 && p2.destroy();
-            var t4 = d2.getContext("2d");
-            p2 = new Chart(t4, {
-                type: "bar",
-                data: {
-                    labels: B2,
-                    datasets: [{
-                        label: s2("metrics.ratio.sharpeRatio"),
-                        data: U2.map((t5) => l2[t5].value),
-                        backgroundColor: G2(U2.map((t5) => l2[t5].value), U2.map((t5) => h2[t5].value)),
-                        borderWidth: 0,
-                        barPercentage: 0.5
-                    }, {
-                        label: s2("benchmark"),
-                        data: U2.map((t5) => h2[t5].value),
-                        backgroundColor: "#77777777",
-                        borderWidth: 0,
-                        barPercentage: 0.5
-                    }]
-                },
-                options: {
-                    responsive: true,
-                    maintainAspectRatio: true,
-                    scales: {
-                        y: {
-                            beginAtZero: true,
-                            ticks: {
-                                color: "light" === o2 ? "#000000aa" : "#FFFFFFaa"
-                            },
-                            grid: {
-                                color: "#77777755",
-                                tickBorderDash: [2, 2]
-                            }
-                        },
-                        x: {
-                            ticks: {
-                                color: "light" === o2 ? "#000000aa" : "#FFFFFFaa"
-                            },
-                            grid: {
-                                color: "#77777755",
-                                tickBorderDash: [2, 2]
-                            }
-                        }
-                    }
-                }
-            }), D2 && D2.destroy();
-            var e3 = P2.getContext("2d");
-            D2 = new Chart(e3, {
-                type: "bar",
-                data: {
-                    labels: B2,
-                    datasets: [{
-                        label: s2("metrics.ratio.tailRatio"),
-                        data: U2.map((t5) => T2[t5].value),
-                        backgroundColor: G2(U2.map((t5) => T2[t5].value), U2.map((t5) => S2[t5].value)),
-                        borderWidth: 0,
-                        barPercentage: 0.5
-                    }, {
-                        label: s2("benchmark"),
-                        data: U2.map((t5) => S2[t5].value),
-                        backgroundColor: "#77777777",
-                        borderWidth: 0,
-                        barPercentage: 0.5
-                    }]
-                },
-                options: {
-                    responsive: true,
-                    maintainAspectRatio: true,
-                    scales: {
-                        y: {
-                            beginAtZero: true,
-                            ticks: {
-                                color: "light" === o2 ? "#000000aa" : "#FFFFFFaa"
-                            },
-                            grid: {
-                                color: "#77777755",
-                                tickBorderDash: [2, 2]
-                            }
-                        },
-                        x: {
-                            ticks: {
-                                color: "light" === o2 ? "#000000aa" : "#FFFFFFaa"
-                            },
-                            grid: {
-                                color: "#77777755",
-                                tickBorderDash: [2, 2]
-                            }
-                        }
-                    }
-                }
-            });
-        }
-    }
-    return pt(() => {
-        if (!n2)
-            return;
-        f2 = new TwChart(u2, false), f2.setTheme(o2), f2.resetAreaSeries(0), f2.resetAreaSeries(1);
-        let t4 = l2[0].time,
-            e3 = l2[l2.length - 1].time;
-        f2.series[0].setData(l2), f2.series[1].setData(h2), f2.setTimeScale(new Date(t4), new Date(e3)), v2 = new TwChart(y2, false), v2.setTheme(o2), v2.resetAreaSeries(0), v2.resetAreaSeries(1), t4 = m2[0].time, e3 = m2[l2.length - 1].time, v2.series[0].setData(m2), v2.series[1].setData(g2), v2.setTimeScale(new Date(t4), new Date(e3)), k2 = new TwChart(x2, false), k2.setTheme(o2), k2.resetAreaSeries(0), k2.resetAreaSeries(1), t4 = b2[0].time, e3 = b2[l2.length - 1].time, k2.series[0].setData(b2), k2.series[1].setData(_2), k2.setTimeScale(new Date(t4), new Date(e3)), R2 = new TwChart(C2, false), R2.setTheme(o2), R2.resetAreaSeries(0), R2.resetAreaSeries(1), t4 = T2[0].time, e3 = T2[l2.length - 1].time, R2.series[0].setData(T2), R2.series[1].setData(S2), R2.setTimeScale(new Date(t4), new Date(e3));
-        const i3 = [f2, v2, k2, R2];
-        for (let t5 in i3) {
-            const e4 = i3[t5].chart;
-            e4.timeScale().subscribeVisibleTimeRangeChange((s3) => {
-                const n3 = e4.timeScale().getVisibleLogicalRange();
-                for (let e5 in i3)
-                    e5 !== t5 && i3[e5].chart.timeScale().setVisibleLogicalRange(n3);
-            });
-        }
-        Y2();
-    }), yt(() => {
-        p2 && p2.destroy(), D2 && D2.destroy();
-    }), t3.$$set = (t4) => {
-        "browser" in t4 && i2(13, n2 = t4.browser), "report" in t4 && i2(14, r2 = t4.report), "theme" in t4 && i2(15, o2 = t4.theme), "lang" in t4 && i2(16, a2 = t4.lang);
-    }, t3.$$.update = () => {
-        65536 & t3.$$.dirty[0] && i2(6, s2 = (t4) => "en" === a2 ? sl(t4) : nl(t4)), 32768 & t3.$$.dirty[0] && o2 && Y2();
-    }, [u2, d2, y2, x2, C2, P2, s2, c2, w2, E2, U2, H2, q2, n2, r2, o2, a2, function(t4) {
-        xt[t4 ? "unshift" : "push"](() => {
-            u2 = t4, i2(0, u2);
-        });
-    }, function(t4) {
-        xt[t4 ? "unshift" : "push"](() => {
-            d2 = t4, i2(1, d2);
-        });
-    }, function(t4) {
-        xt[t4 ? "unshift" : "push"](() => {
-            y2 = t4, i2(2, y2);
-        });
-    }, function(t4) {
-        xt[t4 ? "unshift" : "push"](() => {
-            C2 = t4, i2(4, C2);
-        });
-    }, function(t4) {
-        xt[t4 ? "unshift" : "push"](() => {
-            P2 = t4, i2(5, P2);
-        });
-    }, function(t4) {
-        xt[t4 ? "unshift" : "push"](() => {
-            x2 = t4, i2(3, x2);
-        });
-    }];
-}
-we(Profitability, {
-    browser: {},
-    report: {},
-    theme: {},
-    showAll: {
-        type: "Boolean"
-    },
-    lang: {}
-}, [], [], true);
-class Ratio extends SvelteComponent {
-    constructor(t3) {
-        super(), ve(this, t3, Ju, Qu, o, {
-            browser: 13,
-            report: 14,
-            theme: 15,
-            lang: 16
-        }, null, [-1, -1]);
-    }
-    get browser() {
-        return this.$$.ctx[13];
-    }
-    set browser(t3) {
-        this.$$set({
-            browser: t3
-        }), te();
-    }
-    get report() {
-        return this.$$.ctx[14];
-    }
-    set report(t3) {
-        this.$$set({
-            report: t3
-        }), te();
-    }
-    get theme() {
-        return this.$$.ctx[15];
-    }
-    set theme(t3) {
-        this.$$set({
-            theme: t3
-        }), te();
-    }
-    get lang() {
-        return this.$$.ctx[16];
-    }
-    set lang(t3) {
-        this.$$set({
-            lang: t3
-        }), te();
-    }
-}
-
-function Zu(t3, e2, i2) {
-    const s2 = t3.slice();
-    return s2[35] = e2[i2], s2;
-}
-
-function td(t3, e2, i2) {
-    const s2 = t3.slice();
-    return s2[35] = e2[i2], s2;
-}
-
-function ed(t3, e2, i2) {
-    const s2 = t3.slice();
-    return s2[35] = e2[i2], s2;
-}
-
-function id(t3) {
-    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2, d2 = t3[2].timestamps[t3[35].start].slice(0, 4) + "",
-        f2 = (100 * t3[35].maxDrawdown).toFixed(1) + "";
-
-    function p2() {
-        return t3[22](t3[35]);
-    }
-    return {
-        c() {
-            e2 = P("div"), i2 = P("div"), s2 = D(d2), n2 = $(), r2 = P("div"), o2 = D(f2), a2 = D("%"), l2 = $(), U(i2, "class", "text-xs"), U(r2, "class", "font-bold"), U(e2, "class", h2 = "hover:badge-primary hover:text-white p-2 mt-1 mr-3 cursor-pointer rounded-md " + (t3[11] === t3[35] ? "outline outline-primary" : "bg-base-100"));
-        },
-        m(t4, h3) {
-            S(t4, e2, h3), _(e2, i2), _(i2, s2), _(e2, n2), _(e2, r2), _(r2, o2), _(r2, a2), _(e2, l2), c2 || (u2 = B(e2, "click", p2), c2 = true);
-        },
-        p(i3, n3) {
-            t3 = i3, 20 & n3[0] && d2 !== (d2 = t3[2].timestamps[t3[35].start].slice(0, 4) + "") && H(s2, d2), 16 & n3[0] && f2 !== (f2 = (100 * t3[35].maxDrawdown).toFixed(1) + "") && H(o2, f2), 2064 & n3[0] && h2 !== (h2 = "hover:badge-primary hover:text-white p-2 mt-1 mr-3 cursor-pointer rounded-md " + (t3[11] === t3[35] ? "outline outline-primary" : "bg-base-100")) && U(e2, "class", h2);
-        },
-        d(t4) {
-            t4 && E(e2), c2 = false, u2();
-        }
-    };
-}
-
-function sd(t3) {
-    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2, d2, f2, p2, m2, g2, y2, v2, b2, w2, x2, k2, T2, C2, R2, z2, j2, q2, G2 = t3[2].timestamps[t3[35].at].slice(0, 4) + "",
-        Y2 = t3[2].timestamps[t3[35].at].slice(5, 7) + "",
-        it2 = (100 * t3[35].maxDrawdown).toFixed(1) + "";
-
-    function st2() {
-        return t3[26](t3[35]);
-    }
-    return {
-        c() {
-            e2 = P("div"), i2 = P("div"), s2 = D(G2), n2 = $(), r2 = P("br"), o2 = $(), a2 = D(Y2), l2 = D(" 月"), h2 = $(), c2 = P("div"), u2 = P("div"), p2 = $(), m2 = P("div"), b2 = $(), w2 = P("div"), x2 = D(it2), k2 = P("br"), T2 = D("% "), C2 = P("br"), z2 = $(), U(i2, "class", "mt-2 border-b border-base-content/20 pb-4 px-2 text-center w-full"), U(u2, "style", d2 = `height:${(t3[35].maxDrawdown / t3[4][0].maxDrawdown * 160).toFixed(0)}px`), U(u2, "class", f2 = "w-3 rounded-b-full mx-1 " + ("strategy" === t3[10] ? "bg-primary" : "bg-gray-400")), U(m2, "style", g2 = `height:${(("strategy" === t3[10] ? t3[15] : t3[16])[t3[35].at].value / 100 / Math.max(t3[4][0].maxDrawdown, t3[13][0].maxDrawdown) * 160).toFixed(0)}px`), U(m2, "class", y2 = "w-3 rounded-b-full mx-1 " + ("strategy" === t3[10] ? "bg-gray-400" : "bg-primary")), U(c2, "class", v2 = "flex justify-center " + ("benchmark" === t3[10] ? "flex-row-reverse" : "")), U(w2, "class", R2 = `w-20 pt-2 text-center text-primary ${0 === t3[17] ? "text-2xl font-bold" : ""} ${"strategy" === t3[10] ? "text-primary" : "text-gray-400"}`), U(e2, "class", "flex flex-col justify-center items-center text-sm rounded-full pb-4 transition-all hover:cursor-pointer hover:text-base hover:-mt-4 hover:shadow-2xl hover:shadow-primary");
-        },
-        m(t4, d3) {
-            S(t4, e2, d3), _(e2, i2), _(i2, s2), _(i2, n2), _(i2, r2), _(i2, o2), _(i2, a2), _(i2, l2), _(e2, h2), _(e2, c2), _(c2, u2), _(c2, p2), _(c2, m2), _(e2, b2), _(e2, w2), _(w2, x2), _(w2, k2), _(w2, T2), _(w2, C2), _(e2, z2), j2 || (q2 = B(e2, "click", st2), j2 = true);
-        },
-        p(e3, i3) {
-            t3 = e3, 9236 & i3[0] && G2 !== (G2 = t3[2].timestamps[t3[35].at].slice(0, 4) + "") && H(s2, G2), 9236 & i3[0] && Y2 !== (Y2 = t3[2].timestamps[t3[35].at].slice(5, 7) + "") && H(a2, Y2), 9232 & i3[0] && d2 !== (d2 = `height:${(t3[35].maxDrawdown / t3[4][0].maxDrawdown * 160).toFixed(0)}px`) && U(u2, "style", d2), 1024 & i3[0] && f2 !== (f2 = "w-3 rounded-b-full mx-1 " + ("strategy" === t3[10] ? "bg-primary" : "bg-gray-400")) && U(u2, "class", f2), 107536 & i3[0] && g2 !== (g2 = `height:${(("strategy" === t3[10] ? t3[15] : t3[16])[t3[35].at].value / 100 / Math.max(t3[4][0].maxDrawdown, t3[13][0].maxDrawdown) * 160).toFixed(0)}px`) && U(m2, "style", g2), 1024 & i3[0] && y2 !== (y2 = "w-3 rounded-b-full mx-1 " + ("strategy" === t3[10] ? "bg-gray-400" : "bg-primary")) && U(m2, "class", y2), 1024 & i3[0] && v2 !== (v2 = "flex justify-center " + ("benchmark" === t3[10] ? "flex-row-reverse" : "")) && U(c2, "class", v2), 9232 & i3[0] && it2 !== (it2 = (100 * t3[35].maxDrawdown).toFixed(1) + "") && H(x2, it2), 132096 & i3[0] && R2 !== (R2 = `w-20 pt-2 text-center text-primary ${0 === t3[17] ? "text-2xl font-bold" : ""} ${"strategy" === t3[10] ? "text-primary" : "text-gray-400"}`) && U(w2, "class", R2);
-        },
-        d(t4) {
-            t4 && E(e2), j2 = false, q2();
-        }
-    };
-}
-
-function nd(t3) {
-    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2, d2, f2, p2, m2, g2, y2, v2, b2, w2, x2, k2, T2, C2, R2 = t3[2].timestamps[t3[35].at].slice(0, 4) + "",
-        z2 = t3[2].timestamps[t3[35].at].slice(5, 7) + "",
-        j2 = t3[20](t3[35]) + "",
-        q2 = t3[17]("metrics.risk.days") + "";
-
-    function G2() {
-        return t3[29](t3[35]);
-    }
-    return {
-        c() {
-            e2 = P("div"), i2 = P("div"), s2 = D(R2), n2 = $(), r2 = P("br"), o2 = $(), a2 = D(z2), l2 = D(" 月"), h2 = $(), c2 = P("div"), u2 = P("div"), p2 = $(), m2 = P("div"), g2 = D(j2), y2 = $(), v2 = P("br"), b2 = $(), w2 = D(q2), k2 = $(), U(i2, "class", "mt-2 border-b border-base-content/20 pb-4 px-2 text-center w-full"), U(u2, "style", d2 = `height:${(t3[20](t3[35]) / Math.min(t3[20](t3[14][0]), t3[20](t3[12][0])) * 160).toFixed(0)}px`), U(u2, "class", f2 = "w-3 rounded-b-full mx-1 " + ("strategy" === t3[10] ? "bg-primary" : "bg-gray-400")), U(m2, "class", x2 = `w-14 pt-2 text-center ${0 === t3[17] ? "text-2xl font-bold" : ""} ${"strategy" === t3[10] ? "text-primary" : "text-gray-400"}`), U(e2, "class", "flex flex-col justify-center items-center text-sm rounded-full pb-4 transition-all hover:cursor-pointer hover:text-base hover:-mt-4 hover:shadow-2xl hover:shadow-primary");
-        },
-        m(t4, d3) {
-            S(t4, e2, d3), _(e2, i2), _(i2, s2), _(i2, n2), _(i2, r2), _(i2, o2), _(i2, a2), _(i2, l2), _(e2, h2), _(e2, c2), _(c2, u2), _(e2, p2), _(e2, m2), _(m2, g2), _(m2, y2), _(m2, v2), _(m2, b2), _(m2, w2), _(e2, k2), T2 || (C2 = B(e2, "click", G2), T2 = true);
-        },
-        p(e3, i3) {
-            t3 = e3, 21508 & i3[0] && R2 !== (R2 = t3[2].timestamps[t3[35].at].slice(0, 4) + "") && H(s2, R2), 21508 & i3[0] && z2 !== (z2 = t3[2].timestamps[t3[35].at].slice(5, 7) + "") && H(a2, z2), 21504 & i3[0] && d2 !== (d2 = `height:${(t3[20](t3[35]) / Math.min(t3[20](t3[14][0]), t3[20](t3[12][0])) * 160).toFixed(0)}px`) && U(u2, "style", d2), 1024 & i3[0] && f2 !== (f2 = "w-3 rounded-b-full mx-1 " + ("strategy" === t3[10] ? "bg-primary" : "bg-gray-400")) && U(u2, "class", f2), 21504 & i3[0] && j2 !== (j2 = t3[20](t3[35]) + "") && H(g2, j2), 131072 & i3[0] && q2 !== (q2 = t3[17]("metrics.risk.days") + "") && H(w2, q2), 132096 & i3[0] && x2 !== (x2 = `w-14 pt-2 text-center ${0 === t3[17] ? "text-2xl font-bold" : ""} ${"strategy" === t3[10] ? "text-primary" : "text-gray-400"}`) && U(m2, "class", x2);
-        },
-        d(t4) {
-            t4 && E(e2), T2 = false, C2();
-        }
-    };
-}
-
-function rd(t3) {
-    var _a2, _b2;
-    let e2, i2, s2, r2, o2, a2, l2, h2, c2, u2, d2, f2, p2, m2, g2, y2, v2, b2, w2, x2, k2, T2, R2, z2, j2, q2, Y2, it2, st2, rt2, ht2, ct2, ut2, dt2, ft2, pt2, yt2, bt2, _t2, xt2, kt2, St2, It2, Mt2, At2, Lt2, Ot2, Ht2, Qt2, Jt2, te2, ee2, ie2, se2, ne2, re2, oe2, ae2, ce2, de2, fe2, pe2, ve2, be2, _e2, we2, xe2, ke2, Te2, Se2, Ee2, Ce2, Ie2, Me2, Pe2, Re2, Ae2, De2, Le2, Oe2, Fe2, Ne2, $e2 = t3[17]("risk.drawdowPeriods") + "",
-        Ve2 = t3[17]("profitability.stockList") + "",
-        ze2 = ((_a2 = t3[8]) == null ? void 0 : _a2.toLocaleDateString()) + "",
-        Be2 = ((_b2 = t3[9]) == null ? void 0 : _b2.toLocaleDateString()) + "",
-        Ue2 = t3[17]("metrics.risk.worstDrawdownPeriod") + "",
-        je2 = t3[17]("metrics.risk.worst10Strategy") + "",
-        He2 = t3[17]("metrics.risk.worst10Benchmark") + "",
-        We2 = t3[17]("benchmark") + "",
-        qe2 = t3[17]("strategy") + "",
-        Ke2 = t3[17]("metrics.risk.newHighTimeRank") + "",
-        Ge2 = t3[17]("metrics.risk.worst10Strategy") + "",
-        Ye2 = t3[17]("metrics.risk.worst10Benchmark") + "",
-        Qe2 = t3[17]("strategy") + "",
-        Xe2 = t3[17]("risk.drawdownPercentage") + "",
-        Je2 = ue(t3[4]),
-        Ze2 = [];
-    for (let e3 = 0; e3 < Je2.length; e3 += 1)
-        Ze2[e3] = id(ed(t3, Je2, e3));
-    rt2 = new Stocks({
-        props: {
-            lang: t3[0],
-            report: t3[2],
-            theme: t3[3],
-            browser: t3[1],
-            tstart: t3[8],
-            tend: t3[9]
-        }
-    });
-    let ti2 = ue("strategy" === t3[10] ? t3[4] : t3[13]),
-        ei2 = [];
-    for (let e3 = 0; e3 < ti2.length; e3 += 1)
-        ei2[e3] = sd(td(t3, ti2, e3));
-    let si2 = ue("strategy" === t3[10] ? t3[14] : t3[12]),
-        ni2 = [];
-    for (let e3 = 0; e3 < si2.length; e3 += 1)
-        ni2[e3] = nd(Zu(t3, si2, e3));
-    return {
-        c() {
-            e2 = P("div"), i2 = P("div"), s2 = P("div"), r2 = P("h3"), o2 = D($e2), a2 = $(), l2 = P("div"), h2 = P("div");
-            for (let t4 = 0; t4 < Ze2.length; t4 += 1)
-                Ze2[t4].c();
-            c2 = $(), u2 = P("div"), d2 = P("div"), f2 = $(), p2 = P("div"), m2 = P("span"), g2 = D(t3[7]), y2 = $(), v2 = D("天"), b2 = $(), w2 = P("div"), x2 = P("h3"), k2 = D(Ve2), T2 = $(), R2 = P("h4"), z2 = D(ze2), j2 = D("~"), q2 = D(Be2), Y2 = $(), it2 = P("div"), st2 = P("div"), me(rt2.$$.fragment), ht2 = $(), ct2 = P("div"), ut2 = P("h3"), dt2 = D(Ue2), ft2 = $(), pt2 = P("div"), yt2 = P("button"), bt2 = D(je2), xt2 = $(), kt2 = P("button"), St2 = D(He2), Mt2 = $(), At2 = P("div"), Lt2 = P("div");
-            for (let t4 = 0; t4 < ei2.length; t4 += 1)
-                ei2[t4].c();
-            Ot2 = $(), Ht2 = P("div"), Qt2 = P("div"), Jt2 = D(We2), te2 = $(), ee2 = P("div"), ie2 = D(qe2), se2 = $(), ne2 = P("div"), re2 = P("h3"), oe2 = D(Ke2), ae2 = $(), ce2 = P("div"), de2 = P("span"), fe2 = D(Ge2), ve2 = $(), be2 = P("span"), _e2 = D(Ye2), xe2 = $(), ke2 = P("div"), Te2 = P("div");
-            for (let t4 = 0; t4 < ni2.length; t4 += 1)
-                ni2[t4].c();
-            Se2 = $(), Ee2 = P("div"), Ce2 = P("div"), Ie2 = D(Qe2), Me2 = $(), Pe2 = P("div"), Re2 = P("h3"), Ae2 = D(Xe2), De2 = $(), Le2 = P("div"), U(r2, "class", "text-2xl font-bold text-base-content-200"), U(h2, "class", "flex mt-2 overflow-x-auto max-w-full pb-4 pl-1 no-scrollbar"), U(l2, "class", "flex"), U(d2, "class", "text-primary h-64 z-0"), U(m2, "class", "text-2xl font-bold text-primary"), U(p2, "class", "absolute bottom-8 left-2"), U(u2, "class", "relative overflow-hidden"), U(s2, "class", "h-full"), U(i2, "class", "col-span-6 md:p-8 pt-8 sm:rounded-xl md:border"), U(x2, "class", "text-base-content-200 text-2xl font-bold md:text-center"), U(R2, "class", "mt-2 text-base-content-100 md:text-center"), U(st2, "class", `overflow-auto max-h-72 text-base-content
-				${Lu() ? "no-scrollbar" : "show-scrollbar"}
-				`), U(it2, "class", "relative"), U(w2, "class", "col-span-6 md:col-span-6 md:p-8 pt-8 md:border sm:rounded-xl"), U(ut2, "class", "text-2xl font-bold text-base-content-200 text-center"), U(yt2, "class", _t2 = "border border-base-content/10 text-sm bg-base-100 hover:badge-primary hover:text-white px-2 py-1 rounded-xl " + ("strategy" === t3[10] ? "outline outline-primary" : "")), U(kt2, "class", It2 = "border border-base-content/10 text-sm bg-base-100 hover:badge-primary hover:text-white px-2 py-1 rounded-xl " + ("benchmark" === t3[10] ? "outline outline-primary" : "")), U(pt2, "class", "flex mt-4 justify-center gap-2"), U(Lt2, "class", "grid grid-cols-5 justify-start items-start mt-4"), U(Qt2, "class", "badge rounded bg-gray-500 text-white"), U(ee2, "class", "badge rounded bg-primary text-white"), U(Ht2, "class", "absolute inset-x-0 bottom-0 flex justify-center my-2 text-sm gap-2"), G(Ht2, "direction", "rtl"), U(ct2, "class", "relative col-span-6 md:col-span-3 md:p-8 pt-8 sm:rounded-xl md:border"), U(re2, "class", "text-2xl font-bold text-base-content-200 text-center"), U(de2, "class", pe2 = "border border-base-content/10 text-sm bg-base-100 hover:badge-primary hover:text-white px-2 py-1 cursor-pointer rounded-xl " + ("strategy" === t3[10] ? "outline outline-primary" : "")), U(be2, "class", we2 = "border border-base-content/10 text-sm bg-base-100 hover:badge-primary hover:text-white px-2 py-1 cursor-pointer rounded-xl " + ("benchmark" === t3[10] ? "outline outline-primary" : "")), U(ce2, "class", "flex mt-4 justify-center gap-2"), U(Te2, "class", "flex justify-between items-start mt-4 text-sm"), U(Ce2, "class", "badge rounded badge-primary text-white"), U(Ee2, "class", "absolute inset-x-0 bottom-0 flex justify-center my-2 text-sm"), G(Ee2, "direction", "rtl"), U(ne2, "class", "relative col-span-6 md:col-span-3 md:p-8 pt-8 sm:rounded-xl md:border"), U(Re2, "class", "text-2xl font-bold text-base-content-200"), U(Le2, "class", "text-primary h-48 z-0"), U(Pe2, "class", "col-span-6 md:p-8 pt-8 sm:rounded-xl md:border"), U(e2, "class", "grid grid-cols-6 gap-4 text-base-content-300");
-        },
-        m(n2, E2) {
-            S(n2, e2, E2), _(e2, i2), _(i2, s2), _(s2, r2), _(r2, o2), _(s2, a2), _(s2, l2), _(l2, h2);
-            for (let t4 = 0; t4 < Ze2.length; t4 += 1)
-                Ze2[t4] && Ze2[t4].m(h2, null);
-            _(s2, c2), _(s2, u2), _(u2, d2), t3[23](d2), _(u2, f2), _(u2, p2), _(p2, m2), _(m2, g2), _(m2, y2), _(p2, v2), _(e2, b2), _(e2, w2), _(w2, x2), _(x2, k2), _(w2, T2), _(w2, R2), _(R2, z2), _(R2, j2), _(R2, q2), _(w2, Y2), _(w2, it2), _(it2, st2), ge(rt2, st2, null), _(e2, ht2), _(e2, ct2), _(ct2, ut2), _(ut2, dt2), _(ct2, ft2), _(ct2, pt2), _(pt2, yt2), _(yt2, bt2), _(pt2, xt2), _(pt2, kt2), _(kt2, St2), _(ct2, Mt2), _(ct2, At2), _(At2, Lt2);
-            for (let t4 = 0; t4 < ei2.length; t4 += 1)
-                ei2[t4] && ei2[t4].m(Lt2, null);
-            _(ct2, Ot2), _(ct2, Ht2), _(Ht2, Qt2), _(Qt2, Jt2), _(Ht2, te2), _(Ht2, ee2), _(ee2, ie2), _(e2, se2), _(e2, ne2), _(ne2, re2), _(re2, oe2), _(ne2, ae2), _(ne2, ce2), _(ce2, de2), _(de2, fe2), _(ce2, ve2), _(ce2, be2), _(be2, _e2), _(ne2, xe2), _(ne2, ke2), _(ke2, Te2);
-            for (let t4 = 0; t4 < ni2.length; t4 += 1)
-                ni2[t4] && ni2[t4].m(Te2, null);
-            _(ne2, Se2), _(ne2, Ee2), _(Ee2, Ce2), _(Ce2, Ie2), _(e2, Me2), _(e2, Pe2), _(Pe2, Re2), _(Re2, Ae2), _(Pe2, De2), _(Pe2, Le2), t3[30](Le2), Oe2 = true, Fe2 || (Ne2 = [B(yt2, "click", t3[24]), B(kt2, "click", t3[25]), B(de2, "click", t3[27]), B(be2, "click", t3[28])], Fe2 = true);
-        },
-        p(t4, e3) {
-            var _a3, _b3;
-            if ((!Oe2 || 131072 & e3[0]) && $e2 !== ($e2 = t4[17]("risk.drawdowPeriods") + "") && H(o2, $e2), 788500 & e3[0]) {
-                let i4;
-                for (Je2 = ue(t4[4]), i4 = 0; i4 < Je2.length; i4 += 1) {
-                    const s3 = ed(t4, Je2, i4);
-                    Ze2[i4] ? Ze2[i4].p(s3, e3) : (Ze2[i4] = id(s3), Ze2[i4].c(), Ze2[i4].m(h2, null));
-                }
-                for (; i4 < Ze2.length; i4 += 1)
-                    Ze2[i4].d(1);
-                Ze2.length = Je2.length;
-            }
-            (!Oe2 || 128 & e3[0]) && H(g2, t4[7]), (!Oe2 || 131072 & e3[0]) && Ve2 !== (Ve2 = t4[17]("profitability.stockList") + "") && H(k2, Ve2), (!Oe2 || 256 & e3[0]) && ze2 !== (ze2 = ((_a3 = t4[8]) == null ? void 0 : _a3.toLocaleDateString()) + "") && H(z2, ze2), (!Oe2 || 512 & e3[0]) && Be2 !== (Be2 = ((_b3 = t4[9]) == null ? void 0 : _b3.toLocaleDateString()) + "") && H(q2, Be2);
-            const i3 = {};
-            if (1 & e3[0] && (i3.lang = t4[0]), 4 & e3[0] && (i3.report = t4[2]), 8 & e3[0] && (i3.theme = t4[3]), 2 & e3[0] && (i3.browser = t4[1]), 256 & e3[0] && (i3.tstart = t4[8]), 512 & e3[0] && (i3.tend = t4[9]), rt2.$set(i3), (!Oe2 || 131072 & e3[0]) && Ue2 !== (Ue2 = t4[17]("metrics.risk.worstDrawdownPeriod") + "") && H(dt2, Ue2), (!Oe2 || 131072 & e3[0]) && je2 !== (je2 = t4[17]("metrics.risk.worst10Strategy") + "") && H(bt2, je2), (!Oe2 || 1024 & e3[0] && _t2 !== (_t2 = "border border-base-content/10 text-sm bg-base-100 hover:badge-primary hover:text-white px-2 py-1 rounded-xl " + ("strategy" === t4[10] ? "outline outline-primary" : ""))) && U(yt2, "class", _t2), (!Oe2 || 131072 & e3[0]) && He2 !== (He2 = t4[17]("metrics.risk.worst10Benchmark") + "") && H(St2, He2), (!Oe2 || 1024 & e3[0] && It2 !== (It2 = "border border-base-content/10 text-sm bg-base-100 hover:badge-primary hover:text-white px-2 py-1 rounded-xl " + ("benchmark" === t4[10] ? "outline outline-primary" : ""))) && U(kt2, "class", It2), 1027092 & e3[0]) {
-                let i4;
-                for (ti2 = ue("strategy" === t4[10] ? t4[4] : t4[13]), i4 = 0; i4 < ti2.length; i4 += 1) {
-                    const s3 = td(t4, ti2, i4);
-                    ei2[i4] ? ei2[i4].p(s3, e3) : (ei2[i4] = sd(s3), ei2[i4].c(), ei2[i4].m(Lt2, null));
-                }
-                for (; i4 < ei2.length; i4 += 1)
-                    ei2[i4].d(1);
-                ei2.length = ti2.length;
-            }
-            if ((!Oe2 || 131072 & e3[0]) && We2 !== (We2 = t4[17]("benchmark") + "") && H(Jt2, We2), (!Oe2 || 131072 & e3[0]) && qe2 !== (qe2 = t4[17]("strategy") + "") && H(ie2, qe2), (!Oe2 || 131072 & e3[0]) && Ke2 !== (Ke2 = t4[17]("metrics.risk.newHighTimeRank") + "") && H(oe2, Ke2), (!Oe2 || 131072 & e3[0]) && Ge2 !== (Ge2 = t4[17]("metrics.risk.worst10Strategy") + "") && H(fe2, Ge2), (!Oe2 || 1024 & e3[0] && pe2 !== (pe2 = "border border-base-content/10 text-sm bg-base-100 hover:badge-primary hover:text-white px-2 py-1 cursor-pointer rounded-xl " + ("strategy" === t4[10] ? "outline outline-primary" : ""))) && U(de2, "class", pe2), (!Oe2 || 131072 & e3[0]) && Ye2 !== (Ye2 = t4[17]("metrics.risk.worst10Benchmark") + "") && H(_e2, Ye2), (!Oe2 || 1024 & e3[0] && we2 !== (we2 = "border border-base-content/10 text-sm bg-base-100 hover:badge-primary hover:text-white px-2 py-1 cursor-pointer rounded-xl " + ("benchmark" === t4[10] ? "outline outline-primary" : ""))) && U(be2, "class", we2), 1989636 & e3[0]) {
-                let i4;
-                for (si2 = ue("strategy" === t4[10] ? t4[14] : t4[12]), i4 = 0; i4 < si2.length; i4 += 1) {
-                    const s3 = Zu(t4, si2, i4);
-                    ni2[i4] ? ni2[i4].p(s3, e3) : (ni2[i4] = nd(s3), ni2[i4].c(), ni2[i4].m(Te2, null));
-                }
-                for (; i4 < ni2.length; i4 += 1)
-                    ni2[i4].d(1);
-                ni2.length = si2.length;
-            }
-            (!Oe2 || 131072 & e3[0]) && Qe2 !== (Qe2 = t4[17]("strategy") + "") && H(Ie2, Qe2), (!Oe2 || 131072 & e3[0]) && Xe2 !== (Xe2 = t4[17]("risk.drawdownPercentage") + "") && H(Ae2, Xe2);
-        },
-        i(t4) {
-            Oe2 || (le(rt2.$$.fragment, t4), Oe2 = true);
-        },
-        o(t4) {
-            he(rt2.$$.fragment, t4), Oe2 = false;
-        },
-        d(i3) {
-            i3 && E(e2), C(Ze2, i3), t3[23](null), ye(rt2), C(ei2, i3), C(ni2, i3), t3[30](null), Fe2 = false, n(Ne2);
-        }
-    };
-}
-
-function od(t3, e2, i2) {
-    let s2, n2, r2, o2, a2, l2, h2, c2, u2, d2, {
-            lang: f2 = "en"
-        } = e2,
-        {
-            browser: p2
-        } = e2,
-        {
-            report: m2
-        } = e2,
-        {
-            theme: g2 = "light"
-        } = e2,
-        y2 = null,
-        v2 = null,
-        b2 = null,
-        _2 = null,
-        w2 = null;
-
-    function x2(t4, e3) {
-        if (y2)
-            if ("string" == typeof t4 && "string" == typeof e3) {
-                const s3 = new Date(t4),
-                    n3 = new Date(e3);
-                y2.setTimeScale(s3, n3), i2(7, b2 = S2({
-                    start: t4,
-                    end: e3
-                })), i2(7, b2 = ((s3 - n3) / 864e5).toFixed(0)), i2(8, _2 = s3), i2(9, w2 = n3);
-            } else {
-                const s3 = m2.indexOfTimestamps(t4),
-                    n3 = m2.indexOfTimestamps(e3),
-                    r3 = new Date(m2.timestamps[s3]),
-                    o3 = new Date(m2.timestamps[n3]);
-                y2.setTimeScale(r3, o3), i2(8, _2 = r3), i2(9, w2 = o3);
-            }
-    }
-
-    function k2(t4) {
-        y2 || i2(21, y2 = new TwChart(u2, true)), y2.setTheme(g2);
-        const e3 = "all" === t4 ? m2.timestamps.length : 100,
-            s3 = m2.timestamps.length / (e3 / 100),
-            n3 = m2.createTradingviewSeries("strategy", 0, -1, s3),
-            r3 = m2.createTradingviewSeries("benchmark", 0, -1, s3);
-        y2.resetAreaSeries(0), y2.resetAreaSeries(1), y2.series[0].setData(n3), y2.series[1].setData(r3), y2.chart.subscribeCrosshairMove((t5) => {}), y2.chart.subscribeClick((t5) => {}), y2.chart.timeScale().subscribeVisibleTimeRangeChange((t5) => {}), "all" === t4 && y2.setTimeScale(new Date(m2.timestamps[0]), new Date(m2.timestamps[m2.timestamps.length - 1]));
-    }
-    let T2 = "strategy";
-    const S2 = (t4) => ((new Date(m2.timestamps[t4.end]) - new Date(m2.timestamps[t4.start])) / 864e5).toFixed(0);
-    pt(() => {
-        if (!p2)
-            return;
-        const t4 = o2[0];
-        k2("year"), x2(m2.timestamps[t4.start], m2.timestamps[t4.end]), v2 || (v2 = new TwChart(d2, false)), v2.setTheme(g2), m2.timestamps.length, v2.resetAreaSeries(0), v2.resetAreaSeries(1), v2.series[0].setData(n2), v2.series[1].setData(r2), v2.setTimeScale(new Date(m2.timestamps[0]), new Date(m2.timestamps[m2.timestamps.length - 1]));
-    });
-    return t3.$$set = (t4) => {
-        "lang" in t4 && i2(0, f2 = t4.lang), "browser" in t4 && i2(1, p2 = t4.browser), "report" in t4 && i2(2, m2 = t4.report), "theme" in t4 && i2(3, g2 = t4.theme);
-    }, t3.$$.update = () => {
-        1 & t3.$$.dirty[0] && i2(17, s2 = (t4) => "en" === f2 ? sl(t4) : nl(t4)), 4 & t3.$$.dirty[0] && i2(16, n2 = m2.createTradingViewDrawdown("strategy", m2.timestamps.length)), 4 & t3.$$.dirty[0] && i2(15, r2 = m2.createTradingViewDrawdown("benchmark", m2.timestamps.length)), 2097160 & t3.$$.dirty[0] && y2 && y2.setTheme(g2), 4 & t3.$$.dirty[0] && i2(4, [o2, a2] = m2.calculateDrawdown("strategy"), o2, (i2(14, a2), i2(2, m2))), 4 & t3.$$.dirty[0] && i2(13, [l2, h2] = m2.calculateDrawdown("benchmark"), l2, (i2(12, h2), i2(2, m2))), 16 & t3.$$.dirty[0] && i2(11, c2 = o2[0]);
-    }, [f2, p2, m2, g2, o2, u2, d2, b2, _2, w2, T2, c2, h2, l2, a2, r2, n2, s2, x2, k2, S2, y2, (t4) => {
-        k2("year"), x2(m2.timestamps[t4.start], m2.timestamps[t4.end]), i2(11, c2 = t4);
-    }, function(t4) {
-        xt[t4 ? "unshift" : "push"](() => {
-            u2 = t4, i2(5, u2);
-        });
-    }, () => {
-        i2(10, T2 = "strategy");
-    }, () => {
-        i2(10, T2 = "benchmark");
-    }, (t4) => {
-        k2("year"), x2(m2.timestamps[t4.start], m2.timestamps[t4.end]), i2(11, c2 = t4);
-    }, () => {
-        i2(10, T2 = "strategy");
-    }, () => {
-        i2(10, T2 = "benchmark");
-    }, (t4) => {
-        k2("year"), x2(m2.timestamps[t4.start], m2.timestamps[t4.end]), i2(11, c2 = t4);
-    }, function(t4) {
-        xt[t4 ? "unshift" : "push"](() => {
-            d2 = t4, i2(6, d2);
-        });
-    }];
-}
-we(Ratio, {
-    browser: {},
-    report: {},
-    theme: {},
-    lang: {}
-}, [], [], true);
-class Risk extends SvelteComponent {
-    constructor(t3) {
-        super(), ve(this, t3, od, rd, o, {
-            lang: 0,
-            browser: 1,
-            report: 2,
-            theme: 3
-        }, null, [-1, -1]);
-    }
-    get lang() {
-        return this.$$.ctx[0];
-    }
-    set lang(t3) {
-        this.$$set({
-            lang: t3
-        }), te();
-    }
-    get browser() {
-        return this.$$.ctx[1];
-    }
-    set browser(t3) {
-        this.$$set({
-            browser: t3
-        }), te();
-    }
-    get report() {
-        return this.$$.ctx[2];
-    }
-    set report(t3) {
-        this.$$set({
-            report: t3
-        }), te();
-    }
-    get theme() {
-        return this.$$.ctx[3];
-    }
-    set theme(t3) {
-        this.$$set({
-            theme: t3
-        }), te();
-    }
-}
-we(Risk, {
-    lang: {},
-    browser: {},
-    report: {},
-    theme: {}
-}, [], [], true);
-
-function ad(e2) {
-    let i2, s2, r2, o2, a2, l2, h2, c2, u2, d2, f2, p2, m2, g2, y2, v2, b2, w2, x2, k2, T2, C2, R2, z2, j2, G2, Y2, it2, st2, rt2, ht2, ct2, ut2, dt2, ft2, pt2, yt2, bt2, _t2, xt2, kt2, St2, It2, Mt2, At2, Lt2, Ot2, Ht2, Qt2, Jt2, te2, ee2, ie2, se2, ne2, re2, oe2, ae2, le2, he2, ce2, ue2, de2, fe2, pe2, me2, ge2, ye2, ve2, be2, _e2, we2, xe2, ke2, Te2, Se2, Ee2, Ce2, Ie2, Me2, Pe2, Re2, Ae2, De2, Le2, Oe2, Fe2, Ne2, $e2, Ve2, ze2, Be2, Ue2, je2, He2, We2, qe2, Ke2, Ge2, Ye2, Qe2, Xe2, Je2, Ze2, ti2, ei2, si2, ni2, ri2, ai2, li2, hi2, ci2, ui2, yi2, _i2, ki2 = e2[10]("metrics.winrate.returnDistribution") + "",
-        Ti2 = e2[10]("metrics.winrate.distributionInfo1") + "",
-        Si2 = (100 * e2[11]).toFixed(1) + "",
-        Ei2 = e2[10]("metrics.winrate.distributionInfo2") + "",
-        Ii2 = e2[10]("metrics.winrate.return") + "",
-        Li2 = e2[10]("metrics.winrate.simulatedStopLoss") + "",
-        Oi2 = e2[10]("metrics.winrate.stoploss") + "",
-        Fi2 = (0 !== e2[0] ? 100 * e2[0] + "%" : e2[10]("metrics.winrate.none")) + "",
-        Ni2 = e2[10]("metrics.winrate.extraProfitLoss") + "",
-        Vi2 = (e2[9] > 0 ? "+" : "") + (100 * e2[9]).toFixed(1),
-        zi2 = e2[10]("metrics.winrate.stoplossRatio") + "",
-        Ui2 = (100 * e2[8]).toFixed(1) + "",
-        ji2 = e2[10]("metrics.winrate.maeReturn") + "",
-        Wi2 = e2[10]("metrics.winrate.return") + "",
-        qi2 = e2[10]("metrics.winrate.mae") + "",
-        Gi2 = e2[10]("metrics.winrate.simulatedTakeProfit") + "",
-        Yi2 = e2[10]("metrics.winrate.takeProfit") + "",
-        Qi2 = (0 !== e2[1] ? 100 * e2[1] + "%" : e2[10]("metrics.winrate.none")) + "",
-        Xi2 = e2[10]("metrics.winrate.extraProfitLossTakingProfit") + "",
-        Ji2 = (e2[7] > 0 ? "+" : "") + (100 * e2[7]).toFixed(1),
-        ts2 = e2[10]("metrics.winrate.takeProfitRatio") + "",
-        es2 = (100 * e2[6]).toFixed(1) + "",
-        is2 = e2[10]("metrics.winrate.mfeReturn") + "",
-        ss2 = e2[10]("metrics.winrate.return") + "",
-        ns2 = e2[10]("metrics.winrate.mae") + "",
-        rs2 = e2[10]("metrics.winrate.maemfe") + "",
-        os2 = e2[10]("metrics.winrate.mfe") + "",
-        as2 = e2[10]("metrics.winrate.mae") + "";
-    return {
-        c() {
-            i2 = P("div"), s2 = P("div"), r2 = P("div"), o2 = P("h3"), a2 = D(ki2), l2 = $(), h2 = P("span"), c2 = D(Ti2), u2 = $(), d2 = D(Si2), f2 = $(), p2 = D(Ei2), m2 = $(), g2 = P("canvas"), y2 = $(), v2 = P("div"), b2 = D(Ii2), w2 = $(), x2 = P("div"), k2 = P("h3"), T2 = D(Li2), C2 = $(), R2 = P("span"), z2 = D(Oi2), j2 = $(), G2 = P("span"), Y2 = D(Fi2), it2 = $(), st2 = P("br"), rt2 = $(), ht2 = P("span"), ct2 = D(Ni2), ut2 = $(), dt2 = P("span"), ft2 = D(Vi2), pt2 = D("\n				%"), yt2 = $(), bt2 = P("br"), _t2 = $(), xt2 = P("span"), kt2 = D(zi2), St2 = $(), It2 = P("span"), Mt2 = D(Ui2), At2 = D("%"), Lt2 = $(), Ot2 = P("input"), Ht2 = $(), Qt2 = P("div"), Qt2.innerHTML = '<span class="font-bold text-sm">0％</span> <span class="font-bold text-sm">5％</span> <span class="font-bold text-sm">10％</span> <span class="font-bold text-sm">15％</span> <span class="font-bold text-sm">20％</span> <span class="font-bold text-sm">25％</span> <span class="font-bold text-sm">30％</span>', Jt2 = $(), te2 = P("h3"), ee2 = D(ji2), ie2 = $(), se2 = P("div"), ne2 = D(Wi2), re2 = $(), oe2 = P("canvas"), ae2 = $(), le2 = P("div"), he2 = D(qi2), ce2 = $(), ue2 = P("div"), de2 = P("h3"), fe2 = D(Gi2), pe2 = $(), me2 = P("span"), ge2 = D(Yi2), ye2 = P("span"), ve2 = D(Qi2), be2 = $(), _e2 = P("br"), we2 = $(), xe2 = P("span"), ke2 = D(Xi2), Te2 = $(), Se2 = P("span"), Ee2 = D(Ji2), Ce2 = $(), Ie2 = D("%"), Me2 = $(), Pe2 = P("br"), Re2 = $(), Ae2 = P("span"), De2 = D(ts2), Le2 = P("span"), Oe2 = D(es2), Fe2 = D("%"), Ne2 = $(), $e2 = P("input"), Ve2 = $(), ze2 = P("div"), ze2.innerHTML = '<span class="font-bold text-sm">0％</span> <span class="font-bold text-sm">5％</span> <span class="font-bold text-sm">10％</span> <span class="font-bold text-sm">15％</span> <span class="font-bold text-sm">20％</span> <span class="font-bold text-sm">25％</span> <span class="font-bold text-sm">30％</span>', Be2 = $(), Ue2 = P("h3"), je2 = D(is2), He2 = $(), We2 = P("div"), qe2 = D(ss2), Ke2 = $(), Ge2 = P("canvas"), Ye2 = $(), Qe2 = P("div"), Xe2 = D(ns2), Je2 = $(), Ze2 = P("div"), ti2 = P("h3"), ei2 = D(rs2), si2 = $(), ni2 = P("div"), ri2 = D(os2), ai2 = $(), li2 = P("canvas"), hi2 = $(), ci2 = P("div"), ui2 = D(as2), U(o2, "class", "text-2xl font-bold mb-4 text-base-content-200"), U(g2, "class", "mt-2 max-h-[400px]"), U(v2, "class", "text-sm text-center pb-4 mt-2"), U(r2, "class", "col-span-6 text-center p-2 md:p-8 pt-8 md:border rounded-xl"), U(k2, "class", "text-2xl font-bold mb-4 text-center text-base-content-200"), U(G2, "class", "font-bold"), U(dt2, "class", "font-bold"), U(It2, "class", "font-bold"), U(Ot2, "type", "range"), U(Ot2, "min", "0"), U(Ot2, "max", "0.3"), U(Ot2, "class", "range range-secondary mt-4"), U(Ot2, "step", "0.05"), U(Qt2, "class", "w-full flex justify-between text-xs px-2"), U(te2, "class", "text-2xl font-bold mt-6 mb-3 text-center text-base-content-200"), U(se2, "class", "text-base-content-100 text-sm font-bold mt-2"), U(oe2, "class", "mt-2"), U(le2, "class", "text-base-content-100 text-sm text-center font-bold"), U(x2, "class", "col-span-6 md:col-span-3 p-2 md:p-8 pt-8 md:border rounded-xl"), U(de2, "class", "text-2xl font-bold mb-4 text-center text-base-content-200"), U(ye2, "class", "font-bold"), U(Se2, "class", "font-bold"), U(Le2, "class", "font-bold"), U($e2, "type", "range"), U($e2, "min", "0"), U($e2, "max", "0.3"), U($e2, "class", "range range-primary mt-4"), U($e2, "step", "0.05"), U(ze2, "class", "w-full flex justify-between text-xs px-2"), U(Ue2, "class", "text-2xl font-bold mt-6 mb-3 text-center text-base-content-200"), U(We2, "class", "text-base-content-100 text-sm font-bold mt-2"), U(Ge2, "class", "mt-2"), U(Qe2, "class", "text-base-content-100 text-sm text-center font-bold"), U(ue2, "class", "col-span-6 md:col-span-3 p-2 md:p-8 pt-8 md:border rounded-xl"), U(ti2, "class", "text-2xl font-bold text-center text-base-content-200"), U(ni2, "class", "text-base-content-100 text-sm font-bold mt-4"), U(li2, "class", "mt-2"), U(ci2, "class", "text-base-content-100 text-sm text-center font-bold"), U(Ze2, "class", "col-span-6 p-2 md:p-8 pt-8 md:border rounded-xl"), U(s2, "class", "grid grid-cols-6 gap-4"), U(i2, "class", "text-base-content-200");
-        },
-        m(t3, n2) {
-            S(t3, i2, n2), _(i2, s2), _(s2, r2), _(r2, o2), _(o2, a2), _(r2, l2), _(r2, h2), _(h2, c2), _(h2, u2), _(h2, d2), _(h2, f2), _(h2, p2), _(r2, m2), _(r2, g2), e2[20](g2), _(r2, y2), _(r2, v2), _(v2, b2), _(s2, w2), _(s2, x2), _(x2, k2), _(k2, T2), _(x2, C2), _(x2, R2), _(R2, z2), _(R2, j2), _(R2, G2), _(G2, Y2), _(x2, it2), _(x2, st2), _(x2, rt2), _(x2, ht2), _(ht2, ct2), _(ht2, ut2), _(ht2, dt2), _(dt2, ft2), _(ht2, pt2), _(x2, yt2), _(x2, bt2), _(x2, _t2), _(x2, xt2), _(xt2, kt2), _(xt2, St2), _(xt2, It2), _(It2, Mt2), _(It2, At2), _(x2, Lt2), _(x2, Ot2), q(Ot2, e2[0]), _(x2, Ht2), _(x2, Qt2), _(x2, Jt2), _(x2, te2), _(te2, ee2), _(x2, ie2), _(x2, se2), _(se2, ne2), _(x2, re2), _(x2, oe2), e2[22](oe2), _(x2, ae2), _(x2, le2), _(le2, he2), _(s2, ce2), _(s2, ue2), _(ue2, de2), _(de2, fe2), _(ue2, pe2), _(ue2, me2), _(me2, ge2), _(me2, ye2), _(ye2, ve2), _(ue2, be2), _(ue2, _e2), _(ue2, we2), _(ue2, xe2), _(xe2, ke2), _(xe2, Te2), _(xe2, Se2), _(Se2, Ee2), _(Se2, Ce2), _(xe2, Ie2), _(ue2, Me2), _(ue2, Pe2), _(ue2, Re2), _(ue2, Ae2), _(Ae2, De2), _(Ae2, Le2), _(Le2, Oe2), _(Le2, Fe2), _(ue2, Ne2), _(ue2, $e2), q($e2, e2[1]), _(ue2, Ve2), _(ue2, ze2), _(ue2, Be2), _(ue2, Ue2), _(Ue2, je2), _(ue2, He2), _(ue2, We2), _(We2, qe2), _(ue2, Ke2), _(ue2, Ge2), e2[24](Ge2), _(ue2, Ye2), _(ue2, Qe2), _(Qe2, Xe2), _(s2, Je2), _(s2, Ze2), _(Ze2, ti2), _(ti2, ei2), _(Ze2, si2), _(Ze2, ni2), _(ni2, ri2), _(Ze2, ai2), _(Ze2, li2), e2[25](li2), _(Ze2, hi2), _(Ze2, ci2), _(ci2, ui2), yi2 || (_i2 = [B(Ot2, "change", e2[21]), B(Ot2, "input", e2[21]), B($e2, "change", e2[23]), B($e2, "input", e2[23])], yi2 = true);
-        },
-        p(t3, e3) {
-            1024 & e3[0] && ki2 !== (ki2 = t3[10]("metrics.winrate.returnDistribution") + "") && H(a2, ki2), 1024 & e3[0] && Ti2 !== (Ti2 = t3[10]("metrics.winrate.distributionInfo1") + "") && H(c2, Ti2), 1024 & e3[0] && Ei2 !== (Ei2 = t3[10]("metrics.winrate.distributionInfo2") + "") && H(p2, Ei2), 1024 & e3[0] && Ii2 !== (Ii2 = t3[10]("metrics.winrate.return") + "") && H(b2, Ii2), 1024 & e3[0] && Li2 !== (Li2 = t3[10]("metrics.winrate.simulatedStopLoss") + "") && H(T2, Li2), 1024 & e3[0] && Oi2 !== (Oi2 = t3[10]("metrics.winrate.stoploss") + "") && H(z2, Oi2), 1025 & e3[0] && Fi2 !== (Fi2 = (0 !== t3[0] ? 100 * t3[0] + "%" : t3[10]("metrics.winrate.none")) + "") && H(Y2, Fi2), 1024 & e3[0] && Ni2 !== (Ni2 = t3[10]("metrics.winrate.extraProfitLoss") + "") && H(ct2, Ni2), 512 & e3[0] && Vi2 !== (Vi2 = (t3[9] > 0 ? "+" : "") + (100 * t3[9]).toFixed(1)) && H(ft2, Vi2), 1024 & e3[0] && zi2 !== (zi2 = t3[10]("metrics.winrate.stoplossRatio") + "") && H(kt2, zi2), 256 & e3[0] && Ui2 !== (Ui2 = (100 * t3[8]).toFixed(1) + "") && H(Mt2, Ui2), 1 & e3[0] && q(Ot2, t3[0]), 1024 & e3[0] && ji2 !== (ji2 = t3[10]("metrics.winrate.maeReturn") + "") && H(ee2, ji2), 1024 & e3[0] && Wi2 !== (Wi2 = t3[10]("metrics.winrate.return") + "") && H(ne2, Wi2), 1024 & e3[0] && qi2 !== (qi2 = t3[10]("metrics.winrate.mae") + "") && H(he2, qi2), 1024 & e3[0] && Gi2 !== (Gi2 = t3[10]("metrics.winrate.simulatedTakeProfit") + "") && H(fe2, Gi2), 1024 & e3[0] && Yi2 !== (Yi2 = t3[10]("metrics.winrate.takeProfit") + "") && H(ge2, Yi2), 1026 & e3[0] && Qi2 !== (Qi2 = (0 !== t3[1] ? 100 * t3[1] + "%" : t3[10]("metrics.winrate.none")) + "") && H(ve2, Qi2), 1024 & e3[0] && Xi2 !== (Xi2 = t3[10]("metrics.winrate.extraProfitLossTakingProfit") + "") && H(ke2, Xi2), 128 & e3[0] && Ji2 !== (Ji2 = (t3[7] > 0 ? "+" : "") + (100 * t3[7]).toFixed(1)) && H(Ee2, Ji2), 1024 & e3[0] && ts2 !== (ts2 = t3[10]("metrics.winrate.takeProfitRatio") + "") && H(De2, ts2), 64 & e3[0] && es2 !== (es2 = (100 * t3[6]).toFixed(1) + "") && H(Oe2, es2), 2 & e3[0] && q($e2, t3[1]), 1024 & e3[0] && is2 !== (is2 = t3[10]("metrics.winrate.mfeReturn") + "") && H(je2, is2), 1024 & e3[0] && ss2 !== (ss2 = t3[10]("metrics.winrate.return") + "") && H(qe2, ss2), 1024 & e3[0] && ns2 !== (ns2 = t3[10]("metrics.winrate.mae") + "") && H(Xe2, ns2), 1024 & e3[0] && rs2 !== (rs2 = t3[10]("metrics.winrate.maemfe") + "") && H(ei2, rs2), 1024 & e3[0] && os2 !== (os2 = t3[10]("metrics.winrate.mfe") + "") && H(ri2, os2), 1024 & e3[0] && as2 !== (as2 = t3[10]("metrics.winrate.mae") + "") && H(ui2, as2);
-        },
-        i: t,
-        o: t,
-        d(t3) {
-            t3 && E(i2), e2[20](null), e2[22](null), e2[24](null), e2[25](null), yi2 = false, n(_i2);
-        }
-    };
-}
-
-function ld(t3, e2, i2) {
-    let s2, n2, r2, o2, a2, l2, h2, {
-        lang: c2 = "en"
-    } = e2;
-    Chart.register(BubbleController, LinearScale, PointElement, Ga, CategoryScale, BarController, BarElement, LineElement, LineController);
-    let {
-        browser: u2
-    } = e2, {
-        report: d2
-    } = e2, {
-        theme: f2 = "light"
-    } = e2, p2 = 0, m2 = 0;
-    const g2 = d2.trades.map((t4) => t4.return),
-        y2 = g2.reduce((t4, e3) => t4 + e3, 0) / g2.length,
-        v2 = g2.reduce((t4, e3) => t4 + Math.pow(e3 - y2, 2), 0) / g2.length,
-        b2 = Math.sqrt(v2);
-
-    function _2(t4, e3) {
-        const i3 = -3 * b2,
-            s3 = (3 * b2 - i3) / e3,
-            n3 = new Array(e3).fill(0),
-            r3 = [];
-        t4.forEach((t5) => {
-            const r4 = Math.min(Math.floor((t5 - i3) / s3), e3 - 1);
-            n3[r4]++;
-        });
-        for (let t5 = 0; t5 < e3; t5++)
-            r3.push([i3 + t5 * s3, i3 + (t5 + 1) * s3]);
-        return {
-            bins: n3,
-            ranges: r3
-        };
-    }
-    let w2;
-    [...g2].sort((t4, e3) => t4 - e3);
-    let x2, k2 = null;
-    const T2 = function(t4, e3 = 0.95) {
-        const i3 = t4;
-        return 0 === i3.length ? null : (i3.sort((t5, e4) => t5 - e4), i3[Math.floor((1 - e3) * i3.length)]);
-    }(d2.trades.map((t4) => t4.return));
-
-    function S2(t4) {
-        const e3 = w2,
-            i3 = t4.ranges.map((t5) => t5[0]),
-            s3 = i3.map((t5) => t5 >= 0 ? "light" === f2 ? "#725bf5" : "#7a64f5" : "rgba(241, 99, 102, 1)");
-        null !== k2 && k2.destroy(), k2 = new Chart(e3, {
-            type: "bar",
-            data: {
-                labels: i3,
-                datasets: [{
-                    data: t4.bins,
-                    backgroundColor: s3
-                }]
-            },
-            options: {
-                responsive: true,
-                maintainAspectRatio: true,
-                scales: {
-                    x: {
-                        type: "category",
-                        ticks: {
-                            callback: (t5, e4, s4) => (100 * i3[e4]).toFixed(1) + "%",
-                            color: "light" === f2 ? "#000000aa" : "#FFFFFFaa"
-                        },
-                        grid: {
-                            color: "#77777755",
-                            tickBorderDash: [2, 2]
-                        }
-                    },
-                    y: {
-                        type: "linear",
-                        ticks: {
-                            callback: (t5, e4, i4) => t5 + " trades",
-                            color: "light" === f2 ? "#000000aa" : "#FFFFFFaa"
-                        },
-                        grid: {
-                            color: "#77777755",
-                            tickBorderDash: [2, 2]
-                        }
-                    }
-                }
-            }
-        });
-    }
-    const E2 = d2.trades.filter((t4) => t4.return > 0),
-        C2 = d2.trades.filter((t4) => t4.return <= 0);
-
-    function P2(t4, e3, i3, s3) {
-        const n3 = Math.max(...d2.trades.map((t5) => Math.abs(t5[e3]))),
-            r3 = Math.max(...d2.trades.map((t5) => Math.abs(t5[i3]))),
-            o3 = d2.trades.map((t5) => Math.log(Math.abs(t5.return) + 1)),
-            a3 = Math.max(...o3),
-            l3 = Math.min(...o3);
-
-        function h3(t5, e4, i4, s4, n4) {
-            return (t5 - e4) / (i4 - e4) * (n4 - s4) + s4;
-        }
-
-        function c3(t5, i4) {
-            const s4 = 0 !== p2 ? p2 : 1;
-            return "mae" === e3 ? i4 < -s4 ? -s4 : t5 : "gmfe" === e3 && i4 > m2 && 0 !== m2 ? m2 : t5;
-        }
-        const u3 = {
-            type: "bubble",
-            data: {
-                datasets: [{
-                    label: "Winning",
-                    data: E2.map((t5) => ({
-                        x: Math.abs(t5[e3]),
-                        y: Math.abs(c3(t5[i3], t5[e3])),
-                        r: h3(Math.log(Math.abs(t5.return) + 1), l3, a3, 3, 20),
-                        t: t5
-                    })),
-                    backgroundColor: "rgba(99, 102, 241, 0.5)"
-                }, {
-                    label: "Losing",
-                    data: C2.map((t5) => ({
-                        x: Math.abs(t5[e3]),
-                        y: Math.abs(c3(t5[i3], t5[e3])),
-                        r: h3(Math.log(Math.abs(t5.return) + 1), l3, a3, 3, 20),
-                        t: t5
-                    })),
-                    backgroundColor: "rgba(241, 99, 102, 0.5)"
-                }, {
-                    label: "45-degree Line",
-                    data: [{
-                        x: 0,
-                        y: 0
-                    }, {
-                        x: 0.5,
-                        y: 0.5
-                    }],
-                    type: "line",
-                    fill: false,
-                    borderColor: "rgba(125, 125, 125, 0.8)",
-                    pointRadius: 0,
-                    borderWidth: 1,
-                    tension: 0
-                }]
-            },
-            options: {
-                responsive: true,
-                maintainAspectRatio: true,
-                animation: false,
-                scales: {
-                    x: {
-                        type: "linear",
-                        beginAtZero: true,
-                        max: Math.min(0.5, n3, r3),
-                        ticks: {
-                            color: "light" === f2 ? "#000000aa" : "#FFFFFFaa",
-                            callback: (t5, e4, i4) => (100 * t5).toFixed(1) + "%"
-                        },
-                        grid: {
-                            color: "#77777755",
-                            tickBorderDash: [2, 2]
-                        }
-                    },
-                    y: {
-                        type: "linear",
-                        beginAtZero: true,
-                        max: Math.min(0.5, r3, n3),
-                        ticks: {
-                            color: "light" === f2 ? "#000000aa" : "#FFFFFFaa",
-                            callback: (t5, e4, i4) => (100 * t5).toFixed(1) + "%"
-                        },
-                        grid: {
-                            color: "#77777755",
-                            tickBorderDash: [2, 2]
-                        }
-                    }
-                },
-                plugins: {
-                    zoom: {
-                        pan: {
-                            enabled: true,
-                            mode: "xy"
-                        },
-                        zoom: {
-                            wheel: {
-                                enabled: true
-                            },
-                            pinch: {
-                                enabled: true
-                            },
-                            mode: "xy"
-                        }
-                    },
-                    tooltip: {
-                        callbacks: {
-                            title: (t5) => t5[0].raw.t.stockId + " " + t5[0].dataset.label,
-                            label(t5) {
-                                const s4 = t5.raw.x.toFixed(2),
-                                    n4 = t5.raw.y.toFixed(2);
-                                return t5.raw.t.stock, `${e3}: ${s4}, ${i3}:${n4}`;
-                            }
-                        }
-                    }
-                }
-            }
-        };
-        return new Chart(t4, u3);
-    }
-    let R2, D2;
-    const $2 = {};
-    let z2 = false;
-    return pt(() => {
-        if (!u2)
-            return;
-        S2(_2(g2, 50)), i2(16, $2.maemfe = P2(x2, "mae", "gmfe"), $2), i2(16, $2.mae = P2(R2, "mae", "return"), $2), i2(16, $2.mfe = P2(D2, "gmfe", "return"), $2), i2(17, z2 = true);
-    }), yt(() => {
-        var _a2, _b2, _c2;
-        (_a2 = $2.maemfe) == null ? void 0 : _a2.destroy(), (_b2 = $2.mae) == null ? void 0 : _b2.destroy(), (_c2 = $2.mfe) == null ? void 0 : _c2.destroy(), k2 == null ? void 0 : k2.destroy();
-    }), t3.$$set = (t4) => {
-        "lang" in t4 && i2(12, c2 = t4.lang), "browser" in t4 && i2(13, u2 = t4.browser), "report" in t4 && i2(14, d2 = t4.report), "theme" in t4 && i2(15, f2 = t4.theme);
-    }, t3.$$.update = () => {
-        if (4096 & t3.$$.dirty[0] && i2(10, s2 = (t4) => "en" === c2 ? sl(t4) : nl(t4)), 16385 & t3.$$.dirty[0] && i2(19, n2 = d2.trades.filter((t4) => t4.mae < -p2).map((t4) => t4.return)), 524289 & t3.$$.dirty[0] && i2(9, r2 = 0 === p2 ? 0 : n2.reduce((t4, e3) => t4 + e3, 0) / n2.length + p2 || 0), 540673 & t3.$$.dirty[0] && i2(8, o2 = 0 === p2 ? 0 : n2.length / d2.trades.length), 16386 & t3.$$.dirty[0] && i2(18, a2 = d2.trades.filter((t4) => t4.gmfe > m2).map((t4) => t4.return)), 262146 & t3.$$.dirty[0] && i2(7, l2 = 0 === m2 ? 0 : a2.reduce((t4, e3) => t4 + e3, 0) / a2.length - m2 || 0), 278530 & t3.$$.dirty[0] && i2(6, h2 = 0 === m2 ? 0 : a2.length / d2.trades.length), 229380 & t3.$$.dirty[0] && f2 && z2) {
-            $2.maemfe && ($2.maemfe.destroy(), i2(16, $2.maemfe = P2(x2, "mae", "gmfe"), $2));
-            S2(_2(g2, 50));
-        }
-        98313 & t3.$$.dirty[0] && (0 === p2 || p2 || f2) && $2.mae && ($2.mae.destroy(), i2(16, $2.mae = P2(R2, "mae", "return"), $2)), 98322 & t3.$$.dirty[0] && (0 === m2 || m2 || f2) && $2.mfe && ($2.mfe.destroy(), i2(16, $2.mfe = P2(D2, "gmfe", "return"), $2));
-    }, [p2, m2, x2, R2, D2, w2, h2, l2, o2, r2, s2, T2, c2, u2, d2, f2, $2, z2, a2, n2, function(t4) {
-        xt[t4 ? "unshift" : "push"](() => {
-            w2 = t4, i2(5, w2);
-        });
-    }, function() {
-        p2 = j(this.value), i2(0, p2);
-    }, function(t4) {
-        xt[t4 ? "unshift" : "push"](() => {
-            R2 = t4, i2(3, R2);
-        });
-    }, function() {
-        m2 = j(this.value), i2(1, m2);
-    }, function(t4) {
-        xt[t4 ? "unshift" : "push"](() => {
-            D2 = t4, i2(4, D2);
-        });
-    }, function(t4) {
-        xt[t4 ? "unshift" : "push"](() => {
-            x2 = t4, i2(2, x2);
-        });
-    }];
-}
-class Winrate extends SvelteComponent {
-    constructor(t3) {
-        super(), ve(this, t3, ld, ad, o, {
-            lang: 12,
-            browser: 13,
-            report: 14,
-            theme: 15
-        }, null, [-1, -1]);
-    }
-    get lang() {
-        return this.$$.ctx[12];
-    }
-    set lang(t3) {
-        this.$$set({
-            lang: t3
-        }), te();
-    }
-    get browser() {
-        return this.$$.ctx[13];
-    }
-    set browser(t3) {
-        this.$$set({
-            browser: t3
-        }), te();
-    }
-    get report() {
-        return this.$$.ctx[14];
-    }
-    set report(t3) {
-        this.$$set({
-            report: t3
-        }), te();
-    }
-    get theme() {
-        return this.$$.ctx[15];
-    }
-    set theme(t3) {
-        this.$$set({
-            theme: t3
-        }), te();
-    }
-}
-we(Winrate, {
-    lang: {},
-    browser: {},
-    report: {},
-    theme: {}
-}, [], [], true);
-const hd = [];
-
-function cd(e2, i2 = t) {
-    let s2;
-    const n2 = /* @__PURE__ */ new Set();
-
-    function r2(t3) {
-        if (o(e2, t3) && (e2 = t3, s2)) {
-            const t4 = !hd.length;
-            for (const t5 of n2)
-                t5[1](), hd.push(t5, e2);
-            if (t4) {
-                for (let t5 = 0; t5 < hd.length; t5 += 2)
-                    hd[t5][0](hd[t5 + 1]);
-                hd.length = 0;
-            }
-        }
-    }
-
-    function a2(t3) {
-        r2(t3(e2));
-    }
-    return {
-        set: r2,
-        update: a2,
-        subscribe: function(o2, l2 = t) {
-            const h2 = [o2, l2];
-            return n2.add(h2), 1 === n2.size && (s2 = i2(r2, a2) || t), o2(e2), () => {
-                n2.delete(h2), 0 === n2.size && s2 && (s2(), s2 = null);
-            };
-        }
-    };
-}
-const ud = cd(null),
-    dd = function(t3) {
-        const e2 = [];
-        let i2 = 0;
-        for (let s2 = 0; s2 < t3.length; s2++) {
-            let n2 = t3.charCodeAt(s2);
-            n2 < 128 ? e2[i2++] = n2 : n2 < 2048 ? (e2[i2++] = n2 >> 6 | 192, e2[i2++] = 63 & n2 | 128) : 55296 == (64512 & n2) && s2 + 1 < t3.length && 56320 == (64512 & t3.charCodeAt(s2 + 1)) ? (n2 = 65536 + ((1023 & n2) << 10) + (1023 & t3.charCodeAt(++s2)), e2[i2++] = n2 >> 18 | 240, e2[i2++] = n2 >> 12 & 63 | 128, e2[i2++] = n2 >> 6 & 63 | 128, e2[i2++] = 63 & n2 | 128) : (e2[i2++] = n2 >> 12 | 224, e2[i2++] = n2 >> 6 & 63 | 128, e2[i2++] = 63 & n2 | 128);
-        }
-        return e2;
-    },
-    fd = {
-        byteToCharMap_: null,
-        charToByteMap_: null,
-        byteToCharMapWebSafe_: null,
-        charToByteMapWebSafe_: null,
-        ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
-        get ENCODED_VALS() {
-            return this.ENCODED_VALS_BASE + "+/=";
-        },
-        get ENCODED_VALS_WEBSAFE() {
-            return this.ENCODED_VALS_BASE + "-_.";
-        },
-        HAS_NATIVE_SUPPORT: "function" == typeof atob,
-        encodeByteArray(t3, e2) {
-            if (!Array.isArray(t3))
-                throw Error("encodeByteArray takes an array as a parameter");
-            this.init_();
-            const i2 = e2 ? this.byteToCharMapWebSafe_ : this.byteToCharMap_,
-                s2 = [];
-            for (let e3 = 0; e3 < t3.length; e3 += 3) {
-                const n2 = t3[e3],
-                    r2 = e3 + 1 < t3.length,
-                    o2 = r2 ? t3[e3 + 1] : 0,
-                    a2 = e3 + 2 < t3.length,
-                    l2 = a2 ? t3[e3 + 2] : 0,
-                    h2 = n2 >> 2,
-                    c2 = (3 & n2) << 4 | o2 >> 4;
-                let u2 = (15 & o2) << 2 | l2 >> 6,
-                    d2 = 63 & l2;
-                a2 || (d2 = 64, r2 || (u2 = 64)), s2.push(i2[h2], i2[c2], i2[u2], i2[d2]);
-            }
-            return s2.join("");
-        },
-        encodeString(t3, e2) {
-            return this.HAS_NATIVE_SUPPORT && !e2 ? btoa(t3) : this.encodeByteArray(dd(t3), e2);
-        },
-        decodeString(t3, e2) {
-            return this.HAS_NATIVE_SUPPORT && !e2 ? atob(t3) : function(t4) {
-                const e3 = [];
-                let i2 = 0,
-                    s2 = 0;
-                for (; i2 < t4.length;) {
-                    const n2 = t4[i2++];
-                    if (n2 < 128)
-                        e3[s2++] = String.fromCharCode(n2);
-                    else if (n2 > 191 && n2 < 224) {
-                        const r2 = t4[i2++];
-                        e3[s2++] = String.fromCharCode((31 & n2) << 6 | 63 & r2);
-                    } else if (n2 > 239 && n2 < 365) {
-                        const r2 = ((7 & n2) << 18 | (63 & t4[i2++]) << 12 | (63 & t4[i2++]) << 6 | 63 & t4[i2++]) - 65536;
-                        e3[s2++] = String.fromCharCode(55296 + (r2 >> 10)), e3[s2++] = String.fromCharCode(56320 + (1023 & r2));
-                    } else {
-                        const r2 = t4[i2++],
-                            o2 = t4[i2++];
-                        e3[s2++] = String.fromCharCode((15 & n2) << 12 | (63 & r2) << 6 | 63 & o2);
-                    }
-                }
-                return e3.join("");
-            }(this.decodeStringToByteArray(t3, e2));
-        },
-        decodeStringToByteArray(t3, e2) {
-            this.init_();
-            const i2 = e2 ? this.charToByteMapWebSafe_ : this.charToByteMap_,
-                s2 = [];
-            for (let e3 = 0; e3 < t3.length;) {
-                const n2 = i2[t3.charAt(e3++)],
-                    r2 = e3 < t3.length ? i2[t3.charAt(e3)] : 0;
-                ++e3;
-                const o2 = e3 < t3.length ? i2[t3.charAt(e3)] : 64;
-                ++e3;
-                const a2 = e3 < t3.length ? i2[t3.charAt(e3)] : 64;
-                if (++e3, null == n2 || null == r2 || null == o2 || null == a2)
-                    throw new DecodeBase64StringError();
-                const l2 = n2 << 2 | r2 >> 4;
-                if (s2.push(l2), 64 !== o2) {
-                    const t4 = r2 << 4 & 240 | o2 >> 2;
-                    if (s2.push(t4), 64 !== a2) {
-                        const t5 = o2 << 6 & 192 | a2;
-                        s2.push(t5);
-                    }
-                }
-            }
-            return s2;
-        },
-        init_() {
-            if (!this.byteToCharMap_) {
-                this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {};
-                for (let t3 = 0; t3 < this.ENCODED_VALS.length; t3++)
-                    this.byteToCharMap_[t3] = this.ENCODED_VALS.charAt(t3), this.charToByteMap_[this.byteToCharMap_[t3]] = t3, this.byteToCharMapWebSafe_[t3] = this.ENCODED_VALS_WEBSAFE.charAt(t3), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[t3]] = t3, t3 >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(t3)] = t3, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(t3)] = t3);
-            }
-        }
-    };
-class DecodeBase64StringError extends Error {
-    constructor() {
-        super(...arguments), this.name = "DecodeBase64StringError";
-    }
-}
-const pd = function(t3) {
-        return function(t4) {
-            const e2 = dd(t4);
-            return fd.encodeByteArray(e2, true);
-        }(t3).replace(/\./g, "");
-    },
-    md = function(t3) {
-        try {
-            return fd.decodeString(t3, true);
-        } catch (t4) {
-            console.error("base64Decode failed: ", t4);
-        }
-        return null;
-    };
-const gd = () => function() {
-        if ("undefined" != typeof self)
-            return self;
-        if ("undefined" != typeof window)
-            return window;
-        if ("undefined" != typeof global)
-            return global;
-        throw new Error("Unable to locate global object.");
-    }().__FIREBASE_DEFAULTS__,
-    yd = () => {
-        try {
-            return gd() || (() => {
-                if ("undefined" == typeof process || void 0 === process.env)
-                    return;
-                const t3 = process.env.__FIREBASE_DEFAULTS__;
-                return t3 ? JSON.parse(t3) : void 0;
-            })() || (() => {
-                if ("undefined" == typeof document)
-                    return;
-                let t3;
-                try {
-                    t3 = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
-                } catch (t4) {
-                    return;
-                }
-                const e2 = t3 && md(t3[1]);
-                return e2 && JSON.parse(e2);
-            })();
-        } catch (t3) {
-            return void console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${t3}`);
-        }
-    },
-    vd = (t3) => {
-        var e2, i2;
-        return null === (i2 = null === (e2 = yd()) || void 0 === e2 ? void 0 : e2.emulatorHosts) || void 0 === i2 ? void 0 : i2[t3];
-    },
-    bd = (t3) => {
-        const e2 = vd(t3);
-        if (!e2)
-            return;
-        const i2 = e2.lastIndexOf(":");
-        if (i2 <= 0 || i2 + 1 === e2.length)
-            throw new Error(`Invalid host ${e2} with no separate hostname and port!`);
-        const s2 = parseInt(e2.substring(i2 + 1), 10);
-        return "[" === e2[0] ? [e2.substring(1, i2 - 1), s2] : [e2.substring(0, i2), s2];
-    },
-    _d = () => {
-        var t3;
-        return null === (t3 = yd()) || void 0 === t3 ? void 0 : t3.config;
-    },
-    wd = (t3) => {
-        var e2;
-        return null === (e2 = yd()) || void 0 === e2 ? void 0 : e2[`_${t3}`];
-    };
-class Deferred {
-    constructor() {
-        this.reject = () => {}, this.resolve = () => {}, this.promise = new Promise((t3, e2) => {
-            this.resolve = t3, this.reject = e2;
-        });
-    }
-    wrapCallback(t3) {
-        return (e2, i2) => {
-            e2 ? this.reject(e2) : this.resolve(i2), "function" == typeof t3 && (this.promise.catch(() => {}), 1 === t3.length ? t3(e2) : t3(e2, i2));
-        };
-    }
-}
-
-function xd(t3, e2) {
-    if (t3.uid)
-        throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
-    const i2 = e2 || "demo-project",
-        s2 = t3.iat || 0,
-        n2 = t3.sub || t3.user_id;
-    if (!n2)
-        throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
-    const r2 = Object.assign({
-        iss: `https://securetoken.google.com/${i2}`,
-        aud: i2,
-        iat: s2,
-        exp: s2 + 3600,
-        auth_time: s2,
-        sub: n2,
-        user_id: n2,
-        firebase: {
-            sign_in_provider: "custom",
-            identities: {}
-        }
-    }, t3);
-    return [pd(JSON.stringify({
-        alg: "none",
-        type: "JWT"
-    })), pd(JSON.stringify(r2)), ""].join(".");
-}
-
-function kd() {
-    return "undefined" != typeof navigator && "string" == typeof navigator.userAgent ? navigator.userAgent : "";
-}
-class FirebaseError extends Error {
-    constructor(t3, e2, i2) {
-        super(e2), this.code = t3, this.customData = i2, this.name = "FirebaseError", Object.setPrototypeOf(this, FirebaseError.prototype), Error.captureStackTrace && Error.captureStackTrace(this, ErrorFactory.prototype.create);
-    }
-}
-class ErrorFactory {
-    constructor(t3, e2, i2) {
-        this.service = t3, this.serviceName = e2, this.errors = i2;
-    }
-    create(t3, ...e2) {
-        const i2 = e2[0] || {},
-            s2 = `${this.service}/${t3}`,
-            n2 = this.errors[t3],
-            r2 = n2 ? function(t4, e3) {
-                return t4.replace(Td, (t5, i3) => {
-                    const s3 = e3[i3];
-                    return null != s3 ? String(s3) : `<${i3}?>`;
-                });
-            }(n2, i2) : "Error",
-            o2 = `${this.serviceName}: ${r2} (${s2}).`;
-        return new FirebaseError(s2, o2, i2);
-    }
-}
-const Td = /\{\$([^}]+)}/g;
-
-function Sd(t3, e2) {
-    if (t3 === e2)
-        return true;
-    const i2 = Object.keys(t3),
-        s2 = Object.keys(e2);
-    for (const n2 of i2) {
-        if (!s2.includes(n2))
-            return false;
-        const i3 = t3[n2],
-            r2 = e2[n2];
-        if (Ed(i3) && Ed(r2)) {
-            if (!Sd(i3, r2))
-                return false;
-        } else if (i3 !== r2)
-            return false;
-    }
-    for (const t4 of s2)
-        if (!i2.includes(t4))
-            return false;
-    return true;
-}
-
-function Ed(t3) {
-    return null !== t3 && "object" == typeof t3;
-}
-
-function Cd(t3) {
-    const e2 = [];
-    for (const [i2, s2] of Object.entries(t3))
-        Array.isArray(s2) ? s2.forEach((t4) => {
-            e2.push(encodeURIComponent(i2) + "=" + encodeURIComponent(t4));
-        }) : e2.push(encodeURIComponent(i2) + "=" + encodeURIComponent(s2));
-    return e2.length ? "&" + e2.join("&") : "";
-}
-class ObserverProxy {
-    constructor(t3, e2) {
-        this.observers = [], this.unsubscribes = [], this.observerCount = 0, this.task = Promise.resolve(), this.finalized = false, this.onNoObservers = e2, this.task.then(() => {
-            t3(this);
-        }).catch((t4) => {
-            this.error(t4);
-        });
-    }
-    next(t3) {
-        this.forEachObserver((e2) => {
-            e2.next(t3);
-        });
-    }
-    error(t3) {
-        this.forEachObserver((e2) => {
-            e2.error(t3);
-        }), this.close(t3);
-    }
-    complete() {
-        this.forEachObserver((t3) => {
-            t3.complete();
-        }), this.close();
-    }
-    subscribe(t3, e2, i2) {
-        let s2;
-        if (void 0 === t3 && void 0 === e2 && void 0 === i2)
-            throw new Error("Missing Observer.");
-        s2 = function(t4, e3) {
-            if ("object" != typeof t4 || null === t4)
-                return false;
-            for (const i3 of e3)
-                if (i3 in t4 && "function" == typeof t4[i3])
-                    return true;
-            return false;
-        }(t3, ["next", "error", "complete"]) ? t3 : {
-            next: t3,
-            error: e2,
-            complete: i2
-        }, void 0 === s2.next && (s2.next = Id), void 0 === s2.error && (s2.error = Id), void 0 === s2.complete && (s2.complete = Id);
-        const n2 = this.unsubscribeOne.bind(this, this.observers.length);
-        return this.finalized && this.task.then(() => {
-            try {
-                this.finalError ? s2.error(this.finalError) : s2.complete();
-            } catch (t4) {}
-        }), this.observers.push(s2), n2;
-    }
-    unsubscribeOne(t3) {
-        void 0 !== this.observers && void 0 !== this.observers[t3] && (delete this.observers[t3], this.observerCount -= 1, 0 === this.observerCount && void 0 !== this.onNoObservers && this.onNoObservers(this));
-    }
-    forEachObserver(t3) {
-        if (!this.finalized)
-            for (let e2 = 0; e2 < this.observers.length; e2++)
-                this.sendOne(e2, t3);
-    }
-    sendOne(t3, e2) {
-        this.task.then(() => {
-            if (void 0 !== this.observers && void 0 !== this.observers[t3])
-                try {
-                    e2(this.observers[t3]);
-                } catch (t4) {
-                    "undefined" != typeof console && console.error && console.error(t4);
-                }
-        });
-    }
-    close(t3) {
-        this.finalized || (this.finalized = true, void 0 !== t3 && (this.finalError = t3), this.task.then(() => {
-            this.observers = void 0, this.onNoObservers = void 0;
-        }));
-    }
-}
-
-function Id() {}
-
-function Md(t3) {
-    return t3 && t3._delegate ? t3._delegate : t3;
-}
-class Component {
-    constructor(t3, e2, i2) {
-        this.name = t3, this.instanceFactory = e2, this.type = i2, this.multipleInstances = false, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null;
-    }
-    setInstantiationMode(t3) {
-        return this.instantiationMode = t3, this;
-    }
-    setMultipleInstances(t3) {
-        return this.multipleInstances = t3, this;
-    }
-    setServiceProps(t3) {
-        return this.serviceProps = t3, this;
-    }
-    setInstanceCreatedCallback(t3) {
-        return this.onInstanceCreated = t3, this;
-    }
-}
-const Pd = "[DEFAULT]";
-class Provider {
-    constructor(t3, e2) {
-        this.name = t3, this.container = e2, this.component = null, this.instances = /* @__PURE__ */ new Map(), this.instancesDeferred = /* @__PURE__ */ new Map(), this.instancesOptions = /* @__PURE__ */ new Map(), this.onInitCallbacks = /* @__PURE__ */ new Map();
-    }
-    get(t3) {
-        const e2 = this.normalizeInstanceIdentifier(t3);
-        if (!this.instancesDeferred.has(e2)) {
-            const t4 = new Deferred();
-            if (this.instancesDeferred.set(e2, t4), this.isInitialized(e2) || this.shouldAutoInitialize())
-                try {
-                    const i2 = this.getOrInitializeService({
-                        instanceIdentifier: e2
-                    });
-                    i2 && t4.resolve(i2);
-                } catch (t5) {}
-        }
-        return this.instancesDeferred.get(e2).promise;
-    }
-    getImmediate(t3) {
-        var e2;
-        const i2 = this.normalizeInstanceIdentifier(null == t3 ? void 0 : t3.identifier),
-            s2 = null !== (e2 = null == t3 ? void 0 : t3.optional) && void 0 !== e2 && e2;
-        if (!this.isInitialized(i2) && !this.shouldAutoInitialize()) {
-            if (s2)
-                return null;
-            throw Error(`Service ${this.name} is not available`);
-        }
-        try {
-            return this.getOrInitializeService({
-                instanceIdentifier: i2
-            });
-        } catch (t4) {
-            if (s2)
-                return null;
-            throw t4;
-        }
-    }
-    getComponent() {
-        return this.component;
-    }
-    setComponent(t3) {
-        if (t3.name !== this.name)
-            throw Error(`Mismatching Component ${t3.name} for Provider ${this.name}.`);
-        if (this.component)
-            throw Error(`Component for ${this.name} has already been provided`);
-        if (this.component = t3, this.shouldAutoInitialize()) {
-            if (function(t4) {
-                    return "EAGER" === t4.instantiationMode;
-                }(t3))
-                try {
-                    this.getOrInitializeService({
-                        instanceIdentifier: Pd
-                    });
-                } catch (t4) {}
-            for (const [t4, e2] of this.instancesDeferred.entries()) {
-                const i2 = this.normalizeInstanceIdentifier(t4);
-                try {
-                    const t5 = this.getOrInitializeService({
-                        instanceIdentifier: i2
-                    });
-                    e2.resolve(t5);
-                } catch (t5) {}
-            }
-        }
-    }
-    clearInstance(t3 = Pd) {
-        this.instancesDeferred.delete(t3), this.instancesOptions.delete(t3), this.instances.delete(t3);
-    }
-    async delete() {
-        const t3 = Array.from(this.instances.values());
-        await Promise.all([...t3.filter((t4) => "INTERNAL" in t4).map((t4) => t4.INTERNAL.delete()), ...t3.filter((t4) => "_delete" in t4).map((t4) => t4._delete())]);
-    }
-    isComponentSet() {
-        return null != this.component;
-    }
-    isInitialized(t3 = Pd) {
-        return this.instances.has(t3);
-    }
-    getOptions(t3 = Pd) {
-        return this.instancesOptions.get(t3) || {};
-    }
-    initialize(t3 = {}) {
-        const {
-            options: e2 = {}
-        } = t3, i2 = this.normalizeInstanceIdentifier(t3.instanceIdentifier);
-        if (this.isInitialized(i2))
-            throw Error(`${this.name}(${i2}) has already been initialized`);
-        if (!this.isComponentSet())
-            throw Error(`Component ${this.name} has not been registered yet`);
-        const s2 = this.getOrInitializeService({
-            instanceIdentifier: i2,
-            options: e2
-        });
-        for (const [t4, e3] of this.instancesDeferred.entries()) {
-            i2 === this.normalizeInstanceIdentifier(t4) && e3.resolve(s2);
-        }
-        return s2;
-    }
-    onInit(t3, e2) {
-        var i2;
-        const s2 = this.normalizeInstanceIdentifier(e2),
-            n2 = null !== (i2 = this.onInitCallbacks.get(s2)) && void 0 !== i2 ? i2 : /* @__PURE__ */ new Set();
-        n2.add(t3), this.onInitCallbacks.set(s2, n2);
-        const r2 = this.instances.get(s2);
-        return r2 && t3(r2, s2), () => {
-            n2.delete(t3);
-        };
-    }
-    invokeOnInitCallbacks(t3, e2) {
-        const i2 = this.onInitCallbacks.get(e2);
-        if (i2)
-            for (const s2 of i2)
-                try {
-                    s2(t3, e2);
-                } catch (t4) {}
-    }
-    getOrInitializeService({
-        instanceIdentifier: t3,
-        options: e2 = {}
-    }) {
-        let i2 = this.instances.get(t3);
-        if (!i2 && this.component && (i2 = this.component.instanceFactory(this.container, {
-                instanceIdentifier: (s2 = t3, s2 === Pd ? void 0 : s2),
-                options: e2
-            }), this.instances.set(t3, i2), this.instancesOptions.set(t3, e2), this.invokeOnInitCallbacks(i2, t3), this.component.onInstanceCreated))
-            try {
-                this.component.onInstanceCreated(this.container, t3, i2);
-            } catch (t4) {}
-        var s2;
-        return i2 || null;
-    }
-    normalizeInstanceIdentifier(t3 = Pd) {
-        return this.component ? this.component.multipleInstances ? t3 : Pd : t3;
-    }
-    shouldAutoInitialize() {
-        return !!this.component && "EXPLICIT" !== this.component.instantiationMode;
-    }
-}
-class ComponentContainer {
-    constructor(t3) {
-        this.name = t3, this.providers = /* @__PURE__ */ new Map();
-    }
-    addComponent(t3) {
-        const e2 = this.getProvider(t3.name);
-        if (e2.isComponentSet())
-            throw new Error(`Component ${t3.name} has already been registered with ${this.name}`);
-        e2.setComponent(t3);
-    }
-    addOrOverwriteComponent(t3) {
-        this.getProvider(t3.name).isComponentSet() && this.providers.delete(t3.name), this.addComponent(t3);
-    }
-    getProvider(t3) {
-        if (this.providers.has(t3))
-            return this.providers.get(t3);
-        const e2 = new Provider(t3, this);
-        return this.providers.set(t3, e2), e2;
-    }
-    getProviders() {
-        return Array.from(this.providers.values());
-    }
-}
-var Rd;
-! function(t3) {
-    t3[t3.DEBUG = 0] = "DEBUG", t3[t3.VERBOSE = 1] = "VERBOSE", t3[t3.INFO = 2] = "INFO", t3[t3.WARN = 3] = "WARN", t3[t3.ERROR = 4] = "ERROR", t3[t3.SILENT = 5] = "SILENT";
-}(Rd || (Rd = {}));
-const Ad = {
-        debug: Rd.DEBUG,
-        verbose: Rd.VERBOSE,
-        info: Rd.INFO,
-        warn: Rd.WARN,
-        error: Rd.ERROR,
-        silent: Rd.SILENT
-    },
-    Dd = Rd.INFO,
-    Ld = {
-        [Rd.DEBUG]: "log",
-        [Rd.VERBOSE]: "log",
-        [Rd.INFO]: "info",
-        [Rd.WARN]: "warn",
-        [Rd.ERROR]: "error"
-    },
-    Od = (t3, e2, ...i2) => {
-        if (e2 < t3.logLevel)
-            return;
-        const s2 = ( /* @__PURE__ */ new Date()).toISOString(),
-            n2 = Ld[e2];
-        if (!n2)
-            throw new Error(`Attempted to log a message with an invalid logType (value: ${e2})`);
-        console[n2](`[${s2}]  ${t3.name}:`, ...i2);
-    };
-class Logger {
-    constructor(t3) {
-        this.name = t3, this._logLevel = Dd, this._logHandler = Od, this._userLogHandler = null;
-    }
-    get logLevel() {
-        return this._logLevel;
-    }
-    set logLevel(t3) {
-        if (!(t3 in Rd))
-            throw new TypeError(`Invalid value "${t3}" assigned to \`logLevel\``);
-        this._logLevel = t3;
-    }
-    setLogLevel(t3) {
-        this._logLevel = "string" == typeof t3 ? Ad[t3] : t3;
-    }
-    get logHandler() {
-        return this._logHandler;
-    }
-    set logHandler(t3) {
-        if ("function" != typeof t3)
-            throw new TypeError("Value assigned to `logHandler` must be a function");
-        this._logHandler = t3;
-    }
-    get userLogHandler() {
-        return this._userLogHandler;
-    }
-    set userLogHandler(t3) {
-        this._userLogHandler = t3;
-    }
-    debug(...t3) {
-        this._userLogHandler && this._userLogHandler(this, Rd.DEBUG, ...t3), this._logHandler(this, Rd.DEBUG, ...t3);
-    }
-    log(...t3) {
-        this._userLogHandler && this._userLogHandler(this, Rd.VERBOSE, ...t3), this._logHandler(this, Rd.VERBOSE, ...t3);
-    }
-    info(...t3) {
-        this._userLogHandler && this._userLogHandler(this, Rd.INFO, ...t3), this._logHandler(this, Rd.INFO, ...t3);
-    }
-    warn(...t3) {
-        this._userLogHandler && this._userLogHandler(this, Rd.WARN, ...t3), this._logHandler(this, Rd.WARN, ...t3);
-    }
-    error(...t3) {
-        this._userLogHandler && this._userLogHandler(this, Rd.ERROR, ...t3), this._logHandler(this, Rd.ERROR, ...t3);
-    }
-}
-const Fd = (t3, e2) => e2.some((e3) => t3 instanceof e3);
-let Nd, $d;
-const Vd = /* @__PURE__ */ new WeakMap(),
-    zd = /* @__PURE__ */ new WeakMap(),
-    Bd = /* @__PURE__ */ new WeakMap(),
-    Ud = /* @__PURE__ */ new WeakMap(),
-    jd = /* @__PURE__ */ new WeakMap();
-let Hd = {
-    get(t3, e2, i2) {
-        if (t3 instanceof IDBTransaction) {
-            if ("done" === e2)
-                return zd.get(t3);
-            if ("objectStoreNames" === e2)
-                return t3.objectStoreNames || Bd.get(t3);
-            if ("store" === e2)
-                return i2.objectStoreNames[1] ? void 0 : i2.objectStore(i2.objectStoreNames[0]);
-        }
-        return Kd(t3[e2]);
-    },
-    set: (t3, e2, i2) => (t3[e2] = i2, true),
-    has: (t3, e2) => t3 instanceof IDBTransaction && ("done" === e2 || "store" === e2) || e2 in t3
-};
-
-function Wd(t3) {
-    return t3 !== IDBDatabase.prototype.transaction || "objectStoreNames" in IDBTransaction.prototype ? ($d || ($d = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey])).includes(t3) ? function(...e2) {
-        return t3.apply(Gd(this), e2), Kd(Vd.get(this));
-    } : function(...e2) {
-        return Kd(t3.apply(Gd(this), e2));
-    } : function(e2, ...i2) {
-        const s2 = t3.call(Gd(this), e2, ...i2);
-        return Bd.set(s2, e2.sort ? e2.sort() : [e2]), Kd(s2);
-    };
-}
-
-function qd(t3) {
-    return "function" == typeof t3 ? Wd(t3) : (t3 instanceof IDBTransaction && function(t4) {
-        if (zd.has(t4))
-            return;
-        const e2 = new Promise((e3, i2) => {
-            const s2 = () => {
-                    t4.removeEventListener("complete", n2), t4.removeEventListener("error", r2), t4.removeEventListener("abort", r2);
-                },
-                n2 = () => {
-                    e3(), s2();
-                },
-                r2 = () => {
-                    i2(t4.error || new DOMException("AbortError", "AbortError")), s2();
-                };
-            t4.addEventListener("complete", n2), t4.addEventListener("error", r2), t4.addEventListener("abort", r2);
-        });
-        zd.set(t4, e2);
-    }(t3), Fd(t3, Nd || (Nd = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction])) ? new Proxy(t3, Hd) : t3);
-}
-
-function Kd(t3) {
-    if (t3 instanceof IDBRequest)
-        return function(t4) {
-            const e3 = new Promise((e4, i2) => {
-                const s2 = () => {
-                        t4.removeEventListener("success", n2), t4.removeEventListener("error", r2);
-                    },
-                    n2 = () => {
-                        e4(Kd(t4.result)), s2();
-                    },
-                    r2 = () => {
-                        i2(t4.error), s2();
-                    };
-                t4.addEventListener("success", n2), t4.addEventListener("error", r2);
-            });
-            return e3.then((e4) => {
-                e4 instanceof IDBCursor && Vd.set(e4, t4);
-            }).catch(() => {}), jd.set(e3, t4), e3;
-        }(t3);
-    if (Ud.has(t3))
-        return Ud.get(t3);
-    const e2 = qd(t3);
-    return e2 !== t3 && (Ud.set(t3, e2), jd.set(e2, t3)), e2;
-}
-const Gd = (t3) => jd.get(t3);
-const Yd = ["get", "getKey", "getAll", "getAllKeys", "count"],
-    Qd = ["put", "add", "delete", "clear"],
-    Xd = /* @__PURE__ */ new Map();
-
-function Jd(t3, e2) {
-    if (!(t3 instanceof IDBDatabase) || e2 in t3 || "string" != typeof e2)
-        return;
-    if (Xd.get(e2))
-        return Xd.get(e2);
-    const i2 = e2.replace(/FromIndex$/, ""),
-        s2 = e2 !== i2,
-        n2 = Qd.includes(i2);
-    if (!(i2 in (s2 ? IDBIndex : IDBObjectStore).prototype) || !n2 && !Yd.includes(i2))
-        return;
-    const r2 = async function(t4, ...e3) {
-        const r3 = this.transaction(t4, n2 ? "readwrite" : "readonly");
-        let o2 = r3.store;
-        return s2 && (o2 = o2.index(e3.shift())), (await Promise.all([o2[i2](...e3), n2 && r3.done]))[0];
-    };
-    return Xd.set(e2, r2), r2;
-}! function(t3) {
-    Hd = t3(Hd);
-}((t3) => ({
-    ...t3,
-    get: (e2, i2, s2) => Jd(e2, i2) || t3.get(e2, i2, s2),
-    has: (e2, i2) => !!Jd(e2, i2) || t3.has(e2, i2)
-}));
-class PlatformLoggerServiceImpl {
-    constructor(t3) {
-        this.container = t3;
-    }
-    getPlatformInfoString() {
-        return this.container.getProviders().map((t3) => {
-            if (function(t4) {
-                    const e2 = t4.getComponent();
-                    return "VERSION" === (null == e2 ? void 0 : e2.type);
-                }(t3)) {
-                const e2 = t3.getImmediate();
-                return `${e2.library}/${e2.version}`;
-            }
-            return null;
-        }).filter((t3) => t3).join(" ");
-    }
-}
-const Zd = "@firebase/app",
-    tf = "0.9.14",
-    ef = new Logger("@firebase/app"),
-    sf = "[DEFAULT]",
-    nf = {
-        [Zd]: "fire-core",
-        "@firebase/app-compat": "fire-core-compat",
-        "@firebase/analytics": "fire-analytics",
-        "@firebase/analytics-compat": "fire-analytics-compat",
-        "@firebase/app-check": "fire-app-check",
-        "@firebase/app-check-compat": "fire-app-check-compat",
-        "@firebase/auth": "fire-auth",
-        "@firebase/auth-compat": "fire-auth-compat",
-        "@firebase/database": "fire-rtdb",
-        "@firebase/database-compat": "fire-rtdb-compat",
-        "@firebase/functions": "fire-fn",
-        "@firebase/functions-compat": "fire-fn-compat",
-        "@firebase/installations": "fire-iid",
-        "@firebase/installations-compat": "fire-iid-compat",
-        "@firebase/messaging": "fire-fcm",
-        "@firebase/messaging-compat": "fire-fcm-compat",
-        "@firebase/performance": "fire-perf",
-        "@firebase/performance-compat": "fire-perf-compat",
-        "@firebase/remote-config": "fire-rc",
-        "@firebase/remote-config-compat": "fire-rc-compat",
-        "@firebase/storage": "fire-gcs",
-        "@firebase/storage-compat": "fire-gcs-compat",
-        "@firebase/firestore": "fire-fst",
-        "@firebase/firestore-compat": "fire-fst-compat",
-        "fire-js": "fire-js",
-        firebase: "fire-js-all"
-    },
-    rf = /* @__PURE__ */ new Map(),
-    of = /* @__PURE__ */ new Map();
-
-function af(t3, e2) {
-    try {
-        t3.container.addComponent(e2);
-    } catch (i2) {
-        ef.debug(`Component ${e2.name} failed to register with FirebaseApp ${t3.name}`, i2);
-    }
-}
-
-function lf(t3) {
-    const e2 = t3.name;
-    if (of.has(e2))
-        return ef.debug(`There were multiple attempts to register component ${e2}.`), false;
-    of.set(e2, t3);
-    for (const e3 of rf.values())
-        af(e3, t3);
-    return true;
-}
-
-function hf(t3, e2) {
-    const i2 = t3.container.getProvider("heartbeat").getImmediate({
-        optional: true
-    });
-    return i2 && i2.triggerHeartbeat(), t3.container.getProvider(e2);
-}
-const cf = new ErrorFactory("app", "Firebase", {
-    "no-app": "No Firebase App '{$appName}' has been created - call initializeApp() first",
-    "bad-app-name": "Illegal App name: '{$appName}",
-    "duplicate-app": "Firebase App named '{$appName}' already exists with different options or config",
-    "app-deleted": "Firebase App named '{$appName}' already deleted",
-    "no-options": "Need to provide options, when not being deployed to hosting via source.",
-    "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance.",
-    "invalid-log-argument": "First argument to `onLog` must be null or a function.",
-    "idb-open": "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
-    "idb-get": "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
-    "idb-set": "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
-    "idb-delete": "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}."
-});
-class FirebaseAppImpl {
-    constructor(t3, e2, i2) {
-        this._isDeleted = false, this._options = Object.assign({}, t3), this._config = Object.assign({}, e2), this._name = e2.name, this._automaticDataCollectionEnabled = e2.automaticDataCollectionEnabled, this._container = i2, this.container.addComponent(new Component("app", () => this, "PUBLIC"));
-    }
-    get automaticDataCollectionEnabled() {
-        return this.checkDestroyed(), this._automaticDataCollectionEnabled;
-    }
-    set automaticDataCollectionEnabled(t3) {
-        this.checkDestroyed(), this._automaticDataCollectionEnabled = t3;
-    }
-    get name() {
-        return this.checkDestroyed(), this._name;
-    }
-    get options() {
-        return this.checkDestroyed(), this._options;
-    }
-    get config() {
-        return this.checkDestroyed(), this._config;
-    }
-    get container() {
-        return this._container;
-    }
-    get isDeleted() {
-        return this._isDeleted;
-    }
-    set isDeleted(t3) {
-        this._isDeleted = t3;
-    }
-    checkDestroyed() {
-        if (this.isDeleted)
-            throw cf.create("app-deleted", {
-                appName: this._name
-            });
-    }
-}
-const uf = "10.0.0";
-
-function df(t3, e2 = {}) {
-    let i2 = t3;
-    if ("object" != typeof e2) {
-        e2 = {
-            name: e2
-        };
-    }
-    const s2 = Object.assign({
-            name: sf,
-            automaticDataCollectionEnabled: false
-        }, e2),
-        n2 = s2.name;
-    if ("string" != typeof n2 || !n2)
-        throw cf.create("bad-app-name", {
-            appName: String(n2)
-        });
-    if (i2 || (i2 = _d()), !i2)
-        throw cf.create("no-options");
-    const r2 = rf.get(n2);
-    if (r2) {
-        if (Sd(i2, r2.options) && Sd(s2, r2.config))
-            return r2;
-        throw cf.create("duplicate-app", {
-            appName: n2
-        });
-    }
-    const o2 = new ComponentContainer(n2);
-    for (const t4 of of.values())
-        o2.addComponent(t4);
-    const a2 = new FirebaseAppImpl(i2, s2, o2);
-    return rf.set(n2, a2), a2;
-}
-
-function ff(t3 = sf) {
-    const e2 = rf.get(t3);
-    if (!e2 && t3 === sf && _d())
-        return df();
-    if (!e2)
-        throw cf.create("no-app", {
-            appName: t3
-        });
-    return e2;
-}
-
-function pf(t3, e2, i2) {
-    var s2;
-    let n2 = null !== (s2 = nf[t3]) && void 0 !== s2 ? s2 : t3;
-    i2 && (n2 += `-${i2}`);
-    const r2 = n2.match(/\s|\//),
-        o2 = e2.match(/\s|\//);
-    if (r2 || o2) {
-        const t4 = [`Unable to register library "${n2}" with version "${e2}":`];
-        return r2 && t4.push(`library name "${n2}" contains illegal characters (whitespace or "/")`), r2 && o2 && t4.push("and"), o2 && t4.push(`version name "${e2}" contains illegal characters (whitespace or "/")`), void ef.warn(t4.join(" "));
-    }
-    lf(new Component(`${n2}-version`, () => ({
-        library: n2,
-        version: e2
-    }), "VERSION"));
-}
-const mf = "firebase-heartbeat-database",
-    gf = 1,
-    yf = "firebase-heartbeat-store";
-let vf = null;
-
-function bf() {
-    return vf || (vf = function(t3, e2, {
-        blocked: i2,
-        upgrade: s2,
-        blocking: n2,
-        terminated: r2
-    } = {}) {
-        const o2 = indexedDB.open(t3, e2),
-            a2 = Kd(o2);
-        return s2 && o2.addEventListener("upgradeneeded", (t4) => {
-            s2(Kd(o2.result), t4.oldVersion, t4.newVersion, Kd(o2.transaction), t4);
-        }), i2 && o2.addEventListener("blocked", (t4) => i2(t4.oldVersion, t4.newVersion, t4)), a2.then((t4) => {
-            r2 && t4.addEventListener("close", () => r2()), n2 && t4.addEventListener("versionchange", (t5) => n2(t5.oldVersion, t5.newVersion, t5));
-        }).catch(() => {}), a2;
-    }(mf, gf, {
-        upgrade: (t3, e2) => {
-            if (0 === e2)
-                t3.createObjectStore(yf);
-        }
-    }).catch((t3) => {
-        throw cf.create("idb-open", {
-            originalErrorMessage: t3.message
-        });
-    })), vf;
-}
-async function _f(t3, e2) {
-    try {
-        const i2 = (await bf()).transaction(yf, "readwrite"),
-            s2 = i2.objectStore(yf);
-        await s2.put(e2, wf(t3)), await i2.done;
-    } catch (t4) {
-        if (t4 instanceof FirebaseError)
-            ef.warn(t4.message);
-        else {
-            const e3 = cf.create("idb-set", {
-                originalErrorMessage: null == t4 ? void 0 : t4.message
-            });
-            ef.warn(e3.message);
-        }
-    }
-}
-
-function wf(t3) {
-    return `${t3.name}!${t3.options.appId}`;
-}
-class HeartbeatServiceImpl {
-    constructor(t3) {
-        this.container = t3, this._heartbeatsCache = null;
-        const e2 = this.container.getProvider("app").getImmediate();
-        this._storage = new HeartbeatStorageImpl(e2), this._heartbeatsCachePromise = this._storage.read().then((t4) => (this._heartbeatsCache = t4, t4));
-    }
-    async triggerHeartbeat() {
-        const t3 = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(),
-            e2 = xf();
-        if (null === this._heartbeatsCache && (this._heartbeatsCache = await this._heartbeatsCachePromise), this._heartbeatsCache.lastSentHeartbeatDate !== e2 && !this._heartbeatsCache.heartbeats.some((t4) => t4.date === e2))
-            return this._heartbeatsCache.heartbeats.push({
-                date: e2,
-                agent: t3
-            }), this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((t4) => {
-                const e3 = new Date(t4.date).valueOf();
-                return Date.now() - e3 <= 2592e6;
-            }), this._storage.overwrite(this._heartbeatsCache);
-    }
-    async getHeartbeatsHeader() {
-        if (null === this._heartbeatsCache && await this._heartbeatsCachePromise, null === this._heartbeatsCache || 0 === this._heartbeatsCache.heartbeats.length)
-            return "";
-        const t3 = xf(),
-            {
-                heartbeatsToSend: e2,
-                unsentEntries: i2
-            } = function(t4, e3 = 1024) {
-                const i3 = [];
-                let s3 = t4.slice();
-                for (const n2 of t4) {
-                    const t5 = i3.find((t6) => t6.agent === n2.agent);
-                    if (t5) {
-                        if (t5.dates.push(n2.date), kf(i3) > e3) {
-                            t5.dates.pop();
-                            break;
-                        }
-                    } else if (i3.push({
-                            agent: n2.agent,
-                            dates: [n2.date]
-                        }), kf(i3) > e3) {
-                        i3.pop();
-                        break;
-                    }
-                    s3 = s3.slice(1);
-                }
-                return {
-                    heartbeatsToSend: i3,
-                    unsentEntries: s3
-                };
-            }(this._heartbeatsCache.heartbeats),
-            s2 = pd(JSON.stringify({
-                version: 2,
-                heartbeats: e2
-            }));
-        return this._heartbeatsCache.lastSentHeartbeatDate = t3, i2.length > 0 ? (this._heartbeatsCache.heartbeats = i2, await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [], this._storage.overwrite(this._heartbeatsCache)), s2;
-    }
-}
-
-function xf() {
-    return ( /* @__PURE__ */ new Date()).toISOString().substring(0, 10);
-}
-class HeartbeatStorageImpl {
-    constructor(t3) {
-        this.app = t3, this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();
-    }
-    async runIndexedDBEnvironmentCheck() {
-        return !! function() {
-            try {
-                return "object" == typeof indexedDB;
-            } catch (t3) {
-                return false;
-            }
-        }() && new Promise((t3, e2) => {
-            try {
-                let i2 = true;
-                const s2 = "validate-browser-context-for-indexeddb-analytics-module",
-                    n2 = self.indexedDB.open(s2);
-                n2.onsuccess = () => {
-                    n2.result.close(), i2 || self.indexedDB.deleteDatabase(s2), t3(true);
-                }, n2.onupgradeneeded = () => {
-                    i2 = false;
-                }, n2.onerror = () => {
-                    var t4;
-                    e2((null === (t4 = n2.error) || void 0 === t4 ? void 0 : t4.message) || "");
-                };
-            } catch (t4) {
-                e2(t4);
-            }
-        }).then(() => true).catch(() => false);
-    }
-    async read() {
-        if (await this._canUseIndexedDBPromise) {
-            const t3 = await async function(t4) {
-                try {
-                    const e2 = await bf();
-                    return await e2.transaction(yf).objectStore(yf).get(wf(t4));
-                } catch (t5) {
-                    if (t5 instanceof FirebaseError)
-                        ef.warn(t5.message);
-                    else {
-                        const e2 = cf.create("idb-get", {
-                            originalErrorMessage: null == t5 ? void 0 : t5.message
-                        });
-                        ef.warn(e2.message);
-                    }
-                }
-            }(this.app);
-            return t3 || {
-                heartbeats: []
-            };
-        }
-        return {
-            heartbeats: []
-        };
-    }
-    async overwrite(t3) {
-        var e2;
-        if (await this._canUseIndexedDBPromise) {
-            const i2 = await this.read();
-            return _f(this.app, {
-                lastSentHeartbeatDate: null !== (e2 = t3.lastSentHeartbeatDate) && void 0 !== e2 ? e2 : i2.lastSentHeartbeatDate,
-                heartbeats: t3.heartbeats
-            });
-        }
-    }
-    async add(t3) {
-        var e2;
-        if (await this._canUseIndexedDBPromise) {
-            const i2 = await this.read();
-            return _f(this.app, {
-                lastSentHeartbeatDate: null !== (e2 = t3.lastSentHeartbeatDate) && void 0 !== e2 ? e2 : i2.lastSentHeartbeatDate,
-                heartbeats: [...i2.heartbeats, ...t3.heartbeats]
-            });
-        }
-    }
-}
-
-function kf(t3) {
-    return pd(JSON.stringify({
-        version: 2,
-        heartbeats: t3
-    })).length;
-}
-var Tf;
-Tf = "", lf(new Component("platform-logger", (t3) => new PlatformLoggerServiceImpl(t3), "PRIVATE")), lf(new Component("heartbeat", (t3) => new HeartbeatServiceImpl(t3), "PRIVATE")), pf(Zd, tf, Tf), pf(Zd, tf, "esm2017"), pf("fire-js", "");
-var Sf, Ef = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {},
-    Cf = Cf || {},
-    If = Ef || self;
-
-function Mf(t3) {
-    var e2 = typeof t3;
-    return "array" == (e2 = "object" != e2 ? e2 : t3 ? Array.isArray(t3) ? "array" : e2 : "null") || "object" == e2 && "number" == typeof t3.length;
-}
-
-function Pf(t3) {
-    var e2 = typeof t3;
-    return "object" == e2 && null != t3 || "function" == e2;
-}
-var Rf = "closure_uid_" + (1e9 * Math.random() >>> 0),
-    Af = 0;
-
-function Df(t3, e2, i2) {
-    return t3.call.apply(t3.bind, arguments);
-}
-
-function Lf(t3, e2, i2) {
-    if (!t3)
-        throw Error();
-    if (2 < arguments.length) {
-        var s2 = Array.prototype.slice.call(arguments, 2);
-        return function() {
-            var i3 = Array.prototype.slice.call(arguments);
-            return Array.prototype.unshift.apply(i3, s2), t3.apply(e2, i3);
-        };
-    }
-    return function() {
-        return t3.apply(e2, arguments);
-    };
-}
-
-function Of(t3, e2, i2) {
-    return (Of = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? Df : Lf).apply(null, arguments);
-}
-
-function Ff(t3, e2) {
-    var i2 = Array.prototype.slice.call(arguments, 1);
-    return function() {
-        var e3 = i2.slice();
-        return e3.push.apply(e3, arguments), t3.apply(this, e3);
-    };
-}
-
-function Nf(t3, e2) {
-    function i2() {}
-    i2.prototype = e2.prototype, t3.$ = e2.prototype, t3.prototype = new i2(), t3.prototype.constructor = t3, t3.ac = function(t4, i3, s2) {
-        for (var n2 = Array(arguments.length - 2), r2 = 2; r2 < arguments.length; r2++)
-            n2[r2 - 2] = arguments[r2];
-        return e2.prototype[i3].apply(t4, n2);
-    };
-}
-
-function $f() {
-    this.s = this.s, this.o = this.o;
-}
-$f.prototype.s = false, $f.prototype.sa = function() {
-    !this.s && (this.s = true, this.N(), 0);
-}, $f.prototype.N = function() {
-    if (this.o)
-        for (; this.o.length;)
-            this.o.shift()();
-};
-const Vf = Array.prototype.indexOf ? function(t3, e2) {
-    return Array.prototype.indexOf.call(t3, e2, void 0);
-} : function(t3, e2) {
-    if ("string" == typeof t3)
-        return "string" != typeof e2 || 1 != e2.length ? -1 : t3.indexOf(e2, 0);
-    for (let i2 = 0; i2 < t3.length; i2++)
-        if (i2 in t3 && t3[i2] === e2)
-            return i2;
-    return -1;
-};
-
-function zf(t3) {
-    const e2 = t3.length;
-    if (0 < e2) {
-        const i2 = Array(e2);
-        for (let s2 = 0; s2 < e2; s2++)
-            i2[s2] = t3[s2];
-        return i2;
-    }
-    return [];
-}
-
-function Bf(t3, e2) {
-    for (let e3 = 1; e3 < arguments.length; e3++) {
-        const i2 = arguments[e3];
-        if (Mf(i2)) {
-            const e4 = t3.length || 0,
-                s2 = i2.length || 0;
-            t3.length = e4 + s2;
-            for (let n2 = 0; n2 < s2; n2++)
-                t3[e4 + n2] = i2[n2];
-        } else
-            t3.push(i2);
-    }
-}
-
-function Uf(t3, e2) {
-    this.type = t3, this.g = this.target = e2, this.defaultPrevented = false;
-}
-Uf.prototype.h = function() {
-    this.defaultPrevented = true;
-};
-var jf = function() {
-    if (!If.addEventListener || !Object.defineProperty)
-        return false;
-    var t3 = false,
-        e2 = Object.defineProperty({}, "passive", {
-            get: function() {
-                t3 = true;
-            }
-        });
-    try {
-        If.addEventListener("test", () => {}, e2), If.removeEventListener("test", () => {}, e2);
-    } catch (t4) {}
-    return t3;
-}();
-
-function Hf(t3) {
-    return /^[\s\xa0]*$/.test(t3);
-}
-
-function Wf() {
-    var t3 = If.navigator;
-    return t3 && (t3 = t3.userAgent) ? t3 : "";
-}
-
-function qf(t3) {
-    return -1 != Wf().indexOf(t3);
-}
-
-function Kf(t3) {
-    return Kf[" "](t3), t3;
-}
-Kf[" "] = function() {};
-var Gf, Yf, Qf = qf("Opera"),
-    Xf = qf("Trident") || qf("MSIE"),
-    Jf = qf("Edge"),
-    Zf = Jf || Xf,
-    tp = qf("Gecko") && !(-1 != Wf().toLowerCase().indexOf("webkit") && !qf("Edge")) && !(qf("Trident") || qf("MSIE")) && !qf("Edge"),
-    ep = -1 != Wf().toLowerCase().indexOf("webkit") && !qf("Edge");
-
-function ip() {
-    var t3 = If.document;
-    return t3 ? t3.documentMode : void 0;
-}
-t: {
-    var sp = "",
-        np = function() {
-            var t3 = Wf();
-            return tp ? /rv:([^\);]+)(\)|;)/.exec(t3) : Jf ? /Edge\/([\d\.]+)/.exec(t3) : Xf ? /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(t3) : ep ? /WebKit\/(\S+)/.exec(t3) : Qf ? /(?:Version)[ \/]?(\S+)/.exec(t3) : void 0;
-        }();
-    if (np && (sp = np ? np[1] : ""), Xf) {
-        var rp = ip();
-        if (null != rp && rp > parseFloat(sp)) {
-            Gf = String(rp);
-            break t;
-        }
-    }
-    Gf = sp;
-}
-if (If.document && Xf) {
-    var op = ip();
-    Yf = op || (parseInt(Gf, 10) || void 0);
-} else
-    Yf = void 0;
-var ap = Yf;
-
-function lp(t3, e2) {
-    if (Uf.call(this, t3 ? t3.type : ""), this.relatedTarget = this.g = this.target = null, this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0, this.key = "", this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = false, this.state = null, this.pointerId = 0, this.pointerType = "", this.i = null, t3) {
-        var i2 = this.type = t3.type,
-            s2 = t3.changedTouches && t3.changedTouches.length ? t3.changedTouches[0] : null;
-        if (this.target = t3.target || t3.srcElement, this.g = e2, e2 = t3.relatedTarget) {
-            if (tp) {
-                t: {
-                    try {
-                        Kf(e2.nodeName);
-                        var n2 = true;
-                        break t;
-                    } catch (t4) {}
-                    n2 = false;
-                }
-                n2 || (e2 = null);
-            }
-        } else
-            "mouseover" == i2 ? e2 = t3.fromElement : "mouseout" == i2 && (e2 = t3.toElement);
-        this.relatedTarget = e2, s2 ? (this.clientX = void 0 !== s2.clientX ? s2.clientX : s2.pageX, this.clientY = void 0 !== s2.clientY ? s2.clientY : s2.pageY, this.screenX = s2.screenX || 0, this.screenY = s2.screenY || 0) : (this.clientX = void 0 !== t3.clientX ? t3.clientX : t3.pageX, this.clientY = void 0 !== t3.clientY ? t3.clientY : t3.pageY, this.screenX = t3.screenX || 0, this.screenY = t3.screenY || 0), this.button = t3.button, this.key = t3.key || "", this.ctrlKey = t3.ctrlKey, this.altKey = t3.altKey, this.shiftKey = t3.shiftKey, this.metaKey = t3.metaKey, this.pointerId = t3.pointerId || 0, this.pointerType = "string" == typeof t3.pointerType ? t3.pointerType : hp[t3.pointerType] || "", this.state = t3.state, this.i = t3, t3.defaultPrevented && lp.$.h.call(this);
-    }
-}
-Nf(lp, Uf);
-var hp = {
-    2: "touch",
-    3: "pen",
-    4: "mouse"
-};
-lp.prototype.h = function() {
-    lp.$.h.call(this);
-    var t3 = this.i;
-    t3.preventDefault ? t3.preventDefault() : t3.returnValue = false;
-};
-var cp = "closure_listenable_" + (1e6 * Math.random() | 0),
-    up = 0;
-
-function dp(t3, e2, i2, s2, n2) {
-    this.listener = t3, this.proxy = null, this.src = e2, this.type = i2, this.capture = !!s2, this.la = n2, this.key = ++up, this.fa = this.ia = false;
-}
-
-function fp(t3) {
-    t3.fa = true, t3.listener = null, t3.proxy = null, t3.src = null, t3.la = null;
-}
-
-function pp(t3, e2, i2) {
-    for (const s2 in t3)
-        e2.call(i2, t3[s2], s2, t3);
-}
-
-function mp(t3) {
-    const e2 = {};
-    for (const i2 in t3)
-        e2[i2] = t3[i2];
-    return e2;
-}
-const gp = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
-
-function yp(t3, e2) {
-    let i2, s2;
-    for (let e3 = 1; e3 < arguments.length; e3++) {
-        for (i2 in s2 = arguments[e3], s2)
-            t3[i2] = s2[i2];
-        for (let e4 = 0; e4 < gp.length; e4++)
-            i2 = gp[e4], Object.prototype.hasOwnProperty.call(s2, i2) && (t3[i2] = s2[i2]);
-    }
-}
-
-function vp(t3) {
-    this.src = t3, this.g = {}, this.h = 0;
-}
-
-function bp(t3, e2) {
-    var i2 = e2.type;
-    if (i2 in t3.g) {
-        var s2, n2 = t3.g[i2],
-            r2 = Vf(n2, e2);
-        (s2 = 0 <= r2) && Array.prototype.splice.call(n2, r2, 1), s2 && (fp(e2), 0 == t3.g[i2].length && (delete t3.g[i2], t3.h--));
-    }
-}
-
-function _p(t3, e2, i2, s2) {
-    for (var n2 = 0; n2 < t3.length; ++n2) {
-        var r2 = t3[n2];
-        if (!r2.fa && r2.listener == e2 && r2.capture == !!i2 && r2.la == s2)
-            return n2;
-    }
-    return -1;
-}
-vp.prototype.add = function(t3, e2, i2, s2, n2) {
-    var r2 = t3.toString();
-    (t3 = this.g[r2]) || (t3 = this.g[r2] = [], this.h++);
-    var o2 = _p(t3, e2, s2, n2);
-    return -1 < o2 ? (e2 = t3[o2], i2 || (e2.ia = false)) : ((e2 = new dp(e2, this.src, r2, !!s2, n2)).ia = i2, t3.push(e2)), e2;
-};
-var wp = "closure_lm_" + (1e6 * Math.random() | 0),
-    xp = {};
-
-function kp(t3, e2, i2, s2, n2) {
-    if (s2 && s2.once)
-        return Sp(t3, e2, i2, s2, n2);
-    if (Array.isArray(e2)) {
-        for (var r2 = 0; r2 < e2.length; r2++)
-            kp(t3, e2[r2], i2, s2, n2);
-        return null;
-    }
-    return i2 = Ap(i2), t3 && t3[cp] ? t3.O(e2, i2, Pf(s2) ? !!s2.capture : !!s2, n2) : Tp(t3, e2, i2, false, s2, n2);
-}
-
-function Tp(t3, e2, i2, s2, n2, r2) {
-    if (!e2)
-        throw Error("Invalid event type");
-    var o2 = Pf(n2) ? !!n2.capture : !!n2,
-        a2 = Pp(t3);
-    if (a2 || (t3[wp] = a2 = new vp(t3)), (i2 = a2.add(e2, i2, s2, o2, r2)).proxy)
-        return i2;
-    if (s2 = function() {
-            function t4(i3) {
-                return e3.call(t4.src, t4.listener, i3);
-            }
-            const e3 = Mp;
-            return t4;
-        }(), i2.proxy = s2, s2.src = t3, s2.listener = i2, t3.addEventListener)
-        jf || (n2 = o2), void 0 === n2 && (n2 = false), t3.addEventListener(e2.toString(), s2, n2);
-    else if (t3.attachEvent)
-        t3.attachEvent(Ip(e2.toString()), s2);
-    else {
-        if (!t3.addListener || !t3.removeListener)
-            throw Error("addEventListener and attachEvent are unavailable.");
-        t3.addListener(s2);
-    }
-    return i2;
-}
-
-function Sp(t3, e2, i2, s2, n2) {
-    if (Array.isArray(e2)) {
-        for (var r2 = 0; r2 < e2.length; r2++)
-            Sp(t3, e2[r2], i2, s2, n2);
-        return null;
-    }
-    return i2 = Ap(i2), t3 && t3[cp] ? t3.P(e2, i2, Pf(s2) ? !!s2.capture : !!s2, n2) : Tp(t3, e2, i2, true, s2, n2);
-}
-
-function Ep(t3, e2, i2, s2, n2) {
-    if (Array.isArray(e2))
-        for (var r2 = 0; r2 < e2.length; r2++)
-            Ep(t3, e2[r2], i2, s2, n2);
-    else
-        s2 = Pf(s2) ? !!s2.capture : !!s2, i2 = Ap(i2), t3 && t3[cp] ? (t3 = t3.i, (e2 = String(e2).toString()) in t3.g && (-1 < (i2 = _p(r2 = t3.g[e2], i2, s2, n2)) && (fp(r2[i2]), Array.prototype.splice.call(r2, i2, 1), 0 == r2.length && (delete t3.g[e2], t3.h--)))) : t3 && (t3 = Pp(t3)) && (e2 = t3.g[e2.toString()], t3 = -1, e2 && (t3 = _p(e2, i2, s2, n2)), (i2 = -1 < t3 ? e2[t3] : null) && Cp(i2));
-}
-
-function Cp(t3) {
-    if ("number" != typeof t3 && t3 && !t3.fa) {
-        var e2 = t3.src;
-        if (e2 && e2[cp])
-            bp(e2.i, t3);
-        else {
-            var i2 = t3.type,
-                s2 = t3.proxy;
-            e2.removeEventListener ? e2.removeEventListener(i2, s2, t3.capture) : e2.detachEvent ? e2.detachEvent(Ip(i2), s2) : e2.addListener && e2.removeListener && e2.removeListener(s2), (i2 = Pp(e2)) ? (bp(i2, t3), 0 == i2.h && (i2.src = null, e2[wp] = null)) : fp(t3);
-        }
-    }
-}
-
-function Ip(t3) {
-    return t3 in xp ? xp[t3] : xp[t3] = "on" + t3;
-}
-
-function Mp(t3, e2) {
-    if (t3.fa)
-        t3 = true;
-    else {
-        e2 = new lp(e2, this);
-        var i2 = t3.listener,
-            s2 = t3.la || t3.src;
-        t3.ia && Cp(t3), t3 = i2.call(s2, e2);
-    }
-    return t3;
-}
-
-function Pp(t3) {
-    return (t3 = t3[wp]) instanceof vp ? t3 : null;
-}
-var Rp = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
-
-function Ap(t3) {
-    return "function" == typeof t3 ? t3 : (t3[Rp] || (t3[Rp] = function(e2) {
-        return t3.handleEvent(e2);
-    }), t3[Rp]);
-}
-
-function Dp() {
-    $f.call(this), this.i = new vp(this), this.S = this, this.J = null;
-}
-
-function Lp(t3, e2) {
-    var i2, s2 = t3.J;
-    if (s2)
-        for (i2 = []; s2; s2 = s2.J)
-            i2.push(s2);
-    if (t3 = t3.S, s2 = e2.type || e2, "string" == typeof e2)
-        e2 = new Uf(e2, t3);
-    else if (e2 instanceof Uf)
-        e2.target = e2.target || t3;
-    else {
-        var n2 = e2;
-        yp(e2 = new Uf(s2, t3), n2);
-    }
-    if (n2 = true, i2)
-        for (var r2 = i2.length - 1; 0 <= r2; r2--) {
-            var o2 = e2.g = i2[r2];
-            n2 = Op(o2, s2, true, e2) && n2;
-        }
-    if (n2 = Op(o2 = e2.g = t3, s2, true, e2) && n2, n2 = Op(o2, s2, false, e2) && n2, i2)
-        for (r2 = 0; r2 < i2.length; r2++)
-            n2 = Op(o2 = e2.g = i2[r2], s2, false, e2) && n2;
-}
-
-function Op(t3, e2, i2, s2) {
-    if (!(e2 = t3.i.g[String(e2)]))
-        return true;
-    e2 = e2.concat();
-    for (var n2 = true, r2 = 0; r2 < e2.length; ++r2) {
-        var o2 = e2[r2];
-        if (o2 && !o2.fa && o2.capture == i2) {
-            var a2 = o2.listener,
-                l2 = o2.la || o2.src;
-            o2.ia && bp(t3.i, o2), n2 = false !== a2.call(l2, s2) && n2;
-        }
-    }
-    return n2 && !s2.defaultPrevented;
-}
-Nf(Dp, $f), Dp.prototype[cp] = true, Dp.prototype.removeEventListener = function(t3, e2, i2, s2) {
-    Ep(this, t3, e2, i2, s2);
-}, Dp.prototype.N = function() {
-    if (Dp.$.N.call(this), this.i) {
-        var t3, e2 = this.i;
-        for (t3 in e2.g) {
-            for (var i2 = e2.g[t3], s2 = 0; s2 < i2.length; s2++)
-                fp(i2[s2]);
-            delete e2.g[t3], e2.h--;
-        }
-    }
-    this.J = null;
-}, Dp.prototype.O = function(t3, e2, i2, s2) {
-    return this.i.add(String(t3), e2, false, i2, s2);
-}, Dp.prototype.P = function(t3, e2, i2, s2) {
-    return this.i.add(String(t3), e2, true, i2, s2);
-};
-var Fp = If.JSON.stringify;
-
-function Np() {
-    var t3 = jp;
-    let e2 = null;
-    return t3.g && (e2 = t3.g, t3.g = t3.g.next, t3.g || (t3.h = null), e2.next = null), e2;
-}
-var $p = new class kb {
-    constructor(t3, e2) {
-        this.i = t3, this.j = e2, this.h = 0, this.g = null;
-    }
-    get() {
-        let t3;
-        return 0 < this.h ? (this.h--, t3 = this.g, this.g = t3.next, t3.next = null) : t3 = this.i(), t3;
-    }
-}(() => new pb(), (t3) => t3.reset());
-class pb {
-    constructor() {
-        this.next = this.g = this.h = null;
-    }
-    set(t3, e2) {
-        this.h = t3, this.g = e2, this.next = null;
-    }
-    reset() {
-        this.next = this.g = this.h = null;
-    }
-}
-
-function Vp(t3) {
-    var e2 = 1;
-    t3 = t3.split(":");
-    const i2 = [];
-    for (; 0 < e2 && t3.length;)
-        i2.push(t3.shift()), e2--;
-    return t3.length && i2.push(t3.join(":")), i2;
-}
-
-function zp(t3) {
-    If.setTimeout(() => {
-        throw t3;
-    }, 0);
-}
-let Bp, Up = false,
-    jp = new class nb {
-        constructor() {
-            this.h = this.g = null;
-        }
-        add(t3, e2) {
-            const i2 = $p.get();
-            i2.set(t3, e2), this.h ? this.h.next = i2 : this.g = i2, this.h = i2;
-        }
-    }(),
-    Hp = () => {
-        const t3 = If.Promise.resolve(void 0);
-        Bp = () => {
-            t3.then(Wp);
-        };
-    };
-var Wp = () => {
-    for (var t3; t3 = Np();) {
-        try {
-            t3.h.call(t3.g);
-        } catch (t4) {
-            zp(t4);
-        }
-        var e2 = $p;
-        e2.j(t3), 100 > e2.h && (e2.h++, t3.next = e2.g, e2.g = t3);
-    }
-    Up = false;
-};
-
-function qp(t3, e2) {
-    Dp.call(this), this.h = t3 || 1, this.g = e2 || If, this.j = Of(this.qb, this), this.l = Date.now();
-}
-
-function Kp(t3) {
-    t3.ga = false, t3.T && (t3.g.clearTimeout(t3.T), t3.T = null);
-}
-
-function Gp(t3, e2, i2) {
-    if ("function" == typeof t3)
-        i2 && (t3 = Of(t3, i2));
-    else {
-        if (!t3 || "function" != typeof t3.handleEvent)
-            throw Error("Invalid listener argument");
-        t3 = Of(t3.handleEvent, t3);
-    }
-    return 2147483647 < Number(e2) ? -1 : If.setTimeout(t3, e2 || 0);
-}
-
-function Yp(t3) {
-    t3.g = Gp(() => {
-        t3.g = null, t3.i && (t3.i = false, Yp(t3));
-    }, t3.j);
-    const e2 = t3.h;
-    t3.h = null, t3.m.apply(null, e2);
-}
-Nf(qp, Dp), (Sf = qp.prototype).ga = false, Sf.T = null, Sf.qb = function() {
-    if (this.ga) {
-        var t3 = Date.now() - this.l;
-        0 < t3 && t3 < 0.8 * this.h ? this.T = this.g.setTimeout(this.j, this.h - t3) : (this.T && (this.g.clearTimeout(this.T), this.T = null), Lp(this, "tick"), this.ga && (Kp(this), this.start()));
-    }
-}, Sf.start = function() {
-    this.ga = true, this.T || (this.T = this.g.setTimeout(this.j, this.h), this.l = Date.now());
-}, Sf.N = function() {
-    qp.$.N.call(this), Kp(this), delete this.g;
-};
-class Ab extends $f {
-    constructor(t3, e2) {
-        super(), this.m = t3, this.j = e2, this.h = null, this.i = false, this.g = null;
-    }
-    l(t3) {
-        this.h = arguments, this.g ? this.i = true : Yp(this);
-    }
-    N() {
-        super.N(), this.g && (If.clearTimeout(this.g), this.g = null, this.i = false, this.h = null);
-    }
-}
-
-function Qp(t3) {
-    $f.call(this), this.h = t3, this.g = {};
-}
-Nf(Qp, $f);
-var Xp = [];
-
-function Jp(t3, e2, i2, s2) {
-    Array.isArray(i2) || (i2 && (Xp[0] = i2.toString()), i2 = Xp);
-    for (var n2 = 0; n2 < i2.length; n2++) {
-        var r2 = kp(e2, i2[n2], s2 || t3.handleEvent, false, t3.h || t3);
-        if (!r2)
-            break;
-        t3.g[r2.key] = r2;
-    }
-}
-
-function Zp(t3) {
-    pp(t3.g, function(t4, e2) {
-        this.g.hasOwnProperty(e2) && Cp(t4);
-    }, t3), t3.g = {};
-}
-
-function tm() {
-    this.g = true;
-}
-
-function em(t3, e2, i2, s2) {
-    t3.info(function() {
-        return "XMLHTTP TEXT (" + e2 + "): " + function(t4, e3) {
-            if (!t4.g)
-                return e3;
-            if (!e3)
-                return null;
-            try {
-                var i3 = JSON.parse(e3);
-                if (i3) {
-                    for (t4 = 0; t4 < i3.length; t4++)
-                        if (Array.isArray(i3[t4])) {
-                            var s3 = i3[t4];
-                            if (!(2 > s3.length)) {
-                                var n2 = s3[1];
-                                if (Array.isArray(n2) && !(1 > n2.length)) {
-                                    var r2 = n2[0];
-                                    if ("noop" != r2 && "stop" != r2 && "close" != r2)
-                                        for (var o2 = 1; o2 < n2.length; o2++)
-                                            n2[o2] = "";
-                                }
-                            }
-                        }
-                }
-                return Fp(i3);
-            } catch (t5) {
-                return e3;
-            }
-        }(t3, i2) + (s2 ? " " + s2 : "");
-    });
-}
-Qp.prototype.N = function() {
-    Qp.$.N.call(this), Zp(this);
-}, Qp.prototype.handleEvent = function() {
-    throw Error("EventHandler.handleEvent not implemented");
-}, tm.prototype.Ea = function() {
-    this.g = false;
-}, tm.prototype.info = function() {};
-var im = {},
-    sm = null;
-
-function nm() {
-    return sm = sm || new Dp();
-}
-
-function rm(t3) {
-    Uf.call(this, im.Ta, t3);
-}
-
-function om(t3) {
-    const e2 = nm();
-    Lp(e2, new rm(e2));
-}
-
-function am(t3, e2) {
-    Uf.call(this, im.STAT_EVENT, t3), this.stat = e2;
-}
-
-function lm(t3) {
-    const e2 = nm();
-    Lp(e2, new am(e2, t3));
-}
-
-function hm(t3, e2) {
-    Uf.call(this, im.Ua, t3), this.size = e2;
-}
-
-function cm(t3, e2) {
-    if ("function" != typeof t3)
-        throw Error("Fn must not be null and must be a function");
-    return If.setTimeout(function() {
-        t3();
-    }, e2);
-}
-im.Ta = "serverreachability", Nf(rm, Uf), im.STAT_EVENT = "statevent", Nf(am, Uf), im.Ua = "timingevent", Nf(hm, Uf);
-var um = {
-        NO_ERROR: 0,
-        rb: 1,
-        Eb: 2,
-        Db: 3,
-        yb: 4,
-        Cb: 5,
-        Fb: 6,
-        Qa: 7,
-        TIMEOUT: 8,
-        Ib: 9
-    },
-    dm = {
-        wb: "complete",
-        Sb: "success",
-        Ra: "error",
-        Qa: "abort",
-        Kb: "ready",
-        Lb: "readystatechange",
-        TIMEOUT: "timeout",
-        Gb: "incrementaldata",
-        Jb: "progress",
-        zb: "downloadprogress",
-        $b: "uploadprogress"
-    };
-
-function fm() {}
-
-function pm(t3) {
-    return t3.h || (t3.h = t3.i());
-}
-
-function mm() {}
-fm.prototype.h = null;
-var gm, ym = {
-    OPEN: "a",
-    vb: "b",
-    Ra: "c",
-    Hb: "d"
-};
-
-function vm() {
-    Uf.call(this, "d");
-}
-
-function bm() {
-    Uf.call(this, "c");
-}
-
-function _m() {}
-
-function wm(t3, e2, i2, s2) {
-    this.l = t3, this.j = e2, this.m = i2, this.W = s2 || 1, this.U = new Qp(this), this.P = km, t3 = Zf ? 125 : void 0, this.V = new qp(t3), this.I = null, this.i = false, this.s = this.A = this.v = this.L = this.G = this.Y = this.B = null, this.F = [], this.g = null, this.C = 0, this.o = this.u = null, this.ca = -1, this.J = false, this.O = 0, this.M = null, this.ba = this.K = this.aa = this.S = false, this.h = new xm();
-}
-
-function xm() {
-    this.i = null, this.g = "", this.h = false;
-}
-Nf(vm, Uf), Nf(bm, Uf), Nf(_m, fm), _m.prototype.g = function() {
-    return new XMLHttpRequest();
-}, _m.prototype.i = function() {
-    return {};
-}, gm = new _m();
-var km = 45e3,
-    Tm = {},
-    Sm = {};
-
-function Em(t3, e2, i2) {
-    t3.L = 1, t3.v = Wm(zm(e2)), t3.s = i2, t3.S = true, Cm(t3, null);
-}
-
-function Cm(t3, e2) {
-    t3.G = Date.now(), Rm(t3), t3.A = zm(t3.v);
-    var i2 = t3.A,
-        s2 = t3.W;
-    Array.isArray(s2) || (s2 = [String(s2)]), ng(i2.i, "t", s2), t3.C = 0, i2 = t3.l.J, t3.h = new xm(), t3.g = sy(t3.l, i2 ? e2 : null, !t3.s), 0 < t3.O && (t3.M = new Ab(Of(t3.Pa, t3, t3.g), t3.O)), Jp(t3.U, t3.g, "readystatechange", t3.nb), e2 = t3.I ? mp(t3.I) : {}, t3.s ? (t3.u || (t3.u = "POST"), e2["Content-Type"] = "application/x-www-form-urlencoded", t3.g.ha(t3.A, t3.u, t3.s, e2)) : (t3.u = "GET", t3.g.ha(t3.A, t3.u, null, e2)), om(),
-        function(t4, e3, i3, s3, n2, r2) {
-            t4.info(function() {
-                if (t4.g)
-                    if (r2)
-                        for (var o2 = "", a2 = r2.split("&"), l2 = 0; l2 < a2.length; l2++) {
-                            var h2 = a2[l2].split("=");
-                            if (1 < h2.length) {
-                                var c2 = h2[0];
-                                h2 = h2[1];
-                                var u2 = c2.split("_");
-                                o2 = 2 <= u2.length && "type" == u2[1] ? o2 + (c2 + "=") + h2 + "&" : o2 + (c2 + "=redacted&");
-                            }
-                        }
-                else
-                    o2 = null;
-                else
-                    o2 = r2;
-                return "XMLHTTP REQ (" + s3 + ") [attempt " + n2 + "]: " + e3 + "\n" + i3 + "\n" + o2;
-            });
-        }(t3.j, t3.u, t3.A, t3.m, t3.W, t3.s);
-}
-
-function Im(t3) {
-    return !!t3.g && ("GET" == t3.u && 2 != t3.L && t3.l.Ha);
-}
-
-function Mm(t3, e2, i2) {
-    let s2, n2 = true;
-    for (; !t3.J && t3.C < i2.length;) {
-        if (s2 = Pm(t3, i2), s2 == Sm) {
-            4 == e2 && (t3.o = 4, lm(14), n2 = false), em(t3.j, t3.m, null, "[Incomplete Response]");
-            break;
-        }
-        if (s2 == Tm) {
-            t3.o = 4, lm(15), em(t3.j, t3.m, i2, "[Invalid Chunk]"), n2 = false;
-            break;
-        }
-        em(t3.j, t3.m, s2, null), Fm(t3, s2);
-    }
-    Im(t3) && s2 != Sm && s2 != Tm && (t3.h.g = "", t3.C = 0), 4 != e2 || 0 != i2.length || t3.h.h || (t3.o = 1, lm(16), n2 = false), t3.i = t3.i && n2, n2 ? 0 < i2.length && !t3.ba && (t3.ba = true, (e2 = t3.l).g == t3 && e2.ca && !e2.M && (e2.l.info("Great, no buffering proxy detected. Bytes received: " + i2.length), Yg(e2), e2.M = true, lm(11))) : (em(t3.j, t3.m, i2, "[Invalid Chunked Response]"), Om(t3), Lm(t3));
-}
-
-function Pm(t3, e2) {
-    var i2 = t3.C,
-        s2 = e2.indexOf("\n", i2);
-    return -1 == s2 ? Sm : (i2 = Number(e2.substring(i2, s2)), isNaN(i2) ? Tm : (s2 += 1) + i2 > e2.length ? Sm : (e2 = e2.slice(s2, s2 + i2), t3.C = s2 + i2, e2));
-}
-
-function Rm(t3) {
-    t3.Y = Date.now() + t3.P, Am(t3, t3.P);
-}
-
-function Am(t3, e2) {
-    if (null != t3.B)
-        throw Error("WatchDog timer not null");
-    t3.B = cm(Of(t3.lb, t3), e2);
-}
-
-function Dm(t3) {
-    t3.B && (If.clearTimeout(t3.B), t3.B = null);
-}
-
-function Lm(t3) {
-    0 == t3.l.H || t3.J || Jg(t3.l, t3);
-}
-
-function Om(t3) {
-    Dm(t3);
-    var e2 = t3.M;
-    e2 && "function" == typeof e2.sa && e2.sa(), t3.M = null, Kp(t3.V), Zp(t3.U), t3.g && (e2 = t3.g, t3.g = null, e2.abort(), e2.sa());
-}
-
-function Fm(t3, e2) {
-    try {
-        var i2 = t3.l;
-        if (0 != i2.H && (i2.g == t3 || cg(i2.i, t3))) {
-            if (!t3.K && cg(i2.i, t3) && 3 == i2.H) {
-                try {
-                    var s2 = i2.Ja.g.parse(e2);
-                } catch (t4) {
-                    s2 = null;
-                }
-                if (Array.isArray(s2) && 3 == s2.length) {
-                    var n2 = s2;
-                    if (0 == n2[0]) {
-                        t: if (!i2.u) {
-                            if (i2.g) {
-                                if (!(i2.g.G + 3e3 < t3.G))
-                                    break t;
-                                Xg(i2), Bg(i2);
-                            }
-                            Gg(i2), lm(18);
-                        }
-                    }
-                    else
-                        i2.Fa = n2[1], 0 < i2.Fa - i2.V && 37500 > n2[2] && i2.G && 0 == i2.A && !i2.v && (i2.v = cm(Of(i2.ib, i2), 6e3));
-                    if (1 >= hg(i2.i) && i2.oa) {
-                        try {
-                            i2.oa();
-                        } catch (t4) {}
-                        i2.oa = void 0;
-                    }
-                } else
-                    ty(i2, 11);
-            } else if ((t3.K || i2.g == t3) && Xg(i2), !Hf(e2))
-                for (n2 = i2.Ja.g.parse(e2), e2 = 0; e2 < n2.length; e2++) {
-                    let h2 = n2[e2];
-                    if (i2.V = h2[0], h2 = h2[1], 2 == i2.H)
-                        if ("c" == h2[0]) {
-                            i2.K = h2[1], i2.pa = h2[2];
-                            const e3 = h2[3];
-                            null != e3 && (i2.ra = e3, i2.l.info("VER=" + i2.ra));
-                            const n3 = h2[4];
-                            null != n3 && (i2.Ga = n3, i2.l.info("SVER=" + i2.Ga));
-                            const c2 = h2[5];
-                            null != c2 && "number" == typeof c2 && 0 < c2 && (s2 = 1.5 * c2, i2.L = s2, i2.l.info("backChannelRequestTimeoutMs_=" + s2)), s2 = i2;
-                            const u2 = t3.g;
-                            if (u2) {
-                                const t4 = u2.g ? u2.g.getResponseHeader("X-Client-Wire-Protocol") : null;
-                                if (t4) {
-                                    var r2 = s2.i;
-                                    r2.g || -1 == t4.indexOf("spdy") && -1 == t4.indexOf("quic") && -1 == t4.indexOf("h2") || (r2.j = r2.l, r2.g = /* @__PURE__ */ new Set(), r2.h && (ug(r2, r2.h), r2.h = null));
-                                }
-                                if (s2.F) {
-                                    const t5 = u2.g ? u2.g.getResponseHeader("X-HTTP-Session-Id") : null;
-                                    t5 && (s2.Da = t5, Hm(s2.I, s2.F, t5));
-                                }
-                            }
-                            i2.H = 3, i2.h && i2.h.Ba(), i2.ca && (i2.S = Date.now() - t3.G, i2.l.info("Handshake RTT: " + i2.S + "ms"));
-                            var o2 = t3;
-                            if ((s2 = i2).wa = iy(s2, s2.J ? s2.pa : null, s2.Y), o2.K) {
-                                dg(s2.i, o2);
-                                var a2 = o2,
-                                    l2 = s2.L;
-                                l2 && a2.setTimeout(l2), a2.B && (Dm(a2), Rm(a2)), s2.g = o2;
-                            } else
-                                Kg(s2);
-                            0 < i2.j.length && jg(i2);
-                        } else
-                            "stop" != h2[0] && "close" != h2[0] || ty(i2, 7);
-                    else
-                        3 == i2.H && ("stop" == h2[0] || "close" == h2[0] ? "stop" == h2[0] ? ty(i2, 7) : zg(i2) : "noop" != h2[0] && i2.h && i2.h.Aa(h2), i2.A = 0);
-                }
-        }
-        om();
-    } catch (t4) {}
-}
-
-function Nm(t3, e2) {
-    if (t3.forEach && "function" == typeof t3.forEach)
-        t3.forEach(e2, void 0);
-    else if (Mf(t3) || "string" == typeof t3)
-        Array.prototype.forEach.call(t3, e2, void 0);
-    else
-        for (var i2 = function(t4) {
-                if (t4.ta && "function" == typeof t4.ta)
-                    return t4.ta();
-                if (!t4.Z || "function" != typeof t4.Z) {
-                    if ("undefined" != typeof Map && t4 instanceof Map)
-                        return Array.from(t4.keys());
-                    if (!("undefined" != typeof Set && t4 instanceof Set)) {
-                        if (Mf(t4) || "string" == typeof t4) {
-                            var e3 = [];
-                            t4 = t4.length;
-                            for (var i3 = 0; i3 < t4; i3++)
-                                e3.push(i3);
-                            return e3;
-                        }
-                        e3 = [], i3 = 0;
-                        for (const s3 in t4)
-                            e3[i3++] = s3;
-                        return e3;
-                    }
-                }
-            }(t3), s2 = function(t4) {
-                if (t4.Z && "function" == typeof t4.Z)
-                    return t4.Z();
-                if ("undefined" != typeof Map && t4 instanceof Map || "undefined" != typeof Set && t4 instanceof Set)
-                    return Array.from(t4.values());
-                if ("string" == typeof t4)
-                    return t4.split("");
-                if (Mf(t4)) {
-                    for (var e3 = [], i3 = t4.length, s3 = 0; s3 < i3; s3++)
-                        e3.push(t4[s3]);
-                    return e3;
-                }
-                for (s3 in e3 = [], i3 = 0, t4)
-                    e3[i3++] = t4[s3];
-                return e3;
-            }(t3), n2 = s2.length, r2 = 0; r2 < n2; r2++)
-            e2.call(void 0, s2[r2], i2 && i2[r2], t3);
-}
-(Sf = wm.prototype).setTimeout = function(t3) {
-    this.P = t3;
-}, Sf.nb = function(t3) {
-    t3 = t3.target;
-    const e2 = this.M;
-    e2 && 3 == Lg(t3) ? e2.l() : this.Pa(t3);
-}, Sf.Pa = function(t3) {
-    try {
-        if (t3 == this.g)
-            t: {
-                const c2 = Lg(this.g);
-                var e2 = this.g.Ia();
-                this.g.da();
-                if (!(3 > c2) && (3 != c2 || Zf || this.g && (this.h.h || this.g.ja() || Og(this.g)))) {
-                    this.J || 4 != c2 || 7 == e2 || om(), Dm(this);
-                    var i2 = this.g.da();
-                    this.ca = i2;
-                    e:
-                        if (Im(this)) {
-                            var s2 = Og(this.g);
-                            t3 = "";
-                            var n2 = s2.length,
-                                r2 = 4 == Lg(this.g);
-                            if (!this.h.i) {
-                                if ("undefined" == typeof TextDecoder) {
-                                    Om(this), Lm(this);
-                                    var o2 = "";
-                                    break e;
-                                }
-                                this.h.i = new If.TextDecoder();
-                            }
-                            for (e2 = 0; e2 < n2; e2++)
-                                this.h.h = true, t3 += this.h.i.decode(s2[e2], {
-                                    stream: r2 && e2 == n2 - 1
-                                });
-                            s2.splice(0, n2), this.h.g += t3, this.C = 0, o2 = this.h.g;
-                        } else
-                            o2 = this.g.ja();
-                    if (this.i = 200 == i2, function(t4, e3, i3, s3, n3, r3, o3) {
-                            t4.info(function() {
-                                return "XMLHTTP RESP (" + s3 + ") [ attempt " + n3 + "]: " + e3 + "\n" + i3 + "\n" + r3 + " " + o3;
-                            });
-                        }(this.j, this.u, this.A, this.m, this.W, c2, i2), this.i) {
-                        if (this.aa && !this.K) {
-                            e: {
-                                if (this.g) {
-                                    var a2, l2 = this.g;
-                                    if ((a2 = l2.g ? l2.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !Hf(a2)) {
-                                        var h2 = a2;
-                                        break e;
-                                    }
-                                }
-                                h2 = null;
-                            }
-                            if (!(i2 = h2)) {
-                                this.i = false, this.o = 3, lm(12), Om(this), Lm(this);
-                                break t;
-                            }
-                            em(this.j, this.m, i2, "Initial handshake response via X-HTTP-Initial-Response"),
-                            this.K = true,
-                            Fm(this, i2);
-                        }
-                        this.S ? (Mm(this, c2, o2), Zf && this.i && 3 == c2 && (Jp(this.U, this.V, "tick", this.mb), this.V.start())) : (em(this.j, this.m, o2, null), Fm(this, o2)), 4 == c2 && Om(this), this.i && !this.J && (4 == c2 ? Jg(this.l, this) : (this.i = false, Rm(this)));
-                    } else
-                        (function(t4) {
-                            const e3 = {};
-                            t4 = (t4.g && 2 <= Lg(t4) && t4.g.getAllResponseHeaders() || "").split("\r\n");
-                            for (let s3 = 0; s3 < t4.length; s3++) {
-                                if (Hf(t4[s3]))
-                                    continue;
-                                var i3 = Vp(t4[s3]);
-                                const n3 = i3[0];
-                                if ("string" != typeof(i3 = i3[1]))
-                                    continue;
-                                i3 = i3.trim();
-                                const r3 = e3[n3] || [];
-                                e3[n3] = r3, r3.push(i3);
-                            }! function(t5, e4) {
-                                for (const i4 in t5)
-                                    e4.call(void 0, t5[i4], i4, t5);
-                            }(e3, function(t5) {
-                                return t5.join(", ");
-                            });
-                        })(this.g), 400 == i2 && 0 < o2.indexOf("Unknown SID") ? (this.o = 3, lm(12)) : (this.o = 0, lm(13)), Om(this), Lm(this);
-                }
-            }
-    } catch (t4) {}
-}, Sf.mb = function() {
-    if (this.g) {
-        var t3 = Lg(this.g),
-            e2 = this.g.ja();
-        this.C < e2.length && (Dm(this), Mm(this, t3, e2), this.i && 4 != t3 && Rm(this));
-    }
-}, Sf.cancel = function() {
-    this.J = true, Om(this);
-}, Sf.lb = function() {
-    this.B = null;
-    const t3 = Date.now();
-    0 <= t3 - this.Y ? (function(t4, e2) {
-        t4.info(function() {
-            return "TIMEOUT: " + e2;
-        });
-    }(this.j, this.A), 2 != this.L && (om(), lm(17)), Om(this), this.o = 2, Lm(this)) : Am(this, this.Y - t3);
-};
-var $m = RegExp("^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$");
-
-function Vm(t3) {
-    if (this.g = this.s = this.j = "", this.m = null, this.o = this.l = "", this.h = false, t3 instanceof Vm) {
-        this.h = t3.h, Bm(this, t3.j), this.s = t3.s, this.g = t3.g, Um(this, t3.m), this.l = t3.l;
-        var e2 = t3.i,
-            i2 = new tg();
-        i2.i = e2.i, e2.g && (i2.g = new Map(e2.g), i2.h = e2.h), jm(this, i2), this.o = t3.o;
-    } else
-        t3 && (e2 = String(t3).match($m)) ? (this.h = false, Bm(this, e2[1] || "", true), this.s = qm(e2[2] || ""), this.g = qm(e2[3] || "", true), Um(this, e2[4]), this.l = qm(e2[5] || "", true), jm(this, e2[6] || "", true), this.o = qm(e2[7] || "")) : (this.h = false, this.i = new tg(null, this.h));
-}
-
-function zm(t3) {
-    return new Vm(t3);
-}
-
-function Bm(t3, e2, i2) {
-    t3.j = i2 ? qm(e2, true) : e2, t3.j && (t3.j = t3.j.replace(/:$/, ""));
-}
-
-function Um(t3, e2) {
-    if (e2) {
-        if (e2 = Number(e2), isNaN(e2) || 0 > e2)
-            throw Error("Bad port number " + e2);
-        t3.m = e2;
-    } else
-        t3.m = null;
-}
-
-function jm(t3, e2, i2) {
-    e2 instanceof tg ? (t3.i = e2, function(t4, e3) {
-        e3 && !t4.j && (eg(t4), t4.i = null, t4.g.forEach(function(t5, e4) {
-            var i3 = e4.toLowerCase();
-            e4 != i3 && (ig(this, e4), ng(this, i3, t5));
-        }, t4)), t4.j = e3;
-    }(t3.i, t3.h)) : (i2 || (e2 = Km(e2, Jm)), t3.i = new tg(e2, t3.h));
-}
-
-function Hm(t3, e2, i2) {
-    t3.i.set(e2, i2);
-}
-
-function Wm(t3) {
-    return Hm(t3, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36)), t3;
-}
-
-function qm(t3, e2) {
-    return t3 ? e2 ? decodeURI(t3.replace(/%25/g, "%2525")) : decodeURIComponent(t3) : "";
-}
-
-function Km(t3, e2, i2) {
-    return "string" == typeof t3 ? (t3 = encodeURI(t3).replace(e2, Gm), i2 && (t3 = t3.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), t3) : null;
-}
-
-function Gm(t3) {
-    return "%" + ((t3 = t3.charCodeAt(0)) >> 4 & 15).toString(16) + (15 & t3).toString(16);
-}
-Vm.prototype.toString = function() {
-    var t3 = [],
-        e2 = this.j;
-    e2 && t3.push(Km(e2, Ym, true), ":");
-    var i2 = this.g;
-    return (i2 || "file" == e2) && (t3.push("//"), (e2 = this.s) && t3.push(Km(e2, Ym, true), "@"), t3.push(encodeURIComponent(String(i2)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), null != (i2 = this.m) && t3.push(":", String(i2))), (i2 = this.l) && (this.g && "/" != i2.charAt(0) && t3.push("/"), t3.push(Km(i2, "/" == i2.charAt(0) ? Xm : Qm, true))), (i2 = this.i.toString()) && t3.push("?", i2), (i2 = this.o) && t3.push("#", Km(i2, Zm)), t3.join("");
-};
-var Ym = /[#\/\?@]/g,
-    Qm = /[#\?:]/g,
-    Xm = /[#\?]/g,
-    Jm = /[#\?@]/g,
-    Zm = /#/g;
-
-function tg(t3, e2) {
-    this.h = this.g = null, this.i = t3 || null, this.j = !!e2;
-}
-
-function eg(t3) {
-    t3.g || (t3.g = /* @__PURE__ */ new Map(), t3.h = 0, t3.i && function(t4, e2) {
-        if (t4) {
-            t4 = t4.split("&");
-            for (var i2 = 0; i2 < t4.length; i2++) {
-                var s2 = t4[i2].indexOf("="),
-                    n2 = null;
-                if (0 <= s2) {
-                    var r2 = t4[i2].substring(0, s2);
-                    n2 = t4[i2].substring(s2 + 1);
-                } else
-                    r2 = t4[i2];
-                e2(r2, n2 ? decodeURIComponent(n2.replace(/\+/g, " ")) : "");
-            }
-        }
-    }(t3.i, function(e2, i2) {
-        t3.add(decodeURIComponent(e2.replace(/\+/g, " ")), i2);
-    }));
-}
-
-function ig(t3, e2) {
-    eg(t3), e2 = rg(t3, e2), t3.g.has(e2) && (t3.i = null, t3.h -= t3.g.get(e2).length, t3.g.delete(e2));
-}
-
-function sg(t3, e2) {
-    return eg(t3), e2 = rg(t3, e2), t3.g.has(e2);
-}
-
-function ng(t3, e2, i2) {
-    ig(t3, e2), 0 < i2.length && (t3.i = null, t3.g.set(rg(t3, e2), zf(i2)), t3.h += i2.length);
-}
-
-function rg(t3, e2) {
-    return e2 = String(e2), t3.j && (e2 = e2.toLowerCase()), e2;
-}
-(Sf = tg.prototype).add = function(t3, e2) {
-    eg(this), this.i = null, t3 = rg(this, t3);
-    var i2 = this.g.get(t3);
-    return i2 || this.g.set(t3, i2 = []), i2.push(e2), this.h += 1, this;
-}, Sf.forEach = function(t3, e2) {
-    eg(this), this.g.forEach(function(i2, s2) {
-        i2.forEach(function(i3) {
-            t3.call(e2, i3, s2, this);
-        }, this);
-    }, this);
-}, Sf.ta = function() {
-    eg(this);
-    const t3 = Array.from(this.g.values()),
-        e2 = Array.from(this.g.keys()),
-        i2 = [];
-    for (let s2 = 0; s2 < e2.length; s2++) {
-        const n2 = t3[s2];
-        for (let t4 = 0; t4 < n2.length; t4++)
-            i2.push(e2[s2]);
-    }
-    return i2;
-}, Sf.Z = function(t3) {
-    eg(this);
-    let e2 = [];
-    if ("string" == typeof t3)
-        sg(this, t3) && (e2 = e2.concat(this.g.get(rg(this, t3))));
-    else {
-        t3 = Array.from(this.g.values());
-        for (let i2 = 0; i2 < t3.length; i2++)
-            e2 = e2.concat(t3[i2]);
-    }
-    return e2;
-}, Sf.set = function(t3, e2) {
-    return eg(this), this.i = null, sg(this, t3 = rg(this, t3)) && (this.h -= this.g.get(t3).length), this.g.set(t3, [e2]), this.h += 1, this;
-}, Sf.get = function(t3, e2) {
-    return t3 && 0 < (t3 = this.Z(t3)).length ? String(t3[0]) : e2;
-}, Sf.toString = function() {
-    if (this.i)
-        return this.i;
-    if (!this.g)
-        return "";
-    const t3 = [],
-        e2 = Array.from(this.g.keys());
-    for (var i2 = 0; i2 < e2.length; i2++) {
-        var s2 = e2[i2];
-        const r2 = encodeURIComponent(String(s2)),
-            o2 = this.Z(s2);
-        for (s2 = 0; s2 < o2.length; s2++) {
-            var n2 = r2;
-            "" !== o2[s2] && (n2 += "=" + encodeURIComponent(String(o2[s2]))), t3.push(n2);
-        }
-    }
-    return this.i = t3.join("&");
-};
-
-function og(t3) {
-    this.l = t3 || ag, If.PerformanceNavigationTiming ? t3 = 0 < (t3 = If.performance.getEntriesByType("navigation")).length && ("hq" == t3[0].nextHopProtocol || "h2" == t3[0].nextHopProtocol) : t3 = !!(If.g && If.g.Ka && If.g.Ka() && If.g.Ka().ec), this.j = t3 ? this.l : 1, this.g = null, 1 < this.j && (this.g = /* @__PURE__ */ new Set()), this.h = null, this.i = [];
-}
-var ag = 10;
-
-function lg(t3) {
-    return !!t3.h || !!t3.g && t3.g.size >= t3.j;
-}
-
-function hg(t3) {
-    return t3.h ? 1 : t3.g ? t3.g.size : 0;
-}
-
-function cg(t3, e2) {
-    return t3.h ? t3.h == e2 : !!t3.g && t3.g.has(e2);
-}
-
-function ug(t3, e2) {
-    t3.g ? t3.g.add(e2) : t3.h = e2;
-}
-
-function dg(t3, e2) {
-    t3.h && t3.h == e2 ? t3.h = null : t3.g && t3.g.has(e2) && t3.g.delete(e2);
-}
-
-function fg(t3) {
-    if (null != t3.h)
-        return t3.i.concat(t3.h.F);
-    if (null != t3.g && 0 !== t3.g.size) {
-        let e2 = t3.i;
-        for (const i2 of t3.g.values())
-            e2 = e2.concat(i2.F);
-        return e2;
-    }
-    return zf(t3.i);
-}
-og.prototype.cancel = function() {
-    if (this.i = fg(this), this.h)
-        this.h.cancel(), this.h = null;
-    else if (this.g && 0 !== this.g.size) {
-        for (const t3 of this.g.values())
-            t3.cancel();
-        this.g.clear();
-    }
-};
-var pg = class {
-    stringify(t3) {
-        return If.JSON.stringify(t3, void 0);
-    }
-    parse(t3) {
-        return If.JSON.parse(t3, void 0);
-    }
-};
-
-function mg() {
-    this.g = new pg();
-}
-
-function gg(t3, e2, i2) {
-    const s2 = i2 || "";
-    try {
-        Nm(t3, function(t4, i3) {
-            let n2 = t4;
-            Pf(t4) && (n2 = Fp(t4)), e2.push(s2 + i3 + "=" + encodeURIComponent(n2));
-        });
-    } catch (t4) {
-        throw e2.push(s2 + "type=" + encodeURIComponent("_badmap")), t4;
-    }
-}
-
-function yg(t3, e2, i2, s2, n2) {
-    try {
-        e2.onload = null, e2.onerror = null, e2.onabort = null, e2.ontimeout = null, n2(s2);
-    } catch (t4) {}
-}
-
-function vg(t3) {
-    this.l = t3.fc || null, this.j = t3.ob || false;
-}
-
-function bg(t3, e2) {
-    Dp.call(this), this.F = t3, this.u = e2, this.m = void 0, this.readyState = _g, this.status = 0, this.responseType = this.responseText = this.response = this.statusText = "", this.onreadystatechange = null, this.v = new Headers(), this.h = null, this.C = "GET", this.B = "", this.g = false, this.A = this.j = this.l = null;
-}
-Nf(vg, fm), vg.prototype.g = function() {
-    return new bg(this.l, this.j);
-}, vg.prototype.i = function(t3) {
-    return function() {
-        return t3;
-    };
-}({}), Nf(bg, Dp);
-var _g = 0;
-
-function wg(t3) {
-    t3.j.read().then(t3.Xa.bind(t3)).catch(t3.ka.bind(t3));
-}
-
-function xg(t3) {
-    t3.readyState = 4, t3.l = null, t3.j = null, t3.A = null, kg(t3);
-}
-
-function kg(t3) {
-    t3.onreadystatechange && t3.onreadystatechange.call(t3);
-}
-(Sf = bg.prototype).open = function(t3, e2) {
-    if (this.readyState != _g)
-        throw this.abort(), Error("Error reopening a connection");
-    this.C = t3, this.B = e2, this.readyState = 1, kg(this);
-}, Sf.send = function(t3) {
-    if (1 != this.readyState)
-        throw this.abort(), Error("need to call open() first. ");
-    this.g = true;
-    const e2 = {
-        headers: this.v,
-        method: this.C,
-        credentials: this.m,
-        cache: void 0
-    };
-    t3 && (e2.body = t3), (this.F || If).fetch(new Request(this.B, e2)).then(this.$a.bind(this), this.ka.bind(this));
-}, Sf.abort = function() {
-    this.response = this.responseText = "", this.v = new Headers(), this.status = 0, this.j && this.j.cancel("Request was aborted.").catch(() => {}), 1 <= this.readyState && this.g && 4 != this.readyState && (this.g = false, xg(this)), this.readyState = _g;
-}, Sf.$a = function(t3) {
-    if (this.g && (this.l = t3, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = t3.headers, this.readyState = 2, kg(this)), this.g && (this.readyState = 3, kg(this), this.g)))
-        if ("arraybuffer" === this.responseType)
-            t3.arrayBuffer().then(this.Ya.bind(this), this.ka.bind(this));
-        else if (void 0 !== If.ReadableStream && "body" in t3) {
-        if (this.j = t3.body.getReader(), this.u) {
-            if (this.responseType)
-                throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');
-            this.response = [];
-        } else
-            this.response = this.responseText = "", this.A = new TextDecoder();
-        wg(this);
-    } else
-        t3.text().then(this.Za.bind(this), this.ka.bind(this));
-}, Sf.Xa = function(t3) {
-    if (this.g) {
-        if (this.u && t3.value)
-            this.response.push(t3.value);
-        else if (!this.u) {
-            var e2 = t3.value ? t3.value : new Uint8Array(0);
-            (e2 = this.A.decode(e2, {
-                stream: !t3.done
-            })) && (this.response = this.responseText += e2);
-        }
-        t3.done ? xg(this) : kg(this), 3 == this.readyState && wg(this);
-    }
-}, Sf.Za = function(t3) {
-    this.g && (this.response = this.responseText = t3, xg(this));
-}, Sf.Ya = function(t3) {
-    this.g && (this.response = t3, xg(this));
-}, Sf.ka = function() {
-    this.g && xg(this);
-}, Sf.setRequestHeader = function(t3, e2) {
-    this.v.append(t3, e2);
-}, Sf.getResponseHeader = function(t3) {
-    return this.h && this.h.get(t3.toLowerCase()) || "";
-}, Sf.getAllResponseHeaders = function() {
-    if (!this.h)
-        return "";
-    const t3 = [],
-        e2 = this.h.entries();
-    for (var i2 = e2.next(); !i2.done;)
-        i2 = i2.value, t3.push(i2[0] + ": " + i2[1]), i2 = e2.next();
-    return t3.join("\r\n");
-}, Object.defineProperty(bg.prototype, "withCredentials", {
-    get: function() {
-        return "include" === this.m;
-    },
-    set: function(t3) {
-        this.m = t3 ? "include" : "same-origin";
-    }
-});
-var Tg = If.JSON.parse;
-
-function Sg(t3) {
-    Dp.call(this), this.headers = /* @__PURE__ */ new Map(), this.u = t3 || null, this.h = false, this.C = this.g = null, this.I = "", this.m = 0, this.j = "", this.l = this.G = this.v = this.F = false, this.B = 0, this.A = null, this.K = Eg, this.L = this.M = false;
-}
-Nf(Sg, Dp);
-var Eg = "",
-    Cg = /^https?$/i,
-    Ig = ["POST", "PUT"];
-
-function Mg(t3, e2) {
-    t3.h = false, t3.g && (t3.l = true, t3.g.abort(), t3.l = false), t3.j = e2, t3.m = 5, Pg(t3), Ag(t3);
-}
-
-function Pg(t3) {
-    t3.F || (t3.F = true, Lp(t3, "complete"), Lp(t3, "error"));
-}
-
-function Rg(t3) {
-    if (t3.h && void 0 !== Cf && (!t3.C[1] || 4 != Lg(t3) || 2 != t3.da())) {
-        if (t3.v && 4 == Lg(t3))
-            Gp(t3.La, 0, t3);
-        else if (Lp(t3, "readystatechange"), 4 == Lg(t3)) {
-            t3.h = false;
-            try {
-                const o2 = t3.da();
-                t:
-                    switch (o2) {
-                        case 200:
-                        case 201:
-                        case 202:
-                        case 204:
-                        case 206:
-                        case 304:
-                        case 1223:
-                            var e2 = true;
-                            break t;
-                        default:
-                            e2 = false;
-                    }
-                var i2;
-                if (!(i2 = e2)) {
-                    var s2;
-                    if (s2 = 0 === o2) {
-                        var n2 = String(t3.I).match($m)[1] || null;
-                        !n2 && If.self && If.self.location && (n2 = If.self.location.protocol.slice(0, -1)), s2 = !Cg.test(n2 ? n2.toLowerCase() : "");
-                    }
-                    i2 = s2;
-                }
-                if (i2)
-                    Lp(t3, "complete"), Lp(t3, "success");
-                else {
-                    t3.m = 6;
-                    try {
-                        var r2 = 2 < Lg(t3) ? t3.g.statusText : "";
-                    } catch (t4) {
-                        r2 = "";
-                    }
-                    t3.j = r2 + " [" + t3.da() + "]", Pg(t3);
-                }
-            } finally {
-                Ag(t3);
-            }
-        }
-    }
-}
-
-function Ag(t3, e2) {
-    if (t3.g) {
-        Dg(t3);
-        const i2 = t3.g,
-            s2 = t3.C[0] ? () => {} : null;
-        t3.g = null, t3.C = null, e2 || Lp(t3, "ready");
-        try {
-            i2.onreadystatechange = s2;
-        } catch (t4) {}
-    }
-}
-
-function Dg(t3) {
-    t3.g && t3.L && (t3.g.ontimeout = null), t3.A && (If.clearTimeout(t3.A), t3.A = null);
-}
-
-function Lg(t3) {
-    return t3.g ? t3.g.readyState : 0;
-}
-
-function Og(t3) {
-    try {
-        if (!t3.g)
-            return null;
-        if ("response" in t3.g)
-            return t3.g.response;
-        switch (t3.K) {
-            case Eg:
-            case "text":
-                return t3.g.responseText;
-            case "arraybuffer":
-                if ("mozResponseArrayBuffer" in t3.g)
-                    return t3.g.mozResponseArrayBuffer;
-        }
-        return null;
-    } catch (t4) {
-        return null;
-    }
-}
-
-function Fg(t3) {
-    let e2 = "";
-    return pp(t3, function(t4, i2) {
-        e2 += i2, e2 += ":", e2 += t4, e2 += "\r\n";
-    }), e2;
-}
-
-function Ng(t3, e2, i2) {
-    t: {
-        for (s2 in i2) {
-            var s2 = false;
-            break t;
-        }
-        s2 = true;
-    }
-    s2 || (i2 = Fg(i2), "string" == typeof t3 ? null != i2 && encodeURIComponent(String(i2)) : Hm(t3, e2, i2));
-}
-
-function $g(t3, e2, i2) {
-    return i2 && i2.internalChannelParams && i2.internalChannelParams[t3] || e2;
-}
-
-function Vg(t3) {
-    this.Ga = 0, this.j = [], this.l = new tm(), this.pa = this.wa = this.I = this.Y = this.g = this.Da = this.F = this.na = this.o = this.U = this.s = null, this.fb = this.W = 0, this.cb = $g("failFast", false, t3), this.G = this.v = this.u = this.m = this.h = null, this.aa = true, this.Fa = this.V = -1, this.ba = this.A = this.C = 0, this.ab = $g("baseRetryDelayMs", 5e3, t3), this.hb = $g("retryDelaySeedMs", 1e4, t3), this.eb = $g("forwardChannelMaxRetries", 2, t3), this.xa = $g("forwardChannelRequestTimeoutMs", 2e4, t3), this.va = t3 && t3.xmlHttpFactory || void 0, this.Ha = t3 && t3.dc || false, this.L = void 0, this.J = t3 && t3.supportsCrossDomainXhr || false, this.K = "", this.i = new og(t3 && t3.concurrentRequestLimit), this.Ja = new mg(), this.P = t3 && t3.fastHandshake || false, this.O = t3 && t3.encodeInitMessageHeaders || false, this.P && this.O && (this.O = false), this.bb = t3 && t3.bc || false, t3 && t3.Ea && this.l.Ea(), t3 && t3.forceLongPolling && (this.aa = false), this.ca = !this.P && this.aa && t3 && t3.detectBufferingProxy || false, this.qa = void 0, t3 && t3.longPollingTimeout && 0 < t3.longPollingTimeout && (this.qa = t3.longPollingTimeout), this.oa = void 0, this.S = 0, this.M = false, this.ma = this.B = null;
-}
-
-function zg(t3) {
-    if (Ug(t3), 3 == t3.H) {
-        var e2 = t3.W++,
-            i2 = zm(t3.I);
-        if (Hm(i2, "SID", t3.K), Hm(i2, "RID", e2), Hm(i2, "TYPE", "terminate"), Wg(t3, i2), (e2 = new wm(t3, t3.l, e2)).L = 2, e2.v = Wm(zm(i2)), i2 = false, If.navigator && If.navigator.sendBeacon)
-            try {
-                i2 = If.navigator.sendBeacon(e2.v.toString(), "");
-            } catch (t4) {}!i2 && If.Image && (new Image().src = e2.v, i2 = true), i2 || (e2.g = sy(e2.l, null), e2.g.ha(e2.v)), e2.G = Date.now(), Rm(e2);
-    }
-    ey(t3);
-}
-
-function Bg(t3) {
-    t3.g && (Yg(t3), t3.g.cancel(), t3.g = null);
-}
-
-function Ug(t3) {
-    Bg(t3), t3.u && (If.clearTimeout(t3.u), t3.u = null), Xg(t3), t3.i.cancel(), t3.m && ("number" == typeof t3.m && If.clearTimeout(t3.m), t3.m = null);
-}
-
-function jg(t3) {
-    if (!lg(t3.i) && !t3.m) {
-        t3.m = true;
-        var e2 = t3.Na;
-        Bp || Hp(), Up || (Bp(), Up = true), jp.add(e2, t3), t3.C = 0;
-    }
-}
-
-function Hg(t3, e2) {
-    var i2;
-    i2 = e2 ? e2.m : t3.W++;
-    const s2 = zm(t3.I);
-    Hm(s2, "SID", t3.K), Hm(s2, "RID", i2), Hm(s2, "AID", t3.V), Wg(t3, s2), t3.o && t3.s && Ng(s2, t3.o, t3.s), i2 = new wm(t3, t3.l, i2, t3.C + 1), null === t3.o && (i2.I = t3.s), e2 && (t3.j = e2.F.concat(t3.j)), e2 = qg(t3, i2, 1e3), i2.setTimeout(Math.round(0.5 * t3.xa) + Math.round(0.5 * t3.xa * Math.random())), ug(t3.i, i2), Em(i2, s2, e2);
-}
-
-function Wg(t3, e2) {
-    t3.na && pp(t3.na, function(t4, i2) {
-        Hm(e2, i2, t4);
-    }), t3.h && Nm({}, function(t4, i2) {
-        Hm(e2, i2, t4);
-    });
-}
-
-function qg(t3, e2, i2) {
-    i2 = Math.min(t3.j.length, i2);
-    var s2 = t3.h ? Of(t3.h.Va, t3.h, t3) : null;
-    t: {
-        var n2 = t3.j;
-        let e3 = -1;
-        for (;;) {
-            const t4 = ["count=" + i2]; -
-            1 == e3 ? 0 < i2 ? (e3 = n2[0].g, t4.push("ofs=" + e3)) : e3 = 0 : t4.push("ofs=" + e3);
-            let r2 = true;
-            for (let o2 = 0; o2 < i2; o2++) {
-                let i3 = n2[o2].g;
-                const a2 = n2[o2].map;
-                if (i3 -= e3, 0 > i3)
-                    e3 = Math.max(0, n2[o2].g - 100), r2 = false;
-                else
-                    try {
-                        gg(a2, t4, "req" + i3 + "_");
-                    } catch (t5) {
-                        s2 && s2(a2);
-                    }
-            }
-            if (r2) {
-                s2 = t4.join("&");
-                break t;
-            }
-        }
-    }
-    return t3 = t3.j.splice(0, i2), e2.F = t3, s2;
-}
-
-function Kg(t3) {
-    if (!t3.g && !t3.u) {
-        t3.ba = 1;
-        var e2 = t3.Ma;
-        Bp || Hp(), Up || (Bp(), Up = true), jp.add(e2, t3), t3.A = 0;
-    }
-}
-
-function Gg(t3) {
-    return !(t3.g || t3.u || 3 <= t3.A) && (t3.ba++, t3.u = cm(Of(t3.Ma, t3), Zg(t3, t3.A)), t3.A++, true);
-}
-
-function Yg(t3) {
-    null != t3.B && (If.clearTimeout(t3.B), t3.B = null);
-}
-
-function Qg(t3) {
-    t3.g = new wm(t3, t3.l, "rpc", t3.ba), null === t3.o && (t3.g.I = t3.s), t3.g.O = 0;
-    var e2 = zm(t3.wa);
-    Hm(e2, "RID", "rpc"), Hm(e2, "SID", t3.K), Hm(e2, "AID", t3.V), Hm(e2, "CI", t3.G ? "0" : "1"), !t3.G && t3.qa && Hm(e2, "TO", t3.qa), Hm(e2, "TYPE", "xmlhttp"), Wg(t3, e2), t3.o && t3.s && Ng(e2, t3.o, t3.s), t3.L && t3.g.setTimeout(t3.L);
-    var i2 = t3.g;
-    t3 = t3.pa, i2.L = 1, i2.v = Wm(zm(e2)), i2.s = null, i2.S = true, Cm(i2, t3);
-}
-
-function Xg(t3) {
-    null != t3.v && (If.clearTimeout(t3.v), t3.v = null);
-}
-
-function Jg(t3, e2) {
-    var i2 = null;
-    if (t3.g == e2) {
-        Xg(t3), Yg(t3), t3.g = null;
-        var s2 = 2;
-    } else {
-        if (!cg(t3.i, e2))
-            return;
-        i2 = e2.F, dg(t3.i, e2), s2 = 1;
-    }
-    if (0 != t3.H) {
-        if (e2.i)
-            if (1 == s2) {
-                i2 = e2.s ? e2.s.length : 0, e2 = Date.now() - e2.G;
-                var n2 = t3.C;
-                Lp(s2 = nm(), new hm(s2, i2)), jg(t3);
-            } else
-                Kg(t3);
-        else if (3 == (n2 = e2.o) || 0 == n2 && 0 < e2.ca || !(1 == s2 && function(t4, e3) {
-                return !(hg(t4.i) >= t4.i.j - (t4.m ? 1 : 0) || (t4.m ? (t4.j = e3.F.concat(t4.j), 0) : 1 == t4.H || 2 == t4.H || t4.C >= (t4.cb ? 0 : t4.eb) || (t4.m = cm(Of(t4.Na, t4, e3), Zg(t4, t4.C)), t4.C++, 0)));
-            }(t3, e2) || 2 == s2 && Gg(t3)))
-            switch (i2 && 0 < i2.length && (e2 = t3.i, e2.i = e2.i.concat(i2)), n2) {
-                case 1:
-                    ty(t3, 5);
-                    break;
-                case 4:
-                    ty(t3, 10);
-                    break;
-                case 3:
-                    ty(t3, 6);
-                    break;
-                default:
-                    ty(t3, 2);
-            }
-    }
-}
-
-function Zg(t3, e2) {
-    let i2 = t3.ab + Math.floor(Math.random() * t3.hb);
-    return t3.isActive() || (i2 *= 2), i2 * e2;
-}
-
-function ty(t3, e2) {
-    if (t3.l.info("Error code " + e2), 2 == e2) {
-        var i2 = null;
-        t3.h && (i2 = null);
-        var s2 = Of(t3.pb, t3);
-        i2 || (i2 = new Vm("//www.google.com/images/cleardot.gif"), If.location && "http" == If.location.protocol || Bm(i2, "https"), Wm(i2)),
-            function(t4, e3) {
-                const i3 = new tm();
-                if (If.Image) {
-                    const s3 = new Image();
-                    s3.onload = Ff(yg, i3, s3, "TestLoadImage: loaded", true, e3), s3.onerror = Ff(yg, i3, s3, "TestLoadImage: error", false, e3), s3.onabort = Ff(yg, i3, s3, "TestLoadImage: abort", false, e3), s3.ontimeout = Ff(yg, i3, s3, "TestLoadImage: timeout", false, e3), If.setTimeout(function() {
-                        s3.ontimeout && s3.ontimeout();
-                    }, 1e4), s3.src = t4;
-                } else
-                    e3(false);
-            }(i2.toString(), s2);
-    } else
-        lm(2);
-    t3.H = 0, t3.h && t3.h.za(e2), ey(t3), Ug(t3);
-}
-
-function ey(t3) {
-    if (t3.H = 0, t3.ma = [], t3.h) {
-        const e2 = fg(t3.i);
-        0 == e2.length && 0 == t3.j.length || (Bf(t3.ma, e2), Bf(t3.ma, t3.j), t3.i.i.length = 0, zf(t3.j), t3.j.length = 0), t3.h.ya();
-    }
-}
-
-function iy(t3, e2, i2) {
-    var s2 = i2 instanceof Vm ? zm(i2) : new Vm(i2);
-    if ("" != s2.g)
-        e2 && (s2.g = e2 + "." + s2.g), Um(s2, s2.m);
-    else {
-        var n2 = If.location;
-        s2 = n2.protocol, e2 = e2 ? e2 + "." + n2.hostname : n2.hostname, n2 = +n2.port;
-        var r2 = new Vm(null);
-        s2 && Bm(r2, s2), e2 && (r2.g = e2), n2 && Um(r2, n2), i2 && (r2.l = i2), s2 = r2;
-    }
-    return i2 = t3.F, e2 = t3.Da, i2 && e2 && Hm(s2, i2, e2), Hm(s2, "VER", t3.ra), Wg(t3, s2), s2;
-}
-
-function sy(t3, e2, i2) {
-    if (e2 && !t3.J)
-        throw Error("Can't create secondary domain capable XhrIo object.");
-    return (e2 = i2 && t3.Ha && !t3.va ? new Sg(new vg({
-        ob: true
-    })) : new Sg(t3.va)).Oa(t3.J), e2;
-}
-
-function ny() {}
-
-function ry() {
-    if (Xf && !(10 <= Number(ap)))
-        throw Error("Environmental error: no available transport.");
-}
-
-function oy(t3, e2) {
-    Dp.call(this), this.g = new Vg(e2), this.l = t3, this.h = e2 && e2.messageUrlParams || null, t3 = e2 && e2.messageHeaders || null, e2 && e2.clientProtocolHeaderRequired && (t3 ? t3["X-Client-Protocol"] = "webchannel" : t3 = {
-        "X-Client-Protocol": "webchannel"
-    }), this.g.s = t3, t3 = e2 && e2.initMessageHeaders || null, e2 && e2.messageContentType && (t3 ? t3["X-WebChannel-Content-Type"] = e2.messageContentType : t3 = {
-        "X-WebChannel-Content-Type": e2.messageContentType
-    }), e2 && e2.Ca && (t3 ? t3["X-WebChannel-Client-Profile"] = e2.Ca : t3 = {
-        "X-WebChannel-Client-Profile": e2.Ca
-    }), this.g.U = t3, (t3 = e2 && e2.cc) && !Hf(t3) && (this.g.o = t3), this.A = e2 && e2.supportsCrossDomainXhr || false, this.v = e2 && e2.sendRawJson || false, (e2 = e2 && e2.httpSessionIdParam) && !Hf(e2) && (this.g.F = e2, null !== (t3 = this.h) && e2 in t3 && (e2 in (t3 = this.h) && delete t3[e2])), this.j = new hy(this);
-}
-
-function ay(t3) {
-    vm.call(this), t3.__headers__ && (this.headers = t3.__headers__, this.statusCode = t3.__status__, delete t3.__headers__, delete t3.__status__);
-    var e2 = t3.__sm__;
-    if (e2) {
-        t: {
-            for (const i2 in e2) {
-                t3 = i2;
-                break t;
-            }
-            t3 = void 0;
-        }
-        (this.i = t3) && (t3 = this.i, e2 = null !== e2 && t3 in e2 ? e2[t3] : void 0),
-        this.data = e2;
-    }
-    else
-        this.data = t3;
-}
-
-function ly() {
-    bm.call(this), this.status = 1;
-}
-
-function hy(t3) {
-    this.g = t3;
-}
-
-function cy() {
-    this.blockSize = -1, this.blockSize = 64, this.g = Array(4), this.m = Array(this.blockSize), this.i = this.h = 0, this.reset();
-}
-
-function uy(t3, e2, i2) {
-    i2 || (i2 = 0);
-    var s2 = Array(16);
-    if ("string" == typeof e2)
-        for (var n2 = 0; 16 > n2; ++n2)
-            s2[n2] = e2.charCodeAt(i2++) | e2.charCodeAt(i2++) << 8 | e2.charCodeAt(i2++) << 16 | e2.charCodeAt(i2++) << 24;
-    else
-        for (n2 = 0; 16 > n2; ++n2)
-            s2[n2] = e2[i2++] | e2[i2++] << 8 | e2[i2++] << 16 | e2[i2++] << 24;
-    e2 = t3.g[0], i2 = t3.g[1], n2 = t3.g[2];
-    var r2 = t3.g[3],
-        o2 = e2 + (r2 ^ i2 & (n2 ^ r2)) + s2[0] + 3614090360 & 4294967295;
-    o2 = (i2 = (n2 = (r2 = (e2 = (i2 = (n2 = (r2 = (e2 = (i2 = (n2 = (r2 = (e2 = (i2 = (n2 = (r2 = (e2 = (i2 = (n2 = (r2 = (e2 = (i2 = (n2 = (r2 = (e2 = (i2 = (n2 = (r2 = (e2 = (i2 = (n2 = (r2 = (e2 = (i2 = (n2 = (r2 = (e2 = (i2 = (n2 = (r2 = (e2 = (i2 = (n2 = (r2 = (e2 = (i2 = (n2 = (r2 = (e2 = (i2 = (n2 = (r2 = (e2 = (i2 = (n2 = (r2 = (e2 = (i2 = (n2 = (r2 = (e2 = i2 + (o2 << 7 & 4294967295 | o2 >>> 25)) + ((o2 = r2 + (n2 ^ e2 & (i2 ^ n2)) + s2[1] + 3905402710 & 4294967295) << 12 & 4294967295 | o2 >>> 20)) + ((o2 = n2 + (i2 ^ r2 & (e2 ^ i2)) + s2[2] + 606105819 & 4294967295) << 17 & 4294967295 | o2 >>> 15)) + ((o2 = i2 + (e2 ^ n2 & (r2 ^ e2)) + s2[3] + 3250441966 & 4294967295) << 22 & 4294967295 | o2 >>> 10)) + ((o2 = e2 + (r2 ^ i2 & (n2 ^ r2)) + s2[4] + 4118548399 & 4294967295) << 7 & 4294967295 | o2 >>> 25)) + ((o2 = r2 + (n2 ^ e2 & (i2 ^ n2)) + s2[5] + 1200080426 & 4294967295) << 12 & 4294967295 | o2 >>> 20)) + ((o2 = n2 + (i2 ^ r2 & (e2 ^ i2)) + s2[6] + 2821735955 & 4294967295) << 17 & 4294967295 | o2 >>> 15)) + ((o2 = i2 + (e2 ^ n2 & (r2 ^ e2)) + s2[7] + 4249261313 & 4294967295) << 22 & 4294967295 | o2 >>> 10)) + ((o2 = e2 + (r2 ^ i2 & (n2 ^ r2)) + s2[8] + 1770035416 & 4294967295) << 7 & 4294967295 | o2 >>> 25)) + ((o2 = r2 + (n2 ^ e2 & (i2 ^ n2)) + s2[9] + 2336552879 & 4294967295) << 12 & 4294967295 | o2 >>> 20)) + ((o2 = n2 + (i2 ^ r2 & (e2 ^ i2)) + s2[10] + 4294925233 & 4294967295) << 17 & 4294967295 | o2 >>> 15)) + ((o2 = i2 + (e2 ^ n2 & (r2 ^ e2)) + s2[11] + 2304563134 & 4294967295) << 22 & 4294967295 | o2 >>> 10)) + ((o2 = e2 + (r2 ^ i2 & (n2 ^ r2)) + s2[12] + 1804603682 & 4294967295) << 7 & 4294967295 | o2 >>> 25)) + ((o2 = r2 + (n2 ^ e2 & (i2 ^ n2)) + s2[13] + 4254626195 & 4294967295) << 12 & 4294967295 | o2 >>> 20)) + ((o2 = n2 + (i2 ^ r2 & (e2 ^ i2)) + s2[14] + 2792965006 & 4294967295) << 17 & 4294967295 | o2 >>> 15)) + ((o2 = i2 + (e2 ^ n2 & (r2 ^ e2)) + s2[15] + 1236535329 & 4294967295) << 22 & 4294967295 | o2 >>> 10)) + ((o2 = e2 + (n2 ^ r2 & (i2 ^ n2)) + s2[1] + 4129170786 & 4294967295) << 5 & 4294967295 | o2 >>> 27)) + ((o2 = r2 + (i2 ^ n2 & (e2 ^ i2)) + s2[6] + 3225465664 & 4294967295) << 9 & 4294967295 | o2 >>> 23)) + ((o2 = n2 + (e2 ^ i2 & (r2 ^ e2)) + s2[11] + 643717713 & 4294967295) << 14 & 4294967295 | o2 >>> 18)) + ((o2 = i2 + (r2 ^ e2 & (n2 ^ r2)) + s2[0] + 3921069994 & 4294967295) << 20 & 4294967295 | o2 >>> 12)) + ((o2 = e2 + (n2 ^ r2 & (i2 ^ n2)) + s2[5] + 3593408605 & 4294967295) << 5 & 4294967295 | o2 >>> 27)) + ((o2 = r2 + (i2 ^ n2 & (e2 ^ i2)) + s2[10] + 38016083 & 4294967295) << 9 & 4294967295 | o2 >>> 23)) + ((o2 = n2 + (e2 ^ i2 & (r2 ^ e2)) + s2[15] + 3634488961 & 4294967295) << 14 & 4294967295 | o2 >>> 18)) + ((o2 = i2 + (r2 ^ e2 & (n2 ^ r2)) + s2[4] + 3889429448 & 4294967295) << 20 & 4294967295 | o2 >>> 12)) + ((o2 = e2 + (n2 ^ r2 & (i2 ^ n2)) + s2[9] + 568446438 & 4294967295) << 5 & 4294967295 | o2 >>> 27)) + ((o2 = r2 + (i2 ^ n2 & (e2 ^ i2)) + s2[14] + 3275163606 & 4294967295) << 9 & 4294967295 | o2 >>> 23)) + ((o2 = n2 + (e2 ^ i2 & (r2 ^ e2)) + s2[3] + 4107603335 & 4294967295) << 14 & 4294967295 | o2 >>> 18)) + ((o2 = i2 + (r2 ^ e2 & (n2 ^ r2)) + s2[8] + 1163531501 & 4294967295) << 20 & 4294967295 | o2 >>> 12)) + ((o2 = e2 + (n2 ^ r2 & (i2 ^ n2)) + s2[13] + 2850285829 & 4294967295) << 5 & 4294967295 | o2 >>> 27)) + ((o2 = r2 + (i2 ^ n2 & (e2 ^ i2)) + s2[2] + 4243563512 & 4294967295) << 9 & 4294967295 | o2 >>> 23)) + ((o2 = n2 + (e2 ^ i2 & (r2 ^ e2)) + s2[7] + 1735328473 & 4294967295) << 14 & 4294967295 | o2 >>> 18)) + ((o2 = i2 + (r2 ^ e2 & (n2 ^ r2)) + s2[12] + 2368359562 & 4294967295) << 20 & 4294967295 | o2 >>> 12)) + ((o2 = e2 + (i2 ^ n2 ^ r2) + s2[5] + 4294588738 & 4294967295) << 4 & 4294967295 | o2 >>> 28)) + ((o2 = r2 + (e2 ^ i2 ^ n2) + s2[8] + 2272392833 & 4294967295) << 11 & 4294967295 | o2 >>> 21)) + ((o2 = n2 + (r2 ^ e2 ^ i2) + s2[11] + 1839030562 & 4294967295) << 16 & 4294967295 | o2 >>> 16)) + ((o2 = i2 + (n2 ^ r2 ^ e2) + s2[14] + 4259657740 & 4294967295) << 23 & 4294967295 | o2 >>> 9)) + ((o2 = e2 + (i2 ^ n2 ^ r2) + s2[1] + 2763975236 & 4294967295) << 4 & 4294967295 | o2 >>> 28)) + ((o2 = r2 + (e2 ^ i2 ^ n2) + s2[4] + 1272893353 & 4294967295) << 11 & 4294967295 | o2 >>> 21)) + ((o2 = n2 + (r2 ^ e2 ^ i2) + s2[7] + 4139469664 & 4294967295) << 16 & 4294967295 | o2 >>> 16)) + ((o2 = i2 + (n2 ^ r2 ^ e2) + s2[10] + 3200236656 & 4294967295) << 23 & 4294967295 | o2 >>> 9)) + ((o2 = e2 + (i2 ^ n2 ^ r2) + s2[13] + 681279174 & 4294967295) << 4 & 4294967295 | o2 >>> 28)) + ((o2 = r2 + (e2 ^ i2 ^ n2) + s2[0] + 3936430074 & 4294967295) << 11 & 4294967295 | o2 >>> 21)) + ((o2 = n2 + (r2 ^ e2 ^ i2) + s2[3] + 3572445317 & 4294967295) << 16 & 4294967295 | o2 >>> 16)) + ((o2 = i2 + (n2 ^ r2 ^ e2) + s2[6] + 76029189 & 4294967295) << 23 & 4294967295 | o2 >>> 9)) + ((o2 = e2 + (i2 ^ n2 ^ r2) + s2[9] + 3654602809 & 4294967295) << 4 & 4294967295 | o2 >>> 28)) + ((o2 = r2 + (e2 ^ i2 ^ n2) + s2[12] + 3873151461 & 4294967295) << 11 & 4294967295 | o2 >>> 21)) + ((o2 = n2 + (r2 ^ e2 ^ i2) + s2[15] + 530742520 & 4294967295) << 16 & 4294967295 | o2 >>> 16)) + ((o2 = i2 + (n2 ^ r2 ^ e2) + s2[2] + 3299628645 & 4294967295) << 23 & 4294967295 | o2 >>> 9)) + ((o2 = e2 + (n2 ^ (i2 | ~r2)) + s2[0] + 4096336452 & 4294967295) << 6 & 4294967295 | o2 >>> 26)) + ((o2 = r2 + (i2 ^ (e2 | ~n2)) + s2[7] + 1126891415 & 4294967295) << 10 & 4294967295 | o2 >>> 22)) + ((o2 = n2 + (e2 ^ (r2 | ~i2)) + s2[14] + 2878612391 & 4294967295) << 15 & 4294967295 | o2 >>> 17)) + ((o2 = i2 + (r2 ^ (n2 | ~e2)) + s2[5] + 4237533241 & 4294967295) << 21 & 4294967295 | o2 >>> 11)) + ((o2 = e2 + (n2 ^ (i2 | ~r2)) + s2[12] + 1700485571 & 4294967295) << 6 & 4294967295 | o2 >>> 26)) + ((o2 = r2 + (i2 ^ (e2 | ~n2)) + s2[3] + 2399980690 & 4294967295) << 10 & 4294967295 | o2 >>> 22)) + ((o2 = n2 + (e2 ^ (r2 | ~i2)) + s2[10] + 4293915773 & 4294967295) << 15 & 4294967295 | o2 >>> 17)) + ((o2 = i2 + (r2 ^ (n2 | ~e2)) + s2[1] + 2240044497 & 4294967295) << 21 & 4294967295 | o2 >>> 11)) + ((o2 = e2 + (n2 ^ (i2 | ~r2)) + s2[8] + 1873313359 & 4294967295) << 6 & 4294967295 | o2 >>> 26)) + ((o2 = r2 + (i2 ^ (e2 | ~n2)) + s2[15] + 4264355552 & 4294967295) << 10 & 4294967295 | o2 >>> 22)) + ((o2 = n2 + (e2 ^ (r2 | ~i2)) + s2[6] + 2734768916 & 4294967295) << 15 & 4294967295 | o2 >>> 17)) + ((o2 = i2 + (r2 ^ (n2 | ~e2)) + s2[13] + 1309151649 & 4294967295) << 21 & 4294967295 | o2 >>> 11)) + ((r2 = (e2 = i2 + ((o2 = e2 + (n2 ^ (i2 | ~r2)) + s2[4] + 4149444226 & 4294967295) << 6 & 4294967295 | o2 >>> 26)) + ((o2 = r2 + (i2 ^ (e2 | ~n2)) + s2[11] + 3174756917 & 4294967295) << 10 & 4294967295 | o2 >>> 22)) ^ ((n2 = r2 + ((o2 = n2 + (e2 ^ (r2 | ~i2)) + s2[2] + 718787259 & 4294967295) << 15 & 4294967295 | o2 >>> 17)) | ~e2)) + s2[9] + 3951481745 & 4294967295, t3.g[0] = t3.g[0] + e2 & 4294967295, t3.g[1] = t3.g[1] + (n2 + (o2 << 21 & 4294967295 | o2 >>> 11)) & 4294967295, t3.g[2] = t3.g[2] + n2 & 4294967295, t3.g[3] = t3.g[3] + r2 & 4294967295;
-}
-
-function dy(t3, e2) {
-    this.h = e2;
-    for (var i2 = [], s2 = true, n2 = t3.length - 1; 0 <= n2; n2--) {
-        var r2 = 0 | t3[n2];
-        s2 && r2 == e2 || (i2[n2] = r2, s2 = false);
-    }
-    this.g = i2;
-}
-(Sf = Sg.prototype).Oa = function(t3) {
-    this.M = t3;
-}, Sf.ha = function(t3, e2, i2, s2) {
-    if (this.g)
-        throw Error("[goog.net.XhrIo] Object is active with another request=" + this.I + "; newUri=" + t3);
-    e2 = e2 ? e2.toUpperCase() : "GET", this.I = t3, this.j = "", this.m = 0, this.F = false, this.h = true, this.g = this.u ? this.u.g() : gm.g(), this.C = this.u ? pm(this.u) : pm(gm), this.g.onreadystatechange = Of(this.La, this);
-    try {
-        this.G = true, this.g.open(e2, String(t3), true), this.G = false;
-    } catch (t4) {
-        return void Mg(this, t4);
-    }
-    if (t3 = i2 || "", i2 = new Map(this.headers), s2)
-        if (Object.getPrototypeOf(s2) === Object.prototype)
-            for (var n2 in s2)
-                i2.set(n2, s2[n2]);
-        else {
-            if ("function" != typeof s2.keys || "function" != typeof s2.get)
-                throw Error("Unknown input type for opt_headers: " + String(s2));
-            for (const t4 of s2.keys())
-                i2.set(t4, s2.get(t4));
-        }
-    s2 = Array.from(i2.keys()).find((t4) => "content-type" == t4.toLowerCase()), n2 = If.FormData && t3 instanceof If.FormData, !(0 <= Vf(Ig, e2)) || s2 || n2 || i2.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
-    for (const [t4, e3] of i2)
-        this.g.setRequestHeader(t4, e3);
-    this.K && (this.g.responseType = this.K), "withCredentials" in this.g && this.g.withCredentials !== this.M && (this.g.withCredentials = this.M);
-    try {
-        Dg(this), 0 < this.B && ((this.L = function(t4) {
-            return Xf && "number" == typeof t4.timeout && void 0 !== t4.ontimeout;
-        }(this.g)) ? (this.g.timeout = this.B, this.g.ontimeout = Of(this.ua, this)) : this.A = Gp(this.ua, this.B, this)), this.v = true, this.g.send(t3), this.v = false;
-    } catch (t4) {
-        Mg(this, t4);
-    }
-}, Sf.ua = function() {
-    void 0 !== Cf && this.g && (this.j = "Timed out after " + this.B + "ms, aborting", this.m = 8, Lp(this, "timeout"), this.abort(8));
-}, Sf.abort = function(t3) {
-    this.g && this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false, this.m = t3 || 7, Lp(this, "complete"), Lp(this, "abort"), Ag(this));
-}, Sf.N = function() {
-    this.g && (this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false), Ag(this, true)), Sg.$.N.call(this);
-}, Sf.La = function() {
-    this.s || (this.G || this.v || this.l ? Rg(this) : this.kb());
-}, Sf.kb = function() {
-    Rg(this);
-}, Sf.isActive = function() {
-    return !!this.g;
-}, Sf.da = function() {
-    try {
-        return 2 < Lg(this) ? this.g.status : -1;
-    } catch (t3) {
-        return -1;
-    }
-}, Sf.ja = function() {
-    try {
-        return this.g ? this.g.responseText : "";
-    } catch (t3) {
-        return "";
-    }
-}, Sf.Wa = function(t3) {
-    if (this.g) {
-        var e2 = this.g.responseText;
-        return t3 && 0 == e2.indexOf(t3) && (e2 = e2.substring(t3.length)), Tg(e2);
-    }
-}, Sf.Ia = function() {
-    return this.m;
-}, Sf.Sa = function() {
-    return "string" == typeof this.j ? this.j : String(this.j);
-}, (Sf = Vg.prototype).ra = 8, Sf.H = 1, Sf.Na = function(t3) {
-    if (this.m)
-        if (this.m = null, 1 == this.H) {
-            if (!t3) {
-                this.W = Math.floor(1e5 * Math.random()), t3 = this.W++;
-                const n2 = new wm(this, this.l, t3);
-                let r2 = this.s;
-                if (this.U && (r2 ? (r2 = mp(r2), yp(r2, this.U)) : r2 = this.U), null !== this.o || this.O || (n2.I = r2, r2 = null), this.P)
-                    t: {
-                        for (var e2 = 0, i2 = 0; i2 < this.j.length; i2++) {
-                            var s2 = this.j[i2];
-                            if (void 0 === (s2 = "__data__" in s2.map && "string" == typeof(s2 = s2.map.__data__) ? s2.length : void 0))
-                                break;
-                            if (4096 < (e2 += s2)) {
-                                e2 = i2;
-                                break t;
-                            }
-                            if (4096 === e2 || i2 === this.j.length - 1) {
-                                e2 = i2 + 1;
-                                break t;
-                            }
-                        }
-                        e2 = 1e3;
-                    }
-                else
-                    e2 = 1e3;
-                e2 = qg(this, n2, e2), Hm(i2 = zm(this.I), "RID", t3), Hm(i2, "CVER", 22), this.F && Hm(i2, "X-HTTP-Session-Id", this.F), Wg(this, i2), r2 && (this.O ? e2 = "headers=" + encodeURIComponent(String(Fg(r2))) + "&" + e2 : this.o && Ng(i2, this.o, r2)), ug(this.i, n2), this.bb && Hm(i2, "TYPE", "init"), this.P ? (Hm(i2, "$req", e2), Hm(i2, "SID", "null"), n2.aa = true, Em(n2, i2, null)) : Em(n2, i2, e2), this.H = 2;
-            }
-        } else
-            3 == this.H && (t3 ? Hg(this, t3) : 0 == this.j.length || lg(this.i) || Hg(this));
-}, Sf.Ma = function() {
-    if (this.u = null, Qg(this), this.ca && !(this.M || null == this.g || 0 >= this.S)) {
-        var t3 = 2 * this.S;
-        this.l.info("BP detection timer enabled: " + t3), this.B = cm(Of(this.jb, this), t3);
-    }
-}, Sf.jb = function() {
-    this.B && (this.B = null, this.l.info("BP detection timeout reached."), this.l.info("Buffering proxy detected and switch to long-polling!"), this.G = false, this.M = true, lm(10), Bg(this), Qg(this));
-}, Sf.ib = function() {
-    null != this.v && (this.v = null, Bg(this), Gg(this), lm(19));
-}, Sf.pb = function(t3) {
-    t3 ? (this.l.info("Successfully pinged google.com"), lm(2)) : (this.l.info("Failed to ping google.com"), lm(1));
-}, Sf.isActive = function() {
-    return !!this.h && this.h.isActive(this);
-}, (Sf = ny.prototype).Ba = function() {}, Sf.Aa = function() {}, Sf.za = function() {}, Sf.ya = function() {}, Sf.isActive = function() {
-    return true;
-}, Sf.Va = function() {}, ry.prototype.g = function(t3, e2) {
-    return new oy(t3, e2);
-}, Nf(oy, Dp), oy.prototype.m = function() {
-    this.g.h = this.j, this.A && (this.g.J = true);
-    var t3 = this.g,
-        e2 = this.l,
-        i2 = this.h || void 0;
-    lm(0), t3.Y = e2, t3.na = i2 || {}, t3.G = t3.aa, t3.I = iy(t3, null, t3.Y), jg(t3);
-}, oy.prototype.close = function() {
-    zg(this.g);
-}, oy.prototype.u = function(t3) {
-    var e2 = this.g;
-    if ("string" == typeof t3) {
-        var i2 = {};
-        i2.__data__ = t3, t3 = i2;
-    } else
-        this.v && ((i2 = {}).__data__ = Fp(t3), t3 = i2);
-    e2.j.push(new class {
-        constructor(t4, e3) {
-            this.g = t4, this.map = e3;
-        }
-    }(e2.fb++, t3)), 3 == e2.H && jg(e2);
-}, oy.prototype.N = function() {
-    this.g.h = null, delete this.j, zg(this.g), delete this.g, oy.$.N.call(this);
-}, Nf(ay, vm), Nf(ly, bm), Nf(hy, ny), hy.prototype.Ba = function() {
-    Lp(this.g, "a");
-}, hy.prototype.Aa = function(t3) {
-    Lp(this.g, new ay(t3));
-}, hy.prototype.za = function(t3) {
-    Lp(this.g, new ly());
-}, hy.prototype.ya = function() {
-    Lp(this.g, "b");
-}, Nf(cy, function() {
-    this.blockSize = -1;
-}), cy.prototype.reset = function() {
-    this.g[0] = 1732584193, this.g[1] = 4023233417, this.g[2] = 2562383102, this.g[3] = 271733878, this.i = this.h = 0;
-}, cy.prototype.j = function(t3, e2) {
-    void 0 === e2 && (e2 = t3.length);
-    for (var i2 = e2 - this.blockSize, s2 = this.m, n2 = this.h, r2 = 0; r2 < e2;) {
-        if (0 == n2)
-            for (; r2 <= i2;)
-                uy(this, t3, r2), r2 += this.blockSize;
-        if ("string" == typeof t3) {
-            for (; r2 < e2;)
-                if (s2[n2++] = t3.charCodeAt(r2++), n2 == this.blockSize) {
-                    uy(this, s2), n2 = 0;
-                    break;
-                }
-        } else
-            for (; r2 < e2;)
-                if (s2[n2++] = t3[r2++], n2 == this.blockSize) {
-                    uy(this, s2), n2 = 0;
-                    break;
-                }
-    }
-    this.h = n2, this.i += e2;
-}, cy.prototype.l = function() {
-    var t3 = Array((56 > this.h ? this.blockSize : 2 * this.blockSize) - this.h);
-    t3[0] = 128;
-    for (var e2 = 1; e2 < t3.length - 8; ++e2)
-        t3[e2] = 0;
-    var i2 = 8 * this.i;
-    for (e2 = t3.length - 8; e2 < t3.length; ++e2)
-        t3[e2] = 255 & i2, i2 /= 256;
-    for (this.j(t3), t3 = Array(16), e2 = i2 = 0; 4 > e2; ++e2)
-        for (var s2 = 0; 32 > s2; s2 += 8)
-            t3[i2++] = this.g[e2] >>> s2 & 255;
-    return t3;
-};
-var fy = {};
-
-function py(t3) {
-    return -128 <= t3 && 128 > t3 ? function(t4, e2) {
-        var i2 = fy;
-        return Object.prototype.hasOwnProperty.call(i2, t4) ? i2[t4] : i2[t4] = e2(t4);
-    }(t3, function(t4) {
-        return new dy([0 | t4], 0 > t4 ? -1 : 0);
-    }) : new dy([0 | t3], 0 > t3 ? -1 : 0);
-}
-
-function my(t3) {
-    if (isNaN(t3) || !isFinite(t3))
-        return yy;
-    if (0 > t3)
-        return xy(my(-t3));
-    for (var e2 = [], i2 = 1, s2 = 0; t3 >= i2; s2++)
-        e2[s2] = t3 / i2 | 0, i2 *= gy;
-    return new dy(e2, 0);
-}
-var gy = 4294967296,
-    yy = py(0),
-    vy = py(1),
-    by = py(16777216);
-
-function _y(t3) {
-    if (0 != t3.h)
-        return false;
-    for (var e2 = 0; e2 < t3.g.length; e2++)
-        if (0 != t3.g[e2])
-            return false;
-    return true;
-}
-
-function wy(t3) {
-    return -1 == t3.h;
-}
-
-function xy(t3) {
-    for (var e2 = t3.g.length, i2 = [], s2 = 0; s2 < e2; s2++)
-        i2[s2] = ~t3.g[s2];
-    return new dy(i2, ~t3.h).add(vy);
-}
-
-function ky(t3, e2) {
-    return t3.add(xy(e2));
-}
-
-function Ty(t3, e2) {
-    for (;
-        (65535 & t3[e2]) != t3[e2];)
-        t3[e2 + 1] += t3[e2] >>> 16, t3[e2] &= 65535, e2++;
-}
-
-function Sy(t3, e2) {
-    this.g = t3, this.h = e2;
-}
-
-function Ey(t3, e2) {
-    if (_y(e2))
-        throw Error("division by zero");
-    if (_y(t3))
-        return new Sy(yy, yy);
-    if (wy(t3))
-        return e2 = Ey(xy(t3), e2), new Sy(xy(e2.g), xy(e2.h));
-    if (wy(e2))
-        return e2 = Ey(t3, xy(e2)), new Sy(xy(e2.g), e2.h);
-    if (30 < t3.g.length) {
-        if (wy(t3) || wy(e2))
-            throw Error("slowDivide_ only works with positive integers.");
-        for (var i2 = vy, s2 = e2; 0 >= s2.X(t3);)
-            i2 = Cy(i2), s2 = Cy(s2);
-        var n2 = Iy(i2, 1),
-            r2 = Iy(s2, 1);
-        for (s2 = Iy(s2, 2), i2 = Iy(i2, 2); !_y(s2);) {
-            var o2 = r2.add(s2);
-            0 >= o2.X(t3) && (n2 = n2.add(i2), r2 = o2), s2 = Iy(s2, 1), i2 = Iy(i2, 1);
-        }
-        return e2 = ky(t3, n2.R(e2)), new Sy(n2, e2);
-    }
-    for (n2 = yy; 0 <= t3.X(e2);) {
-        for (i2 = Math.max(1, Math.floor(t3.ea() / e2.ea())), s2 = 48 >= (s2 = Math.ceil(Math.log(i2) / Math.LN2)) ? 1 : Math.pow(2, s2 - 48), o2 = (r2 = my(i2)).R(e2); wy(o2) || 0 < o2.X(t3);)
-            o2 = (r2 = my(i2 -= s2)).R(e2);
-        _y(r2) && (r2 = vy), n2 = n2.add(r2), t3 = ky(t3, o2);
-    }
-    return new Sy(n2, t3);
-}
-
-function Cy(t3) {
-    for (var e2 = t3.g.length + 1, i2 = [], s2 = 0; s2 < e2; s2++)
-        i2[s2] = t3.D(s2) << 1 | t3.D(s2 - 1) >>> 31;
-    return new dy(i2, t3.h);
-}
-
-function Iy(t3, e2) {
-    var i2 = e2 >> 5;
-    e2 %= 32;
-    for (var s2 = t3.g.length - i2, n2 = [], r2 = 0; r2 < s2; r2++)
-        n2[r2] = 0 < e2 ? t3.D(r2 + i2) >>> e2 | t3.D(r2 + i2 + 1) << 32 - e2 : t3.D(r2 + i2);
-    return new dy(n2, t3.h);
-}
-(Sf = dy.prototype).ea = function() {
-    if (wy(this))
-        return -xy(this).ea();
-    for (var t3 = 0, e2 = 1, i2 = 0; i2 < this.g.length; i2++) {
-        var s2 = this.D(i2);
-        t3 += (0 <= s2 ? s2 : gy + s2) * e2, e2 *= gy;
-    }
-    return t3;
-}, Sf.toString = function(t3) {
-    if (2 > (t3 = t3 || 10) || 36 < t3)
-        throw Error("radix out of range: " + t3);
-    if (_y(this))
-        return "0";
-    if (wy(this))
-        return "-" + xy(this).toString(t3);
-    for (var e2 = my(Math.pow(t3, 6)), i2 = this, s2 = "";;) {
-        var n2 = Ey(i2, e2).g,
-            r2 = ((0 < (i2 = ky(i2, n2.R(e2))).g.length ? i2.g[0] : i2.h) >>> 0).toString(t3);
-        if (_y(i2 = n2))
-            return r2 + s2;
-        for (; 6 > r2.length;)
-            r2 = "0" + r2;
-        s2 = r2 + s2;
-    }
-}, Sf.D = function(t3) {
-    return 0 > t3 ? 0 : t3 < this.g.length ? this.g[t3] : this.h;
-}, Sf.X = function(t3) {
-    return wy(t3 = ky(this, t3)) ? -1 : _y(t3) ? 0 : 1;
-}, Sf.abs = function() {
-    return wy(this) ? xy(this) : this;
-}, Sf.add = function(t3) {
-    for (var e2 = Math.max(this.g.length, t3.g.length), i2 = [], s2 = 0, n2 = 0; n2 <= e2; n2++) {
-        var r2 = s2 + (65535 & this.D(n2)) + (65535 & t3.D(n2)),
-            o2 = (r2 >>> 16) + (this.D(n2) >>> 16) + (t3.D(n2) >>> 16);
-        s2 = o2 >>> 16, r2 &= 65535, o2 &= 65535, i2[n2] = o2 << 16 | r2;
-    }
-    return new dy(i2, -2147483648 & i2[i2.length - 1] ? -1 : 0);
-}, Sf.R = function(t3) {
-    if (_y(this) || _y(t3))
-        return yy;
-    if (wy(this))
-        return wy(t3) ? xy(this).R(xy(t3)) : xy(xy(this).R(t3));
-    if (wy(t3))
-        return xy(this.R(xy(t3)));
-    if (0 > this.X(by) && 0 > t3.X(by))
-        return my(this.ea() * t3.ea());
-    for (var e2 = this.g.length + t3.g.length, i2 = [], s2 = 0; s2 < 2 * e2; s2++)
-        i2[s2] = 0;
-    for (s2 = 0; s2 < this.g.length; s2++)
-        for (var n2 = 0; n2 < t3.g.length; n2++) {
-            var r2 = this.D(s2) >>> 16,
-                o2 = 65535 & this.D(s2),
-                a2 = t3.D(n2) >>> 16,
-                l2 = 65535 & t3.D(n2);
-            i2[2 * s2 + 2 * n2] += o2 * l2, Ty(i2, 2 * s2 + 2 * n2), i2[2 * s2 + 2 * n2 + 1] += r2 * l2, Ty(i2, 2 * s2 + 2 * n2 + 1), i2[2 * s2 + 2 * n2 + 1] += o2 * a2, Ty(i2, 2 * s2 + 2 * n2 + 1), i2[2 * s2 + 2 * n2 + 2] += r2 * a2, Ty(i2, 2 * s2 + 2 * n2 + 2);
-        }
-    for (s2 = 0; s2 < e2; s2++)
-        i2[s2] = i2[2 * s2 + 1] << 16 | i2[2 * s2];
-    for (s2 = e2; s2 < 2 * e2; s2++)
-        i2[s2] = 0;
-    return new dy(i2, 0);
-}, Sf.gb = function(t3) {
-    return Ey(this, t3).h;
-}, Sf.and = function(t3) {
-    for (var e2 = Math.max(this.g.length, t3.g.length), i2 = [], s2 = 0; s2 < e2; s2++)
-        i2[s2] = this.D(s2) & t3.D(s2);
-    return new dy(i2, this.h & t3.h);
-}, Sf.or = function(t3) {
-    for (var e2 = Math.max(this.g.length, t3.g.length), i2 = [], s2 = 0; s2 < e2; s2++)
-        i2[s2] = this.D(s2) | t3.D(s2);
-    return new dy(i2, this.h | t3.h);
-}, Sf.xor = function(t3) {
-    for (var e2 = Math.max(this.g.length, t3.g.length), i2 = [], s2 = 0; s2 < e2; s2++)
-        i2[s2] = this.D(s2) ^ t3.D(s2);
-    return new dy(i2, this.h ^ t3.h);
-}, ry.prototype.createWebChannel = ry.prototype.g, oy.prototype.send = oy.prototype.u, oy.prototype.open = oy.prototype.m, oy.prototype.close = oy.prototype.close, um.NO_ERROR = 0, um.TIMEOUT = 8, um.HTTP_ERROR = 6, dm.COMPLETE = "complete", mm.EventType = ym, ym.OPEN = "a", ym.CLOSE = "b", ym.ERROR = "c", ym.MESSAGE = "d", Dp.prototype.listen = Dp.prototype.O, Sg.prototype.listenOnce = Sg.prototype.P, Sg.prototype.getLastError = Sg.prototype.Sa, Sg.prototype.getLastErrorCode = Sg.prototype.Ia, Sg.prototype.getStatus = Sg.prototype.da, Sg.prototype.getResponseJson = Sg.prototype.Wa, Sg.prototype.getResponseText = Sg.prototype.ja, Sg.prototype.send = Sg.prototype.ha, Sg.prototype.setWithCredentials = Sg.prototype.Oa, cy.prototype.digest = cy.prototype.l, cy.prototype.reset = cy.prototype.reset, cy.prototype.update = cy.prototype.j, dy.prototype.add = dy.prototype.add, dy.prototype.multiply = dy.prototype.R, dy.prototype.modulo = dy.prototype.gb, dy.prototype.compare = dy.prototype.X, dy.prototype.toNumber = dy.prototype.ea, dy.prototype.toString = dy.prototype.toString, dy.prototype.getBits = dy.prototype.D, dy.fromNumber = my, dy.fromString = function t2(e2, i2) {
-    if (0 == e2.length)
-        throw Error("number format error: empty string");
-    if (2 > (i2 = i2 || 10) || 36 < i2)
-        throw Error("radix out of range: " + i2);
-    if ("-" == e2.charAt(0))
-        return xy(t2(e2.substring(1), i2));
-    if (0 <= e2.indexOf("-"))
-        throw Error('number format error: interior "-" character');
-    for (var s2 = my(Math.pow(i2, 8)), n2 = yy, r2 = 0; r2 < e2.length; r2 += 8) {
-        var o2 = Math.min(8, e2.length - r2),
-            a2 = parseInt(e2.substring(r2, r2 + o2), i2);
-        8 > o2 ? (o2 = my(Math.pow(i2, o2)), n2 = n2.R(o2).add(my(a2))) : n2 = (n2 = n2.R(s2)).add(my(a2));
-    }
-    return n2;
-};
-var My = um,
-    Py = dm,
-    Ry = im,
-    Ay = 10,
-    Dy = 11,
-    Ly = vg,
-    Oy = mm,
-    Fy = Sg,
-    Ny = cy,
-    $y = dy;
-const Vy = "@firebase/firestore";
-class User {
-    constructor(t3) {
-        this.uid = t3;
-    }
-    isAuthenticated() {
-        return null != this.uid;
-    }
-    toKey() {
-        return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
-    }
-    isEqual(t3) {
-        return t3.uid === this.uid;
-    }
-}
-User.UNAUTHENTICATED = new User(null), User.GOOGLE_CREDENTIALS = new User("google-credentials-uid"), User.FIRST_PARTY = new User("first-party-uid"), User.MOCK_USER = new User("mock-user");
-let zy = "10.0.0";
-const By = new Logger("@firebase/firestore");
-
-function Uy() {
-    return By.logLevel;
-}
-
-function jy(t3, ...e2) {
-    if (By.logLevel <= Rd.DEBUG) {
-        const i2 = e2.map(qy);
-        By.debug(`Firestore (${zy}): ${t3}`, ...i2);
-    }
-}
-
-function Hy(t3, ...e2) {
-    if (By.logLevel <= Rd.ERROR) {
-        const i2 = e2.map(qy);
-        By.error(`Firestore (${zy}): ${t3}`, ...i2);
-    }
-}
-
-function Wy(t3, ...e2) {
-    if (By.logLevel <= Rd.WARN) {
-        const i2 = e2.map(qy);
-        By.warn(`Firestore (${zy}): ${t3}`, ...i2);
-    }
-}
-
-function qy(t3) {
-    if ("string" == typeof t3)
-        return t3;
-    try {
-        return function(t4) {
-            return JSON.stringify(t4);
-        }(t3);
-    } catch (e2) {
-        return t3;
-    }
-}
-
-function Ky(t3 = "Unexpected state") {
-    const e2 = `FIRESTORE (${zy}) INTERNAL ASSERTION FAILED: ` + t3;
-    throw Hy(e2), new Error(e2);
-}
-
-function Gy(t3, e2) {
-    t3 || Ky();
-}
-
-function Yy(t3, e2) {
-    return t3;
-}
-const Qy = {
-    OK: "ok",
-    CANCELLED: "cancelled",
-    UNKNOWN: "unknown",
-    INVALID_ARGUMENT: "invalid-argument",
-    DEADLINE_EXCEEDED: "deadline-exceeded",
-    NOT_FOUND: "not-found",
-    ALREADY_EXISTS: "already-exists",
-    PERMISSION_DENIED: "permission-denied",
-    UNAUTHENTICATED: "unauthenticated",
-    RESOURCE_EXHAUSTED: "resource-exhausted",
-    FAILED_PRECONDITION: "failed-precondition",
-    ABORTED: "aborted",
-    OUT_OF_RANGE: "out-of-range",
-    UNIMPLEMENTED: "unimplemented",
-    INTERNAL: "internal",
-    UNAVAILABLE: "unavailable",
-    DATA_LOSS: "data-loss"
-};
-class FirestoreError extends FirebaseError {
-    constructor(t3, e2) {
-        super(t3, e2), this.code = t3, this.message = e2, this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
-    }
-}
-class __PRIVATE_Deferred {
-    constructor() {
-        this.promise = new Promise((t3, e2) => {
-            this.resolve = t3, this.reject = e2;
-        });
-    }
-}
-class __PRIVATE_OAuthToken {
-    constructor(t3, e2) {
-        this.user = e2, this.type = "OAuth", this.headers = /* @__PURE__ */ new Map(), this.headers.set("Authorization", `Bearer ${t3}`);
-    }
-}
-class __PRIVATE_EmptyAuthCredentialsProvider {
-    getToken() {
-        return Promise.resolve(null);
-    }
-    invalidateToken() {}
-    start(t3, e2) {
-        t3.enqueueRetryable(() => e2(User.UNAUTHENTICATED));
-    }
-    shutdown() {}
-}
-class __PRIVATE_EmulatorAuthCredentialsProvider {
-    constructor(t3) {
-        this.token = t3, this.changeListener = null;
-    }
-    getToken() {
-        return Promise.resolve(this.token);
-    }
-    invalidateToken() {}
-    start(t3, e2) {
-        this.changeListener = e2, t3.enqueueRetryable(() => e2(this.token.user));
-    }
-    shutdown() {
-        this.changeListener = null;
-    }
-}
-class __PRIVATE_FirebaseAuthCredentialsProvider {
-    constructor(t3) {
-        this.t = t3, this.currentUser = User.UNAUTHENTICATED, this.i = 0, this.forceRefresh = false, this.auth = null;
-    }
-    start(t3, e2) {
-        let i2 = this.i;
-        const s2 = (t4) => this.i !== i2 ? (i2 = this.i, e2(t4)) : Promise.resolve();
-        let n2 = new __PRIVATE_Deferred();
-        this.o = () => {
-            this.i++, this.currentUser = this.u(), n2.resolve(), n2 = new __PRIVATE_Deferred(), t3.enqueueRetryable(() => s2(this.currentUser));
-        };
-        const r2 = () => {
-                const e3 = n2;
-                t3.enqueueRetryable(async () => {
-                    await e3.promise, await s2(this.currentUser);
-                });
-            },
-            o2 = (t4) => {
-                jy("FirebaseAuthCredentialsProvider", "Auth detected"), this.auth = t4, this.auth.addAuthTokenListener(this.o), r2();
-            };
-        this.t.onInit((t4) => o2(t4)), setTimeout(() => {
-            if (!this.auth) {
-                const t4 = this.t.getImmediate({
-                    optional: true
-                });
-                t4 ? o2(t4) : (jy("FirebaseAuthCredentialsProvider", "Auth not yet detected"), n2.resolve(), n2 = new __PRIVATE_Deferred());
-            }
-        }, 0), r2();
-    }
-    getToken() {
-        const t3 = this.i,
-            e2 = this.forceRefresh;
-        return this.forceRefresh = false, this.auth ? this.auth.getToken(e2).then((e3) => this.i !== t3 ? (jy("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : e3 ? (Gy("string" == typeof e3.accessToken), new __PRIVATE_OAuthToken(e3.accessToken, this.currentUser)) : null) : Promise.resolve(null);
-    }
-    invalidateToken() {
-        this.forceRefresh = true;
-    }
-    shutdown() {
-        this.auth && this.auth.removeAuthTokenListener(this.o);
-    }
-    u() {
-        const t3 = this.auth && this.auth.getUid();
-        return Gy(null === t3 || "string" == typeof t3), new User(t3);
-    }
-}
-class __PRIVATE_FirstPartyToken {
-    constructor(t3, e2, i2) {
-        this.l = t3, this.h = e2, this.P = i2, this.type = "FirstParty", this.user = User.FIRST_PARTY, this.I = /* @__PURE__ */ new Map();
-    }
-    T() {
-        return this.P ? this.P() : null;
-    }
-    get headers() {
-        this.I.set("X-Goog-AuthUser", this.l);
-        const t3 = this.T();
-        return t3 && this.I.set("Authorization", t3), this.h && this.I.set("X-Goog-Iam-Authorization-Token", this.h), this.I;
-    }
-}
-class __PRIVATE_FirstPartyAuthCredentialsProvider {
-    constructor(t3, e2, i2) {
-        this.l = t3, this.h = e2, this.P = i2;
-    }
-    getToken() {
-        return Promise.resolve(new __PRIVATE_FirstPartyToken(this.l, this.h, this.P));
-    }
-    start(t3, e2) {
-        t3.enqueueRetryable(() => e2(User.FIRST_PARTY));
-    }
-    shutdown() {}
-    invalidateToken() {}
-}
-class AppCheckToken {
-    constructor(t3) {
-        this.value = t3, this.type = "AppCheck", this.headers = /* @__PURE__ */ new Map(), t3 && t3.length > 0 && this.headers.set("x-firebase-appcheck", this.value);
-    }
-}
-class __PRIVATE_FirebaseAppCheckTokenProvider {
-    constructor(t3) {
-        this.A = t3, this.forceRefresh = false, this.appCheck = null, this.R = null;
-    }
-    start(t3, e2) {
-        const i2 = (t4) => {
-            null != t4.error && jy("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${t4.error.message}`);
-            const i3 = t4.token !== this.R;
-            return this.R = t4.token, jy("FirebaseAppCheckTokenProvider", `Received ${i3 ? "new" : "existing"} token.`), i3 ? e2(t4.token) : Promise.resolve();
-        };
-        this.o = (e3) => {
-            t3.enqueueRetryable(() => i2(e3));
-        };
-        const s2 = (t4) => {
-            jy("FirebaseAppCheckTokenProvider", "AppCheck detected"), this.appCheck = t4, this.appCheck.addTokenListener(this.o);
-        };
-        this.A.onInit((t4) => s2(t4)), setTimeout(() => {
-            if (!this.appCheck) {
-                const t4 = this.A.getImmediate({
-                    optional: true
-                });
-                t4 ? s2(t4) : jy("FirebaseAppCheckTokenProvider", "AppCheck not yet detected");
-            }
-        }, 0);
-    }
-    getToken() {
-        const t3 = this.forceRefresh;
-        return this.forceRefresh = false, this.appCheck ? this.appCheck.getToken(t3).then((t4) => t4 ? (Gy("string" == typeof t4.token), this.R = t4.token, new AppCheckToken(t4.token)) : null) : Promise.resolve(null);
-    }
-    invalidateToken() {
-        this.forceRefresh = true;
-    }
-    shutdown() {
-        this.appCheck && this.appCheck.removeTokenListener(this.o);
-    }
-}
-
-function Xy(t3) {
-    const e2 = "undefined" != typeof self && (self.crypto || self.msCrypto),
-        i2 = new Uint8Array(t3);
-    if (e2 && "function" == typeof e2.getRandomValues)
-        e2.getRandomValues(i2);
-    else
-        for (let e3 = 0; e3 < t3; e3++)
-            i2[e3] = Math.floor(256 * Math.random());
-    return i2;
-}
-class __PRIVATE_AutoId {
-    static V() {
-        const t3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
-            e2 = 62 * Math.floor(256 / 62);
-        let i2 = "";
-        for (; i2.length < 20;) {
-            const s2 = Xy(40);
-            for (let n2 = 0; n2 < s2.length; ++n2)
-                i2.length < 20 && s2[n2] < e2 && (i2 += t3.charAt(s2[n2] % 62));
-        }
-        return i2;
-    }
-}
-
-function Jy(t3, e2) {
-    return t3 < e2 ? -1 : t3 > e2 ? 1 : 0;
-}
-
-function Zy(t3, e2, i2) {
-    return t3.length === e2.length && t3.every((t4, s2) => i2(t4, e2[s2]));
-}
-class Timestamp {
-    constructor(t3, e2) {
-        if (this.seconds = t3, this.nanoseconds = e2, e2 < 0)
-            throw new FirestoreError(Qy.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e2);
-        if (e2 >= 1e9)
-            throw new FirestoreError(Qy.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e2);
-        if (t3 < -62135596800)
-            throw new FirestoreError(Qy.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t3);
-        if (t3 >= 253402300800)
-            throw new FirestoreError(Qy.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t3);
-    }
-    static now() {
-        return Timestamp.fromMillis(Date.now());
-    }
-    static fromDate(t3) {
-        return Timestamp.fromMillis(t3.getTime());
-    }
-    static fromMillis(t3) {
-        const e2 = Math.floor(t3 / 1e3),
-            i2 = Math.floor(1e6 * (t3 - 1e3 * e2));
-        return new Timestamp(e2, i2);
-    }
-    toDate() {
-        return new Date(this.toMillis());
-    }
-    toMillis() {
-        return 1e3 * this.seconds + this.nanoseconds / 1e6;
-    }
-    _compareTo(t3) {
-        return this.seconds === t3.seconds ? Jy(this.nanoseconds, t3.nanoseconds) : Jy(this.seconds, t3.seconds);
-    }
-    isEqual(t3) {
-        return t3.seconds === this.seconds && t3.nanoseconds === this.nanoseconds;
-    }
-    toString() {
-        return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
-    }
-    toJSON() {
-        return {
-            seconds: this.seconds,
-            nanoseconds: this.nanoseconds
-        };
-    }
-    valueOf() {
-        const t3 = this.seconds - -62135596800;
-        return String(t3).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
-    }
-}
-class SnapshotVersion {
-    constructor(t3) {
-        this.timestamp = t3;
-    }
-    static fromTimestamp(t3) {
-        return new SnapshotVersion(t3);
-    }
-    static min() {
-        return new SnapshotVersion(new Timestamp(0, 0));
-    }
-    static max() {
-        return new SnapshotVersion(new Timestamp(253402300799, 999999999));
-    }
-    compareTo(t3) {
-        return this.timestamp._compareTo(t3.timestamp);
-    }
-    isEqual(t3) {
-        return this.timestamp.isEqual(t3.timestamp);
-    }
-    toMicroseconds() {
-        return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
-    }
-    toString() {
-        return "SnapshotVersion(" + this.timestamp.toString() + ")";
-    }
-    toTimestamp() {
-        return this.timestamp;
-    }
-}
-class BasePath {
-    constructor(t3, e2, i2) {
-        void 0 === e2 ? e2 = 0 : e2 > t3.length && Ky(), void 0 === i2 ? i2 = t3.length - e2 : i2 > t3.length - e2 && Ky(), this.segments = t3, this.offset = e2, this.len = i2;
-    }
-    get length() {
-        return this.len;
-    }
-    isEqual(t3) {
-        return 0 === BasePath.comparator(this, t3);
-    }
-    child(t3) {
-        const e2 = this.segments.slice(this.offset, this.limit());
-        return t3 instanceof BasePath ? t3.forEach((t4) => {
-            e2.push(t4);
-        }) : e2.push(t3), this.construct(e2);
-    }
-    limit() {
-        return this.offset + this.length;
-    }
-    popFirst(t3) {
-        return t3 = void 0 === t3 ? 1 : t3, this.construct(this.segments, this.offset + t3, this.length - t3);
-    }
-    popLast() {
-        return this.construct(this.segments, this.offset, this.length - 1);
-    }
-    firstSegment() {
-        return this.segments[this.offset];
-    }
-    lastSegment() {
-        return this.get(this.length - 1);
-    }
-    get(t3) {
-        return this.segments[this.offset + t3];
-    }
-    isEmpty() {
-        return 0 === this.length;
-    }
-    isPrefixOf(t3) {
-        if (t3.length < this.length)
-            return false;
-        for (let e2 = 0; e2 < this.length; e2++)
-            if (this.get(e2) !== t3.get(e2))
-                return false;
-        return true;
-    }
-    isImmediateParentOf(t3) {
-        if (this.length + 1 !== t3.length)
-            return false;
-        for (let e2 = 0; e2 < this.length; e2++)
-            if (this.get(e2) !== t3.get(e2))
-                return false;
-        return true;
-    }
-    forEach(t3) {
-        for (let e2 = this.offset, i2 = this.limit(); e2 < i2; e2++)
-            t3(this.segments[e2]);
-    }
-    toArray() {
-        return this.segments.slice(this.offset, this.limit());
-    }
-    static comparator(t3, e2) {
-        const i2 = Math.min(t3.length, e2.length);
-        for (let s2 = 0; s2 < i2; s2++) {
-            const i3 = t3.get(s2),
-                n2 = e2.get(s2);
-            if (i3 < n2)
-                return -1;
-            if (i3 > n2)
-                return 1;
-        }
-        return t3.length < e2.length ? -1 : t3.length > e2.length ? 1 : 0;
-    }
-}
-class ResourcePath extends BasePath {
-    construct(t3, e2, i2) {
-        return new ResourcePath(t3, e2, i2);
-    }
-    canonicalString() {
-        return this.toArray().join("/");
-    }
-    toString() {
-        return this.canonicalString();
-    }
-    static fromString(...t3) {
-        const e2 = [];
-        for (const i2 of t3) {
-            if (i2.indexOf("//") >= 0)
-                throw new FirestoreError(Qy.INVALID_ARGUMENT, `Invalid segment (${i2}). Paths must not contain // in them.`);
-            e2.push(...i2.split("/").filter((t4) => t4.length > 0));
-        }
-        return new ResourcePath(e2);
-    }
-    static emptyPath() {
-        return new ResourcePath([]);
-    }
-}
-const tv = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
-class FieldPath$1 extends BasePath {
-    construct(t3, e2, i2) {
-        return new FieldPath$1(t3, e2, i2);
-    }
-    static isValidIdentifier(t3) {
-        return tv.test(t3);
-    }
-    canonicalString() {
-        return this.toArray().map((t3) => (t3 = t3.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), FieldPath$1.isValidIdentifier(t3) || (t3 = "`" + t3 + "`"), t3)).join(".");
-    }
-    toString() {
-        return this.canonicalString();
-    }
-    isKeyField() {
-        return 1 === this.length && "__name__" === this.get(0);
-    }
-    static keyField() {
-        return new FieldPath$1(["__name__"]);
-    }
-    static fromServerFormat(t3) {
-        const e2 = [];
-        let i2 = "",
-            s2 = 0;
-        const n2 = () => {
-            if (0 === i2.length)
-                throw new FirestoreError(Qy.INVALID_ARGUMENT, `Invalid field path (${t3}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
-            e2.push(i2), i2 = "";
-        };
-        let r2 = false;
-        for (; s2 < t3.length;) {
-            const e3 = t3[s2];
-            if ("\\" === e3) {
-                if (s2 + 1 === t3.length)
-                    throw new FirestoreError(Qy.INVALID_ARGUMENT, "Path has trailing escape character: " + t3);
-                const e4 = t3[s2 + 1];
-                if ("\\" !== e4 && "." !== e4 && "`" !== e4)
-                    throw new FirestoreError(Qy.INVALID_ARGUMENT, "Path has invalid escape sequence: " + t3);
-                i2 += e4, s2 += 2;
-            } else
-                "`" === e3 ? (r2 = !r2, s2++) : "." !== e3 || r2 ? (i2 += e3, s2++) : (n2(), s2++);
-        }
-        if (n2(), r2)
-            throw new FirestoreError(Qy.INVALID_ARGUMENT, "Unterminated ` in path: " + t3);
-        return new FieldPath$1(e2);
-    }
-    static emptyPath() {
-        return new FieldPath$1([]);
-    }
-}
-class DocumentKey {
-    constructor(t3) {
-        this.path = t3;
-    }
-    static fromPath(t3) {
-        return new DocumentKey(ResourcePath.fromString(t3));
-    }
-    static fromName(t3) {
-        return new DocumentKey(ResourcePath.fromString(t3).popFirst(5));
-    }
-    static empty() {
-        return new DocumentKey(ResourcePath.emptyPath());
-    }
-    get collectionGroup() {
-        return this.path.popLast().lastSegment();
-    }
-    hasCollectionId(t3) {
-        return this.path.length >= 2 && this.path.get(this.path.length - 2) === t3;
-    }
-    getCollectionGroup() {
-        return this.path.get(this.path.length - 2);
-    }
-    getCollectionPath() {
-        return this.path.popLast();
-    }
-    isEqual(t3) {
-        return null !== t3 && 0 === ResourcePath.comparator(this.path, t3.path);
-    }
-    toString() {
-        return this.path.toString();
-    }
-    static comparator(t3, e2) {
-        return ResourcePath.comparator(t3.path, e2.path);
-    }
-    static isDocumentKey(t3) {
-        return t3.length % 2 == 0;
-    }
-    static fromSegments(t3) {
-        return new DocumentKey(new ResourcePath(t3.slice()));
-    }
-}
-
-function ev(t3) {
-    return new IndexOffset(t3.readTime, t3.key, -1);
-}
-class IndexOffset {
-    constructor(t3, e2, i2) {
-        this.readTime = t3, this.documentKey = e2, this.largestBatchId = i2;
-    }
-    static min() {
-        return new IndexOffset(SnapshotVersion.min(), DocumentKey.empty(), -1);
-    }
-    static max() {
-        return new IndexOffset(SnapshotVersion.max(), DocumentKey.empty(), -1);
-    }
-}
-
-function iv(t3, e2) {
-    let i2 = t3.readTime.compareTo(e2.readTime);
-    return 0 !== i2 ? i2 : (i2 = DocumentKey.comparator(t3.documentKey, e2.documentKey), 0 !== i2 ? i2 : Jy(t3.largestBatchId, e2.largestBatchId));
-}
-const sv = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
-class PersistenceTransaction {
-    constructor() {
-        this.onCommittedListeners = [];
-    }
-    addOnCommittedListener(t3) {
-        this.onCommittedListeners.push(t3);
-    }
-    raiseOnCommittedEvent() {
-        this.onCommittedListeners.forEach((t3) => t3());
-    }
-}
-async function nv(t3) {
-    if (t3.code !== Qy.FAILED_PRECONDITION || t3.message !== sv)
-        throw t3;
-    jy("LocalStore", "Unexpectedly lost primary lease");
-}
-class PersistencePromise {
-    constructor(t3) {
-        this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = false, this.callbackAttached = false, t3((t4) => {
-            this.isDone = true, this.result = t4, this.nextCallback && this.nextCallback(t4);
-        }, (t4) => {
-            this.isDone = true, this.error = t4, this.catchCallback && this.catchCallback(t4);
-        });
-    }
-    catch (t3) {
-        return this.next(void 0, t3);
-    }
-    next(t3, e2) {
-        return this.callbackAttached && Ky(), this.callbackAttached = true, this.isDone ? this.error ? this.wrapFailure(e2, this.error) : this.wrapSuccess(t3, this.result) : new PersistencePromise((i2, s2) => {
-            this.nextCallback = (e3) => {
-                this.wrapSuccess(t3, e3).next(i2, s2);
-            }, this.catchCallback = (t4) => {
-                this.wrapFailure(e2, t4).next(i2, s2);
-            };
-        });
-    }
-    toPromise() {
-        return new Promise((t3, e2) => {
-            this.next(t3, e2);
-        });
-    }
-    wrapUserFunction(t3) {
-        try {
-            const e2 = t3();
-            return e2 instanceof PersistencePromise ? e2 : PersistencePromise.resolve(e2);
-        } catch (t4) {
-            return PersistencePromise.reject(t4);
-        }
-    }
-    wrapSuccess(t3, e2) {
-        return t3 ? this.wrapUserFunction(() => t3(e2)) : PersistencePromise.resolve(e2);
-    }
-    wrapFailure(t3, e2) {
-        return t3 ? this.wrapUserFunction(() => t3(e2)) : PersistencePromise.reject(e2);
-    }
-    static resolve(t3) {
-        return new PersistencePromise((e2, i2) => {
-            e2(t3);
-        });
-    }
-    static reject(t3) {
-        return new PersistencePromise((e2, i2) => {
-            i2(t3);
-        });
-    }
-    static waitFor(t3) {
-        return new PersistencePromise((e2, i2) => {
-            let s2 = 0,
-                n2 = 0,
-                r2 = false;
-            t3.forEach((t4) => {
-                ++s2, t4.next(() => {
-                    ++n2, r2 && n2 === s2 && e2();
-                }, (t5) => i2(t5));
-            }), r2 = true, n2 === s2 && e2();
-        });
-    }
-    static or(t3) {
-        let e2 = PersistencePromise.resolve(false);
-        for (const i2 of t3)
-            e2 = e2.next((t4) => t4 ? PersistencePromise.resolve(t4) : i2());
-        return e2;
-    }
-    static forEach(t3, e2) {
-        const i2 = [];
-        return t3.forEach((t4, s2) => {
-            i2.push(e2.call(this, t4, s2));
-        }), this.waitFor(i2);
-    }
-    static mapArray(t3, e2) {
-        return new PersistencePromise((i2, s2) => {
-            const n2 = t3.length,
-                r2 = new Array(n2);
-            let o2 = 0;
-            for (let a2 = 0; a2 < n2; a2++) {
-                const l2 = a2;
-                e2(t3[l2]).next((t4) => {
-                    r2[l2] = t4, ++o2, o2 === n2 && i2(r2);
-                }, (t4) => s2(t4));
-            }
-        });
-    }
-    static doWhile(t3, e2) {
-        return new PersistencePromise((i2, s2) => {
-            const n2 = () => {
-                true === t3() ? e2().next(() => {
-                    n2();
-                }, s2) : i2();
-            };
-            n2();
-        });
-    }
-}
-
-function rv(t3) {
-    return "IndexedDbTransactionError" === t3.name;
-}
-class __PRIVATE_ListenSequence {
-    constructor(t3, e2) {
-        this.previousValue = t3, e2 && (e2.sequenceNumberHandler = (t4) => this.oe(t4), this._e = (t4) => e2.writeSequenceNumber(t4));
-    }
-    oe(t3) {
-        return this.previousValue = Math.max(t3, this.previousValue), this.previousValue;
-    }
-    next() {
-        const t3 = ++this.previousValue;
-        return this._e && this._e(t3), t3;
-    }
-}
-
-function ov(t3) {
-    return null == t3;
-}
-
-function av(t3) {
-    return 0 === t3 && 1 / t3 == -1 / 0;
-}
-
-function lv(t3) {
-    let e2 = 0;
-    for (const i2 in t3)
-        Object.prototype.hasOwnProperty.call(t3, i2) && e2++;
-    return e2;
-}
-
-function hv(t3, e2) {
-    for (const i2 in t3)
-        Object.prototype.hasOwnProperty.call(t3, i2) && e2(i2, t3[i2]);
-}
-__PRIVATE_ListenSequence.ae = -1;
-class SortedMap {
-    constructor(t3, e2) {
-        this.comparator = t3, this.root = e2 || LLRBNode.EMPTY;
-    }
-    insert(t3, e2) {
-        return new SortedMap(this.comparator, this.root.insert(t3, e2, this.comparator).copy(null, null, LLRBNode.BLACK, null, null));
-    }
-    remove(t3) {
-        return new SortedMap(this.comparator, this.root.remove(t3, this.comparator).copy(null, null, LLRBNode.BLACK, null, null));
-    }
-    get(t3) {
-        let e2 = this.root;
-        for (; !e2.isEmpty();) {
-            const i2 = this.comparator(t3, e2.key);
-            if (0 === i2)
-                return e2.value;
-            i2 < 0 ? e2 = e2.left : i2 > 0 && (e2 = e2.right);
-        }
-        return null;
-    }
-    indexOf(t3) {
-        let e2 = 0,
-            i2 = this.root;
-        for (; !i2.isEmpty();) {
-            const s2 = this.comparator(t3, i2.key);
-            if (0 === s2)
-                return e2 + i2.left.size;
-            s2 < 0 ? i2 = i2.left : (e2 += i2.left.size + 1, i2 = i2.right);
-        }
-        return -1;
-    }
-    isEmpty() {
-        return this.root.isEmpty();
-    }
-    get size() {
-        return this.root.size;
-    }
-    minKey() {
-        return this.root.minKey();
-    }
-    maxKey() {
-        return this.root.maxKey();
-    }
-    inorderTraversal(t3) {
-        return this.root.inorderTraversal(t3);
-    }
-    forEach(t3) {
-        this.inorderTraversal((e2, i2) => (t3(e2, i2), false));
-    }
-    toString() {
-        const t3 = [];
-        return this.inorderTraversal((e2, i2) => (t3.push(`${e2}:${i2}`), false)), `{${t3.join(", ")}}`;
-    }
-    reverseTraversal(t3) {
-        return this.root.reverseTraversal(t3);
-    }
-    getIterator() {
-        return new SortedMapIterator(this.root, null, this.comparator, false);
-    }
-    getIteratorFrom(t3) {
-        return new SortedMapIterator(this.root, t3, this.comparator, false);
-    }
-    getReverseIterator() {
-        return new SortedMapIterator(this.root, null, this.comparator, true);
-    }
-    getReverseIteratorFrom(t3) {
-        return new SortedMapIterator(this.root, t3, this.comparator, true);
-    }
-}
-class SortedMapIterator {
-    constructor(t3, e2, i2, s2) {
-        this.isReverse = s2, this.nodeStack = [];
-        let n2 = 1;
-        for (; !t3.isEmpty();)
-            if (n2 = e2 ? i2(t3.key, e2) : 1, e2 && s2 && (n2 *= -1), n2 < 0)
-                t3 = this.isReverse ? t3.left : t3.right;
-            else {
-                if (0 === n2) {
-                    this.nodeStack.push(t3);
-                    break;
-                }
-                this.nodeStack.push(t3), t3 = this.isReverse ? t3.right : t3.left;
-            }
-    }
-    getNext() {
-        let t3 = this.nodeStack.pop();
-        const e2 = {
-            key: t3.key,
-            value: t3.value
-        };
-        if (this.isReverse)
-            for (t3 = t3.left; !t3.isEmpty();)
-                this.nodeStack.push(t3), t3 = t3.right;
-        else
-            for (t3 = t3.right; !t3.isEmpty();)
-                this.nodeStack.push(t3), t3 = t3.left;
-        return e2;
-    }
-    hasNext() {
-        return this.nodeStack.length > 0;
-    }
-    peek() {
-        if (0 === this.nodeStack.length)
-            return null;
-        const t3 = this.nodeStack[this.nodeStack.length - 1];
-        return {
-            key: t3.key,
-            value: t3.value
-        };
-    }
-}
-class LLRBNode {
-    constructor(t3, e2, i2, s2, n2) {
-        this.key = t3, this.value = e2, this.color = null != i2 ? i2 : LLRBNode.RED, this.left = null != s2 ? s2 : LLRBNode.EMPTY, this.right = null != n2 ? n2 : LLRBNode.EMPTY, this.size = this.left.size + 1 + this.right.size;
-    }
-    copy(t3, e2, i2, s2, n2) {
-        return new LLRBNode(null != t3 ? t3 : this.key, null != e2 ? e2 : this.value, null != i2 ? i2 : this.color, null != s2 ? s2 : this.left, null != n2 ? n2 : this.right);
-    }
-    isEmpty() {
-        return false;
-    }
-    inorderTraversal(t3) {
-        return this.left.inorderTraversal(t3) || t3(this.key, this.value) || this.right.inorderTraversal(t3);
-    }
-    reverseTraversal(t3) {
-        return this.right.reverseTraversal(t3) || t3(this.key, this.value) || this.left.reverseTraversal(t3);
-    }
-    min() {
-        return this.left.isEmpty() ? this : this.left.min();
-    }
-    minKey() {
-        return this.min().key;
-    }
-    maxKey() {
-        return this.right.isEmpty() ? this.key : this.right.maxKey();
-    }
-    insert(t3, e2, i2) {
-        let s2 = this;
-        const n2 = i2(t3, s2.key);
-        return s2 = n2 < 0 ? s2.copy(null, null, null, s2.left.insert(t3, e2, i2), null) : 0 === n2 ? s2.copy(null, e2, null, null, null) : s2.copy(null, null, null, null, s2.right.insert(t3, e2, i2)), s2.fixUp();
-    }
-    removeMin() {
-        if (this.left.isEmpty())
-            return LLRBNode.EMPTY;
-        let t3 = this;
-        return t3.left.isRed() || t3.left.left.isRed() || (t3 = t3.moveRedLeft()), t3 = t3.copy(null, null, null, t3.left.removeMin(), null), t3.fixUp();
-    }
-    remove(t3, e2) {
-        let i2, s2 = this;
-        if (e2(t3, s2.key) < 0)
-            s2.left.isEmpty() || s2.left.isRed() || s2.left.left.isRed() || (s2 = s2.moveRedLeft()), s2 = s2.copy(null, null, null, s2.left.remove(t3, e2), null);
-        else {
-            if (s2.left.isRed() && (s2 = s2.rotateRight()), s2.right.isEmpty() || s2.right.isRed() || s2.right.left.isRed() || (s2 = s2.moveRedRight()), 0 === e2(t3, s2.key)) {
-                if (s2.right.isEmpty())
-                    return LLRBNode.EMPTY;
-                i2 = s2.right.min(), s2 = s2.copy(i2.key, i2.value, null, null, s2.right.removeMin());
-            }
-            s2 = s2.copy(null, null, null, null, s2.right.remove(t3, e2));
-        }
-        return s2.fixUp();
-    }
-    isRed() {
-        return this.color;
-    }
-    fixUp() {
-        let t3 = this;
-        return t3.right.isRed() && !t3.left.isRed() && (t3 = t3.rotateLeft()), t3.left.isRed() && t3.left.left.isRed() && (t3 = t3.rotateRight()), t3.left.isRed() && t3.right.isRed() && (t3 = t3.colorFlip()), t3;
-    }
-    moveRedLeft() {
-        let t3 = this.colorFlip();
-        return t3.right.left.isRed() && (t3 = t3.copy(null, null, null, null, t3.right.rotateRight()), t3 = t3.rotateLeft(), t3 = t3.colorFlip()), t3;
-    }
-    moveRedRight() {
-        let t3 = this.colorFlip();
-        return t3.left.left.isRed() && (t3 = t3.rotateRight(), t3 = t3.colorFlip()), t3;
-    }
-    rotateLeft() {
-        const t3 = this.copy(null, null, LLRBNode.RED, null, this.right.left);
-        return this.right.copy(null, null, this.color, t3, null);
-    }
-    rotateRight() {
-        const t3 = this.copy(null, null, LLRBNode.RED, this.left.right, null);
-        return this.left.copy(null, null, this.color, null, t3);
-    }
-    colorFlip() {
-        const t3 = this.left.copy(null, null, !this.left.color, null, null),
-            e2 = this.right.copy(null, null, !this.right.color, null, null);
-        return this.copy(null, null, !this.color, t3, e2);
-    }
-    checkMaxDepth() {
-        const t3 = this.check();
-        return Math.pow(2, t3) <= this.size + 1;
-    }
-    check() {
-        if (this.isRed() && this.left.isRed())
-            throw Ky();
-        if (this.right.isRed())
-            throw Ky();
-        const t3 = this.left.check();
-        if (t3 !== this.right.check())
-            throw Ky();
-        return t3 + (this.isRed() ? 0 : 1);
-    }
-}
-LLRBNode.EMPTY = null, LLRBNode.RED = true, LLRBNode.BLACK = false, LLRBNode.EMPTY = new class LLRBEmptyNode {
-    constructor() {
-        this.size = 0;
-    }
-    get key() {
-        throw Ky();
-    }
-    get value() {
-        throw Ky();
-    }
-    get color() {
-        throw Ky();
-    }
-    get left() {
-        throw Ky();
-    }
-    get right() {
-        throw Ky();
-    }
-    copy(t3, e2, i2, s2, n2) {
-        return this;
-    }
-    insert(t3, e2, i2) {
-        return new LLRBNode(t3, e2);
-    }
-    remove(t3, e2) {
-        return this;
-    }
-    isEmpty() {
-        return true;
-    }
-    inorderTraversal(t3) {
-        return false;
-    }
-    reverseTraversal(t3) {
-        return false;
-    }
-    minKey() {
-        return null;
-    }
-    maxKey() {
-        return null;
-    }
-    isRed() {
-        return false;
-    }
-    checkMaxDepth() {
-        return true;
-    }
-    check() {
-        return 0;
-    }
-}();
-class SortedSet {
-    constructor(t3) {
-        this.comparator = t3, this.data = new SortedMap(this.comparator);
-    }
-    has(t3) {
-        return null !== this.data.get(t3);
-    }
-    first() {
-        return this.data.minKey();
-    }
-    last() {
-        return this.data.maxKey();
-    }
-    get size() {
-        return this.data.size;
-    }
-    indexOf(t3) {
-        return this.data.indexOf(t3);
-    }
-    forEach(t3) {
-        this.data.inorderTraversal((e2, i2) => (t3(e2), false));
-    }
-    forEachInRange(t3, e2) {
-        const i2 = this.data.getIteratorFrom(t3[0]);
-        for (; i2.hasNext();) {
-            const s2 = i2.getNext();
-            if (this.comparator(s2.key, t3[1]) >= 0)
-                return;
-            e2(s2.key);
-        }
-    }
-    forEachWhile(t3, e2) {
-        let i2;
-        for (i2 = void 0 !== e2 ? this.data.getIteratorFrom(e2) : this.data.getIterator(); i2.hasNext();)
-            if (!t3(i2.getNext().key))
-                return;
-    }
-    firstAfterOrEqual(t3) {
-        const e2 = this.data.getIteratorFrom(t3);
-        return e2.hasNext() ? e2.getNext().key : null;
-    }
-    getIterator() {
-        return new SortedSetIterator(this.data.getIterator());
-    }
-    getIteratorFrom(t3) {
-        return new SortedSetIterator(this.data.getIteratorFrom(t3));
-    }
-    add(t3) {
-        return this.copy(this.data.remove(t3).insert(t3, true));
-    }
-    delete(t3) {
-        return this.has(t3) ? this.copy(this.data.remove(t3)) : this;
-    }
-    isEmpty() {
-        return this.data.isEmpty();
-    }
-    unionWith(t3) {
-        let e2 = this;
-        return e2.size < t3.size && (e2 = t3, t3 = this), t3.forEach((t4) => {
-            e2 = e2.add(t4);
-        }), e2;
-    }
-    isEqual(t3) {
-        if (!(t3 instanceof SortedSet))
-            return false;
-        if (this.size !== t3.size)
-            return false;
-        const e2 = this.data.getIterator(),
-            i2 = t3.data.getIterator();
-        for (; e2.hasNext();) {
-            const t4 = e2.getNext().key,
-                s2 = i2.getNext().key;
-            if (0 !== this.comparator(t4, s2))
-                return false;
-        }
-        return true;
-    }
-    toArray() {
-        const t3 = [];
-        return this.forEach((e2) => {
-            t3.push(e2);
-        }), t3;
-    }
-    toString() {
-        const t3 = [];
-        return this.forEach((e2) => t3.push(e2)), "SortedSet(" + t3.toString() + ")";
-    }
-    copy(t3) {
-        const e2 = new SortedSet(this.comparator);
-        return e2.data = t3, e2;
-    }
-}
-class SortedSetIterator {
-    constructor(t3) {
-        this.iter = t3;
-    }
-    getNext() {
-        return this.iter.getNext().key;
-    }
-    hasNext() {
-        return this.iter.hasNext();
-    }
-}
-class FieldMask {
-    constructor(t3) {
-        this.fields = t3, t3.sort(FieldPath$1.comparator);
-    }
-    static empty() {
-        return new FieldMask([]);
-    }
-    unionWith(t3) {
-        let e2 = new SortedSet(FieldPath$1.comparator);
-        for (const t4 of this.fields)
-            e2 = e2.add(t4);
-        for (const i2 of t3)
-            e2 = e2.add(i2);
-        return new FieldMask(e2.toArray());
-    }
-    covers(t3) {
-        for (const e2 of this.fields)
-            if (e2.isPrefixOf(t3))
-                return true;
-        return false;
-    }
-    isEqual(t3) {
-        return Zy(this.fields, t3.fields, (t4, e2) => t4.isEqual(e2));
-    }
-}
-class __PRIVATE_Base64DecodeError extends Error {
-    constructor() {
-        super(...arguments), this.name = "Base64DecodeError";
-    }
-}
-class ByteString {
-    constructor(t3) {
-        this.binaryString = t3;
-    }
-    static fromBase64String(t3) {
-        const e2 = function(t4) {
-            try {
-                return atob(t4);
-            } catch (t5) {
-                throw "undefined" != typeof DOMException && t5 instanceof DOMException ? new __PRIVATE_Base64DecodeError("Invalid base64 string: " + t5) : t5;
-            }
-        }(t3);
-        return new ByteString(e2);
-    }
-    static fromUint8Array(t3) {
-            const e2 = function(t4) {
-                let e3 = "";
-                for (let i2 = 0; i2 < t4.length; ++i2)
-                    e3 += String.fromCharCode(t4[i2]);
-                return e3;
-            }(t3);
-            return new ByteString(e2);
-        }
-        [Symbol.iterator]() {
-            let t3 = 0;
-            return {
-                next: () => t3 < this.binaryString.length ? {
-                    value: this.binaryString.charCodeAt(t3++),
-                    done: false
-                } : {
-                    value: void 0,
-                    done: true
-                }
-            };
-        }
-    toBase64() {
-        return function(t3) {
-            return btoa(t3);
-        }(this.binaryString);
-    }
-    toUint8Array() {
-        return function(t3) {
-            const e2 = new Uint8Array(t3.length);
-            for (let i2 = 0; i2 < t3.length; i2++)
-                e2[i2] = t3.charCodeAt(i2);
-            return e2;
-        }(this.binaryString);
-    }
-    approximateByteSize() {
-        return 2 * this.binaryString.length;
-    }
-    compareTo(t3) {
-        return Jy(this.binaryString, t3.binaryString);
-    }
-    isEqual(t3) {
-        return this.binaryString === t3.binaryString;
-    }
-}
-ByteString.EMPTY_BYTE_STRING = new ByteString("");
-const cv = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
-
-function uv(t3) {
-    if (Gy(!!t3), "string" == typeof t3) {
-        let e2 = 0;
-        const i2 = cv.exec(t3);
-        if (Gy(!!i2), i2[1]) {
-            let t4 = i2[1];
-            t4 = (t4 + "000000000").substr(0, 9), e2 = Number(t4);
-        }
-        const s2 = new Date(t3);
-        return {
-            seconds: Math.floor(s2.getTime() / 1e3),
-            nanos: e2
-        };
-    }
-    return {
-        seconds: dv(t3.seconds),
-        nanos: dv(t3.nanos)
-    };
-}
-
-function dv(t3) {
-    return "number" == typeof t3 ? t3 : "string" == typeof t3 ? Number(t3) : 0;
-}
-
-function fv(t3) {
-    return "string" == typeof t3 ? ByteString.fromBase64String(t3) : ByteString.fromUint8Array(t3);
-}
-
-function pv(t3) {
-    var e2, i2;
-    return "server_timestamp" === (null === (i2 = ((null === (e2 = null == t3 ? void 0 : t3.mapValue) || void 0 === e2 ? void 0 : e2.fields) || {}).__type__) || void 0 === i2 ? void 0 : i2.stringValue);
-}
-
-function mv(t3) {
-    const e2 = t3.mapValue.fields.__previous_value__;
-    return pv(e2) ? mv(e2) : e2;
-}
-
-function gv(t3) {
-    const e2 = uv(t3.mapValue.fields.__local_write_time__.timestampValue);
-    return new Timestamp(e2.seconds, e2.nanos);
-}
-class DatabaseInfo {
-    constructor(t3, e2, i2, s2, n2, r2, o2, a2, l2) {
-        this.databaseId = t3, this.appId = e2, this.persistenceKey = i2, this.host = s2, this.ssl = n2, this.forceLongPolling = r2, this.autoDetectLongPolling = o2, this.longPollingOptions = a2, this.useFetchStreams = l2;
-    }
-}
-class DatabaseId {
-    constructor(t3, e2) {
-        this.projectId = t3, this.database = e2 || "(default)";
-    }
-    static empty() {
-        return new DatabaseId("", "");
-    }
-    get isDefaultDatabase() {
-        return "(default)" === this.database;
-    }
-    isEqual(t3) {
-        return t3 instanceof DatabaseId && t3.projectId === this.projectId && t3.database === this.database;
-    }
-}
-const yv = {
-    mapValue: {
-        fields: {
-            __type__: {
-                stringValue: "__max__"
-            }
-        }
-    }
-};
-
-function vv(t3) {
-    return "nullValue" in t3 ? 0 : "booleanValue" in t3 ? 1 : "integerValue" in t3 || "doubleValue" in t3 ? 2 : "timestampValue" in t3 ? 3 : "stringValue" in t3 ? 5 : "bytesValue" in t3 ? 6 : "referenceValue" in t3 ? 7 : "geoPointValue" in t3 ? 8 : "arrayValue" in t3 ? 9 : "mapValue" in t3 ? pv(t3) ? 4 : function(t4) {
-        return "__max__" === (((t4.mapValue || {}).fields || {}).__type__ || {}).stringValue;
-    }(t3) ? 9007199254740991 : 10 : Ky();
-}
-
-function bv(t3, e2) {
-    if (t3 === e2)
-        return true;
-    const i2 = vv(t3);
-    if (i2 !== vv(e2))
-        return false;
-    switch (i2) {
-        case 0:
-        case 9007199254740991:
-            return true;
-        case 1:
-            return t3.booleanValue === e2.booleanValue;
-        case 4:
-            return gv(t3).isEqual(gv(e2));
-        case 3:
-            return function(t4, e3) {
-                if ("string" == typeof t4.timestampValue && "string" == typeof e3.timestampValue && t4.timestampValue.length === e3.timestampValue.length)
-                    return t4.timestampValue === e3.timestampValue;
-                const i3 = uv(t4.timestampValue),
-                    s2 = uv(e3.timestampValue);
-                return i3.seconds === s2.seconds && i3.nanos === s2.nanos;
-            }(t3, e2);
-        case 5:
-            return t3.stringValue === e2.stringValue;
-        case 6:
-            return function(t4, e3) {
-                return fv(t4.bytesValue).isEqual(fv(e3.bytesValue));
-            }(t3, e2);
-        case 7:
-            return t3.referenceValue === e2.referenceValue;
-        case 8:
-            return function(t4, e3) {
-                return dv(t4.geoPointValue.latitude) === dv(e3.geoPointValue.latitude) && dv(t4.geoPointValue.longitude) === dv(e3.geoPointValue.longitude);
-            }(t3, e2);
-        case 2:
-            return function(t4, e3) {
-                if ("integerValue" in t4 && "integerValue" in e3)
-                    return dv(t4.integerValue) === dv(e3.integerValue);
-                if ("doubleValue" in t4 && "doubleValue" in e3) {
-                    const i3 = dv(t4.doubleValue),
-                        s2 = dv(e3.doubleValue);
-                    return i3 === s2 ? av(i3) === av(s2) : isNaN(i3) && isNaN(s2);
-                }
-                return false;
-            }(t3, e2);
-        case 9:
-            return Zy(t3.arrayValue.values || [], e2.arrayValue.values || [], bv);
-        case 10:
-            return function(t4, e3) {
-                const i3 = t4.mapValue.fields || {},
-                    s2 = e3.mapValue.fields || {};
-                if (lv(i3) !== lv(s2))
-                    return false;
-                for (const t5 in i3)
-                    if (i3.hasOwnProperty(t5) && (void 0 === s2[t5] || !bv(i3[t5], s2[t5])))
-                        return false;
-                return true;
-            }(t3, e2);
-        default:
-            return Ky();
-    }
-}
-
-function _v(t3, e2) {
-    return void 0 !== (t3.values || []).find((t4) => bv(t4, e2));
-}
-
-function wv(t3, e2) {
-    if (t3 === e2)
-        return 0;
-    const i2 = vv(t3),
-        s2 = vv(e2);
-    if (i2 !== s2)
-        return Jy(i2, s2);
-    switch (i2) {
-        case 0:
-        case 9007199254740991:
-            return 0;
-        case 1:
-            return Jy(t3.booleanValue, e2.booleanValue);
-        case 2:
-            return function(t4, e3) {
-                const i3 = dv(t4.integerValue || t4.doubleValue),
-                    s3 = dv(e3.integerValue || e3.doubleValue);
-                return i3 < s3 ? -1 : i3 > s3 ? 1 : i3 === s3 ? 0 : isNaN(i3) ? isNaN(s3) ? 0 : -1 : 1;
-            }(t3, e2);
-        case 3:
-            return xv(t3.timestampValue, e2.timestampValue);
-        case 4:
-            return xv(gv(t3), gv(e2));
-        case 5:
-            return Jy(t3.stringValue, e2.stringValue);
-        case 6:
-            return function(t4, e3) {
-                const i3 = fv(t4),
-                    s3 = fv(e3);
-                return i3.compareTo(s3);
-            }(t3.bytesValue, e2.bytesValue);
-        case 7:
-            return function(t4, e3) {
-                const i3 = t4.split("/"),
-                    s3 = e3.split("/");
-                for (let t5 = 0; t5 < i3.length && t5 < s3.length; t5++) {
-                    const e4 = Jy(i3[t5], s3[t5]);
-                    if (0 !== e4)
-                        return e4;
-                }
-                return Jy(i3.length, s3.length);
-            }(t3.referenceValue, e2.referenceValue);
-        case 8:
-            return function(t4, e3) {
-                const i3 = Jy(dv(t4.latitude), dv(e3.latitude));
-                return 0 !== i3 ? i3 : Jy(dv(t4.longitude), dv(e3.longitude));
-            }(t3.geoPointValue, e2.geoPointValue);
-        case 9:
-            return function(t4, e3) {
-                const i3 = t4.values || [],
-                    s3 = e3.values || [];
-                for (let t5 = 0; t5 < i3.length && t5 < s3.length; ++t5) {
-                    const e4 = wv(i3[t5], s3[t5]);
-                    if (e4)
-                        return e4;
-                }
-                return Jy(i3.length, s3.length);
-            }(t3.arrayValue, e2.arrayValue);
-        case 10:
-            return function(t4, e3) {
-                if (t4 === yv.mapValue && e3 === yv.mapValue)
-                    return 0;
-                if (t4 === yv.mapValue)
-                    return 1;
-                if (e3 === yv.mapValue)
-                    return -1;
-                const i3 = t4.fields || {},
-                    s3 = Object.keys(i3),
-                    n2 = e3.fields || {},
-                    r2 = Object.keys(n2);
-                s3.sort(), r2.sort();
-                for (let t5 = 0; t5 < s3.length && t5 < r2.length; ++t5) {
-                    const e4 = Jy(s3[t5], r2[t5]);
-                    if (0 !== e4)
-                        return e4;
-                    const o2 = wv(i3[s3[t5]], n2[r2[t5]]);
-                    if (0 !== o2)
-                        return o2;
-                }
-                return Jy(s3.length, r2.length);
-            }(t3.mapValue, e2.mapValue);
-        default:
-            throw Ky();
-    }
-}
-
-function xv(t3, e2) {
-    if ("string" == typeof t3 && "string" == typeof e2 && t3.length === e2.length)
-        return Jy(t3, e2);
-    const i2 = uv(t3),
-        s2 = uv(e2),
-        n2 = Jy(i2.seconds, s2.seconds);
-    return 0 !== n2 ? n2 : Jy(i2.nanos, s2.nanos);
-}
-
-function kv(t3) {
-    return Tv(t3);
-}
-
-function Tv(t3) {
-    return "nullValue" in t3 ? "null" : "booleanValue" in t3 ? "" + t3.booleanValue : "integerValue" in t3 ? "" + t3.integerValue : "doubleValue" in t3 ? "" + t3.doubleValue : "timestampValue" in t3 ? function(t4) {
-        const e2 = uv(t4);
-        return `time(${e2.seconds},${e2.nanos})`;
-    }(t3.timestampValue) : "stringValue" in t3 ? t3.stringValue : "bytesValue" in t3 ? function(t4) {
-        return fv(t4).toBase64();
-    }(t3.bytesValue) : "referenceValue" in t3 ? function(t4) {
-        return DocumentKey.fromName(t4).toString();
-    }(t3.referenceValue) : "geoPointValue" in t3 ? function(t4) {
-        return `geo(${t4.latitude},${t4.longitude})`;
-    }(t3.geoPointValue) : "arrayValue" in t3 ? function(t4) {
-        let e2 = "[",
-            i2 = true;
-        for (const s2 of t4.values || [])
-            i2 ? i2 = false : e2 += ",", e2 += Tv(s2);
-        return e2 + "]";
-    }(t3.arrayValue) : "mapValue" in t3 ? function(t4) {
-        const e2 = Object.keys(t4.fields || {}).sort();
-        let i2 = "{",
-            s2 = true;
-        for (const n2 of e2)
-            s2 ? s2 = false : i2 += ",", i2 += `${n2}:${Tv(t4.fields[n2])}`;
-        return i2 + "}";
-    }(t3.mapValue) : Ky();
-}
-
-function Sv(t3) {
-    return !!t3 && "integerValue" in t3;
-}
-
-function Ev(t3) {
-    return !!t3 && "arrayValue" in t3;
-}
-
-function Cv(t3) {
-    return !!t3 && "nullValue" in t3;
-}
-
-function Iv(t3) {
-    return !!t3 && "doubleValue" in t3 && isNaN(Number(t3.doubleValue));
-}
-
-function Mv(t3) {
-    return !!t3 && "mapValue" in t3;
-}
-
-function Pv(t3) {
-    if (t3.geoPointValue)
-        return {
-            geoPointValue: Object.assign({}, t3.geoPointValue)
-        };
-    if (t3.timestampValue && "object" == typeof t3.timestampValue)
-        return {
-            timestampValue: Object.assign({}, t3.timestampValue)
-        };
-    if (t3.mapValue) {
-        const e2 = {
-            mapValue: {
-                fields: {}
-            }
-        };
-        return hv(t3.mapValue.fields, (t4, i2) => e2.mapValue.fields[t4] = Pv(i2)), e2;
-    }
-    if (t3.arrayValue) {
-        const e2 = {
-            arrayValue: {
-                values: []
-            }
-        };
-        for (let i2 = 0; i2 < (t3.arrayValue.values || []).length; ++i2)
-            e2.arrayValue.values[i2] = Pv(t3.arrayValue.values[i2]);
-        return e2;
-    }
-    return Object.assign({}, t3);
-}
-class ObjectValue {
-    constructor(t3) {
-        this.value = t3;
-    }
-    static empty() {
-        return new ObjectValue({
-            mapValue: {}
-        });
-    }
-    field(t3) {
-        if (t3.isEmpty())
-            return this.value;
-        {
-            let e2 = this.value;
-            for (let i2 = 0; i2 < t3.length - 1; ++i2)
-                if (e2 = (e2.mapValue.fields || {})[t3.get(i2)], !Mv(e2))
-                    return null;
-            return e2 = (e2.mapValue.fields || {})[t3.lastSegment()], e2 || null;
-        }
-    }
-    set(t3, e2) {
-        this.getFieldsMap(t3.popLast())[t3.lastSegment()] = Pv(e2);
-    }
-    setAll(t3) {
-        let e2 = FieldPath$1.emptyPath(),
-            i2 = {},
-            s2 = [];
-        t3.forEach((t4, n3) => {
-            if (!e2.isImmediateParentOf(n3)) {
-                const t5 = this.getFieldsMap(e2);
-                this.applyChanges(t5, i2, s2), i2 = {}, s2 = [], e2 = n3.popLast();
-            }
-            t4 ? i2[n3.lastSegment()] = Pv(t4) : s2.push(n3.lastSegment());
-        });
-        const n2 = this.getFieldsMap(e2);
-        this.applyChanges(n2, i2, s2);
-    }
-    delete(t3) {
-        const e2 = this.field(t3.popLast());
-        Mv(e2) && e2.mapValue.fields && delete e2.mapValue.fields[t3.lastSegment()];
-    }
-    isEqual(t3) {
-        return bv(this.value, t3.value);
-    }
-    getFieldsMap(t3) {
-        let e2 = this.value;
-        e2.mapValue.fields || (e2.mapValue = {
-            fields: {}
-        });
-        for (let i2 = 0; i2 < t3.length; ++i2) {
-            let s2 = e2.mapValue.fields[t3.get(i2)];
-            Mv(s2) && s2.mapValue.fields || (s2 = {
-                mapValue: {
-                    fields: {}
-                }
-            }, e2.mapValue.fields[t3.get(i2)] = s2), e2 = s2;
-        }
-        return e2.mapValue.fields;
-    }
-    applyChanges(t3, e2, i2) {
-        hv(e2, (e3, i3) => t3[e3] = i3);
-        for (const e3 of i2)
-            delete t3[e3];
-    }
-    clone() {
-        return new ObjectValue(Pv(this.value));
-    }
-}
-class MutableDocument {
-    constructor(t3, e2, i2, s2, n2, r2, o2) {
-        this.key = t3, this.documentType = e2, this.version = i2, this.readTime = s2, this.createTime = n2, this.data = r2, this.documentState = o2;
-    }
-    static newInvalidDocument(t3) {
-        return new MutableDocument(t3, 0, SnapshotVersion.min(), SnapshotVersion.min(), SnapshotVersion.min(), ObjectValue.empty(), 0);
-    }
-    static newFoundDocument(t3, e2, i2, s2) {
-        return new MutableDocument(t3, 1, e2, SnapshotVersion.min(), i2, s2, 0);
-    }
-    static newNoDocument(t3, e2) {
-        return new MutableDocument(t3, 2, e2, SnapshotVersion.min(), SnapshotVersion.min(), ObjectValue.empty(), 0);
-    }
-    static newUnknownDocument(t3, e2) {
-        return new MutableDocument(t3, 3, e2, SnapshotVersion.min(), SnapshotVersion.min(), ObjectValue.empty(), 2);
-    }
-    convertToFoundDocument(t3, e2) {
-        return !this.createTime.isEqual(SnapshotVersion.min()) || 2 !== this.documentType && 0 !== this.documentType || (this.createTime = t3), this.version = t3, this.documentType = 1, this.data = e2, this.documentState = 0, this;
-    }
-    convertToNoDocument(t3) {
-        return this.version = t3, this.documentType = 2, this.data = ObjectValue.empty(), this.documentState = 0, this;
-    }
-    convertToUnknownDocument(t3) {
-        return this.version = t3, this.documentType = 3, this.data = ObjectValue.empty(), this.documentState = 2, this;
-    }
-    setHasCommittedMutations() {
-        return this.documentState = 2, this;
-    }
-    setHasLocalMutations() {
-        return this.documentState = 1, this.version = SnapshotVersion.min(), this;
-    }
-    setReadTime(t3) {
-        return this.readTime = t3, this;
-    }
-    get hasLocalMutations() {
-        return 1 === this.documentState;
-    }
-    get hasCommittedMutations() {
-        return 2 === this.documentState;
-    }
-    get hasPendingWrites() {
-        return this.hasLocalMutations || this.hasCommittedMutations;
-    }
-    isValidDocument() {
-        return 0 !== this.documentType;
-    }
-    isFoundDocument() {
-        return 1 === this.documentType;
-    }
-    isNoDocument() {
-        return 2 === this.documentType;
-    }
-    isUnknownDocument() {
-        return 3 === this.documentType;
-    }
-    isEqual(t3) {
-        return t3 instanceof MutableDocument && this.key.isEqual(t3.key) && this.version.isEqual(t3.version) && this.documentType === t3.documentType && this.documentState === t3.documentState && this.data.isEqual(t3.data);
-    }
-    mutableCopy() {
-        return new MutableDocument(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState);
-    }
-    toString() {
-        return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
-    }
-}
-class Bound {
-    constructor(t3, e2) {
-        this.position = t3, this.inclusive = e2;
-    }
-}
-
-function Rv(t3, e2, i2) {
-    let s2 = 0;
-    for (let n2 = 0; n2 < t3.position.length; n2++) {
-        const r2 = e2[n2],
-            o2 = t3.position[n2];
-        if (s2 = r2.field.isKeyField() ? DocumentKey.comparator(DocumentKey.fromName(o2.referenceValue), i2.key) : wv(o2, i2.data.field(r2.field)), "desc" === r2.dir && (s2 *= -1), 0 !== s2)
-            break;
-    }
-    return s2;
-}
-
-function Av(t3, e2) {
-    if (null === t3)
-        return null === e2;
-    if (null === e2)
-        return false;
-    if (t3.inclusive !== e2.inclusive || t3.position.length !== e2.position.length)
-        return false;
-    for (let i2 = 0; i2 < t3.position.length; i2++)
-        if (!bv(t3.position[i2], e2.position[i2]))
-            return false;
-    return true;
-}
-class OrderBy {
-    constructor(t3, e2 = "asc") {
-        this.field = t3, this.dir = e2;
-    }
-}
-
-function Dv(t3, e2) {
-    return t3.dir === e2.dir && t3.field.isEqual(e2.field);
-}
-class Filter {}
-class FieldFilter extends Filter {
-    constructor(t3, e2, i2) {
-        super(), this.field = t3, this.op = e2, this.value = i2;
-    }
-    static create(t3, e2, i2) {
-        return t3.isKeyField() ? "in" === e2 || "not-in" === e2 ? this.createKeyFieldInFilter(t3, e2, i2) : new __PRIVATE_KeyFieldFilter(t3, e2, i2) : "array-contains" === e2 ? new __PRIVATE_ArrayContainsFilter(t3, i2) : "in" === e2 ? new __PRIVATE_InFilter(t3, i2) : "not-in" === e2 ? new __PRIVATE_NotInFilter(t3, i2) : "array-contains-any" === e2 ? new __PRIVATE_ArrayContainsAnyFilter(t3, i2) : new FieldFilter(t3, e2, i2);
-    }
-    static createKeyFieldInFilter(t3, e2, i2) {
-        return "in" === e2 ? new __PRIVATE_KeyFieldInFilter(t3, i2) : new __PRIVATE_KeyFieldNotInFilter(t3, i2);
-    }
-    matches(t3) {
-        const e2 = t3.data.field(this.field);
-        return "!=" === this.op ? null !== e2 && this.matchesComparison(wv(e2, this.value)) : null !== e2 && vv(this.value) === vv(e2) && this.matchesComparison(wv(e2, this.value));
-    }
-    matchesComparison(t3) {
-        switch (this.op) {
-            case "<":
-                return t3 < 0;
-            case "<=":
-                return t3 <= 0;
-            case "==":
-                return 0 === t3;
-            case "!=":
-                return 0 !== t3;
-            case ">":
-                return t3 > 0;
-            case ">=":
-                return t3 >= 0;
-            default:
-                return Ky();
-        }
-    }
-    isInequality() {
-        return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0;
-    }
-    getFlattenedFilters() {
-        return [this];
-    }
-    getFilters() {
-        return [this];
-    }
-    getFirstInequalityField() {
-        return this.isInequality() ? this.field : null;
-    }
-}
-class CompositeFilter extends Filter {
-    constructor(t3, e2) {
-        super(), this.filters = t3, this.op = e2, this.ce = null;
-    }
-    static create(t3, e2) {
-        return new CompositeFilter(t3, e2);
-    }
-    matches(t3) {
-        return Lv(this) ? void 0 === this.filters.find((e2) => !e2.matches(t3)) : void 0 !== this.filters.find((e2) => e2.matches(t3));
-    }
-    getFlattenedFilters() {
-        return null !== this.ce || (this.ce = this.filters.reduce((t3, e2) => t3.concat(e2.getFlattenedFilters()), [])), this.ce;
-    }
-    getFilters() {
-        return Object.assign([], this.filters);
-    }
-    getFirstInequalityField() {
-        const t3 = this.le((t4) => t4.isInequality());
-        return null !== t3 ? t3.field : null;
-    }
-    le(t3) {
-        for (const e2 of this.getFlattenedFilters())
-            if (t3(e2))
-                return e2;
-        return null;
-    }
-}
-
-function Lv(t3) {
-    return "and" === t3.op;
-}
-
-function Ov(t3) {
-    return function(t4) {
-        for (const e2 of t4.filters)
-            if (e2 instanceof CompositeFilter)
-                return false;
-        return true;
-    }(t3) && Lv(t3);
-}
-
-function Fv(t3) {
-    if (t3 instanceof FieldFilter)
-        return t3.field.canonicalString() + t3.op.toString() + kv(t3.value);
-    if (Ov(t3))
-        return t3.filters.map((t4) => Fv(t4)).join(",");
-    {
-        const e2 = t3.filters.map((t4) => Fv(t4)).join(",");
-        return `${t3.op}(${e2})`;
-    }
-}
-
-function Nv(t3, e2) {
-    return t3 instanceof FieldFilter ? function(t4, e3) {
-        return e3 instanceof FieldFilter && t4.op === e3.op && t4.field.isEqual(e3.field) && bv(t4.value, e3.value);
-    }(t3, e2) : t3 instanceof CompositeFilter ? function(t4, e3) {
-        return e3 instanceof CompositeFilter && t4.op === e3.op && t4.filters.length === e3.filters.length && t4.filters.reduce((t5, i2, s2) => t5 && Nv(i2, e3.filters[s2]), true);
-    }(t3, e2) : void Ky();
-}
-
-function $v(t3) {
-    return t3 instanceof FieldFilter ? function(t4) {
-        return `${t4.field.canonicalString()} ${t4.op} ${kv(t4.value)}`;
-    }(t3) : t3 instanceof CompositeFilter ? function(t4) {
-        return t4.op.toString() + " {" + t4.getFilters().map($v).join(" ,") + "}";
-    }(t3) : "Filter";
-}
-class __PRIVATE_KeyFieldFilter extends FieldFilter {
-    constructor(t3, e2, i2) {
-        super(t3, e2, i2), this.key = DocumentKey.fromName(i2.referenceValue);
-    }
-    matches(t3) {
-        const e2 = DocumentKey.comparator(t3.key, this.key);
-        return this.matchesComparison(e2);
-    }
-}
-class __PRIVATE_KeyFieldInFilter extends FieldFilter {
-    constructor(t3, e2) {
-        super(t3, "in", e2), this.keys = Vv("in", e2);
-    }
-    matches(t3) {
-        return this.keys.some((e2) => e2.isEqual(t3.key));
-    }
-}
-class __PRIVATE_KeyFieldNotInFilter extends FieldFilter {
-    constructor(t3, e2) {
-        super(t3, "not-in", e2), this.keys = Vv("not-in", e2);
-    }
-    matches(t3) {
-        return !this.keys.some((e2) => e2.isEqual(t3.key));
-    }
-}
-
-function Vv(t3, e2) {
-    var i2;
-    return ((null === (i2 = e2.arrayValue) || void 0 === i2 ? void 0 : i2.values) || []).map((t4) => DocumentKey.fromName(t4.referenceValue));
-}
-class __PRIVATE_ArrayContainsFilter extends FieldFilter {
-    constructor(t3, e2) {
-        super(t3, "array-contains", e2);
-    }
-    matches(t3) {
-        const e2 = t3.data.field(this.field);
-        return Ev(e2) && _v(e2.arrayValue, this.value);
-    }
-}
-class __PRIVATE_InFilter extends FieldFilter {
-    constructor(t3, e2) {
-        super(t3, "in", e2);
-    }
-    matches(t3) {
-        const e2 = t3.data.field(this.field);
-        return null !== e2 && _v(this.value.arrayValue, e2);
-    }
-}
-class __PRIVATE_NotInFilter extends FieldFilter {
-    constructor(t3, e2) {
-        super(t3, "not-in", e2);
-    }
-    matches(t3) {
-        if (_v(this.value.arrayValue, {
-                nullValue: "NULL_VALUE"
-            }))
-            return false;
-        const e2 = t3.data.field(this.field);
-        return null !== e2 && !_v(this.value.arrayValue, e2);
-    }
-}
-class __PRIVATE_ArrayContainsAnyFilter extends FieldFilter {
-    constructor(t3, e2) {
-        super(t3, "array-contains-any", e2);
-    }
-    matches(t3) {
-        const e2 = t3.data.field(this.field);
-        return !(!Ev(e2) || !e2.arrayValue.values) && e2.arrayValue.values.some((t4) => _v(this.value.arrayValue, t4));
-    }
-}
-class __PRIVATE_TargetImpl {
-    constructor(t3, e2 = null, i2 = [], s2 = [], n2 = null, r2 = null, o2 = null) {
-        this.path = t3, this.collectionGroup = e2, this.orderBy = i2, this.filters = s2, this.limit = n2, this.startAt = r2, this.endAt = o2, this.he = null;
-    }
-}
-
-function zv(t3, e2 = null, i2 = [], s2 = [], n2 = null, r2 = null, o2 = null) {
-    return new __PRIVATE_TargetImpl(t3, e2, i2, s2, n2, r2, o2);
-}
-
-function Bv(t3) {
-    const e2 = Yy(t3);
-    if (null === e2.he) {
-        let t4 = e2.path.canonicalString();
-        null !== e2.collectionGroup && (t4 += "|cg:" + e2.collectionGroup), t4 += "|f:", t4 += e2.filters.map((t5) => Fv(t5)).join(","), t4 += "|ob:", t4 += e2.orderBy.map((t5) => function(t6) {
-            return t6.field.canonicalString() + t6.dir;
-        }(t5)).join(","), ov(e2.limit) || (t4 += "|l:", t4 += e2.limit), e2.startAt && (t4 += "|lb:", t4 += e2.startAt.inclusive ? "b:" : "a:", t4 += e2.startAt.position.map((t5) => kv(t5)).join(",")), e2.endAt && (t4 += "|ub:", t4 += e2.endAt.inclusive ? "a:" : "b:", t4 += e2.endAt.position.map((t5) => kv(t5)).join(",")), e2.he = t4;
-    }
-    return e2.he;
-}
-
-function Uv(t3, e2) {
-    if (t3.limit !== e2.limit)
-        return false;
-    if (t3.orderBy.length !== e2.orderBy.length)
-        return false;
-    for (let i2 = 0; i2 < t3.orderBy.length; i2++)
-        if (!Dv(t3.orderBy[i2], e2.orderBy[i2]))
-            return false;
-    if (t3.filters.length !== e2.filters.length)
-        return false;
-    for (let i2 = 0; i2 < t3.filters.length; i2++)
-        if (!Nv(t3.filters[i2], e2.filters[i2]))
-            return false;
-    return t3.collectionGroup === e2.collectionGroup && !!t3.path.isEqual(e2.path) && !!Av(t3.startAt, e2.startAt) && Av(t3.endAt, e2.endAt);
-}
-
-function jv(t3) {
-    return DocumentKey.isDocumentKey(t3.path) && null === t3.collectionGroup && 0 === t3.filters.length;
-}
-class __PRIVATE_QueryImpl {
-    constructor(t3, e2 = null, i2 = [], s2 = [], n2 = null, r2 = "F", o2 = null, a2 = null) {
-        this.path = t3, this.collectionGroup = e2, this.explicitOrderBy = i2, this.filters = s2, this.limit = n2, this.limitType = r2, this.startAt = o2, this.endAt = a2, this.Pe = null, this.Ie = null, this.startAt, this.endAt;
-    }
-}
-
-function Hv(t3) {
-    return new __PRIVATE_QueryImpl(t3);
-}
-
-function Wv(t3) {
-    return 0 === t3.filters.length && null === t3.limit && null == t3.startAt && null == t3.endAt && (0 === t3.explicitOrderBy.length || 1 === t3.explicitOrderBy.length && t3.explicitOrderBy[0].field.isKeyField());
-}
-
-function qv(t3) {
-    const e2 = Yy(t3);
-    if (null === e2.Pe) {
-        e2.Pe = [];
-        const t4 = function(t5) {
-                for (const e3 of t5.filters) {
-                    const t6 = e3.getFirstInequalityField();
-                    if (null !== t6)
-                        return t6;
-                }
-                return null;
-            }(e2),
-            i2 = function(t5) {
-                return t5.explicitOrderBy.length > 0 ? t5.explicitOrderBy[0].field : null;
-            }(e2);
-        if (null !== t4 && null === i2)
-            t4.isKeyField() || e2.Pe.push(new OrderBy(t4)), e2.Pe.push(new OrderBy(FieldPath$1.keyField(), "asc"));
-        else {
-            let t5 = false;
-            for (const i3 of e2.explicitOrderBy)
-                e2.Pe.push(i3), i3.field.isKeyField() && (t5 = true);
-            if (!t5) {
-                const t6 = e2.explicitOrderBy.length > 0 ? e2.explicitOrderBy[e2.explicitOrderBy.length - 1].dir : "asc";
-                e2.Pe.push(new OrderBy(FieldPath$1.keyField(), t6));
-            }
-        }
-    }
-    return e2.Pe;
-}
-
-function Kv(t3) {
-    const e2 = Yy(t3);
-    if (!e2.Ie)
-        if ("F" === e2.limitType)
-            e2.Ie = zv(e2.path, e2.collectionGroup, qv(e2), e2.filters, e2.limit, e2.startAt, e2.endAt);
-        else {
-            const t4 = [];
-            for (const i3 of qv(e2)) {
-                const e3 = "desc" === i3.dir ? "asc" : "desc";
-                t4.push(new OrderBy(i3.field, e3));
-            }
-            const i2 = e2.endAt ? new Bound(e2.endAt.position, e2.endAt.inclusive) : null,
-                s2 = e2.startAt ? new Bound(e2.startAt.position, e2.startAt.inclusive) : null;
-            e2.Ie = zv(e2.path, e2.collectionGroup, t4, e2.filters, e2.limit, i2, s2);
-        }
-    return e2.Ie;
-}
-
-function Gv(t3, e2, i2) {
-    return new __PRIVATE_QueryImpl(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), e2, i2, t3.startAt, t3.endAt);
-}
-
-function Yv(t3, e2) {
-    return Uv(Kv(t3), Kv(e2)) && t3.limitType === e2.limitType;
-}
-
-function Qv(t3) {
-    return `${Bv(Kv(t3))}|lt:${t3.limitType}`;
-}
-
-function Xv(t3) {
-    return `Query(target=${function(t4) {
-    let e2 = t4.path.canonicalString();
-    return null !== t4.collectionGroup && (e2 += " collectionGroup=" + t4.collectionGroup), t4.filters.length > 0 && (e2 += `, filters: [${t4.filters.map((t5) => $v(t5)).join(", ")}]`), ov(t4.limit) || (e2 += ", limit: " + t4.limit), t4.orderBy.length > 0 && (e2 += `, orderBy: [${t4.orderBy.map((t5) => function(t6) {
-      return `${t6.field.canonicalString()} (${t6.dir})`;
-    }(t5)).join(", ")}]`), t4.startAt && (e2 += ", startAt: ", e2 += t4.startAt.inclusive ? "b:" : "a:", e2 += t4.startAt.position.map((t5) => kv(t5)).join(",")), t4.endAt && (e2 += ", endAt: ", e2 += t4.endAt.inclusive ? "a:" : "b:", e2 += t4.endAt.position.map((t5) => kv(t5)).join(",")), `Target(${e2})`;
-  }(Kv(t3))}; limitType=${t3.limitType})`;
-}
-
-function Jv(t3, e2) {
-    return e2.isFoundDocument() && function(t4, e3) {
-        const i2 = e3.key.path;
-        return null !== t4.collectionGroup ? e3.key.hasCollectionId(t4.collectionGroup) && t4.path.isPrefixOf(i2) : DocumentKey.isDocumentKey(t4.path) ? t4.path.isEqual(i2) : t4.path.isImmediateParentOf(i2);
-    }(t3, e2) && function(t4, e3) {
-        for (const i2 of qv(t4))
-            if (!i2.field.isKeyField() && null === e3.data.field(i2.field))
-                return false;
-        return true;
-    }(t3, e2) && function(t4, e3) {
-        for (const i2 of t4.filters)
-            if (!i2.matches(e3))
-                return false;
-        return true;
-    }(t3, e2) && function(t4, e3) {
-        return !(t4.startAt && ! function(t5, e4, i2) {
-            const s2 = Rv(t5, e4, i2);
-            return t5.inclusive ? s2 <= 0 : s2 < 0;
-        }(t4.startAt, qv(t4), e3)) && !(t4.endAt && ! function(t5, e4, i2) {
-            const s2 = Rv(t5, e4, i2);
-            return t5.inclusive ? s2 >= 0 : s2 > 0;
-        }(t4.endAt, qv(t4), e3));
-    }(t3, e2);
-}
-
-function Zv(t3) {
-    return (e2, i2) => {
-        let s2 = false;
-        for (const n2 of qv(t3)) {
-            const t4 = tb(n2, e2, i2);
-            if (0 !== t4)
-                return t4;
-            s2 = s2 || n2.field.isKeyField();
-        }
-        return 0;
-    };
-}
-
-function tb(t3, e2, i2) {
-    const s2 = t3.field.isKeyField() ? DocumentKey.comparator(e2.key, i2.key) : function(t4, e3, i3) {
-        const s3 = e3.data.field(t4),
-            n2 = i3.data.field(t4);
-        return null !== s3 && null !== n2 ? wv(s3, n2) : Ky();
-    }(t3.field, e2, i2);
-    switch (t3.dir) {
-        case "asc":
-            return s2;
-        case "desc":
-            return -1 * s2;
-        default:
-            return Ky();
-    }
-}
-class ObjectMap {
-    constructor(t3, e2) {
-        this.mapKeyFn = t3, this.equalsFn = e2, this.inner = {}, this.innerSize = 0;
-    }
-    get(t3) {
-        const e2 = this.mapKeyFn(t3),
-            i2 = this.inner[e2];
-        if (void 0 !== i2) {
-            for (const [e3, s2] of i2)
-                if (this.equalsFn(e3, t3))
-                    return s2;
-        }
-    }
-    has(t3) {
-        return void 0 !== this.get(t3);
-    }
-    set(t3, e2) {
-        const i2 = this.mapKeyFn(t3),
-            s2 = this.inner[i2];
-        if (void 0 === s2)
-            return this.inner[i2] = [
-                [t3, e2]
-            ], void this.innerSize++;
-        for (let i3 = 0; i3 < s2.length; i3++)
-            if (this.equalsFn(s2[i3][0], t3))
-                return void(s2[i3] = [t3, e2]);
-        s2.push([t3, e2]), this.innerSize++;
-    }
-    delete(t3) {
-        const e2 = this.mapKeyFn(t3),
-            i2 = this.inner[e2];
-        if (void 0 === i2)
-            return false;
-        for (let s2 = 0; s2 < i2.length; s2++)
-            if (this.equalsFn(i2[s2][0], t3))
-                return 1 === i2.length ? delete this.inner[e2] : i2.splice(s2, 1), this.innerSize--, true;
-        return false;
-    }
-    forEach(t3) {
-        hv(this.inner, (e2, i2) => {
-            for (const [e3, s2] of i2)
-                t3(e3, s2);
-        });
-    }
-    isEmpty() {
-        return function(t3) {
-            for (const e2 in t3)
-                if (Object.prototype.hasOwnProperty.call(t3, e2))
-                    return false;
-            return true;
-        }(this.inner);
-    }
-    size() {
-        return this.innerSize;
-    }
-}
-const eb = new SortedMap(DocumentKey.comparator);
-
-function ib() {
-    return eb;
-}
-const sb = new SortedMap(DocumentKey.comparator);
-
-function rb(...t3) {
-    let e2 = sb;
-    for (const i2 of t3)
-        e2 = e2.insert(i2.key, i2);
-    return e2;
-}
-
-function ob(t3) {
-    let e2 = sb;
-    return t3.forEach((t4, i2) => e2 = e2.insert(t4, i2.overlayedDocument)), e2;
-}
-
-function ab() {
-    return hb();
-}
-
-function lb() {
-    return hb();
-}
-
-function hb() {
-    return new ObjectMap((t3) => t3.toString(), (t3, e2) => t3.isEqual(e2));
-}
-const cb = new SortedSet(DocumentKey.comparator);
-
-function ub(...t3) {
-    let e2 = cb;
-    for (const i2 of t3)
-        e2 = e2.add(i2);
-    return e2;
-}
-const db = new SortedSet(Jy);
-class TransformOperation {
-    constructor() {
-        this._ = void 0;
-    }
-}
-
-function fb(t3, e2, i2) {
-    return t3 instanceof __PRIVATE_ServerTimestampTransform ? function(t4, e3) {
-        const i3 = {
-            fields: {
-                __type__: {
-                    stringValue: "server_timestamp"
-                },
-                __local_write_time__: {
-                    timestampValue: {
-                        seconds: t4.seconds,
-                        nanos: t4.nanoseconds
-                    }
-                }
-            }
-        };
-        return e3 && pv(e3) && (e3 = mv(e3)), e3 && (i3.fields.__previous_value__ = e3), {
-            mapValue: i3
-        };
-    }(i2, e2) : t3 instanceof __PRIVATE_ArrayUnionTransformOperation ? gb(t3, e2) : t3 instanceof __PRIVATE_ArrayRemoveTransformOperation ? yb(t3, e2) : function(t4, e3) {
-        const i3 = function(t5, e4) {
-                return t5 instanceof __PRIVATE_NumericIncrementTransformOperation ? function(t6) {
-                    return Sv(t6) || function(t7) {
-                        return !!t7 && "doubleValue" in t7;
-                    }(t6);
-                }(e4) ? e4 : {
-                    integerValue: 0
-                } : null;
-            }(t4, e3),
-            s2 = vb(i3) + vb(t4.Te);
-        return Sv(i3) && Sv(t4.Te) ? function(t5) {
-            return {
-                integerValue: "" + t5
-            };
-        }(s2) : function(t5, e4) {
-            if (t5.useProto3Json) {
-                if (isNaN(e4))
-                    return {
-                        doubleValue: "NaN"
-                    };
-                if (e4 === 1 / 0)
-                    return {
-                        doubleValue: "Infinity"
-                    };
-                if (e4 === -1 / 0)
-                    return {
-                        doubleValue: "-Infinity"
-                    };
-            }
-            return {
-                doubleValue: av(e4) ? "-0" : e4
-            };
-        }(t4.serializer, s2);
-    }(t3, e2);
-}
-
-function mb(t3, e2, i2) {
-    return t3 instanceof __PRIVATE_ArrayUnionTransformOperation ? gb(t3, e2) : t3 instanceof __PRIVATE_ArrayRemoveTransformOperation ? yb(t3, e2) : i2;
-}
-class __PRIVATE_ServerTimestampTransform extends TransformOperation {}
-class __PRIVATE_ArrayUnionTransformOperation extends TransformOperation {
-    constructor(t3) {
-        super(), this.elements = t3;
-    }
-}
-
-function gb(t3, e2) {
-    const i2 = bb(e2);
-    for (const e3 of t3.elements)
-        i2.some((t4) => bv(t4, e3)) || i2.push(e3);
-    return {
-        arrayValue: {
-            values: i2
-        }
-    };
-}
-class __PRIVATE_ArrayRemoveTransformOperation extends TransformOperation {
-    constructor(t3) {
-        super(), this.elements = t3;
-    }
-}
-
-function yb(t3, e2) {
-    let i2 = bb(e2);
-    for (const e3 of t3.elements)
-        i2 = i2.filter((t4) => !bv(t4, e3));
-    return {
-        arrayValue: {
-            values: i2
-        }
-    };
-}
-class __PRIVATE_NumericIncrementTransformOperation extends TransformOperation {
-    constructor(t3, e2) {
-        super(), this.serializer = t3, this.Te = e2;
-    }
-}
-
-function vb(t3) {
-    return dv(t3.integerValue || t3.doubleValue);
-}
-
-function bb(t3) {
-    return Ev(t3) && t3.arrayValue.values ? t3.arrayValue.values.slice() : [];
-}
-class Precondition {
-    constructor(t3, e2) {
-        this.updateTime = t3, this.exists = e2;
-    }
-    static none() {
-        return new Precondition();
-    }
-    static exists(t3) {
-        return new Precondition(void 0, t3);
-    }
-    static updateTime(t3) {
-        return new Precondition(t3);
-    }
-    get isNone() {
-        return void 0 === this.updateTime && void 0 === this.exists;
-    }
-    isEqual(t3) {
-        return this.exists === t3.exists && (this.updateTime ? !!t3.updateTime && this.updateTime.isEqual(t3.updateTime) : !t3.updateTime);
-    }
-}
-
-function _b(t3, e2) {
-    return void 0 !== t3.updateTime ? e2.isFoundDocument() && e2.version.isEqual(t3.updateTime) : void 0 === t3.exists || t3.exists === e2.isFoundDocument();
-}
-class Mutation {}
-
-function wb(t3, e2) {
-    if (!t3.hasLocalMutations || e2 && 0 === e2.fields.length)
-        return null;
-    if (null === e2)
-        return t3.isNoDocument() ? new __PRIVATE_DeleteMutation(t3.key, Precondition.none()) : new __PRIVATE_SetMutation(t3.key, t3.data, Precondition.none());
-    {
-        const i2 = t3.data,
-            s2 = ObjectValue.empty();
-        let n2 = new SortedSet(FieldPath$1.comparator);
-        for (let t4 of e2.fields)
-            if (!n2.has(t4)) {
-                let e3 = i2.field(t4);
-                null === e3 && t4.length > 1 && (t4 = t4.popLast(), e3 = i2.field(t4)), null === e3 ? s2.delete(t4) : s2.set(t4, e3), n2 = n2.add(t4);
-            }
-        return new __PRIVATE_PatchMutation(t3.key, s2, new FieldMask(n2.toArray()), Precondition.none());
-    }
-}
-
-function xb(t3, e2, i2) {
-    t3 instanceof __PRIVATE_SetMutation ? function(t4, e3, i3) {
-        const s2 = t4.value.clone(),
-            n2 = Cb(t4.fieldTransforms, e3, i3.transformResults);
-        s2.setAll(n2), e3.convertToFoundDocument(i3.version, s2).setHasCommittedMutations();
-    }(t3, e2, i2) : t3 instanceof __PRIVATE_PatchMutation ? function(t4, e3, i3) {
-        if (!_b(t4.precondition, e3))
-            return void e3.convertToUnknownDocument(i3.version);
-        const s2 = Cb(t4.fieldTransforms, e3, i3.transformResults),
-            n2 = e3.data;
-        n2.setAll(Eb(t4)), n2.setAll(s2), e3.convertToFoundDocument(i3.version, n2).setHasCommittedMutations();
-    }(t3, e2, i2) : function(t4, e3, i3) {
-        e3.convertToNoDocument(i3.version).setHasCommittedMutations();
-    }(0, e2, i2);
-}
-
-function Tb(t3, e2, i2, s2) {
-    return t3 instanceof __PRIVATE_SetMutation ? function(t4, e3, i3, s3) {
-        if (!_b(t4.precondition, e3))
-            return i3;
-        const n2 = t4.value.clone(),
-            r2 = Ib(t4.fieldTransforms, s3, e3);
-        return n2.setAll(r2), e3.convertToFoundDocument(e3.version, n2).setHasLocalMutations(), null;
-    }(t3, e2, i2, s2) : t3 instanceof __PRIVATE_PatchMutation ? function(t4, e3, i3, s3) {
-        if (!_b(t4.precondition, e3))
-            return i3;
-        const n2 = Ib(t4.fieldTransforms, s3, e3),
-            r2 = e3.data;
-        return r2.setAll(Eb(t4)), r2.setAll(n2), e3.convertToFoundDocument(e3.version, r2).setHasLocalMutations(), null === i3 ? null : i3.unionWith(t4.fieldMask.fields).unionWith(t4.fieldTransforms.map((t5) => t5.field));
-    }(t3, e2, i2, s2) : function(t4, e3, i3) {
-        return _b(t4.precondition, e3) ? (e3.convertToNoDocument(e3.version).setHasLocalMutations(), null) : i3;
-    }(t3, e2, i2);
-}
-
-function Sb(t3, e2) {
-    return t3.type === e2.type && !!t3.key.isEqual(e2.key) && !!t3.precondition.isEqual(e2.precondition) && !! function(t4, e3) {
-        return void 0 === t4 && void 0 === e3 || !(!t4 || !e3) && Zy(t4, e3, (t5, e4) => function(t6, e5) {
-            return t6.field.isEqual(e5.field) && function(t7, e6) {
-                return t7 instanceof __PRIVATE_ArrayUnionTransformOperation && e6 instanceof __PRIVATE_ArrayUnionTransformOperation || t7 instanceof __PRIVATE_ArrayRemoveTransformOperation && e6 instanceof __PRIVATE_ArrayRemoveTransformOperation ? Zy(t7.elements, e6.elements, bv) : t7 instanceof __PRIVATE_NumericIncrementTransformOperation && e6 instanceof __PRIVATE_NumericIncrementTransformOperation ? bv(t7.Te, e6.Te) : t7 instanceof __PRIVATE_ServerTimestampTransform && e6 instanceof __PRIVATE_ServerTimestampTransform;
-            }(t6.transform, e5.transform);
-        }(t5, e4));
-    }(t3.fieldTransforms, e2.fieldTransforms) && (0 === t3.type ? t3.value.isEqual(e2.value) : 1 !== t3.type || t3.data.isEqual(e2.data) && t3.fieldMask.isEqual(e2.fieldMask));
-}
-class __PRIVATE_SetMutation extends Mutation {
-    constructor(t3, e2, i2, s2 = []) {
-        super(), this.key = t3, this.value = e2, this.precondition = i2, this.fieldTransforms = s2, this.type = 0;
-    }
-    getFieldMask() {
-        return null;
-    }
-}
-class __PRIVATE_PatchMutation extends Mutation {
-    constructor(t3, e2, i2, s2, n2 = []) {
-        super(), this.key = t3, this.data = e2, this.fieldMask = i2, this.precondition = s2, this.fieldTransforms = n2, this.type = 1;
-    }
-    getFieldMask() {
-        return this.fieldMask;
-    }
-}
-
-function Eb(t3) {
-    const e2 = /* @__PURE__ */ new Map();
-    return t3.fieldMask.fields.forEach((i2) => {
-        if (!i2.isEmpty()) {
-            const s2 = t3.data.field(i2);
-            e2.set(i2, s2);
-        }
-    }), e2;
-}
-
-function Cb(t3, e2, i2) {
-    const s2 = /* @__PURE__ */ new Map();
-    Gy(t3.length === i2.length);
-    for (let n2 = 0; n2 < i2.length; n2++) {
-        const r2 = t3[n2],
-            o2 = r2.transform,
-            a2 = e2.data.field(r2.field);
-        s2.set(r2.field, mb(o2, a2, i2[n2]));
-    }
-    return s2;
-}
-
-function Ib(t3, e2, i2) {
-    const s2 = /* @__PURE__ */ new Map();
-    for (const n2 of t3) {
-        const t4 = n2.transform,
-            r2 = i2.data.field(n2.field);
-        s2.set(n2.field, fb(t4, r2, e2));
-    }
-    return s2;
-}
-class __PRIVATE_DeleteMutation extends Mutation {
-    constructor(t3, e2) {
-        super(), this.key = t3, this.precondition = e2, this.type = 2, this.fieldTransforms = [];
-    }
-    getFieldMask() {
-        return null;
-    }
-}
-class MutationBatch {
-    constructor(t3, e2, i2, s2) {
-        this.batchId = t3, this.localWriteTime = e2, this.baseMutations = i2, this.mutations = s2;
-    }
-    applyToRemoteDocument(t3, e2) {
-        const i2 = e2.mutationResults;
-        for (let e3 = 0; e3 < this.mutations.length; e3++) {
-            const s2 = this.mutations[e3];
-            s2.key.isEqual(t3.key) && xb(s2, t3, i2[e3]);
-        }
-    }
-    applyToLocalView(t3, e2) {
-        for (const i2 of this.baseMutations)
-            i2.key.isEqual(t3.key) && (e2 = Tb(i2, t3, e2, this.localWriteTime));
-        for (const i2 of this.mutations)
-            i2.key.isEqual(t3.key) && (e2 = Tb(i2, t3, e2, this.localWriteTime));
-        return e2;
-    }
-    applyToLocalDocumentSet(t3, e2) {
-        const i2 = lb();
-        return this.mutations.forEach((s2) => {
-            const n2 = t3.get(s2.key),
-                r2 = n2.overlayedDocument;
-            let o2 = this.applyToLocalView(r2, n2.mutatedFields);
-            o2 = e2.has(s2.key) ? null : o2;
-            const a2 = wb(r2, o2);
-            null !== a2 && i2.set(s2.key, a2), r2.isValidDocument() || r2.convertToNoDocument(SnapshotVersion.min());
-        }), i2;
-    }
-    keys() {
-        return this.mutations.reduce((t3, e2) => t3.add(e2.key), ub());
-    }
-    isEqual(t3) {
-        return this.batchId === t3.batchId && Zy(this.mutations, t3.mutations, (t4, e2) => Sb(t4, e2)) && Zy(this.baseMutations, t3.baseMutations, (t4, e2) => Sb(t4, e2));
-    }
-}
-class Overlay {
-    constructor(t3, e2) {
-        this.largestBatchId = t3, this.mutation = e2;
-    }
-    getKey() {
-        return this.mutation.key;
-    }
-    isEqual(t3) {
-        return null !== t3 && this.mutation === t3.mutation;
-    }
-    toString() {
-        return `Overlay{
-      largestBatchId: ${this.largestBatchId},
-      mutation: ${this.mutation.toString()}
-    }`;
-    }
-}
-class ExistenceFilter {
-    constructor(t3, e2) {
-        this.count = t3, this.unchangedNames = e2;
-    }
-}
-var Mb, Pb;
-
-function Rb(t3) {
-    if (void 0 === t3)
-        return Hy("GRPC error has no .code"), Qy.UNKNOWN;
-    switch (t3) {
-        case Mb.OK:
-            return Qy.OK;
-        case Mb.CANCELLED:
-            return Qy.CANCELLED;
-        case Mb.UNKNOWN:
-            return Qy.UNKNOWN;
-        case Mb.DEADLINE_EXCEEDED:
-            return Qy.DEADLINE_EXCEEDED;
-        case Mb.RESOURCE_EXHAUSTED:
-            return Qy.RESOURCE_EXHAUSTED;
-        case Mb.INTERNAL:
-            return Qy.INTERNAL;
-        case Mb.UNAVAILABLE:
-            return Qy.UNAVAILABLE;
-        case Mb.UNAUTHENTICATED:
-            return Qy.UNAUTHENTICATED;
-        case Mb.INVALID_ARGUMENT:
-            return Qy.INVALID_ARGUMENT;
-        case Mb.NOT_FOUND:
-            return Qy.NOT_FOUND;
-        case Mb.ALREADY_EXISTS:
-            return Qy.ALREADY_EXISTS;
-        case Mb.PERMISSION_DENIED:
-            return Qy.PERMISSION_DENIED;
-        case Mb.FAILED_PRECONDITION:
-            return Qy.FAILED_PRECONDITION;
-        case Mb.ABORTED:
-            return Qy.ABORTED;
-        case Mb.OUT_OF_RANGE:
-            return Qy.OUT_OF_RANGE;
-        case Mb.UNIMPLEMENTED:
-            return Qy.UNIMPLEMENTED;
-        case Mb.DATA_LOSS:
-            return Qy.DATA_LOSS;
-        default:
-            return Ky();
-    }
-}
-(Pb = Mb || (Mb = {}))[Pb.OK = 0] = "OK", Pb[Pb.CANCELLED = 1] = "CANCELLED", Pb[Pb.UNKNOWN = 2] = "UNKNOWN", Pb[Pb.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", Pb[Pb.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", Pb[Pb.NOT_FOUND = 5] = "NOT_FOUND", Pb[Pb.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", Pb[Pb.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", Pb[Pb.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", Pb[Pb.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", Pb[Pb.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", Pb[Pb.ABORTED = 10] = "ABORTED", Pb[Pb.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", Pb[Pb.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", Pb[Pb.INTERNAL = 13] = "INTERNAL", Pb[Pb.UNAVAILABLE = 14] = "UNAVAILABLE", Pb[Pb.DATA_LOSS = 15] = "DATA_LOSS";
-class __PRIVATE_TestingHooks {
-    constructor() {
-        this.onExistenceFilterMismatchCallbacks = /* @__PURE__ */ new Map();
-    }
-    static get instance() {
-        return Db;
-    }
-    static getOrCreateInstance() {
-        return null === Db && (Db = new __PRIVATE_TestingHooks()), Db;
-    }
-    onExistenceFilterMismatch(t3) {
-        const e2 = Symbol();
-        return this.onExistenceFilterMismatchCallbacks.set(e2, t3), () => this.onExistenceFilterMismatchCallbacks.delete(e2);
-    }
-    notifyOnExistenceFilterMismatch(t3) {
-        this.onExistenceFilterMismatchCallbacks.forEach((e2) => e2(t3));
-    }
-}
-let Db = null;
-const Lb = new $y([4294967295, 4294967295], 0);
-
-function Ob(t3) {
-    const e2 = new TextEncoder().encode(t3),
-        i2 = new Ny();
-    return i2.update(e2), new Uint8Array(i2.digest());
-}
-
-function Fb(t3) {
-    const e2 = new DataView(t3.buffer),
-        i2 = e2.getUint32(0, true),
-        s2 = e2.getUint32(4, true),
-        n2 = e2.getUint32(8, true),
-        r2 = e2.getUint32(12, true);
-    return [new $y([i2, s2], 0), new $y([n2, r2], 0)];
-}
-class BloomFilter {
-    constructor(t3, e2, i2) {
-        if (this.bitmap = t3, this.padding = e2, this.hashCount = i2, e2 < 0 || e2 >= 8)
-            throw new __PRIVATE_BloomFilterError(`Invalid padding: ${e2}`);
-        if (i2 < 0)
-            throw new __PRIVATE_BloomFilterError(`Invalid hash count: ${i2}`);
-        if (t3.length > 0 && 0 === this.hashCount)
-            throw new __PRIVATE_BloomFilterError(`Invalid hash count: ${i2}`);
-        if (0 === t3.length && 0 !== e2)
-            throw new __PRIVATE_BloomFilterError(`Invalid padding when bitmap length is 0: ${e2}`);
-        this.de = 8 * t3.length - e2, this.Ae = $y.fromNumber(this.de);
-    }
-    Re(t3, e2, i2) {
-        let s2 = t3.add(e2.multiply($y.fromNumber(i2)));
-        return 1 === s2.compare(Lb) && (s2 = new $y([s2.getBits(0), s2.getBits(1)], 0)), s2.modulo(this.Ae).toNumber();
-    }
-    Ve(t3) {
-        return 0 != (this.bitmap[Math.floor(t3 / 8)] & 1 << t3 % 8);
-    }
-    mightContain(t3) {
-        if (0 === this.de)
-            return false;
-        const e2 = Ob(t3),
-            [i2, s2] = Fb(e2);
-        for (let t4 = 0; t4 < this.hashCount; t4++) {
-            const e3 = this.Re(i2, s2, t4);
-            if (!this.Ve(e3))
-                return false;
-        }
-        return true;
-    }
-    static create(t3, e2, i2) {
-        const s2 = t3 % 8 == 0 ? 0 : 8 - t3 % 8,
-            n2 = new Uint8Array(Math.ceil(t3 / 8)),
-            r2 = new BloomFilter(n2, s2, e2);
-        return i2.forEach((t4) => r2.insert(t4)), r2;
-    }
-    insert(t3) {
-        if (0 === this.de)
-            return;
-        const e2 = Ob(t3),
-            [i2, s2] = Fb(e2);
-        for (let t4 = 0; t4 < this.hashCount; t4++) {
-            const e3 = this.Re(i2, s2, t4);
-            this.me(e3);
-        }
-    }
-    me(t3) {
-        const e2 = Math.floor(t3 / 8),
-            i2 = t3 % 8;
-        this.bitmap[e2] |= 1 << i2;
-    }
-}
-class __PRIVATE_BloomFilterError extends Error {
-    constructor() {
-        super(...arguments), this.name = "BloomFilterError";
-    }
-}
-class RemoteEvent {
-    constructor(t3, e2, i2, s2, n2) {
-        this.snapshotVersion = t3, this.targetChanges = e2, this.targetMismatches = i2, this.documentUpdates = s2, this.resolvedLimboDocuments = n2;
-    }
-    static createSynthesizedRemoteEventForCurrentChange(t3, e2, i2) {
-        const s2 = /* @__PURE__ */ new Map();
-        return s2.set(t3, TargetChange.createSynthesizedTargetChangeForCurrentChange(t3, e2, i2)), new RemoteEvent(SnapshotVersion.min(), s2, new SortedMap(Jy), ib(), ub());
-    }
-}
-class TargetChange {
-    constructor(t3, e2, i2, s2, n2) {
-        this.resumeToken = t3, this.current = e2, this.addedDocuments = i2, this.modifiedDocuments = s2, this.removedDocuments = n2;
-    }
-    static createSynthesizedTargetChangeForCurrentChange(t3, e2, i2) {
-        return new TargetChange(i2, e2, ub(), ub(), ub());
-    }
-}
-class __PRIVATE_DocumentWatchChange {
-    constructor(t3, e2, i2, s2) {
-        this.fe = t3, this.removedTargetIds = e2, this.key = i2, this.ge = s2;
-    }
-}
-class __PRIVATE_ExistenceFilterChange {
-    constructor(t3, e2) {
-        this.targetId = t3, this.pe = e2;
-    }
-}
-class __PRIVATE_WatchTargetChange {
-    constructor(t3, e2, i2 = ByteString.EMPTY_BYTE_STRING, s2 = null) {
-        this.state = t3, this.targetIds = e2, this.resumeToken = i2, this.cause = s2;
-    }
-}
-class __PRIVATE_TargetState {
-    constructor() {
-        this.ye = 0, this.we = $b(), this.Se = ByteString.EMPTY_BYTE_STRING, this.be = false, this.De = true;
-    }
-    get current() {
-        return this.be;
-    }
-    get resumeToken() {
-        return this.Se;
-    }
-    get ve() {
-        return 0 !== this.ye;
-    }
-    get Ce() {
-        return this.De;
-    }
-    Fe(t3) {
-        t3.approximateByteSize() > 0 && (this.De = true, this.Se = t3);
-    }
-    Me() {
-        let t3 = ub(),
-            e2 = ub(),
-            i2 = ub();
-        return this.we.forEach((s2, n2) => {
-            switch (n2) {
-                case 0:
-                    t3 = t3.add(s2);
-                    break;
-                case 2:
-                    e2 = e2.add(s2);
-                    break;
-                case 1:
-                    i2 = i2.add(s2);
-                    break;
-                default:
-                    Ky();
-            }
-        }), new TargetChange(this.Se, this.be, t3, e2, i2);
-    }
-    xe() {
-        this.De = false, this.we = $b();
-    }
-    Oe(t3, e2) {
-        this.De = true, this.we = this.we.insert(t3, e2);
-    }
-    Ne(t3) {
-        this.De = true, this.we = this.we.remove(t3);
-    }
-    Be() {
-        this.ye += 1;
-    }
-    Le() {
-        this.ye -= 1;
-    }
-    ke() {
-        this.De = true, this.be = true;
-    }
-}
-class __PRIVATE_WatchChangeAggregator {
-    constructor(t3) {
-        this.qe = t3, this.Qe = /* @__PURE__ */ new Map(), this.Ke = ib(), this.$e = Nb(), this.Ue = new SortedMap(Jy);
-    }
-    We(t3) {
-        for (const e2 of t3.fe)
-            t3.ge && t3.ge.isFoundDocument() ? this.Ge(e2, t3.ge) : this.ze(e2, t3.key, t3.ge);
-        for (const e2 of t3.removedTargetIds)
-            this.ze(e2, t3.key, t3.ge);
-    }
-    je(t3) {
-        this.forEachTarget(t3, (e2) => {
-            const i2 = this.He(e2);
-            switch (t3.state) {
-                case 0:
-                    this.Je(e2) && i2.Fe(t3.resumeToken);
-                    break;
-                case 1:
-                    i2.Le(), i2.ve || i2.xe(), i2.Fe(t3.resumeToken);
-                    break;
-                case 2:
-                    i2.Le(), i2.ve || this.removeTarget(e2);
-                    break;
-                case 3:
-                    this.Je(e2) && (i2.ke(), i2.Fe(t3.resumeToken));
-                    break;
-                case 4:
-                    this.Je(e2) && (this.Ye(e2), i2.Fe(t3.resumeToken));
-                    break;
-                default:
-                    Ky();
-            }
-        });
-    }
-    forEachTarget(t3, e2) {
-        t3.targetIds.length > 0 ? t3.targetIds.forEach(e2) : this.Qe.forEach((t4, i2) => {
-            this.Je(i2) && e2(i2);
-        });
-    }
-    Ze(t3) {
-        var e2, i2;
-        const s2 = t3.targetId,
-            n2 = t3.pe.count,
-            r2 = this.Xe(s2);
-        if (r2) {
-            const o2 = r2.target;
-            if (jv(o2))
-                if (0 === n2) {
-                    const t4 = new DocumentKey(o2.path);
-                    this.ze(s2, t4, MutableDocument.newNoDocument(t4, SnapshotVersion.min()));
-                } else
-                    Gy(1 === n2);
-            else {
-                const r3 = this.et(s2);
-                if (r3 !== n2) {
-                    const n3 = this.tt(t3, r3);
-                    if (0 !== n3.status) {
-                        this.Ye(s2);
-                        const t4 = 2 === n3.status ? "TargetPurposeExistenceFilterMismatchBloom" : "TargetPurposeExistenceFilterMismatch";
-                        this.Ue = this.Ue.insert(s2, t4);
-                    }
-                    null === (e2 = __PRIVATE_TestingHooks.instance) || void 0 === e2 || e2.notifyOnExistenceFilterMismatch(function(t4, e3, i3, s3) {
-                        var n4, r4, o3, a2, l2, h2;
-                        const c2 = {
-                                localCacheCount: i3,
-                                existenceFilterCount: s3.count
-                            },
-                            u2 = s3.unchangedNames;
-                        return u2 && (c2.bloomFilter = {
-                            applied: 0 === t4,
-                            hashCount: null !== (n4 = null == u2 ? void 0 : u2.hashCount) && void 0 !== n4 ? n4 : 0,
-                            bitmapLength: null !== (a2 = null === (o3 = null === (r4 = null == u2 ? void 0 : u2.bits) || void 0 === r4 ? void 0 : r4.bitmap) || void 0 === o3 ? void 0 : o3.length) && void 0 !== a2 ? a2 : 0,
-                            padding: null !== (h2 = null === (l2 = null == u2 ? void 0 : u2.bits) || void 0 === l2 ? void 0 : l2.padding) && void 0 !== h2 ? h2 : 0
-                        }, e3 && (c2.bloomFilter.mightContain = e3)), c2;
-                    }(n3.status, null !== (i2 = n3.nt) && void 0 !== i2 ? i2 : null, r3, t3.pe));
-                }
-            }
-        }
-    }
-    tt(t3, e2) {
-        const {
-            unchangedNames: i2,
-            count: s2
-        } = t3.pe;
-        if (!i2 || !i2.bits)
-            return {
-                status: 1
-            };
-        const {
-            bits: {
-                bitmap: n2 = "",
-                padding: r2 = 0
-            },
-            hashCount: o2 = 0
-        } = i2;
-        let a2, l2;
-        try {
-            a2 = fv(n2).toUint8Array();
-        } catch (t4) {
-            if (t4 instanceof __PRIVATE_Base64DecodeError)
-                return Wy("Decoding the base64 bloom filter in existence filter failed (" + t4.message + "); ignoring the bloom filter and falling back to full re-query."), {
-                    status: 1
-                };
-            throw t4;
-        }
-        try {
-            l2 = new BloomFilter(a2, r2, o2);
-        } catch (t4) {
-            return Wy(t4 instanceof __PRIVATE_BloomFilterError ? "BloomFilter error: " : "Applying bloom filter failed: ", t4), {
-                status: 1
-            };
-        }
-        const h2 = (t4) => {
-            const e3 = this.qe.rt();
-            return l2.mightContain(`projects/${e3.projectId}/databases/${e3.database}/documents/${t4}`);
-        };
-        return 0 === l2.de ? {
-            status: 1
-        } : {
-            status: s2 === e2 - this.it(t3.targetId, h2) ? 0 : 2,
-            nt: h2
-        };
-    }
-    it(t3, e2) {
-        const i2 = this.qe.getRemoteKeysForTarget(t3);
-        let s2 = 0;
-        return i2.forEach((i3) => {
-            e2(i3.path.canonicalString()) || (this.ze(t3, i3, null), s2++);
-        }), s2;
-    }
-    st(t3) {
-        const e2 = /* @__PURE__ */ new Map();
-        this.Qe.forEach((i3, s3) => {
-            const n2 = this.Xe(s3);
-            if (n2) {
-                if (i3.current && jv(n2.target)) {
-                    const e3 = new DocumentKey(n2.target.path);
-                    null !== this.Ke.get(e3) || this.ot(s3, e3) || this.ze(s3, e3, MutableDocument.newNoDocument(e3, t3));
-                }
-                i3.Ce && (e2.set(s3, i3.Me()), i3.xe());
-            }
-        });
-        let i2 = ub();
-        this.$e.forEach((t4, e3) => {
-            let s3 = true;
-            e3.forEachWhile((t5) => {
-                const e4 = this.Xe(t5);
-                return !e4 || "TargetPurposeLimboResolution" === e4.purpose || (s3 = false, false);
-            }), s3 && (i2 = i2.add(t4));
-        }), this.Ke.forEach((e3, i3) => i3.setReadTime(t3));
-        const s2 = new RemoteEvent(t3, e2, this.Ue, this.Ke, i2);
-        return this.Ke = ib(), this.$e = Nb(), this.Ue = new SortedMap(Jy), s2;
-    }
-    Ge(t3, e2) {
-        if (!this.Je(t3))
-            return;
-        const i2 = this.ot(t3, e2.key) ? 2 : 0;
-        this.He(t3).Oe(e2.key, i2), this.Ke = this.Ke.insert(e2.key, e2), this.$e = this.$e.insert(e2.key, this._t(e2.key).add(t3));
-    }
-    ze(t3, e2, i2) {
-        if (!this.Je(t3))
-            return;
-        const s2 = this.He(t3);
-        this.ot(t3, e2) ? s2.Oe(e2, 1) : s2.Ne(e2), this.$e = this.$e.insert(e2, this._t(e2).delete(t3)), i2 && (this.Ke = this.Ke.insert(e2, i2));
-    }
-    removeTarget(t3) {
-        this.Qe.delete(t3);
-    }
-    et(t3) {
-        const e2 = this.He(t3).Me();
-        return this.qe.getRemoteKeysForTarget(t3).size + e2.addedDocuments.size - e2.removedDocuments.size;
-    }
-    Be(t3) {
-        this.He(t3).Be();
-    }
-    He(t3) {
-        let e2 = this.Qe.get(t3);
-        return e2 || (e2 = new __PRIVATE_TargetState(), this.Qe.set(t3, e2)), e2;
-    }
-    _t(t3) {
-        let e2 = this.$e.get(t3);
-        return e2 || (e2 = new SortedSet(Jy), this.$e = this.$e.insert(t3, e2)), e2;
-    }
-    Je(t3) {
-        const e2 = null !== this.Xe(t3);
-        return e2 || jy("WatchChangeAggregator", "Detected inactive target", t3), e2;
-    }
-    Xe(t3) {
-        const e2 = this.Qe.get(t3);
-        return e2 && e2.ve ? null : this.qe.ut(t3);
-    }
-    Ye(t3) {
-        this.Qe.set(t3, new __PRIVATE_TargetState()), this.qe.getRemoteKeysForTarget(t3).forEach((e2) => {
-            this.ze(t3, e2, null);
-        });
-    }
-    ot(t3, e2) {
-        return this.qe.getRemoteKeysForTarget(t3).has(e2);
-    }
-}
-
-function Nb() {
-    return new SortedMap(DocumentKey.comparator);
-}
-
-function $b() {
-    return new SortedMap(DocumentKey.comparator);
-}
-const Vb = {
-        asc: "ASCENDING",
-        desc: "DESCENDING"
-    },
-    zb = {
-        "<": "LESS_THAN",
-        "<=": "LESS_THAN_OR_EQUAL",
-        ">": "GREATER_THAN",
-        ">=": "GREATER_THAN_OR_EQUAL",
-        "==": "EQUAL",
-        "!=": "NOT_EQUAL",
-        "array-contains": "ARRAY_CONTAINS",
-        in: "IN",
-        "not-in": "NOT_IN",
-        "array-contains-any": "ARRAY_CONTAINS_ANY"
-    },
-    Bb = {
-        and: "AND",
-        or: "OR"
-    };
-class JsonProtoSerializer {
-    constructor(t3, e2) {
-        this.databaseId = t3, this.useProto3Json = e2;
-    }
-}
-
-function Ub(t3, e2) {
-    return t3.useProto3Json || ov(e2) ? e2 : {
-        value: e2
-    };
-}
-
-function jb(t3) {
-    return Gy(!!t3), SnapshotVersion.fromTimestamp(function(t4) {
-        const e2 = uv(t4);
-        return new Timestamp(e2.seconds, e2.nanos);
-    }(t3));
-}
-
-function Hb(t3) {
-    const e2 = ResourcePath.fromString(t3);
-    return Gy(r_(e2)), e2;
-}
-
-function Wb(t3, e2) {
-    const i2 = Hb(e2);
-    if (i2.get(1) !== t3.databaseId.projectId)
-        throw new FirestoreError(Qy.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + i2.get(1) + " vs " + t3.databaseId.projectId);
-    if (i2.get(3) !== t3.databaseId.database)
-        throw new FirestoreError(Qy.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + i2.get(3) + " vs " + t3.databaseId.database);
-    return new DocumentKey(Gb(i2));
-}
-
-function qb(t3, e2) {
-    return function(t4, e3) {
-        return function(t5) {
-            return new ResourcePath(["projects", t5.projectId, "databases", t5.database]);
-        }(t4).child("documents").child(e3).canonicalString();
-    }(t3.databaseId, e2);
-}
-
-function Kb(t3) {
-    return new ResourcePath(["projects", t3.databaseId.projectId, "databases", t3.databaseId.database]).canonicalString();
-}
-
-function Gb(t3) {
-    return Gy(t3.length > 4 && "documents" === t3.get(4)), t3.popFirst(5);
-}
-
-function Yb(t3, e2) {
-    return {
-        documents: [qb(t3, e2.path)]
-    };
-}
-
-function Qb(t3, e2) {
-    const i2 = {
-            structuredQuery: {}
-        },
-        s2 = e2.path;
-    null !== e2.collectionGroup ? (i2.parent = qb(t3, s2), i2.structuredQuery.from = [{
-        collectionId: e2.collectionGroup,
-        allDescendants: true
-    }]) : (i2.parent = qb(t3, s2.popLast()), i2.structuredQuery.from = [{
-        collectionId: s2.lastSegment()
-    }]);
-    const n2 = function(t4) {
-        if (0 !== t4.length)
-            return n_(CompositeFilter.create(t4, "and"));
-    }(e2.filters);
-    n2 && (i2.structuredQuery.where = n2);
-    const r2 = function(t4) {
-        if (0 !== t4.length)
-            return t4.map((t5) => function(t6) {
-                return {
-                    field: i_(t6.field),
-                    direction: Zb(t6.dir)
-                };
-            }(t5));
-    }(e2.orderBy);
-    r2 && (i2.structuredQuery.orderBy = r2);
-    const o2 = Ub(t3, e2.limit);
-    return null !== o2 && (i2.structuredQuery.limit = o2), e2.startAt && (i2.structuredQuery.startAt = function(t4) {
-        return {
-            before: t4.inclusive,
-            values: t4.position
-        };
-    }(e2.startAt)), e2.endAt && (i2.structuredQuery.endAt = function(t4) {
-        return {
-            before: !t4.inclusive,
-            values: t4.position
-        };
-    }(e2.endAt)), i2;
-}
-
-function Xb(t3) {
-    let e2 = function(t4) {
-        const e3 = Hb(t4);
-        return 4 === e3.length ? ResourcePath.emptyPath() : Gb(e3);
-    }(t3.parent);
-    const i2 = t3.structuredQuery,
-        s2 = i2.from ? i2.from.length : 0;
-    let n2 = null;
-    if (s2 > 0) {
-        Gy(1 === s2);
-        const t4 = i2.from[0];
-        t4.allDescendants ? n2 = t4.collectionId : e2 = e2.child(t4.collectionId);
-    }
-    let r2 = [];
-    i2.where && (r2 = function(t4) {
-        const e3 = Jb(t4);
-        return e3 instanceof CompositeFilter && Ov(e3) ? e3.getFilters() : [e3];
-    }(i2.where));
-    let o2 = [];
-    i2.orderBy && (o2 = function(t4) {
-        return t4.map((t5) => function(t6) {
-            return new OrderBy(s_(t6.field), function(t7) {
-                switch (t7) {
-                    case "ASCENDING":
-                        return "asc";
-                    case "DESCENDING":
-                        return "desc";
-                    default:
-                        return;
-                }
-            }(t6.direction));
-        }(t5));
-    }(i2.orderBy));
-    let a2 = null;
-    i2.limit && (a2 = function(t4) {
-        let e3;
-        return e3 = "object" == typeof t4 ? t4.value : t4, ov(e3) ? null : e3;
-    }(i2.limit));
-    let l2 = null;
-    i2.startAt && (l2 = function(t4) {
-        const e3 = !!t4.before,
-            i3 = t4.values || [];
-        return new Bound(i3, e3);
-    }(i2.startAt));
-    let h2 = null;
-    return i2.endAt && (h2 = function(t4) {
-            const e3 = !t4.before,
-                i3 = t4.values || [];
-            return new Bound(i3, e3);
-        }(i2.endAt)),
-        function(t4, e3, i3, s3, n3, r3, o3, a3) {
-            return new __PRIVATE_QueryImpl(t4, e3, i3, s3, n3, r3, o3, a3);
-        }(e2, n2, o2, r2, a2, "F", l2, h2);
-}
-
-function Jb(t3) {
-    return void 0 !== t3.unaryFilter ? function(t4) {
-        switch (t4.unaryFilter.op) {
-            case "IS_NAN":
-                const e2 = s_(t4.unaryFilter.field);
-                return FieldFilter.create(e2, "==", {
-                    doubleValue: NaN
-                });
-            case "IS_NULL":
-                const i2 = s_(t4.unaryFilter.field);
-                return FieldFilter.create(i2, "==", {
-                    nullValue: "NULL_VALUE"
-                });
-            case "IS_NOT_NAN":
-                const s2 = s_(t4.unaryFilter.field);
-                return FieldFilter.create(s2, "!=", {
-                    doubleValue: NaN
-                });
-            case "IS_NOT_NULL":
-                const n2 = s_(t4.unaryFilter.field);
-                return FieldFilter.create(n2, "!=", {
-                    nullValue: "NULL_VALUE"
-                });
-            default:
-                return Ky();
-        }
-    }(t3) : void 0 !== t3.fieldFilter ? function(t4) {
-        return FieldFilter.create(s_(t4.fieldFilter.field), function(t5) {
-            switch (t5) {
-                case "EQUAL":
-                    return "==";
-                case "NOT_EQUAL":
-                    return "!=";
-                case "GREATER_THAN":
-                    return ">";
-                case "GREATER_THAN_OR_EQUAL":
-                    return ">=";
-                case "LESS_THAN":
-                    return "<";
-                case "LESS_THAN_OR_EQUAL":
-                    return "<=";
-                case "ARRAY_CONTAINS":
-                    return "array-contains";
-                case "IN":
-                    return "in";
-                case "NOT_IN":
-                    return "not-in";
-                case "ARRAY_CONTAINS_ANY":
-                    return "array-contains-any";
-                default:
-                    return Ky();
-            }
-        }(t4.fieldFilter.op), t4.fieldFilter.value);
-    }(t3) : void 0 !== t3.compositeFilter ? function(t4) {
-        return CompositeFilter.create(t4.compositeFilter.filters.map((t5) => Jb(t5)), function(t5) {
-            switch (t5) {
-                case "AND":
-                    return "and";
-                case "OR":
-                    return "or";
-                default:
-                    return Ky();
-            }
-        }(t4.compositeFilter.op));
-    }(t3) : Ky();
-}
-
-function Zb(t3) {
-    return Vb[t3];
-}
-
-function t_(t3) {
-    return zb[t3];
-}
-
-function e_(t3) {
-    return Bb[t3];
-}
-
-function i_(t3) {
-    return {
-        fieldPath: t3.canonicalString()
-    };
-}
-
-function s_(t3) {
-    return FieldPath$1.fromServerFormat(t3.fieldPath);
-}
-
-function n_(t3) {
-    return t3 instanceof FieldFilter ? function(t4) {
-        if ("==" === t4.op) {
-            if (Iv(t4.value))
-                return {
-                    unaryFilter: {
-                        field: i_(t4.field),
-                        op: "IS_NAN"
-                    }
-                };
-            if (Cv(t4.value))
-                return {
-                    unaryFilter: {
-                        field: i_(t4.field),
-                        op: "IS_NULL"
-                    }
-                };
-        } else if ("!=" === t4.op) {
-            if (Iv(t4.value))
-                return {
-                    unaryFilter: {
-                        field: i_(t4.field),
-                        op: "IS_NOT_NAN"
-                    }
-                };
-            if (Cv(t4.value))
-                return {
-                    unaryFilter: {
-                        field: i_(t4.field),
-                        op: "IS_NOT_NULL"
-                    }
-                };
-        }
-        return {
-            fieldFilter: {
-                field: i_(t4.field),
-                op: t_(t4.op),
-                value: t4.value
-            }
-        };
-    }(t3) : t3 instanceof CompositeFilter ? function(t4) {
-        const e2 = t4.getFilters().map((t5) => n_(t5));
-        return 1 === e2.length ? e2[0] : {
-            compositeFilter: {
-                op: e_(t4.op),
-                filters: e2
-            }
-        };
-    }(t3) : Ky();
-}
-
-function r_(t3) {
-    return t3.length >= 4 && "projects" === t3.get(0) && "databases" === t3.get(2);
-}
-class TargetData {
-    constructor(t3, e2, i2, s2, n2 = SnapshotVersion.min(), r2 = SnapshotVersion.min(), o2 = ByteString.EMPTY_BYTE_STRING, a2 = null) {
-        this.target = t3, this.targetId = e2, this.purpose = i2, this.sequenceNumber = s2, this.snapshotVersion = n2, this.lastLimboFreeSnapshotVersion = r2, this.resumeToken = o2, this.expectedCount = a2;
-    }
-    withSequenceNumber(t3) {
-        return new TargetData(this.target, this.targetId, this.purpose, t3, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, this.expectedCount);
-    }
-    withResumeToken(t3, e2) {
-        return new TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, e2, this.lastLimboFreeSnapshotVersion, t3, null);
-    }
-    withExpectedCount(t3) {
-        return new TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, t3);
-    }
-    withLastLimboFreeSnapshotVersion(t3) {
-        return new TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, t3, this.resumeToken, this.expectedCount);
-    }
-}
-class __PRIVATE_LocalSerializer {
-    constructor(t3) {
-        this.ct = t3;
-    }
-}
-
-function o_(t3) {
-    const e2 = Xb({
-        parent: t3.parent,
-        structuredQuery: t3.structuredQuery
-    });
-    return "LAST" === t3.limitType ? Gv(e2, e2.limit, "L") : e2;
-}
-class __PRIVATE_MemoryIndexManager {
-    constructor() {
-        this.sn = new __PRIVATE_MemoryCollectionParentIndex();
-    }
-    addToCollectionParentIndex(t3, e2) {
-        return this.sn.add(e2), PersistencePromise.resolve();
-    }
-    getCollectionParents(t3, e2) {
-        return PersistencePromise.resolve(this.sn.getEntries(e2));
-    }
-    addFieldIndex(t3, e2) {
-        return PersistencePromise.resolve();
-    }
-    deleteFieldIndex(t3, e2) {
-        return PersistencePromise.resolve();
-    }
-    getDocumentsMatchingTarget(t3, e2) {
-        return PersistencePromise.resolve(null);
-    }
-    getIndexType(t3, e2) {
-        return PersistencePromise.resolve(0);
-    }
-    getFieldIndexes(t3, e2) {
-        return PersistencePromise.resolve([]);
-    }
-    getNextCollectionGroupToUpdate(t3) {
-        return PersistencePromise.resolve(null);
-    }
-    getMinOffset(t3, e2) {
-        return PersistencePromise.resolve(IndexOffset.min());
-    }
-    getMinOffsetFromCollectionGroup(t3, e2) {
-        return PersistencePromise.resolve(IndexOffset.min());
-    }
-    updateCollectionGroup(t3, e2, i2) {
-        return PersistencePromise.resolve();
-    }
-    updateIndexEntries(t3, e2) {
-        return PersistencePromise.resolve();
-    }
-}
-class __PRIVATE_MemoryCollectionParentIndex {
-    constructor() {
-        this.index = {};
-    }
-    add(t3) {
-        const e2 = t3.lastSegment(),
-            i2 = t3.popLast(),
-            s2 = this.index[e2] || new SortedSet(ResourcePath.comparator),
-            n2 = !s2.has(i2);
-        return this.index[e2] = s2.add(i2), n2;
-    }
-    has(t3) {
-        const e2 = t3.lastSegment(),
-            i2 = t3.popLast(),
-            s2 = this.index[e2];
-        return s2 && s2.has(i2);
-    }
-    getEntries(t3) {
-        return (this.index[t3] || new SortedSet(ResourcePath.comparator)).toArray();
-    }
-}
-class __PRIVATE_TargetIdGenerator {
-    constructor(t3) {
-        this.Mn = t3;
-    }
-    next() {
-        return this.Mn += 2, this.Mn;
-    }
-    static xn() {
-        return new __PRIVATE_TargetIdGenerator(0);
-    }
-    static On() {
-        return new __PRIVATE_TargetIdGenerator(-1);
-    }
-}
-class RemoteDocumentChangeBuffer {
-    constructor() {
-        this.changes = new ObjectMap((t3) => t3.toString(), (t3, e2) => t3.isEqual(e2)), this.changesApplied = false;
-    }
-    addEntry(t3) {
-        this.assertNotApplied(), this.changes.set(t3.key, t3);
-    }
-    removeEntry(t3, e2) {
-        this.assertNotApplied(), this.changes.set(t3, MutableDocument.newInvalidDocument(t3).setReadTime(e2));
-    }
-    getEntry(t3, e2) {
-        this.assertNotApplied();
-        const i2 = this.changes.get(e2);
-        return void 0 !== i2 ? PersistencePromise.resolve(i2) : this.getFromCache(t3, e2);
-    }
-    getEntries(t3, e2) {
-        return this.getAllFromCache(t3, e2);
-    }
-    apply(t3) {
-        return this.assertNotApplied(), this.changesApplied = true, this.applyChanges(t3);
-    }
-    assertNotApplied() {}
-}
-class OverlayedDocument {
-    constructor(t3, e2) {
-        this.overlayedDocument = t3, this.mutatedFields = e2;
-    }
-}
-class LocalDocumentsView {
-    constructor(t3, e2, i2, s2) {
-        this.remoteDocumentCache = t3, this.mutationQueue = e2, this.documentOverlayCache = i2, this.indexManager = s2;
-    }
-    getDocument(t3, e2) {
-        let i2 = null;
-        return this.documentOverlayCache.getOverlay(t3, e2).next((s2) => (i2 = s2, this.remoteDocumentCache.getEntry(t3, e2))).next((t4) => (null !== i2 && Tb(i2.mutation, t4, FieldMask.empty(), Timestamp.now()), t4));
-    }
-    getDocuments(t3, e2) {
-        return this.remoteDocumentCache.getEntries(t3, e2).next((e3) => this.getLocalViewOfDocuments(t3, e3, ub()).next(() => e3));
-    }
-    getLocalViewOfDocuments(t3, e2, i2 = ub()) {
-        const s2 = ab();
-        return this.populateOverlays(t3, s2, e2).next(() => this.computeViews(t3, e2, s2, i2).next((t4) => {
-            let e3 = rb();
-            return t4.forEach((t5, i3) => {
-                e3 = e3.insert(t5, i3.overlayedDocument);
-            }), e3;
-        }));
-    }
-    getOverlayedDocuments(t3, e2) {
-        const i2 = ab();
-        return this.populateOverlays(t3, i2, e2).next(() => this.computeViews(t3, e2, i2, ub()));
-    }
-    populateOverlays(t3, e2, i2) {
-        const s2 = [];
-        return i2.forEach((t4) => {
-            e2.has(t4) || s2.push(t4);
-        }), this.documentOverlayCache.getOverlays(t3, s2).next((t4) => {
-            t4.forEach((t5, i3) => {
-                e2.set(t5, i3);
-            });
-        });
-    }
-    computeViews(t3, e2, i2, s2) {
-        let n2 = ib();
-        const r2 = hb(),
-            o2 = hb();
-        return e2.forEach((t4, e3) => {
-            const o3 = i2.get(e3.key);
-            s2.has(e3.key) && (void 0 === o3 || o3.mutation instanceof __PRIVATE_PatchMutation) ? n2 = n2.insert(e3.key, e3) : void 0 !== o3 ? (r2.set(e3.key, o3.mutation.getFieldMask()), Tb(o3.mutation, e3, o3.mutation.getFieldMask(), Timestamp.now())) : r2.set(e3.key, FieldMask.empty());
-        }), this.recalculateAndSaveOverlays(t3, n2).next((t4) => (t4.forEach((t5, e3) => r2.set(t5, e3)), e2.forEach((t5, e3) => {
-            var i3;
-            return o2.set(t5, new OverlayedDocument(e3, null !== (i3 = r2.get(t5)) && void 0 !== i3 ? i3 : null));
-        }), o2));
-    }
-    recalculateAndSaveOverlays(t3, e2) {
-        const i2 = hb();
-        let s2 = new SortedMap((t4, e3) => t4 - e3),
-            n2 = ub();
-        return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(t3, e2).next((t4) => {
-            for (const n3 of t4)
-                n3.keys().forEach((t5) => {
-                    const r2 = e2.get(t5);
-                    if (null === r2)
-                        return;
-                    let o2 = i2.get(t5) || FieldMask.empty();
-                    o2 = n3.applyToLocalView(r2, o2), i2.set(t5, o2);
-                    const a2 = (s2.get(n3.batchId) || ub()).add(t5);
-                    s2 = s2.insert(n3.batchId, a2);
-                });
-        }).next(() => {
-            const r2 = [],
-                o2 = s2.getReverseIterator();
-            for (; o2.hasNext();) {
-                const s3 = o2.getNext(),
-                    a2 = s3.key,
-                    l2 = s3.value,
-                    h2 = lb();
-                l2.forEach((t4) => {
-                    if (!n2.has(t4)) {
-                        const s4 = wb(e2.get(t4), i2.get(t4));
-                        null !== s4 && h2.set(t4, s4), n2 = n2.add(t4);
-                    }
-                }), r2.push(this.documentOverlayCache.saveOverlays(t3, a2, h2));
-            }
-            return PersistencePromise.waitFor(r2);
-        }).next(() => i2);
-    }
-    recalculateAndSaveOverlaysForDocumentKeys(t3, e2) {
-        return this.remoteDocumentCache.getEntries(t3, e2).next((e3) => this.recalculateAndSaveOverlays(t3, e3));
-    }
-    getDocumentsMatchingQuery(t3, e2, i2) {
-        return function(t4) {
-            return DocumentKey.isDocumentKey(t4.path) && null === t4.collectionGroup && 0 === t4.filters.length;
-        }(e2) ? this.getDocumentsMatchingDocumentQuery(t3, e2.path) : function(t4) {
-            return null !== t4.collectionGroup;
-        }(e2) ? this.getDocumentsMatchingCollectionGroupQuery(t3, e2, i2) : this.getDocumentsMatchingCollectionQuery(t3, e2, i2);
-    }
-    getNextDocuments(t3, e2, i2, s2) {
-        return this.remoteDocumentCache.getAllFromCollectionGroup(t3, e2, i2, s2).next((n2) => {
-            const r2 = s2 - n2.size > 0 ? this.documentOverlayCache.getOverlaysForCollectionGroup(t3, e2, i2.largestBatchId, s2 - n2.size) : PersistencePromise.resolve(ab());
-            let o2 = -1,
-                a2 = n2;
-            return r2.next((e3) => PersistencePromise.forEach(e3, (e4, i3) => (o2 < i3.largestBatchId && (o2 = i3.largestBatchId), n2.get(e4) ? PersistencePromise.resolve() : this.remoteDocumentCache.getEntry(t3, e4).next((t4) => {
-                a2 = a2.insert(e4, t4);
-            }))).next(() => this.populateOverlays(t3, e3, n2)).next(() => this.computeViews(t3, a2, e3, ub())).next((t4) => ({
-                batchId: o2,
-                changes: ob(t4)
-            })));
-        });
-    }
-    getDocumentsMatchingDocumentQuery(t3, e2) {
-        return this.getDocument(t3, new DocumentKey(e2)).next((t4) => {
-            let e3 = rb();
-            return t4.isFoundDocument() && (e3 = e3.insert(t4.key, t4)), e3;
-        });
-    }
-    getDocumentsMatchingCollectionGroupQuery(t3, e2, i2) {
-        const s2 = e2.collectionGroup;
-        let n2 = rb();
-        return this.indexManager.getCollectionParents(t3, s2).next((r2) => PersistencePromise.forEach(r2, (r3) => {
-            const o2 = function(t4, e3) {
-                return new __PRIVATE_QueryImpl(e3, null, t4.explicitOrderBy.slice(), t4.filters.slice(), t4.limit, t4.limitType, t4.startAt, t4.endAt);
-            }(e2, r3.child(s2));
-            return this.getDocumentsMatchingCollectionQuery(t3, o2, i2).next((t4) => {
-                t4.forEach((t5, e3) => {
-                    n2 = n2.insert(t5, e3);
-                });
-            });
-        }).next(() => n2));
-    }
-    getDocumentsMatchingCollectionQuery(t3, e2, i2) {
-        let s2;
-        return this.documentOverlayCache.getOverlaysForCollection(t3, e2.path, i2.largestBatchId).next((n2) => (s2 = n2, this.remoteDocumentCache.getDocumentsMatchingQuery(t3, e2, i2, s2))).next((t4) => {
-            s2.forEach((e3, i4) => {
-                const s3 = i4.getKey();
-                null === t4.get(s3) && (t4 = t4.insert(s3, MutableDocument.newInvalidDocument(s3)));
-            });
-            let i3 = rb();
-            return t4.forEach((t5, n2) => {
-                const r2 = s2.get(t5);
-                void 0 !== r2 && Tb(r2.mutation, n2, FieldMask.empty(), Timestamp.now()), Jv(e2, n2) && (i3 = i3.insert(t5, n2));
-            }), i3;
-        });
-    }
-}
-class __PRIVATE_MemoryBundleCache {
-    constructor(t3) {
-        this.serializer = t3, this.ar = /* @__PURE__ */ new Map(), this.ur = /* @__PURE__ */ new Map();
-    }
-    getBundleMetadata(t3, e2) {
-        return PersistencePromise.resolve(this.ar.get(e2));
-    }
-    saveBundleMetadata(t3, e2) {
-        return this.ar.set(e2.id, function(t4) {
-            return {
-                id: t4.id,
-                version: t4.version,
-                createTime: jb(t4.createTime)
-            };
-        }(e2)), PersistencePromise.resolve();
-    }
-    getNamedQuery(t3, e2) {
-        return PersistencePromise.resolve(this.ur.get(e2));
-    }
-    saveNamedQuery(t3, e2) {
-        return this.ur.set(e2.name, function(t4) {
-            return {
-                name: t4.name,
-                query: o_(t4.bundledQuery),
-                readTime: jb(t4.readTime)
-            };
-        }(e2)), PersistencePromise.resolve();
-    }
-}
-class __PRIVATE_MemoryDocumentOverlayCache {
-    constructor() {
-        this.overlays = new SortedMap(DocumentKey.comparator), this.cr = /* @__PURE__ */ new Map();
-    }
-    getOverlay(t3, e2) {
-        return PersistencePromise.resolve(this.overlays.get(e2));
-    }
-    getOverlays(t3, e2) {
-        const i2 = ab();
-        return PersistencePromise.forEach(e2, (e3) => this.getOverlay(t3, e3).next((t4) => {
-            null !== t4 && i2.set(e3, t4);
-        })).next(() => i2);
-    }
-    saveOverlays(t3, e2, i2) {
-        return i2.forEach((i3, s2) => {
-            this.ht(t3, e2, s2);
-        }), PersistencePromise.resolve();
-    }
-    removeOverlaysForBatchId(t3, e2, i2) {
-        const s2 = this.cr.get(i2);
-        return void 0 !== s2 && (s2.forEach((t4) => this.overlays = this.overlays.remove(t4)), this.cr.delete(i2)), PersistencePromise.resolve();
-    }
-    getOverlaysForCollection(t3, e2, i2) {
-        const s2 = ab(),
-            n2 = e2.length + 1,
-            r2 = new DocumentKey(e2.child("")),
-            o2 = this.overlays.getIteratorFrom(r2);
-        for (; o2.hasNext();) {
-            const t4 = o2.getNext().value,
-                r3 = t4.getKey();
-            if (!e2.isPrefixOf(r3.path))
-                break;
-            r3.path.length === n2 && t4.largestBatchId > i2 && s2.set(t4.getKey(), t4);
-        }
-        return PersistencePromise.resolve(s2);
-    }
-    getOverlaysForCollectionGroup(t3, e2, i2, s2) {
-        let n2 = new SortedMap((t4, e3) => t4 - e3);
-        const r2 = this.overlays.getIterator();
-        for (; r2.hasNext();) {
-            const t4 = r2.getNext().value;
-            if (t4.getKey().getCollectionGroup() === e2 && t4.largestBatchId > i2) {
-                let e3 = n2.get(t4.largestBatchId);
-                null === e3 && (e3 = ab(), n2 = n2.insert(t4.largestBatchId, e3)), e3.set(t4.getKey(), t4);
-            }
-        }
-        const o2 = ab(),
-            a2 = n2.getIterator();
-        for (; a2.hasNext() && (a2.getNext().value.forEach((t4, e3) => o2.set(t4, e3)), !(o2.size() >= s2));)
-        ;
-        return PersistencePromise.resolve(o2);
-    }
-    ht(t3, e2, i2) {
-        const s2 = this.overlays.get(i2.key);
-        if (null !== s2) {
-            const t4 = this.cr.get(s2.largestBatchId).delete(i2.key);
-            this.cr.set(s2.largestBatchId, t4);
-        }
-        this.overlays = this.overlays.insert(i2.key, new Overlay(e2, i2));
-        let n2 = this.cr.get(e2);
-        void 0 === n2 && (n2 = ub(), this.cr.set(e2, n2)), this.cr.set(e2, n2.add(i2.key));
-    }
-}
-class __PRIVATE_ReferenceSet {
-    constructor() {
-        this.lr = new SortedSet(__PRIVATE_DocReference.hr), this.Pr = new SortedSet(__PRIVATE_DocReference.Ir);
-    }
-    isEmpty() {
-        return this.lr.isEmpty();
-    }
-    addReference(t3, e2) {
-        const i2 = new __PRIVATE_DocReference(t3, e2);
-        this.lr = this.lr.add(i2), this.Pr = this.Pr.add(i2);
-    }
-    Tr(t3, e2) {
-        t3.forEach((t4) => this.addReference(t4, e2));
-    }
-    removeReference(t3, e2) {
-        this.Er(new __PRIVATE_DocReference(t3, e2));
-    }
-    dr(t3, e2) {
-        t3.forEach((t4) => this.removeReference(t4, e2));
-    }
-    Ar(t3) {
-        const e2 = new DocumentKey(new ResourcePath([])),
-            i2 = new __PRIVATE_DocReference(e2, t3),
-            s2 = new __PRIVATE_DocReference(e2, t3 + 1),
-            n2 = [];
-        return this.Pr.forEachInRange([i2, s2], (t4) => {
-            this.Er(t4), n2.push(t4.key);
-        }), n2;
-    }
-    Rr() {
-        this.lr.forEach((t3) => this.Er(t3));
-    }
-    Er(t3) {
-        this.lr = this.lr.delete(t3), this.Pr = this.Pr.delete(t3);
-    }
-    Vr(t3) {
-        const e2 = new DocumentKey(new ResourcePath([])),
-            i2 = new __PRIVATE_DocReference(e2, t3),
-            s2 = new __PRIVATE_DocReference(e2, t3 + 1);
-        let n2 = ub();
-        return this.Pr.forEachInRange([i2, s2], (t4) => {
-            n2 = n2.add(t4.key);
-        }), n2;
-    }
-    containsKey(t3) {
-        const e2 = new __PRIVATE_DocReference(t3, 0),
-            i2 = this.lr.firstAfterOrEqual(e2);
-        return null !== i2 && t3.isEqual(i2.key);
-    }
-}
-class __PRIVATE_DocReference {
-    constructor(t3, e2) {
-        this.key = t3, this.mr = e2;
-    }
-    static hr(t3, e2) {
-        return DocumentKey.comparator(t3.key, e2.key) || Jy(t3.mr, e2.mr);
-    }
-    static Ir(t3, e2) {
-        return Jy(t3.mr, e2.mr) || DocumentKey.comparator(t3.key, e2.key);
-    }
-}
-class __PRIVATE_MemoryMutationQueue {
-    constructor(t3, e2) {
-        this.indexManager = t3, this.referenceDelegate = e2, this.mutationQueue = [], this.gr = 1, this.pr = new SortedSet(__PRIVATE_DocReference.hr);
-    }
-    checkEmpty(t3) {
-        return PersistencePromise.resolve(0 === this.mutationQueue.length);
-    }
-    addMutationBatch(t3, e2, i2, s2) {
-        const n2 = this.gr;
-        this.gr++, this.mutationQueue.length > 0 && this.mutationQueue[this.mutationQueue.length - 1];
-        const r2 = new MutationBatch(n2, e2, i2, s2);
-        this.mutationQueue.push(r2);
-        for (const e3 of s2)
-            this.pr = this.pr.add(new __PRIVATE_DocReference(e3.key, n2)), this.indexManager.addToCollectionParentIndex(t3, e3.key.path.popLast());
-        return PersistencePromise.resolve(r2);
-    }
-    lookupMutationBatch(t3, e2) {
-        return PersistencePromise.resolve(this.yr(e2));
-    }
-    getNextMutationBatchAfterBatchId(t3, e2) {
-        const i2 = e2 + 1,
-            s2 = this.wr(i2),
-            n2 = s2 < 0 ? 0 : s2;
-        return PersistencePromise.resolve(this.mutationQueue.length > n2 ? this.mutationQueue[n2] : null);
-    }
-    getHighestUnacknowledgedBatchId() {
-        return PersistencePromise.resolve(0 === this.mutationQueue.length ? -1 : this.gr - 1);
-    }
-    getAllMutationBatches(t3) {
-        return PersistencePromise.resolve(this.mutationQueue.slice());
-    }
-    getAllMutationBatchesAffectingDocumentKey(t3, e2) {
-        const i2 = new __PRIVATE_DocReference(e2, 0),
-            s2 = new __PRIVATE_DocReference(e2, Number.POSITIVE_INFINITY),
-            n2 = [];
-        return this.pr.forEachInRange([i2, s2], (t4) => {
-            const e3 = this.yr(t4.mr);
-            n2.push(e3);
-        }), PersistencePromise.resolve(n2);
-    }
-    getAllMutationBatchesAffectingDocumentKeys(t3, e2) {
-        let i2 = new SortedSet(Jy);
-        return e2.forEach((t4) => {
-            const e3 = new __PRIVATE_DocReference(t4, 0),
-                s2 = new __PRIVATE_DocReference(t4, Number.POSITIVE_INFINITY);
-            this.pr.forEachInRange([e3, s2], (t5) => {
-                i2 = i2.add(t5.mr);
-            });
-        }), PersistencePromise.resolve(this.Sr(i2));
-    }
-    getAllMutationBatchesAffectingQuery(t3, e2) {
-        const i2 = e2.path,
-            s2 = i2.length + 1;
-        let n2 = i2;
-        DocumentKey.isDocumentKey(n2) || (n2 = n2.child(""));
-        const r2 = new __PRIVATE_DocReference(new DocumentKey(n2), 0);
-        let o2 = new SortedSet(Jy);
-        return this.pr.forEachWhile((t4) => {
-            const e3 = t4.key.path;
-            return !!i2.isPrefixOf(e3) && (e3.length === s2 && (o2 = o2.add(t4.mr)), true);
-        }, r2), PersistencePromise.resolve(this.Sr(o2));
-    }
-    Sr(t3) {
-        const e2 = [];
-        return t3.forEach((t4) => {
-            const i2 = this.yr(t4);
-            null !== i2 && e2.push(i2);
-        }), e2;
-    }
-    removeMutationBatch(t3, e2) {
-        Gy(0 === this.br(e2.batchId, "removed")), this.mutationQueue.shift();
-        let i2 = this.pr;
-        return PersistencePromise.forEach(e2.mutations, (s2) => {
-            const n2 = new __PRIVATE_DocReference(s2.key, e2.batchId);
-            return i2 = i2.delete(n2), this.referenceDelegate.markPotentiallyOrphaned(t3, s2.key);
-        }).next(() => {
-            this.pr = i2;
-        });
-    }
-    Cn(t3) {}
-    containsKey(t3, e2) {
-        const i2 = new __PRIVATE_DocReference(e2, 0),
-            s2 = this.pr.firstAfterOrEqual(i2);
-        return PersistencePromise.resolve(e2.isEqual(s2 && s2.key));
-    }
-    performConsistencyCheck(t3) {
-        return this.mutationQueue.length, PersistencePromise.resolve();
-    }
-    br(t3, e2) {
-        return this.wr(t3);
-    }
-    wr(t3) {
-        return 0 === this.mutationQueue.length ? 0 : t3 - this.mutationQueue[0].batchId;
-    }
-    yr(t3) {
-        const e2 = this.wr(t3);
-        return e2 < 0 || e2 >= this.mutationQueue.length ? null : this.mutationQueue[e2];
-    }
-}
-class __PRIVATE_MemoryRemoteDocumentCacheImpl {
-    constructor(t3) {
-        this.Dr = t3, this.docs = new SortedMap(DocumentKey.comparator), this.size = 0;
-    }
-    setIndexManager(t3) {
-        this.indexManager = t3;
-    }
-    addEntry(t3, e2) {
-        const i2 = e2.key,
-            s2 = this.docs.get(i2),
-            n2 = s2 ? s2.size : 0,
-            r2 = this.Dr(e2);
-        return this.docs = this.docs.insert(i2, {
-            document: e2.mutableCopy(),
-            size: r2
-        }), this.size += r2 - n2, this.indexManager.addToCollectionParentIndex(t3, i2.path.popLast());
-    }
-    removeEntry(t3) {
-        const e2 = this.docs.get(t3);
-        e2 && (this.docs = this.docs.remove(t3), this.size -= e2.size);
-    }
-    getEntry(t3, e2) {
-        const i2 = this.docs.get(e2);
-        return PersistencePromise.resolve(i2 ? i2.document.mutableCopy() : MutableDocument.newInvalidDocument(e2));
-    }
-    getEntries(t3, e2) {
-        let i2 = ib();
-        return e2.forEach((t4) => {
-            const e3 = this.docs.get(t4);
-            i2 = i2.insert(t4, e3 ? e3.document.mutableCopy() : MutableDocument.newInvalidDocument(t4));
-        }), PersistencePromise.resolve(i2);
-    }
-    getDocumentsMatchingQuery(t3, e2, i2, s2) {
-        let n2 = ib();
-        const r2 = e2.path,
-            o2 = new DocumentKey(r2.child("")),
-            a2 = this.docs.getIteratorFrom(o2);
-        for (; a2.hasNext();) {
-            const {
-                key: t4,
-                value: {
-                    document: o3
-                }
-            } = a2.getNext();
-            if (!r2.isPrefixOf(t4.path))
-                break;
-            t4.path.length > r2.length + 1 || iv(ev(o3), i2) <= 0 || (s2.has(o3.key) || Jv(e2, o3)) && (n2 = n2.insert(o3.key, o3.mutableCopy()));
-        }
-        return PersistencePromise.resolve(n2);
-    }
-    getAllFromCollectionGroup(t3, e2, i2, s2) {
-        Ky();
-    }
-    vr(t3, e2) {
-        return PersistencePromise.forEach(this.docs, (t4) => e2(t4));
-    }
-    newChangeBuffer(t3) {
-        return new __PRIVATE_MemoryRemoteDocumentChangeBuffer(this);
-    }
-    getSize(t3) {
-        return PersistencePromise.resolve(this.size);
-    }
-}
-class __PRIVATE_MemoryRemoteDocumentChangeBuffer extends RemoteDocumentChangeBuffer {
-    constructor(t3) {
-        super(), this.sr = t3;
-    }
-    applyChanges(t3) {
-        const e2 = [];
-        return this.changes.forEach((i2, s2) => {
-            s2.isValidDocument() ? e2.push(this.sr.addEntry(t3, s2)) : this.sr.removeEntry(i2);
-        }), PersistencePromise.waitFor(e2);
-    }
-    getFromCache(t3, e2) {
-        return this.sr.getEntry(t3, e2);
-    }
-    getAllFromCache(t3, e2) {
-        return this.sr.getEntries(t3, e2);
-    }
-}
-class __PRIVATE_MemoryTargetCache {
-    constructor(t3) {
-        this.persistence = t3, this.Cr = new ObjectMap((t4) => Bv(t4), Uv), this.lastRemoteSnapshotVersion = SnapshotVersion.min(), this.highestTargetId = 0, this.Fr = 0, this.Mr = new __PRIVATE_ReferenceSet(), this.targetCount = 0, this.Or = __PRIVATE_TargetIdGenerator.xn();
-    }
-    forEachTarget(t3, e2) {
-        return this.Cr.forEach((t4, i2) => e2(i2)), PersistencePromise.resolve();
-    }
-    getLastRemoteSnapshotVersion(t3) {
-        return PersistencePromise.resolve(this.lastRemoteSnapshotVersion);
-    }
-    getHighestSequenceNumber(t3) {
-        return PersistencePromise.resolve(this.Fr);
-    }
-    allocateTargetId(t3) {
-        return this.highestTargetId = this.Or.next(), PersistencePromise.resolve(this.highestTargetId);
-    }
-    setTargetsMetadata(t3, e2, i2) {
-        return i2 && (this.lastRemoteSnapshotVersion = i2), e2 > this.Fr && (this.Fr = e2), PersistencePromise.resolve();
-    }
-    Ln(t3) {
-        this.Cr.set(t3.target, t3);
-        const e2 = t3.targetId;
-        e2 > this.highestTargetId && (this.Or = new __PRIVATE_TargetIdGenerator(e2), this.highestTargetId = e2), t3.sequenceNumber > this.Fr && (this.Fr = t3.sequenceNumber);
-    }
-    addTargetData(t3, e2) {
-        return this.Ln(e2), this.targetCount += 1, PersistencePromise.resolve();
-    }
-    updateTargetData(t3, e2) {
-        return this.Ln(e2), PersistencePromise.resolve();
-    }
-    removeTargetData(t3, e2) {
-        return this.Cr.delete(e2.target), this.Mr.Ar(e2.targetId), this.targetCount -= 1, PersistencePromise.resolve();
-    }
-    removeTargets(t3, e2, i2) {
-        let s2 = 0;
-        const n2 = [];
-        return this.Cr.forEach((r2, o2) => {
-            o2.sequenceNumber <= e2 && null === i2.get(o2.targetId) && (this.Cr.delete(r2), n2.push(this.removeMatchingKeysForTargetId(t3, o2.targetId)), s2++);
-        }), PersistencePromise.waitFor(n2).next(() => s2);
-    }
-    getTargetCount(t3) {
-        return PersistencePromise.resolve(this.targetCount);
-    }
-    getTargetData(t3, e2) {
-        const i2 = this.Cr.get(e2) || null;
-        return PersistencePromise.resolve(i2);
-    }
-    addMatchingKeys(t3, e2, i2) {
-        return this.Mr.Tr(e2, i2), PersistencePromise.resolve();
-    }
-    removeMatchingKeys(t3, e2, i2) {
-        this.Mr.dr(e2, i2);
-        const s2 = this.persistence.referenceDelegate,
-            n2 = [];
-        return s2 && e2.forEach((e3) => {
-            n2.push(s2.markPotentiallyOrphaned(t3, e3));
-        }), PersistencePromise.waitFor(n2);
-    }
-    removeMatchingKeysForTargetId(t3, e2) {
-        return this.Mr.Ar(e2), PersistencePromise.resolve();
-    }
-    getMatchingKeysForTargetId(t3, e2) {
-        const i2 = this.Mr.Vr(e2);
-        return PersistencePromise.resolve(i2);
-    }
-    containsKey(t3, e2) {
-        return PersistencePromise.resolve(this.Mr.containsKey(e2));
-    }
-}
-class __PRIVATE_MemoryPersistence {
-    constructor(t3, e2) {
-        this.Nr = {}, this.overlays = {}, this.Br = new __PRIVATE_ListenSequence(0), this.Lr = false, this.Lr = true, this.referenceDelegate = t3(this), this.kr = new __PRIVATE_MemoryTargetCache(this), this.indexManager = new __PRIVATE_MemoryIndexManager(), this.remoteDocumentCache = function(t4) {
-            return new __PRIVATE_MemoryRemoteDocumentCacheImpl(t4);
-        }((t4) => this.referenceDelegate.qr(t4)), this.serializer = new __PRIVATE_LocalSerializer(e2), this.Qr = new __PRIVATE_MemoryBundleCache(this.serializer);
-    }
-    start() {
-        return Promise.resolve();
-    }
-    shutdown() {
-        return this.Lr = false, Promise.resolve();
-    }
-    get started() {
-        return this.Lr;
-    }
-    setDatabaseDeletedListener() {}
-    setNetworkEnabled() {}
-    getIndexManager(t3) {
-        return this.indexManager;
-    }
-    getDocumentOverlayCache(t3) {
-        let e2 = this.overlays[t3.toKey()];
-        return e2 || (e2 = new __PRIVATE_MemoryDocumentOverlayCache(), this.overlays[t3.toKey()] = e2), e2;
-    }
-    getMutationQueue(t3, e2) {
-        let i2 = this.Nr[t3.toKey()];
-        return i2 || (i2 = new __PRIVATE_MemoryMutationQueue(e2, this.referenceDelegate), this.Nr[t3.toKey()] = i2), i2;
-    }
-    getTargetCache() {
-        return this.kr;
-    }
-    getRemoteDocumentCache() {
-        return this.remoteDocumentCache;
-    }
-    getBundleCache() {
-        return this.Qr;
-    }
-    runTransaction(t3, e2, i2) {
-        jy("MemoryPersistence", "Starting transaction:", t3);
-        const s2 = new __PRIVATE_MemoryTransaction(this.Br.next());
-        return this.referenceDelegate.Kr(), i2(s2).next((t4) => this.referenceDelegate.$r(s2).next(() => t4)).toPromise().then((t4) => (s2.raiseOnCommittedEvent(), t4));
-    }
-    Ur(t3, e2) {
-        return PersistencePromise.or(Object.values(this.Nr).map((i2) => () => i2.containsKey(t3, e2)));
-    }
-}
-class __PRIVATE_MemoryTransaction extends PersistenceTransaction {
-    constructor(t3) {
-        super(), this.currentSequenceNumber = t3;
-    }
-}
-class __PRIVATE_MemoryEagerDelegate {
-    constructor(t3) {
-        this.persistence = t3, this.Wr = new __PRIVATE_ReferenceSet(), this.Gr = null;
-    }
-    static zr(t3) {
-        return new __PRIVATE_MemoryEagerDelegate(t3);
-    }
-    get jr() {
-        if (this.Gr)
-            return this.Gr;
-        throw Ky();
-    }
-    addReference(t3, e2, i2) {
-        return this.Wr.addReference(i2, e2), this.jr.delete(i2.toString()), PersistencePromise.resolve();
-    }
-    removeReference(t3, e2, i2) {
-        return this.Wr.removeReference(i2, e2), this.jr.add(i2.toString()), PersistencePromise.resolve();
-    }
-    markPotentiallyOrphaned(t3, e2) {
-        return this.jr.add(e2.toString()), PersistencePromise.resolve();
-    }
-    removeTarget(t3, e2) {
-        this.Wr.Ar(e2.targetId).forEach((t4) => this.jr.add(t4.toString()));
-        const i2 = this.persistence.getTargetCache();
-        return i2.getMatchingKeysForTargetId(t3, e2.targetId).next((t4) => {
-            t4.forEach((t5) => this.jr.add(t5.toString()));
-        }).next(() => i2.removeTargetData(t3, e2));
-    }
-    Kr() {
-        this.Gr = /* @__PURE__ */ new Set();
-    }
-    $r(t3) {
-        const e2 = this.persistence.getRemoteDocumentCache().newChangeBuffer();
-        return PersistencePromise.forEach(this.jr, (i2) => {
-            const s2 = DocumentKey.fromPath(i2);
-            return this.Hr(t3, s2).next((t4) => {
-                t4 || e2.removeEntry(s2, SnapshotVersion.min());
-            });
-        }).next(() => (this.Gr = null, e2.apply(t3)));
-    }
-    updateLimboDocument(t3, e2) {
-        return this.Hr(t3, e2).next((t4) => {
-            t4 ? this.jr.delete(e2.toString()) : this.jr.add(e2.toString());
-        });
-    }
-    qr(t3) {
-        return 0;
-    }
-    Hr(t3, e2) {
-        return PersistencePromise.or([() => PersistencePromise.resolve(this.Wr.containsKey(e2)), () => this.persistence.getTargetCache().containsKey(t3, e2), () => this.persistence.Ur(t3, e2)]);
-    }
-}
-class __PRIVATE_LocalViewChanges {
-    constructor(t3, e2, i2, s2) {
-        this.targetId = t3, this.fromCache = e2, this.Li = i2, this.ki = s2;
-    }
-    static qi(t3, e2) {
-        let i2 = ub(),
-            s2 = ub();
-        for (const t4 of e2.docChanges)
-            switch (t4.type) {
-                case 0:
-                    i2 = i2.add(t4.doc.key);
-                    break;
-                case 1:
-                    s2 = s2.add(t4.doc.key);
-            }
-        return new __PRIVATE_LocalViewChanges(t3, e2.fromCache, i2, s2);
-    }
-}
-class __PRIVATE_QueryEngine {
-    constructor() {
-        this.Qi = false;
-    }
-    initialize(t3, e2) {
-        this.Ki = t3, this.indexManager = e2, this.Qi = true;
-    }
-    getDocumentsMatchingQuery(t3, e2, i2, s2) {
-        return this.$i(t3, e2).next((n2) => n2 || this.Ui(t3, e2, s2, i2)).next((i3) => i3 || this.Wi(t3, e2));
-    }
-    $i(t3, e2) {
-        if (Wv(e2))
-            return PersistencePromise.resolve(null);
-        let i2 = Kv(e2);
-        return this.indexManager.getIndexType(t3, i2).next((s2) => 0 === s2 ? null : (null !== e2.limit && 1 === s2 && (e2 = Gv(e2, null, "F"), i2 = Kv(e2)), this.indexManager.getDocumentsMatchingTarget(t3, i2).next((s3) => {
-            const n2 = ub(...s3);
-            return this.Ki.getDocuments(t3, n2).next((s4) => this.indexManager.getMinOffset(t3, i2).next((i3) => {
-                const r2 = this.Gi(e2, s4);
-                return this.zi(e2, r2, n2, i3.readTime) ? this.$i(t3, Gv(e2, null, "F")) : this.ji(t3, r2, e2, i3);
-            }));
-        })));
-    }
-    Ui(t3, e2, i2, s2) {
-        return Wv(e2) || s2.isEqual(SnapshotVersion.min()) ? this.Wi(t3, e2) : this.Ki.getDocuments(t3, i2).next((n2) => {
-            const r2 = this.Gi(e2, n2);
-            return this.zi(e2, r2, i2, s2) ? this.Wi(t3, e2) : (Uy() <= Rd.DEBUG && jy("QueryEngine", "Re-using previous result from %s to execute query: %s", s2.toString(), Xv(e2)), this.ji(t3, r2, e2, function(t4, e3) {
-                const i3 = t4.toTimestamp().seconds,
-                    s3 = t4.toTimestamp().nanoseconds + 1,
-                    n3 = SnapshotVersion.fromTimestamp(1e9 === s3 ? new Timestamp(i3 + 1, 0) : new Timestamp(i3, s3));
-                return new IndexOffset(n3, DocumentKey.empty(), e3);
-            }(s2, -1)));
-        });
-    }
-    Gi(t3, e2) {
-        let i2 = new SortedSet(Zv(t3));
-        return e2.forEach((e3, s2) => {
-            Jv(t3, s2) && (i2 = i2.add(s2));
-        }), i2;
-    }
-    zi(t3, e2, i2, s2) {
-        if (null === t3.limit)
-            return false;
-        if (i2.size !== e2.size)
-            return true;
-        const n2 = "F" === t3.limitType ? e2.last() : e2.first();
-        return !!n2 && (n2.hasPendingWrites || n2.version.compareTo(s2) > 0);
-    }
-    Wi(t3, e2) {
-        return Uy() <= Rd.DEBUG && jy("QueryEngine", "Using full collection scan to execute query:", Xv(e2)), this.Ki.getDocumentsMatchingQuery(t3, e2, IndexOffset.min());
-    }
-    ji(t3, e2, i2, s2) {
-        return this.Ki.getDocumentsMatchingQuery(t3, i2, s2).next((t4) => (e2.forEach((e3) => {
-            t4 = t4.insert(e3.key, e3);
-        }), t4));
-    }
-}
-class __PRIVATE_LocalStoreImpl {
-    constructor(t3, e2, i2, s2) {
-        this.persistence = t3, this.Hi = e2, this.serializer = s2, this.Ji = new SortedMap(Jy), this.Yi = new ObjectMap((t4) => Bv(t4), Uv), this.Zi = /* @__PURE__ */ new Map(), this.Xi = t3.getRemoteDocumentCache(), this.kr = t3.getTargetCache(), this.Qr = t3.getBundleCache(), this.es(i2);
-    }
-    es(t3) {
-        this.documentOverlayCache = this.persistence.getDocumentOverlayCache(t3), this.indexManager = this.persistence.getIndexManager(t3), this.mutationQueue = this.persistence.getMutationQueue(t3, this.indexManager), this.localDocuments = new LocalDocumentsView(this.Xi, this.mutationQueue, this.documentOverlayCache, this.indexManager), this.Xi.setIndexManager(this.indexManager), this.Hi.initialize(this.localDocuments, this.indexManager);
-    }
-    collectGarbage(t3) {
-        return this.persistence.runTransaction("Collect garbage", "readwrite-primary", (e2) => t3.collect(e2, this.Ji));
-    }
-}
-async function a_(t3, e2) {
-    const i2 = Yy(t3);
-    return await i2.persistence.runTransaction("Handle user change", "readonly", (t4) => {
-        let s2;
-        return i2.mutationQueue.getAllMutationBatches(t4).next((n2) => (s2 = n2, i2.es(e2), i2.mutationQueue.getAllMutationBatches(t4))).next((e3) => {
-            const n2 = [],
-                r2 = [];
-            let o2 = ub();
-            for (const t5 of s2) {
-                n2.push(t5.batchId);
-                for (const e4 of t5.mutations)
-                    o2 = o2.add(e4.key);
-            }
-            for (const t5 of e3) {
-                r2.push(t5.batchId);
-                for (const e4 of t5.mutations)
-                    o2 = o2.add(e4.key);
-            }
-            return i2.localDocuments.getDocuments(t4, o2).next((t5) => ({
-                ts: t5,
-                removedBatchIds: n2,
-                addedBatchIds: r2
-            }));
-        });
-    });
-}
-
-function l_(t3) {
-    const e2 = Yy(t3);
-    return e2.persistence.runTransaction("Get last remote snapshot version", "readonly", (t4) => e2.kr.getLastRemoteSnapshotVersion(t4));
-}
-
-function h_(t3, e2) {
-    const i2 = Yy(t3),
-        s2 = e2.snapshotVersion;
-    let n2 = i2.Ji;
-    return i2.persistence.runTransaction("Apply remote event", "readwrite-primary", (t4) => {
-        const r2 = i2.Xi.newChangeBuffer({
-            trackRemovals: true
-        });
-        n2 = i2.Ji;
-        const o2 = [];
-        e2.targetChanges.forEach((r3, a3) => {
-            const l3 = n2.get(a3);
-            if (!l3)
-                return;
-            o2.push(i2.kr.removeMatchingKeys(t4, r3.removedDocuments, a3).next(() => i2.kr.addMatchingKeys(t4, r3.addedDocuments, a3)));
-            let h2 = l3.withSequenceNumber(t4.currentSequenceNumber);
-            null !== e2.targetMismatches.get(a3) ? h2 = h2.withResumeToken(ByteString.EMPTY_BYTE_STRING, SnapshotVersion.min()).withLastLimboFreeSnapshotVersion(SnapshotVersion.min()) : r3.resumeToken.approximateByteSize() > 0 && (h2 = h2.withResumeToken(r3.resumeToken, s2)), n2 = n2.insert(a3, h2),
-                function(t5, e3, i3) {
-                    return 0 === t5.resumeToken.approximateByteSize() || (e3.snapshotVersion.toMicroseconds() - t5.snapshotVersion.toMicroseconds() >= 3e8 || i3.addedDocuments.size + i3.modifiedDocuments.size + i3.removedDocuments.size > 0);
-                }(l3, h2, r3) && o2.push(i2.kr.updateTargetData(t4, h2));
-        });
-        let a2 = ib(),
-            l2 = ub();
-        if (e2.documentUpdates.forEach((s3) => {
-                e2.resolvedLimboDocuments.has(s3) && o2.push(i2.persistence.referenceDelegate.updateLimboDocument(t4, s3));
-            }), o2.push(function(t5, e3, i3) {
-                let s3 = ub(),
-                    n3 = ub();
-                return i3.forEach((t6) => s3 = s3.add(t6)), e3.getEntries(t5, s3).next((t6) => {
-                    let s4 = ib();
-                    return i3.forEach((i4, r3) => {
-                        const o3 = t6.get(i4);
-                        r3.isFoundDocument() !== o3.isFoundDocument() && (n3 = n3.add(i4)), r3.isNoDocument() && r3.version.isEqual(SnapshotVersion.min()) ? (e3.removeEntry(i4, r3.readTime), s4 = s4.insert(i4, r3)) : !o3.isValidDocument() || r3.version.compareTo(o3.version) > 0 || 0 === r3.version.compareTo(o3.version) && o3.hasPendingWrites ? (e3.addEntry(r3), s4 = s4.insert(i4, r3)) : jy("LocalStore", "Ignoring outdated watch update for ", i4, ". Current version:", o3.version, " Watch version:", r3.version);
-                    }), {
-                        ns: s4,
-                        rs: n3
-                    };
-                });
-            }(t4, r2, e2.documentUpdates).next((t5) => {
-                a2 = t5.ns, l2 = t5.rs;
-            })), !s2.isEqual(SnapshotVersion.min())) {
-            const e3 = i2.kr.getLastRemoteSnapshotVersion(t4).next((e4) => i2.kr.setTargetsMetadata(t4, t4.currentSequenceNumber, s2));
-            o2.push(e3);
-        }
-        return PersistencePromise.waitFor(o2).next(() => r2.apply(t4)).next(() => i2.localDocuments.getLocalViewOfDocuments(t4, a2, l2)).next(() => a2);
-    }).then((t4) => (i2.Ji = n2, t4));
-}
-async function c_(t3, e2, i2) {
-    const s2 = Yy(t3),
-        n2 = s2.Ji.get(e2),
-        r2 = i2 ? "readwrite" : "readwrite-primary";
-    try {
-        i2 || await s2.persistence.runTransaction("Release target", r2, (t4) => s2.persistence.referenceDelegate.removeTarget(t4, n2));
-    } catch (t4) {
-        if (!rv(t4))
-            throw t4;
-        jy("LocalStore", `Failed to update sequence numbers for target ${e2}: ${t4}`);
-    }
-    s2.Ji = s2.Ji.remove(e2), s2.Yi.delete(n2.target);
-}
-
-function u_(t3, e2, i2) {
-    const s2 = Yy(t3);
-    let n2 = SnapshotVersion.min(),
-        r2 = ub();
-    return s2.persistence.runTransaction("Execute query", "readonly", (t4) => function(t5, e3, i3) {
-        const s3 = Yy(t5),
-            n3 = s3.Yi.get(i3);
-        return void 0 !== n3 ? PersistencePromise.resolve(s3.Ji.get(n3)) : s3.kr.getTargetData(e3, i3);
-    }(s2, t4, Kv(e2)).next((e3) => {
-        if (e3)
-            return n2 = e3.lastLimboFreeSnapshotVersion, s2.kr.getMatchingKeysForTargetId(t4, e3.targetId).next((t5) => {
-                r2 = t5;
-            });
-    }).next(() => s2.Hi.getDocumentsMatchingQuery(t4, e2, i2 ? n2 : SnapshotVersion.min(), i2 ? r2 : ub())).next((t5) => (function(t6, e3, i3) {
-        let s3 = t6.Zi.get(e3) || SnapshotVersion.min();
-        i3.forEach((t7, e4) => {
-            e4.readTime.compareTo(s3) > 0 && (s3 = e4.readTime);
-        }), t6.Zi.set(e3, s3);
-    }(s2, function(t6) {
-        return t6.collectionGroup || (t6.path.length % 2 == 1 ? t6.path.lastSegment() : t6.path.get(t6.path.length - 2));
-    }(e2), t5), {
-        documents: t5,
-        ss: r2
-    })));
-}
-class __PRIVATE_LocalClientState {
-    constructor() {
-        this.activeTargetIds = db;
-    }
-    hs(t3) {
-        this.activeTargetIds = this.activeTargetIds.add(t3);
-    }
-    Ps(t3) {
-        this.activeTargetIds = this.activeTargetIds.delete(t3);
-    }
-    ls() {
-        const t3 = {
-            activeTargetIds: this.activeTargetIds.toArray(),
-            updateTimeMs: Date.now()
-        };
-        return JSON.stringify(t3);
-    }
-}
-class __PRIVATE_MemorySharedClientState {
-    constructor() {
-        this.Hs = new __PRIVATE_LocalClientState(), this.Js = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null;
-    }
-    addPendingMutation(t3) {}
-    updateMutationState(t3, e2, i2) {}
-    addLocalQueryTarget(t3) {
-        return this.Hs.hs(t3), this.Js[t3] || "not-current";
-    }
-    updateQueryState(t3, e2, i2) {
-        this.Js[t3] = e2;
-    }
-    removeLocalQueryTarget(t3) {
-        this.Hs.Ps(t3);
-    }
-    isLocalQueryTarget(t3) {
-        return this.Hs.activeTargetIds.has(t3);
-    }
-    clearQueryState(t3) {
-        delete this.Js[t3];
-    }
-    getAllActiveQueryTargets() {
-        return this.Hs.activeTargetIds;
-    }
-    isActiveQueryTarget(t3) {
-        return this.Hs.activeTargetIds.has(t3);
-    }
-    start() {
-        return this.Hs = new __PRIVATE_LocalClientState(), Promise.resolve();
-    }
-    handleUserChange(t3, e2, i2) {}
-    setOnlineState(t3) {}
-    shutdown() {}
-    writeSequenceNumber(t3) {}
-    notifyBundleLoaded(t3) {}
-}
-class __PRIVATE_NoopConnectivityMonitor {
-    Ys(t3) {}
-    shutdown() {}
-}
-class __PRIVATE_BrowserConnectivityMonitor {
-    constructor() {
-        this.Zs = () => this.Xs(), this.eo = () => this.no(), this.ro = [], this.io();
-    }
-    Ys(t3) {
-        this.ro.push(t3);
-    }
-    shutdown() {
-        window.removeEventListener("online", this.Zs), window.removeEventListener("offline", this.eo);
-    }
-    io() {
-        window.addEventListener("online", this.Zs), window.addEventListener("offline", this.eo);
-    }
-    Xs() {
-        jy("ConnectivityMonitor", "Network connectivity changed: AVAILABLE");
-        for (const t3 of this.ro)
-            t3(0);
-    }
-    no() {
-        jy("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE");
-        for (const t3 of this.ro)
-            t3(1);
-    }
-    static v() {
-        return "undefined" != typeof window && void 0 !== window.addEventListener && void 0 !== window.removeEventListener;
-    }
-}
-let d_ = null;
-
-function f_() {
-    return null === d_ ? d_ = 268435456 + Math.round(2147483648 * Math.random()) : d_++, "0x" + d_.toString(16);
-}
-const p_ = {
-    BatchGetDocuments: "batchGet",
-    Commit: "commit",
-    RunQuery: "runQuery",
-    RunAggregationQuery: "runAggregationQuery"
-};
-class __PRIVATE_StreamBridge {
-    constructor(t3) {
-        this.so = t3.so, this.oo = t3.oo;
-    }
-    _o(t3) {
-        this.ao = t3;
-    }
-    uo(t3) {
-        this.co = t3;
-    }
-    onMessage(t3) {
-        this.lo = t3;
-    }
-    close() {
-        this.oo();
-    }
-    send(t3) {
-        this.so(t3);
-    }
-    ho() {
-        this.ao();
-    }
-    Po(t3) {
-        this.co(t3);
-    }
-    Io(t3) {
-        this.lo(t3);
-    }
-}
-const m_ = "WebChannelConnection";
-class __PRIVATE_WebChannelConnection extends class __PRIVATE_RestConnection {
-    constructor(t3) {
-        this.databaseInfo = t3, this.databaseId = t3.databaseId;
-        const e2 = t3.ssl ? "https" : "http";
-        this.To = e2 + "://" + t3.host, this.Eo = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents";
-    }
-    get Ao() {
-        return false;
-    }
-    Ro(t3, e2, i2, s2, n2) {
-        const r2 = f_(),
-            o2 = this.Vo(t3, e2);
-        jy("RestConnection", `Sending RPC '${t3}' ${r2}:`, o2, i2);
-        const a2 = {};
-        return this.mo(a2, s2, n2), this.fo(t3, o2, a2, i2).then((e3) => (jy("RestConnection", `Received RPC '${t3}' ${r2}: `, e3), e3), (e3) => {
-            throw Wy("RestConnection", `RPC '${t3}' ${r2} failed with error: `, e3, "url: ", o2, "request:", i2), e3;
-        });
-    }
-    po(t3, e2, i2, s2, n2, r2) {
-        return this.Ro(t3, e2, i2, s2, n2);
-    }
-    mo(t3, e2, i2) {
-        t3["X-Goog-Api-Client"] = "gl-js/ fire/" + zy, t3["Content-Type"] = "text/plain", this.databaseInfo.appId && (t3["X-Firebase-GMPID"] = this.databaseInfo.appId), e2 && e2.headers.forEach((e3, i3) => t3[i3] = e3), i2 && i2.headers.forEach((e3, i3) => t3[i3] = e3);
-    }
-    Vo(t3, e2) {
-        const i2 = p_[t3];
-        return `${this.To}/v1/${e2}:${i2}`;
-    }
-} {
-    constructor(t3) {
-        super(t3), this.forceLongPolling = t3.forceLongPolling, this.autoDetectLongPolling = t3.autoDetectLongPolling, this.useFetchStreams = t3.useFetchStreams, this.longPollingOptions = t3.longPollingOptions;
-    }
-    fo(t3, e2, i2, s2) {
-        const n2 = f_();
-        return new Promise((r2, o2) => {
-            const a2 = new Fy();
-            a2.setWithCredentials(true), a2.listenOnce(Py.COMPLETE, () => {
-                try {
-                    switch (a2.getLastErrorCode()) {
-                        case My.NO_ERROR:
-                            const e3 = a2.getResponseJson();
-                            jy(m_, `XHR for RPC '${t3}' ${n2} received:`, JSON.stringify(e3)), r2(e3);
-                            break;
-                        case My.TIMEOUT:
-                            jy(m_, `RPC '${t3}' ${n2} timed out`), o2(new FirestoreError(Qy.DEADLINE_EXCEEDED, "Request time out"));
-                            break;
-                        case My.HTTP_ERROR:
-                            const i3 = a2.getStatus();
-                            if (jy(m_, `RPC '${t3}' ${n2} failed with status:`, i3, "response text:", a2.getResponseText()), i3 > 0) {
-                                let t4 = a2.getResponseJson();
-                                Array.isArray(t4) && (t4 = t4[0]);
-                                const e4 = null == t4 ? void 0 : t4.error;
-                                if (e4 && e4.status && e4.message) {
-                                    const t5 = function(t6) {
-                                        const e5 = t6.toLowerCase().replace(/_/g, "-");
-                                        return Object.values(Qy).indexOf(e5) >= 0 ? e5 : Qy.UNKNOWN;
-                                    }(e4.status);
-                                    o2(new FirestoreError(t5, e4.message));
-                                } else
-                                    o2(new FirestoreError(Qy.UNKNOWN, "Server responded with status " + a2.getStatus()));
-                            } else
-                                o2(new FirestoreError(Qy.UNAVAILABLE, "Connection failed."));
-                            break;
-                        default:
-                            Ky();
-                    }
-                } finally {
-                    jy(m_, `RPC '${t3}' ${n2} completed.`);
-                }
-            });
-            const l2 = JSON.stringify(s2);
-            jy(m_, `RPC '${t3}' ${n2} sending request:`, s2), a2.send(e2, "POST", l2, i2, 15);
-        });
-    }
-    yo(t3, e2, i2) {
-        const s2 = f_(),
-            n2 = [this.To, "/", "google.firestore.v1.Firestore", "/", t3, "/channel"],
-            r2 = new ry(),
-            o2 = nm(),
-            a2 = {
-                httpSessionIdParam: "gsessionid",
-                initMessageHeaders: {},
-                messageUrlParams: {
-                    database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
-                },
-                sendRawJson: true,
-                supportsCrossDomainXhr: true,
-                internalChannelParams: {
-                    forwardChannelRequestTimeoutMs: 6e5
-                },
-                forceLongPolling: this.forceLongPolling,
-                detectBufferingProxy: this.autoDetectLongPolling
-            },
-            l2 = this.longPollingOptions.timeoutSeconds;
-        void 0 !== l2 && (a2.longPollingTimeout = Math.round(1e3 * l2)), this.useFetchStreams && (a2.xmlHttpFactory = new Ly({})), this.mo(a2.initMessageHeaders, e2, i2), a2.encodeInitMessageHeaders = true;
-        const h2 = n2.join("");
-        jy(m_, `Creating RPC '${t3}' stream ${s2}: ${h2}`, a2);
-        const c2 = r2.createWebChannel(h2, a2);
-        let u2 = false,
-            d2 = false;
-        const f2 = new __PRIVATE_StreamBridge({
-                so: (e3) => {
-                    d2 ? jy(m_, `Not sending because RPC '${t3}' stream ${s2} is closed:`, e3) : (u2 || (jy(m_, `Opening RPC '${t3}' stream ${s2} transport.`), c2.open(), u2 = true), jy(m_, `RPC '${t3}' stream ${s2} sending:`, e3), c2.send(e3));
-                },
-                oo: () => c2.close()
-            }),
-            p2 = (t4, e3, i3) => {
-                t4.listen(e3, (t5) => {
-                    try {
-                        i3(t5);
-                    } catch (t6) {
-                        setTimeout(() => {
-                            throw t6;
-                        }, 0);
-                    }
-                });
-            };
-        return p2(c2, Oy.EventType.OPEN, () => {
-            d2 || jy(m_, `RPC '${t3}' stream ${s2} transport opened.`);
-        }), p2(c2, Oy.EventType.CLOSE, () => {
-            d2 || (d2 = true, jy(m_, `RPC '${t3}' stream ${s2} transport closed`), f2.Po());
-        }), p2(c2, Oy.EventType.ERROR, (e3) => {
-            d2 || (d2 = true, Wy(m_, `RPC '${t3}' stream ${s2} transport errored:`, e3), f2.Po(new FirestoreError(Qy.UNAVAILABLE, "The operation could not be completed")));
-        }), p2(c2, Oy.EventType.MESSAGE, (e3) => {
-            var i3;
-            if (!d2) {
-                const n3 = e3.data[0];
-                Gy(!!n3);
-                const r3 = n3,
-                    o3 = r3.error || (null === (i3 = r3[0]) || void 0 === i3 ? void 0 : i3.error);
-                if (o3) {
-                    jy(m_, `RPC '${t3}' stream ${s2} received error:`, o3);
-                    const e4 = o3.status;
-                    let i4 = function(t4) {
-                            const e5 = Mb[t4];
-                            if (void 0 !== e5)
-                                return Rb(e5);
-                        }(e4),
-                        n4 = o3.message;
-                    void 0 === i4 && (i4 = Qy.INTERNAL, n4 = "Unknown error status: " + e4 + " with message " + o3.message), d2 = true, f2.Po(new FirestoreError(i4, n4)), c2.close();
-                } else
-                    jy(m_, `RPC '${t3}' stream ${s2} received:`, n3), f2.Io(n3);
-            }
-        }), p2(o2, Ry.STAT_EVENT, (e3) => {
-            e3.stat === Ay ? jy(m_, `RPC '${t3}' stream ${s2} detected buffering proxy`) : e3.stat === Dy && jy(m_, `RPC '${t3}' stream ${s2} detected no buffering proxy`);
-        }), setTimeout(() => {
-            f2.ho();
-        }, 0), f2;
-    }
-}
-
-function g_() {
-    return "undefined" != typeof document ? document : null;
-}
-
-function y_(t3) {
-    return new JsonProtoSerializer(t3, true);
-}
-class __PRIVATE_ExponentialBackoff {
-    constructor(t3, e2, i2 = 1e3, s2 = 1.5, n2 = 6e4) {
-        this.ii = t3, this.timerId = e2, this.wo = i2, this.So = s2, this.bo = n2, this.Do = 0, this.vo = null, this.Co = Date.now(), this.reset();
-    }
-    reset() {
-        this.Do = 0;
-    }
-    Fo() {
-        this.Do = this.bo;
-    }
-    Mo(t3) {
-        this.cancel();
-        const e2 = Math.floor(this.Do + this.xo()),
-            i2 = Math.max(0, Date.now() - this.Co),
-            s2 = Math.max(0, e2 - i2);
-        s2 > 0 && jy("ExponentialBackoff", `Backing off for ${s2} ms (base delay: ${this.Do} ms, delay with jitter: ${e2} ms, last attempt: ${i2} ms ago)`), this.vo = this.ii.enqueueAfterDelay(this.timerId, s2, () => (this.Co = Date.now(), t3())), this.Do *= this.So, this.Do < this.wo && (this.Do = this.wo), this.Do > this.bo && (this.Do = this.bo);
-    }
-    Oo() {
-        null !== this.vo && (this.vo.skipDelay(), this.vo = null);
-    }
-    cancel() {
-        null !== this.vo && (this.vo.cancel(), this.vo = null);
-    }
-    xo() {
-        return (Math.random() - 0.5) * this.Do;
-    }
-}
-class __PRIVATE_PersistentStream {
-    constructor(t3, e2, i2, s2, n2, r2, o2, a2) {
-        this.ii = t3, this.No = i2, this.Bo = s2, this.connection = n2, this.authCredentialsProvider = r2, this.appCheckCredentialsProvider = o2, this.listener = a2, this.state = 0, this.Lo = 0, this.ko = null, this.qo = null, this.stream = null, this.Qo = new __PRIVATE_ExponentialBackoff(t3, e2);
-    }
-    Ko() {
-        return 1 === this.state || 5 === this.state || this.$o();
-    }
-    $o() {
-        return 2 === this.state || 3 === this.state;
-    }
-    start() {
-        4 !== this.state ? this.auth() : this.Uo();
-    }
-    async stop() {
-        this.Ko() && await this.close(0);
-    }
-    Wo() {
-        this.state = 0, this.Qo.reset();
-    }
-    Go() {
-        this.$o() && null === this.ko && (this.ko = this.ii.enqueueAfterDelay(this.No, 6e4, () => this.zo()));
-    }
-    jo(t3) {
-        this.Ho(), this.stream.send(t3);
-    }
-    async zo() {
-        if (this.$o())
-            return this.close(0);
-    }
-    Ho() {
-        this.ko && (this.ko.cancel(), this.ko = null);
-    }
-    Jo() {
-        this.qo && (this.qo.cancel(), this.qo = null);
-    }
-    async close(t3, e2) {
-        this.Ho(), this.Jo(), this.Qo.cancel(), this.Lo++, 4 !== t3 ? this.Qo.reset() : e2 && e2.code === Qy.RESOURCE_EXHAUSTED ? (Hy(e2.toString()), Hy("Using maximum backoff delay to prevent overloading the backend."), this.Qo.Fo()) : e2 && e2.code === Qy.UNAUTHENTICATED && 3 !== this.state && (this.authCredentialsProvider.invalidateToken(), this.appCheckCredentialsProvider.invalidateToken()), null !== this.stream && (this.Yo(), this.stream.close(), this.stream = null), this.state = t3, await this.listener.uo(e2);
-    }
-    Yo() {}
-    auth() {
-        this.state = 1;
-        const t3 = this.Zo(this.Lo),
-            e2 = this.Lo;
-        Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then(([t4, i2]) => {
-            this.Lo === e2 && this.Xo(t4, i2);
-        }, (e3) => {
-            t3(() => {
-                const t4 = new FirestoreError(Qy.UNKNOWN, "Fetching auth token failed: " + e3.message);
-                return this.e_(t4);
-            });
-        });
-    }
-    Xo(t3, e2) {
-        const i2 = this.Zo(this.Lo);
-        this.stream = this.t_(t3, e2), this.stream._o(() => {
-            i2(() => (this.state = 2, this.qo = this.ii.enqueueAfterDelay(this.Bo, 1e4, () => (this.$o() && (this.state = 3), Promise.resolve())), this.listener._o()));
-        }), this.stream.uo((t4) => {
-            i2(() => this.e_(t4));
-        }), this.stream.onMessage((t4) => {
-            i2(() => this.onMessage(t4));
-        });
-    }
-    Uo() {
-        this.state = 5, this.Qo.Mo(async () => {
-            this.state = 0, this.start();
-        });
-    }
-    e_(t3) {
-        return jy("PersistentStream", `close with error: ${t3}`), this.stream = null, this.close(4, t3);
-    }
-    Zo(t3) {
-        return (e2) => {
-            this.ii.enqueueAndForget(() => this.Lo === t3 ? e2() : (jy("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()));
-        };
-    }
-}
-class __PRIVATE_PersistentListenStream extends __PRIVATE_PersistentStream {
-    constructor(t3, e2, i2, s2, n2, r2) {
-        super(t3, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", e2, i2, s2, r2), this.serializer = n2;
-    }
-    t_(t3, e2) {
-        return this.connection.yo("Listen", t3, e2);
-    }
-    onMessage(t3) {
-        this.Qo.reset();
-        const e2 = function(t4, e3) {
-                let i3;
-                if ("targetChange" in e3) {
-                    e3.targetChange;
-                    const s2 = function(t5) {
-                            return "NO_CHANGE" === t5 ? 0 : "ADD" === t5 ? 1 : "REMOVE" === t5 ? 2 : "CURRENT" === t5 ? 3 : "RESET" === t5 ? 4 : Ky();
-                        }(e3.targetChange.targetChangeType || "NO_CHANGE"),
-                        n2 = e3.targetChange.targetIds || [],
-                        r2 = function(t5, e4) {
-                            return t5.useProto3Json ? (Gy(void 0 === e4 || "string" == typeof e4), ByteString.fromBase64String(e4 || "")) : (Gy(void 0 === e4 || e4 instanceof Uint8Array), ByteString.fromUint8Array(e4 || new Uint8Array()));
-                        }(t4, e3.targetChange.resumeToken),
-                        o2 = e3.targetChange.cause,
-                        a2 = o2 && function(t5) {
-                            const e4 = void 0 === t5.code ? Qy.UNKNOWN : Rb(t5.code);
-                            return new FirestoreError(e4, t5.message || "");
-                        }(o2);
-                    i3 = new __PRIVATE_WatchTargetChange(s2, n2, r2, a2 || null);
-                } else if ("documentChange" in e3) {
-                    e3.documentChange;
-                    const s2 = e3.documentChange;
-                    s2.document, s2.document.name, s2.document.updateTime;
-                    const n2 = Wb(t4, s2.document.name),
-                        r2 = jb(s2.document.updateTime),
-                        o2 = s2.document.createTime ? jb(s2.document.createTime) : SnapshotVersion.min(),
-                        a2 = new ObjectValue({
-                            mapValue: {
-                                fields: s2.document.fields
-                            }
-                        }),
-                        l2 = MutableDocument.newFoundDocument(n2, r2, o2, a2),
-                        h2 = s2.targetIds || [],
-                        c2 = s2.removedTargetIds || [];
-                    i3 = new __PRIVATE_DocumentWatchChange(h2, c2, l2.key, l2);
-                } else if ("documentDelete" in e3) {
-                    e3.documentDelete;
-                    const s2 = e3.documentDelete;
-                    s2.document;
-                    const n2 = Wb(t4, s2.document),
-                        r2 = s2.readTime ? jb(s2.readTime) : SnapshotVersion.min(),
-                        o2 = MutableDocument.newNoDocument(n2, r2),
-                        a2 = s2.removedTargetIds || [];
-                    i3 = new __PRIVATE_DocumentWatchChange([], a2, o2.key, o2);
-                } else if ("documentRemove" in e3) {
-                    e3.documentRemove;
-                    const s2 = e3.documentRemove;
-                    s2.document;
-                    const n2 = Wb(t4, s2.document),
-                        r2 = s2.removedTargetIds || [];
-                    i3 = new __PRIVATE_DocumentWatchChange([], r2, n2, null);
-                } else {
-                    if (!("filter" in e3))
-                        return Ky();
-                    {
-                        e3.filter;
-                        const t5 = e3.filter;
-                        t5.targetId;
-                        const {
-                            count: s2 = 0,
-                            unchangedNames: n2
-                        } = t5, r2 = new ExistenceFilter(s2, n2), o2 = t5.targetId;
-                        i3 = new __PRIVATE_ExistenceFilterChange(o2, r2);
-                    }
-                }
-                return i3;
-            }(this.serializer, t3),
-            i2 = function(t4) {
-                if (!("targetChange" in t4))
-                    return SnapshotVersion.min();
-                const e3 = t4.targetChange;
-                return e3.targetIds && e3.targetIds.length ? SnapshotVersion.min() : e3.readTime ? jb(e3.readTime) : SnapshotVersion.min();
-            }(t3);
-        return this.listener.n_(e2, i2);
-    }
-    r_(t3) {
-        const e2 = {};
-        e2.database = Kb(this.serializer), e2.addTarget = function(t4, e3) {
-            let i3;
-            const s2 = e3.target;
-            if (i3 = jv(s2) ? {
-                    documents: Yb(t4, s2)
-                } : {
-                    query: Qb(t4, s2)
-                }, i3.targetId = e3.targetId, e3.resumeToken.approximateByteSize() > 0) {
-                i3.resumeToken = function(t5, e4) {
-                    return t5.useProto3Json ? e4.toBase64() : e4.toUint8Array();
-                }(t4, e3.resumeToken);
-                const s3 = Ub(t4, e3.expectedCount);
-                null !== s3 && (i3.expectedCount = s3);
-            } else if (e3.snapshotVersion.compareTo(SnapshotVersion.min()) > 0) {
-                i3.readTime = function(t5, e4) {
-                    return t5.useProto3Json ? `${new Date(1e3 * e4.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + e4.nanoseconds).slice(-9)}Z` : {
-                        seconds: "" + e4.seconds,
-                        nanos: e4.nanoseconds
-                    };
-                }(t4, e3.snapshotVersion.toTimestamp());
-                const s3 = Ub(t4, e3.expectedCount);
-                null !== s3 && (i3.expectedCount = s3);
-            }
-            return i3;
-        }(this.serializer, t3);
-        const i2 = function(t4, e3) {
-            const i3 = function(t5) {
-                switch (t5) {
-                    case "TargetPurposeListen":
-                        return null;
-                    case "TargetPurposeExistenceFilterMismatch":
-                        return "existence-filter-mismatch";
-                    case "TargetPurposeExistenceFilterMismatchBloom":
-                        return "existence-filter-mismatch-bloom";
-                    case "TargetPurposeLimboResolution":
-                        return "limbo-document";
-                    default:
-                        return Ky();
-                }
-            }(e3.purpose);
-            return null == i3 ? null : {
-                "goog-listen-tags": i3
-            };
-        }(this.serializer, t3);
-        i2 && (e2.labels = i2), this.jo(e2);
-    }
-    i_(t3) {
-        const e2 = {};
-        e2.database = Kb(this.serializer), e2.removeTarget = t3, this.jo(e2);
-    }
-}
-class __PRIVATE_DatastoreImpl extends class Datastore {} {
-    constructor(t3, e2, i2, s2) {
-        super(), this.authCredentials = t3, this.appCheckCredentials = e2, this.connection = i2, this.serializer = s2, this.l_ = false;
-    }
-    h_() {
-        if (this.l_)
-            throw new FirestoreError(Qy.FAILED_PRECONDITION, "The client has already been terminated.");
-    }
-    Ro(t3, e2, i2) {
-        return this.h_(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s2, n2]) => this.connection.Ro(t3, e2, i2, s2, n2)).catch((t4) => {
-            throw "FirebaseError" === t4.name ? (t4.code === Qy.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), t4) : new FirestoreError(Qy.UNKNOWN, t4.toString());
-        });
-    }
-    po(t3, e2, i2, s2) {
-        return this.h_(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([n2, r2]) => this.connection.po(t3, e2, i2, n2, r2, s2)).catch((t4) => {
-            throw "FirebaseError" === t4.name ? (t4.code === Qy.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), t4) : new FirestoreError(Qy.UNKNOWN, t4.toString());
-        });
-    }
-    terminate() {
-        this.l_ = true;
-    }
-}
-class __PRIVATE_OnlineStateTracker {
-    constructor(t3, e2) {
-        this.asyncQueue = t3, this.onlineStateHandler = e2, this.state = "Unknown", this.I_ = 0, this.T_ = null, this.E_ = true;
-    }
-    d_() {
-        0 === this.I_ && (this.A_("Unknown"), this.T_ = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.T_ = null, this.R_("Backend didn't respond within 10 seconds."), this.A_("Offline"), Promise.resolve())));
-    }
-    V_(t3) {
-        "Online" === this.state ? this.A_("Unknown") : (this.I_++, this.I_ >= 1 && (this.m_(), this.R_(`Connection failed 1 times. Most recent error: ${t3.toString()}`), this.A_("Offline")));
-    }
-    set(t3) {
-        this.m_(), this.I_ = 0, "Online" === t3 && (this.E_ = false), this.A_(t3);
-    }
-    A_(t3) {
-        t3 !== this.state && (this.state = t3, this.onlineStateHandler(t3));
-    }
-    R_(t3) {
-        const e2 = `Could not reach Cloud Firestore backend. ${t3}
-This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
-        this.E_ ? (Hy(e2), this.E_ = false) : jy("OnlineStateTracker", e2);
-    }
-    m_() {
-        null !== this.T_ && (this.T_.cancel(), this.T_ = null);
-    }
-}
-class __PRIVATE_RemoteStoreImpl {
-    constructor(t3, e2, i2, s2, n2) {
-        this.localStore = t3, this.datastore = e2, this.asyncQueue = i2, this.remoteSyncer = {}, this.f_ = [], this.g_ = /* @__PURE__ */ new Map(), this.p_ = /* @__PURE__ */ new Set(), this.y_ = [], this.w_ = n2, this.w_.Ys((t4) => {
-            i2.enqueueAndForget(async () => {
-                E_(this) && (jy("RemoteStore", "Restarting streams for network reachability change."), await async function(t5) {
-                    const e3 = Yy(t5);
-                    e3.p_.add(4), await b_(e3), e3.S_.set("Unknown"), e3.p_.delete(4), await v_(e3);
-                }(this));
-            });
-        }), this.S_ = new __PRIVATE_OnlineStateTracker(i2, s2);
-    }
-}
-async function v_(t3) {
-    if (E_(t3))
-        for (const e2 of t3.y_)
-            await e2(true);
-}
-async function b_(t3) {
-    for (const e2 of t3.y_)
-        await e2(false);
-}
-
-function __(t3, e2) {
-    const i2 = Yy(t3);
-    i2.g_.has(e2.targetId) || (i2.g_.set(e2.targetId, e2), S_(i2) ? T_(i2) : D_(i2).$o() && x_(i2, e2));
-}
-
-function w_(t3, e2) {
-    const i2 = Yy(t3),
-        s2 = D_(i2);
-    i2.g_.delete(e2), s2.$o() && k_(i2, e2), 0 === i2.g_.size && (s2.$o() ? s2.Go() : E_(i2) && i2.S_.set("Unknown"));
-}
-
-function x_(t3, e2) {
-    if (t3.b_.Be(e2.targetId), e2.resumeToken.approximateByteSize() > 0 || e2.snapshotVersion.compareTo(SnapshotVersion.min()) > 0) {
-        const i2 = t3.remoteSyncer.getRemoteKeysForTarget(e2.targetId).size;
-        e2 = e2.withExpectedCount(i2);
-    }
-    D_(t3).r_(e2);
-}
-
-function k_(t3, e2) {
-    t3.b_.Be(e2), D_(t3).i_(e2);
-}
-
-function T_(t3) {
-    t3.b_ = new __PRIVATE_WatchChangeAggregator({
-        getRemoteKeysForTarget: (e2) => t3.remoteSyncer.getRemoteKeysForTarget(e2),
-        ut: (e2) => t3.g_.get(e2) || null,
-        rt: () => t3.datastore.serializer.databaseId
-    }), D_(t3).start(), t3.S_.d_();
-}
-
-function S_(t3) {
-    return E_(t3) && !D_(t3).Ko() && t3.g_.size > 0;
-}
-
-function E_(t3) {
-    return 0 === Yy(t3).p_.size;
-}
-
-function C_(t3) {
-    t3.b_ = void 0;
-}
-async function I_(t3) {
-    t3.g_.forEach((e2, i2) => {
-        x_(t3, e2);
-    });
-}
-async function M_(t3, e2) {
-    C_(t3), S_(t3) ? (t3.S_.V_(e2), T_(t3)) : t3.S_.set("Unknown");
-}
-async function P_(t3, e2, i2) {
-    if (t3.S_.set("Online"), e2 instanceof __PRIVATE_WatchTargetChange && 2 === e2.state && e2.cause)
-        try {
-            await async function(t4, e3) {
-                const i3 = e3.cause;
-                for (const s2 of e3.targetIds)
-                    t4.g_.has(s2) && (await t4.remoteSyncer.rejectListen(s2, i3), t4.g_.delete(s2), t4.b_.removeTarget(s2));
-            }(t3, e2);
-        } catch (i3) {
-            jy("RemoteStore", "Failed to remove targets %s: %s ", e2.targetIds.join(","), i3), await R_(t3, i3);
-        }
-    else if (e2 instanceof __PRIVATE_DocumentWatchChange ? t3.b_.We(e2) : e2 instanceof __PRIVATE_ExistenceFilterChange ? t3.b_.Ze(e2) : t3.b_.je(e2), !i2.isEqual(SnapshotVersion.min()))
-        try {
-            const e3 = await l_(t3.localStore);
-            i2.compareTo(e3) >= 0 && await
-            function(t4, e4) {
-                const i3 = t4.b_.st(e4);
-                return i3.targetChanges.forEach((i4, s2) => {
-                    if (i4.resumeToken.approximateByteSize() > 0) {
-                        const n2 = t4.g_.get(s2);
-                        n2 && t4.g_.set(s2, n2.withResumeToken(i4.resumeToken, e4));
-                    }
-                }), i3.targetMismatches.forEach((e5, i4) => {
-                    const s2 = t4.g_.get(e5);
-                    if (!s2)
-                        return;
-                    t4.g_.set(e5, s2.withResumeToken(ByteString.EMPTY_BYTE_STRING, s2.snapshotVersion)), k_(t4, e5);
-                    const n2 = new TargetData(s2.target, e5, i4, s2.sequenceNumber);
-                    x_(t4, n2);
-                }), t4.remoteSyncer.applyRemoteEvent(i3);
-            }(t3, i2);
-        } catch (e3) {
-            jy("RemoteStore", "Failed to raise snapshot:", e3), await R_(t3, e3);
-        }
-}
-async function R_(t3, e2, i2) {
-    if (!rv(e2))
-        throw e2;
-    t3.p_.add(1), await b_(t3), t3.S_.set("Offline"), i2 || (i2 = () => l_(t3.localStore)), t3.asyncQueue.enqueueRetryable(async () => {
-        jy("RemoteStore", "Retrying IndexedDB access"), await i2(), t3.p_.delete(1), await v_(t3);
-    });
-}
-async function A_(t3, e2) {
-    const i2 = Yy(t3);
-    i2.asyncQueue.verifyOperationInProgress(), jy("RemoteStore", "RemoteStore received new credentials");
-    const s2 = E_(i2);
-    i2.p_.add(3), await b_(i2), s2 && i2.S_.set("Unknown"), await i2.remoteSyncer.handleCredentialChange(e2), i2.p_.delete(3), await v_(i2);
-}
-
-function D_(t3) {
-    return t3.D_ || (t3.D_ = function(t4, e2, i2) {
-        const s2 = Yy(t4);
-        return s2.h_(), new __PRIVATE_PersistentListenStream(e2, s2.connection, s2.authCredentials, s2.appCheckCredentials, s2.serializer, i2);
-    }(t3.datastore, t3.asyncQueue, {
-        _o: I_.bind(null, t3),
-        uo: M_.bind(null, t3),
-        n_: P_.bind(null, t3)
-    }), t3.y_.push(async (e2) => {
-        e2 ? (t3.D_.Wo(), S_(t3) ? T_(t3) : t3.S_.set("Unknown")) : (await t3.D_.stop(), C_(t3));
-    })), t3.D_;
-}
-class DelayedOperation {
-    constructor(t3, e2, i2, s2, n2) {
-        this.asyncQueue = t3, this.timerId = e2, this.targetTimeMs = i2, this.op = s2, this.removalCallback = n2, this.deferred = new __PRIVATE_Deferred(), this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch((t4) => {});
-    }
-    static createAndSchedule(t3, e2, i2, s2, n2) {
-        const r2 = Date.now() + i2,
-            o2 = new DelayedOperation(t3, e2, r2, s2, n2);
-        return o2.start(i2), o2;
-    }
-    start(t3) {
-        this.timerHandle = setTimeout(() => this.handleDelayElapsed(), t3);
-    }
-    skipDelay() {
-        return this.handleDelayElapsed();
-    }
-    cancel(t3) {
-        null !== this.timerHandle && (this.clearTimeout(), this.deferred.reject(new FirestoreError(Qy.CANCELLED, "Operation cancelled" + (t3 ? ": " + t3 : ""))));
-    }
-    handleDelayElapsed() {
-        this.asyncQueue.enqueueAndForget(() => null !== this.timerHandle ? (this.clearTimeout(), this.op().then((t3) => this.deferred.resolve(t3))) : Promise.resolve());
-    }
-    clearTimeout() {
-        null !== this.timerHandle && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
-    }
-}
-
-function L_(t3, e2) {
-    if (Hy("AsyncQueue", `${e2}: ${t3}`), rv(t3))
-        return new FirestoreError(Qy.UNAVAILABLE, `${e2}: ${t3}`);
-    throw t3;
-}
-class DocumentSet {
-    constructor(t3) {
-        this.comparator = t3 ? (e2, i2) => t3(e2, i2) || DocumentKey.comparator(e2.key, i2.key) : (t4, e2) => DocumentKey.comparator(t4.key, e2.key), this.keyedMap = rb(), this.sortedSet = new SortedMap(this.comparator);
-    }
-    static emptySet(t3) {
-        return new DocumentSet(t3.comparator);
-    }
-    has(t3) {
-        return null != this.keyedMap.get(t3);
-    }
-    get(t3) {
-        return this.keyedMap.get(t3);
-    }
-    first() {
-        return this.sortedSet.minKey();
-    }
-    last() {
-        return this.sortedSet.maxKey();
-    }
-    isEmpty() {
-        return this.sortedSet.isEmpty();
-    }
-    indexOf(t3) {
-        const e2 = this.keyedMap.get(t3);
-        return e2 ? this.sortedSet.indexOf(e2) : -1;
-    }
-    get size() {
-        return this.sortedSet.size;
-    }
-    forEach(t3) {
-        this.sortedSet.inorderTraversal((e2, i2) => (t3(e2), false));
-    }
-    add(t3) {
-        const e2 = this.delete(t3.key);
-        return e2.copy(e2.keyedMap.insert(t3.key, t3), e2.sortedSet.insert(t3, null));
-    }
-    delete(t3) {
-        const e2 = this.get(t3);
-        return e2 ? this.copy(this.keyedMap.remove(t3), this.sortedSet.remove(e2)) : this;
-    }
-    isEqual(t3) {
-        if (!(t3 instanceof DocumentSet))
-            return false;
-        if (this.size !== t3.size)
-            return false;
-        const e2 = this.sortedSet.getIterator(),
-            i2 = t3.sortedSet.getIterator();
-        for (; e2.hasNext();) {
-            const t4 = e2.getNext().key,
-                s2 = i2.getNext().key;
-            if (!t4.isEqual(s2))
-                return false;
-        }
-        return true;
-    }
-    toString() {
-        const t3 = [];
-        return this.forEach((e2) => {
-            t3.push(e2.toString());
-        }), 0 === t3.length ? "DocumentSet ()" : "DocumentSet (\n  " + t3.join("  \n") + "\n)";
-    }
-    copy(t3, e2) {
-        const i2 = new DocumentSet();
-        return i2.comparator = this.comparator, i2.keyedMap = t3, i2.sortedSet = e2, i2;
-    }
-}
-class __PRIVATE_DocumentChangeSet {
-    constructor() {
-        this.C_ = new SortedMap(DocumentKey.comparator);
-    }
-    track(t3) {
-        const e2 = t3.doc.key,
-            i2 = this.C_.get(e2);
-        i2 ? 0 !== t3.type && 3 === i2.type ? this.C_ = this.C_.insert(e2, t3) : 3 === t3.type && 1 !== i2.type ? this.C_ = this.C_.insert(e2, {
-            type: i2.type,
-            doc: t3.doc
-        }) : 2 === t3.type && 2 === i2.type ? this.C_ = this.C_.insert(e2, {
-            type: 2,
-            doc: t3.doc
-        }) : 2 === t3.type && 0 === i2.type ? this.C_ = this.C_.insert(e2, {
-            type: 0,
-            doc: t3.doc
-        }) : 1 === t3.type && 0 === i2.type ? this.C_ = this.C_.remove(e2) : 1 === t3.type && 2 === i2.type ? this.C_ = this.C_.insert(e2, {
-            type: 1,
-            doc: i2.doc
-        }) : 0 === t3.type && 1 === i2.type ? this.C_ = this.C_.insert(e2, {
-            type: 2,
-            doc: t3.doc
-        }) : Ky() : this.C_ = this.C_.insert(e2, t3);
-    }
-    F_() {
-        const t3 = [];
-        return this.C_.inorderTraversal((e2, i2) => {
-            t3.push(i2);
-        }), t3;
-    }
-}
-class ViewSnapshot {
-    constructor(t3, e2, i2, s2, n2, r2, o2, a2, l2) {
-        this.query = t3, this.docs = e2, this.oldDocs = i2, this.docChanges = s2, this.mutatedKeys = n2, this.fromCache = r2, this.syncStateChanged = o2, this.excludesMetadataChanges = a2, this.hasCachedResults = l2;
-    }
-    static fromInitialDocuments(t3, e2, i2, s2, n2) {
-        const r2 = [];
-        return e2.forEach((t4) => {
-            r2.push({
-                type: 0,
-                doc: t4
-            });
-        }), new ViewSnapshot(t3, e2, DocumentSet.emptySet(e2), r2, i2, s2, true, false, n2);
-    }
-    get hasPendingWrites() {
-        return !this.mutatedKeys.isEmpty();
-    }
-    isEqual(t3) {
-        if (!(this.fromCache === t3.fromCache && this.hasCachedResults === t3.hasCachedResults && this.syncStateChanged === t3.syncStateChanged && this.mutatedKeys.isEqual(t3.mutatedKeys) && Yv(this.query, t3.query) && this.docs.isEqual(t3.docs) && this.oldDocs.isEqual(t3.oldDocs)))
-            return false;
-        const e2 = this.docChanges,
-            i2 = t3.docChanges;
-        if (e2.length !== i2.length)
-            return false;
-        for (let t4 = 0; t4 < e2.length; t4++)
-            if (e2[t4].type !== i2[t4].type || !e2[t4].doc.isEqual(i2[t4].doc))
-                return false;
-        return true;
-    }
-}
-class __PRIVATE_QueryListenersInfo {
-    constructor() {
-        this.M_ = void 0, this.listeners = [];
-    }
-}
-class __PRIVATE_EventManagerImpl {
-    constructor() {
-        this.queries = new ObjectMap((t3) => Qv(t3), Yv), this.onlineState = "Unknown", this.x_ = /* @__PURE__ */ new Set();
-    }
-}
-
-function O_(t3, e2) {
-    const i2 = Yy(t3);
-    let s2 = false;
-    for (const t4 of e2) {
-        const e3 = t4.query,
-            n2 = i2.queries.get(e3);
-        if (n2) {
-            for (const e4 of n2.listeners)
-                e4.N_(t4) && (s2 = true);
-            n2.M_ = t4;
-        }
-    }
-    s2 && N_(i2);
-}
-
-function F_(t3, e2, i2) {
-    const s2 = Yy(t3),
-        n2 = s2.queries.get(e2);
-    if (n2)
-        for (const t4 of n2.listeners)
-            t4.onError(i2);
-    s2.queries.delete(e2);
-}
-
-function N_(t3) {
-    t3.x_.forEach((t4) => {
-        t4.next();
-    });
-}
-class __PRIVATE_QueryListener {
-    constructor(t3, e2, i2) {
-        this.query = t3, this.B_ = e2, this.L_ = false, this.k_ = null, this.onlineState = "Unknown", this.options = i2 || {};
-    }
-    N_(t3) {
-        if (!this.options.includeMetadataChanges) {
-            const e3 = [];
-            for (const i2 of t3.docChanges)
-                3 !== i2.type && e3.push(i2);
-            t3 = new ViewSnapshot(t3.query, t3.docs, t3.oldDocs, e3, t3.mutatedKeys, t3.fromCache, t3.syncStateChanged, true, t3.hasCachedResults);
-        }
-        let e2 = false;
-        return this.L_ ? this.q_(t3) && (this.B_.next(t3), e2 = true) : this.Q_(t3, this.onlineState) && (this.K_(t3), e2 = true), this.k_ = t3, e2;
-    }
-    onError(t3) {
-        this.B_.error(t3);
-    }
-    O_(t3) {
-        this.onlineState = t3;
-        let e2 = false;
-        return this.k_ && !this.L_ && this.Q_(this.k_, t3) && (this.K_(this.k_), e2 = true), e2;
-    }
-    Q_(t3, e2) {
-        if (!t3.fromCache)
-            return true;
-        const i2 = "Offline" !== e2;
-        return (!this.options.U_ || !i2) && (!t3.docs.isEmpty() || t3.hasCachedResults || "Offline" === e2);
-    }
-    q_(t3) {
-        if (t3.docChanges.length > 0)
-            return true;
-        const e2 = this.k_ && this.k_.hasPendingWrites !== t3.hasPendingWrites;
-        return !(!t3.syncStateChanged && !e2) && true === this.options.includeMetadataChanges;
-    }
-    K_(t3) {
-        t3 = ViewSnapshot.fromInitialDocuments(t3.query, t3.docs, t3.mutatedKeys, t3.fromCache, t3.hasCachedResults), this.L_ = true, this.B_.next(t3);
-    }
-}
-class __PRIVATE_AddedLimboDocument {
-    constructor(t3) {
-        this.key = t3;
-    }
-}
-class __PRIVATE_RemovedLimboDocument {
-    constructor(t3) {
-        this.key = t3;
-    }
-}
-class __PRIVATE_View {
-    constructor(t3, e2) {
-        this.query = t3, this.Z_ = e2, this.X_ = null, this.hasCachedResults = false, this.current = false, this.ea = ub(), this.mutatedKeys = ub(), this.ta = Zv(t3), this.na = new DocumentSet(this.ta);
-    }
-    get ra() {
-        return this.Z_;
-    }
-    ia(t3, e2) {
-        const i2 = e2 ? e2.sa : new __PRIVATE_DocumentChangeSet(),
-            s2 = e2 ? e2.na : this.na;
-        let n2 = e2 ? e2.mutatedKeys : this.mutatedKeys,
-            r2 = s2,
-            o2 = false;
-        const a2 = "F" === this.query.limitType && s2.size === this.query.limit ? s2.last() : null,
-            l2 = "L" === this.query.limitType && s2.size === this.query.limit ? s2.first() : null;
-        if (t3.inorderTraversal((t4, e3) => {
-                const h2 = s2.get(t4),
-                    c2 = Jv(this.query, e3) ? e3 : null,
-                    u2 = !!h2 && this.mutatedKeys.has(h2.key),
-                    d2 = !!c2 && (c2.hasLocalMutations || this.mutatedKeys.has(c2.key) && c2.hasCommittedMutations);
-                let f2 = false;
-                h2 && c2 ? h2.data.isEqual(c2.data) ? u2 !== d2 && (i2.track({
-                    type: 3,
-                    doc: c2
-                }), f2 = true) : this.oa(h2, c2) || (i2.track({
-                    type: 2,
-                    doc: c2
-                }), f2 = true, (a2 && this.ta(c2, a2) > 0 || l2 && this.ta(c2, l2) < 0) && (o2 = true)) : !h2 && c2 ? (i2.track({
-                    type: 0,
-                    doc: c2
-                }), f2 = true) : h2 && !c2 && (i2.track({
-                    type: 1,
-                    doc: h2
-                }), f2 = true, (a2 || l2) && (o2 = true)), f2 && (c2 ? (r2 = r2.add(c2), n2 = d2 ? n2.add(t4) : n2.delete(t4)) : (r2 = r2.delete(t4), n2 = n2.delete(t4)));
-            }), null !== this.query.limit)
-            for (; r2.size > this.query.limit;) {
-                const t4 = "F" === this.query.limitType ? r2.last() : r2.first();
-                r2 = r2.delete(t4.key), n2 = n2.delete(t4.key), i2.track({
-                    type: 1,
-                    doc: t4
-                });
-            }
-        return {
-            na: r2,
-            sa: i2,
-            zi: o2,
-            mutatedKeys: n2
-        };
-    }
-    oa(t3, e2) {
-        return t3.hasLocalMutations && e2.hasCommittedMutations && !e2.hasLocalMutations;
-    }
-    applyChanges(t3, e2, i2) {
-        const s2 = this.na;
-        this.na = t3.na, this.mutatedKeys = t3.mutatedKeys;
-        const n2 = t3.sa.F_();
-        n2.sort((t4, e3) => function(t5, e4) {
-            const i3 = (t6) => {
-                switch (t6) {
-                    case 0:
-                        return 1;
-                    case 2:
-                    case 3:
-                        return 2;
-                    case 1:
-                        return 0;
-                    default:
-                        return Ky();
-                }
-            };
-            return i3(t5) - i3(e4);
-        }(t4.type, e3.type) || this.ta(t4.doc, e3.doc)), this._a(i2);
-        const r2 = e2 ? this.aa() : [],
-            o2 = 0 === this.ea.size && this.current ? 1 : 0,
-            a2 = o2 !== this.X_;
-        return this.X_ = o2, 0 !== n2.length || a2 ? {
-            snapshot: new ViewSnapshot(this.query, t3.na, s2, n2, t3.mutatedKeys, 0 === o2, a2, false, !!i2 && i2.resumeToken.approximateByteSize() > 0),
-            ua: r2
-        } : {
-            ua: r2
-        };
-    }
-    O_(t3) {
-        return this.current && "Offline" === t3 ? (this.current = false, this.applyChanges({
-            na: this.na,
-            sa: new __PRIVATE_DocumentChangeSet(),
-            mutatedKeys: this.mutatedKeys,
-            zi: false
-        }, false)) : {
-            ua: []
-        };
-    }
-    ca(t3) {
-        return !this.Z_.has(t3) && !!this.na.has(t3) && !this.na.get(t3).hasLocalMutations;
-    }
-    _a(t3) {
-        t3 && (t3.addedDocuments.forEach((t4) => this.Z_ = this.Z_.add(t4)), t3.modifiedDocuments.forEach((t4) => {}), t3.removedDocuments.forEach((t4) => this.Z_ = this.Z_.delete(t4)), this.current = t3.current);
-    }
-    aa() {
-        if (!this.current)
-            return [];
-        const t3 = this.ea;
-        this.ea = ub(), this.na.forEach((t4) => {
-            this.ca(t4.key) && (this.ea = this.ea.add(t4.key));
-        });
-        const e2 = [];
-        return t3.forEach((t4) => {
-            this.ea.has(t4) || e2.push(new __PRIVATE_RemovedLimboDocument(t4));
-        }), this.ea.forEach((i2) => {
-            t3.has(i2) || e2.push(new __PRIVATE_AddedLimboDocument(i2));
-        }), e2;
-    }
-    la(t3) {
-        this.Z_ = t3.ss, this.ea = ub();
-        const e2 = this.ia(t3.documents);
-        return this.applyChanges(e2, true);
-    }
-    ha() {
-        return ViewSnapshot.fromInitialDocuments(this.query, this.na, this.mutatedKeys, 0 === this.X_, this.hasCachedResults);
-    }
-}
-class __PRIVATE_QueryView {
-    constructor(t3, e2, i2) {
-        this.query = t3, this.targetId = e2, this.view = i2;
-    }
-}
-class LimboResolution {
-    constructor(t3) {
-        this.key = t3, this.Pa = false;
-    }
-}
-class __PRIVATE_SyncEngineImpl {
-    constructor(t3, e2, i2, s2, n2, r2) {
-        this.localStore = t3, this.remoteStore = e2, this.eventManager = i2, this.sharedClientState = s2, this.currentUser = n2, this.maxConcurrentLimboResolutions = r2, this.Ia = {}, this.Ta = new ObjectMap((t4) => Qv(t4), Yv), this.Ea = /* @__PURE__ */ new Map(), this.da = /* @__PURE__ */ new Set(), this.Aa = new SortedMap(DocumentKey.comparator), this.Ra = /* @__PURE__ */ new Map(), this.Va = new __PRIVATE_ReferenceSet(), this.ma = {}, this.fa = /* @__PURE__ */ new Map(), this.ga = __PRIVATE_TargetIdGenerator.On(), this.onlineState = "Unknown", this.pa = void 0;
-    }
-    get isPrimaryClient() {
-        return true === this.pa;
-    }
-}
-async function $_(t3, e2) {
-    const i2 = function(t4) {
-        const e3 = Yy(t4);
-        return e3.remoteStore.remoteSyncer.applyRemoteEvent = z_.bind(null, e3), e3.remoteStore.remoteSyncer.getRemoteKeysForTarget = Q_.bind(null, e3), e3.remoteStore.remoteSyncer.rejectListen = U_.bind(null, e3), e3.Ia.n_ = O_.bind(null, e3.eventManager), e3.Ia.wa = F_.bind(null, e3.eventManager), e3;
-    }(t3);
-    let s2, n2;
-    const r2 = i2.Ta.get(e2);
-    if (r2)
-        s2 = r2.targetId, i2.sharedClientState.addLocalQueryTarget(s2), n2 = r2.view.ha();
-    else {
-        const t4 = await
-        function(t5, e3) {
-            const i3 = Yy(t5);
-            return i3.persistence.runTransaction("Allocate target", "readwrite", (t6) => {
-                let s3;
-                return i3.kr.getTargetData(t6, e3).next((n3) => n3 ? (s3 = n3, PersistencePromise.resolve(s3)) : i3.kr.allocateTargetId(t6).next((n4) => (s3 = new TargetData(e3, n4, "TargetPurposeListen", t6.currentSequenceNumber), i3.kr.addTargetData(t6, s3).next(() => s3))));
-            }).then((t6) => {
-                const s3 = i3.Ji.get(t6.targetId);
-                return (null === s3 || t6.snapshotVersion.compareTo(s3.snapshotVersion) > 0) && (i3.Ji = i3.Ji.insert(t6.targetId, t6), i3.Yi.set(e3, t6.targetId)), t6;
-            });
-        }(i2.localStore, Kv(e2)), r3 = i2.sharedClientState.addLocalQueryTarget(t4.targetId);
-        s2 = t4.targetId, n2 = await async function(t5, e3, i3, s3, n3) {
-            t5.ya = (e4, i4, s4) => async function(t6, e5, i5, s5) {
-                let n4 = e5.view.ia(i5);
-                n4.zi && (n4 = await u_(t6.localStore, e5.query, false).then(({
-                    documents: t7
-                }) => e5.view.ia(t7, n4)));
-                const r5 = s5 && s5.targetChanges.get(e5.targetId),
-                    o3 = e5.view.applyChanges(n4, t6.isPrimaryClient, r5);
-                return W_(t6, e5.targetId, o3.ua), o3.snapshot;
-            }(t5, e4, i4, s4);
-            const r4 = await u_(t5.localStore, e3, true),
-                o2 = new __PRIVATE_View(e3, r4.ss),
-                a2 = o2.ia(r4.documents),
-                l2 = TargetChange.createSynthesizedTargetChangeForCurrentChange(i3, s3 && "Offline" !== t5.onlineState, n3),
-                h2 = o2.applyChanges(a2, t5.isPrimaryClient, l2);
-            W_(t5, i3, h2.ua);
-            const c2 = new __PRIVATE_QueryView(e3, i3, o2);
-            return t5.Ta.set(e3, c2), t5.Ea.has(i3) ? t5.Ea.get(i3).push(e3) : t5.Ea.set(i3, [e3]), h2.snapshot;
-        }(i2, e2, s2, "current" === r3, t4.resumeToken), i2.isPrimaryClient && __(i2.remoteStore, t4);
-    }
-    return n2;
-}
-async function V_(t3, e2) {
-    const i2 = Yy(t3),
-        s2 = i2.Ta.get(e2),
-        n2 = i2.Ea.get(s2.targetId);
-    if (n2.length > 1)
-        return i2.Ea.set(s2.targetId, n2.filter((t4) => !Yv(t4, e2))), void i2.Ta.delete(e2);
-    i2.isPrimaryClient ? (i2.sharedClientState.removeLocalQueryTarget(s2.targetId), i2.sharedClientState.isActiveQueryTarget(s2.targetId) || await c_(i2.localStore, s2.targetId, false).then(() => {
-        i2.sharedClientState.clearQueryState(s2.targetId), w_(i2.remoteStore, s2.targetId), j_(i2, s2.targetId);
-    }).catch(nv)) : (j_(i2, s2.targetId), await c_(i2.localStore, s2.targetId, true));
-}
-async function z_(t3, e2) {
-    const i2 = Yy(t3);
-    try {
-        const t4 = await h_(i2.localStore, e2);
-        e2.targetChanges.forEach((t5, e3) => {
-            const s2 = i2.Ra.get(e3);
-            s2 && (Gy(t5.addedDocuments.size + t5.modifiedDocuments.size + t5.removedDocuments.size <= 1), t5.addedDocuments.size > 0 ? s2.Pa = true : t5.modifiedDocuments.size > 0 ? Gy(s2.Pa) : t5.removedDocuments.size > 0 && (Gy(s2.Pa), s2.Pa = false));
-        }), await G_(i2, t4, e2);
-    } catch (t4) {
-        await nv(t4);
-    }
-}
-
-function B_(t3, e2, i2) {
-    const s2 = Yy(t3);
-    if (s2.isPrimaryClient && 0 === i2 || !s2.isPrimaryClient && 1 === i2) {
-        const t4 = [];
-        s2.Ta.forEach((i3, s3) => {
-                const n2 = s3.view.O_(e2);
-                n2.snapshot && t4.push(n2.snapshot);
-            }),
-            function(t5, e3) {
-                const i3 = Yy(t5);
-                i3.onlineState = e3;
-                let s3 = false;
-                i3.queries.forEach((t6, i4) => {
-                    for (const t7 of i4.listeners)
-                        t7.O_(e3) && (s3 = true);
-                }), s3 && N_(i3);
-            }(s2.eventManager, e2), t4.length && s2.Ia.n_(t4), s2.onlineState = e2, s2.isPrimaryClient && s2.sharedClientState.setOnlineState(e2);
-    }
-}
-async function U_(t3, e2, i2) {
-    const s2 = Yy(t3);
-    s2.sharedClientState.updateQueryState(e2, "rejected", i2);
-    const n2 = s2.Ra.get(e2),
-        r2 = n2 && n2.key;
-    if (r2) {
-        let t4 = new SortedMap(DocumentKey.comparator);
-        t4 = t4.insert(r2, MutableDocument.newNoDocument(r2, SnapshotVersion.min()));
-        const i3 = ub().add(r2),
-            n3 = new RemoteEvent(SnapshotVersion.min(), /* @__PURE__ */ new Map(), new SortedMap(Jy), t4, i3);
-        await z_(s2, n3), s2.Aa = s2.Aa.remove(r2), s2.Ra.delete(e2), K_(s2);
-    } else
-        await c_(s2.localStore, e2, false).then(() => j_(s2, e2, i2)).catch(nv);
-}
-
-function j_(t3, e2, i2 = null) {
-    t3.sharedClientState.removeLocalQueryTarget(e2);
-    for (const s2 of t3.Ea.get(e2))
-        t3.Ta.delete(s2), i2 && t3.Ia.wa(s2, i2);
-    t3.Ea.delete(e2), t3.isPrimaryClient && t3.Va.Ar(e2).forEach((e3) => {
-        t3.Va.containsKey(e3) || H_(t3, e3);
-    });
-}
-
-function H_(t3, e2) {
-    t3.da.delete(e2.path.canonicalString());
-    const i2 = t3.Aa.get(e2);
-    null !== i2 && (w_(t3.remoteStore, i2), t3.Aa = t3.Aa.remove(e2), t3.Ra.delete(i2), K_(t3));
-}
-
-function W_(t3, e2, i2) {
-    for (const s2 of i2)
-        s2 instanceof __PRIVATE_AddedLimboDocument ? (t3.Va.addReference(s2.key, e2), q_(t3, s2)) : s2 instanceof __PRIVATE_RemovedLimboDocument ? (jy("SyncEngine", "Document no longer in limbo: " + s2.key), t3.Va.removeReference(s2.key, e2), t3.Va.containsKey(s2.key) || H_(t3, s2.key)) : Ky();
-}
-
-function q_(t3, e2) {
-    const i2 = e2.key,
-        s2 = i2.path.canonicalString();
-    t3.Aa.get(i2) || t3.da.has(s2) || (jy("SyncEngine", "New document in limbo: " + i2), t3.da.add(s2), K_(t3));
-}
-
-function K_(t3) {
-    for (; t3.da.size > 0 && t3.Aa.size < t3.maxConcurrentLimboResolutions;) {
-        const e2 = t3.da.values().next().value;
-        t3.da.delete(e2);
-        const i2 = new DocumentKey(ResourcePath.fromString(e2)),
-            s2 = t3.ga.next();
-        t3.Ra.set(s2, new LimboResolution(i2)), t3.Aa = t3.Aa.insert(i2, s2), __(t3.remoteStore, new TargetData(Kv(Hv(i2.path)), s2, "TargetPurposeLimboResolution", __PRIVATE_ListenSequence.ae));
-    }
-}
-async function G_(t3, e2, i2) {
-    const s2 = Yy(t3),
-        n2 = [],
-        r2 = [],
-        o2 = [];
-    s2.Ta.isEmpty() || (s2.Ta.forEach((t4, a2) => {
-        o2.push(s2.ya(a2, e2, i2).then((t5) => {
-            if ((t5 || i2) && s2.isPrimaryClient && s2.sharedClientState.updateQueryState(a2.targetId, (null == t5 ? void 0 : t5.fromCache) ? "not-current" : "current"), t5) {
-                n2.push(t5);
-                const e3 = __PRIVATE_LocalViewChanges.qi(a2.targetId, t5);
-                r2.push(e3);
-            }
-        }));
-    }), await Promise.all(o2), s2.Ia.n_(n2), await async function(t4, e3) {
-        const i3 = Yy(t4);
-        try {
-            await i3.persistence.runTransaction("notifyLocalViewChanges", "readwrite", (t5) => PersistencePromise.forEach(e3, (e4) => PersistencePromise.forEach(e4.Li, (s3) => i3.persistence.referenceDelegate.addReference(t5, e4.targetId, s3)).next(() => PersistencePromise.forEach(e4.ki, (s3) => i3.persistence.referenceDelegate.removeReference(t5, e4.targetId, s3)))));
-        } catch (t5) {
-            if (!rv(t5))
-                throw t5;
-            jy("LocalStore", "Failed to update sequence numbers: " + t5);
-        }
-        for (const t5 of e3) {
-            const e4 = t5.targetId;
-            if (!t5.fromCache) {
-                const t6 = i3.Ji.get(e4),
-                    s3 = t6.snapshotVersion,
-                    n3 = t6.withLastLimboFreeSnapshotVersion(s3);
-                i3.Ji = i3.Ji.insert(e4, n3);
-            }
-        }
-    }(s2.localStore, r2));
-}
-async function Y_(t3, e2) {
-    const i2 = Yy(t3);
-    if (!i2.currentUser.isEqual(e2)) {
-        jy("SyncEngine", "User change. New user:", e2.toKey());
-        const t4 = await a_(i2.localStore, e2);
-        i2.currentUser = e2,
-            function(t5, e3) {
-                t5.fa.forEach((t6) => {
-                    t6.forEach((t7) => {
-                        t7.reject(new FirestoreError(Qy.CANCELLED, e3));
-                    });
-                }), t5.fa.clear();
-            }(i2, "'waitForPendingWrites' promise is rejected due to a user change."), i2.sharedClientState.handleUserChange(e2, t4.removedBatchIds, t4.addedBatchIds), await G_(i2, t4.ts);
-    }
-}
-
-function Q_(t3, e2) {
-    const i2 = Yy(t3),
-        s2 = i2.Ra.get(e2);
-    if (s2 && s2.Pa)
-        return ub().add(s2.key);
-    {
-        let t4 = ub();
-        const s3 = i2.Ea.get(e2);
-        if (!s3)
-            return t4;
-        for (const e3 of s3) {
-            const s4 = i2.Ta.get(e3);
-            t4 = t4.unionWith(s4.view.ra);
-        }
-        return t4;
-    }
-}
-class MemoryOfflineComponentProvider {
-    constructor() {
-        this.synchronizeTabs = false;
-    }
-    async initialize(t3) {
-        this.serializer = y_(t3.databaseInfo.databaseId), this.sharedClientState = this.createSharedClientState(t3), this.persistence = this.createPersistence(t3), await this.persistence.start(), this.localStore = this.createLocalStore(t3), this.gcScheduler = this.createGarbageCollectionScheduler(t3, this.localStore), this.indexBackfillerScheduler = this.createIndexBackfillerScheduler(t3, this.localStore);
-    }
-    createGarbageCollectionScheduler(t3, e2) {
-        return null;
-    }
-    createIndexBackfillerScheduler(t3, e2) {
-        return null;
-    }
-    createLocalStore(t3) {
-        return function(t4, e2, i2, s2) {
-            return new __PRIVATE_LocalStoreImpl(t4, e2, i2, s2);
-        }(this.persistence, new __PRIVATE_QueryEngine(), t3.initialUser, this.serializer);
-    }
-    createPersistence(t3) {
-        return new __PRIVATE_MemoryPersistence(__PRIVATE_MemoryEagerDelegate.zr, this.serializer);
-    }
-    createSharedClientState(t3) {
-        return new __PRIVATE_MemorySharedClientState();
-    }
-    async terminate() {
-        this.gcScheduler && this.gcScheduler.stop(), await this.sharedClientState.shutdown(), await this.persistence.shutdown();
-    }
-}
-class OnlineComponentProvider {
-    async initialize(t3, e2) {
-        this.localStore || (this.localStore = t3.localStore, this.sharedClientState = t3.sharedClientState, this.datastore = this.createDatastore(e2), this.remoteStore = this.createRemoteStore(e2), this.eventManager = this.createEventManager(e2), this.syncEngine = this.createSyncEngine(e2, !t3.synchronizeTabs), this.sharedClientState.onlineStateHandler = (t4) => B_(this.syncEngine, t4, 1), this.remoteStore.remoteSyncer.handleCredentialChange = Y_.bind(null, this.syncEngine), await async function(t4, e3) {
-            const i2 = Yy(t4);
-            e3 ? (i2.p_.delete(2), await v_(i2)) : e3 || (i2.p_.add(2), await b_(i2), i2.S_.set("Unknown"));
-        }(this.remoteStore, this.syncEngine.isPrimaryClient));
-    }
-    createEventManager(t3) {
-        return new __PRIVATE_EventManagerImpl();
-    }
-    createDatastore(t3) {
-        const e2 = y_(t3.databaseInfo.databaseId),
-            i2 = function(t4) {
-                return new __PRIVATE_WebChannelConnection(t4);
-            }(t3.databaseInfo);
-        return function(t4, e3, i3, s2) {
-            return new __PRIVATE_DatastoreImpl(t4, e3, i3, s2);
-        }(t3.authCredentials, t3.appCheckCredentials, i2, e2);
-    }
-    createRemoteStore(t3) {
-        return function(t4, e2, i2, s2, n2) {
-            return new __PRIVATE_RemoteStoreImpl(t4, e2, i2, s2, n2);
-        }(this.localStore, this.datastore, t3.asyncQueue, (t4) => B_(this.syncEngine, t4, 0), __PRIVATE_BrowserConnectivityMonitor.v() ? new __PRIVATE_BrowserConnectivityMonitor() : new __PRIVATE_NoopConnectivityMonitor());
-    }
-    createSyncEngine(t3, e2) {
-        return function(t4, e3, i2, s2, n2, r2, o2) {
-            const a2 = new __PRIVATE_SyncEngineImpl(t4, e3, i2, s2, n2, r2);
-            return o2 && (a2.pa = true), a2;
-        }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, t3.initialUser, t3.maxConcurrentLimboResolutions, e2);
-    }
-    terminate() {
-        return async function(t3) {
-            const e2 = Yy(t3);
-            jy("RemoteStore", "RemoteStore shutting down."), e2.p_.add(5), await b_(e2), e2.w_.shutdown(), e2.S_.set("Unknown");
-        }(this.remoteStore);
-    }
-}
-class __PRIVATE_AsyncObserver {
-    constructor(t3) {
-        this.observer = t3, this.muted = false;
-    }
-    next(t3) {
-        this.observer.next && this.Da(this.observer.next, t3);
-    }
-    error(t3) {
-        this.observer.error ? this.Da(this.observer.error, t3) : Hy("Uncaught Error in snapshot listener:", t3.toString());
-    }
-    va() {
-        this.muted = true;
-    }
-    Da(t3, e2) {
-        this.muted || setTimeout(() => {
-            this.muted || t3(e2);
-        }, 0);
-    }
-}
-class FirestoreClient {
-    constructor(t3, e2, i2, s2) {
-        this.authCredentials = t3, this.appCheckCredentials = e2, this.asyncQueue = i2, this.databaseInfo = s2, this.user = User.UNAUTHENTICATED, this.clientId = __PRIVATE_AutoId.V(), this.authCredentialListener = () => Promise.resolve(), this.appCheckCredentialListener = () => Promise.resolve(), this.authCredentials.start(i2, async (t4) => {
-            jy("FirestoreClient", "Received user=", t4.uid), await this.authCredentialListener(t4), this.user = t4;
-        }), this.appCheckCredentials.start(i2, (t4) => (jy("FirestoreClient", "Received new app check token=", t4), this.appCheckCredentialListener(t4, this.user)));
-    }
-    async getConfiguration() {
-        return {
-            asyncQueue: this.asyncQueue,
-            databaseInfo: this.databaseInfo,
-            clientId: this.clientId,
-            authCredentials: this.authCredentials,
-            appCheckCredentials: this.appCheckCredentials,
-            initialUser: this.user,
-            maxConcurrentLimboResolutions: 100
-        };
-    }
-    setCredentialChangeListener(t3) {
-        this.authCredentialListener = t3;
-    }
-    setAppCheckTokenChangeListener(t3) {
-        this.appCheckCredentialListener = t3;
-    }
-    verifyNotTerminated() {
-        if (this.asyncQueue.isShuttingDown)
-            throw new FirestoreError(Qy.FAILED_PRECONDITION, "The client has already been terminated.");
-    }
-    terminate() {
-        this.asyncQueue.enterRestrictedMode();
-        const t3 = new __PRIVATE_Deferred();
-        return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
-            try {
-                this._onlineComponents && await this._onlineComponents.terminate(), this._offlineComponents && await this._offlineComponents.terminate(), this.authCredentials.shutdown(), this.appCheckCredentials.shutdown(), t3.resolve();
-            } catch (e2) {
-                const i2 = L_(e2, "Failed to shutdown persistence");
-                t3.reject(i2);
-            }
-        }), t3.promise;
-    }
-}
-async function X_(t3, e2) {
-    t3.asyncQueue.verifyOperationInProgress(), jy("FirestoreClient", "Initializing OfflineComponentProvider");
-    const i2 = await t3.getConfiguration();
-    await e2.initialize(i2);
-    let s2 = i2.initialUser;
-    t3.setCredentialChangeListener(async (t4) => {
-        s2.isEqual(t4) || (await a_(e2.localStore, t4), s2 = t4);
-    }), e2.persistence.setDatabaseDeletedListener(() => t3.terminate()), t3._offlineComponents = e2;
-}
-async function J_(t3, e2) {
-    t3.asyncQueue.verifyOperationInProgress();
-    const i2 = await async function(t4) {
-        if (!t4._offlineComponents)
-            if (t4._uninitializedComponentsProvider) {
-                jy("FirestoreClient", "Using user provided OfflineComponentProvider");
-                try {
-                    await X_(t4, t4._uninitializedComponentsProvider._offline);
-                } catch (e3) {
-                    const i3 = e3;
-                    if (! function(t5) {
-                            return "FirebaseError" === t5.name ? t5.code === Qy.FAILED_PRECONDITION || t5.code === Qy.UNIMPLEMENTED : !("undefined" != typeof DOMException && t5 instanceof DOMException) || 22 === t5.code || 20 === t5.code || 11 === t5.code;
-                        }(i3))
-                        throw i3;
-                    Wy("Error using user provided cache. Falling back to memory cache: " + i3), await X_(t4, new MemoryOfflineComponentProvider());
-                }
-            } else
-                jy("FirestoreClient", "Using default OfflineComponentProvider"), await X_(t4, new MemoryOfflineComponentProvider());
-        return t4._offlineComponents;
-    }(t3);
-    jy("FirestoreClient", "Initializing OnlineComponentProvider");
-    const s2 = await t3.getConfiguration();
-    await e2.initialize(i2, s2), t3.setCredentialChangeListener((t4) => A_(e2.remoteStore, t4)), t3.setAppCheckTokenChangeListener((t4, i3) => A_(e2.remoteStore, i3)), t3._onlineComponents = e2;
-}
-async function Z_(t3) {
-    const e2 = await async function(t4) {
-        return t4._onlineComponents || (t4._uninitializedComponentsProvider ? (jy("FirestoreClient", "Using user provided OnlineComponentProvider"), await J_(t4, t4._uninitializedComponentsProvider._online)) : (jy("FirestoreClient", "Using default OnlineComponentProvider"), await J_(t4, new OnlineComponentProvider()))), t4._onlineComponents;
-    }(t3), i2 = e2.eventManager;
-    return i2.onListen = $_.bind(null, e2.syncEngine), i2.onUnlisten = V_.bind(null, e2.syncEngine), i2;
-}
-
-function tw(t3, e2, i2 = {}) {
-    const s2 = new __PRIVATE_Deferred();
-    return t3.asyncQueue.enqueueAndForget(async () => function(t4, e3, i3, s3, n2) {
-        const r2 = new __PRIVATE_AsyncObserver({
-                next: (r3) => {
-                    e3.enqueueAndForget(() => async function(t5, e4) {
-                        const i4 = Yy(t5),
-                            s4 = e4.query;
-                        let n3 = false;
-                        const r4 = i4.queries.get(s4);
-                        if (r4) {
-                            const t6 = r4.listeners.indexOf(e4);
-                            t6 >= 0 && (r4.listeners.splice(t6, 1), n3 = 0 === r4.listeners.length);
-                        }
-                        if (n3)
-                            return i4.queries.delete(s4), i4.onUnlisten(s4);
-                    }(t4, o2));
-                    const a2 = r3.docs.has(i3);
-                    !a2 && r3.fromCache ? n2.reject(new FirestoreError(Qy.UNAVAILABLE, "Failed to get document because the client is offline.")) : a2 && r3.fromCache && s3 && "server" === s3.source ? n2.reject(new FirestoreError(Qy.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : n2.resolve(r3);
-                },
-                error: (t5) => n2.reject(t5)
-            }),
-            o2 = new __PRIVATE_QueryListener(Hv(i3.path), r2, {
-                includeMetadataChanges: true,
-                U_: true
-            });
-        return async function(t5, e4) {
-            const i4 = Yy(t5),
-                s4 = e4.query;
-            let n3 = false,
-                r3 = i4.queries.get(s4);
-            if (r3 || (n3 = true, r3 = new __PRIVATE_QueryListenersInfo()), n3)
-                try {
-                    r3.M_ = await i4.onListen(s4);
-                } catch (t6) {
-                    const i5 = L_(t6, `Initialization of query '${Xv(e4.query)}' failed`);
-                    return void e4.onError(i5);
-                }
-            i4.queries.set(s4, r3), r3.listeners.push(e4), e4.O_(i4.onlineState), r3.M_ && e4.N_(r3.M_) && N_(i4);
-        }(t4, o2);
-    }(await Z_(t3), t3.asyncQueue, e2, i2, s2)), s2.promise;
-}
-
-function ew(t3) {
-    const e2 = {};
-    return void 0 !== t3.timeoutSeconds && (e2.timeoutSeconds = t3.timeoutSeconds), e2;
-}
-const iw = /* @__PURE__ */ new Map();
-
-function sw(t3) {
-    if (!DocumentKey.isDocumentKey(t3))
-        throw new FirestoreError(Qy.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${t3} has ${t3.length}.`);
-}
-
-function nw(t3, e2) {
-    if ("_delegate" in t3 && (t3 = t3._delegate), !(t3 instanceof e2)) {
-        if (e2.name === t3.constructor.name)
-            throw new FirestoreError(Qy.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
-        {
-            const i2 = function(t4) {
-                if (void 0 === t4)
-                    return "undefined";
-                if (null === t4)
-                    return "null";
-                if ("string" == typeof t4)
-                    return t4.length > 20 && (t4 = `${t4.substring(0, 20)}...`), JSON.stringify(t4);
-                if ("number" == typeof t4 || "boolean" == typeof t4)
-                    return "" + t4;
-                if ("object" == typeof t4) {
-                    if (t4 instanceof Array)
-                        return "an array";
-                    {
-                        const e3 = function(t5) {
-                            return t5.constructor ? t5.constructor.name : null;
-                        }(t4);
-                        return e3 ? `a custom ${e3} object` : "an object";
-                    }
-                }
-                return "function" == typeof t4 ? "a function" : Ky();
-            }(t3);
-            throw new FirestoreError(Qy.INVALID_ARGUMENT, `Expected type '${e2.name}', but it was: ${i2}`);
-        }
-    }
-    return t3;
-}
-class FirestoreSettingsImpl {
-    constructor(t3) {
-        var e2, i2;
-        if (void 0 === t3.host) {
-            if (void 0 !== t3.ssl)
-                throw new FirestoreError(Qy.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
-            this.host = "firestore.googleapis.com", this.ssl = true;
-        } else
-            this.host = t3.host, this.ssl = null === (e2 = t3.ssl) || void 0 === e2 || e2;
-        if (this.credentials = t3.credentials, this.ignoreUndefinedProperties = !!t3.ignoreUndefinedProperties, this.localCache = t3.localCache, void 0 === t3.cacheSizeBytes)
-            this.cacheSizeBytes = 41943040;
-        else {
-            if (-1 !== t3.cacheSizeBytes && t3.cacheSizeBytes < 1048576)
-                throw new FirestoreError(Qy.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
-            this.cacheSizeBytes = t3.cacheSizeBytes;
-        }
-        (function(t4, e3, i3, s2) {
-            if (true === e3 && true === s2)
-                throw new FirestoreError(Qy.INVALID_ARGUMENT, `${t4} and ${i3} cannot be used together.`);
-        })("experimentalForceLongPolling", t3.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", t3.experimentalAutoDetectLongPolling), this.experimentalForceLongPolling = !!t3.experimentalForceLongPolling, this.experimentalForceLongPolling ? this.experimentalAutoDetectLongPolling = false : void 0 === t3.experimentalAutoDetectLongPolling ? this.experimentalAutoDetectLongPolling = true : this.experimentalAutoDetectLongPolling = !!t3.experimentalAutoDetectLongPolling, this.experimentalLongPollingOptions = ew(null !== (i2 = t3.experimentalLongPollingOptions) && void 0 !== i2 ? i2 : {}),
-            function(t4) {
-                if (void 0 !== t4.timeoutSeconds) {
-                    if (isNaN(t4.timeoutSeconds))
-                        throw new FirestoreError(Qy.INVALID_ARGUMENT, `invalid long polling timeout: ${t4.timeoutSeconds} (must not be NaN)`);
-                    if (t4.timeoutSeconds < 5)
-                        throw new FirestoreError(Qy.INVALID_ARGUMENT, `invalid long polling timeout: ${t4.timeoutSeconds} (minimum allowed value is 5)`);
-                    if (t4.timeoutSeconds > 30)
-                        throw new FirestoreError(Qy.INVALID_ARGUMENT, `invalid long polling timeout: ${t4.timeoutSeconds} (maximum allowed value is 30)`);
-                }
-            }(this.experimentalLongPollingOptions), this.useFetchStreams = !!t3.useFetchStreams;
-    }
-    isEqual(t3) {
-        return this.host === t3.host && this.ssl === t3.ssl && this.credentials === t3.credentials && this.cacheSizeBytes === t3.cacheSizeBytes && this.experimentalForceLongPolling === t3.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === t3.experimentalAutoDetectLongPolling && function(t4, e2) {
-            return t4.timeoutSeconds === e2.timeoutSeconds;
-        }(this.experimentalLongPollingOptions, t3.experimentalLongPollingOptions) && this.ignoreUndefinedProperties === t3.ignoreUndefinedProperties && this.useFetchStreams === t3.useFetchStreams;
-    }
-}
-class Firestore$1 {
-    constructor(t3, e2, i2, s2) {
-        this._authCredentials = t3, this._appCheckCredentials = e2, this._databaseId = i2, this._app = s2, this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new FirestoreSettingsImpl({}), this._settingsFrozen = false;
-    }
-    get app() {
-        if (!this._app)
-            throw new FirestoreError(Qy.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
-        return this._app;
-    }
-    get _initialized() {
-        return this._settingsFrozen;
-    }
-    get _terminated() {
-        return void 0 !== this._terminateTask;
-    }
-    _setSettings(t3) {
-        if (this._settingsFrozen)
-            throw new FirestoreError(Qy.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
-        this._settings = new FirestoreSettingsImpl(t3), void 0 !== t3.credentials && (this._authCredentials = function(t4) {
-            if (!t4)
-                return new __PRIVATE_EmptyAuthCredentialsProvider();
-            switch (t4.type) {
-                case "firstParty":
-                    return new __PRIVATE_FirstPartyAuthCredentialsProvider(t4.sessionIndex || "0", t4.iamToken || null, t4.authTokenFactory || null);
-                case "provider":
-                    return t4.client;
-                default:
-                    throw new FirestoreError(Qy.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type");
-            }
-        }(t3.credentials));
-    }
-    _getSettings() {
-        return this._settings;
-    }
-    _freezeSettings() {
-        return this._settingsFrozen = true, this._settings;
-    }
-    _delete() {
-        return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
-    }
-    toJSON() {
-        return {
-            app: this._app,
-            databaseId: this._databaseId,
-            settings: this._settings
-        };
-    }
-    _terminate() {
-        return function(t3) {
-            const e2 = iw.get(t3);
-            e2 && (jy("ComponentProvider", "Removing Datastore"), iw.delete(t3), e2.terminate());
-        }(this), Promise.resolve();
-    }
-}
-class Query {
-    constructor(t3, e2, i2) {
-        this.converter = e2, this._query = i2, this.type = "query", this.firestore = t3;
-    }
-    withConverter(t3) {
-        return new Query(this.firestore, t3, this._query);
-    }
-}
-class DocumentReference {
-    constructor(t3, e2, i2) {
-        this.converter = e2, this._key = i2, this.type = "document", this.firestore = t3;
-    }
-    get _path() {
-        return this._key.path;
-    }
-    get id() {
-        return this._key.path.lastSegment();
-    }
-    get path() {
-        return this._key.path.canonicalString();
-    }
-    get parent() {
-        return new CollectionReference(this.firestore, this.converter, this._key.path.popLast());
-    }
-    withConverter(t3) {
-        return new DocumentReference(this.firestore, t3, this._key);
-    }
-}
-class CollectionReference extends Query {
-    constructor(t3, e2, i2) {
-        super(t3, e2, Hv(i2)), this._path = i2, this.type = "collection";
-    }
-    get id() {
-        return this._query.path.lastSegment();
-    }
-    get path() {
-        return this._query.path.canonicalString();
-    }
-    get parent() {
-        const t3 = this._path.popLast();
-        return t3.isEmpty() ? null : new DocumentReference(this.firestore, null, new DocumentKey(t3));
-    }
-    withConverter(t3) {
-        return new CollectionReference(this.firestore, t3, this._path);
-    }
-}
-
-function rw(t3, e2, ...i2) {
-    if (t3 = Md(t3), 1 === arguments.length && (e2 = __PRIVATE_AutoId.V()), function(t4, e3, i3) {
-            if (!i3)
-                throw new FirestoreError(Qy.INVALID_ARGUMENT, `Function ${t4}() cannot be called with an empty ${e3}.`);
-        }("doc", "path", e2), t3 instanceof Firestore$1) {
-        const s2 = ResourcePath.fromString(e2, ...i2);
-        return sw(s2), new DocumentReference(t3, null, new DocumentKey(s2));
-    } {
-        if (!(t3 instanceof DocumentReference || t3 instanceof CollectionReference))
-            throw new FirestoreError(Qy.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
-        const s2 = t3._path.child(ResourcePath.fromString(e2, ...i2));
-        return sw(s2), new DocumentReference(t3.firestore, t3 instanceof CollectionReference ? t3.converter : null, new DocumentKey(s2));
-    }
-}
-class __PRIVATE_AsyncQueueImpl {
-    constructor() {
-        this.Ua = Promise.resolve(), this.Wa = [], this.Ga = false, this.za = [], this.ja = null, this.Ha = false, this.Ja = false, this.Ya = [], this.Qo = new __PRIVATE_ExponentialBackoff(this, "async_queue_retry"), this.Za = () => {
-            const t4 = g_();
-            t4 && jy("AsyncQueue", "Visibility state changed to " + t4.visibilityState), this.Qo.Oo();
-        };
-        const t3 = g_();
-        t3 && "function" == typeof t3.addEventListener && t3.addEventListener("visibilitychange", this.Za);
-    }
-    get isShuttingDown() {
-        return this.Ga;
-    }
-    enqueueAndForget(t3) {
-        this.enqueue(t3);
-    }
-    enqueueAndForgetEvenWhileRestricted(t3) {
-        this.Xa(), this.eu(t3);
-    }
-    enterRestrictedMode(t3) {
-        if (!this.Ga) {
-            this.Ga = true, this.Ja = t3 || false;
-            const e2 = g_();
-            e2 && "function" == typeof e2.removeEventListener && e2.removeEventListener("visibilitychange", this.Za);
-        }
-    }
-    enqueue(t3) {
-        if (this.Xa(), this.Ga)
-            return new Promise(() => {});
-        const e2 = new __PRIVATE_Deferred();
-        return this.eu(() => this.Ga && this.Ja ? Promise.resolve() : (t3().then(e2.resolve, e2.reject), e2.promise)).then(() => e2.promise);
-    }
-    enqueueRetryable(t3) {
-        this.enqueueAndForget(() => (this.Wa.push(t3), this.tu()));
-    }
-    async tu() {
-        if (0 !== this.Wa.length) {
-            try {
-                await this.Wa[0](), this.Wa.shift(), this.Qo.reset();
-            } catch (t3) {
-                if (!rv(t3))
-                    throw t3;
-                jy("AsyncQueue", "Operation failed with retryable error: " + t3);
-            }
-            this.Wa.length > 0 && this.Qo.Mo(() => this.tu());
-        }
-    }
-    eu(t3) {
-        const e2 = this.Ua.then(() => (this.Ha = true, t3().catch((t4) => {
-            this.ja = t4, this.Ha = false;
-            const e3 = function(t5) {
-                let e4 = t5.message || "";
-                return t5.stack && (e4 = t5.stack.includes(t5.message) ? t5.stack : t5.message + "\n" + t5.stack), e4;
-            }(t4);
-            throw Hy("INTERNAL UNHANDLED ERROR: ", e3), t4;
-        }).then((t4) => (this.Ha = false, t4))));
-        return this.Ua = e2, e2;
-    }
-    enqueueAfterDelay(t3, e2, i2) {
-        this.Xa(), this.Ya.indexOf(t3) > -1 && (e2 = 0);
-        const s2 = DelayedOperation.createAndSchedule(this, t3, e2, i2, (t4) => this.nu(t4));
-        return this.za.push(s2), s2;
-    }
-    Xa() {
-        this.ja && Ky();
-    }
-    verifyOperationInProgress() {}
-    async ru() {
-        let t3;
-        do {
-            t3 = this.Ua, await t3;
-        } while (t3 !== this.Ua);
-    }
-    iu(t3) {
-        for (const e2 of this.za)
-            if (e2.timerId === t3)
-                return true;
-        return false;
-    }
-    su(t3) {
-        return this.ru().then(() => {
-            this.za.sort((t4, e2) => t4.targetTimeMs - e2.targetTimeMs);
-            for (const e2 of this.za)
-                if (e2.skipDelay(), "all" !== t3 && e2.timerId === t3)
-                    break;
-            return this.ru();
-        });
-    }
-    ou(t3) {
-        this.Ya.push(t3);
-    }
-    nu(t3) {
-        const e2 = this.za.indexOf(t3);
-        this.za.splice(e2, 1);
-    }
-}
-class Firestore extends Firestore$1 {
-    constructor(t3, e2, i2, s2) {
-        super(t3, e2, i2, s2), this.type = "firestore", this._queue = new __PRIVATE_AsyncQueueImpl(), this._persistenceKey = (null == s2 ? void 0 : s2.name) || "[DEFAULT]";
-    }
-    _terminate() {
-        return this._firestoreClient || ow(this), this._firestoreClient.terminate();
-    }
-}
-
-function ow(t3) {
-    var e2, i2, s2;
-    const n2 = t3._freezeSettings(),
-        r2 = function(t4, e3, i3, s3) {
-            return new DatabaseInfo(t4, e3, i3, s3.host, s3.ssl, s3.experimentalForceLongPolling, s3.experimentalAutoDetectLongPolling, ew(s3.experimentalLongPollingOptions), s3.useFetchStreams);
-        }(t3._databaseId, (null === (e2 = t3._app) || void 0 === e2 ? void 0 : e2.options.appId) || "", t3._persistenceKey, n2);
-    t3._firestoreClient = new FirestoreClient(t3._authCredentials, t3._appCheckCredentials, t3._queue, r2), (null === (i2 = n2.localCache) || void 0 === i2 ? void 0 : i2._offlineComponentProvider) && (null === (s2 = n2.localCache) || void 0 === s2 ? void 0 : s2._onlineComponentProvider) && (t3._firestoreClient._uninitializedComponentsProvider = {
-        _offlineKind: n2.localCache.kind,
-        _offline: n2.localCache._offlineComponentProvider,
-        _online: n2.localCache._onlineComponentProvider
-    });
-}
-class Bytes {
-    constructor(t3) {
-        this._byteString = t3;
-    }
-    static fromBase64String(t3) {
-        try {
-            return new Bytes(ByteString.fromBase64String(t3));
-        } catch (t4) {
-            throw new FirestoreError(Qy.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + t4);
-        }
-    }
-    static fromUint8Array(t3) {
-        return new Bytes(ByteString.fromUint8Array(t3));
-    }
-    toBase64() {
-        return this._byteString.toBase64();
-    }
-    toUint8Array() {
-        return this._byteString.toUint8Array();
-    }
-    toString() {
-        return "Bytes(base64: " + this.toBase64() + ")";
-    }
-    isEqual(t3) {
-        return this._byteString.isEqual(t3._byteString);
-    }
-}
-class FieldPath {
-    constructor(...t3) {
-        for (let e2 = 0; e2 < t3.length; ++e2)
-            if (0 === t3[e2].length)
-                throw new FirestoreError(Qy.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
-        this._internalPath = new FieldPath$1(t3);
-    }
-    isEqual(t3) {
-        return this._internalPath.isEqual(t3._internalPath);
-    }
-}
-class GeoPoint {
-    constructor(t3, e2) {
-        if (!isFinite(t3) || t3 < -90 || t3 > 90)
-            throw new FirestoreError(Qy.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + t3);
-        if (!isFinite(e2) || e2 < -180 || e2 > 180)
-            throw new FirestoreError(Qy.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + e2);
-        this._lat = t3, this._long = e2;
-    }
-    get latitude() {
-        return this._lat;
-    }
-    get longitude() {
-        return this._long;
-    }
-    isEqual(t3) {
-        return this._lat === t3._lat && this._long === t3._long;
-    }
-    toJSON() {
-        return {
-            latitude: this._lat,
-            longitude: this._long
-        };
-    }
-    _compareTo(t3) {
-        return Jy(this._lat, t3._lat) || Jy(this._long, t3._long);
-    }
-}
-const aw = new RegExp("[~\\*/\\[\\]]");
-
-function lw(t3, e2, i2, s2, n2) {
-    const r2 = s2 && !s2.isEmpty(),
-        o2 = void 0 !== n2;
-    let a2 = `Function ${e2}() called with invalid data`;
-    i2 && (a2 += " (via `toFirestore()`)"), a2 += ". ";
-    let l2 = "";
-    return (r2 || o2) && (l2 += " (found", r2 && (l2 += ` in field ${s2}`), o2 && (l2 += ` in document ${n2}`), l2 += ")"), new FirestoreError(Qy.INVALID_ARGUMENT, a2 + t3 + l2);
-}
-class DocumentSnapshot$1 {
-    constructor(t3, e2, i2, s2, n2) {
-        this._firestore = t3, this._userDataWriter = e2, this._key = i2, this._document = s2, this._converter = n2;
-    }
-    get id() {
-        return this._key.path.lastSegment();
-    }
-    get ref() {
-        return new DocumentReference(this._firestore, this._converter, this._key);
-    }
-    exists() {
-        return null !== this._document;
-    }
-    data() {
-        if (this._document) {
-            if (this._converter) {
-                const t3 = new QueryDocumentSnapshot$1(this._firestore, this._userDataWriter, this._key, this._document, null);
-                return this._converter.fromFirestore(t3);
-            }
-            return this._userDataWriter.convertValue(this._document.data.value);
-        }
-    }
-    get(t3) {
-        if (this._document) {
-            const e2 = this._document.data.field(hw("DocumentSnapshot.get", t3));
-            if (null !== e2)
-                return this._userDataWriter.convertValue(e2);
-        }
-    }
-}
-class QueryDocumentSnapshot$1 extends DocumentSnapshot$1 {
-    data() {
-        return super.data();
-    }
-}
-
-function hw(t3, e2) {
-    return "string" == typeof e2 ? function(t4, e3, i2) {
-        if (e3.search(aw) >= 0)
-            throw lw(`Invalid field path (${e3}). Paths must not contain '~', '*', '/', '[', or ']'`, t4, false, void 0, i2);
-        try {
-            return new FieldPath(...e3.split("."))._internalPath;
-        } catch (s2) {
-            throw lw(`Invalid field path (${e3}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, t4, false, void 0, i2);
-        }
-    }(t3, e2) : e2 instanceof FieldPath ? e2._internalPath : e2._delegate._internalPath;
-}
-class AbstractUserDataWriter {
-    convertValue(t3, e2 = "none") {
-        switch (vv(t3)) {
-            case 0:
-                return null;
-            case 1:
-                return t3.booleanValue;
-            case 2:
-                return dv(t3.integerValue || t3.doubleValue);
-            case 3:
-                return this.convertTimestamp(t3.timestampValue);
-            case 4:
-                return this.convertServerTimestamp(t3, e2);
-            case 5:
-                return t3.stringValue;
-            case 6:
-                return this.convertBytes(fv(t3.bytesValue));
-            case 7:
-                return this.convertReference(t3.referenceValue);
-            case 8:
-                return this.convertGeoPoint(t3.geoPointValue);
-            case 9:
-                return this.convertArray(t3.arrayValue, e2);
-            case 10:
-                return this.convertObject(t3.mapValue, e2);
-            default:
-                throw Ky();
-        }
-    }
-    convertObject(t3, e2) {
-        return this.convertObjectMap(t3.fields, e2);
-    }
-    convertObjectMap(t3, e2 = "none") {
-        const i2 = {};
-        return hv(t3, (t4, s2) => {
-            i2[t4] = this.convertValue(s2, e2);
-        }), i2;
-    }
-    convertGeoPoint(t3) {
-        return new GeoPoint(dv(t3.latitude), dv(t3.longitude));
-    }
-    convertArray(t3, e2) {
-        return (t3.values || []).map((t4) => this.convertValue(t4, e2));
-    }
-    convertServerTimestamp(t3, e2) {
-        switch (e2) {
-            case "previous":
-                const i2 = mv(t3);
-                return null == i2 ? null : this.convertValue(i2, e2);
-            case "estimate":
-                return this.convertTimestamp(gv(t3));
-            default:
-                return null;
-        }
-    }
-    convertTimestamp(t3) {
-        const e2 = uv(t3);
-        return new Timestamp(e2.seconds, e2.nanos);
-    }
-    convertDocumentKey(t3, e2) {
-        const i2 = ResourcePath.fromString(t3);
-        Gy(r_(i2));
-        const s2 = new DatabaseId(i2.get(1), i2.get(3)),
-            n2 = new DocumentKey(i2.popFirst(5));
-        return s2.isEqual(e2) || Hy(`Document ${n2} contains a document reference within a different database (${s2.projectId}/${s2.database}) which is not supported. It will be treated as a reference in the current database (${e2.projectId}/${e2.database}) instead.`), n2;
-    }
-}
-class SnapshotMetadata {
-    constructor(t3, e2) {
-        this.hasPendingWrites = t3, this.fromCache = e2;
-    }
-    isEqual(t3) {
-        return this.hasPendingWrites === t3.hasPendingWrites && this.fromCache === t3.fromCache;
-    }
-}
-class DocumentSnapshot extends DocumentSnapshot$1 {
-    constructor(t3, e2, i2, s2, n2, r2) {
-        super(t3, e2, i2, s2, r2), this._firestore = t3, this._firestoreImpl = t3, this.metadata = n2;
-    }
-    exists() {
-        return super.exists();
-    }
-    data(t3 = {}) {
-        if (this._document) {
-            if (this._converter) {
-                const e2 = new QueryDocumentSnapshot(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null);
-                return this._converter.fromFirestore(e2, t3);
-            }
-            return this._userDataWriter.convertValue(this._document.data.value, t3.serverTimestamps);
-        }
-    }
-    get(t3, e2 = {}) {
-        if (this._document) {
-            const i2 = this._document.data.field(hw("DocumentSnapshot.get", t3));
-            if (null !== i2)
-                return this._userDataWriter.convertValue(i2, e2.serverTimestamps);
-        }
-    }
-}
-class QueryDocumentSnapshot extends DocumentSnapshot {
-    data(t3 = {}) {
-        return super.data(t3);
-    }
-}
-
-function cw(t3) {
-    t3 = nw(t3, DocumentReference);
-    const e2 = nw(t3.firestore, Firestore);
-    return tw(function(t4) {
-        return t4._firestoreClient || ow(t4), t4._firestoreClient.verifyNotTerminated(), t4._firestoreClient;
-    }(e2), t3._key).then((i2) => function(t4, e3, i3) {
-        const s2 = i3.docs.get(e3._key),
-            n2 = new __PRIVATE_ExpUserDataWriter(t4);
-        return new DocumentSnapshot(t4, n2, e3._key, s2, new SnapshotMetadata(i3.hasPendingWrites, i3.fromCache), e3.converter);
-    }(e2, t3, i2));
-}
-class __PRIVATE_ExpUserDataWriter extends AbstractUserDataWriter {
-    constructor(t3) {
-        super(), this.firestore = t3;
-    }
-    convertBytes(t3) {
-        return new Bytes(t3);
-    }
-    convertReference(t3) {
-        const e2 = this.convertDocumentKey(t3, this.firestore._databaseId);
-        return new DocumentReference(this.firestore, null, e2);
-    }
-}! function(t3, e2 = true) {
-    ! function(t4) {
-        zy = t4;
-    }(uf), lf(new Component("firestore", (t4, {
-        instanceIdentifier: i2,
-        options: s2
-    }) => {
-        const n2 = t4.getProvider("app").getImmediate(),
-            r2 = new Firestore(new __PRIVATE_FirebaseAuthCredentialsProvider(t4.getProvider("auth-internal")), new __PRIVATE_FirebaseAppCheckTokenProvider(t4.getProvider("app-check-internal")), function(t5, e3) {
-                if (!Object.prototype.hasOwnProperty.apply(t5.options, ["projectId"]))
-                    throw new FirestoreError(Qy.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
-                return new DatabaseId(t5.options.projectId, e3);
-            }(n2, i2), n2);
-        return s2 = Object.assign({
-            useFetchStreams: e2
-        }, s2), r2._setSettings(s2), r2;
-    }, "PUBLIC").setMultipleInstances(true)), pf(Vy, "4.0.0", t3), pf(Vy, "4.0.0", "esm2017");
-}();
-
-function uw(t3, e2) {
-    var i2 = {};
-    for (var s2 in t3)
-        Object.prototype.hasOwnProperty.call(t3, s2) && e2.indexOf(s2) < 0 && (i2[s2] = t3[s2]);
-    if (null != t3 && "function" == typeof Object.getOwnPropertySymbols) {
-        var n2 = 0;
-        for (s2 = Object.getOwnPropertySymbols(t3); n2 < s2.length; n2++)
-            e2.indexOf(s2[n2]) < 0 && Object.prototype.propertyIsEnumerable.call(t3, s2[n2]) && (i2[s2[n2]] = t3[s2[n2]]);
-    }
-    return i2;
-}
-
-function dw() {
-    return {
-        "dependent-sdk-initialized-before-auth": "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK."
-    };
-}
-pf("firebase", "10.0.0", "app"), "function" == typeof SuppressedError && SuppressedError;
-const fw = dw,
-    pw = new ErrorFactory("auth", "Firebase", {
-        "dependent-sdk-initialized-before-auth": "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK."
-    }),
-    mw = new Logger("@firebase/auth");
-
-function gw(t3, ...e2) {
-    mw.logLevel <= Rd.ERROR && mw.error(`Auth (${uf}): ${t3}`, ...e2);
-}
-
-function yw(t3, ...e2) {
-    throw bw(t3, ...e2);
-}
-
-function vw(t3, ...e2) {
-    return bw(t3, ...e2);
-}
-
-function bw(t3, ...e2) {
-    if ("string" != typeof t3) {
-        const i2 = e2[0],
-            s2 = [...e2.slice(1)];
-        return s2[0] && (s2[0].appName = t3.name), t3._errorFactory.create(i2, ...s2);
-    }
-    return pw.create(t3, ...e2);
-}
-
-function _w(t3, e2, ...i2) {
-    if (!t3)
-        throw bw(e2, ...i2);
-}
-
-function ww(t3) {
-    const e2 = "INTERNAL ASSERTION FAILED: " + t3;
-    throw gw(e2), new Error(e2);
-}
-
-function xw(t3, e2) {
-    t3 || ww(e2);
-}
-
-function kw() {
-    var t3;
-    return "undefined" != typeof self && (null === (t3 = self.location) || void 0 === t3 ? void 0 : t3.href) || "";
-}
-
-function Tw() {
-    var t3;
-    return "undefined" != typeof self && (null === (t3 = self.location) || void 0 === t3 ? void 0 : t3.protocol) || null;
-}
-
-function Sw() {
-    return "undefined" == typeof navigator || !navigator || !("onLine" in navigator) || "boolean" != typeof navigator.onLine || "http:" !== Tw() && "https:" !== Tw() && ! function() {
-        const t3 = "object" == typeof chrome ? chrome.runtime : "object" == typeof browser ? browser.runtime : void 0;
-        return "object" == typeof t3 && void 0 !== t3.id;
-    }() && !("connection" in navigator) || navigator.onLine;
-}
-class Delay {
-    constructor(t3, e2) {
-        this.shortDelay = t3, this.longDelay = e2, xw(e2 > t3, "Short delay should be less than long delay!"), this.isMobile = "undefined" != typeof window && !!(window.cordova || window.phonegap || window.PhoneGap) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(kd()) || "object" == typeof navigator && "ReactNative" === navigator.product;
-    }
-    get() {
-        return Sw() ? this.isMobile ? this.longDelay : this.shortDelay : Math.min(5e3, this.shortDelay);
-    }
-}
-
-function Ew(t3, e2) {
-    xw(t3.emulator, "Emulator should always be set here");
-    const {
-        url: i2
-    } = t3.emulator;
-    return e2 ? `${i2}${e2.startsWith("/") ? e2.slice(1) : e2}` : i2;
-}
-class FetchProvider {
-    static initialize(t3, e2, i2) {
-        this.fetchImpl = t3, e2 && (this.headersImpl = e2), i2 && (this.responseImpl = i2);
-    }
-    static fetch() {
-        return this.fetchImpl ? this.fetchImpl : "undefined" != typeof self && "fetch" in self ? self.fetch : void ww("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
-    }
-    static headers() {
-        return this.headersImpl ? this.headersImpl : "undefined" != typeof self && "Headers" in self ? self.Headers : void ww("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
-    }
-    static response() {
-        return this.responseImpl ? this.responseImpl : "undefined" != typeof self && "Response" in self ? self.Response : void ww("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
-    }
-}
-const Cw = {
-        CREDENTIAL_MISMATCH: "custom-token-mismatch",
-        MISSING_CUSTOM_TOKEN: "internal-error",
-        INVALID_IDENTIFIER: "invalid-email",
-        MISSING_CONTINUE_URI: "internal-error",
-        INVALID_PASSWORD: "wrong-password",
-        MISSING_PASSWORD: "missing-password",
-        EMAIL_EXISTS: "email-already-in-use",
-        PASSWORD_LOGIN_DISABLED: "operation-not-allowed",
-        INVALID_IDP_RESPONSE: "invalid-credential",
-        INVALID_PENDING_TOKEN: "invalid-credential",
-        FEDERATED_USER_ID_ALREADY_LINKED: "credential-already-in-use",
-        MISSING_REQ_TYPE: "internal-error",
-        EMAIL_NOT_FOUND: "user-not-found",
-        RESET_PASSWORD_EXCEED_LIMIT: "too-many-requests",
-        EXPIRED_OOB_CODE: "expired-action-code",
-        INVALID_OOB_CODE: "invalid-action-code",
-        MISSING_OOB_CODE: "internal-error",
-        CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "requires-recent-login",
-        INVALID_ID_TOKEN: "invalid-user-token",
-        TOKEN_EXPIRED: "user-token-expired",
-        USER_NOT_FOUND: "user-token-expired",
-        TOO_MANY_ATTEMPTS_TRY_LATER: "too-many-requests",
-        INVALID_CODE: "invalid-verification-code",
-        INVALID_SESSION_INFO: "invalid-verification-id",
-        INVALID_TEMPORARY_PROOF: "invalid-credential",
-        MISSING_SESSION_INFO: "missing-verification-id",
-        SESSION_EXPIRED: "code-expired",
-        MISSING_ANDROID_PACKAGE_NAME: "missing-android-pkg-name",
-        UNAUTHORIZED_DOMAIN: "unauthorized-continue-uri",
-        INVALID_OAUTH_CLIENT_ID: "invalid-oauth-client-id",
-        ADMIN_ONLY_OPERATION: "admin-restricted-operation",
-        INVALID_MFA_PENDING_CREDENTIAL: "invalid-multi-factor-session",
-        MFA_ENROLLMENT_NOT_FOUND: "multi-factor-info-not-found",
-        MISSING_MFA_ENROLLMENT_ID: "missing-multi-factor-info",
-        MISSING_MFA_PENDING_CREDENTIAL: "missing-multi-factor-session",
-        SECOND_FACTOR_EXISTS: "second-factor-already-in-use",
-        SECOND_FACTOR_LIMIT_EXCEEDED: "maximum-second-factor-count-exceeded",
-        BLOCKING_FUNCTION_ERROR_RESPONSE: "internal-error",
-        RECAPTCHA_NOT_ENABLED: "recaptcha-not-enabled",
-        MISSING_RECAPTCHA_TOKEN: "missing-recaptcha-token",
-        INVALID_RECAPTCHA_TOKEN: "invalid-recaptcha-token",
-        INVALID_RECAPTCHA_ACTION: "invalid-recaptcha-action",
-        MISSING_CLIENT_TYPE: "missing-client-type",
-        MISSING_RECAPTCHA_VERSION: "missing-recaptcha-version",
-        INVALID_RECAPTCHA_VERSION: "invalid-recaptcha-version",
-        INVALID_REQ_TYPE: "invalid-req-type"
-    },
-    Iw = new Delay(3e4, 6e4);
-
-function Mw(t3, e2) {
-    return t3.tenantId && !e2.tenantId ? Object.assign(Object.assign({}, e2), {
-        tenantId: t3.tenantId
-    }) : e2;
-}
-async function Pw(t3, e2, i2, s2, n2 = {}) {
-    return Rw(t3, n2, async () => {
-        let n3 = {},
-            r2 = {};
-        s2 && ("GET" === e2 ? r2 = s2 : n3 = {
-            body: JSON.stringify(s2)
-        });
-        const o2 = Cd(Object.assign({
-                key: t3.config.apiKey
-            }, r2)).slice(1),
-            a2 = await t3._getAdditionalHeaders();
-        return a2["Content-Type"] = "application/json", t3.languageCode && (a2["X-Firebase-Locale"] = t3.languageCode), FetchProvider.fetch()(Aw(t3, t3.config.apiHost, i2, o2), Object.assign({
-            method: e2,
-            headers: a2,
-            referrerPolicy: "no-referrer"
-        }, n3));
-    });
-}
-async function Rw(t3, e2, i2) {
-    t3._canInitEmulator = false;
-    const s2 = Object.assign(Object.assign({}, Cw), e2);
-    try {
-        const e3 = new NetworkTimeout(t3),
-            n2 = await Promise.race([i2(), e3.promise]);
-        e3.clearNetworkTimeout();
-        const r2 = await n2.json();
-        if ("needConfirmation" in r2)
-            throw Dw(t3, "account-exists-with-different-credential", r2);
-        if (n2.ok && !("errorMessage" in r2))
-            return r2;
-        {
-            const e4 = n2.ok ? r2.errorMessage : r2.error.message,
-                [i3, o2] = e4.split(" : ");
-            if ("FEDERATED_USER_ID_ALREADY_LINKED" === i3)
-                throw Dw(t3, "credential-already-in-use", r2);
-            if ("EMAIL_EXISTS" === i3)
-                throw Dw(t3, "email-already-in-use", r2);
-            if ("USER_DISABLED" === i3)
-                throw Dw(t3, "user-disabled", r2);
-            const a2 = s2[i3] || i3.toLowerCase().replace(/[_\s]+/g, "-");
-            if (o2)
-                throw function(t4, e5, i4) {
-                    const s3 = Object.assign(Object.assign({}, fw()), {
-                        [e5]: i4
-                    });
-                    return new ErrorFactory("auth", "Firebase", s3).create(e5, {
-                        appName: t4.name
-                    });
-                }(t3, a2, o2);
-            yw(t3, a2);
-        }
-    } catch (e3) {
-        if (e3 instanceof FirebaseError)
-            throw e3;
-        yw(t3, "network-request-failed", {
-            message: String(e3)
-        });
-    }
-}
-
-function Aw(t3, e2, i2, s2) {
-    const n2 = `${e2}${i2}?${s2}`;
-    return t3.config.emulator ? Ew(t3.config, n2) : `${t3.config.apiScheme}://${n2}`;
-}
-class NetworkTimeout {
-    constructor(t3) {
-        this.auth = t3, this.timer = null, this.promise = new Promise((t4, e2) => {
-            this.timer = setTimeout(() => e2(vw(this.auth, "network-request-failed")), Iw.get());
-        });
-    }
-    clearNetworkTimeout() {
-        clearTimeout(this.timer);
-    }
-}
-
-function Dw(t3, e2, i2) {
-    const s2 = {
-        appName: t3.name
-    };
-    i2.email && (s2.email = i2.email), i2.phoneNumber && (s2.phoneNumber = i2.phoneNumber);
-    const n2 = vw(t3, e2, s2);
-    return n2.customData._tokenResponse = i2, n2;
-}
-
-function Lw(t3) {
-    if (t3)
-        try {
-            const e2 = new Date(Number(t3));
-            if (!isNaN(e2.getTime()))
-                return e2.toUTCString();
-        } catch (t4) {}
-}
-
-function Ow(t3) {
-    return 1e3 * Number(t3);
-}
-
-function Fw(t3) {
-    const [e2, i2, s2] = t3.split(".");
-    if (void 0 === e2 || void 0 === i2 || void 0 === s2)
-        return gw("JWT malformed, contained fewer than 3 sections"), null;
-    try {
-        const t4 = md(i2);
-        return t4 ? JSON.parse(t4) : (gw("Failed to decode base64 JWT payload"), null);
-    } catch (t4) {
-        return gw("Caught error parsing JWT payload as JSON", null == t4 ? void 0 : t4.toString()), null;
-    }
-}
-async function Nw(t3, e2, i2 = false) {
-    if (i2)
-        return e2;
-    try {
-        return await e2;
-    } catch (e3) {
-        throw e3 instanceof FirebaseError && function({
-            code: t4
-        }) {
-            return "auth/user-disabled" === t4 || "auth/user-token-expired" === t4;
-        }(e3) && t3.auth.currentUser === t3 && await t3.auth.signOut(), e3;
-    }
-}
-class ProactiveRefresh {
-    constructor(t3) {
-        this.user = t3, this.isRunning = false, this.timerId = null, this.errorBackoff = 3e4;
-    }
-    _start() {
-        this.isRunning || (this.isRunning = true, this.schedule());
-    }
-    _stop() {
-        this.isRunning && (this.isRunning = false, null !== this.timerId && clearTimeout(this.timerId));
-    }
-    getInterval(t3) {
-        var e2;
-        if (t3) {
-            const t4 = this.errorBackoff;
-            return this.errorBackoff = Math.min(2 * this.errorBackoff, 96e4), t4;
-        } {
-            this.errorBackoff = 3e4;
-            const t4 = (null !== (e2 = this.user.stsTokenManager.expirationTime) && void 0 !== e2 ? e2 : 0) - Date.now() - 3e5;
-            return Math.max(0, t4);
-        }
-    }
-    schedule(t3 = false) {
-        if (!this.isRunning)
-            return;
-        const e2 = this.getInterval(t3);
-        this.timerId = setTimeout(async () => {
-            await this.iteration();
-        }, e2);
-    }
-    async iteration() {
-        try {
-            await this.user.getIdToken(true);
-        } catch (t3) {
-            return void("auth/network-request-failed" === (null == t3 ? void 0 : t3.code) && this.schedule(true));
-        }
-        this.schedule();
-    }
-}
-class UserMetadata {
-    constructor(t3, e2) {
-        this.createdAt = t3, this.lastLoginAt = e2, this._initializeTime();
-    }
-    _initializeTime() {
-        this.lastSignInTime = Lw(this.lastLoginAt), this.creationTime = Lw(this.createdAt);
-    }
-    _copy(t3) {
-        this.createdAt = t3.createdAt, this.lastLoginAt = t3.lastLoginAt, this._initializeTime();
-    }
-    toJSON() {
-        return {
-            createdAt: this.createdAt,
-            lastLoginAt: this.lastLoginAt
-        };
-    }
-}
-async function $w(t3) {
-    var e2;
-    const i2 = t3.auth,
-        s2 = await t3.getIdToken(),
-        n2 = await Nw(t3, async function(t4, e3) {
-            return Pw(t4, "POST", "/v1/accounts:lookup", e3);
-        }(i2, {
-            idToken: s2
-        }));
-    _w(null == n2 ? void 0 : n2.users.length, i2, "internal-error");
-    const r2 = n2.users[0];
-    t3._notifyReloadListener(r2);
-    const o2 = (null === (e2 = r2.providerUserInfo) || void 0 === e2 ? void 0 : e2.length) ? r2.providerUserInfo.map((t4) => {
-        var {
-            providerId: e3
-        } = t4, i3 = uw(t4, ["providerId"]);
-        return {
-            providerId: e3,
-            uid: i3.rawId || "",
-            displayName: i3.displayName || null,
-            email: i3.email || null,
-            phoneNumber: i3.phoneNumber || null,
-            photoURL: i3.photoUrl || null
-        };
-    }) : [];
-    const a2 = function(t4, e3) {
-            const i3 = t4.filter((t5) => !e3.some((e4) => e4.providerId === t5.providerId));
-            return [...i3, ...e3];
-        }(t3.providerData, o2),
-        l2 = t3.isAnonymous,
-        h2 = !(t3.email && r2.passwordHash || (null == a2 ? void 0 : a2.length)),
-        c2 = !!l2 && h2,
-        u2 = {
-            uid: r2.localId,
-            displayName: r2.displayName || null,
-            photoURL: r2.photoUrl || null,
-            email: r2.email || null,
-            emailVerified: r2.emailVerified || false,
-            phoneNumber: r2.phoneNumber || null,
-            tenantId: r2.tenantId || null,
-            providerData: a2,
-            metadata: new UserMetadata(r2.createdAt, r2.lastLoginAt),
-            isAnonymous: c2
-        };
-    Object.assign(t3, u2);
-}
-class StsTokenManager {
-    constructor() {
-        this.refreshToken = null, this.accessToken = null, this.expirationTime = null;
-    }
-    get isExpired() {
-        return !this.expirationTime || Date.now() > this.expirationTime - 3e4;
-    }
-    updateFromServerResponse(t3) {
-        _w(t3.idToken, "internal-error"), _w(void 0 !== t3.idToken, "internal-error"), _w(void 0 !== t3.refreshToken, "internal-error");
-        const e2 = "expiresIn" in t3 && void 0 !== t3.expiresIn ? Number(t3.expiresIn) : function(t4) {
-            const e3 = Fw(t4);
-            return _w(e3, "internal-error"), _w(void 0 !== e3.exp, "internal-error"), _w(void 0 !== e3.iat, "internal-error"), Number(e3.exp) - Number(e3.iat);
-        }(t3.idToken);
-        this.updateTokensAndExpiration(t3.idToken, t3.refreshToken, e2);
-    }
-    async getToken(t3, e2 = false) {
-        return _w(!this.accessToken || this.refreshToken, t3, "user-token-expired"), e2 || !this.accessToken || this.isExpired ? this.refreshToken ? (await this.refresh(t3, this.refreshToken), this.accessToken) : null : this.accessToken;
-    }
-    clearRefreshToken() {
-        this.refreshToken = null;
-    }
-    async refresh(t3, e2) {
-        const {
-            accessToken: i2,
-            refreshToken: s2,
-            expiresIn: n2
-        } = await async function(t4, e3) {
-            const i3 = await Rw(t4, {}, async () => {
-                const i4 = Cd({
-                        grant_type: "refresh_token",
-                        refresh_token: e3
-                    }).slice(1),
-                    {
-                        tokenApiHost: s3,
-                        apiKey: n3
-                    } = t4.config,
-                    r2 = Aw(t4, s3, "/v1/token", `key=${n3}`),
-                    o2 = await t4._getAdditionalHeaders();
-                return o2["Content-Type"] = "application/x-www-form-urlencoded", FetchProvider.fetch()(r2, {
-                    method: "POST",
-                    headers: o2,
-                    body: i4
-                });
-            });
-            return {
-                accessToken: i3.access_token,
-                expiresIn: i3.expires_in,
-                refreshToken: i3.refresh_token
-            };
-        }(t3, e2);
-        this.updateTokensAndExpiration(i2, s2, Number(n2));
-    }
-    updateTokensAndExpiration(t3, e2, i2) {
-        this.refreshToken = e2 || null, this.accessToken = t3 || null, this.expirationTime = Date.now() + 1e3 * i2;
-    }
-    static fromJSON(t3, e2) {
-        const {
-            refreshToken: i2,
-            accessToken: s2,
-            expirationTime: n2
-        } = e2, r2 = new StsTokenManager();
-        return i2 && (_w("string" == typeof i2, "internal-error", {
-            appName: t3
-        }), r2.refreshToken = i2), s2 && (_w("string" == typeof s2, "internal-error", {
-            appName: t3
-        }), r2.accessToken = s2), n2 && (_w("number" == typeof n2, "internal-error", {
-            appName: t3
-        }), r2.expirationTime = n2), r2;
-    }
-    toJSON() {
-        return {
-            refreshToken: this.refreshToken,
-            accessToken: this.accessToken,
-            expirationTime: this.expirationTime
-        };
-    }
-    _assign(t3) {
-        this.accessToken = t3.accessToken, this.refreshToken = t3.refreshToken, this.expirationTime = t3.expirationTime;
-    }
-    _clone() {
-        return Object.assign(new StsTokenManager(), this.toJSON());
-    }
-    _performRefresh() {
-        return ww("not implemented");
-    }
-}
-
-function Vw(t3, e2) {
-    _w("string" == typeof t3 || void 0 === t3, "internal-error", {
-        appName: e2
-    });
-}
-class UserImpl {
-    constructor(t3) {
-        var {
-            uid: e2,
-            auth: i2,
-            stsTokenManager: s2
-        } = t3, n2 = uw(t3, ["uid", "auth", "stsTokenManager"]);
-        this.providerId = "firebase", this.proactiveRefresh = new ProactiveRefresh(this), this.reloadUserInfo = null, this.reloadListener = null, this.uid = e2, this.auth = i2, this.stsTokenManager = s2, this.accessToken = s2.accessToken, this.displayName = n2.displayName || null, this.email = n2.email || null, this.emailVerified = n2.emailVerified || false, this.phoneNumber = n2.phoneNumber || null, this.photoURL = n2.photoURL || null, this.isAnonymous = n2.isAnonymous || false, this.tenantId = n2.tenantId || null, this.providerData = n2.providerData ? [...n2.providerData] : [], this.metadata = new UserMetadata(n2.createdAt || void 0, n2.lastLoginAt || void 0);
-    }
-    async getIdToken(t3) {
-        const e2 = await Nw(this, this.stsTokenManager.getToken(this.auth, t3));
-        return _w(e2, this.auth, "internal-error"), this.accessToken !== e2 && (this.accessToken = e2, await this.auth._persistUserIfCurrent(this), this.auth._notifyListenersIfCurrent(this)), e2;
-    }
-    getIdTokenResult(t3) {
-        return async function(t4, e2 = false) {
-            const i2 = Md(t4),
-                s2 = await i2.getIdToken(e2),
-                n2 = Fw(s2);
-            _w(n2 && n2.exp && n2.auth_time && n2.iat, i2.auth, "internal-error");
-            const r2 = "object" == typeof n2.firebase ? n2.firebase : void 0,
-                o2 = null == r2 ? void 0 : r2.sign_in_provider;
-            return {
-                claims: n2,
-                token: s2,
-                authTime: Lw(Ow(n2.auth_time)),
-                issuedAtTime: Lw(Ow(n2.iat)),
-                expirationTime: Lw(Ow(n2.exp)),
-                signInProvider: o2 || null,
-                signInSecondFactor: (null == r2 ? void 0 : r2.sign_in_second_factor) || null
-            };
-        }(this, t3);
-    }
-    reload() {
-        return async function(t3) {
-            const e2 = Md(t3);
-            await $w(e2), await e2.auth._persistUserIfCurrent(e2), e2.auth._notifyListenersIfCurrent(e2);
-        }(this);
-    }
-    _assign(t3) {
-        this !== t3 && (_w(this.uid === t3.uid, this.auth, "internal-error"), this.displayName = t3.displayName, this.photoURL = t3.photoURL, this.email = t3.email, this.emailVerified = t3.emailVerified, this.phoneNumber = t3.phoneNumber, this.isAnonymous = t3.isAnonymous, this.tenantId = t3.tenantId, this.providerData = t3.providerData.map((t4) => Object.assign({}, t4)), this.metadata._copy(t3.metadata), this.stsTokenManager._assign(t3.stsTokenManager));
-    }
-    _clone(t3) {
-        const e2 = new UserImpl(Object.assign(Object.assign({}, this), {
-            auth: t3,
-            stsTokenManager: this.stsTokenManager._clone()
-        }));
-        return e2.metadata._copy(this.metadata), e2;
-    }
-    _onReload(t3) {
-        _w(!this.reloadListener, this.auth, "internal-error"), this.reloadListener = t3, this.reloadUserInfo && (this._notifyReloadListener(this.reloadUserInfo), this.reloadUserInfo = null);
-    }
-    _notifyReloadListener(t3) {
-        this.reloadListener ? this.reloadListener(t3) : this.reloadUserInfo = t3;
-    }
-    _startProactiveRefresh() {
-        this.proactiveRefresh._start();
-    }
-    _stopProactiveRefresh() {
-        this.proactiveRefresh._stop();
-    }
-    async _updateTokensIfNecessary(t3, e2 = false) {
-        let i2 = false;
-        t3.idToken && t3.idToken !== this.stsTokenManager.accessToken && (this.stsTokenManager.updateFromServerResponse(t3), i2 = true), e2 && await $w(this), await this.auth._persistUserIfCurrent(this), i2 && this.auth._notifyListenersIfCurrent(this);
-    }
-    async delete() {
-        const t3 = await this.getIdToken();
-        return await Nw(this, async function(t4, e2) {
-            return Pw(t4, "POST", "/v1/accounts:delete", e2);
-        }(this.auth, {
-            idToken: t3
-        })), this.stsTokenManager.clearRefreshToken(), this.auth.signOut();
-    }
-    toJSON() {
-        return Object.assign(Object.assign({
-            uid: this.uid,
-            email: this.email || void 0,
-            emailVerified: this.emailVerified,
-            displayName: this.displayName || void 0,
-            isAnonymous: this.isAnonymous,
-            photoURL: this.photoURL || void 0,
-            phoneNumber: this.phoneNumber || void 0,
-            tenantId: this.tenantId || void 0,
-            providerData: this.providerData.map((t3) => Object.assign({}, t3)),
-            stsTokenManager: this.stsTokenManager.toJSON(),
-            _redirectEventId: this._redirectEventId
-        }, this.metadata.toJSON()), {
-            apiKey: this.auth.config.apiKey,
-            appName: this.auth.name
-        });
-    }
-    get refreshToken() {
-        return this.stsTokenManager.refreshToken || "";
-    }
-    static _fromJSON(t3, e2) {
-        var i2, s2, n2, r2, o2, a2, l2, h2;
-        const c2 = null !== (i2 = e2.displayName) && void 0 !== i2 ? i2 : void 0,
-            u2 = null !== (s2 = e2.email) && void 0 !== s2 ? s2 : void 0,
-            d2 = null !== (n2 = e2.phoneNumber) && void 0 !== n2 ? n2 : void 0,
-            f2 = null !== (r2 = e2.photoURL) && void 0 !== r2 ? r2 : void 0,
-            p2 = null !== (o2 = e2.tenantId) && void 0 !== o2 ? o2 : void 0,
-            m2 = null !== (a2 = e2._redirectEventId) && void 0 !== a2 ? a2 : void 0,
-            g2 = null !== (l2 = e2.createdAt) && void 0 !== l2 ? l2 : void 0,
-            y2 = null !== (h2 = e2.lastLoginAt) && void 0 !== h2 ? h2 : void 0,
-            {
-                uid: v2,
-                emailVerified: b2,
-                isAnonymous: _2,
-                providerData: w2,
-                stsTokenManager: x2
-            } = e2;
-        _w(v2 && x2, t3, "internal-error");
-        const k2 = StsTokenManager.fromJSON(this.name, x2);
-        _w("string" == typeof v2, t3, "internal-error"), Vw(c2, t3.name), Vw(u2, t3.name), _w("boolean" == typeof b2, t3, "internal-error"), _w("boolean" == typeof _2, t3, "internal-error"), Vw(d2, t3.name), Vw(f2, t3.name), Vw(p2, t3.name), Vw(m2, t3.name), Vw(g2, t3.name), Vw(y2, t3.name);
-        const T2 = new UserImpl({
-            uid: v2,
-            auth: t3,
-            email: u2,
-            emailVerified: b2,
-            displayName: c2,
-            isAnonymous: _2,
-            photoURL: f2,
-            phoneNumber: d2,
-            tenantId: p2,
-            stsTokenManager: k2,
-            createdAt: g2,
-            lastLoginAt: y2
-        });
-        return w2 && Array.isArray(w2) && (T2.providerData = w2.map((t4) => Object.assign({}, t4))), m2 && (T2._redirectEventId = m2), T2;
-    }
-    static async _fromIdTokenResponse(t3, e2, i2 = false) {
-        const s2 = new StsTokenManager();
-        s2.updateFromServerResponse(e2);
-        const n2 = new UserImpl({
-            uid: e2.localId,
-            auth: t3,
-            stsTokenManager: s2,
-            isAnonymous: i2
-        });
-        return await $w(n2), n2;
-    }
-}
-const zw = /* @__PURE__ */ new Map();
-
-function Bw(t3) {
-    xw(t3 instanceof Function, "Expected a class definition");
-    let e2 = zw.get(t3);
-    return e2 ? (xw(e2 instanceof t3, "Instance stored in cache mismatched with class"), e2) : (e2 = new t3(), zw.set(t3, e2), e2);
-}
-class InMemoryPersistence {
-    constructor() {
-        this.type = "NONE", this.storage = {};
-    }
-    async _isAvailable() {
-        return true;
-    }
-    async _set(t3, e2) {
-        this.storage[t3] = e2;
-    }
-    async _get(t3) {
-        const e2 = this.storage[t3];
-        return void 0 === e2 ? null : e2;
-    }
-    async _remove(t3) {
-        delete this.storage[t3];
-    }
-    _addListener(t3, e2) {}
-    _removeListener(t3, e2) {}
-}
-InMemoryPersistence.type = "NONE";
-const Uw = InMemoryPersistence;
-
-function jw(t3, e2, i2) {
-    return `firebase:${t3}:${e2}:${i2}`;
-}
-class PersistenceUserManager {
-    constructor(t3, e2, i2) {
-        this.persistence = t3, this.auth = e2, this.userKey = i2;
-        const {
-            config: s2,
-            name: n2
-        } = this.auth;
-        this.fullUserKey = jw(this.userKey, s2.apiKey, n2), this.fullPersistenceKey = jw("persistence", s2.apiKey, n2), this.boundEventHandler = e2._onStorageEvent.bind(e2), this.persistence._addListener(this.fullUserKey, this.boundEventHandler);
-    }
-    setCurrentUser(t3) {
-        return this.persistence._set(this.fullUserKey, t3.toJSON());
-    }
-    async getCurrentUser() {
-        const t3 = await this.persistence._get(this.fullUserKey);
-        return t3 ? UserImpl._fromJSON(this.auth, t3) : null;
-    }
-    removeCurrentUser() {
-        return this.persistence._remove(this.fullUserKey);
-    }
-    savePersistenceForRedirect() {
-        return this.persistence._set(this.fullPersistenceKey, this.persistence.type);
-    }
-    async setPersistence(t3) {
-        if (this.persistence === t3)
-            return;
-        const e2 = await this.getCurrentUser();
-        return await this.removeCurrentUser(), this.persistence = t3, e2 ? this.setCurrentUser(e2) : void 0;
-    }
-    delete() {
-        this.persistence._removeListener(this.fullUserKey, this.boundEventHandler);
-    }
-    static async create(t3, e2, i2 = "authUser") {
-        if (!e2.length)
-            return new PersistenceUserManager(Bw(Uw), t3, i2);
-        const s2 = (await Promise.all(e2.map(async (t4) => {
-            if (await t4._isAvailable())
-                return t4;
-        }))).filter((t4) => t4);
-        let n2 = s2[0] || Bw(Uw);
-        const r2 = jw(i2, t3.config.apiKey, t3.name);
-        let o2 = null;
-        for (const i3 of e2)
-            try {
-                const e3 = await i3._get(r2);
-                if (e3) {
-                    const s3 = UserImpl._fromJSON(t3, e3);
-                    i3 !== n2 && (o2 = s3), n2 = i3;
-                    break;
-                }
-            } catch (t4) {}
-        const a2 = s2.filter((t4) => t4._shouldAllowMigration);
-        return n2._shouldAllowMigration && a2.length ? (n2 = a2[0], o2 && await n2._set(r2, o2.toJSON()), await Promise.all(e2.map(async (t4) => {
-            if (t4 !== n2)
-                try {
-                    await t4._remove(r2);
-                } catch (t5) {}
-        })), new PersistenceUserManager(n2, t3, i2)) : new PersistenceUserManager(n2, t3, i2);
-    }
-}
-
-function Hw(t3) {
-    const e2 = t3.toLowerCase();
-    if (e2.includes("opera/") || e2.includes("opr/") || e2.includes("opios/"))
-        return "Opera";
-    if (Gw(e2))
-        return "IEMobile";
-    if (e2.includes("msie") || e2.includes("trident/"))
-        return "IE";
-    if (e2.includes("edge/"))
-        return "Edge";
-    if (Ww(e2))
-        return "Firefox";
-    if (e2.includes("silk/"))
-        return "Silk";
-    if (Qw(e2))
-        return "Blackberry";
-    if (Xw(e2))
-        return "Webos";
-    if (qw(e2))
-        return "Safari";
-    if ((e2.includes("chrome/") || Kw(e2)) && !e2.includes("edge/"))
-        return "Chrome";
-    if (Yw(e2))
-        return "Android";
-    {
-        const e3 = /([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/,
-            i2 = t3.match(e3);
-        if (2 === (null == i2 ? void 0 : i2.length))
-            return i2[1];
-    }
-    return "Other";
-}
-
-function Ww(t3 = kd()) {
-    return /firefox\//i.test(t3);
-}
-
-function qw(t3 = kd()) {
-    const e2 = t3.toLowerCase();
-    return e2.includes("safari/") && !e2.includes("chrome/") && !e2.includes("crios/") && !e2.includes("android");
-}
-
-function Kw(t3 = kd()) {
-    return /crios\//i.test(t3);
-}
-
-function Gw(t3 = kd()) {
-    return /iemobile/i.test(t3);
-}
-
-function Yw(t3 = kd()) {
-    return /android/i.test(t3);
-}
-
-function Qw(t3 = kd()) {
-    return /blackberry/i.test(t3);
-}
-
-function Xw(t3 = kd()) {
-    return /webos/i.test(t3);
-}
-
-function Jw(t3 = kd()) {
-    return /iphone|ipad|ipod/i.test(t3) || /macintosh/i.test(t3) && /mobile/i.test(t3);
-}
-
-function Zw() {
-    return function() {
-        const t3 = kd();
-        return t3.indexOf("MSIE ") >= 0 || t3.indexOf("Trident/") >= 0;
-    }() && 10 === document.documentMode;
-}
-
-function tx(t3 = kd()) {
-    return Jw(t3) || Yw(t3) || Xw(t3) || Qw(t3) || /windows phone/i.test(t3) || Gw(t3);
-}
-
-function ex(t3, e2 = []) {
-    let i2;
-    switch (t3) {
-        case "Browser":
-            i2 = Hw(kd());
-            break;
-        case "Worker":
-            i2 = `${Hw(kd())}-${t3}`;
-            break;
-        default:
-            i2 = t3;
-    }
-    const s2 = e2.length ? e2.join(",") : "FirebaseCore-web";
-    return `${i2}/JsCore/${uf}/${s2}`;
-}
-async function ix(t3, e2) {
-    return Pw(t3, "GET", "/v2/recaptchaConfig", Mw(t3, e2));
-}
-
-function sx(t3) {
-    return void 0 !== t3 && void 0 !== t3.enterprise;
-}
-class RecaptchaConfig {
-    constructor(t3) {
-        if (this.siteKey = "", this.emailPasswordEnabled = false, void 0 === t3.recaptchaKey)
-            throw new Error("recaptchaKey undefined");
-        this.siteKey = t3.recaptchaKey.split("/")[3], this.emailPasswordEnabled = t3.recaptchaEnforcementState.some((t4) => "EMAIL_PASSWORD_PROVIDER" === t4.provider && "OFF" !== t4.enforcementState);
-    }
-}
-
-function nx(t3) {
-    return new Promise((e2, i2) => {
-        const s2 = document.createElement("script");
-        var n2, r2;
-        s2.setAttribute("src", t3), s2.onload = e2, s2.onerror = (t4) => {
-            const e3 = vw("internal-error");
-            e3.customData = t4, i2(e3);
-        }, s2.type = "text/javascript", s2.charset = "UTF-8", (null !== (r2 = null === (n2 = document.getElementsByTagName("head")) || void 0 === n2 ? void 0 : n2[0]) && void 0 !== r2 ? r2 : document).appendChild(s2);
-    });
-}
-class RecaptchaEnterpriseVerifier {
-    constructor(t3) {
-        this.type = "recaptcha-enterprise", this.auth = rx(t3);
-    }
-    async verify(t3 = "verify", e2 = false) {
-        function i2(e3, i3, s2) {
-            const n2 = window.grecaptcha;
-            sx(n2) ? n2.enterprise.ready(() => {
-                n2.enterprise.execute(e3, {
-                    action: t3
-                }).then((t4) => {
-                    i3(t4);
-                }).catch(() => {
-                    i3("NO_RECAPTCHA");
-                });
-            }) : s2(Error("No reCAPTCHA enterprise script loaded."));
-        }
-        return new Promise((t4, s2) => {
-            (async function(t5) {
-                if (!e2) {
-                    if (null == t5.tenantId && null != t5._agentRecaptchaConfig)
-                        return t5._agentRecaptchaConfig.siteKey;
-                    if (null != t5.tenantId && void 0 !== t5._tenantRecaptchaConfigs[t5.tenantId])
-                        return t5._tenantRecaptchaConfigs[t5.tenantId].siteKey;
-                }
-                return new Promise(async (e3, i3) => {
-                    ix(t5, {
-                        clientType: "CLIENT_TYPE_WEB",
-                        version: "RECAPTCHA_ENTERPRISE"
-                    }).then((s3) => {
-                        if (void 0 !== s3.recaptchaKey) {
-                            const i4 = new RecaptchaConfig(s3);
-                            return null == t5.tenantId ? t5._agentRecaptchaConfig = i4 : t5._tenantRecaptchaConfigs[t5.tenantId] = i4, e3(i4.siteKey);
-                        }
-                        i3(new Error("recaptcha Enterprise site key undefined"));
-                    }).catch((t6) => {
-                        i3(t6);
-                    });
-                });
-            })(this.auth).then((n2) => {
-                if (!e2 && sx(window.grecaptcha))
-                    i2(n2, t4, s2);
-                else {
-                    if ("undefined" == typeof window)
-                        return void s2(new Error("RecaptchaVerifier is only supported in browser"));
-                    nx("https://www.google.com/recaptcha/enterprise.js?render=" + n2).then(() => {
-                        i2(n2, t4, s2);
-                    }).catch((t5) => {
-                        s2(t5);
-                    });
-                }
-            }).catch((t5) => {
-                s2(t5);
-            });
-        });
-    }
-}
-class AuthMiddlewareQueue {
-    constructor(t3) {
-        this.auth = t3, this.queue = [];
-    }
-    pushCallback(t3, e2) {
-        const i2 = (e3) => new Promise((i3, s3) => {
-            try {
-                i3(t3(e3));
-            } catch (t4) {
-                s3(t4);
-            }
-        });
-        i2.onAbort = e2, this.queue.push(i2);
-        const s2 = this.queue.length - 1;
-        return () => {
-            this.queue[s2] = () => Promise.resolve();
-        };
-    }
-    async runMiddleware(t3) {
-        if (this.auth.currentUser === t3)
-            return;
-        const e2 = [];
-        try {
-            for (const i2 of this.queue)
-                await i2(t3), i2.onAbort && e2.push(i2.onAbort);
-        } catch (t4) {
-            e2.reverse();
-            for (const t5 of e2)
-                try {
-                    t5();
-                } catch (t6) {}
-            throw this.auth._errorFactory.create("login-blocked", {
-                originalMessage: null == t4 ? void 0 : t4.message
-            });
-        }
-    }
-}
-class AuthImpl {
-    constructor(t3, e2, i2, s2) {
-        this.app = t3, this.heartbeatServiceProvider = e2, this.appCheckServiceProvider = i2, this.config = s2, this.currentUser = null, this.emulatorConfig = null, this.operations = Promise.resolve(), this.authStateSubscription = new Subscription(this), this.idTokenSubscription = new Subscription(this), this.beforeStateQueue = new AuthMiddlewareQueue(this), this.redirectUser = null, this.isProactiveRefreshEnabled = false, this._canInitEmulator = true, this._isInitialized = false, this._deleted = false, this._initializationPromise = null, this._popupRedirectResolver = null, this._errorFactory = pw, this._agentRecaptchaConfig = null, this._tenantRecaptchaConfigs = {}, this.lastNotifiedUid = void 0, this.languageCode = null, this.tenantId = null, this.settings = {
-            appVerificationDisabledForTesting: false
-        }, this.frameworks = [], this.name = t3.name, this.clientVersion = s2.sdkClientVersion;
-    }
-    _initializeWithPersistence(t3, e2) {
-        return e2 && (this._popupRedirectResolver = Bw(e2)), this._initializationPromise = this.queue(async () => {
-            var i2, s2;
-            if (!this._deleted && (this.persistenceManager = await PersistenceUserManager.create(this, t3), !this._deleted)) {
-                if (null === (i2 = this._popupRedirectResolver) || void 0 === i2 ? void 0 : i2._shouldInitProactively)
-                    try {
-                        await this._popupRedirectResolver._initialize(this);
-                    } catch (t4) {}
-                await this.initializeCurrentUser(e2), this.lastNotifiedUid = (null === (s2 = this.currentUser) || void 0 === s2 ? void 0 : s2.uid) || null, this._deleted || (this._isInitialized = true);
-            }
-        }), this._initializationPromise;
-    }
-    async _onStorageEvent() {
-        if (this._deleted)
-            return;
-        const t3 = await this.assertedPersistence.getCurrentUser();
-        return this.currentUser || t3 ? this.currentUser && t3 && this.currentUser.uid === t3.uid ? (this._currentUser._assign(t3), void await this.currentUser.getIdToken()) : void await this._updateCurrentUser(t3, true) : void 0;
-    }
-    async initializeCurrentUser(t3) {
-        var e2;
-        const i2 = await this.assertedPersistence.getCurrentUser();
-        let s2 = i2,
-            n2 = false;
-        if (t3 && this.config.authDomain) {
-            await this.getOrInitRedirectPersistenceManager();
-            const i3 = null === (e2 = this.redirectUser) || void 0 === e2 ? void 0 : e2._redirectEventId,
-                r2 = null == s2 ? void 0 : s2._redirectEventId,
-                o2 = await this.tryRedirectSignIn(t3);
-            i3 && i3 !== r2 || !(null == o2 ? void 0 : o2.user) || (s2 = o2.user, n2 = true);
-        }
-        if (!s2)
-            return this.directlySetCurrentUser(null);
-        if (!s2._redirectEventId) {
-            if (n2)
-                try {
-                    await this.beforeStateQueue.runMiddleware(s2);
-                } catch (t4) {
-                    s2 = i2, this._popupRedirectResolver._overrideRedirectResult(this, () => Promise.reject(t4));
-                }
-            return s2 ? this.reloadAndSetCurrentUserOrClear(s2) : this.directlySetCurrentUser(null);
-        }
-        return _w(this._popupRedirectResolver, this, "argument-error"), await this.getOrInitRedirectPersistenceManager(), this.redirectUser && this.redirectUser._redirectEventId === s2._redirectEventId ? this.directlySetCurrentUser(s2) : this.reloadAndSetCurrentUserOrClear(s2);
-    }
-    async tryRedirectSignIn(t3) {
-        let e2 = null;
-        try {
-            e2 = await this._popupRedirectResolver._completeRedirectFn(this, t3, true);
-        } catch (t4) {
-            await this._setRedirectUser(null);
-        }
-        return e2;
-    }
-    async reloadAndSetCurrentUserOrClear(t3) {
-        try {
-            await $w(t3);
-        } catch (t4) {
-            if ("auth/network-request-failed" !== (null == t4 ? void 0 : t4.code))
-                return this.directlySetCurrentUser(null);
-        }
-        return this.directlySetCurrentUser(t3);
-    }
-    useDeviceLanguage() {
-        this.languageCode = function() {
-            if ("undefined" == typeof navigator)
-                return null;
-            const t3 = navigator;
-            return t3.languages && t3.languages[0] || t3.language || null;
-        }();
-    }
-    async _delete() {
-        this._deleted = true;
-    }
-    async updateCurrentUser(t3) {
-        const e2 = t3 ? Md(t3) : null;
-        return e2 && _w(e2.auth.config.apiKey === this.config.apiKey, this, "invalid-user-token"), this._updateCurrentUser(e2 && e2._clone(this));
-    }
-    async _updateCurrentUser(t3, e2 = false) {
-        if (!this._deleted)
-            return t3 && _w(this.tenantId === t3.tenantId, this, "tenant-id-mismatch"), e2 || await this.beforeStateQueue.runMiddleware(t3), this.queue(async () => {
-                await this.directlySetCurrentUser(t3), this.notifyAuthListeners();
-            });
-    }
-    async signOut() {
-        return await this.beforeStateQueue.runMiddleware(null), (this.redirectPersistenceManager || this._popupRedirectResolver) && await this._setRedirectUser(null), this._updateCurrentUser(null, true);
-    }
-    setPersistence(t3) {
-        return this.queue(async () => {
-            await this.assertedPersistence.setPersistence(Bw(t3));
-        });
-    }
-    async initializeRecaptchaConfig() {
-        const t3 = await ix(this, {
-                clientType: "CLIENT_TYPE_WEB",
-                version: "RECAPTCHA_ENTERPRISE"
-            }),
-            e2 = new RecaptchaConfig(t3);
-        if (null == this.tenantId ? this._agentRecaptchaConfig = e2 : this._tenantRecaptchaConfigs[this.tenantId] = e2, e2.emailPasswordEnabled) {
-            new RecaptchaEnterpriseVerifier(this).verify();
-        }
-    }
-    _getRecaptchaConfig() {
-        return null == this.tenantId ? this._agentRecaptchaConfig : this._tenantRecaptchaConfigs[this.tenantId];
-    }
-    _getPersistence() {
-        return this.assertedPersistence.persistence.type;
-    }
-    _updateErrorMap(t3) {
-        this._errorFactory = new ErrorFactory("auth", "Firebase", t3());
-    }
-    onAuthStateChanged(t3, e2, i2) {
-        return this.registerStateListener(this.authStateSubscription, t3, e2, i2);
-    }
-    beforeAuthStateChanged(t3, e2) {
-        return this.beforeStateQueue.pushCallback(t3, e2);
-    }
-    onIdTokenChanged(t3, e2, i2) {
-        return this.registerStateListener(this.idTokenSubscription, t3, e2, i2);
-    }
-    toJSON() {
-        var t3;
-        return {
-            apiKey: this.config.apiKey,
-            authDomain: this.config.authDomain,
-            appName: this.name,
-            currentUser: null === (t3 = this._currentUser) || void 0 === t3 ? void 0 : t3.toJSON()
-        };
-    }
-    async _setRedirectUser(t3, e2) {
-        const i2 = await this.getOrInitRedirectPersistenceManager(e2);
-        return null === t3 ? i2.removeCurrentUser() : i2.setCurrentUser(t3);
-    }
-    async getOrInitRedirectPersistenceManager(t3) {
-        if (!this.redirectPersistenceManager) {
-            const e2 = t3 && Bw(t3) || this._popupRedirectResolver;
-            _w(e2, this, "argument-error"), this.redirectPersistenceManager = await PersistenceUserManager.create(this, [Bw(e2._redirectPersistence)], "redirectUser"), this.redirectUser = await this.redirectPersistenceManager.getCurrentUser();
-        }
-        return this.redirectPersistenceManager;
-    }
-    async _redirectUserForId(t3) {
-        var e2, i2;
-        return this._isInitialized && await this.queue(async () => {}), (null === (e2 = this._currentUser) || void 0 === e2 ? void 0 : e2._redirectEventId) === t3 ? this._currentUser : (null === (i2 = this.redirectUser) || void 0 === i2 ? void 0 : i2._redirectEventId) === t3 ? this.redirectUser : null;
-    }
-    async _persistUserIfCurrent(t3) {
-        if (t3 === this.currentUser)
-            return this.queue(async () => this.directlySetCurrentUser(t3));
-    }
-    _notifyListenersIfCurrent(t3) {
-        t3 === this.currentUser && this.notifyAuthListeners();
-    }
-    _key() {
-        return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`;
-    }
-    _startProactiveRefresh() {
-        this.isProactiveRefreshEnabled = true, this.currentUser && this._currentUser._startProactiveRefresh();
-    }
-    _stopProactiveRefresh() {
-        this.isProactiveRefreshEnabled = false, this.currentUser && this._currentUser._stopProactiveRefresh();
-    }
-    get _currentUser() {
-        return this.currentUser;
-    }
-    notifyAuthListeners() {
-        var t3, e2;
-        if (!this._isInitialized)
-            return;
-        this.idTokenSubscription.next(this.currentUser);
-        const i2 = null !== (e2 = null === (t3 = this.currentUser) || void 0 === t3 ? void 0 : t3.uid) && void 0 !== e2 ? e2 : null;
-        this.lastNotifiedUid !== i2 && (this.lastNotifiedUid = i2, this.authStateSubscription.next(this.currentUser));
-    }
-    registerStateListener(t3, e2, i2, s2) {
-        if (this._deleted)
-            return () => {};
-        const n2 = "function" == typeof e2 ? e2 : e2.next.bind(e2),
-            r2 = this._isInitialized ? Promise.resolve() : this._initializationPromise;
-        return _w(r2, this, "internal-error"), r2.then(() => n2(this.currentUser)), "function" == typeof e2 ? t3.addObserver(e2, i2, s2) : t3.addObserver(e2);
-    }
-    async directlySetCurrentUser(t3) {
-        this.currentUser && this.currentUser !== t3 && this._currentUser._stopProactiveRefresh(), t3 && this.isProactiveRefreshEnabled && t3._startProactiveRefresh(), this.currentUser = t3, t3 ? await this.assertedPersistence.setCurrentUser(t3) : await this.assertedPersistence.removeCurrentUser();
-    }
-    queue(t3) {
-        return this.operations = this.operations.then(t3, t3), this.operations;
-    }
-    get assertedPersistence() {
-        return _w(this.persistenceManager, this, "internal-error"), this.persistenceManager;
-    }
-    _logFramework(t3) {
-        t3 && !this.frameworks.includes(t3) && (this.frameworks.push(t3), this.frameworks.sort(), this.clientVersion = ex(this.config.clientPlatform, this._getFrameworks()));
-    }
-    _getFrameworks() {
-        return this.frameworks;
-    }
-    async _getAdditionalHeaders() {
-        var t3;
-        const e2 = {
-            "X-Client-Version": this.clientVersion
-        };
-        this.app.options.appId && (e2["X-Firebase-gmpid"] = this.app.options.appId);
-        const i2 = await (null === (t3 = this.heartbeatServiceProvider.getImmediate({
-            optional: true
-        })) || void 0 === t3 ? void 0 : t3.getHeartbeatsHeader());
-        i2 && (e2["X-Firebase-Client"] = i2);
-        const s2 = await this._getAppCheckToken();
-        return s2 && (e2["X-Firebase-AppCheck"] = s2), e2;
-    }
-    async _getAppCheckToken() {
-        var t3;
-        const e2 = await (null === (t3 = this.appCheckServiceProvider.getImmediate({
-            optional: true
-        })) || void 0 === t3 ? void 0 : t3.getToken());
-        return (null == e2 ? void 0 : e2.error) && function(t4, ...e3) {
-            mw.logLevel <= Rd.WARN && mw.warn(`Auth (${uf}): ${t4}`, ...e3);
-        }(`Error while retrieving App Check token: ${e2.error}`), null == e2 ? void 0 : e2.token;
-    }
-}
-
-function rx(t3) {
-    return Md(t3);
-}
-class Subscription {
-    constructor(t3) {
-        this.auth = t3, this.observer = null, this.addObserver = function(t4, e2) {
-            const i2 = new ObserverProxy(t4, e2);
-            return i2.subscribe.bind(i2);
-        }((t4) => this.observer = t4);
-    }
-    get next() {
-        return _w(this.observer, this.auth, "internal-error"), this.observer.next.bind(this.observer);
-    }
-}
-
-function ox(t3, e2, i2) {
-    const s2 = rx(t3);
-    _w(s2._canInitEmulator, s2, "emulator-config-failed"), _w(/^https?:\/\//.test(e2), s2, "invalid-emulator-scheme");
-    const n2 = !!(null == i2 ? void 0 : i2.disableWarnings),
-        r2 = ax(e2),
-        {
-            host: o2,
-            port: a2
-        } = function(t4) {
-            const e3 = ax(t4),
-                i3 = /(\/\/)?([^?#/]+)/.exec(t4.substr(e3.length));
-            if (!i3)
-                return {
-                    host: "",
-                    port: null
-                };
-            const s3 = i3[2].split("@").pop() || "",
-                n3 = /^(\[[^\]]+\])(:|$)/.exec(s3);
-            if (n3) {
-                const t5 = n3[1];
-                return {
-                    host: t5,
-                    port: lx(s3.substr(t5.length + 1))
-                };
-            } {
-                const [t5, e4] = s3.split(":");
-                return {
-                    host: t5,
-                    port: lx(e4)
-                };
-            }
-        }(e2),
-        l2 = null === a2 ? "" : `:${a2}`;
-    s2.config.emulator = {
-        url: `${r2}//${o2}${l2}/`
-    }, s2.settings.appVerificationDisabledForTesting = true, s2.emulatorConfig = Object.freeze({
-        host: o2,
-        port: a2,
-        protocol: r2.replace(":", ""),
-        options: Object.freeze({
-            disableWarnings: n2
-        })
-    }), n2 || function() {
-        function t4() {
-            const t5 = document.createElement("p"),
-                e3 = t5.style;
-            t5.innerText = "Running in emulator mode. Do not use with production credentials.", e3.position = "fixed", e3.width = "100%", e3.backgroundColor = "#ffffff", e3.border = ".1em solid #000000", e3.color = "#b50000", e3.bottom = "0px", e3.left = "0px", e3.margin = "0px", e3.zIndex = "10000", e3.textAlign = "center", t5.classList.add("firebase-emulator-warning"), document.body.appendChild(t5);
-        }
-        "undefined" != typeof console && "function" == typeof console.info && console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials.");
-        "undefined" != typeof window && "undefined" != typeof document && ("loading" === document.readyState ? window.addEventListener("DOMContentLoaded", t4) : t4());
-    }();
-}
-
-function ax(t3) {
-    const e2 = t3.indexOf(":");
-    return e2 < 0 ? "" : t3.substr(0, e2 + 1);
-}
-
-function lx(t3) {
-    if (!t3)
-        return null;
-    const e2 = Number(t3);
-    return isNaN(e2) ? null : e2;
-}
-class AuthCredential {
-    constructor(t3, e2) {
-        this.providerId = t3, this.signInMethod = e2;
-    }
-    toJSON() {
-        return ww("not implemented");
-    }
-    _getIdTokenResponse(t3) {
-        return ww("not implemented");
-    }
-    _linkToIdToken(t3, e2) {
-        return ww("not implemented");
-    }
-    _getReauthenticationResolver(t3) {
-        return ww("not implemented");
-    }
-}
-async function hx(t3, e2) {
-    return async function(t4, e3, i2, s2, n2 = {}) {
-        const r2 = await Pw(t4, e3, i2, s2, n2);
-        return "mfaPendingCredential" in r2 && yw(t4, "multi-factor-auth-required", {
-            _serverResponse: r2
-        }), r2;
-    }(t3, "POST", "/v1/accounts:signInWithIdp", Mw(t3, e2));
-}
-class OAuthCredential extends AuthCredential {
-    constructor() {
-        super(...arguments), this.pendingToken = null;
-    }
-    static _fromParams(t3) {
-        const e2 = new OAuthCredential(t3.providerId, t3.signInMethod);
-        return t3.idToken || t3.accessToken ? (t3.idToken && (e2.idToken = t3.idToken), t3.accessToken && (e2.accessToken = t3.accessToken), t3.nonce && !t3.pendingToken && (e2.nonce = t3.nonce), t3.pendingToken && (e2.pendingToken = t3.pendingToken)) : t3.oauthToken && t3.oauthTokenSecret ? (e2.accessToken = t3.oauthToken, e2.secret = t3.oauthTokenSecret) : yw("argument-error"), e2;
-    }
-    toJSON() {
-        return {
-            idToken: this.idToken,
-            accessToken: this.accessToken,
-            secret: this.secret,
-            nonce: this.nonce,
-            pendingToken: this.pendingToken,
-            providerId: this.providerId,
-            signInMethod: this.signInMethod
-        };
-    }
-    static fromJSON(t3) {
-        const e2 = "string" == typeof t3 ? JSON.parse(t3) : t3,
-            {
-                providerId: i2,
-                signInMethod: s2
-            } = e2,
-            n2 = uw(e2, ["providerId", "signInMethod"]);
-        if (!i2 || !s2)
-            return null;
-        const r2 = new OAuthCredential(i2, s2);
-        return r2.idToken = n2.idToken || void 0, r2.accessToken = n2.accessToken || void 0, r2.secret = n2.secret, r2.nonce = n2.nonce, r2.pendingToken = n2.pendingToken || null, r2;
-    }
-    _getIdTokenResponse(t3) {
-        return hx(t3, this.buildRequest());
-    }
-    _linkToIdToken(t3, e2) {
-        const i2 = this.buildRequest();
-        return i2.idToken = e2, hx(t3, i2);
-    }
-    _getReauthenticationResolver(t3) {
-        const e2 = this.buildRequest();
-        return e2.autoCreate = false, hx(t3, e2);
-    }
-    buildRequest() {
-        const t3 = {
-            requestUri: "http://localhost",
-            returnSecureToken: true
-        };
-        if (this.pendingToken)
-            t3.pendingToken = this.pendingToken;
-        else {
-            const e2 = {};
-            this.idToken && (e2.id_token = this.idToken), this.accessToken && (e2.access_token = this.accessToken), this.secret && (e2.oauth_token_secret = this.secret), e2.providerId = this.providerId, this.nonce && !this.pendingToken && (e2.nonce = this.nonce), t3.postBody = Cd(e2);
-        }
-        return t3;
-    }
-}
-class FederatedAuthProvider {
-    constructor(t3) {
-        this.providerId = t3, this.defaultLanguageCode = null, this.customParameters = {};
-    }
-    setDefaultLanguage(t3) {
-        this.defaultLanguageCode = t3;
-    }
-    setCustomParameters(t3) {
-        return this.customParameters = t3, this;
-    }
-    getCustomParameters() {
-        return this.customParameters;
-    }
-}
-class BaseOAuthProvider extends FederatedAuthProvider {
-    constructor() {
-        super(...arguments), this.scopes = [];
-    }
-    addScope(t3) {
-        return this.scopes.includes(t3) || this.scopes.push(t3), this;
-    }
-    getScopes() {
-        return [...this.scopes];
-    }
-}
-class FacebookAuthProvider extends BaseOAuthProvider {
-    constructor() {
-        super("facebook.com");
-    }
-    static credential(t3) {
-        return OAuthCredential._fromParams({
-            providerId: FacebookAuthProvider.PROVIDER_ID,
-            signInMethod: FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD,
-            accessToken: t3
-        });
-    }
-    static credentialFromResult(t3) {
-        return FacebookAuthProvider.credentialFromTaggedObject(t3);
-    }
-    static credentialFromError(t3) {
-        return FacebookAuthProvider.credentialFromTaggedObject(t3.customData || {});
-    }
-    static credentialFromTaggedObject({
-        _tokenResponse: t3
-    }) {
-        if (!t3 || !("oauthAccessToken" in t3))
-            return null;
-        if (!t3.oauthAccessToken)
-            return null;
-        try {
-            return FacebookAuthProvider.credential(t3.oauthAccessToken);
-        } catch (t4) {
-            return null;
-        }
-    }
-}
-FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD = "facebook.com", FacebookAuthProvider.PROVIDER_ID = "facebook.com";
-class GoogleAuthProvider extends BaseOAuthProvider {
-    constructor() {
-        super("google.com"), this.addScope("profile");
-    }
-    static credential(t3, e2) {
-        return OAuthCredential._fromParams({
-            providerId: GoogleAuthProvider.PROVIDER_ID,
-            signInMethod: GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD,
-            idToken: t3,
-            accessToken: e2
-        });
-    }
-    static credentialFromResult(t3) {
-        return GoogleAuthProvider.credentialFromTaggedObject(t3);
-    }
-    static credentialFromError(t3) {
-        return GoogleAuthProvider.credentialFromTaggedObject(t3.customData || {});
-    }
-    static credentialFromTaggedObject({
-        _tokenResponse: t3
-    }) {
-        if (!t3)
-            return null;
-        const {
-            oauthIdToken: e2,
-            oauthAccessToken: i2
-        } = t3;
-        if (!e2 && !i2)
-            return null;
-        try {
-            return GoogleAuthProvider.credential(e2, i2);
-        } catch (t4) {
-            return null;
-        }
-    }
-}
-GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD = "google.com", GoogleAuthProvider.PROVIDER_ID = "google.com";
-class GithubAuthProvider extends BaseOAuthProvider {
-    constructor() {
-        super("github.com");
-    }
-    static credential(t3) {
-        return OAuthCredential._fromParams({
-            providerId: GithubAuthProvider.PROVIDER_ID,
-            signInMethod: GithubAuthProvider.GITHUB_SIGN_IN_METHOD,
-            accessToken: t3
-        });
-    }
-    static credentialFromResult(t3) {
-        return GithubAuthProvider.credentialFromTaggedObject(t3);
-    }
-    static credentialFromError(t3) {
-        return GithubAuthProvider.credentialFromTaggedObject(t3.customData || {});
-    }
-    static credentialFromTaggedObject({
-        _tokenResponse: t3
-    }) {
-        if (!t3 || !("oauthAccessToken" in t3))
-            return null;
-        if (!t3.oauthAccessToken)
-            return null;
-        try {
-            return GithubAuthProvider.credential(t3.oauthAccessToken);
-        } catch (t4) {
-            return null;
-        }
-    }
-}
-GithubAuthProvider.GITHUB_SIGN_IN_METHOD = "github.com", GithubAuthProvider.PROVIDER_ID = "github.com";
-class TwitterAuthProvider extends BaseOAuthProvider {
-    constructor() {
-        super("twitter.com");
-    }
-    static credential(t3, e2) {
-        return OAuthCredential._fromParams({
-            providerId: TwitterAuthProvider.PROVIDER_ID,
-            signInMethod: TwitterAuthProvider.TWITTER_SIGN_IN_METHOD,
-            oauthToken: t3,
-            oauthTokenSecret: e2
-        });
-    }
-    static credentialFromResult(t3) {
-        return TwitterAuthProvider.credentialFromTaggedObject(t3);
-    }
-    static credentialFromError(t3) {
-        return TwitterAuthProvider.credentialFromTaggedObject(t3.customData || {});
-    }
-    static credentialFromTaggedObject({
-        _tokenResponse: t3
-    }) {
-        if (!t3)
-            return null;
-        const {
-            oauthAccessToken: e2,
-            oauthTokenSecret: i2
-        } = t3;
-        if (!e2 || !i2)
-            return null;
-        try {
-            return TwitterAuthProvider.credential(e2, i2);
-        } catch (t4) {
-            return null;
-        }
-    }
-}
-TwitterAuthProvider.TWITTER_SIGN_IN_METHOD = "twitter.com", TwitterAuthProvider.PROVIDER_ID = "twitter.com";
-class UserCredentialImpl {
-    constructor(t3) {
-        this.user = t3.user, this.providerId = t3.providerId, this._tokenResponse = t3._tokenResponse, this.operationType = t3.operationType;
-    }
-    static async _fromIdTokenResponse(t3, e2, i2, s2 = false) {
-        const n2 = await UserImpl._fromIdTokenResponse(t3, i2, s2),
-            r2 = cx(i2);
-        return new UserCredentialImpl({
-            user: n2,
-            providerId: r2,
-            _tokenResponse: i2,
-            operationType: e2
-        });
-    }
-    static async _forOperation(t3, e2, i2) {
-        await t3._updateTokensIfNecessary(i2, true);
-        const s2 = cx(i2);
-        return new UserCredentialImpl({
-            user: t3,
-            providerId: s2,
-            _tokenResponse: i2,
-            operationType: e2
-        });
-    }
-}
-
-function cx(t3) {
-    return t3.providerId ? t3.providerId : "phoneNumber" in t3 ? "phone" : null;
-}
-class MultiFactorError extends FirebaseError {
-    constructor(t3, e2, i2, s2) {
-        var n2;
-        super(e2.code, e2.message), this.operationType = i2, this.user = s2, Object.setPrototypeOf(this, MultiFactorError.prototype), this.customData = {
-            appName: t3.name,
-            tenantId: null !== (n2 = t3.tenantId) && void 0 !== n2 ? n2 : void 0,
-            _serverResponse: e2.customData._serverResponse,
-            operationType: i2
-        };
-    }
-    static _fromErrorAndOperation(t3, e2, i2, s2) {
-        return new MultiFactorError(t3, e2, i2, s2);
-    }
-}
-
-function ux(t3, e2, i2, s2) {
-    return ("reauthenticate" === e2 ? i2._getReauthenticationResolver(t3) : i2._getIdTokenResponse(t3)).catch((i3) => {
-        if ("auth/multi-factor-auth-required" === i3.code)
-            throw MultiFactorError._fromErrorAndOperation(t3, i3, e2, s2);
-        throw i3;
-    });
-}
-const dx = "__sak";
-class BrowserPersistenceClass {
-    constructor(t3, e2) {
-        this.storageRetriever = t3, this.type = e2;
-    }
-    _isAvailable() {
-        try {
-            return this.storage ? (this.storage.setItem(dx, "1"), this.storage.removeItem(dx), Promise.resolve(true)) : Promise.resolve(false);
-        } catch (t3) {
-            return Promise.resolve(false);
-        }
-    }
-    _set(t3, e2) {
-        return this.storage.setItem(t3, JSON.stringify(e2)), Promise.resolve();
-    }
-    _get(t3) {
-        const e2 = this.storage.getItem(t3);
-        return Promise.resolve(e2 ? JSON.parse(e2) : null);
-    }
-    _remove(t3) {
-        return this.storage.removeItem(t3), Promise.resolve();
-    }
-    get storage() {
-        return this.storageRetriever();
-    }
-}
-class BrowserLocalPersistence extends BrowserPersistenceClass {
-    constructor() {
-        super(() => window.localStorage, "LOCAL"), this.boundEventHandler = (t3, e2) => this.onStorageEvent(t3, e2), this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.safariLocalStorageNotSynced = function() {
-            const t3 = kd();
-            return qw(t3) || Jw(t3);
-        }() && function() {
-            try {
-                return !(!window || window === window.top);
-            } catch (t3) {
-                return false;
-            }
-        }(), this.fallbackToPolling = tx(), this._shouldAllowMigration = true;
-    }
-    forAllChangedKeys(t3) {
-        for (const e2 of Object.keys(this.listeners)) {
-            const i2 = this.storage.getItem(e2),
-                s2 = this.localCache[e2];
-            i2 !== s2 && t3(e2, s2, i2);
-        }
-    }
-    onStorageEvent(t3, e2 = false) {
-        if (!t3.key)
-            return void this.forAllChangedKeys((t4, e3, i3) => {
-                this.notifyListeners(t4, i3);
-            });
-        const i2 = t3.key;
-        if (e2 ? this.detachListener() : this.stopPolling(), this.safariLocalStorageNotSynced) {
-            const s3 = this.storage.getItem(i2);
-            if (t3.newValue !== s3)
-                null !== t3.newValue ? this.storage.setItem(i2, t3.newValue) : this.storage.removeItem(i2);
-            else if (this.localCache[i2] === t3.newValue && !e2)
-                return;
-        }
-        const s2 = () => {
-                const t4 = this.storage.getItem(i2);
-                (e2 || this.localCache[i2] !== t4) && this.notifyListeners(i2, t4);
-            },
-            n2 = this.storage.getItem(i2);
-        Zw() && n2 !== t3.newValue && t3.newValue !== t3.oldValue ? setTimeout(s2, 10) : s2();
-    }
-    notifyListeners(t3, e2) {
-        this.localCache[t3] = e2;
-        const i2 = this.listeners[t3];
-        if (i2)
-            for (const t4 of Array.from(i2))
-                t4(e2 ? JSON.parse(e2) : e2);
-    }
-    startPolling() {
-        this.stopPolling(), this.pollTimer = setInterval(() => {
-            this.forAllChangedKeys((t3, e2, i2) => {
-                this.onStorageEvent(new StorageEvent("storage", {
-                    key: t3,
-                    oldValue: e2,
-                    newValue: i2
-                }), true);
-            });
-        }, 1e3);
-    }
-    stopPolling() {
-        this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null);
-    }
-    attachListener() {
-        window.addEventListener("storage", this.boundEventHandler);
-    }
-    detachListener() {
-        window.removeEventListener("storage", this.boundEventHandler);
-    }
-    _addListener(t3, e2) {
-        0 === Object.keys(this.listeners).length && (this.fallbackToPolling ? this.startPolling() : this.attachListener()), this.listeners[t3] || (this.listeners[t3] = /* @__PURE__ */ new Set(), this.localCache[t3] = this.storage.getItem(t3)), this.listeners[t3].add(e2);
-    }
-    _removeListener(t3, e2) {
-        this.listeners[t3] && (this.listeners[t3].delete(e2), 0 === this.listeners[t3].size && delete this.listeners[t3]), 0 === Object.keys(this.listeners).length && (this.detachListener(), this.stopPolling());
-    }
-    async _set(t3, e2) {
-        await super._set(t3, e2), this.localCache[t3] = JSON.stringify(e2);
-    }
-    async _get(t3) {
-        const e2 = await super._get(t3);
-        return this.localCache[t3] = JSON.stringify(e2), e2;
-    }
-    async _remove(t3) {
-        await super._remove(t3), delete this.localCache[t3];
-    }
-}
-BrowserLocalPersistence.type = "LOCAL";
-const fx = BrowserLocalPersistence;
-class BrowserSessionPersistence extends BrowserPersistenceClass {
-    constructor() {
-        super(() => window.sessionStorage, "SESSION");
-    }
-    _addListener(t3, e2) {}
-    _removeListener(t3, e2) {}
-}
-BrowserSessionPersistence.type = "SESSION";
-const px = BrowserSessionPersistence;
-class Receiver {
-    constructor(t3) {
-        this.eventTarget = t3, this.handlersMap = {}, this.boundEventHandler = this.handleEvent.bind(this);
-    }
-    static _getInstance(t3) {
-        const e2 = this.receivers.find((e3) => e3.isListeningto(t3));
-        if (e2)
-            return e2;
-        const i2 = new Receiver(t3);
-        return this.receivers.push(i2), i2;
-    }
-    isListeningto(t3) {
-        return this.eventTarget === t3;
-    }
-    async handleEvent(t3) {
-        const e2 = t3,
-            {
-                eventId: i2,
-                eventType: s2,
-                data: n2
-            } = e2.data,
-            r2 = this.handlersMap[s2];
-        if (!(null == r2 ? void 0 : r2.size))
-            return;
-        e2.ports[0].postMessage({
-            status: "ack",
-            eventId: i2,
-            eventType: s2
-        });
-        const o2 = Array.from(r2).map(async (t4) => t4(e2.origin, n2)),
-            a2 = await
-        function(t4) {
-            return Promise.all(t4.map(async (t5) => {
-                try {
-                    return {
-                        fulfilled: true,
-                        value: await t5
-                    };
-                } catch (t6) {
-                    return {
-                        fulfilled: false,
-                        reason: t6
-                    };
-                }
-            }));
-        }(o2);
-        e2.ports[0].postMessage({
-            status: "done",
-            eventId: i2,
-            eventType: s2,
-            response: a2
-        });
-    }
-    _subscribe(t3, e2) {
-        0 === Object.keys(this.handlersMap).length && this.eventTarget.addEventListener("message", this.boundEventHandler), this.handlersMap[t3] || (this.handlersMap[t3] = /* @__PURE__ */ new Set()), this.handlersMap[t3].add(e2);
-    }
-    _unsubscribe(t3, e2) {
-        this.handlersMap[t3] && e2 && this.handlersMap[t3].delete(e2), e2 && 0 !== this.handlersMap[t3].size || delete this.handlersMap[t3], 0 === Object.keys(this.handlersMap).length && this.eventTarget.removeEventListener("message", this.boundEventHandler);
-    }
-}
-
-function mx(t3 = "", e2 = 10) {
-    let i2 = "";
-    for (let t4 = 0; t4 < e2; t4++)
-        i2 += Math.floor(10 * Math.random());
-    return t3 + i2;
-}
-Receiver.receivers = [];
-class Sender {
-    constructor(t3) {
-        this.target = t3, this.handlers = /* @__PURE__ */ new Set();
-    }
-    removeMessageHandler(t3) {
-        t3.messageChannel && (t3.messageChannel.port1.removeEventListener("message", t3.onMessage), t3.messageChannel.port1.close()), this.handlers.delete(t3);
-    }
-    async _send(t3, e2, i2 = 50) {
-        const s2 = "undefined" != typeof MessageChannel ? new MessageChannel() : null;
-        if (!s2)
-            throw new Error("connection_unavailable");
-        let n2, r2;
-        return new Promise((o2, a2) => {
-            const l2 = mx("", 20);
-            s2.port1.start();
-            const h2 = setTimeout(() => {
-                a2(new Error("unsupported_event"));
-            }, i2);
-            r2 = {
-                messageChannel: s2,
-                onMessage(t4) {
-                    const e3 = t4;
-                    if (e3.data.eventId === l2)
-                        switch (e3.data.status) {
-                            case "ack":
-                                clearTimeout(h2), n2 = setTimeout(() => {
-                                    a2(new Error("timeout"));
-                                }, 3e3);
-                                break;
-                            case "done":
-                                clearTimeout(n2), o2(e3.data.response);
-                                break;
-                            default:
-                                clearTimeout(h2), clearTimeout(n2), a2(new Error("invalid_response"));
-                        }
-                }
-            }, this.handlers.add(r2), s2.port1.addEventListener("message", r2.onMessage), this.target.postMessage({
-                eventType: t3,
-                eventId: l2,
-                data: e2
-            }, [s2.port2]);
-        }).finally(() => {
-            r2 && this.removeMessageHandler(r2);
-        });
-    }
-}
-
-function gx() {
-    return window;
-}
-
-function yx() {
-    return void 0 !== gx().WorkerGlobalScope && "function" == typeof gx().importScripts;
-}
-const vx = "firebaseLocalStorageDb",
-    bx = "firebaseLocalStorage",
-    _x = "fbase_key";
-class DBPromise {
-    constructor(t3) {
-        this.request = t3;
-    }
-    toPromise() {
-        return new Promise((t3, e2) => {
-            this.request.addEventListener("success", () => {
-                t3(this.request.result);
-            }), this.request.addEventListener("error", () => {
-                e2(this.request.error);
-            });
-        });
-    }
-}
-
-function wx(t3, e2) {
-    return t3.transaction([bx], e2 ? "readwrite" : "readonly").objectStore(bx);
-}
-
-function xx() {
-    const t3 = indexedDB.open(vx, 1);
-    return new Promise((e2, i2) => {
-        t3.addEventListener("error", () => {
-            i2(t3.error);
-        }), t3.addEventListener("upgradeneeded", () => {
-            const e3 = t3.result;
-            try {
-                e3.createObjectStore(bx, {
-                    keyPath: _x
-                });
-            } catch (t4) {
-                i2(t4);
-            }
-        }), t3.addEventListener("success", async () => {
-            const i3 = t3.result;
-            i3.objectStoreNames.contains(bx) ? e2(i3) : (i3.close(), await
-                function() {
-                    const t4 = indexedDB.deleteDatabase(vx);
-                    return new DBPromise(t4).toPromise();
-                }(), e2(await xx()));
-        });
-    });
-}
-async function kx(t3, e2, i2) {
-    const s2 = wx(t3, true).put({
-        [_x]: e2,
-        value: i2
-    });
-    return new DBPromise(s2).toPromise();
-}
-
-function Tx(t3, e2) {
-    const i2 = wx(t3, true).delete(e2);
-    return new DBPromise(i2).toPromise();
-}
-class IndexedDBLocalPersistence {
-    constructor() {
-        this.type = "LOCAL", this._shouldAllowMigration = true, this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.pendingWrites = 0, this.receiver = null, this.sender = null, this.serviceWorkerReceiverAvailable = false, this.activeServiceWorker = null, this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then(() => {}, () => {});
-    }
-    async _openDb() {
-        return this.db || (this.db = await xx()), this.db;
-    }
-    async _withRetries(t3) {
-        let e2 = 0;
-        for (;;)
-            try {
-                const e3 = await this._openDb();
-                return await t3(e3);
-            } catch (t4) {
-                if (e2++ > 3)
-                    throw t4;
-                this.db && (this.db.close(), this.db = void 0);
-            }
-    }
-    async initializeServiceWorkerMessaging() {
-        return yx() ? this.initializeReceiver() : this.initializeSender();
-    }
-    async initializeReceiver() {
-        this.receiver = Receiver._getInstance(yx() ? self : null), this.receiver._subscribe("keyChanged", async (t3, e2) => ({
-            keyProcessed: (await this._poll()).includes(e2.key)
-        })), this.receiver._subscribe("ping", async (t3, e2) => ["keyChanged"]);
-    }
-    async initializeSender() {
-        var t3, e2;
-        if (this.activeServiceWorker = await async function() {
-                if (!(null === navigator || void 0 === navigator ? void 0 : navigator.serviceWorker))
-                    return null;
-                try {
-                    return (await navigator.serviceWorker.ready).active;
-                } catch (t4) {
-                    return null;
-                }
-            }(), !this.activeServiceWorker)
-            return;
-        this.sender = new Sender(this.activeServiceWorker);
-        const i2 = await this.sender._send("ping", {}, 800);
-        i2 && (null === (t3 = i2[0]) || void 0 === t3 ? void 0 : t3.fulfilled) && (null === (e2 = i2[0]) || void 0 === e2 ? void 0 : e2.value.includes("keyChanged")) && (this.serviceWorkerReceiverAvailable = true);
-    }
-    async notifyServiceWorker(t3) {
-        var e2;
-        if (this.sender && this.activeServiceWorker && ((null === (e2 = null === navigator || void 0 === navigator ? void 0 : navigator.serviceWorker) || void 0 === e2 ? void 0 : e2.controller) || null) === this.activeServiceWorker)
-            try {
-                await this.sender._send("keyChanged", {
-                    key: t3
-                }, this.serviceWorkerReceiverAvailable ? 800 : 50);
-            } catch (e3) {}
-    }
-    async _isAvailable() {
-        try {
-            if (!indexedDB)
-                return false;
-            const t3 = await xx();
-            return await kx(t3, dx, "1"), await Tx(t3, dx), true;
-        } catch (t3) {}
-        return false;
-    }
-    async _withPendingWrite(t3) {
-        this.pendingWrites++;
-        try {
-            await t3();
-        } finally {
-            this.pendingWrites--;
-        }
-    }
-    async _set(t3, e2) {
-        return this._withPendingWrite(async () => (await this._withRetries((i2) => kx(i2, t3, e2)), this.localCache[t3] = e2, this.notifyServiceWorker(t3)));
-    }
-    async _get(t3) {
-        const e2 = await this._withRetries((e3) => async function(t4, e4) {
-            const i2 = wx(t4, false).get(e4),
-                s2 = await new DBPromise(i2).toPromise();
-            return void 0 === s2 ? null : s2.value;
-        }(e3, t3));
-        return this.localCache[t3] = e2, e2;
-    }
-    async _remove(t3) {
-        return this._withPendingWrite(async () => (await this._withRetries((e2) => Tx(e2, t3)), delete this.localCache[t3], this.notifyServiceWorker(t3)));
-    }
-    async _poll() {
-        const t3 = await this._withRetries((t4) => {
-            const e3 = wx(t4, false).getAll();
-            return new DBPromise(e3).toPromise();
-        });
-        if (!t3)
-            return [];
-        if (0 !== this.pendingWrites)
-            return [];
-        const e2 = [],
-            i2 = /* @__PURE__ */ new Set();
-        for (const {
-                fbase_key: s2,
-                value: n2
-            }
-            of t3)
-            i2.add(s2), JSON.stringify(this.localCache[s2]) !== JSON.stringify(n2) && (this.notifyListeners(s2, n2), e2.push(s2));
-        for (const t4 of Object.keys(this.localCache))
-            this.localCache[t4] && !i2.has(t4) && (this.notifyListeners(t4, null), e2.push(t4));
-        return e2;
-    }
-    notifyListeners(t3, e2) {
-        this.localCache[t3] = e2;
-        const i2 = this.listeners[t3];
-        if (i2)
-            for (const t4 of Array.from(i2))
-                t4(e2);
-    }
-    startPolling() {
-        this.stopPolling(), this.pollTimer = setInterval(async () => this._poll(), 800);
-    }
-    stopPolling() {
-        this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null);
-    }
-    _addListener(t3, e2) {
-        0 === Object.keys(this.listeners).length && this.startPolling(), this.listeners[t3] || (this.listeners[t3] = /* @__PURE__ */ new Set(), this._get(t3)), this.listeners[t3].add(e2);
-    }
-    _removeListener(t3, e2) {
-        this.listeners[t3] && (this.listeners[t3].delete(e2), 0 === this.listeners[t3].size && delete this.listeners[t3]), 0 === Object.keys(this.listeners).length && this.stopPolling();
-    }
-}
-IndexedDBLocalPersistence.type = "LOCAL";
-const Sx = IndexedDBLocalPersistence;
-new Delay(3e4, 6e4);
-class IdpCredential extends AuthCredential {
-    constructor(t3) {
-        super("custom", "custom"), this.params = t3;
-    }
-    _getIdTokenResponse(t3) {
-        return hx(t3, this._buildIdpRequest());
-    }
-    _linkToIdToken(t3, e2) {
-        return hx(t3, this._buildIdpRequest(e2));
-    }
-    _getReauthenticationResolver(t3) {
-        return hx(t3, this._buildIdpRequest());
-    }
-    _buildIdpRequest(t3) {
-        const e2 = {
-            requestUri: this.params.requestUri,
-            sessionId: this.params.sessionId,
-            postBody: this.params.postBody,
-            tenantId: this.params.tenantId,
-            pendingToken: this.params.pendingToken,
-            returnSecureToken: true,
-            returnIdpCredential: true
-        };
-        return t3 && (e2.idToken = t3), e2;
-    }
-}
-
-function Ex(t3) {
-    return async function(t4, e2, i2 = false) {
-        const s2 = "signIn",
-            n2 = await ux(t4, s2, e2),
-            r2 = await UserCredentialImpl._fromIdTokenResponse(t4, s2, n2);
-        return i2 || await t4._updateCurrentUser(r2.user), r2;
-    }(t3.auth, new IdpCredential(t3), t3.bypassAuthState);
-}
-
-function Cx(t3) {
-    const {
-        auth: e2,
-        user: i2
-    } = t3;
-    return _w(i2, e2, "internal-error"), async function(t4, e3, i3 = false) {
-        const {
-            auth: s2
-        } = t4, n2 = "reauthenticate";
-        try {
-            const r2 = await Nw(t4, ux(s2, n2, e3, t4), i3);
-            _w(r2.idToken, s2, "internal-error");
-            const o2 = Fw(r2.idToken);
-            _w(o2, s2, "internal-error");
-            const {
-                sub: a2
-            } = o2;
-            return _w(t4.uid === a2, s2, "user-mismatch"), UserCredentialImpl._forOperation(t4, n2, r2);
-        } catch (t5) {
-            throw "auth/user-not-found" === (null == t5 ? void 0 : t5.code) && yw(s2, "user-mismatch"), t5;
-        }
-    }(i2, new IdpCredential(t3), t3.bypassAuthState);
-}
-async function Ix(t3) {
-    const {
-        auth: e2,
-        user: i2
-    } = t3;
-    return _w(i2, e2, "internal-error"), async function(t4, e3, i3 = false) {
-        const s2 = await Nw(t4, e3._linkToIdToken(t4.auth, await t4.getIdToken()), i3);
-        return UserCredentialImpl._forOperation(t4, "link", s2);
-    }(i2, new IdpCredential(t3), t3.bypassAuthState);
-}
-class AbstractPopupRedirectOperation {
-    constructor(t3, e2, i2, s2, n2 = false) {
-        this.auth = t3, this.resolver = i2, this.user = s2, this.bypassAuthState = n2, this.pendingPromise = null, this.eventManager = null, this.filter = Array.isArray(e2) ? e2 : [e2];
-    }
-    execute() {
-        return new Promise(async (t3, e2) => {
-            this.pendingPromise = {
-                resolve: t3,
-                reject: e2
-            };
-            try {
-                this.eventManager = await this.resolver._initialize(this.auth), await this.onExecution(), this.eventManager.registerConsumer(this);
-            } catch (t4) {
-                this.reject(t4);
-            }
-        });
-    }
-    async onAuthEvent(t3) {
-        const {
-            urlResponse: e2,
-            sessionId: i2,
-            postBody: s2,
-            tenantId: n2,
-            error: r2,
-            type: o2
-        } = t3;
-        if (r2)
-            return void this.reject(r2);
-        const a2 = {
-            auth: this.auth,
-            requestUri: e2,
-            sessionId: i2,
-            tenantId: n2 || void 0,
-            postBody: s2 || void 0,
-            user: this.user,
-            bypassAuthState: this.bypassAuthState
-        };
-        try {
-            this.resolve(await this.getIdpTask(o2)(a2));
-        } catch (t4) {
-            this.reject(t4);
-        }
-    }
-    onError(t3) {
-        this.reject(t3);
-    }
-    getIdpTask(t3) {
-        switch (t3) {
-            case "signInViaPopup":
-            case "signInViaRedirect":
-                return Ex;
-            case "linkViaPopup":
-            case "linkViaRedirect":
-                return Ix;
-            case "reauthViaPopup":
-            case "reauthViaRedirect":
-                return Cx;
-            default:
-                yw(this.auth, "internal-error");
-        }
-    }
-    resolve(t3) {
-        xw(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.resolve(t3), this.unregisterAndCleanUp();
-    }
-    reject(t3) {
-        xw(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.reject(t3), this.unregisterAndCleanUp();
-    }
-    unregisterAndCleanUp() {
-        this.eventManager && this.eventManager.unregisterConsumer(this), this.pendingPromise = null, this.cleanUp();
-    }
-}
-const Mx = new Delay(2e3, 1e4);
-class PopupOperation extends AbstractPopupRedirectOperation {
-    constructor(t3, e2, i2, s2, n2) {
-        super(t3, e2, s2, n2), this.provider = i2, this.authWindow = null, this.pollId = null, PopupOperation.currentPopupAction && PopupOperation.currentPopupAction.cancel(), PopupOperation.currentPopupAction = this;
-    }
-    async executeNotNull() {
-        const t3 = await this.execute();
-        return _w(t3, this.auth, "internal-error"), t3;
-    }
-    async onExecution() {
-        xw(1 === this.filter.length, "Popup operations only handle one event");
-        const t3 = mx();
-        this.authWindow = await this.resolver._openPopup(this.auth, this.provider, this.filter[0], t3), this.authWindow.associatedEvent = t3, this.resolver._originValidation(this.auth).catch((t4) => {
-            this.reject(t4);
-        }), this.resolver._isIframeWebStorageSupported(this.auth, (t4) => {
-            t4 || this.reject(vw(this.auth, "web-storage-unsupported"));
-        }), this.pollUserCancellation();
-    }
-    get eventId() {
-        var t3;
-        return (null === (t3 = this.authWindow) || void 0 === t3 ? void 0 : t3.associatedEvent) || null;
-    }
-    cancel() {
-        this.reject(vw(this.auth, "cancelled-popup-request"));
-    }
-    cleanUp() {
-        this.authWindow && this.authWindow.close(), this.pollId && window.clearTimeout(this.pollId), this.authWindow = null, this.pollId = null, PopupOperation.currentPopupAction = null;
-    }
-    pollUserCancellation() {
-        const t3 = () => {
-            var e2, i2;
-            (null === (i2 = null === (e2 = this.authWindow) || void 0 === e2 ? void 0 : e2.window) || void 0 === i2 ? void 0 : i2.closed) ? this.pollId = window.setTimeout(() => {
-                this.pollId = null, this.reject(vw(this.auth, "popup-closed-by-user"));
-            }, 8e3): this.pollId = window.setTimeout(t3, Mx.get());
-        };
-        t3();
-    }
-}
-PopupOperation.currentPopupAction = null;
-const Px = "pendingRedirect",
-    Rx = /* @__PURE__ */ new Map();
-class RedirectAction extends AbstractPopupRedirectOperation {
-    constructor(t3, e2, i2 = false) {
-        super(t3, ["signInViaRedirect", "linkViaRedirect", "reauthViaRedirect", "unknown"], e2, void 0, i2), this.eventId = null;
-    }
-    async execute() {
-        let t3 = Rx.get(this.auth._key());
-        if (!t3) {
-            try {
-                const e2 = await async function(t4, e3) {
-                    const i3 = function(t5) {
-                            return jw(Px, t5.config.apiKey, t5.name);
-                        }(e3),
-                        s2 = function(t5) {
-                            return Bw(t5._redirectPersistence);
-                        }(t4);
-                    if (!await s2._isAvailable())
-                        return false;
-                    const n2 = "true" === await s2._get(i3);
-                    return await s2._remove(i3), n2;
-                }(this.resolver, this.auth), i2 = e2 ? await super.execute() : null;
-                t3 = () => Promise.resolve(i2);
-            } catch (e2) {
-                t3 = () => Promise.reject(e2);
-            }
-            Rx.set(this.auth._key(), t3);
-        }
-        return this.bypassAuthState || Rx.set(this.auth._key(), () => Promise.resolve(null)), t3();
-    }
-    async onAuthEvent(t3) {
-        if ("signInViaRedirect" === t3.type)
-            return super.onAuthEvent(t3);
-        if ("unknown" !== t3.type) {
-            if (t3.eventId) {
-                const e2 = await this.auth._redirectUserForId(t3.eventId);
-                if (e2)
-                    return this.user = e2, super.onAuthEvent(t3);
-                this.resolve(null);
-            }
-        } else
-            this.resolve(null);
-    }
-    async onExecution() {}
-    cleanUp() {}
-}
-
-function Ax(t3, e2) {
-    Rx.set(t3._key(), e2);
-}
-async function Dx(t3, e2, i2 = false) {
-    const s2 = rx(t3),
-        n2 = function(t4, e3) {
-            return e3 ? Bw(e3) : (_w(t4._popupRedirectResolver, t4, "argument-error"), t4._popupRedirectResolver);
-        }(s2, e2),
-        r2 = new RedirectAction(s2, n2, i2),
-        o2 = await r2.execute();
-    return o2 && !i2 && (delete o2.user._redirectEventId, await s2._persistUserIfCurrent(o2.user), await s2._setRedirectUser(null, e2)), o2;
-}
-class AuthEventManager {
-    constructor(t3) {
-        this.auth = t3, this.cachedEventUids = /* @__PURE__ */ new Set(), this.consumers = /* @__PURE__ */ new Set(), this.queuedRedirectEvent = null, this.hasHandledPotentialRedirect = false, this.lastProcessedEventTime = Date.now();
-    }
-    registerConsumer(t3) {
-        this.consumers.add(t3), this.queuedRedirectEvent && this.isEventForConsumer(this.queuedRedirectEvent, t3) && (this.sendToConsumer(this.queuedRedirectEvent, t3), this.saveEventToCache(this.queuedRedirectEvent), this.queuedRedirectEvent = null);
-    }
-    unregisterConsumer(t3) {
-        this.consumers.delete(t3);
-    }
-    onEvent(t3) {
-        if (this.hasEventBeenHandled(t3))
-            return false;
-        let e2 = false;
-        return this.consumers.forEach((i2) => {
-            this.isEventForConsumer(t3, i2) && (e2 = true, this.sendToConsumer(t3, i2), this.saveEventToCache(t3));
-        }), this.hasHandledPotentialRedirect || ! function(t4) {
-            switch (t4.type) {
-                case "signInViaRedirect":
-                case "linkViaRedirect":
-                case "reauthViaRedirect":
-                    return true;
-                case "unknown":
-                    return Ox(t4);
-                default:
-                    return false;
-            }
-        }(t3) || (this.hasHandledPotentialRedirect = true, e2 || (this.queuedRedirectEvent = t3, e2 = true)), e2;
-    }
-    sendToConsumer(t3, e2) {
-        var i2;
-        if (t3.error && !Ox(t3)) {
-            const s2 = (null === (i2 = t3.error.code) || void 0 === i2 ? void 0 : i2.split("auth/")[1]) || "internal-error";
-            e2.onError(vw(this.auth, s2));
-        } else
-            e2.onAuthEvent(t3);
-    }
-    isEventForConsumer(t3, e2) {
-        const i2 = null === e2.eventId || !!t3.eventId && t3.eventId === e2.eventId;
-        return e2.filter.includes(t3.type) && i2;
-    }
-    hasEventBeenHandled(t3) {
-        return Date.now() - this.lastProcessedEventTime >= 6e5 && this.cachedEventUids.clear(), this.cachedEventUids.has(Lx(t3));
-    }
-    saveEventToCache(t3) {
-        this.cachedEventUids.add(Lx(t3)), this.lastProcessedEventTime = Date.now();
-    }
-}
-
-function Lx(t3) {
-    return [t3.type, t3.eventId, t3.sessionId, t3.tenantId].filter((t4) => t4).join("-");
-}
-
-function Ox({
-    type: t3,
-    error: e2
-}) {
-    return "unknown" === t3 && "auth/no-auth-event" === (null == e2 ? void 0 : e2.code);
-}
-const Fx = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/,
-    Nx = /^https?/;
-async function $x(t3) {
-    if (t3.config.emulator)
-        return;
-    const {
-        authorizedDomains: e2
-    } = await async function(t4, e3 = {}) {
-        return Pw(t4, "GET", "/v1/projects", e3);
-    }(t3);
-    for (const t4 of e2)
-        try {
-            if (Vx(t4))
-                return;
-        } catch (t5) {}
-    yw(t3, "unauthorized-domain");
-}
-
-function Vx(t3) {
-    const e2 = kw(),
-        {
-            protocol: i2,
-            hostname: s2
-        } = new URL(e2);
-    if (t3.startsWith("chrome-extension://")) {
-        const n3 = new URL(t3);
-        return "" === n3.hostname && "" === s2 ? "chrome-extension:" === i2 && t3.replace("chrome-extension://", "") === e2.replace("chrome-extension://", "") : "chrome-extension:" === i2 && n3.hostname === s2;
-    }
-    if (!Nx.test(i2))
-        return false;
-    if (Fx.test(t3))
-        return s2 === t3;
-    const n2 = t3.replace(/\./g, "\\.");
-    return new RegExp("^(.+\\." + n2 + "|" + n2 + ")$", "i").test(s2);
-}
-const zx = new Delay(3e4, 6e4);
-
-function Bx() {
-    const t3 = gx().___jsl;
-    if (null == t3 ? void 0 : t3.H) {
-        for (const e2 of Object.keys(t3.H))
-            if (t3.H[e2].r = t3.H[e2].r || [], t3.H[e2].L = t3.H[e2].L || [], t3.H[e2].r = [...t3.H[e2].L], t3.CP)
-                for (let e3 = 0; e3 < t3.CP.length; e3++)
-                    t3.CP[e3] = null;
-    }
-}
-
-function Ux(t3) {
-    return new Promise((e2, i2) => {
-        var s2, n2, r2;
-
-        function o2() {
-            Bx(), gapi.load("gapi.iframes", {
-                callback: () => {
-                    e2(gapi.iframes.getContext());
-                },
-                ontimeout: () => {
-                    Bx(), i2(vw(t3, "network-request-failed"));
-                },
-                timeout: zx.get()
-            });
-        }
-        if (null === (n2 = null === (s2 = gx().gapi) || void 0 === s2 ? void 0 : s2.iframes) || void 0 === n2 ? void 0 : n2.Iframe)
-            e2(gapi.iframes.getContext());
-        else {
-            if (!(null === (r2 = gx().gapi) || void 0 === r2 ? void 0 : r2.load)) {
-                const e3 = `__${"iframefcb"}${Math.floor(1e6 * Math.random())}`;
-                return gx()[e3] = () => {
-                    gapi.load ? o2() : i2(vw(t3, "network-request-failed"));
-                }, nx(`https://apis.google.com/js/api.js?onload=${e3}`).catch((t4) => i2(t4));
-            }
-            o2();
-        }
-    }).catch((t4) => {
-        throw jx = null, t4;
-    });
-}
-let jx = null;
-const Hx = new Delay(5e3, 15e3),
-    Wx = "__/auth/iframe",
-    qx = "emulator/auth/iframe",
-    Kx = {
-        style: {
-            position: "absolute",
-            top: "-100px",
-            width: "1px",
-            height: "1px"
-        },
-        "aria-hidden": "true",
-        tabindex: "-1"
-    },
-    Gx = /* @__PURE__ */ new Map([
-        ["identitytoolkit.googleapis.com", "p"],
-        ["staging-identitytoolkit.sandbox.googleapis.com", "s"],
-        ["test-identitytoolkit.sandbox.googleapis.com", "t"]
-    ]);
-
-function Yx(t3) {
-    const e2 = t3.config;
-    _w(e2.authDomain, t3, "auth-domain-config-required");
-    const i2 = e2.emulator ? Ew(e2, qx) : `https://${t3.config.authDomain}/${Wx}`,
-        s2 = {
-            apiKey: e2.apiKey,
-            appName: t3.name,
-            v: uf
-        },
-        n2 = Gx.get(t3.config.apiHost);
-    n2 && (s2.eid = n2);
-    const r2 = t3._getFrameworks();
-    return r2.length && (s2.fw = r2.join(",")), `${i2}?${Cd(s2).slice(1)}`;
-}
-async function Qx(t3) {
-    const e2 = await
-    function(t4) {
-        return jx = jx || Ux(t4), jx;
-    }(t3), i2 = gx().gapi;
-    return _w(i2, t3, "internal-error"), e2.open({
-        where: document.body,
-        url: Yx(t3),
-        messageHandlersFilter: i2.iframes.CROSS_ORIGIN_IFRAMES_FILTER,
-        attributes: Kx,
-        dontclear: true
-    }, (e3) => new Promise(async (i3, s2) => {
-        await e3.restyle({
-            setHideOnLeave: false
-        });
-        const n2 = vw(t3, "network-request-failed"),
-            r2 = gx().setTimeout(() => {
-                s2(n2);
-            }, Hx.get());
-
-        function o2() {
-            gx().clearTimeout(r2), i3(e3);
-        }
-        e3.ping(o2).then(o2, () => {
-            s2(n2);
-        });
-    }));
-}
-const Xx = {
-    location: "yes",
-    resizable: "yes",
-    statusbar: "yes",
-    toolbar: "no"
-};
-class AuthPopup {
-    constructor(t3) {
-        this.window = t3, this.associatedEvent = null;
-    }
-    close() {
-        if (this.window)
-            try {
-                this.window.close();
-            } catch (t3) {}
-    }
-}
-
-function Jx(t3, e2, i2, s2 = 500, n2 = 600) {
-    const r2 = Math.max((window.screen.availHeight - n2) / 2, 0).toString(),
-        o2 = Math.max((window.screen.availWidth - s2) / 2, 0).toString();
-    let a2 = "";
-    const l2 = Object.assign(Object.assign({}, Xx), {
-            width: s2.toString(),
-            height: n2.toString(),
-            top: r2,
-            left: o2
-        }),
-        h2 = kd().toLowerCase();
-    i2 && (a2 = Kw(h2) ? "_blank" : i2), Ww(h2) && (e2 = e2 || "http://localhost", l2.scrollbars = "yes");
-    const c2 = Object.entries(l2).reduce((t4, [e3, i3]) => `${t4}${e3}=${i3},`, "");
-    if (function(t4 = kd()) {
-            var e3;
-            return Jw(t4) && !!(null === (e3 = window.navigator) || void 0 === e3 ? void 0 : e3.standalone);
-        }(h2) && "_self" !== a2)
-        return function(t4, e3) {
-            const i3 = document.createElement("a");
-            i3.href = t4, i3.target = e3;
-            const s3 = document.createEvent("MouseEvent");
-            s3.initMouseEvent("click", true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 1, null), i3.dispatchEvent(s3);
-        }(e2 || "", a2), new AuthPopup(null);
-    const u2 = window.open(e2 || "", a2, c2);
-    _w(u2, t3, "popup-blocked");
-    try {
-        u2.focus();
-    } catch (t4) {}
-    return new AuthPopup(u2);
-}
-const Zx = "__/auth/handler",
-    tk = "emulator/auth/handler",
-    ek = encodeURIComponent("fac");
-async function ik(t3, e2, i2, s2, n2, r2) {
-    _w(t3.config.authDomain, t3, "auth-domain-config-required"), _w(t3.config.apiKey, t3, "invalid-api-key");
-    const o2 = {
-        apiKey: t3.config.apiKey,
-        appName: t3.name,
-        authType: i2,
-        redirectUrl: s2,
-        v: uf,
-        eventId: n2
-    };
-    if (e2 instanceof FederatedAuthProvider) {
-        e2.setDefaultLanguage(t3.languageCode), o2.providerId = e2.providerId || "",
-            function(t4) {
-                for (const e3 in t4)
-                    if (Object.prototype.hasOwnProperty.call(t4, e3))
-                        return false;
-                return true;
-            }(e2.getCustomParameters()) || (o2.customParameters = JSON.stringify(e2.getCustomParameters()));
-        for (const [t4, e3] of Object.entries(r2 || {}))
-            o2[t4] = e3;
-    }
-    if (e2 instanceof BaseOAuthProvider) {
-        const t4 = e2.getScopes().filter((t5) => "" !== t5);
-        t4.length > 0 && (o2.scopes = t4.join(","));
-    }
-    t3.tenantId && (o2.tid = t3.tenantId);
-    const a2 = o2;
-    for (const t4 of Object.keys(a2))
-        void 0 === a2[t4] && delete a2[t4];
-    const l2 = await t3._getAppCheckToken(),
-        h2 = l2 ? `#${ek}=${encodeURIComponent(l2)}` : "";
-    return `${function({ config: t4 }) {
-    if (!t4.emulator)
-      return `
-    https: //${t4.authDomain}/${Zx}`;
-        return Ew(t4, tk);
-}(t3)
-} ? $ {
-    Cd(a2).slice(1)
-}
-$ {
-    h2
-}
-`;
-}
-const sk = "webStorageSupport";
-const nk = class BrowserPopupRedirectResolver {
-  constructor() {
-    this.eventManagers = {}, this.iframes = {}, this.originValidationPromises = {}, this._redirectPersistence = px, this._completeRedirectFn = Dx, this._overrideRedirectResult = Ax;
-  }
-  async _openPopup(t3, e2, i2, s2) {
-    var n2;
-    xw(null === (n2 = this.eventManagers[t3._key()]) || void 0 === n2 ? void 0 : n2.manager, "_initialize() not called before _openPopup()");
-    return Jx(t3, await ik(t3, e2, i2, kw(), s2), mx());
-  }
-  async _openRedirect(t3, e2, i2, s2) {
-    await this._originValidation(t3);
-    return function(t4) {
-      gx().location.href = t4;
-    }(await ik(t3, e2, i2, kw(), s2)), new Promise(() => {
-    });
-  }
-  _initialize(t3) {
-    const e2 = t3._key();
-    if (this.eventManagers[e2]) {
-      const { manager: t4, promise: i3 } = this.eventManagers[e2];
-      return t4 ? Promise.resolve(t4) : (xw(i3, "If manager is not set, promise should be"), i3);
-    }
-    const i2 = this.initAndGetManager(t3);
-    return this.eventManagers[e2] = { promise: i2 }, i2.catch(() => {
-      delete this.eventManagers[e2];
-    }), i2;
-  }
-  async initAndGetManager(t3) {
-    const e2 = await Qx(t3), i2 = new AuthEventManager(t3);
-    return e2.register("authEvent", (e3) => {
-      _w(null == e3 ? void 0 : e3.authEvent, t3, "invalid-auth-event");
-      return { status: i2.onEvent(e3.authEvent) ? "ACK" : "ERROR" };
-    }, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER), this.eventManagers[t3._key()] = { manager: i2 }, this.iframes[t3._key()] = e2, i2;
-  }
-  _isIframeWebStorageSupported(t3, e2) {
-    this.iframes[t3._key()].send(sk, { type: sk }, (i2) => {
-      var s2;
-      const n2 = null === (s2 = null == i2 ? void 0 : i2[0]) || void 0 === s2 ? void 0 : s2[sk];
-      void 0 !== n2 && e2(!!n2), yw(t3, "internal-error");
-    }, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER);
-  }
-  _originValidation(t3) {
-    const e2 = t3._key();
-    return this.originValidationPromises[e2] || (this.originValidationPromises[e2] = $x(t3)), this.originValidationPromises[e2];
-  }
-  get _shouldInitProactively() {
-    return tx() || qw() || Jw();
-  }
-};
-var rk = "@firebase/auth", ok = "1.0.0";
-class AuthInterop {
-  constructor(t3) {
-    this.auth = t3, this.internalListeners = /* @__PURE__ */ new Map();
-  }
-  getUid() {
-    var t3;
-    return this.assertAuthConfigured(), (null === (t3 = this.auth.currentUser) || void 0 === t3 ? void 0 : t3.uid) || null;
-  }
-  async getToken(t3) {
-    if (this.assertAuthConfigured(), await this.auth._initializationPromise, !this.auth.currentUser)
-      return null;
-    return { accessToken: await this.auth.currentUser.getIdToken(t3) };
-  }
-  addAuthTokenListener(t3) {
-    if (this.assertAuthConfigured(), this.internalListeners.has(t3))
-      return;
-    const e2 = this.auth.onIdTokenChanged((e3) => {
-      t3((null == e3 ? void 0 : e3.stsTokenManager.accessToken) || null);
-    });
-    this.internalListeners.set(t3, e2), this.updateProactiveRefresh();
-  }
-  removeAuthTokenListener(t3) {
-    this.assertAuthConfigured();
-    const e2 = this.internalListeners.get(t3);
-    e2 && (this.internalListeners.delete(t3), e2(), this.updateProactiveRefresh());
-  }
-  assertAuthConfigured() {
-    _w(this.auth._initializationPromise, "dependent-sdk-initialized-before-auth");
-  }
-  updateProactiveRefresh() {
-    this.internalListeners.size > 0 ? this.auth._startProactiveRefresh() : this.auth._stopProactiveRefresh();
-  }
-}
-const ak = wd("authIdTokenMaxAge") || 300;
-let lk = null;
-var hk;
-hk = "Browser", lf(new Component("auth", (t3, { options: e2 }) => {
-  const i2 = t3.getProvider("app").getImmediate(), s2 = t3.getProvider("heartbeat"), n2 = t3.getProvider("app-check-internal"), { apiKey: r2, authDomain: o2 } = i2.options;
-  _w(r2 && !r2.includes(":"), "invalid-api-key", { appName: i2.name });
-  const a2 = { apiKey: r2, authDomain: o2, clientPlatform: hk, apiHost: "identitytoolkit.googleapis.com", tokenApiHost: "securetoken.googleapis.com", apiScheme: "https", sdkClientVersion: ex(hk) }, l2 = new AuthImpl(i2, s2, n2, a2);
-  return function(t4, e3) {
-    const i3 = (null == e3 ? void 0 : e3.persistence) || [], s3 = (Array.isArray(i3) ? i3 : [i3]).map(Bw);
-    (null == e3 ? void 0 : e3.errorMap) && t4._updateErrorMap(e3.errorMap), t4._initializeWithPersistence(s3, null == e3 ? void 0 : e3.popupRedirectResolver);
-  }(l2, e2), l2;
-}, "PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback((t3, e2, i2) => {
-  t3.getProvider("auth-internal").initialize();
-})), lf(new Component("auth-internal", (t3) => ((t4) => new AuthInterop(t4))(rx(t3.getProvider("auth").getImmediate())), "PRIVATE").setInstantiationMode("EXPLICIT")), pf(rk, ok, function(t3) {
-  switch (t3) {
-    case "Node":
-      return "node";
-    case "ReactNative":
-      return "rn";
-    case "Worker":
-      return "webworker";
-    case "Cordova":
-      return "cordova";
-    default:
-      return;
-  }
-}(hk)), pf(rk, ok, "esm2017");
-const ck = "firebasestorage.googleapis.com";
-class StorageError extends FirebaseError {
-  constructor(t3, e2, i2 = 0) {
-    super(fk(t3), `
-Firebase Storage: $ {
-    e2
-}($ {
-    fk(t3)
-})`), this.status_ = i2, this.customData = { serverResponse: null }, this._baseMessage = this.message, Object.setPrototypeOf(this, StorageError.prototype);
-  }
-  get status() {
-    return this.status_;
-  }
-  set status(t3) {
-    this.status_ = t3;
-  }
-  _codeEquals(t3) {
-    return fk(t3) === this.code;
-  }
-  get serverResponse() {
-    return this.customData.serverResponse;
-  }
-  set serverResponse(t3) {
-    this.customData.serverResponse = t3, this.customData.serverResponse ? this.message = `
-$ {
-    this._baseMessage
-}
-$ {
-    this.customData.serverResponse
-}
-` : this.message = this._baseMessage;
-  }
-}
-var uk, dk;
-function fk(t3) {
-  return "storage/" + t3;
-}
-function pk(t3) {
-  return new StorageError(uk.INVALID_ARGUMENT, t3);
-}
-function mk() {
-  return new StorageError(uk.APP_DELETED, "The Firebase app was deleted.");
-}
-!function(t3) {
-  t3.UNKNOWN = "unknown", t3.OBJECT_NOT_FOUND = "object-not-found", t3.BUCKET_NOT_FOUND = "bucket-not-found", t3.PROJECT_NOT_FOUND = "project-not-found", t3.QUOTA_EXCEEDED = "quota-exceeded", t3.UNAUTHENTICATED = "unauthenticated", t3.UNAUTHORIZED = "unauthorized", t3.UNAUTHORIZED_APP = "unauthorized-app", t3.RETRY_LIMIT_EXCEEDED = "retry-limit-exceeded", t3.INVALID_CHECKSUM = "invalid-checksum", t3.CANCELED = "canceled", t3.INVALID_EVENT_NAME = "invalid-event-name", t3.INVALID_URL = "invalid-url", t3.INVALID_DEFAULT_BUCKET = "invalid-default-bucket", t3.NO_DEFAULT_BUCKET = "no-default-bucket", t3.CANNOT_SLICE_BLOB = "cannot-slice-blob", t3.SERVER_FILE_WRONG_SIZE = "server-file-wrong-size", t3.NO_DOWNLOAD_URL = "no-download-url", t3.INVALID_ARGUMENT = "invalid-argument", t3.INVALID_ARGUMENT_COUNT = "invalid-argument-count", t3.APP_DELETED = "app-deleted", t3.INVALID_ROOT_OPERATION = "invalid-root-operation", t3.INVALID_FORMAT = "invalid-format", t3.INTERNAL_ERROR = "internal-error", t3.UNSUPPORTED_ENVIRONMENT = "unsupported-environment";
-}(uk || (uk = {}));
-class Location {
-  constructor(t3, e2) {
-    this.bucket = t3, this.path_ = e2;
-  }
-  get path() {
-    return this.path_;
-  }
-  get isRoot() {
-    return 0 === this.path.length;
-  }
-  fullServerUrl() {
-    const t3 = encodeURIComponent;
-    return "/b/" + t3(this.bucket) + "/o/" + t3(this.path);
-  }
-  bucketOnlyServerUrl() {
-    return "/b/" + encodeURIComponent(this.bucket) + "/o";
-  }
-  static makeFromBucketSpec(t3, e2) {
-    let i2;
-    try {
-      i2 = Location.makeFromUrl(t3, e2);
-    } catch (e3) {
-      return new Location(t3, "");
-    }
-    if ("" === i2.path)
-      return i2;
-    throw s2 = t3, new StorageError(uk.INVALID_DEFAULT_BUCKET, "Invalid default bucket '" + s2 + "'.");
-    var s2;
-  }
-  static makeFromUrl(t3, e2) {
-    let i2 = null;
-    const s2 = "([A-Za-z0-9.\\-_]+)";
-    const n2 = new RegExp("^gs://" + s2 + "(/(.*))?$", "i");
-    function r2(t4) {
-      t4.path_ = decodeURIComponent(t4.path);
-    }
-    const o2 = e2.replace(/[.]/g, "\\."), a2 = [{ regex: n2, indices: { bucket: 1, path: 3 }, postModify: function(t4) {
-      "/" === t4.path.charAt(t4.path.length - 1) && (t4.path_ = t4.path_.slice(0, -1));
-    } }, { regex: new RegExp(` ^ https ? : //${o2}/v[A-Za-z0-9_]+/b/${s2}/o(/([^?#]*).*)?$`, "i"), indices: { bucket: 1, path: 3 }, postModify: r2 }, { regex: new RegExp(`^https?://${e2 === ck ? "(?:storage.googleapis.com|storage.cloud.google.com)" : e2}/${s2}/([^?#]*)`, "i"), indices: { bucket: 1, path: 2 }, postModify: r2 }];
-    for (let e3 = 0; e3 < a2.length; e3++) {
-        const s3 = a2[e3],
-            n3 = s3.regex.exec(t3);
-        if (n3) {
-            const t4 = n3[s3.indices.bucket];
-            let e4 = n3[s3.indices.path];
-            e4 || (e4 = ""), i2 = new Location(t4, e4), s3.postModify(i2);
-            break;
-        }
-    }
-if (null == i2)
-    throw function(t4) {
-        return new StorageError(uk.INVALID_URL, "Invalid URL '" + t4 + "'.");
-    }(t3);
-return i2;
-}
-}
-class FailRequest {
-    constructor(t3) {
-        this.promise_ = Promise.reject(t3);
-    }
-    getPromise() {
-        return this.promise_;
-    }
-    cancel(t3 = false) {}
-}
-
-function gk(t3, e2, i2, s2) {
-    if (s2 < e2)
-        throw pk(`Invalid value for '${t3}'. Expected ${e2} or greater.`);
-    if (s2 > i2)
-        throw pk(`Invalid value for '${t3}'. Expected ${i2} or less.`);
-}! function(t3) {
-    t3[t3.NO_ERROR = 0] = "NO_ERROR", t3[t3.NETWORK_ERROR = 1] = "NETWORK_ERROR", t3[t3.ABORT = 2] = "ABORT";
-}(dk || (dk = {}));
-class NetworkRequest {
-    constructor(t3, e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2 = true) {
-        this.url_ = t3, this.method_ = e2, this.headers_ = i2, this.body_ = s2, this.successCodes_ = n2, this.additionalRetryCodes_ = r2, this.callback_ = o2, this.errorCallback_ = a2, this.timeout_ = l2, this.progressCallback_ = h2, this.connectionFactory_ = c2, this.retry = u2, this.pendingConnection_ = null, this.backoffId_ = null, this.canceled_ = false, this.appDelete_ = false, this.promise_ = new Promise((t4, e3) => {
-            this.resolve_ = t4, this.reject_ = e3, this.start_();
-        });
-    }
-    start_() {
-        const t3 = (t4, e3) => {
-                if (e3)
-                    return void t4(false, new RequestEndStatus(false, null, true));
-                const i2 = this.connectionFactory_();
-                this.pendingConnection_ = i2;
-                const s2 = (t5) => {
-                    const e4 = t5.loaded,
-                        i3 = t5.lengthComputable ? t5.total : -1;
-                    null !== this.progressCallback_ && this.progressCallback_(e4, i3);
-                };
-                null !== this.progressCallback_ && i2.addUploadProgressListener(s2), i2.send(this.url_, this.method_, this.body_, this.headers_).then(() => {
-                    null !== this.progressCallback_ && i2.removeUploadProgressListener(s2), this.pendingConnection_ = null;
-                    const e4 = i2.getErrorCode() === dk.NO_ERROR,
-                        n2 = i2.getStatus();
-                    if (!e4 || function(t5, e5) {
-                            const i3 = t5 >= 500 && t5 < 600,
-                                s3 = -1 !== [408, 429].indexOf(t5),
-                                n3 = -1 !== e5.indexOf(t5);
-                            return i3 || s3 || n3;
-                        }(n2, this.additionalRetryCodes_) && this.retry) {
-                        const e5 = i2.getErrorCode() === dk.ABORT;
-                        return void t4(false, new RequestEndStatus(false, null, e5));
-                    }
-                    const r2 = -1 !== this.successCodes_.indexOf(n2);
-                    t4(true, new RequestEndStatus(r2, i2));
-                });
-            },
-            e2 = (t4, e3) => {
-                const i2 = this.resolve_,
-                    s2 = this.reject_,
-                    n2 = e3.connection;
-                if (e3.wasSuccessCode)
-                    try {
-                        const t5 = this.callback_(n2, n2.getResponse());
-                        ! function(t6) {
-                            return void 0 !== t6;
-                        }(t5) ? i2(): i2(t5);
-                    } catch (t5) {
-                        s2(t5);
-                    }
-                else if (null !== n2) {
-                    const t5 = new StorageError(uk.UNKNOWN, "An unknown error occurred, please check the error payload for server response.");
-                    t5.serverResponse = n2.getErrorText(), this.errorCallback_ ? s2(this.errorCallback_(n2, t5)) : s2(t5);
-                } else if (e3.canceled) {
-                    s2(this.appDelete_ ? mk() : new StorageError(uk.CANCELED, "User canceled the upload/download."));
-                } else {
-                    s2(new StorageError(uk.RETRY_LIMIT_EXCEEDED, "Max retry time for operation exceeded, please try again."));
-                }
-            };
-        this.canceled_ ? e2(0, new RequestEndStatus(false, null, true)) : this.backoffId_ = function(t4, e3, i2) {
-            let s2 = 1,
-                n2 = null,
-                r2 = null,
-                o2 = false,
-                a2 = 0;
-
-            function l2() {
-                return 2 === a2;
-            }
-            let h2 = false;
-
-            function c2(...t5) {
-                h2 || (h2 = true, e3.apply(null, t5));
-            }
-
-            function u2(e4) {
-                n2 = setTimeout(() => {
-                    n2 = null, t4(f2, l2());
-                }, e4);
-            }
-
-            function d2() {
-                r2 && clearTimeout(r2);
-            }
-
-            function f2(t5, ...e4) {
-                if (h2)
-                    return void d2();
-                if (t5)
-                    return d2(), void c2.call(null, t5, ...e4);
-                if (l2() || o2)
-                    return d2(), void c2.call(null, t5, ...e4);
-                let i3;
-                s2 < 64 && (s2 *= 2), 1 === a2 ? (a2 = 2, i3 = 0) : i3 = 1e3 * (s2 + Math.random()), u2(i3);
-            }
-            let p2 = false;
-
-            function m2(t5) {
-                p2 || (p2 = true, d2(), h2 || (null !== n2 ? (t5 || (a2 = 2), clearTimeout(n2), u2(0)) : t5 || (a2 = 1)));
-            }
-            return u2(0), r2 = setTimeout(() => {
-                o2 = true, m2(true);
-            }, i2), m2;
-        }(t3, e2, this.timeout_);
-    }
-    getPromise() {
-        return this.promise_;
-    }
-    cancel(t3) {
-        this.canceled_ = true, this.appDelete_ = t3 || false, null !== this.backoffId_ && function(t4) {
-            t4(false);
-        }(this.backoffId_), null !== this.pendingConnection_ && this.pendingConnection_.abort();
-    }
-}
-class RequestEndStatus {
-    constructor(t3, e2, i2) {
-        this.wasSuccessCode = t3, this.connection = e2, this.canceled = !!i2;
-    }
-}
-
-function yk(t3, e2, i2, s2, n2, r2, o2 = true) {
-    const a2 = function(t4) {
-            const e3 = encodeURIComponent;
-            let i3 = "?";
-            for (const s3 in t4)
-                t4.hasOwnProperty(s3) && (i3 = i3 + (e3(s3) + "=") + e3(t4[s3]) + "&");
-            return i3 = i3.slice(0, -1), i3;
-        }(t3.urlParams),
-        l2 = t3.url + a2,
-        h2 = Object.assign({}, t3.headers);
-    return function(t4, e3) {
-            e3 && (t4["X-Firebase-GMPID"] = e3);
-        }(h2, e2),
-        function(t4, e3) {
-            null !== e3 && e3.length > 0 && (t4.Authorization = "Firebase " + e3);
-        }(h2, i2),
-        function(t4, e3) {
-            t4["X-Firebase-Storage-Version"] = "webjs/" + (null != e3 ? e3 : "AppManager");
-        }(h2, r2),
-        function(t4, e3) {
-            null !== e3 && (t4["X-Firebase-AppCheck"] = e3);
-        }(h2, s2), new NetworkRequest(l2, t3.method, h2, t3.body, t3.successCodes, t3.additionalRetryCodes, t3.handler, t3.errorHandler, t3.timeout, t3.progressCallback, n2, o2);
-}
-class Reference {
-    constructor(t3, e2) {
-        this._service = t3, this._location = e2 instanceof Location ? e2 : Location.makeFromUrl(e2, t3.host);
-    }
-    toString() {
-        return "gs://" + this._location.bucket + "/" + this._location.path;
-    }
-    _newRef(t3, e2) {
-        return new Reference(t3, e2);
-    }
-    get root() {
-        const t3 = new Location(this._location.bucket, "");
-        return this._newRef(this._service, t3);
-    }
-    get bucket() {
-        return this._location.bucket;
-    }
-    get fullPath() {
-        return this._location.path;
-    }
-    get name() {
-        return function(t3) {
-            const e2 = t3.lastIndexOf("/", t3.length - 2);
-            return -1 === e2 ? t3 : t3.slice(e2 + 1);
-        }(this._location.path);
-    }
-    get storage() {
-        return this._service;
-    }
-    get parent() {
-        const t3 = function(t4) {
-            if (0 === t4.length)
-                return null;
-            const e3 = t4.lastIndexOf("/");
-            return -1 === e3 ? "" : t4.slice(0, e3);
-        }(this._location.path);
-        if (null === t3)
-            return null;
-        const e2 = new Location(this._location.bucket, t3);
-        return new Reference(this._service, e2);
-    }
-    _throwIfRoot(t3) {
-        if ("" === this._location.path)
-            throw function(t4) {
-                return new StorageError(uk.INVALID_ROOT_OPERATION, "The operation '" + t4 + "' cannot be performed on a root reference, create a non-root reference using child, such as .child('file.png').");
-            }(t3);
-    }
-}
-
-function vk(t3, e2) {
-    const i2 = null == e2 ? void 0 : e2.storageBucket;
-    return null == i2 ? null : Location.makeFromBucketSpec(i2, t3);
-}
-class FirebaseStorageImpl {
-    constructor(t3, e2, i2, s2, n2) {
-        this.app = t3, this._authProvider = e2, this._appCheckProvider = i2, this._url = s2, this._firebaseVersion = n2, this._bucket = null, this._host = ck, this._protocol = "https", this._appId = null, this._deleted = false, this._maxOperationRetryTime = 12e4, this._maxUploadRetryTime = 6e5, this._requests = /* @__PURE__ */ new Set(), this._bucket = null != s2 ? Location.makeFromBucketSpec(s2, this._host) : vk(this._host, this.app.options);
-    }
-    get host() {
-        return this._host;
-    }
-    set host(t3) {
-        this._host = t3, null != this._url ? this._bucket = Location.makeFromBucketSpec(this._url, t3) : this._bucket = vk(t3, this.app.options);
-    }
-    get maxUploadRetryTime() {
-        return this._maxUploadRetryTime;
-    }
-    set maxUploadRetryTime(t3) {
-        gk("time", 0, Number.POSITIVE_INFINITY, t3), this._maxUploadRetryTime = t3;
-    }
-    get maxOperationRetryTime() {
-        return this._maxOperationRetryTime;
-    }
-    set maxOperationRetryTime(t3) {
-        gk("time", 0, Number.POSITIVE_INFINITY, t3), this._maxOperationRetryTime = t3;
-    }
-    async _getAuthToken() {
-        if (this._overrideAuthToken)
-            return this._overrideAuthToken;
-        const t3 = this._authProvider.getImmediate({
-            optional: true
-        });
-        if (t3) {
-            const e2 = await t3.getToken();
-            if (null !== e2)
-                return e2.accessToken;
-        }
-        return null;
-    }
-    async _getAppCheckToken() {
-        const t3 = this._appCheckProvider.getImmediate({
-            optional: true
-        });
-        if (t3) {
-            return (await t3.getToken()).token;
-        }
-        return null;
-    }
-    _delete() {
-        return this._deleted || (this._deleted = true, this._requests.forEach((t3) => t3.cancel()), this._requests.clear()), Promise.resolve();
-    }
-    _makeStorageReference(t3) {
-        return new Reference(this, t3);
-    }
-    _makeRequest(t3, e2, i2, s2, n2 = true) {
-        if (this._deleted)
-            return new FailRequest(mk());
-        {
-            const r2 = yk(t3, this._appId, i2, s2, e2, this._firebaseVersion, n2);
-            return this._requests.add(r2), r2.getPromise().then(() => this._requests.delete(r2), () => this._requests.delete(r2)), r2;
-        }
-    }
-    async makeRequestWithTokens(t3, e2) {
-        const [i2, s2] = await Promise.all([this._getAuthToken(), this._getAppCheckToken()]);
-        return this._makeRequest(t3, e2, i2, s2).getPromise();
-    }
-}
-const bk = "@firebase/storage",
-    _k = "0.11.2",
-    wk = "storage";
-
-function xk(t3, {
-    instanceIdentifier: e2
-}) {
-    const i2 = t3.getProvider("app").getImmediate(),
-        s2 = t3.getProvider("auth-internal"),
-        n2 = t3.getProvider("app-check-internal");
-    return new FirebaseStorageImpl(i2, s2, n2, e2, uf);
-}
-lf(new Component(wk, xk, "PUBLIC").setMultipleInstances(true)), pf(bk, _k, ""), pf(bk, _k, "esm2017");
-const kk = df({
-        apiKey: "AIzaSyB9Ogv6Vbwfy6_I0aLEfcpsPhqhlc4FSTw",
-        authDomain: "auth.finlab.tw",
-        projectId: "fdata-299302",
-        storageBucket: "fdata-299302.appspot.com",
-        messagingSenderId: "748308483506",
-        appId: "1:748308483506:web:7c78dd82b422cd4ea5a8ab"
-    }),
-    Tk = function(t3, e2) {
-        const i2 = "string" == typeof t3 ? t3 : e2 || "(default)",
-            s2 = hf("object" == typeof t3 ? t3 : ff(), "firestore").getImmediate({
-                identifier: i2
-            });
-        if (!s2._initialized) {
-            const t4 = bd("firestore");
-            t4 && function(t5, e3, i3, s3 = {}) {
-                var n2;
-                const r2 = (t5 = nw(t5, Firestore$1))._getSettings(),
-                    o2 = `${e3}:${i3}`;
-                if ("firestore.googleapis.com" !== r2.host && r2.host !== o2 && Wy("Host has been set in both settings() and connectFirestoreEmulator(), emulator host will be used."), t5._setSettings(Object.assign(Object.assign({}, r2), {
-                        host: o2,
-                        ssl: false
-                    })), s3.mockUserToken) {
-                    let e4, i4;
-                    if ("string" == typeof s3.mockUserToken)
-                        e4 = s3.mockUserToken, i4 = User.MOCK_USER;
-                    else {
-                        e4 = xd(s3.mockUserToken, null === (n2 = t5._app) || void 0 === n2 ? void 0 : n2.options.projectId);
-                        const r3 = s3.mockUserToken.sub || s3.mockUserToken.user_id;
-                        if (!r3)
-                            throw new FirestoreError(Qy.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
-                        i4 = new User(r3);
-                    }
-                    t5._authCredentials = new __PRIVATE_EmulatorAuthCredentialsProvider(new __PRIVATE_OAuthToken(e4, i4));
-                }
-            }(s2, ...t4);
-        }
-        return s2;
-    }(kk);
-! function(t3 = ff(), e2) {
-    const i2 = hf(t3 = Md(t3), wk).getImmediate({
-            identifier: e2
-        }),
-        s2 = bd("storage");
-    s2 && function(t4, e3, i3, s3 = {}) {
-        ! function(t5, e4, i4, s4 = {}) {
-            t5.host = `${e4}:${i4}`, t5._protocol = "http";
-            const {
-                mockUserToken: n2
-            } = s4;
-            n2 && (t5._overrideAuthToken = "string" == typeof n2 ? n2 : xd(n2, t5.app.options.projectId));
-        }(t4, e3, i3, s3);
-    }(i2, ...s2);
-}(kk);
-const Sk = function(t3 = ff()) {
-    const e2 = hf(t3, "auth");
-    if (e2.isInitialized())
-        return e2.getImmediate();
-    const i2 = function(t4, e3) {
-            const i3 = hf(t4, "auth");
-            if (i3.isInitialized()) {
-                const t5 = i3.getImmediate();
-                if (Sd(i3.getOptions(), null != e3 ? e3 : {}))
-                    return t5;
-                yw(t5, "already-initialized");
-            }
-            return i3.initialize({
-                options: e3
-            });
-        }(t3, {
-            popupRedirectResolver: nk,
-            persistence: [Sx, fx, px]
-        }),
-        s2 = wd("authTokenSyncURL");
-    if (s2) {
-        const t4 = (n2 = s2, async (t5) => {
-            const e3 = t5 && await t5.getIdTokenResult(),
-                i3 = e3 && (( /* @__PURE__ */ new Date()).getTime() - Date.parse(e3.issuedAtTime)) / 1e3;
-            if (i3 && i3 > ak)
-                return;
-            const s3 = null == e3 ? void 0 : e3.token;
-            lk !== s3 && (lk = s3, await fetch(n2, {
-                method: s3 ? "POST" : "DELETE",
-                headers: s3 ? {
-                    Authorization: `Bearer ${s3}`
-                } : {}
-            }));
-        });
-        ! function(t5, e3, i3) {
-            Md(t5).beforeAuthStateChanged(e3, i3);
-        }(i2, t4, () => t4(i2.currentUser)),
-        function(t5, e3, i3, s3) {
-            Md(t5).onIdTokenChanged(e3, i3, s3);
-        }(i2, (e3) => t4(e3));
-    }
-    var n2;
-    const r2 = vd("auth");
-    return r2 && ox(i2, `http://${r2}`), i2;
-}(kk);
-Sk.useDeviceLanguage(),
-    function(t3, e2) {
-        Md(t3).setPersistence(e2);
-    }(Sk, fx);
-class Stock {
-    constructor(t3) {
-        this.timestamps = t3.date, this.open = t3.open, this.high = t3.high, this.close = t3.close, this.low = t3.low, this.volume = t3.volume;
-    }
-    createTradingviewSeries(t3, e2 = 0, i2 = -1, s2 = 500) {
-        const n2 = this[t3],
-            r2 = this.timestamps.map((t4, e3) => ({
-                time: t4,
-                value: n2[e3]
-            })).slice(this.indexOfTimestamps(e2), this.indexOfTimestamps(i2) + 1),
-            o2 = Math.round(r2.length / s2);
-        return r2.filter((t4, e3) => e3 % o2 == 0 || e3 === r2.length - 1);
-    }
-    indexOfTimestamps(t3) {
-        return "string" == typeof t3 ? this.timestamps.findIndex((e2) => e2 === t3) : t3 < 0 ? Math.max(this.timestamps.length + t3, 0) : Math.min(t3, this.timestamps.length - 1);
-    }
-    createCandlestickSeries(t3 = 0, e2 = -1) {
-        const i2 = this.indexOfTimestamps(t3),
-            s2 = this.indexOfTimestamps(e2) + 1;
-        return this.timestamps.slice(i2, s2).map((t4, e3) => ({
-            time: t4,
-            open: this.open[i2 + e3],
-            high: this.high[i2 + e3],
-            low: this.low[i2 + e3],
-            close: this.close[i2 + e3]
-        }));
-    }
-}
-const Ek = cd(null);
-
-function Ck(t3) {
-    let e2, i2, s2, r2, o2, a2, l2, h2, c2, u2, d2, f2, p2, m2, g2, y2, v2, b2, w2, x2, k2, T2, C2 = t3[0].assetId + "",
-        R2 = t3[0].assetName + "";
-    return {
-        c() {
-            e2 = P("h3"), i2 = D(C2), s2 = $(), r2 = D(R2), o2 = $(), a2 = P("button"), a2.textContent = "✕", l2 = $(), h2 = P("div"), u2 = $(), d2 = P("div"), p2 = $(), m2 = P("div"), g2 = P("span"), g2.textContent = "報酬曲線圖", y2 = $(), v2 = P("label"), b2 = P("input"), w2 = $(), x2 = P("span"), x2.textContent = "蠟燭圖", U(e2, "class", "font-bold text-lg"), U(a2, "class", "btn btn-sm btn-circle btn-ghost absolute right-2 top-2"), U(h2, "class", c2 = "text-primary h-64 w-full z-0 " + (t3[3] ? "hidden" : "block")), U(d2, "class", f2 = "text-primary h-64 w-full z-0 " + (t3[3] ? "block" : "hidden")), U(g2, "class", "text-gray-500"), U(b2, "type", "checkbox"), U(b2, "class", "toggle toggle-primary toggle-md mx-2"), U(x2, "class", "text-gray-500"), U(m2, "class", "mt-4 flex item-center justify-center");
-        },
-        m(n2, c3) {
-            S(n2, e2, c3), _(e2, i2), _(e2, s2), _(e2, r2), S(n2, o2, c3), S(n2, a2, c3), S(n2, l2, c3), S(n2, h2, c3), t3[6](h2), S(n2, u2, c3), S(n2, d2, c3), t3[7](d2), S(n2, p2, c3), S(n2, m2, c3), _(m2, g2), _(m2, y2), _(m2, v2), _(v2, b2), b2.checked = t3[3], _(m2, w2), _(m2, x2), k2 || (T2 = [B(a2, "click", t3[4]), B(b2, "change", t3[8])], k2 = true);
-        },
-        p(t4, e3) {
-            1 & e3 && C2 !== (C2 = t4[0].assetId + "") && H(i2, C2), 1 & e3 && R2 !== (R2 = t4[0].assetName + "") && H(r2, R2), 8 & e3 && c2 !== (c2 = "text-primary h-64 w-full z-0 " + (t4[3] ? "hidden" : "block")) && U(h2, "class", c2), 8 & e3 && f2 !== (f2 = "text-primary h-64 w-full z-0 " + (t4[3] ? "block" : "hidden")) && U(d2, "class", f2), 8 & e3 && (b2.checked = t4[3]);
-        },
-        d(i3) {
-            i3 && (E(e2), E(o2), E(a2), E(l2), E(h2), E(u2), E(d2), E(p2), E(m2)), t3[6](null), t3[7](null), k2 = false, n(T2);
-        }
-    };
-}
-
-function Ik(e2) {
-    let i2, s2 = e2[0] && Ck(e2);
-    return {
-        c() {
-            i2 = P("div"), s2 && s2.c(), U(i2, "class", "card bg-base-100 shadow-xl text-base-content-300 p-4");
-        },
-        m(t3, e3) {
-            S(t3, i2, e3), s2 && s2.m(i2, null);
-        },
-        p(t3, [e3]) {
-            t3[0] ? s2 ? s2.p(t3, e3) : (s2 = Ck(t3), s2.c(), s2.m(i2, null)) : s2 && (s2.d(1), s2 = null);
-        },
-        i: t,
-        o: t,
-        d(t3) {
-            t3 && E(i2), s2 && s2.d();
-        }
-    };
-}
-
-function Mk(t3, e2, i2) {
-    let s2, n2, r2, o2;
-    async function l2(t4) {
-        await async function(t5) {
-            const e3 = await f2(t5),
-                i3 = e3.timestamps.length,
-                s3 = e3.timestamps.length / (i3 / 100);
-            c2 = e3.createTradingviewSeries("close", 0, -1, s3), c2.forEach((t6) => {
-                try {
-                    if (!t6.time || "number" != typeof t6.time.seconds)
-                        throw new Error("Invalid or missing time.seconds property");
-                    {
-                        const e4 = 1e3 * t6.time.seconds,
-                            i4 = new Date(e4);
-                        if (isNaN(i4.getTime()))
-                            throw new Error("Invalid date");
-                        t6.time = {
-                            day: i4.getDate(),
-                            month: i4.getMonth() + 1,
-                            year: i4.getFullYear()
-                        };
-                    }
-                } catch (e4) {
-                    t6.time = {
-                        day: null,
-                        month: null,
-                        year: null
-                    };
-                }
-            });
-        }(t4.assetId), await async function(t5) {
-                const e3 = await f2(t5),
-                    i3 = e3.createCandlestickSeries(0, -1);
-                i3.forEach((t6) => {
-                    try {
-                        if (!t6.time || "object" != typeof t6.time || !("seconds" in t6.time))
-                            throw new Error("Invalid or missing time property");
-                        {
-                            const e4 = new Date(1e3 * t6.time.seconds);
-                            if (isNaN(e4.getTime()))
-                                throw new Error("Invalid date");
-                            t6.time = e4.toISOString().split("T")[0];
-                        }
-                    } catch (e4) {
-                        console.error("Error processing time:", t6.time, e4), t6.time = null;
-                    }
-                }), h2 = i3;
-            }(t4.assetId),
-            function() {
-                d2 || (d2 = new TwChart(o2, false));
-                d2.setTheme("dark" === Ek ? "dark" : "light"), d2.addCandlestickSeries(), d2.updateCandlestickSeriesData(h2);
-            }(),
-            function() {
-                u2 || (u2 = new TwChart(r2, true));
-                u2.setTheme("dark" === Ek ? "dark" : "light"), u2.resetAreaSeries(0), u2.resetAreaSeries(1), u2.series[0].setData(c2);
-            }();
-    }
-    a(t3, ud, (t4) => i2(5, s2 = t4));
-    let h2, c2, u2 = null,
-        d2 = null;
-    async function f2(t4) {
-        const e3 = rw(Tk, "twStock", t4);
-        if (e3) {
-            const t5 = (await cw(e3)).data();
-            return new Stock(t5.price);
-        }
-    }
-    const p2 = bt();
-
-    function m2() {
-        p2("close"), ud.set(null);
-    }
-
-    function g2(t4) {
-        "Escape" === t4.key && m2();
-    }
-    pt(() => {
-        window.addEventListener("keydown", g2);
-    }), yt(() => {
-        window.removeEventListener("keydown", g2);
-    });
-    let y2 = true;
-    return t3.$$.update = () => {
-        32 & t3.$$.dirty && i2(0, n2 = s2), 1 & t3.$$.dirty && n2 && l2(n2);
-    }, [n2, r2, o2, y2, m2, s2, function(t4) {
-        xt[t4 ? "unshift" : "push"](() => {
-            r2 = t4, i2(1, r2);
-        });
-    }, function(t4) {
-        xt[t4 ? "unshift" : "push"](() => {
-            o2 = t4, i2(2, o2);
-        });
-    }, function() {
-        y2 = this.checked, i2(3, y2);
-    }];
-}
-class StockBlock extends SvelteComponent {
-    constructor(t3) {
-        super(), ve(this, t3, Mk, Ik, o, {});
-    }
-}
-
-function Pk(t3, e2, i2) {
-    const s2 = t3.slice();
-    return s2[18] = e2[i2], s2;
-}
-
-function Rk(t3, e2, i2) {
-    const s2 = t3.slice();
-    return s2[21] = e2[i2], s2;
-}
-we(StockBlock, {}, [], [], true);
-const Ak = (t3) => ({
-        row: 2 & t3
-    }),
-    Dk = (t3) => ({
-        row: t3[18]
-    }),
-    Lk = (t3) => ({
-        row: 2 & t3
-    }),
-    Ok = (t3) => ({
-        row: t3[18]
-    }),
-    Fk = (t3) => ({
-        row: 2 & t3
-    }),
-    Nk = (t3) => ({
-        row: t3[18]
-    }),
-    $k = (t3) => ({
-        row: 2 & t3
-    }),
-    Vk = (t3) => ({
-        row: t3[18]
-    }),
-    zk = (t3) => ({
-        row: 2 & t3
-    }),
-    Bk = (t3) => ({
-        row: t3[18]
-    }),
-    Uk = (t3) => ({
-        row: 2 & t3
-    }),
-    jk = (t3) => ({
-        row: t3[18]
-    });
-
-function Hk(t3, e2, i2) {
-    const s2 = t3.slice();
-    return s2[21] = e2[i2], s2;
-}
-
-function Wk(t3) {
-    let e2, i2, s2 = t3[3] ? "▲" : "▼";
-    return {
-        c() {
-            e2 = P("span"), i2 = D(s2), U(e2, "class", "pl-2");
-        },
-        m(t4, s3) {
-            S(t4, e2, s3), _(e2, i2);
-        },
-        p(t4, e3) {
-            8 & e3 && s2 !== (s2 = t4[3] ? "▲" : "▼") && H(i2, s2);
-        },
-        d(t4) {
-            t4 && E(e2);
-        }
-    };
-}
-
-function qk(t3, e2) {
-    let i2, s2, n2, r2, o2, a2, l2, h2 = e2[21].name + "",
-        c2 = e2[2] === e2[21].key && Wk(e2);
-
-    function u2() {
-        return e2[13](e2[21]);
-    }
-    return {
-        key: t3,
-        first: null,
-        c() {
-            i2 = P("th"), s2 = D(h2), n2 = $(), c2 && c2.c(), r2 = $(), G(i2, "width", e2[21].width), U(i2, "class", o2 = "tracking-wider cursor-pointer font-bold whitespace-nowrap " + ("name" === e2[21].key ? "pl-0 text-left sticky left-0 bg-base-200" : "text-right") + " " + (e2[21].sort, " ") + (e2[2] === e2[21].key ? "text-primary" : "")), this.first = i2;
-        },
-        m(t4, e3) {
-            S(t4, i2, e3), _(i2, s2), _(i2, n2), c2 && c2.m(i2, null), _(i2, r2), a2 || (l2 = B(i2, "click", u2), a2 = true);
-        },
-        p(t4, n3) {
-            e2 = t4, 1 & n3 && h2 !== (h2 = e2[21].name + "") && H(s2, h2), e2[2] === e2[21].key ? c2 ? c2.p(e2, n3) : (c2 = Wk(e2), c2.c(), c2.m(i2, r2)) : c2 && (c2.d(1), c2 = null), 1 & n3 && G(i2, "width", e2[21].width), 5 & n3 && o2 !== (o2 = "tracking-wider cursor-pointer font-bold whitespace-nowrap " + ("name" === e2[21].key ? "pl-0 text-left sticky left-0 bg-base-200" : "text-right") + " " + (e2[21].sort, " ") + (e2[2] === e2[21].key ? "text-primary" : "")) && U(i2, "class", o2);
-        },
-        d(t4) {
-            t4 && E(i2), c2 && c2.d(), a2 = false, l2();
-        }
-    };
-}
-
-function Kk(e2) {
-    let i2, s2 = (e2[18][e2[21].key] ? e2[18][e2[21].key] : "-") + "";
-    return {
-        c() {
-            i2 = D(s2);
-        },
-        m(t3, e3) {
-            S(t3, i2, e3);
-        },
-        p(t3, e3) {
-            3 & e3 && s2 !== (s2 = (t3[18][t3[21].key] ? t3[18][t3[21].key] : "-") + "") && H(i2, s2);
-        },
-        i: t,
-        o: t,
-        d(t3) {
-            t3 && E(i2);
-        }
-    };
-}
-
-function Gk(t3) {
-    let e2;
-    const i2 = t3[12].RSV,
-        s2 = l(i2, t3, t3[11], Dk),
-        n2 = s2 || function(t4) {
-            let e3, i3 = t4[18].RSV + "";
-            return {
-                c() {
-                    e3 = D(i3);
-                },
-                m(t5, i4) {
-                    S(t5, e3, i4);
-                },
-                p(t5, s3) {
-                    2 & s3 && i3 !== (i3 = t5[18].RSV + "") && H(e3, i3);
-                },
-                d(t5) {
-                    t5 && E(e3);
-                }
-            };
-        }(t3);
-    return {
-        c() {
-            n2 && n2.c();
-        },
-        m(t4, i3) {
-            n2 && n2.m(t4, i3), e2 = true;
-        },
-        p(t4, r2) {
-            s2 ? s2.p && (!e2 || 2050 & r2) && u(s2, i2, t4, t4[11], e2 ? c(i2, t4[11], r2, Ak) : d(t4[11]), Dk) : n2 && n2.p && (!e2 || 2 & r2) && n2.p(t4, e2 ? r2 : -1);
-        },
-        i(t4) {
-            e2 || (le(n2, t4), e2 = true);
-        },
-        o(t4) {
-            he(n2, t4), e2 = false;
-        },
-        d(t4) {
-            n2 && n2.d(t4);
-        }
-    };
-}
-
-function Yk(t3) {
-    let e2;
-    const i2 = t3[12].currentWeight,
-        s2 = l(i2, t3, t3[11], Ok),
-        n2 = s2 || function(t4) {
-            let e3, i3 = t4[18].currentWeight + "";
-            return {
-                c() {
-                    e3 = D(i3);
-                },
-                m(t5, i4) {
-                    S(t5, e3, i4);
-                },
-                p(t5, s3) {
-                    2 & s3 && i3 !== (i3 = t5[18].currentWeight + "") && H(e3, i3);
-                },
-                d(t5) {
-                    t5 && E(e3);
-                }
-            };
-        }(t3);
-    return {
-        c() {
-            n2 && n2.c();
-        },
-        m(t4, i3) {
-            n2 && n2.m(t4, i3), e2 = true;
-        },
-        p(t4, r2) {
-            s2 ? s2.p && (!e2 || 2050 & r2) && u(s2, i2, t4, t4[11], e2 ? c(i2, t4[11], r2, Lk) : d(t4[11]), Ok) : n2 && n2.p && (!e2 || 2 & r2) && n2.p(t4, e2 ? r2 : -1);
-        },
-        i(t4) {
-            e2 || (le(n2, t4), e2 = true);
-        },
-        o(t4) {
-            he(n2, t4), e2 = false;
-        },
-        d(t4) {
-            n2 && n2.d(t4);
-        }
-    };
-}
-
-function Qk(t3) {
-    let e2;
-    const i2 = t3[12].profit,
-        s2 = l(i2, t3, t3[11], Nk),
-        n2 = s2 || function(t4) {
-            let e3, i3 = t4[18].profit + "";
-            return {
-                c() {
-                    e3 = D(i3);
-                },
-                m(t5, i4) {
-                    S(t5, e3, i4);
-                },
-                p(t5, s3) {
-                    2 & s3 && i3 !== (i3 = t5[18].profit + "") && H(e3, i3);
-                },
-                d(t5) {
-                    t5 && E(e3);
-                }
-            };
-        }(t3);
-    return {
-        c() {
-            n2 && n2.c();
-        },
-        m(t4, i3) {
-            n2 && n2.m(t4, i3), e2 = true;
-        },
-        p(t4, r2) {
-            s2 ? s2.p && (!e2 || 2050 & r2) && u(s2, i2, t4, t4[11], e2 ? c(i2, t4[11], r2, Fk) : d(t4[11]), Nk) : n2 && n2.p && (!e2 || 2 & r2) && n2.p(t4, e2 ? r2 : -1);
-        },
-        i(t4) {
-            e2 || (le(n2, t4), e2 = true);
-        },
-        o(t4) {
-            he(n2, t4), e2 = false;
-        },
-        d(t4) {
-            n2 && n2.d(t4);
-        }
-    };
-}
-
-function Xk(t3) {
-    let e2;
-    const i2 = t3[12].entryDate,
-        s2 = l(i2, t3, t3[11], Vk),
-        n2 = s2 || function(t4) {
-            let e3, i3 = t4[18].entryDate + "";
-            return {
-                c() {
-                    e3 = D(i3);
-                },
-                m(t5, i4) {
-                    S(t5, e3, i4);
-                },
-                p(t5, s3) {
-                    2 & s3 && i3 !== (i3 = t5[18].entryDate + "") && H(e3, i3);
-                },
-                d(t5) {
-                    t5 && E(e3);
-                }
-            };
-        }(t3);
-    return {
-        c() {
-            n2 && n2.c();
-        },
-        m(t4, i3) {
-            n2 && n2.m(t4, i3), e2 = true;
-        },
-        p(t4, r2) {
-            s2 ? s2.p && (!e2 || 2050 & r2) && u(s2, i2, t4, t4[11], e2 ? c(i2, t4[11], r2, $k) : d(t4[11]), Vk) : n2 && n2.p && (!e2 || 2 & r2) && n2.p(t4, e2 ? r2 : -1);
-        },
-        i(t4) {
-            e2 || (le(n2, t4), e2 = true);
-        },
-        o(t4) {
-            he(n2, t4), e2 = false;
-        },
-        d(t4) {
-            n2 && n2.d(t4);
-        }
-    };
-}
-
-function Jk(t3) {
-    let e2;
-    const i2 = t3[12].action,
-        s2 = l(i2, t3, t3[11], Bk),
-        n2 = s2 || function(t4) {
-            let e3, i3 = t4[18].action + "";
-            return {
-                c() {
-                    e3 = D(i3);
-                },
-                m(t5, i4) {
-                    S(t5, e3, i4);
-                },
-                p(t5, s3) {
-                    2 & s3 && i3 !== (i3 = t5[18].action + "") && H(e3, i3);
-                },
-                d(t5) {
-                    t5 && E(e3);
-                }
-            };
-        }(t3);
-    return {
-        c() {
-            n2 && n2.c();
-        },
-        m(t4, i3) {
-            n2 && n2.m(t4, i3), e2 = true;
-        },
-        p(t4, r2) {
-            s2 ? s2.p && (!e2 || 2050 & r2) && u(s2, i2, t4, t4[11], e2 ? c(i2, t4[11], r2, zk) : d(t4[11]), Bk) : n2 && n2.p && (!e2 || 2 & r2) && n2.p(t4, e2 ? r2 : -1);
-        },
-        i(t4) {
-            e2 || (le(n2, t4), e2 = true);
-        },
-        o(t4) {
-            he(n2, t4), e2 = false;
-        },
-        d(t4) {
-            n2 && n2.d(t4);
-        }
-    };
-}
-
-function Zk(t3) {
-    let e2;
-    const i2 = t3[12].name,
-        s2 = l(i2, t3, t3[11], jk),
-        n2 = s2 || function(t4) {
-            let e3, i3 = t4[18].name + "";
-            return {
-                c() {
-                    e3 = D(i3);
-                },
-                m(t5, i4) {
-                    S(t5, e3, i4);
-                },
-                p(t5, s3) {
-                    2 & s3 && i3 !== (i3 = t5[18].name + "") && H(e3, i3);
-                },
-                d(t5) {
-                    t5 && E(e3);
-                }
-            };
-        }(t3);
-    return {
-        c() {
-            n2 && n2.c();
-        },
-        m(t4, i3) {
-            n2 && n2.m(t4, i3), e2 = true;
-        },
-        p(t4, r2) {
-            s2 ? s2.p && (!e2 || 2050 & r2) && u(s2, i2, t4, t4[11], e2 ? c(i2, t4[11], r2, Uk) : d(t4[11]), jk) : n2 && n2.p && (!e2 || 2 & r2) && n2.p(t4, e2 ? r2 : -1);
-        },
-        i(t4) {
-            e2 || (le(n2, t4), e2 = true);
-        },
-        o(t4) {
-            he(n2, t4), e2 = false;
-        },
-        d(t4) {
-            n2 && n2.d(t4);
-        }
-    };
-}
-
-function tT(t3, e2) {
-    let i2, s2, n2, r2, o2, a2;
-    const l2 = [Zk, Jk, Xk, Qk, Yk, Gk, Kk],
-        h2 = [];
-
-    function c2(t4, e3) {
-        return "name" === t4[21].key ? 0 : "action" === t4[21].key ? 1 : "entryDate" === t4[21].key ? 2 : "profit" === t4[21].key ? 3 : "currentWeight" === t4[21].key ? 4 : "RSV" === t4[21].key ? 5 : 6;
-    }
-    return s2 = c2(e2), n2 = h2[s2] = l2[s2](e2), {
-        key: t3,
-        first: null,
-        c() {
-            i2 = P("td"), n2.c(), r2 = $(), G(i2, "width", e2[21].width), U(i2, "class", o2 = "whitespace-nowrap " + ("name" === e2[21].key ? "pl-0 text-left sticky left-0 z-10 bg-base-200" : "text-right")), this.first = i2;
-        },
-        m(t4, e3) {
-            S(t4, i2, e3), h2[s2].m(i2, null), _(i2, r2), a2 = true;
-        },
-        p(t4, u2) {
-            let d2 = s2;
-            s2 = c2(e2 = t4), s2 === d2 ? h2[s2].p(e2, u2) : (oe(), he(h2[d2], 1, 1, () => {
-                h2[d2] = null;
-            }), ae(), n2 = h2[s2], n2 ? n2.p(e2, u2) : (n2 = h2[s2] = l2[s2](e2), n2.c()), le(n2, 1), n2.m(i2, r2)), (!a2 || 1 & u2) && G(i2, "width", e2[21].width), (!a2 || 1 & u2 && o2 !== (o2 = "whitespace-nowrap " + ("name" === e2[21].key ? "pl-0 text-left sticky left-0 z-10 bg-base-200" : "text-right"))) && U(i2, "class", o2);
-        },
-        i(t4) {
-            a2 || (le(n2), a2 = true);
-        },
-        o(t4) {
-            he(n2), a2 = false;
-        },
-        d(t4) {
-            t4 && E(i2), h2[s2].d();
-        }
-    };
-}
-
-function eT(t3) {
-    let e2, i2, s2, n2, r2, o2;
-    return s2 = new StockBlock({}), s2.$on("close", t3[8]), {
-        c() {
-            e2 = P("tr"), i2 = P("td"), me(s2.$$.fragment), r2 = $(), U(i2, "colspan", n2 = t3[0].length - 1);
-        },
-        m(t4, n3) {
-            S(t4, e2, n3), _(e2, i2), ge(s2, i2, null), _(e2, r2), o2 = true;
-        },
-        p(t4, e3) {
-            (!o2 || 1 & e3 && n2 !== (n2 = t4[0].length - 1)) && U(i2, "colspan", n2);
-        },
-        i(t4) {
-            o2 || (le(s2.$$.fragment, t4), o2 = true);
-        },
-        o(t4) {
-            he(s2.$$.fragment, t4), o2 = false;
-        },
-        d(t4) {
-            t4 && E(e2), ye(s2);
-        }
-    };
-}
-
-function iT(t3, e2) {
-    let i2, s2, n2, r2, o2 = [],
-        a2 = /* @__PURE__ */ new Map(),
-        l2 = Ou(),
-        h2 = ue(e2[0]);
-    const c2 = (t4) => t4[21].name;
-    for (let t4 = 0; t4 < h2.length; t4 += 1) {
-        let i3 = Rk(e2, h2, t4),
-            s3 = c2(i3);
-        a2.set(s3, o2[t4] = tT(s3, i3));
-    }
-    let u2 = l2 && function(t4) {
-        let e3, i3, s3 = t4[6] && t4[18].assetId === t4[6].assetId && eT(t4);
-        return {
-            c() {
-                s3 && s3.c(), e3 = z();
-            },
-            m(t5, n3) {
-                s3 && s3.m(t5, n3), S(t5, e3, n3), i3 = true;
-            },
-            p(t5, i4) {
-                t5[6] && t5[18].assetId === t5[6].assetId ? s3 ? (s3.p(t5, i4), 66 & i4 && le(s3, 1)) : (s3 = eT(t5), s3.c(), le(s3, 1), s3.m(e3.parentNode, e3)) : s3 && (oe(), he(s3, 1, 1, () => {
-                    s3 = null;
-                }), ae());
-            },
-            i(t5) {
-                i3 || (le(s3), i3 = true);
-            },
-            o(t5) {
-                he(s3), i3 = false;
-            },
-            d(t5) {
-                t5 && E(e3), s3 && s3.d(t5);
-            }
-        };
-    }(e2);
-    return {
-        key: t3,
-        first: null,
-        c() {
-            i2 = P("tr");
-            for (let t4 = 0; t4 < o2.length; t4 += 1)
-                o2[t4].c();
-            s2 = $(), u2 && u2.c(), n2 = z(), this.first = i2;
-        },
-        m(t4, e3) {
-            S(t4, i2, e3);
-            for (let t5 = 0; t5 < o2.length; t5 += 1)
-                o2[t5] && o2[t5].m(i2, null);
-            S(t4, s2, e3), u2 && u2.m(t4, e3), S(t4, n2, e3), r2 = true;
-        },
-        p(t4, s3) {
-            e2 = t4, 2051 & s3 && (h2 = ue(e2[0]), oe(), o2 = pe(o2, s3, c2, 1, e2, h2, a2, i2, fe, tT, null, Rk), ae()), l2 && u2.p(e2, s3);
-        },
-        i(t4) {
-            if (!r2) {
-                for (let t5 = 0; t5 < h2.length; t5 += 1)
-                    le(o2[t5]);
-                le(u2), r2 = true;
-            }
-        },
-        o(t4) {
-            for (let t5 = 0; t5 < o2.length; t5 += 1)
-                he(o2[t5]);
-            he(u2), r2 = false;
-        },
-        d(t4) {
-            t4 && (E(i2), E(s2), E(n2));
-            for (let t5 = 0; t5 < o2.length; t5 += 1)
-                o2[t5].d();
-            u2 && u2.d(t4);
-        }
-    };
-}
-
-function sT(t3) {
-    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2, d2, f2, p2 = [],
-        m2 = /* @__PURE__ */ new Map(),
-        g2 = [],
-        y2 = /* @__PURE__ */ new Map(),
-        v2 = ue(t3[0]);
-    const b2 = (t4) => t4[21].name;
-    for (let e3 = 0; e3 < v2.length; e3 += 1) {
-        let i3 = Hk(t3, v2, e3),
-            s3 = b2(i3);
-        m2.set(s3, p2[e3] = qk(s3, i3));
-    }
-    let w2 = ue(t3[1]);
-    const x2 = (t4) => t4[18].assetId;
-    for (let e3 = 0; e3 < w2.length; e3 += 1) {
-        let i3 = Pk(t3, w2, e3),
-            s3 = x2(i3);
-        y2.set(s3, g2[e3] = iT(s3, i3));
-    }
-    return {
-        c() {
-            e2 = P("div"), i2 = P("div"), s2 = P("div"), n2 = P("table"), r2 = P("thead"), o2 = P("tr");
-            for (let t4 = 0; t4 < p2.length; t4 += 1)
-                p2[t4].c();
-            a2 = $(), l2 = P("div"), h2 = P("table"), c2 = P("tbody");
-            for (let t4 = 0; t4 < g2.length; t4 += 1)
-                g2[t4].c();
-            U(r2, "class", "sticky top-12 z-20 bg-base-200 h-8 pb-4"), U(n2, "class", "table min-w-full table-fixed"), U(s2, "class", "overflow-hidden"), U(i2, "class", "sticky top-12 z-20"), U(h2, "class", "table table-fixed m-0"), U(l2, "class", "overflow-x-auto overflow-y-hidden pb-8"), U(e2, "class", "relative w-full -mt-2");
-        },
-        m(m3, y3) {
-            S(m3, e2, y3), _(e2, i2), _(i2, s2), _(s2, n2), _(n2, r2), _(r2, o2);
-            for (let t4 = 0; t4 < p2.length; t4 += 1)
-                p2[t4] && p2[t4].m(o2, null);
-            t3[14](s2), _(e2, a2), _(e2, l2), _(l2, h2), _(h2, c2);
-            for (let t4 = 0; t4 < g2.length; t4 += 1)
-                g2[t4] && g2[t4].m(c2, null);
-            t3[15](l2), u2 = true, d2 || (f2 = B(l2, "scroll", t3[16]), d2 = true);
-        },
-        p(t4, [e3]) {
-            141 & e3 && (v2 = ue(t4[0]), p2 = pe(p2, e3, b2, 1, t4, v2, m2, o2, de, qk, null, Hk)), 2371 & e3 && (w2 = ue(t4[1]), oe(), g2 = pe(g2, e3, x2, 1, t4, w2, y2, c2, fe, iT, null, Pk), ae());
-        },
-        i(t4) {
-            if (!u2) {
-                for (let t5 = 0; t5 < w2.length; t5 += 1)
-                    le(g2[t5]);
-                u2 = true;
-            }
-        },
-        o(t4) {
-            for (let t5 = 0; t5 < g2.length; t5 += 1)
-                he(g2[t5]);
-            u2 = false;
-        },
-        d(i3) {
-            i3 && E(e2);
-            for (let t4 = 0; t4 < p2.length; t4 += 1)
-                p2[t4].d();
-            t3[14](null);
-            for (let t4 = 0; t4 < g2.length; t4 += 1)
-                g2[t4].d();
-            t3[15](null), d2 = false, f2();
-        }
-    };
-}
-
-function nT(t3, e2, i2) {
-    let s2;
-    a(t3, ud, (t4) => i2(10, s2 = t4));
-    let n2, r2, o2, l2, h2, {
-            $$slots: c2 = {},
-            $$scope: u2
-        } = e2,
-        {
-            rows: d2 = []
-        } = e2,
-        {
-            columns: f2 = []
-        } = e2,
-        p2 = [];
-
-    function m2(t4) {
-        if (!t4.sort)
-            return;
-        const e3 = t4.key;
-        n2 === e3 ? i2(3, r2 = !r2) : (i2(2, n2 = e3), i2(3, r2 = true)), i2(1, p2 = [...d2].sort((t5, i3) => {
-            const s3 = t5[e3],
-                n3 = i3[e3];
-            if (s3 === n3)
-                return 0;
-            const o3 = s3 < n3 ? -1 : 1;
-            return r2 ? o3 : -o3;
-        }));
-    }
-    const g2 = bt();
-    return t3.$$set = (t4) => {
-        "rows" in t4 && i2(9, d2 = t4.rows), "columns" in t4 && i2(0, f2 = t4.columns), "$$scope" in t4 && i2(11, u2 = t4.$$scope);
-    }, t3.$$.update = () => {
-        512 & t3.$$.dirty && (i2(1, p2 = d2), i2(2, n2 = null), i2(3, r2 = true)), 1024 & t3.$$.dirty && i2(6, h2 = s2);
-    }, [f2, p2, n2, r2, o2, l2, h2, m2, function() {
-        g2("close");
-    }, d2, s2, u2, c2, (t4) => m2(t4), function(t4) {
-        xt[t4 ? "unshift" : "push"](() => {
-            o2 = t4, i2(4, o2);
-        });
-    }, function(t4) {
-        xt[t4 ? "unshift" : "push"](() => {
-            l2 = t4, i2(5, l2);
-        });
-    }, () => {
-        return t4 = l2, void(o2.scrollLeft = t4.scrollLeft);
-        var t4;
-    }];
-}
-class PositionDataTable extends SvelteComponent {
-    constructor(t3) {
-        super(), ve(this, t3, nT, sT, o, {
-            rows: 9,
-            columns: 0
-        });
-    }
-    get rows() {
-        return this.$$.ctx[9];
-    }
-    set rows(t3) {
-        this.$$set({
-            rows: t3
-        }), te();
-    }
-    get columns() {
-        return this.$$.ctx[0];
-    }
-    set columns(t3) {
-        this.$$set({
-            columns: t3
-        }), te();
-    }
-}
-
-function rT(t3) {
-    const e2 = function(t4) {
-            if (!t4)
-                return 0;
-            const e3 = t4.codePointAt(0);
-            if (void 0 === e3)
-                throw new Error("Invalid character");
-            return e3 % 360;
-        }(t3),
-        i2 = function(t4, e3, i3) {
-            let s3, n2, r2;
-            if (0 === e3)
-                s3 = n2 = r2 = i3;
-            else {
-                const o2 = (t5, e4, i4) => (i4 < 0 && (i4 += 1), i4 > 1 && (i4 -= 1), i4 < 1 / 6 ? t5 + 6 * (e4 - t5) * i4 : i4 < 0.5 ? e4 : i4 < 2 / 3 ? t5 + (e4 - t5) * (2 / 3 - i4) * 6 : t5);
-                let a2 = i3 < 0.5 ? i3 * (1 + e3) : i3 + e3 - i3 * e3,
-                    l2 = 2 * i3 - a2;
-                s3 = o2(l2, a2, t4 + 1 / 3), n2 = o2(l2, a2, t4), r2 = o2(l2, a2, t4 - 1 / 3);
-            }
-            return [Math.round(255 * s3), Math.round(255 * n2), Math.round(255 * r2)];
-        }(e2 / 360, 0.5, 0.5),
-        s2 = function(t4, e3, i3) {
-            const s3 = (t5) => {
-                const e4 = t5.toString(16);
-                return 1 === e4.length ? "0" + e4 : e4;
-            };
-            return `#${s3(t4)}${s3(e3)}${s3(i3)}`;
-        }(...i2);
-    return s2 + "77";
-}
-
-function oT(t3) {
-    const e2 = {};
-    for (let [i2, s2] of t3.entries())
-        s2 instanceof Map ? e2[i2] = oT(s2) : e2[i2] = s2;
-    return e2;
-}
-
-function aT(t3) {
-    if ("object" != typeof t3 || null === t3)
-        return console.log("Invalid: obj is not an object or is null"), false;
-    t3 instanceof Map && (t3 = oT(t3));
-    const e2 = ["assetName", "assetId"],
-        i2 = ["entryDate", "exitDate"],
-        s2 = ["entryPrice", "exitPrice", "currentPrice", "profit", "currentWeight", "nextWeight", "rsv20"];
-    for (const i3 of e2)
-        if ("string" != typeof t3[i3])
-            return console.log(`Invalid: ${i3} is not a string`), false;
-    for (const e3 of i2)
-        if (!(t3[e3] instanceof Date) && void 0 !== t3[e3])
-            return console.log(`Invalid: ${e3} is not a Date`), false;
-    for (const e3 of s2)
-        if ("number" != typeof t3[e3])
-            return console.log(`Invalid: ${e3} is not a number`), false;
-    if (null !== t3.action) {
-        if ("object" != typeof t3.action || null === t3.action)
-            return console.log("Invalid: action is not an object or is null"), false;
-        const e3 = ["type", "reason", "date", "profit"];
-        for (const i4 of e3)
-            if (!(i4 in t3.action))
-                return console.log(`Invalid: ${i4} is missing in action`), false;
-        if (!["entry", "exit", "hold", "entry_f", "exit_p"].includes(t3.action.type))
-            return console.log("Invalid: action.type is not one of 'entry', 'exit', 'hold'"), false;
-        const i3 = ["sl", "tp", "sl_", "tp_", "_", "entry", "exit", "sl_enter", "tp_enter"];
-        if (!i3.includes(t3.action.reason))
-            return console.log(`Invalid: action.reason is not one of ${i3}`), false;
-        if (!(t3.action.date instanceof Date) && void 0 !== t3.action.date)
-            return console.log("Invalid: action.date is not a Date"), false;
-        if ("number" != typeof t3.action.profit)
-            return console.log("Invalid: action.profit is not a number"), false;
-    }
-    return true;
-}
-
-function lT(t3) {
-    let e2, i2, s2, r2, o2, a2, l2, h2, c2, u2, d2, f2, p2, m2, g2, y2, v2, b2, w2, x2, k2, T2, C2, R2, z2 = t3[0].assetId + "",
-        j2 = t3[0].assetName + "";
-    return {
-        c() {
-            e2 = P("div"), i2 = P("form"), s2 = P("button"), s2.textContent = "✕", r2 = $(), o2 = P("h3"), a2 = D(z2), l2 = $(), h2 = D(j2), c2 = $(), u2 = P("div"), f2 = $(), p2 = P("div"), g2 = $(), y2 = P("div"), v2 = P("span"), v2.textContent = "報酬曲線圖", b2 = $(), w2 = P("label"), x2 = P("input"), k2 = $(), T2 = P("span"), T2.textContent = "蠟燭圖", U(s2, "class", "btn btn-sm btn-circle btn-ghost absolute right-2 top-2"), U(i2, "method", "dialog"), U(o2, "class", "font-bold text-lg"), U(u2, "class", d2 = "text-primary h-64 z-0 " + (t3[3] ? "hidden" : "block")), U(p2, "class", m2 = "text-primary h-64 z-0 " + (t3[3] ? "block" : "hidden")), U(v2, "class", "text-gray-500"), U(x2, "type", "checkbox"), U(x2, "class", "toggle toggle-primary toggle-md mx-2"), U(T2, "class", "text-gray-500"), U(y2, "class", "mt-4 flex item-center justify-center");
-        },
-        m(n2, d3) {
-            S(n2, e2, d3), _(e2, i2), _(i2, s2), _(e2, r2), _(e2, o2), _(o2, a2), _(o2, l2), _(o2, h2), _(e2, c2), _(e2, u2), t3[7](u2), _(e2, f2), _(e2, p2), t3[8](p2), _(e2, g2), _(e2, y2), _(y2, v2), _(y2, b2), _(y2, w2), _(w2, x2), x2.checked = t3[3], _(y2, k2), _(y2, T2), C2 || (R2 = [B(s2, "click", t3[4]), B(x2, "change", t3[9])], C2 = true);
-        },
-        p(t4, e3) {
-            1 & e3 && z2 !== (z2 = t4[0].assetId + "") && H(a2, z2), 1 & e3 && j2 !== (j2 = t4[0].assetName + "") && H(h2, j2), 8 & e3 && d2 !== (d2 = "text-primary h-64 z-0 " + (t4[3] ? "hidden" : "block")) && U(u2, "class", d2), 8 & e3 && m2 !== (m2 = "text-primary h-64 z-0 " + (t4[3] ? "block" : "hidden")) && U(p2, "class", m2), 8 & e3 && (x2.checked = t4[3]);
-        },
-        d(i3) {
-            i3 && E(e2), t3[7](null), t3[8](null), C2 = false, n(R2);
-        }
-    };
-}
-
-function hT(e2) {
-    let i2, s2, n2, r2 = e2[0] && lT(e2);
-    return {
-        c() {
-            i2 = P("dialog"), r2 && r2.c(), U(i2, "id", "stockModal"), U(i2, "class", "sticky bottom-0 overflow-hidden pb-4 w-auto max-w-screen-md rounded-xl md:border p-4 md:p-8 pt-8 shadow-2xl");
-        },
-        m(t3, o2) {
-            S(t3, i2, o2), r2 && r2.m(i2, null), s2 || (n2 = B(i2, "keydown", e2[5]), s2 = true);
-        },
-        p(t3, [e3]) {
-            t3[0] ? r2 ? r2.p(t3, e3) : (r2 = lT(t3), r2.c(), r2.m(i2, null)) : r2 && (r2.d(1), r2 = null);
-        },
-        i: t,
-        o: t,
-        d(t3) {
-            t3 && E(i2), r2 && r2.d(), s2 = false, n2();
-        }
-    };
-}
-
-function cT(t3, e2, i2) {
-    let s2, n2, r2, o2;
-    async function l2(t4) {
-        await async function(t5) {
-            const e3 = await f2(t5),
-                i3 = e3.timestamps.length,
-                s3 = e3.timestamps.length / (i3 / 100);
-            c2 = e3.createTradingviewSeries("close", 0, -1, s3), c2.forEach((t6) => {
-                try {
-                    if (!t6.time || "number" != typeof t6.time.seconds)
-                        throw new Error("Invalid or missing time.seconds property");
-                    {
-                        const e4 = 1e3 * t6.time.seconds,
-                            i4 = new Date(e4);
-                        if (isNaN(i4.getTime()))
-                            throw new Error("Invalid date");
-                        t6.time = {
-                            day: i4.getDate(),
-                            month: i4.getMonth() + 1,
-                            year: i4.getFullYear()
-                        };
-                    }
-                } catch (e4) {
-                    t6.time = {
-                        day: null,
-                        month: null,
-                        year: null
-                    };
-                }
-            });
-        }(t4.assetId), await async function(t5) {
-                const e3 = await f2(t5),
-                    i3 = e3.createCandlestickSeries(0, -1);
-                i3.forEach((t6) => {
-                    try {
-                        if (!t6.time || "object" != typeof t6.time || !("seconds" in t6.time))
-                            throw new Error("Invalid or missing time property");
-                        {
-                            const e4 = new Date(1e3 * t6.time.seconds);
-                            if (isNaN(e4.getTime()))
-                                throw new Error("Invalid date");
-                            t6.time = e4.toISOString().split("T")[0];
-                        }
-                    } catch (e4) {
-                        console.error("Error processing time:", t6.time, e4), t6.time = null;
-                    }
-                }), h2 = i3;
-            }(t4.assetId),
-            function() {
-                d2 || (d2 = new TwChart(o2, false));
-                d2.setTheme("dark" === Ek ? "dark" : "light"), d2.addCandlestickSeries(), d2.updateCandlestickSeriesData(h2);
-            }(),
-            function() {
-                u2 || (u2 = new TwChart(r2, true));
-                u2.setTheme("dark" === Ek ? "dark" : "light"), u2.resetAreaSeries(0), u2.resetAreaSeries(1), u2.series[0].setData(c2);
-            }(), stockModal.showModal();
-    }
-    a(t3, ud, (t4) => i2(6, s2 = t4));
-    let h2, c2, u2 = null,
-        d2 = null;
-    async function f2(t4) {
-        const e3 = rw(Tk, "twStock", t4);
-        if (e3) {
-            const t5 = (await cw(e3)).data();
-            return new Stock(t5.price);
-        }
-    }
-    const p2 = bt();
-
-    function m2() {
-        p2("close"), document.body.classList.remove("overflow-hidden");
-    }
-
-    function g2(t4) {
-        "Escape" === t4.key && m2();
-    }
-    pt(() => {
-        window.addEventListener("keydown", g2), document.body.classList.add("overflow-hidden");
-    }), yt(() => {
-        window.removeEventListener("keydown", g2), document.body.classList.remove("overflow-hidden");
-    });
-    let y2 = true;
-    return t3.$$.update = () => {
-        64 & t3.$$.dirty && i2(0, n2 = s2), 1 & t3.$$.dirty && n2 && l2(n2);
-    }, [n2, r2, o2, y2, m2, g2, s2, function(t4) {
-        xt[t4 ? "unshift" : "push"](() => {
-            r2 = t4, i2(1, r2);
-        });
-    }, function(t4) {
-        xt[t4 ? "unshift" : "push"](() => {
-            o2 = t4, i2(2, o2);
-        });
-    }, function() {
-        y2 = this.checked, i2(3, y2);
-    }];
-}
-we(PositionDataTable, {
-    rows: {},
-    columns: {}
-}, ["name", "action", "entryDate", "profit", "currentWeight", "RSV"], [], true);
-class StockModal extends SvelteComponent {
-    constructor(t3) {
-        super(), ve(this, t3, cT, hT, o, {});
-    }
-}
-
-function uT(t3) {
-    w(t3, "svelte-1nx0ef2", ".lining-nums.svelte-1nx0ef2{font-weight:600;font-size:18px;line-height:32px}");
-}
-
-function dT(t3, e2, i2) {
-    const s2 = t3.slice();
-    return s2[26] = e2[i2], s2;
-}
-
-function fT(t3, e2, i2) {
-    const s2 = t3.slice();
-    return s2[26] = e2[i2], s2;
-}
-
-function pT(t3, e2, i2) {
-    const s2 = t3.slice();
-    return s2[31] = e2[i2][0], s2[32] = e2[i2][1], s2;
-}
-
-function mT(t3) {
-    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2 = ue(Object.entries(t3[10])),
-        u2 = [];
-    for (let e3 = 0; e3 < c2.length; e3 += 1)
-        u2[e3] = yT(pT(t3, c2, e3));
-    let d2 = (0 !== t3[7].length || 0 !== t3[6].length) && vT(t3),
-        f2 = (0 !== t3[7].length || 0 !== t3[6].length) && MT();
-    o2 = new PositionDataTable({
-        props: {
-            rows: t3[2],
-            columns: t3[8],
-            $$slots: {
-                RSV: [$T, ({
-                    row: t4
-                }) => ({
-                    25: t4
-                }), ({
-                    row: t4
-                }) => [t4 ? 33554432 : 0]],
-                currentWeight: [OT, ({
-                    row: t4
-                }) => ({
-                    25: t4
-                }), ({
-                    row: t4
-                }) => [t4 ? 33554432 : 0]],
-                entryDate: [LT, ({
-                    row: t4
-                }) => ({
-                    25: t4
-                }), ({
-                    row: t4
-                }) => [t4 ? 33554432 : 0]],
-                profit: [AT, ({
-                    row: t4
-                }) => ({
-                    25: t4
-                }), ({
-                    row: t4
-                }) => [t4 ? 33554432 : 0]],
-                name: [RT, ({
-                    row: t4
-                }) => ({
-                    25: t4
-                }), ({
-                    row: t4
-                }) => [t4 ? 33554432 : 0]]
-            },
-            $$scope: {
-                ctx: t3
-            }
-        }
-    }), o2.$on("close", t3[12]);
-    let p2 = t3[4] && VT(t3);
-    return {
-        c() {
-            e2 = P("div");
-            for (let t4 = 0; t4 < u2.length; t4 += 1)
-                u2[t4].c();
-            i2 = $(), d2 && d2.c(), s2 = $(), n2 = P("div"), f2 && f2.c(), r2 = $(), me(o2.$$.fragment), a2 = $(), p2 && p2.c(), l2 = z(), U(e2, "class", "hidden sm:flex gap-2 md:gap-4 stats bg-transparent sm:text-center min-w-full mb-4"), U(n2, "class", "md:rounded-2xl h-full bg-base-200 my-4 p-4 sm:p-8 sm:border relative");
-        },
-        m(t4, c3) {
-            S(t4, e2, c3);
-            for (let t5 = 0; t5 < u2.length; t5 += 1)
-                u2[t5] && u2[t5].m(e2, null);
-            S(t4, i2, c3), d2 && d2.m(t4, c3), S(t4, s2, c3), S(t4, n2, c3), f2 && f2.m(n2, null), _(n2, r2), ge(o2, n2, null), S(t4, a2, c3), p2 && p2.m(t4, c3), S(t4, l2, c3), h2 = true;
-        },
-        p(t4, i3) {
-            if (1027 & i3[0]) {
-                let s3;
-                for (c2 = ue(Object.entries(t4[10])), s3 = 0; s3 < c2.length; s3 += 1) {
-                    const n3 = pT(t4, c2, s3);
-                    u2[s3] ? u2[s3].p(n3, i3) : (u2[s3] = yT(n3), u2[s3].c(), u2[s3].m(e2, null));
-                }
-                for (; s3 < u2.length; s3 += 1)
-                    u2[s3].d(1);
-                u2.length = c2.length;
-            }
-            0 !== t4[7].length || 0 !== t4[6].length ? d2 ? d2.p(t4, i3) : (d2 = vT(t4), d2.c(), d2.m(s2.parentNode, s2)) : d2 && (d2.d(1), d2 = null), 0 !== t4[7].length || 0 !== t4[6].length ? f2 || (f2 = MT(), f2.c(), f2.m(n2, r2)) : f2 && (f2.d(1), f2 = null);
-            const a3 = {};
-            4 & i3[0] && (a3.rows = t4[2]), 256 & i3[0] && (a3.columns = t4[8]), 33554449 & i3[0] | 16 & i3[1] && (a3.$$scope = {
-                dirty: i3,
-                ctx: t4
-            }), o2.$set(a3), t4[4] ? p2 ? (p2.p(t4, i3), 16 & i3[0] && le(p2, 1)) : (p2 = VT(t4), p2.c(), le(p2, 1), p2.m(l2.parentNode, l2)) : p2 && (oe(), he(p2, 1, 1, () => {
-                p2 = null;
-            }), ae());
-        },
-        i(t4) {
-            h2 || (le(o2.$$.fragment, t4), le(p2), h2 = true);
-        },
-        o(t4) {
-            he(o2.$$.fragment, t4), he(p2), h2 = false;
-        },
-        d(t4) {
-            t4 && (E(e2), E(i2), E(s2), E(n2), E(a2), E(l2)), C(u2, t4), d2 && d2.d(t4), f2 && f2.d(), ye(o2), p2 && p2.d(t4);
-        }
-    };
-}
-
-function gT(t3) {
-    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2 = t3[1]("position." + t3[31]) + "",
-        d2 = t3[32].formatter(t3[0][t3[31]]) + "";
-    return {
-        c() {
-            e2 = P("div"), i2 = P("span"), s2 = D(u2), n2 = P("br"), r2 = $(), o2 = P("span"), a2 = D(d2), l2 = $(), h2 = P("span"), h2.textContent = `${t3[32].unit}`, c2 = $(), U(i2, "class", "text-base-content-100"), U(o2, "class", "text-base-content-200 text-2xl font-bold"), U(h2, "class", "text-base-content-200"), U(e2, "class", "flex-1");
-        },
-        m(t4, u3) {
-            S(t4, e2, u3), _(e2, i2), _(i2, s2), _(e2, n2), _(e2, r2), _(e2, o2), _(o2, a2), _(e2, l2), _(e2, h2), _(e2, c2);
-        },
-        p(t4, e3) {
-            2 & e3[0] && u2 !== (u2 = t4[1]("position." + t4[31]) + "") && H(s2, u2), 1 & e3[0] && d2 !== (d2 = t4[32].formatter(t4[0][t4[31]]) + "") && H(a2, d2);
-        },
-        d(t4) {
-            t4 && E(e2);
-        }
-    };
-}
-
-function yT(t3) {
-    let e2, i2 = !("shown" in t3[32]) || t3[32].shown(t3[0][t3[31]]),
-        s2 = i2 && gT(t3);
-    return {
-        c() {
-            s2 && s2.c(), e2 = z();
-        },
-        m(t4, i3) {
-            s2 && s2.m(t4, i3), S(t4, e2, i3);
-        },
-        p(t4, n2) {
-            1 & n2[0] && (i2 = !("shown" in t4[32]) || t4[32].shown(t4[0][t4[31]])), i2 ? s2 ? s2.p(t4, n2) : (s2 = gT(t4), s2.c(), s2.m(e2.parentNode, e2)) : s2 && (s2.d(1), s2 = null);
-        },
-        d(t4) {
-            t4 && E(e2), s2 && s2.d(t4);
-        }
-    };
-}
-
-function vT(t3) {
-    let e2, i2, s2, n2 = 0 !== t3[6].length && bT(t3),
-        r2 = 0 !== t3[6].length && 0 !== t3[7].length && TT(),
-        o2 = t3[7] && ST(t3);
-    return {
-        c() {
-            e2 = P("div"), n2 && n2.c(), i2 = $(), r2 && r2.c(), s2 = $(), o2 && o2.c(), U(e2, "class", "md:rounded-2xl h-full border bg-base-200 p-4 sm:p-8");
-        },
-        m(t4, a2) {
-            S(t4, e2, a2), n2 && n2.m(e2, null), _(e2, i2), r2 && r2.m(e2, null), _(e2, s2), o2 && o2.m(e2, null);
-        },
-        p(t4, a2) {
-            0 !== t4[6].length ? n2 ? n2.p(t4, a2) : (n2 = bT(t4), n2.c(), n2.m(e2, i2)) : n2 && (n2.d(1), n2 = null), 0 !== t4[6].length && 0 !== t4[7].length ? r2 || (r2 = TT(), r2.c(), r2.m(e2, s2)) : r2 && (r2.d(1), r2 = null), t4[7] ? o2 ? o2.p(t4, a2) : (o2 = ST(t4), o2.c(), o2.m(e2, null)) : o2 && (o2.d(1), o2 = null);
-        },
-        d(t4) {
-            t4 && E(e2), n2 && n2.d(), r2 && r2.d(), o2 && o2.d();
-        }
-    };
-}
-
-function bT(t3) {
-    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2, d2, f2 = {
-            close: "收盤",
-            open: "開盤"
-        } [t3[0].entryTradePrice] + "",
-        p2 = ue(t3[6]),
-        m2 = [];
-    for (let e3 = 0; e3 < p2.length; e3 += 1)
-        m2[e3] = kT(fT(t3, p2, e3));
-    return {
-        c() {
-            e2 = P("div"), i2 = P("h2"), s2 = D(f2), n2 = D("買入"), r2 = $(), o2 = P("input"), a2 = $(), l2 = P("span"), l2.textContent = "顯示買入部位", h2 = $(), c2 = P("div");
-            for (let t4 = 0; t4 < m2.length; t4 += 1)
-                m2[t4].c();
-            U(o2, "type", "checkbox"), U(o2, "class", "ml-4 toggle toggle-sm"), U(l2, "class", "ml-2 text-sm font-normal"), U(e2, "class", "text-2xl text-base-content-200 font-bold items-center flex"), U(c2, "class", "grid grid-cols-2 md:grid-cols-3 gap-4 pt-1 mt-4");
-        },
-        m(f3, p3) {
-            S(f3, e2, p3), _(e2, i2), _(i2, s2), _(i2, n2), _(e2, r2), _(e2, o2), o2.checked = t3[3], _(e2, a2), _(e2, l2), S(f3, h2, p3), S(f3, c2, p3);
-            for (let t4 = 0; t4 < m2.length; t4 += 1)
-                m2[t4] && m2[t4].m(c2, null);
-            u2 || (d2 = B(o2, "change", t3[18]), u2 = true);
-        },
-        p(t4, e3) {
-            if (1 & e3[0] && f2 !== (f2 = {
-                    close: "收盤",
-                    open: "開盤"
-                } [t4[0].entryTradePrice] + "") && H(s2, f2), 8 & e3[0] && (o2.checked = t4[3]), 72 & e3[0]) {
-                let i3;
-                for (p2 = ue(t4[6]), i3 = 0; i3 < p2.length; i3 += 1) {
-                    const s3 = fT(t4, p2, i3);
-                    m2[i3] ? m2[i3].p(s3, e3) : (m2[i3] = kT(s3), m2[i3].c(), m2[i3].m(c2, null));
-                }
-                for (; i3 < m2.length; i3 += 1)
-                    m2[i3].d(1);
-                m2.length = p2.length;
-            }
-        },
-        d(t4) {
-            t4 && (E(e2), E(h2), E(c2)), C(m2, t4), u2 = false, d2();
-        }
-    };
-}
-
-function _T(t3) {
-    let e2, i2 = t3[26].assetName[0] + "";
-    return {
-        c() {
-            e2 = D(i2);
-        },
-        m(t4, i3) {
-            S(t4, e2, i3);
-        },
-        p(t4, s2) {
-            64 & s2[0] && i2 !== (i2 = t4[26].assetName[0] + "") && H(e2, i2);
-        },
-        d(t4) {
-            t4 && E(e2);
-        }
-    };
-}
-
-function wT(t3) {
-    let e2, i2, s2, n2, r2 = t3[26].assetName + "";
-    return {
-        c() {
-            e2 = P("span"), i2 = D(r2), s2 = $(), n2 = P("br"), U(e2, "class", "whitespace-nowrap font-bold text-base-content-200");
-        },
-        m(t4, r3) {
-            S(t4, e2, r3), _(e2, i2), S(t4, s2, r3), S(t4, n2, r3);
-        },
-        p(t4, e3) {
-            64 & e3[0] && r2 !== (r2 = t4[26].assetName + "") && H(i2, r2);
-        },
-        d(t4) {
-            t4 && (E(e2), E(s2), E(n2));
-        }
-    };
-}
-
-function xT(t3) {
-    let e2, i2, s2, n2, r2 = Math.abs(100 * t3[26].nextWeight).toFixed(1) + "";
-    return {
-        c() {
-            e2 = P("div"), i2 = P("span"), s2 = D(r2), n2 = D("%"), G(i2, "color", t3[26].nextWeight > 0 ? vu("red") : bu("red")), U(i2, "class", "font-light lining-nums ml-4 svelte-1nx0ef2"), U(e2, "class", "flex-grow text-left");
-        },
-        m(t4, r3) {
-            S(t4, e2, r3), _(e2, i2), _(i2, s2), _(i2, n2);
-        },
-        p(t4, e3) {
-            64 & e3[0] && r2 !== (r2 = Math.abs(100 * t4[26].nextWeight).toFixed(1) + "") && H(s2, r2), 64 & e3[0] && G(i2, "color", t4[26].nextWeight > 0 ? vu("red") : bu("red"));
-        },
-        d(t4) {
-            t4 && E(e2);
-        }
-    };
-}
-
-function kT(t3) {
-    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2 = t3[26].assetId + "",
-        d2 = t3[26].assetName && _T(t3),
-        f2 = t3[26].assetName && wT(t3),
-        p2 = t3[3] && xT(t3);
-    return {
-        c() {
-            e2 = P("div"), i2 = P("div"), s2 = P("div"), d2 && d2.c(), n2 = $(), r2 = P("div"), f2 && f2.c(), o2 = $(), a2 = P("span"), l2 = D(u2), h2 = $(), p2 && p2.c(), c2 = $(), U(s2, "class", "mr-3 w-8 h-8 rounded-full text-white font-bold justify-center items-center flex"), G(s2, "background", rT(t3[26].assetName[0])), U(a2, "class", "font-light text-base-content-300"), U(i2, "class", "flex flex-nowrap items-center"), U(e2, "class", "text-base font-bold relative text-ellipsis overflow-hidden text-left");
-        },
-        m(t4, u3) {
-            S(t4, e2, u3), _(e2, i2), _(i2, s2), d2 && d2.m(s2, null), _(i2, n2), _(i2, r2), f2 && f2.m(r2, null), _(r2, o2), _(r2, a2), _(a2, l2), _(i2, h2), p2 && p2.m(i2, null), _(e2, c2);
-        },
-        p(t4, e3) {
-            t4[26].assetName ? d2 ? d2.p(t4, e3) : (d2 = _T(t4), d2.c(), d2.m(s2, null)) : d2 && (d2.d(1), d2 = null), 64 & e3[0] && G(s2, "background", rT(t4[26].assetName[0])), t4[26].assetName ? f2 ? f2.p(t4, e3) : (f2 = wT(t4), f2.c(), f2.m(r2, o2)) : f2 && (f2.d(1), f2 = null), 64 & e3[0] && u2 !== (u2 = t4[26].assetId + "") && H(l2, u2), t4[3] ? p2 ? p2.p(t4, e3) : (p2 = xT(t4), p2.c(), p2.m(i2, null)) : p2 && (p2.d(1), p2 = null);
-        },
-        d(t4) {
-            t4 && E(e2), d2 && d2.d(), f2 && f2.d(), p2 && p2.d();
-        }
-    };
-}
-
-function TT(t3) {
-    let e2;
-    return {
-        c() {
-            e2 = P("hr"), U(e2, "class", "my-6");
-        },
-        m(t4, i2) {
-            S(t4, e2, i2);
-        },
-        d(t4) {
-            t4 && E(e2);
-        }
-    };
-}
-
-function ST(t3) {
-    let e2, i2, s2, n2, r2, o2 = {
-            close: "收盤",
-            open: "開盤"
-        } [t3[0].entryTradePrice] + "",
-        a2 = ue(t3[7]),
-        l2 = [];
-    for (let e3 = 0; e3 < a2.length; e3 += 1)
-        l2[e3] = IT(dT(t3, a2, e3));
-    return {
-        c() {
-            e2 = P("h2"), i2 = D(o2), s2 = D("賣出"), n2 = $(), r2 = P("div");
-            for (let t4 = 0; t4 < l2.length; t4 += 1)
-                l2[t4].c();
-            U(e2, "class", "text-2xl text-base-content-200 font-bold flex items-center"), U(r2, "class", "grid grid-cols-2 md:grid-cols-3 gap-4 pt-1 mt-4");
-        },
-        m(t4, o3) {
-            S(t4, e2, o3), _(e2, i2), _(e2, s2), S(t4, n2, o3), S(t4, r2, o3);
-            for (let t5 = 0; t5 < l2.length; t5 += 1)
-                l2[t5] && l2[t5].m(r2, null);
-        },
-        p(t4, e3) {
-            if (1 & e3[0] && o2 !== (o2 = {
-                    close: "收盤",
-                    open: "開盤"
-                } [t4[0].entryTradePrice] + "") && H(i2, o2), 128 & e3[0]) {
-                let i3;
-                for (a2 = ue(t4[7]), i3 = 0; i3 < a2.length; i3 += 1) {
-                    const s3 = dT(t4, a2, i3);
-                    l2[i3] ? l2[i3].p(s3, e3) : (l2[i3] = IT(s3), l2[i3].c(), l2[i3].m(r2, null));
-                }
-                for (; i3 < l2.length; i3 += 1)
-                    l2[i3].d(1);
-                l2.length = a2.length;
-            }
-        },
-        d(t4) {
-            t4 && (E(e2), E(n2), E(r2)), C(l2, t4);
-        }
-    };
-}
-
-function ET(t3) {
-    let e2, i2 = t3[26].assetName[0] + "";
-    return {
-        c() {
-            e2 = D(i2);
-        },
-        m(t4, i3) {
-            S(t4, e2, i3);
-        },
-        p(t4, s2) {
-            128 & s2[0] && i2 !== (i2 = t4[26].assetName[0] + "") && H(e2, i2);
-        },
-        d(t4) {
-            t4 && E(e2);
-        }
-    };
-}
-
-function CT(t3) {
-    let e2, i2, s2, n2, r2 = t3[26].assetName + "";
-    return {
-        c() {
-            e2 = P("span"), i2 = D(r2), s2 = $(), n2 = P("br"), U(e2, "class", "whitespace-nowrap font-bold text-base-content-300");
-        },
-        m(t4, r3) {
-            S(t4, e2, r3), _(e2, i2), S(t4, s2, r3), S(t4, n2, r3);
-        },
-        p(t4, e3) {
-            128 & e3[0] && r2 !== (r2 = t4[26].assetName + "") && H(i2, r2);
-        },
-        d(t4) {
-            t4 && (E(e2), E(s2), E(n2));
-        }
-    };
-}
-
-function IT(t3) {
-    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2 = t3[26].assetId + "",
-        u2 = t3[26].assetName && ET(t3),
-        d2 = t3[26].assetName && CT(t3);
-    return {
-        c() {
-            e2 = P("div"), i2 = P("div"), s2 = P("div"), u2 && u2.c(), n2 = $(), r2 = P("div"), d2 && d2.c(), o2 = $(), a2 = P("span"), l2 = D(c2), h2 = $(), U(s2, "class", "mr-3 w-8 h-8 rounded-full text-white font-bold justify-center items-center flex"), G(s2, "background", rT(t3[26].assetName[0])), U(a2, "class", "font-light text-base-content-200"), U(i2, "class", "flex flex-nowrap items-center"), U(e2, "class", "text-base font-bold relative text-ellipsis overflow-hidden text-left");
-        },
-        m(t4, c3) {
-            S(t4, e2, c3), _(e2, i2), _(i2, s2), u2 && u2.m(s2, null), _(i2, n2), _(i2, r2), d2 && d2.m(r2, null), _(r2, o2), _(r2, a2), _(a2, l2), _(e2, h2);
-        },
-        p(t4, e3) {
-            t4[26].assetName ? u2 ? u2.p(t4, e3) : (u2 = ET(t4), u2.c(), u2.m(s2, null)) : u2 && (u2.d(1), u2 = null), 128 & e3[0] && G(s2, "background", rT(t4[26].assetName[0])), t4[26].assetName ? d2 ? d2.p(t4, e3) : (d2 = CT(t4), d2.c(), d2.m(r2, o2)) : d2 && (d2.d(1), d2 = null), 128 & e3[0] && c2 !== (c2 = t4[26].assetId + "") && H(l2, c2);
-        },
-        d(t4) {
-            t4 && E(e2), u2 && u2.d(), d2 && d2.d();
-        }
-    };
-}
-
-function MT(t3) {
-    let e2;
-    return {
-        c() {
-            e2 = P("h2"), e2.textContent = "當前部位", U(e2, "class", "text-2xl text-base-content-200 font-bold mb-2");
-        },
-        m(t4, i2) {
-            S(t4, e2, i2);
-        },
-        d(t4) {
-            t4 && E(e2);
-        }
-    };
-}
-
-function PT(t3) {
-    let e2, i2, s2, n2, r2 = (t3[25].assetName ? t3[25].assetName : "") + "";
-    return {
-        c() {
-            e2 = P("span"), i2 = D(r2), s2 = $(), n2 = P("br"), U(e2, "class", "whitespace-nowrap font-bold text-base-content-300");
-        },
-        m(t4, r3) {
-            S(t4, e2, r3), _(e2, i2), S(t4, s2, r3), S(t4, n2, r3);
-        },
-        p(t4, e3) {
-            33554432 & e3[0] && r2 !== (r2 = (t4[25].assetName ? t4[25].assetName : "") + "") && H(i2, r2);
-        },
-        d(t4) {
-            t4 && (E(e2), E(s2), E(n2));
-        }
-    };
-}
-
-function RT(t3) {
-    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2, d2 = (t3[25].assetName ? t3[25].assetName[0] : "") + "",
-        f2 = t3[25].assetId + "",
-        p2 = t3[25].assetName && PT(t3);
-
-    function m2() {
-        return t3[19](t3[25]);
-    }
-    return {
-        c() {
-            e2 = P("div"), i2 = P("div"), s2 = P("div"), n2 = D(d2), r2 = $(), o2 = P("div"), p2 && p2.c(), a2 = $(), l2 = P("span"), h2 = D(f2), U(s2, "class", "mr-3 w-8 h-8 rounded-full text-white font-bold justify-center items-center flex"), G(s2, "background", rT(t3[25].assetName[0])), U(l2, "class", "font-light text-base-content-200"), U(i2, "class", "flex flex-nowrap items-center"), U(e2, "slot", "name"), U(e2, "class", "text-base font-bold relative text-ellipsis overflow-hidden text-left cursor-pointer");
-        },
-        m(t4, d3) {
-            S(t4, e2, d3), _(e2, i2), _(i2, s2), _(s2, n2), _(i2, r2), _(i2, o2), p2 && p2.m(o2, null), _(o2, a2), _(o2, l2), _(l2, h2), c2 || (u2 = B(e2, "click", m2), c2 = true);
-        },
-        p(e3, i3) {
-            t3 = e3, 33554432 & i3[0] && d2 !== (d2 = (t3[25].assetName ? t3[25].assetName[0] : "") + "") && H(n2, d2), 33554432 & i3[0] && G(s2, "background", rT(t3[25].assetName[0])), t3[25].assetName ? p2 ? p2.p(t3, i3) : (p2 = PT(t3), p2.c(), p2.m(o2, a2)) : p2 && (p2.d(1), p2 = null), 33554432 & i3[0] && f2 !== (f2 = t3[25].assetId + "") && H(h2, f2);
-        },
-        d(t4) {
-            t4 && E(e2), p2 && p2.d(), c2 = false, u2();
-        }
-    };
-}
-
-function AT(t3) {
-    let e2, i2, s2, n2, r2, o2 = t3[9](t3[25].profit) + "",
-        a2 = (100 * t3[25].profit).toFixed(2) + "";
-    return {
-        c() {
-            e2 = P("div"), i2 = P("span"), s2 = D(o2), n2 = D(a2), r2 = D("%"), G(i2, "color", t3[25].profit > 0 ? vu("red") : bu("red")), U(e2, "slot", "profit"), U(e2, "class", "lining-nums svelte-1nx0ef2");
-        },
-        m(t4, o3) {
-            S(t4, e2, o3), _(e2, i2), _(i2, s2), _(i2, n2), _(i2, r2);
-        },
-        p(t4, e3) {
-            33554432 & e3[0] && o2 !== (o2 = t4[9](t4[25].profit) + "") && H(s2, o2), 33554432 & e3[0] && a2 !== (a2 = (100 * t4[25].profit).toFixed(2) + "") && H(n2, a2), 33554432 & e3[0] && G(i2, "color", t4[25].profit > 0 ? vu("red") : bu("red"));
-        },
-        d(t4) {
-            t4 && E(e2);
-        }
-    };
-}
-
-function DT(t3) {
-    let e2, i2, s2 = t3[25].entryDate.toLocaleTimeString() + "";
-    return {
-        c() {
-            e2 = P("br"), i2 = D(s2);
-        },
-        m(t4, s3) {
-            S(t4, e2, s3), S(t4, i2, s3);
-        },
-        p(t4, e3) {
-            33554432 & e3[0] && s2 !== (s2 = t4[25].entryDate.toLocaleTimeString() + "") && H(i2, s2);
-        },
-        d(t4) {
-            t4 && (E(e2), E(i2));
-        }
-    };
-}
-
-function LT(t3) {
-    let e2, i2, s2, n2, r2, o2, a2, l2, h2 = t3[25].currentPrice.toFixed(2) + "",
-        c2 = t3[25].entryDate.toLocaleDateString() + "",
-        u2 = !t3[0].isDailyStrategy && DT(t3);
-    return {
-        c() {
-            e2 = P("div"), i2 = P("span"), s2 = D(h2), n2 = P("br"), r2 = $(), o2 = P("span"), a2 = D(c2), l2 = $(), u2 && u2.c(), U(i2, "class", "lining-nums svelte-1nx0ef2"), U(o2, "class", "text-sm"), U(e2, "slot", "entryDate");
-        },
-        m(t4, h3) {
-            S(t4, e2, h3), _(e2, i2), _(i2, s2), _(e2, n2), _(e2, r2), _(e2, o2), _(o2, a2), _(e2, l2), u2 && u2.m(e2, null);
-        },
-        p(t4, i3) {
-            33554432 & i3[0] && h2 !== (h2 = t4[25].currentPrice.toFixed(2) + "") && H(s2, h2), 33554432 & i3[0] && c2 !== (c2 = t4[25].entryDate.toLocaleDateString() + "") && H(a2, c2), t4[0].isDailyStrategy ? u2 && (u2.d(1), u2 = null) : u2 ? u2.p(t4, i3) : (u2 = DT(t4), u2.c(), u2.m(e2, null));
-        },
-        d(t4) {
-            t4 && E(e2), u2 && u2.d();
-        }
-    };
-}
-
-function OT(t3) {
-    let e2, i2, s2, n2, r2 = (100 * t3[25].currentWeight).toFixed(1) + "";
-    return {
-        c() {
-            e2 = P("div"), i2 = P("span"), s2 = D(r2), n2 = D("%"), G(i2, "color", t3[25].currentWeight > 0 ? vu("red") : bu("red")), U(e2, "slot", "currentWeight"), U(e2, "class", "lining-nums svelte-1nx0ef2");
-        },
-        m(t4, r3) {
-            S(t4, e2, r3), _(e2, i2), _(i2, s2), _(i2, n2);
-        },
-        p(t4, e3) {
-            33554432 & e3[0] && r2 !== (r2 = (100 * t4[25].currentWeight).toFixed(1) + "") && H(s2, r2), 33554432 & e3[0] && G(i2, "color", t4[25].currentWeight > 0 ? vu("red") : bu("red"));
-        },
-        d(t4) {
-            t4 && E(e2);
-        }
-    };
-}
-
-function FT(e2) {
-    let i2;
-    return {
-        c() {
-            i2 = D("-");
-        },
-        m(t3, e3) {
-            S(t3, i2, e3);
-        },
-        p: t,
-        d(t3) {
-            t3 && E(i2);
-        }
-    };
-}
-
-function NT(t3) {
-    let e2, i2, s2, n2, r2, o2, a2 = (100 * t3[25].rsv20).toFixed(2) + "";
-    return {
-        c() {
-            e2 = D(a2), i2 = D("%"), s2 = P("br"), n2 = $(), r2 = P("progress"), U(r2, "class", "progress progress-primary w-32"), r2.value = o2 = t3[25].rsv20, U(r2, "max", "1");
-        },
-        m(t4, o3) {
-            S(t4, e2, o3), S(t4, i2, o3), S(t4, s2, o3), S(t4, n2, o3), S(t4, r2, o3);
-        },
-        p(t4, i3) {
-            33554432 & i3[0] && a2 !== (a2 = (100 * t4[25].rsv20).toFixed(2) + "") && H(e2, a2), 33554432 & i3[0] && o2 !== (o2 = t4[25].rsv20) && (r2.value = o2);
-        },
-        d(t4) {
-            t4 && (E(e2), E(i2), E(s2), E(n2), E(r2));
-        }
-    };
-}
-
-function $T(t3) {
-    let e2, i2;
-
-    function s2(t4, e3) {
-        return 33554432 & e3[0] && (i2 = null), null == i2 && (i2 = !!isFinite(t4[25].rsv20)), i2 ? NT : FT;
-    }
-    let n2 = s2(t3, [-1, -1]),
-        r2 = n2(t3);
-    return {
-        c() {
-            e2 = P("div"), r2.c(), U(e2, "slot", "RSV"), U(e2, "class", "text-base-content-100");
-        },
-        m(t4, i3) {
-            S(t4, e2, i3), r2.m(e2, null);
-        },
-        p(t4, i3) {
-            n2 === (n2 = s2(t4, i3)) && r2 ? r2.p(t4, i3) : (r2.d(1), r2 = n2(t4), r2 && (r2.c(), r2.m(e2, null)));
-        },
-        d(t4) {
-            t4 && E(e2), r2.d();
-        }
-    };
-}
-
-function VT(e2) {
-    let i2, s2;
-    return i2 = new StockModal({}), i2.$on("close", e2[11]), {
-        c() {
-            me(i2.$$.fragment);
-        },
-        m(t3, e3) {
-            ge(i2, t3, e3), s2 = true;
-        },
-        p: t,
-        i(t3) {
-            s2 || (le(i2.$$.fragment, t3), s2 = true);
-        },
-        o(t3) {
-            he(i2.$$.fragment, t3), s2 = false;
-        },
-        d(t3) {
-            ye(i2, t3);
-        }
-    };
-}
-
-function zT(t3) {
-    let e2, i2, s2 = t3[0] && mT(t3);
-    return {
-        c() {
-            e2 = P("div"), s2 && s2.c(), U(e2, "class", "text-base-content w-full relative");
-        },
-        m(n2, r2) {
-            S(n2, e2, r2), s2 && s2.m(e2, null), t3[20](e2), i2 = true;
-        },
-        p(t4, i3) {
-            t4[0] ? s2 ? (s2.p(t4, i3), 1 & i3[0] && le(s2, 1)) : (s2 = mT(t4), s2.c(), le(s2, 1), s2.m(e2, null)) : s2 && (oe(), he(s2, 1, 1, () => {
-                s2 = null;
-            }), ae());
-        },
-        i(t4) {
-            i2 || (le(s2), i2 = true);
-        },
-        o(t4) {
-            he(s2), i2 = false;
-        },
-        d(i3) {
-            i3 && E(e2), s2 && s2.d(), t3[20](null);
-        }
-    };
-}
-we(StockModal, {}, [], [], true);
-
-function BT(t3) {
-    const e2 = {};
-    for (const [i2, s2] of t3.entries())
-        e2[i2] = s2;
-    return e2.action && (e2.action = BT(e2.action)), e2;
-}
-
-function UT(t3 = null) {
-    !t3 || t3 instanceof Date || (t3 = new Date(t3)), t3 || (t3 = /* @__PURE__ */ new Date());
-    const e2 = t3.getTime() + 6e4 * t3.getTimezoneOffset(),
-        i2 = new Date(e2 + 288e5);
-    return i2.setHours(15, 0, 0, 0), i2;
-}
-
-function jT(t3, e2, i2) {
-    let s2, n2, r2, o2, a2, {
-            reportPosition: l2 = null
-        } = e2,
-        {
-            lang: h2 = "en"
-        } = e2;
-    let c2 = null,
-        u2 = [];
-    pt(async () => {
-        let t4 = null;
-        t4 = l2, i2(16, u2 = []), t4 ? (i2(0, c2 = t4.positionConfig), null !== c2 && (i2(0, c2.created = new Date(c2.created), c2), i2(0, c2.scheduled = new Date(c2.scheduled), c2)), t4.positions.forEach((t5) => {
-            t5 instanceof Map && (t5 = BT(t5)), t5.entryDate = new Date(t5.entryDate), t5.exitDate = new Date(t5.exitDate), t5.entrySigDate = new Date(t5.entrySigDate), t5.exitSigDate = new Date(t5.exitSigDate), t5.action && (t5.action.date = new Date(t5.action.date)), aT(t5) ? u2.push(t5) : console.log("Invalid position:", t5);
-        })) : console.log("No such document!"), window.positions = u2;
-    });
-    const d2 = {
-        resample: {
-            formatter: (t4) => s2("position.resampleValue." + t4) || t4,
-            unit: ""
-        },
-        created: {
-            formatter: (t4) => c2.isDailyStrategy ? t4.toLocaleDateString() : t4.toLocaleString(),
-            unit: ""
-        },
-        sl: {
-            shown: (t4) => 1 != t4,
-            formatter: (t4) => 100 !== t4 ? -(100 * t4).toFixed() : "無",
-            unit: "%"
-        },
-        tp: {
-            shown: (t4) => t4 < 1e5,
-            formatter: (t4) => "+" + (100 * t4).toFixed(),
-            unit: "%"
-        },
-        ts: {
-            shown: (t4) => t4 < 1e5,
-            formatter: (t4) => "+" + (100 * t4).toFixed(),
-            unit: "%"
-        }
-    };
-    let f2;
-    const p2 = /* @__PURE__ */ new Date();
-    let m2, g2 = false,
-        y2 = false;
-    async function v2(t4) {
-        await Lt(), await new Promise((t5) => setTimeout(t5, 500));
-        let e3 = m2.scrollHeight + 120,
-            i3 = t4 ? t4.assetId : "";
-        window.parent.postMessage({
-            frameHeight: e3,
-            tab: "選股 " + i3
-        }, "*");
-    }
-    return t3.$$set = (t4) => {
-        "reportPosition" in t4 && i2(14, l2 = t4.reportPosition), "lang" in t4 && i2(15, h2 = t4.lang);
-    }, t3.$$.update = () => {
-        32768 & t3.$$.dirty[0] && i2(1, s2 = (t4) => "en" === h2 ? sl(t4) : nl(t4)), 65536 & t3.$$.dirty[0] && i2(17, n2 = u2.sort((t4, e3) => {
-            var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
-            return "entry" === ((_a2 = t4.action) == null ? void 0 : _a2.type) && "entry" !== ((_b2 = e3.action) == null ? void 0 : _b2.type) ? -1 : "entry" !== ((_c2 = t4.action) == null ? void 0 : _c2.type) && "entry" === ((_d2 = e3.action) == null ? void 0 : _d2.type) ? 1 : "exit" === ((_e2 = t4.action) == null ? void 0 : _e2.type) && "exit" !== ((_f2 = e3.action) == null ? void 0 : _f2.type) ? -1 : "exit" !== ((_g2 = t4.action) == null ? void 0 : _g2.type) && "exit" === ((_h2 = e3.action) == null ? void 0 : _h2.type) ? 1 : e3.entryDate.getTime() - t4.entryDate.getTime();
-        })), 131072 & t3.$$.dirty[0] && i2(2, f2 = n2.filter((t4) => "hold" == t4.action.type || "exit" == t4.action.type)), 2 & t3.$$.dirty[0] && i2(8, r2 = [{
-            key: "name",
-            name: s2("position.assetName"),
-            sort: false,
-            width: "160px"
-        }, {
-            key: "profit",
-            name: s2("position.profit"),
-            sort: true,
-            width: "160px"
-        }, {
-            key: "entryDate",
-            name: s2("position.entryDate"),
-            sort: true,
-            width: "180px"
-        }, {
-            key: "currentWeight",
-            name: s2("position.currentWeight"),
-            sort: true,
-            width: "160px"
-        }, {
-            key: "RSV",
-            name: s2("position.RSV"),
-            sort: false,
-            width: "240px"
-        }]), 131073 & t3.$$.dirty[0] && i2(7, o2 = n2.filter((t4) => {
-            var _a2, _b2, _c2;
-            return t4.exitSigDate >= new Date(c2.lastTimestamp) && p2 > UT(t4.exitSigDate) && (0 === t4.nextWeight || "exit" === ((_a2 = t4.action) == null ? void 0 : _a2.type) && ("tp" === ((_b2 = t4.action) == null ? void 0 : _b2.reason) || "sl" === ((_c2 = t4.action) == null ? void 0 : _c2.reason))) || function(t5) {
-                var _a3, _b3;
-                return ("tp_enter" === ((_a3 = t5.action) == null ? void 0 : _a3.reason) || "sl_enter" === ((_b3 = t5.action) == null ? void 0 : _b3.reason)) && 0 !== t5.currentWeight && c2.scheduled && p2 < UT(c2.scheduled);
-            }(t4);
-        })), 131073 & t3.$$.dirty[0] && i2(6, a2 = n2.filter((t4) => t4.entrySigDate >= new Date(c2.lastTimestamp) && p2 > UT(t4.entrySigDate) && 0 !== t4.nextWeight || function(t5) {
-            var _a2, _b2;
-            return ("tp_enter" === ((_a2 = t5.action) == null ? void 0 : _a2.reason) || "sl_enter" === ((_b2 = t5.action) == null ? void 0 : _b2.reason)) && 0 === t5.currentWeight && c2.scheduled && p2 >= UT(c2.scheduled);
-        }(t4)));
-    }, [c2, s2, f2, g2, y2, m2, a2, o2, r2, (t4) => t4 > 0 ? "▴ " : "▾ ", d2, function() {
-        i2(4, y2 = false);
-    }, function() {
-        localStorage.setItem("strategyAnalyticTab", "position"), v2();
-    }, v2, l2, h2, u2, n2, function() {
-        g2 = this.checked, i2(3, g2);
-    }, (t4) => {
-        Ou() ? (localStorage.setItem("strategyAnalyticTab", "position"), v2(t4)) : i2(4, y2 = true), ud.set(t4);
-    }, function(t4) {
-        xt[t4 ? "unshift" : "push"](() => {
-            m2 = t4, i2(5, m2);
-        });
-    }];
-}
-class Position extends SvelteComponent {
-    constructor(t3) {
-        super(), ve(this, t3, jT, zT, o, {
-            reportPosition: 14,
-            lang: 15
-        }, uT, [-1, -1]);
-    }
-    get reportPosition() {
-        return this.$$.ctx[14];
-    }
-    set reportPosition(t3) {
-        this.$$set({
-            reportPosition: t3
-        }), te();
-    }
-    get lang() {
-        return this.$$.ctx[15];
-    }
-    set lang(t3) {
-        this.$$set({
-            lang: t3
-        }), te();
-    }
-}
-if (we(Position, {
-        reportPosition: {},
-        lang: {}
-    }, [], [], true), "undefined" != typeof window) {
-    let HT = function() {
-        var t3 = document.body,
-            e2 = document.getElementById("__svg__icons__dom__");
-        e2 || ((e2 = document.createElementNS("http://www.w3.org/2000/svg", "svg")).style.position = "absolute", e2.style.width = "0", e2.style.height = "0", e2.id = "__svg__icons__dom__", e2.setAttribute("xmlns", "http://www.w3.org/2000/svg"), e2.setAttribute("xmlns:link", "http://www.w3.org/1999/xlink")), e2.innerHTML = '<symbol viewBox="0 0 24 24" fill="none"  id="icon-barChart"><path d="M9 11v9m0-9H4.6c-.56 0-.84 0-1.054.109a1 1 0 0 0-.437.437C3 11.76 3 12.04 3 12.6V20h6m0-9V5.6c0-.56 0-.84.109-1.054a1 1 0 0 1 .437-.437C9.76 4 10.04 4 10.6 4h2.8c.56 0 .84 0 1.054.109.188.096.34.249.437.437C15 4.76 15 5.04 15 5.6V8M9 20h6m0 0h6V9.6c0-.56 0-.84-.11-1.054a.997.997 0 0 0-.435-.437C20.24 8 19.96 8 19.4 8H15m0 12V8" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" /></symbol><symbol fill="currentColor"  viewBox="0 0 24 24" id="icon-checked"><g data-name="Layer 2"><path d="M9.86 18a1 1 0 0 1-.73-.32l-4.86-5.17a1 1 0 1 1 1.46-1.37l4.12 4.39 8.41-9.2a1 1 0 1 1 1.48 1.34l-9.14 10a1 1 0 0 1-.73.33z" data-name="checkmark" /></g></symbol><symbol  viewBox="0 0 48 48" id="icon-chinese"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="4"><rect width="36" height="36" x="6" y="6" stroke-linejoin="round" rx="3" /><path stroke-linejoin="round" d="M14 18h20v10H14z" /><path d="M24 14v21" /></g></symbol><symbol  viewBox="0 0 24 24" id="icon-close"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" /></symbol><symbol  viewBox="0 0 24 24" id="icon-code"><path d="M9.4 16.6 4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0 4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z" /></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-copy"><path d="M9 9V6.2c0-1.12 0-1.68.218-2.108.192-.377.497-.682.874-.874C10.52 3 11.08 3 12.2 3h5.6c1.12 0 1.68 0 2.108.218a2 2 0 0 1 .874.874C21 4.52 21 5.08 21 6.2v5.6c0 1.12 0 1.68-.218 2.108a2.002 2.002 0 0 1-.874.874C19.48 15 18.92 15 17.803 15H15M9 9H6.2c-1.12 0-1.68 0-2.108.218a1.999 1.999 0 0 0-.874.874C3 10.52 3 11.08 3 12.2v5.6c0 1.12 0 1.68.218 2.108a2 2 0 0 0 .874.874c.427.218.987.218 2.105.218h5.607c1.117 0 1.676 0 2.104-.218.376-.192.683-.498.874-.874.218-.428.218-.987.218-2.105V15M9 9h2.8c1.12 0 1.68 0 2.108.218a2 2 0 0 1 .874.874c.218.427.218.987.218 2.105V15" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" /></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-dark-mode"><path opacity=".1" d="M20.867 15.316c.052-.118-.066-.238-.188-.194-3.362 1.215-7.23.498-9.767-2.038-2.525-2.525-3.243-6.367-2.05-9.718.049-.139-.088-.273-.222-.213l-.027.012c-1.855.838-3.506 2.252-4.476 4.032a9.335 9.335 0 0 0 2.255 11.664A9.344 9.344 0 0 0 12.332 21a9.344 9.344 0 0 0 5.23-1.601c1.427-.964 2.557-2.423 3.27-4.003l.035-.08Z" /><path d="M20.867 15.316c.052-.118-.066-.238-.188-.194-3.362 1.215-7.23.498-9.767-2.038-2.525-2.525-3.243-6.367-2.05-9.718.049-.139-.088-.273-.222-.213l-.027.012c-1.855.838-3.506 2.252-4.476 4.032a9.335 9.335 0 0 0 2.255 11.664A9.344 9.344 0 0 0 12.332 21a9.344 9.344 0 0 0 5.23-1.601c1.427-.964 2.557-2.423 3.27-4.003l.035-.08Z" /></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-diamond"><path d="M12 21v-9m0 9 3-3m-3 3-3-3m3-6V3m0 9H3m9 0h9m-9-9L9 6m3-3 3 3M3 12l3 3m-3-3 3-3m15 3-3-3m3 3-3 3" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" /></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-drag"><g stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 18a1 1 0 1 0 2 0 1 1 0 0 0-2 0ZM8 18a1 1 0 1 0 2 0 1 1 0 0 0-2 0ZM14 12a1 1 0 1 0 2 0 1 1 0 0 0-2 0ZM8 12a1 1 0 1 0 2 0 1 1 0 0 0-2 0ZM14 6a1 1 0 1 0 2 0 1 1 0 0 0-2 0ZM8 6a1 1 0 1 0 2 0 1 1 0 0 0-2 0Z" /></g></symbol><symbol  viewBox="0 0 48 48" id="icon-english"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="4"><rect width="36" height="36" x="6" y="6" rx="3" /><path d="M13 31V17h8m-8 7h7.5M13 31h7.5m5.5 0V19m0 12v-6.5a4.5 4.5 0 0 1 4.5-4.5v0a4.5 4.5 0 0 1 4.5 4.5V31" /></g></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-fail"><circle cx="12" cy="12" r="10" /><path d="m14.5 9.5-5 5m0-5 5 5" /></symbol><symbol  viewBox="0 0 24 24" id="icon-favorite"><path d="M12 20.325q-.35 0-.712-.125t-.638-.4l-1.725-1.575q-2.65-2.425-4.788-4.812T2 8.15Q2 5.8 3.575 4.225T7.5 2.65q1.325 0 2.5.562t2 1.538q.825-.975 2-1.537t2.5-.563q2.35 0 3.925 1.575T22 8.15q0 2.875-2.125 5.275T15.05 18.25l-1.7 1.55q-.275.275-.637.4t-.713.125M11.05 6.75q-.725-1.025-1.55-1.563t-2-.537q-1.5 0-2.5 1t-1 2.5q0 1.3.925 2.763t2.213 2.837q1.287 1.375 2.65 2.575T12 18.3q.85-.775 2.213-1.975t2.65-2.575q1.287-1.375 2.212-2.837T20 8.15q0-1.5-1-2.5t-2.5-1q-1.175 0-2 .538T12.95 6.75q-.175.25-.425.375T12 7.25q-.275 0-.525-.125t-.425-.375m.95 4.725" /></symbol><symbol  viewBox="0 0 248 348" id="icon-finlab"><path d="M145.3 28.8c-7.4 2.7-11.9 6-15.7 11.7-6.2 9.4-7.1 18.9-2.6 29.3 5.5 12.8 21.6 20.8 34.7 17.2 18.4-5.1 28.6-26.2 20.3-42.3-7.2-13.9-23-20.8-36.7-15.9zM104.5 90.5c-4.7 2.5-6.4 4.5-7.6 8.6-1.7 5.4-.4 10.4 3.6 14.4 8.7 8.6 22.9 3.5 24.2-8.8.5-4.9-1.8-10-5.8-13-3.7-2.6-10.6-3.2-14.4-1.2zM114.6 135.7l-2.9.5.7 14.6c.3 8.1 1.1 18.4 1.6 23l.9 8.2-36.7 55.3c-42 63-46.7 70.5-45.7 71.5.3.4 45.4.8 100.1 1 82.3.2 99.4 0 99.4-1.1 0-2.2-11.3-21-45.4-75.7l-32.7-52.5.5-7.5c.4-4.1.9-14.1 1.3-22.1l.6-14.6-3.9-.6c-4.2-.7-33-.7-37.8 0zm32.7 72.3c26.8 42.7 47.7 77.1 47.7 78.6 0 1.6-54.3 2.7-93.3 1.8l-31.6-.7 1.6-3.1c2.6-4.9 47.2-72.7 51-77.4l3.5-4.3 9.1.3 9.2.3 2.8 4.5z" /><path d="M116.3 242.2c-5.4 5.9-21.3 30.3-21.3 32.6 0 .9 9.1 1.2 35.3 1.2 34.7 0 39.7-.3 39.7-2.2 0-2.4-17-25.8-18.8-25.8-.8 0-3.7 2-6.4 4.5-2.8 2.5-5.6 4.5-6.4 4.5-.8 0-5.4-3.8-10.3-8.5-5-4.7-9.2-8.5-9.4-8.5-.2 0-1.3 1-2.4 2.2z" /></symbol><symbol  viewBox="0 0 24 24" id="icon-heart-minus"><path d="M15 14v-2h8v2zm-4 7-3.175-2.85q-1.8-1.625-3.088-2.9t-2.125-2.4q-.837-1.125-1.225-2.175T1 8.475q0-2.35 1.575-3.912T6.5 3q1.3 0 2.475.538T11 5.075q.85-1 2.025-1.537T15.5 3q2.125 0 3.563 1.288T20.85 7.3q-.45-.175-.9-.262t-.875-.088q-2.525 0-4.3 1.763T13 13q0 1.3.525 2.463T15 17.45q-.475.425-1.237 1.088T12.45 19.7z" /></symbol><symbol  viewBox="0 0 24 24" id="icon-info"><path d="M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" /></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-light-mode"><path opacity=".1" d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z" /><path d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0ZM12 5V3M17 7l2-2M19 12h2M17 17l2 2M12 19v2M7 17l-2 2M5 12H3M5 5l2 2" /></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-lineChart"><path d="M3 15v1.8c0 1.12 0 1.68.218 2.108a2 2 0 0 0 .874.874c.427.218.987.218 2.105.218H21M3 15V5m0 10 3.853-3.21.004-.003c.697-.581 1.046-.872 1.425-.99.447-.14.929-.118 1.362.061.367.153.688.474 1.332 1.118l.006.006c.654.654.981.982 1.354 1.133a2 2 0 0 0 1.385.046c.383-.128.733-.434 1.433-1.046L21 7" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" /></symbol><symbol  class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" id="icon-menu"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h8m-8 6h16" /></symbol><symbol  class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" id="icon-notification"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0 1 18 14.158V11a6.002 6.002 0 0 0-4-5.659V5a2 2 0 1 0-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 1 1-6 0v-1m6 0H9" /></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-pass"><circle cx="12" cy="12" r="10" /><path d="m8.5 12.5 2 2 5-5" /></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-pieChart"><path d="M12 3a9 9 0 1 0 9 9m-9-9a9 9 0 0 1 9 9m-9-9v9m9 0h-9m6 6.5L12 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" /></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-plus"><path d="M8 12h4m0 0h4m-4 0v4m0-4V8m0 13a9 9 0 1 1 0-18 9 9 0 0 1 0 18Z" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" /></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-save"><path d="M17 21H7m10 0h.803c1.118 0 1.677 0 2.104-.218.377-.192.683-.498.875-.874.218-.427.218-.987.218-2.105V9.22c0-.45 0-.675-.048-.889a1.994 1.994 0 0 0-.209-.545c-.106-.19-.256-.355-.55-.682l-2.755-3.062c-.341-.378-.514-.57-.721-.708a1.999 1.999 0 0 0-.61-.271C15.863 3 15.6 3 15.075 3H6.2c-1.12 0-1.68 0-2.108.218a1.999 1.999 0 0 0-.874.874C3 4.52 3 5.08 3 6.2v11.6c0 1.12 0 1.68.218 2.107.192.377.497.683.874.875.427.218.987.218 2.105.218H7m10 0v-3.803c0-1.118 0-1.678-.218-2.105a2.001 2.001 0 0 0-.875-.874C15.48 14 14.92 14 13.8 14h-3.6c-1.12 0-1.68 0-2.108.218a1.999 1.999 0 0 0-.874.874C7 15.52 7 16.08 7 17.2V21m8-14H9" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" /></symbol><symbol class="w-4 h-4 text-gray-500 dark:text-gray-400" aria-hidden="true"  fill="none" viewBox="0 0 20 20" id="icon-search"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m19 19-4-4m0-7A7 7 0 1 1 1 8a7 7 0 0 1 14 0Z" /></symbol><symbol viewBox="-102.4 -102.4 1228.8 1228.8"  fill="currentColor" stroke="currentColor" stroke-width=".5" id="icon-setting"><path d="M600.704 64a32 32 0 0 1 30.464 22.208l35.2 109.376c14.784 7.232 28.928 15.36 42.432 24.512l112.384-24.192a32 32 0 0 1 34.432 15.36L944.32 364.8a32 32 0 0 1-4.032 37.504l-77.12 85.12a357.12 357.12 0 0 1 0 49.024l77.12 85.248a32 32 0 0 1 4.032 37.504l-88.704 153.6a32 32 0 0 1-34.432 15.296L708.8 803.904c-13.44 9.088-27.648 17.28-42.368 24.512l-35.264 109.376A32 32 0 0 1 600.704 960H423.296a32 32 0 0 1-30.464-22.208L357.696 828.48a351.616 351.616 0 0 1-42.56-24.64l-112.32 24.256a32 32 0 0 1-34.432-15.36L79.68 659.2a32 32 0 0 1 4.032-37.504l77.12-85.248a357.12 357.12 0 0 1 0-48.896l-77.12-85.248A32 32 0 0 1 79.68 364.8l88.704-153.6a32 32 0 0 1 34.432-15.296l112.32 24.256c13.568-9.152 27.776-17.408 42.56-24.64l35.2-109.312A32 32 0 0 1 423.232 64H600.64zm-23.424 64H446.72l-36.352 113.088-24.512 11.968a294.113 294.113 0 0 0-34.816 20.096l-22.656 15.36-116.224-25.088-65.28 113.152 79.68 88.192-1.92 27.136a293.12 293.12 0 0 0 0 40.192l1.92 27.136-79.808 88.192 65.344 113.152 116.224-25.024 22.656 15.296a294.113 294.113 0 0 0 34.816 20.096l24.512 11.968L446.72 896h130.688l36.48-113.152 24.448-11.904a288.282 288.282 0 0 0 34.752-20.096l22.592-15.296 116.288 25.024 65.28-113.152-79.744-88.192 1.92-27.136a293.12 293.12 0 0 0 0-40.256l-1.92-27.136 79.808-88.128-65.344-113.152-116.288 24.96-22.592-15.232a287.616 287.616 0 0 0-34.752-20.096l-24.448-11.904L577.344 128zM512 320a192 192 0 1 1 0 384 192 192 0 0 1 0-384zm0 64a128 128 0 1 0 0 256 128 128 0 0 0 0-256z" /></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-shield"><path d="m15 9-4 4-2-2m11-.835c0 6.568-4.968 9.513-7.074 10.466l-.003.002c-.221.1-.332.15-.584.193-.16.028-.518.028-.677 0a2.01 2.01 0 0 1-.588-.195C8.968 19.678 4 16.733 4 10.165V6.2c0-1.12 0-1.68.218-2.108.192-.377.497-.682.874-.874C5.52 3 6.08 3 7.2 3h9.6c1.12 0 1.68 0 2.107.218.377.192.683.497.875.874.218.427.218.987.218 2.105v3.968Z" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" /></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-star-filled"><path d="M9.153 5.408C10.42 3.136 11.053 2 12 2c.947 0 1.58 1.136 2.847 3.408l.328.588c.36.646.54.969.82 1.182.28.213.63.292 1.33.45l.636.144c2.46.557 3.689.835 3.982 1.776.292.94-.546 1.921-2.223 3.882l-.434.507c-.476.557-.715.836-.822 1.18-.107.345-.071.717.001 1.46l.066.677c.253 2.617.38 3.925-.386 4.506-.766.582-1.918.051-4.22-1.009l-.597-.274c-.654-.302-.981-.452-1.328-.452-.347 0-.674.15-1.329.452l-.595.274c-2.303 1.06-3.455 1.59-4.22 1.01-.767-.582-.64-1.89-.387-4.507l.066-.676c.072-.744.108-1.116 0-1.46-.106-.345-.345-.624-.821-1.18l-.434-.508c-1.677-1.96-2.515-2.941-2.223-3.882.293-.941 1.523-1.22 3.983-1.776l.636-.144c.699-.158 1.048-.237 1.329-.45.28-.213.46-.536.82-1.182l.328-.588Z" fill="currentColor" stroke="currentColor" /></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-star"><path d="M9.153 5.408C10.42 3.136 11.053 2 12 2c.947 0 1.58 1.136 2.847 3.408l.328.588c.36.646.54.969.82 1.182.28.213.63.292 1.33.45l.636.144c2.46.557 3.689.835 3.982 1.776.292.94-.546 1.921-2.223 3.882l-.434.507c-.476.557-.715.836-.822 1.18-.107.345-.071.717.001 1.46l.066.677c.253 2.617.38 3.925-.386 4.506-.766.582-1.918.051-4.22-1.009l-.597-.274c-.654-.302-.981-.452-1.328-.452-.347 0-.674.15-1.329.452l-.595.274c-2.303 1.06-3.455 1.59-4.22 1.01-.767-.582-.64-1.89-.387-4.507l.066-.676c.072-.744.108-1.116 0-1.46-.106-.345-.345-.624-.821-1.18l-.434-.508c-1.677-1.96-2.515-2.941-2.223-3.882.293-.941 1.523-1.22 3.983-1.776l.636-.144c.699-.158 1.048-.237 1.329-.45.28-.213.46-.536.82-1.182l.328-.588Z" stroke="currentColor" /></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-trophy"><path d="M15 13V9m0 0h-4m4 0-6 6m12-3a9 9 0 1 0-18 0 9 9 0 0 0 18 0Z" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" /></symbol>', t3.insertBefore(e2, t3.lastChild);
-    };
-    "loading" === document.readyState ? document.addEventListener("DOMContentLoaded", HT) : HT();
-}
-
-function WT(t3) {
-    const e2 = t3 - 1;
-    return e2 * e2 * e2 + 1;
-}
-
-function qT(t3, {
-    delay: e2 = 0,
-    duration: i2 = 400,
-    easing: s2 = WT,
-    axis: n2 = "y"
-} = {}) {
-    const r2 = getComputedStyle(t3),
-        o2 = +r2.opacity,
-        a2 = "y" === n2 ? "height" : "width",
-        l2 = parseFloat(r2[a2]),
-        h2 = "y" === n2 ? ["top", "bottom"] : ["left", "right"],
-        c2 = h2.map((t4) => `${t4[0].toUpperCase()}${t4.slice(1)}`),
-        u2 = parseFloat(r2[`padding${c2[0]}`]),
-        d2 = parseFloat(r2[`padding${c2[1]}`]),
-        f2 = parseFloat(r2[`margin${c2[0]}`]),
-        p2 = parseFloat(r2[`margin${c2[1]}`]),
-        m2 = parseFloat(r2[`border${c2[0]}Width`]),
-        g2 = parseFloat(r2[`border${c2[1]}Width`]);
-    return {
-        delay: e2,
-        duration: i2,
-        easing: s2,
-        css: (t4) => `overflow: hidden;opacity: ${Math.min(20 * t4, 1) * o2};${a2}: ${t4 * l2}px;padding-${h2[0]}: ${t4 * u2}px;padding-${h2[1]}: ${t4 * d2}px;margin-${h2[0]}: ${t4 * f2}px;margin-${h2[1]}: ${t4 * p2}px;border-${h2[0]}-width: ${t4 * m2}px;border-${h2[1]}-width: ${t4 * g2}px;`
-    };
-}
-
-function KT(t3, e2, i2) {
-    const s2 = t3.slice();
-    return s2[26] = e2[i2][0], s2[27] = e2[i2][1], s2;
-}
-
-function GT(t3, e2, i2) {
-    const s2 = t3.slice();
-    return s2[11] = e2[i2][0], s2[23] = e2[i2][1], s2;
-}
-
-function YT(t3, e2, i2) {
-    const s2 = t3.slice();
-    return s2[26] = e2[i2][0], s2[27] = e2[i2][1], s2;
-}
-
-function QT(t3, e2, i2) {
-    const s2 = t3.slice();
-    return s2[26] = e2[i2][0], s2[23] = e2[i2][1], s2;
-}
-
-function XT(t3, e2, i2) {
-    const s2 = t3.slice();
-    return s2[34] = e2[i2], s2[12] = i2, s2;
-}
-
-function JT(t3, e2, i2) {
-    const s2 = t3.slice();
-    return s2[36] = e2[i2], s2;
-}
-
-function ZT(t3) {
-    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2 = t3[5] && tS(t3),
-        u2 = ue(t3[14]),
-        d2 = [];
-    for (let e3 = 0; e3 < u2.length; e3 += 1)
-        d2[e3] = eS(JT(t3, u2, e3));
-    return {
-        c() {
-            e2 = P("div"), i2 = P("div"), s2 = P("div"), c2 && c2.c(), n2 = $(), r2 = P("div"), o2 = P("div");
-            for (let t4 = 0; t4 < d2.length; t4 += 1)
-                d2[t4].c();
-            a2 = $(), l2 = P("div"), G(s2, "margin-left", "-4px"), U(s2, "class", "flex items-end flex-1 -mt-2"), U(o2, "role", "tablist"), U(o2, "class", "tabs tabs-boxed bg-base-100"), U(r2, "class", "flex-1 w-full bg-base-100 rounded-lg"), U(l2, "class", "flex-1 text-right text-base-content-200 flex items-center justify-end"), U(i2, "class", "flex gap-4 h-20 items-center"), U(e2, "class", "sticky top-0 z-[21] backdrop-blur-lg");
-        },
-        m(t4, u3) {
-            S(t4, e2, u3), _(e2, i2), _(i2, s2), c2 && c2.m(s2, null), _(i2, n2), _(i2, r2), _(r2, o2);
-            for (let t5 = 0; t5 < d2.length; t5 += 1)
-                d2[t5] && d2[t5].m(o2, null);
-            _(i2, a2), _(i2, l2), h2 = true;
-        },
-        p(t4, e3) {
-            if (t4[5] ? c2 ? (c2.p(t4, e3), 32 & e3[0] && le(c2, 1)) : (c2 = tS(t4), c2.c(), le(c2, 1), c2.m(s2, null)) : c2 && (oe(), he(c2, 1, 1, () => {
-                    c2 = null;
-                }), ae()), 49472 & e3[0]) {
-                let i3;
-                for (u2 = ue(t4[14]), i3 = 0; i3 < u2.length; i3 += 1) {
-                    const s3 = JT(t4, u2, i3);
-                    d2[i3] ? d2[i3].p(s3, e3) : (d2[i3] = eS(s3), d2[i3].c(), d2[i3].m(o2, null));
-                }
-                for (; i3 < d2.length; i3 += 1)
-                    d2[i3].d(1);
-                d2.length = u2.length;
-            }
-        },
-        i(t4) {
-            h2 || (le(c2), h2 = true);
-        },
-        o(t4) {
-            he(c2), h2 = false;
-        },
-        d(t4) {
-            t4 && E(e2), c2 && c2.d(), C(d2, t4);
-        }
-    };
-}
-
-function tS(t3) {
-    let e2, i2, s2, n2, r2;
-    return i2 = new Du({
-        props: {
-            name: "finlab",
-            className: "w-6 h-10",
-            color: "light" === t3[2] || null === t3[2] ? "rgb(31 41 55)" : "rgb(209 213 219)"
-        }
-    }), {
-        c() {
-            e2 = P("div"), me(i2.$$.fragment), s2 = $(), n2 = P("div"), n2.innerHTML = '<span class="text-base-content-300 font-bold">FinLab</span>', U(e2, "class", "w-8 flex justify-center");
-        },
-        m(t4, o2) {
-            S(t4, e2, o2), ge(i2, e2, null), S(t4, s2, o2), S(t4, n2, o2), r2 = true;
-        },
-        p(t4, e3) {
-            const s3 = {};
-            4 & e3[0] && (s3.color = "light" === t4[2] || null === t4[2] ? "rgb(31 41 55)" : "rgb(209 213 219)"), i2.$set(s3);
-        },
-        i(t4) {
-            r2 || (le(i2.$$.fragment, t4), r2 = true);
-        },
-        o(t4) {
-            he(i2.$$.fragment, t4), r2 = false;
-        },
-        d(t4) {
-            t4 && (E(e2), E(s2), E(n2)), ye(i2);
-        }
-    };
-}
-
-function eS(t3) {
-    let e2, i2, s2;
-
-    function n2() {
-        return t3[17](t3[36]);
-    }
-    return {
-        c() {
-            e2 = P("a"), e2.textContent = `${t3[36]}`, U(e2, "role", "tab"), U(e2, "tabindex", "1"), U(e2, "class", "tab"), Y(e2, "tab-active", t3[6] === t3[36]);
-        },
-        m(t4, r2) {
-            S(t4, e2, r2), i2 || (s2 = B(e2, "click", n2), i2 = true);
-        },
-        p(i3, s3) {
-            t3 = i3, 16448 & s3[0] && Y(e2, "tab-active", t3[6] === t3[36]);
-        },
-        d(t4) {
-            t4 && E(e2), i2 = false, s2();
-        }
-    };
-}
-
-function iS(t3) {
-    let e2, i2, s2;
-    return i2 = new Position({
-        props: {
-            reportPosition: t3[4],
-            lang: t3[0]
-        }
-    }), {
-        c() {
-            e2 = P("div"), me(i2.$$.fragment), U(e2, "class", "pb-4");
-        },
-        m(t4, n2) {
-            S(t4, e2, n2), ge(i2, e2, null), s2 = true;
-        },
-        p(t4, e3) {
-            const s3 = {};
-            16 & e3[0] && (s3.reportPosition = t4[4]), 1 & e3[0] && (s3.lang = t4[0]), i2.$set(s3);
-        },
-        i(t4) {
-            s2 || (le(i2.$$.fragment, t4), s2 = true);
-        },
-        o(t4) {
-            he(i2.$$.fragment, t4), s2 = false;
-        },
-        d(t4) {
-            t4 && E(e2), ye(i2);
-        }
-    };
-}
-
-function sS(t3) {
-    let e2, i2, s2 = t3[1] && nS(t3);
-    return {
-        c() {
-            s2 && s2.c(), e2 = z();
-        },
-        m(t4, n2) {
-            s2 && s2.m(t4, n2), S(t4, e2, n2), i2 = true;
-        },
-        p(t4, i3) {
-            t4[1] ? s2 ? (s2.p(t4, i3), 2 & i3[0] && le(s2, 1)) : (s2 = nS(t4), s2.c(), le(s2, 1), s2.m(e2.parentNode, e2)) : s2 && (oe(), he(s2, 1, 1, () => {
-                s2 = null;
-            }), ae());
-        },
-        i(t4) {
-            i2 || (le(s2), i2 = true);
-        },
-        o(t4) {
-            he(s2), i2 = false;
-        },
-        d(t4) {
-            t4 && E(e2), s2 && s2.d(t4);
-        }
-    };
-}
-
-function nS(t3) {
-    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2 = ue(Object.entries(t3[1].metrics).filter(ES)),
-        d2 = [];
-    for (let e3 = 0; e3 < u2.length; e3 += 1)
-        d2[e3] = lS(QT(t3, u2, e3));
-    const f2 = [cS, hS],
-        p2 = [];
-
-    function m2(t4, e3) {
-        return "all" === t4[11] ? 0 : 1;
-    }
-    n2 = m2(t3), r2 = p2[n2] = f2[n2](t3);
-    const g2 = [TS, kS, xS, wS, _S],
-        y2 = [];
-
-    function v2(t4, e3) {
-        return "profitability" === t4[11] ? 0 : "risk" === t4[11] ? 1 : "ratio" === t4[11] ? 2 : "winrate" === t4[11] ? 3 : "liquidity" === t4[11] ? 4 : -1;
-    }
-    return ~(l2 = v2(t3)) && (h2 = y2[l2] = g2[l2](t3)), {
-        c() {
-            e2 = P("div"), i2 = P("div");
-            for (let t4 = 0; t4 < d2.length; t4 += 1)
-                d2[t4].c();
-            s2 = $(), r2.c(), o2 = $(), a2 = P("div"), h2 && h2.c(), U(i2, "class", "items-center justify-center flex overflow-x-auto no-scrollbar divide-x gap-2 -ml-2 -mr-2"), U(a2, "class", "pb-4"), U(e2, "class", "ml-4 md:ml-0");
-        },
-        m(t4, r3) {
-            S(t4, e2, r3), _(e2, i2);
-            for (let t5 = 0; t5 < d2.length; t5 += 1)
-                d2[t5] && d2[t5].m(i2, null);
-            _(e2, s2), p2[n2].m(e2, null), _(e2, o2), _(e2, a2), ~l2 && y2[l2].m(a2, null), c2 = true;
-        },
-        p(t4, s3) {
-            if (40450 & s3[0]) {
-                let e3;
-                for (u2 = ue(Object.entries(t4[1].metrics).filter(ES)), e3 = 0; e3 < u2.length; e3 += 1) {
-                    const n3 = QT(t4, u2, e3);
-                    d2[e3] ? d2[e3].p(n3, s3) : (d2[e3] = lS(n3), d2[e3].c(), d2[e3].m(i2, null));
-                }
-                for (; e3 < d2.length; e3 += 1)
-                    d2[e3].d(1);
-                d2.length = u2.length;
-            }
-            let c3 = n2;
-            n2 = m2(t4), n2 === c3 ? p2[n2].p(t4, s3) : (oe(), he(p2[c3], 1, 1, () => {
-                p2[c3] = null;
-            }), ae(), r2 = p2[n2], r2 ? r2.p(t4, s3) : (r2 = p2[n2] = f2[n2](t4), r2.c()), le(r2, 1), r2.m(e2, o2));
-            let b2 = l2;
-            l2 = v2(t4), l2 === b2 ? ~l2 && y2[l2].p(t4, s3) : (h2 && (oe(), he(y2[b2], 1, 1, () => {
-                y2[b2] = null;
-            }), ae()), ~l2 ? (h2 = y2[l2], h2 ? h2.p(t4, s3) : (h2 = y2[l2] = g2[l2](t4), h2.c()), le(h2, 1), h2.m(a2, null)) : h2 = null);
-        },
-        i(t4) {
-            c2 || (le(r2), le(h2), c2 = true);
-        },
-        o(t4) {
-            he(r2), he(h2), c2 = false;
-        },
-        d(t4) {
-            t4 && E(e2), C(d2, t4), p2[n2].d(), ~l2 && y2[l2].d();
-        }
-    };
-}
-
-function rS(e2) {
-    let i2;
-    return {
-        c() {
-            i2 = P("input"), U(i2, "type", "radio"), i2.readOnly = true, U(i2, "name", "rating-2"), U(i2, "class", "pointer-events-none mask mask-star-2 bg-base-content/10");
-        },
-        m(t3, e3) {
-            S(t3, i2, e3);
-        },
-        p: t,
-        d(t3) {
-            t3 && E(i2);
-        }
-    };
-}
-
-function oS(t3) {
-    let e2, i2;
-    return {
-        c() {
-            e2 = P("input"), U(e2, "type", "radio"), e2.readOnly = true, U(e2, "name", "rating-2"), U(e2, "class", i2 = "pointer-events-none mask mask-star-2 " + (t3[11] == t3[26] ? "bg-white" : "bg-primary"));
-        },
-        m(t4, i3) {
-            S(t4, e2, i3);
-        },
-        p(t4, s2) {
-            2050 & s2[0] && i2 !== (i2 = "pointer-events-none mask mask-star-2 " + (t4[11] == t4[26] ? "bg-white" : "bg-primary")) && U(e2, "class", i2);
-        },
-        d(t4) {
-            t4 && E(e2);
-        }
-    };
-}
-
-function aS(t3) {
-    let e2;
-
-    function i2(t4, e3) {
-        return 0.2 * t4[12] < t4[10][t4[26]] ? oS : rS;
-    }
-    let s2 = i2(t3),
-        n2 = s2(t3);
-    return {
-        c() {
-            n2.c(), e2 = z();
-        },
-        m(t4, i3) {
-            n2.m(t4, i3), S(t4, e2, i3);
-        },
-        p(t4, r2) {
-            s2 === (s2 = i2(t4)) && n2 ? n2.p(t4, r2) : (n2.d(1), n2 = s2(t4), n2 && (n2.c(), n2.m(e2.parentNode, e2)));
-        },
-        d(t4) {
-            t4 && E(e2), n2.d(t4);
-        }
-    };
-}
-
-function lS(t3) {
-    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2, d2 = t3[12](`tabs.${t3[26]}`) + "",
-        f2 = ue(Array.from({
-            length: 5
-        })),
-        p2 = [];
-    for (let e3 = 0; e3 < f2.length; e3 += 1)
-        p2[e3] = aS(XT(t3, f2, e3));
-
-    function m2() {
-        return t3[19](t3[26]);
-    }
-    return {
-        c() {
-            e2 = P("div"), i2 = P("button"), s2 = P("span"), n2 = D(d2), r2 = $(), o2 = P("div"), a2 = P("div");
-            for (let t4 = 0; t4 < p2.length; t4 += 1)
-                p2[t4].c();
-            h2 = $(), U(a2, "class", "rating rating-sm"), U(i2, "class", l2 = "py-2 px-4 ml-2 hover:text-base-content-300 rounded-md " + (t3[11] === t3[26] ? "bg-primary text-white" : "text-base-content-200"));
-        },
-        m(t4, l3) {
-            S(t4, e2, l3), _(e2, i2), _(i2, s2), _(s2, n2), _(i2, r2), _(i2, o2), _(o2, a2);
-            for (let t5 = 0; t5 < p2.length; t5 += 1)
-                p2[t5] && p2[t5].m(a2, null);
-            _(e2, h2), c2 || (u2 = B(i2, "click", m2), c2 = true);
-        },
-        p(e3, s3) {
-            if (t3 = e3, 4098 & s3[0] && d2 !== (d2 = t3[12](`tabs.${t3[26]}`) + "") && H(n2, d2), 3074 & s3[0]) {
-                let e4;
-                for (f2 = ue(Array.from({
-                        length: 5
-                    })), e4 = 0; e4 < f2.length; e4 += 1) {
-                    const i3 = XT(t3, f2, e4);
-                    p2[e4] ? p2[e4].p(i3, s3) : (p2[e4] = aS(i3), p2[e4].c(), p2[e4].m(a2, null));
-                }
-                for (; e4 < p2.length; e4 += 1)
-                    p2[e4].d(1);
-                p2.length = f2.length;
-            }
-            2050 & s3[0] && l2 !== (l2 = "py-2 px-4 ml-2 hover:text-base-content-300 rounded-md " + (t3[11] === t3[26] ? "bg-primary text-white" : "text-base-content-200")) && U(i2, "class", l2);
-        },
-        d(t4) {
-            t4 && E(e2), C(p2, t4), c2 = false, u2();
-        }
-    };
-}
-
-function hS(t3) {
-    let e2, i2, s2, n2, r2 = ue(Object.entries(t3[1].metrics[t3[11]]).splice(0, 6)),
-        o2 = [];
-    for (let e3 = 0; e3 < r2.length; e3 += 1)
-        o2[e3] = pS(KT(t3, r2, e3));
-    const a2 = (t4) => he(o2[t4], 1, 1, () => {
-        o2[t4] = null;
-    });
-    let l2 = null !== t3[9] && mS(t3);
-    return {
-        c() {
-            e2 = P("div"), i2 = P("div");
-            for (let t4 = 0; t4 < o2.length; t4 += 1)
-                o2[t4].c();
-            s2 = $(), l2 && l2.c(), U(i2, "class", "flex overflow-x-auto sm:justify-center divide-x bg-transparent no-scrollbar p-4 min-w-full"), U(e2, "class", "rounded-xl border my-4");
-        },
-        m(t4, r3) {
-            S(t4, e2, r3), _(e2, i2);
-            for (let t5 = 0; t5 < o2.length; t5 += 1)
-                o2[t5] && o2[t5].m(i2, null);
-            _(e2, s2), l2 && l2.m(e2, null), n2 = true;
-        },
-        p(t4, s3) {
-            if (112642 & s3[0]) {
-                let e3;
-                for (r2 = ue(Object.entries(t4[1].metrics[t4[11]]).splice(0, 6)), e3 = 0; e3 < r2.length; e3 += 1) {
-                    const n3 = KT(t4, r2, e3);
-                    o2[e3] ? (o2[e3].p(n3, s3), le(o2[e3], 1)) : (o2[e3] = pS(n3), o2[e3].c(), le(o2[e3], 1), o2[e3].m(i2, null));
-                }
-                for (oe(), e3 = r2.length; e3 < o2.length; e3 += 1)
-                    a2(e3);
-                ae();
-            }
-            null !== t4[9] ? l2 ? (l2.p(t4, s3), 512 & s3[0] && le(l2, 1)) : (l2 = mS(t4), l2.c(), le(l2, 1), l2.m(e2, null)) : l2 && (oe(), he(l2, 1, 1, () => {
-                l2 = null;
-            }), ae());
-        },
-        i(t4) {
-            if (!n2) {
-                for (let t5 = 0; t5 < r2.length; t5 += 1)
-                    le(o2[t5]);
-                le(l2), n2 = true;
-            }
-        },
-        o(t4) {
-            o2 = o2.filter(Boolean);
-            for (let t5 = 0; t5 < o2.length; t5 += 1)
-                he(o2[t5]);
-            he(l2), n2 = false;
-        },
-        d(t4) {
-            t4 && E(e2), C(o2, t4), l2 && l2.d();
-        }
-    };
-}
-
-function cS(t3) {
-    let e2, i2, s2 = ue(Object.entries(t3[1].metrics).filter(CS)),
-        n2 = [];
-    for (let e3 = 0; e3 < s2.length; e3 += 1)
-        n2[e3] = bS(GT(t3, s2, e3));
-    const r2 = (t4) => he(n2[t4], 1, 1, () => {
-        n2[t4] = null;
-    });
-    return {
-        c() {
-            e2 = P("div");
-            for (let t4 = 0; t4 < n2.length; t4 += 1)
-                n2[t4].c();
-            U(e2, "class", "text-base-content-200 grid grid-cols-5 gap-4 p-4 border rounded-xl mt-4");
-        },
-        m(t4, s3) {
-            S(t4, e2, s3);
-            for (let t5 = 0; t5 < n2.length; t5 += 1)
-                n2[t5] && n2[t5].m(e2, null);
-            i2 = true;
-        },
-        p(t4, i3) {
-            if (12290 & i3[0]) {
-                let o2;
-                for (s2 = ue(Object.entries(t4[1].metrics).filter(CS)), o2 = 0; o2 < s2.length; o2 += 1) {
-                    const r3 = GT(t4, s2, o2);
-                    n2[o2] ? (n2[o2].p(r3, i3), le(n2[o2], 1)) : (n2[o2] = bS(r3), n2[o2].c(), le(n2[o2], 1), n2[o2].m(e2, null));
-                }
-                for (oe(), o2 = s2.length; o2 < n2.length; o2 += 1)
-                    r2(o2);
-                ae();
-            }
-        },
-        i(t4) {
-            if (!i2) {
-                for (let t5 = 0; t5 < s2.length; t5 += 1)
-                    le(n2[t5]);
-                i2 = true;
-            }
-        },
-        o(t4) {
-            n2 = n2.filter(Boolean);
-            for (let t5 = 0; t5 < n2.length; t5 += 1)
-                he(n2[t5]);
-            i2 = false;
-        },
-        d(t4) {
-            t4 && E(e2), C(n2, t4);
-        }
-    };
-}
-
-function uS(t3) {
-    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2, d2, f2, p2, m2, g2, y2, v2, b2, w2, x2 = t3[12](`metrics.${t3[11]}.${t3[26]}`) + "",
-        k2 = t3[13].format(t3[26], t3[27]) + "",
-        T2 = t3[13].getUnit(t3[26]) + "";
-    const C2 = [fS, dS],
-        R2 = [];
-
-    function z2(t4, e3) {
-        return 2050 & e3[0] && (n2 = null), null == n2 && (n2 = !!Te[t4[11]][t4[26]](t4[27])), n2 ? 0 : 1;
-    }
-
-    function j2() {
-        return t3[20](t3[26]);
-    }
-    return r2 = z2(t3, [-1, -1]), o2 = R2[r2] = C2[r2](t3), {
-        c() {
-            e2 = P("button"), i2 = P("div"), s2 = P("div"), o2.c(), a2 = $(), l2 = P("div"), h2 = D(x2), c2 = $(), u2 = P("div"), d2 = P("span"), f2 = D(k2), p2 = $(), m2 = P("span"), g2 = D(T2), y2 = $(), U(s2, "class", "flex justify-center w-full"), U(l2, "class", "mt-1 text-base-content-300 text-sm whitespace-no-wrap break-keep whitespace-nowrap overflow-hidden truncate stat-title"), U(d2, "class", "font-bold"), U(m2, "class", "text-sm"), U(u2, "class", "sm:stat-value text-base-content-200 mt-2 whitespace-nowrap"), U(i2, "class", "text-center px-4"), U(e2, "class", "flex-1 border-base-content/10");
-        },
-        m(t4, n3) {
-            S(t4, e2, n3), _(e2, i2), _(i2, s2), R2[r2].m(s2, null), _(i2, a2), _(i2, l2), _(l2, h2), _(i2, c2), _(i2, u2), _(u2, d2), _(d2, f2), _(u2, p2), _(u2, m2), _(m2, g2), _(e2, y2), v2 = true, b2 || (w2 = B(e2, "click", j2), b2 = true);
-        },
-        p(e3, i3) {
-            let n3 = r2;
-            r2 = z2(t3 = e3, i3), r2 === n3 ? R2[r2].p(t3, i3) : (oe(), he(R2[n3], 1, 1, () => {
-                R2[n3] = null;
-            }), ae(), o2 = R2[r2], o2 ? o2.p(t3, i3) : (o2 = R2[r2] = C2[r2](t3), o2.c()), le(o2, 1), o2.m(s2, null)), (!v2 || 6146 & i3[0]) && x2 !== (x2 = t3[12](`metrics.${t3[11]}.${t3[26]}`) + "") && H(h2, x2), (!v2 || 2050 & i3[0]) && k2 !== (k2 = t3[13].format(t3[26], t3[27]) + "") && H(f2, k2), (!v2 || 2050 & i3[0]) && T2 !== (T2 = t3[13].getUnit(t3[26]) + "") && H(g2, T2);
-        },
-        i(t4) {
-            v2 || (le(o2), v2 = true);
-        },
-        o(t4) {
-            he(o2), v2 = false;
-        },
-        d(t4) {
-            t4 && E(e2), R2[r2].d(), b2 = false, w2();
-        }
-    };
-}
-
-function dS(e2) {
-    let i2, s2;
-    return i2 = new Du({
-        props: {
-            name: "fail",
-            className: "w-6 h-6",
-            strokeColor: vu("red")
-        }
-    }), {
-        c() {
-            me(i2.$$.fragment);
-        },
-        m(t3, e3) {
-            ge(i2, t3, e3), s2 = true;
-        },
-        p: t,
-        i(t3) {
-            s2 || (le(i2.$$.fragment, t3), s2 = true);
-        },
-        o(t3) {
-            he(i2.$$.fragment, t3), s2 = false;
-        },
-        d(t3) {
-            ye(i2, t3);
-        }
-    };
-}
-
-function fS(e2) {
-    let i2, s2;
-    return i2 = new Du({
-        props: {
-            name: "pass",
-            className: "w-6 h-6",
-            strokeColor: vu("green")
-        }
-    }), {
-        c() {
-            me(i2.$$.fragment);
-        },
-        m(t3, e3) {
-            ge(i2, t3, e3), s2 = true;
-        },
-        p: t,
-        i(t3) {
-            s2 || (le(i2.$$.fragment, t3), s2 = true);
-        },
-        o(t3) {
-            he(i2.$$.fragment, t3), s2 = false;
-        },
-        d(t3) {
-            ye(i2, t3);
-        }
-    };
-}
-
-function pS(t3) {
-    var _a2;
-    let e2, i2, s2 = ((_a2 = Te[t3[11]]) == null ? void 0 : _a2[t3[26]]) && uS(t3);
-    return {
-        c() {
-            s2 && s2.c(), e2 = z();
-        },
-        m(t4, n2) {
-            s2 && s2.m(t4, n2), S(t4, e2, n2), i2 = true;
-        },
-        p(t4, i3) {
-            var _a3;
-            ((_a3 = Te[t4[11]]) == null ? void 0 : _a3[t4[26]]) ? s2 ? (s2.p(t4, i3), 2050 & i3[0] && le(s2, 1)) : (s2 = uS(t4), s2.c(), le(s2, 1), s2.m(e2.parentNode, e2)): s2 && (oe(), he(s2, 1, 1, () => {
-                s2 = null;
-            }), ae());
-        },
-        i(t4) {
-            i2 || (le(s2), i2 = true);
-        },
-        o(t4) {
-            he(s2), i2 = false;
-        },
-        d(t4) {
-            t4 && E(e2), s2 && s2.d(t4);
-        }
-    };
-}
-
-function mS(i2) {
-    let s2, o2, a2, l2, h2, c2, u2, d2, f2, p2, g2, y2, v2, w2, x2, k2, T2 = i2[12](`metrics.${i2[11]}.${i2[9]}`) + "",
-        C2 = i2[12](`metric.description.${i2[11]}.${i2[9]}`) + "",
-        R2 = i2[12]("metrics.condition") + "",
-        z2 = Te[i2[11]][i2[9]].toString().split("=>")[1] + "";
-    return {
-        c() {
-            s2 = P("div"), o2 = P("div"), a2 = P("h3"), l2 = D(T2), h2 = $(), c2 = P("p"), u2 = D(C2), d2 = $(), f2 = P("h3"), p2 = D(R2), g2 = $(), y2 = P("p"), v2 = D(z2), U(a2, "class", "font-bold text-lg"), U(f2, "class", "font-bold text-lg mt-4"), U(o2, "class", "card-body"), U(s2, "class", "card bg-base-100 shadow-xl text-base-content-300");
-        },
-        m(t3, e2) {
-            S(t3, s2, e2), _(s2, o2), _(o2, a2), _(a2, l2), _(o2, h2), _(o2, c2), _(c2, u2), _(o2, d2), _(o2, f2), _(f2, p2), _(o2, g2), _(o2, y2), _(y2, v2), k2 = true;
-        },
-        p(t3, e2) {
-            (!k2 || 6656 & e2[0]) && T2 !== (T2 = t3[12](`metrics.${t3[11]}.${t3[9]}`) + "") && H(l2, T2), (!k2 || 6656 & e2[0]) && C2 !== (C2 = t3[12](`metric.description.${t3[11]}.${t3[9]}`) + "") && H(u2, C2), (!k2 || 4096 & e2[0]) && R2 !== (R2 = t3[12]("metrics.condition") + "") && H(p2, R2), (!k2 || 2560 & e2[0]) && z2 !== (z2 = Te[t3[11]][t3[9]].toString().split("=>")[1] + "") && H(v2, z2);
-        },
-        i(i3) {
-            k2 || (i3 && Ot(() => {
-                k2 && (x2 && x2.end(1), w2 = function(i4, s3, n2) {
-                    const o3 = {
-                        direction: "in"
-                    };
-                    let a3, l3, h3 = s3(i4, n2, o3),
-                        c3 = false,
-                        u3 = 0;
-
-                    function d3() {
-                        a3 && ut(i4, a3);
-                    }
-
-                    function f3() {
-                        const {
-                            delay: s4 = 0,
-                            duration: n3 = 300,
-                            easing: r2 = e,
-                            tick: o4 = t,
-                            css: f4
-                        } = h3 || ce;
-                        f4 && (a3 = ct(i4, 0, 1, n3, s4, r2, f4, u3++)), o4(0, 1);
-                        const p4 = m() + s4,
-                            g3 = p4 + n3;
-                        l3 && l3.abort(), c3 = true, Ot(() => se(i4, true, "start")), l3 = b((t3) => {
-                            if (c3) {
-                                if (t3 >= g3)
-                                    return o4(1, 0), se(i4, true, "end"), d3(), c3 = false;
-                                if (t3 >= p4) {
-                                    const e2 = r2((t3 - p4) / n3);
-                                    o4(e2, 1 - e2);
-                                }
-                            }
-                            return c3;
-                        });
-                    }
-                    let p3 = false;
-                    return {
-                        start() {
-                            p3 || (p3 = true, ut(i4), r(h3) ? (h3 = h3(o3), ie().then(f3)) : f3());
-                        },
-                        invalidate() {
-                            p3 = false;
-                        },
-                        end() {
-                            c3 && (d3(), c3 = false);
-                        }
-                    };
-                }(s2, qT, {
-                    duration: 300
-                }), w2.start());
-            }), k2 = true);
-        },
-        o(i3) {
-            w2 && w2.invalidate(), i3 && (x2 = function(i4, s3, o3) {
-                const a3 = {
-                    direction: "out"
-                };
-                let l3, h3 = s3(i4, o3, a3),
-                    c3 = true;
-                const u3 = re;
-                let d3;
-
-                function f3() {
-                    const {
-                        delay: s4 = 0,
-                        duration: r2 = 300,
-                        easing: o4 = e,
-                        tick: a4 = t,
-                        css: f4
-                    } = h3 || ce;
-                    f4 && (l3 = ct(i4, 1, 0, r2, s4, o4, f4));
-                    const p3 = m() + s4,
-                        g3 = p3 + r2;
-                    Ot(() => se(i4, false, "start")), "inert" in i4 && (d3 = i4.inert, i4.inert = true), b((t3) => {
-                        if (c3) {
-                            if (t3 >= g3)
-                                return a4(0, 1), se(i4, false, "end"), --u3.r || n(u3.c), false;
-                            if (t3 >= p3) {
-                                const e2 = o4((t3 - p3) / r2);
-                                a4(1 - e2, e2);
-                            }
-                        }
-                        return c3;
-                    });
-                }
-                return u3.r += 1, r(h3) ? ie().then(() => {
-                    h3 = h3(a3), f3();
-                }) : f3(), {
-                    end(t3) {
-                        t3 && "inert" in i4 && (i4.inert = d3), t3 && h3.tick && h3.tick(1, 0), c3 && (l3 && ut(i4, l3), c3 = false);
-                    }
-                };
-            }(s2, qT, {
-                duration: 300
-            })), k2 = false;
-        },
-        d(t3) {
-            t3 && E(s2), t3 && x2 && x2.end();
-        }
-    };
-}
-
-function gS(e2) {
-    let i2, s2;
-    return i2 = new Du({
-        props: {
-            name: "fail",
-            className: "w-6 h-6",
-            strokeColor: vu("red")
-        }
-    }), {
-        c() {
-            me(i2.$$.fragment);
-        },
-        m(t3, e3) {
-            ge(i2, t3, e3), s2 = true;
-        },
-        p: t,
-        i(t3) {
-            s2 || (le(i2.$$.fragment, t3), s2 = true);
-        },
-        o(t3) {
-            he(i2.$$.fragment, t3), s2 = false;
-        },
-        d(t3) {
-            ye(i2, t3);
-        }
-    };
-}
-
-function yS(e2) {
-    let i2, s2;
-    return i2 = new Du({
-        props: {
-            name: "pass",
-            className: "w-6 h-6",
-            strokeColor: vu("green")
-        }
-    }), {
-        c() {
-            me(i2.$$.fragment);
-        },
-        m(t3, e3) {
-            ge(i2, t3, e3), s2 = true;
-        },
-        p: t,
-        i(t3) {
-            s2 || (le(i2.$$.fragment, t3), s2 = true);
-        },
-        o(t3) {
-            he(i2.$$.fragment, t3), s2 = false;
-        },
-        d(t3) {
-            ye(i2, t3);
-        }
-    };
-}
-
-function vS(t3) {
-    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2, d2, f2, p2, m2, g2, y2 = t3[12](`metrics.${t3[11]}.${t3[26]}`) + "",
-        v2 = t3[13].format(t3[26], t3[27]) + "",
-        b2 = t3[13].getUnit(t3[26]) + "";
-    const w2 = [yS, gS],
-        x2 = [];
-
-    function k2(t4, e3) {
-        return 2 & e3[0] && (s2 = null), null == s2 && (s2 = !!(t4[11] in Te && t4[26] in Te[t4[11]] && Te[t4[11]][t4[26]](t4[27]))), s2 ? 0 : 1;
-    }
-    return n2 = k2(t3, [-1, -1]), r2 = x2[n2] = w2[n2](t3), {
-        c() {
-            e2 = P("div"), i2 = P("div"), r2.c(), o2 = $(), a2 = P("div"), l2 = D(y2), h2 = $(), c2 = P("div"), u2 = P("span"), d2 = D(v2), f2 = P("span"), p2 = D(b2), m2 = $(), U(i2, "class", "flex justify-center w-full"), U(a2, "class", "mt-1 text-base-content-300 text-sm whitespace-no-wrap break-keep whitespace-nowrap overflow-hidden truncate stat-title"), U(u2, "class", "font-bold"), U(f2, "class", "text-sm"), U(c2, "class", "text-2xl text-base-content-200 mt-2"), U(e2, "class", "text-center px-4");
-        },
-        m(t4, s3) {
-            S(t4, e2, s3), _(e2, i2), x2[n2].m(i2, null), _(e2, o2), _(e2, a2), _(a2, l2), _(e2, h2), _(e2, c2), _(c2, u2), _(u2, d2), _(c2, f2), _(f2, p2), _(e2, m2), g2 = true;
-        },
-        p(t4, e3) {
-            let s3 = n2;
-            n2 = k2(t4, e3), n2 === s3 ? x2[n2].p(t4, e3) : (oe(), he(x2[s3], 1, 1, () => {
-                x2[s3] = null;
-            }), ae(), r2 = x2[n2], r2 ? r2.p(t4, e3) : (r2 = x2[n2] = w2[n2](t4), r2.c()), le(r2, 1), r2.m(i2, null)), (!g2 || 4098 & e3[0]) && y2 !== (y2 = t4[12](`metrics.${t4[11]}.${t4[26]}`) + "") && H(l2, y2), (!g2 || 2 & e3[0]) && v2 !== (v2 = t4[13].format(t4[26], t4[27]) + "") && H(d2, v2), (!g2 || 2 & e3[0]) && b2 !== (b2 = t4[13].getUnit(t4[26]) + "") && H(p2, b2);
-        },
-        i(t4) {
-            g2 || (le(r2), g2 = true);
-        },
-        o(t4) {
-            he(r2), g2 = false;
-        },
-        d(t4) {
-            t4 && E(e2), x2[n2].d();
-        }
-    };
-}
-
-function bS(t3) {
-    let e2, i2, s2 = ue(Object.entries(t3[1].metrics[t3[11]]).splice(0, 6)),
-        n2 = [];
-    for (let e3 = 0; e3 < s2.length; e3 += 1)
-        n2[e3] = vS(YT(t3, s2, e3));
-    const r2 = (t4) => he(n2[t4], 1, 1, () => {
-        n2[t4] = null;
-    });
-    return {
-        c() {
-            for (let t4 = 0; t4 < n2.length; t4 += 1)
-                n2[t4].c();
-            e2 = z();
-        },
-        m(t4, s3) {
-            for (let e3 = 0; e3 < n2.length; e3 += 1)
-                n2[e3] && n2[e3].m(t4, s3);
-            S(t4, e2, s3), i2 = true;
-        },
-        p(t4, i3) {
-            if (12290 & i3[0]) {
-                let o2;
-                for (s2 = ue(Object.entries(t4[1].metrics[t4[11]]).splice(0, 6)), o2 = 0; o2 < s2.length; o2 += 1) {
-                    const r3 = YT(t4, s2, o2);
-                    n2[o2] ? (n2[o2].p(r3, i3), le(n2[o2], 1)) : (n2[o2] = vS(r3), n2[o2].c(), le(n2[o2], 1), n2[o2].m(e2.parentNode, e2));
-                }
-                for (oe(), o2 = s2.length; o2 < n2.length; o2 += 1)
-                    r2(o2);
-                ae();
-            }
-        },
-        i(t4) {
-            if (!i2) {
-                for (let t5 = 0; t5 < s2.length; t5 += 1)
-                    le(n2[t5]);
-                i2 = true;
-            }
-        },
-        o(t4) {
-            n2 = n2.filter(Boolean);
-            for (let t5 = 0; t5 < n2.length; t5 += 1)
-                he(n2[t5]);
-            i2 = false;
-        },
-        d(t4) {
-            t4 && E(e2), C(n2, t4);
-        }
-    };
-}
-
-function _S(t3) {
-    let e2, i2;
-    return e2 = new Liquidity({
-        props: {
-            report: t3[1],
-            browser: t3[3],
-            theme: t3[2],
-            lang: t3[0]
-        }
-    }), {
-        c() {
-            me(e2.$$.fragment);
-        },
-        m(t4, s2) {
-            ge(e2, t4, s2), i2 = true;
-        },
-        p(t4, i3) {
-            const s2 = {};
-            2 & i3[0] && (s2.report = t4[1]), 8 & i3[0] && (s2.browser = t4[3]), 4 & i3[0] && (s2.theme = t4[2]), 1 & i3[0] && (s2.lang = t4[0]), e2.$set(s2);
-        },
-        i(t4) {
-            i2 || (le(e2.$$.fragment, t4), i2 = true);
-        },
-        o(t4) {
-            he(e2.$$.fragment, t4), i2 = false;
-        },
-        d(t4) {
-            ye(e2, t4);
-        }
-    };
-}
-
-function wS(t3) {
-    let e2, i2;
-    return e2 = new Winrate({
-        props: {
-            report: t3[1],
-            browser: t3[3],
-            theme: t3[2],
-            lang: t3[0]
-        }
-    }), {
-        c() {
-            me(e2.$$.fragment);
-        },
-        m(t4, s2) {
-            ge(e2, t4, s2), i2 = true;
-        },
-        p(t4, i3) {
-            const s2 = {};
-            2 & i3[0] && (s2.report = t4[1]), 8 & i3[0] && (s2.browser = t4[3]), 4 & i3[0] && (s2.theme = t4[2]), 1 & i3[0] && (s2.lang = t4[0]), e2.$set(s2);
-        },
-        i(t4) {
-            i2 || (le(e2.$$.fragment, t4), i2 = true);
-        },
-        o(t4) {
-            he(e2.$$.fragment, t4), i2 = false;
-        },
-        d(t4) {
-            ye(e2, t4);
-        }
-    };
-}
-
-function xS(t3) {
-    let e2, i2;
-    return e2 = new Ratio({
-        props: {
-            report: t3[1],
-            browser: t3[3],
-            theme: t3[2],
-            lang: t3[0]
-        }
-    }), {
-        c() {
-            me(e2.$$.fragment);
-        },
-        m(t4, s2) {
-            ge(e2, t4, s2), i2 = true;
-        },
-        p(t4, i3) {
-            const s2 = {};
-            2 & i3[0] && (s2.report = t4[1]), 8 & i3[0] && (s2.browser = t4[3]), 4 & i3[0] && (s2.theme = t4[2]), 1 & i3[0] && (s2.lang = t4[0]), e2.$set(s2);
-        },
-        i(t4) {
-            i2 || (le(e2.$$.fragment, t4), i2 = true);
-        },
-        o(t4) {
-            he(e2.$$.fragment, t4), i2 = false;
-        },
-        d(t4) {
-            ye(e2, t4);
-        }
-    };
-}
-
-function kS(t3) {
-    let e2, i2;
-    return e2 = new Risk({
-        props: {
-            report: t3[1],
-            browser: t3[3],
-            theme: t3[2],
-            lang: t3[0]
-        }
-    }), {
-        c() {
-            me(e2.$$.fragment);
-        },
-        m(t4, s2) {
-            ge(e2, t4, s2), i2 = true;
-        },
-        p(t4, i3) {
-            const s2 = {};
-            2 & i3[0] && (s2.report = t4[1]), 8 & i3[0] && (s2.browser = t4[3]), 4 & i3[0] && (s2.theme = t4[2]), 1 & i3[0] && (s2.lang = t4[0]), e2.$set(s2);
-        },
-        i(t4) {
-            i2 || (le(e2.$$.fragment, t4), i2 = true);
-        },
-        o(t4) {
-            he(e2.$$.fragment, t4), i2 = false;
-        },
-        d(t4) {
-            ye(e2, t4);
-        }
-    };
-}
-
-function TS(t3) {
-    let e2, i2;
-    return e2 = new Profitability({
-        props: {
-            report: t3[1],
-            browser: t3[3],
-            theme: t3[2],
-            lang: t3[0]
-        }
-    }), {
-        c() {
-            me(e2.$$.fragment);
-        },
-        m(t4, s2) {
-            ge(e2, t4, s2), i2 = true;
-        },
-        p(t4, i3) {
-            const s2 = {};
-            2 & i3[0] && (s2.report = t4[1]), 8 & i3[0] && (s2.browser = t4[3]), 4 & i3[0] && (s2.theme = t4[2]), 1 & i3[0] && (s2.lang = t4[0]), e2.$set(s2);
-        },
-        i(t4) {
-            i2 || (le(e2.$$.fragment, t4), i2 = true);
-        },
-        o(t4) {
-            he(e2.$$.fragment, t4), i2 = false;
-        },
-        d(t4) {
-            ye(e2, t4);
-        }
-    };
-}
-
-function SS(t3) {
-    let e2, i2, s2, n2, r2, o2, a2, l2 = t3[4] && ZT(t3);
-    const h2 = [sS, iS],
-        c2 = [];
-
-    function u2(t4, e3) {
-        return "分析" === t4[6] ? 0 : 1;
-    }
-    return r2 = u2(t3), o2 = c2[r2] = h2[r2](t3), {
-        c() {
-            e2 = P("div"), l2 && l2.c(), i2 = $(), s2 = P("div"), n2 = $(), o2.c();
-        },
-        m(o3, h3) {
-            S(o3, e2, h3), l2 && l2.m(e2, null), _(e2, i2), _(e2, s2), t3[18](s2), _(e2, n2), c2[r2].m(e2, null), t3[21](e2), a2 = true;
-        },
-        p(t4, s3) {
-            t4[4] ? l2 ? (l2.p(t4, s3), 16 & s3[0] && le(l2, 1)) : (l2 = ZT(t4), l2.c(), le(l2, 1), l2.m(e2, i2)) : l2 && (oe(), he(l2, 1, 1, () => {
-                l2 = null;
-            }), ae());
-            let n3 = r2;
-            r2 = u2(t4), r2 === n3 ? c2[r2].p(t4, s3) : (oe(), he(c2[n3], 1, 1, () => {
-                c2[n3] = null;
-            }), ae(), o2 = c2[r2], o2 ? o2.p(t4, s3) : (o2 = c2[r2] = h2[r2](t4), o2.c()), le(o2, 1), o2.m(e2, null));
-        },
-        i(t4) {
-            a2 || (le(l2), le(o2), a2 = true);
-        },
-        o(t4) {
-            he(l2), he(o2), a2 = false;
-        },
-        d(i3) {
-            i3 && E(e2), l2 && l2.d(), t3[18](null), c2[r2].d(), t3[21](null);
-        }
-    };
-}
-const ES = (t3) => "backtest" !== t3[0],
-    CS = (t3) => "backtest" !== t3[0];
-
-function IS(t3, e2, i2) {
-    let s2, n2, {
-            lang: r2 = "en"
-        } = e2,
-        {
-            report: o2 = null
-        } = e2,
-        {
-            theme: a2 = "light"
-        } = e2,
-        {
-            browser: l2 = true
-        } = e2,
-        {
-            reportPosition: h2 = null
-        } = e2,
-        {
-            webcomponent: c2 = false
-        } = e2;
-    const u2 = new MetricDisplay();
-    let d2, f2, p2 = "position" === localStorage.getItem("strategyAnalyticTab") ? "profitability" : localStorage.getItem("strategyAnalyticTab") || "profitability",
-        m2 = "分析";
-    async function g2() {
-        await Lt(), await new Promise((t5) => setTimeout(t5, 500));
-        let t4 = d2.scrollHeight;
-        window.parent.postMessage({
-            frameHeight: t4,
-            tab: m2 + " " + p2
-        }, "*");
-    }
-    pt(async () => {
-        await g2();
-    });
-    let y2 = null;
-
-    function v2(t4) {
-        i2(9, y2 = y2 === t4 ? null : t4);
-    }
-    return t3.$$set = (t4) => {
-        "lang" in t4 && i2(0, r2 = t4.lang), "report" in t4 && i2(1, o2 = t4.report), "theme" in t4 && i2(2, a2 = t4.theme), "browser" in t4 && i2(3, l2 = t4.browser), "reportPosition" in t4 && i2(4, h2 = t4.reportPosition), "webcomponent" in t4 && i2(5, c2 = t4.webcomponent);
-    }, t3.$$.update = () => {
-        1 & t3.$$.dirty[0] && i2(12, s2 = (t4) => "en" === r2 ? sl(t4) : nl(t4)), 2 & t3.$$.dirty[0] && i2(10, n2 = o2 ? Se(o2.metrics) : {});
-    }, [r2, o2, a2, l2, h2, c2, m2, d2, f2, y2, n2, p2, s2, u2, ["分析", "選股"], g2, v2, (t4) => {
-        i2(6, m2 = t4), void 0 !== window && window.scrollY > f2.offsetTop && window.scrollTo(0, f2.offsetTop), g2();
-    }, function(t4) {
-        xt[t4 ? "unshift" : "push"](() => {
-            f2 = t4, i2(8, f2);
-        });
-    }, (t4) => {
-        i2(9, y2 = null), i2(11, p2 = t4), localStorage.setItem("strategyAnalyticTab", t4), g2();
-    }, (t4) => {
-        v2(t4), g2();
-    }, function(t4) {
-        xt[t4 ? "unshift" : "push"](() => {
-            d2 = t4, i2(7, d2);
-        });
-    }];
-}
-class StrategyAnalytic extends SvelteComponent {
-    constructor(t3) {
-        super(), ve(this, t3, IS, SS, o, {
-            lang: 0,
-            report: 1,
-            theme: 2,
-            browser: 3,
-            reportPosition: 4,
-            webcomponent: 5
-        }, null, [-1, -1]);
-    }
-    get lang() {
-        return this.$$.ctx[0];
-    }
-    set lang(t3) {
-        this.$$set({
-            lang: t3
-        }), te();
-    }
-    get report() {
-        return this.$$.ctx[1];
-    }
-    set report(t3) {
-        this.$$set({
-            report: t3
-        }), te();
-    }
-    get theme() {
-        return this.$$.ctx[2];
-    }
-    set theme(t3) {
-        this.$$set({
-            theme: t3
-        }), te();
-    }
-    get browser() {
-        return this.$$.ctx[3];
-    }
-    set browser(t3) {
-        this.$$set({
-            browser: t3
-        }), te();
-    }
-    get reportPosition() {
-        return this.$$.ctx[4];
-    }
-    set reportPosition(t3) {
-        this.$$set({
-            reportPosition: t3
-        }), te();
-    }
-    get webcomponent() {
-        return this.$$.ctx[5];
-    }
-    set webcomponent(t3) {
-        this.$$set({
-            webcomponent: t3
-        }), te();
-    }
-}
-
-function MS(e2) {
-    let i2, s2;
-    return {
-        c() {
-            i2 = R("svg"), s2 = R("use"), U(s2, "href", e2[3]), U(s2, "fill", e2[0]), U(s2, "stroke", e2[1]), U(i2, "class", e2[2]), U(i2, "aria-hidden", "true");
-        },
-        m(t3, e3) {
-            S(t3, i2, e3), _(i2, s2);
-        },
-        p(t3, [e3]) {
-            8 & e3 && U(s2, "href", t3[3]), 1 & e3 && U(s2, "fill", t3[0]), 2 & e3 && U(s2, "stroke", t3[1]), 4 & e3 && U(i2, "class", t3[2]);
-        },
-        i: t,
-        o: t,
-        d(t3) {
-            t3 && E(i2);
-        }
-    };
-}
-
-function PS(t3, e2, i2) {
-    let s2, {
-            prefix: n2 = "icon"
-        } = e2,
-        {
-            name: r2 = ""
-        } = e2,
-        {
-            color: o2 = "#333"
-        } = e2,
-        {
-            strokeColor: a2 = ""
-        } = e2,
-        {
-            className: l2 = ""
-        } = e2;
-    return t3.$$set = (t4) => {
-        "prefix" in t4 && i2(4, n2 = t4.prefix), "name" in t4 && i2(5, r2 = t4.name), "color" in t4 && i2(0, o2 = t4.color), "strokeColor" in t4 && i2(1, a2 = t4.strokeColor), "className" in t4 && i2(2, l2 = t4.className);
-    }, t3.$$.update = () => {
-        48 & t3.$$.dirty && i2(3, s2 = `#${n2}-${r2}`);
-    }, [o2, a2, l2, s2, n2, r2];
-}
-customElements.define("strategy-analytic", we(StrategyAnalytic, {
-    lang: {},
-    report: {
-        type: "Object",
-        reflect: true
-    },
-    theme: {
-        type: "String",
-        reflect: true
-    },
-    browser: {
-        type: "Boolean",
-        reflect: true
-    },
-    reportPosition: {},
-    webcomponent: {
-        type: "Boolean",
-        reflect: true
-    }
-}, [], [], false));
-class Svgicon2 extends SvelteComponent {
-    constructor(t3) {
-        super(), ve(this, t3, PS, MS, o, {
-            prefix: 4,
-            name: 5,
-            color: 0,
-            strokeColor: 1,
-            className: 2
-        });
-    }
-    get prefix() {
-        return this.$$.ctx[4];
-    }
-    set prefix(t3) {
-        this.$$set({
-            prefix: t3
-        }), te();
-    }
-    get name() {
-        return this.$$.ctx[5];
-    }
-    set name(t3) {
-        this.$$set({
-            name: t3
-        }), te();
-    }
-    get color() {
-        return this.$$.ctx[0];
-    }
-    set color(t3) {
-        this.$$set({
-            color: t3
-        }), te();
-    }
-    get strokeColor() {
-        return this.$$.ctx[1];
-    }
-    set strokeColor(t3) {
-        this.$$set({
-            strokeColor: t3
-        }), te();
-    }
-    get className() {
-        return this.$$.ctx[2];
-    }
-    set className(t3) {
-        this.$$set({
-            className: t3
-        }), te();
-    }
-}
-we(Svgicon2, {
-    prefix: {},
-    name: {},
-    color: {},
-    strokeColor: {},
-    className: {}
-}, [], [], true);
-export {
-    xe as I,
-    Liquidity as L,
-    MetricDisplay as M,
-    Profitability as P,
-    Report as R,
-    Stocks as S,
-    Winrate as W,
-    Ratio as a,
-    Risk as b,
-    Se as c,
-    StrategyAnalytic as d,
-    Svgicon2 as e,
-    ke as o,
-    Te as q
+var __defProp = Object.defineProperty;
+var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
+    enumerable: true,
+    configurable: true,
+    writable: true,
+    value
+}) : obj[key] = value;
+var __publicField = (obj, key, value) => {
+    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
+    return value;
+};
+
+function t() {}
+const e = (t3) => t3;
+
+function i(t3) {
+    return t3();
+}
+
+function s() {
+    return /* @__PURE__ */ Object.create(null);
+}
+
+function n(t3) {
+    t3.forEach(i);
+}
+
+function r(t3) {
+    return "function" == typeof t3;
+}
+
+function o(t3, e2) {
+    return t3 != t3 ? e2 == e2 : t3 !== e2 || t3 && "object" == typeof t3 || "function" == typeof t3;
+}
+
+function a(e2, i2, s2) {
+    e2.$$.on_destroy.push(function(e3, ...i3) {
+        if (null == e3) {
+            for (const t3 of i3)
+                t3(void 0);
+            return t;
+        }
+        const s3 = e3.subscribe(...i3);
+        return s3.unsubscribe ? () => s3.unsubscribe() : s3;
+    }(i2, s2));
+}
+
+function l(t3, e2, i2, s2) {
+    if (t3) {
+        const n2 = h(t3, e2, i2, s2);
+        return t3[0](n2);
+    }
+}
+
+function h(t3, e2, i2, s2) {
+    return t3[1] && s2 ? function(t4, e3) {
+        for (const i3 in e3)
+            t4[i3] = e3[i3];
+        return t4;
+    }(i2.ctx.slice(), t3[1](s2(e2))) : i2.ctx;
+}
+
+function c(t3, e2, i2, s2) {
+    if (t3[2] && s2) {
+        const n2 = t3[2](s2(i2));
+        if (void 0 === e2.dirty)
+            return n2;
+        if ("object" == typeof n2) {
+            const t4 = [],
+                i3 = Math.max(e2.dirty.length, n2.length);
+            for (let s3 = 0; s3 < i3; s3 += 1)
+                t4[s3] = e2.dirty[s3] | n2[s3];
+            return t4;
+        }
+        return e2.dirty | n2;
+    }
+    return e2.dirty;
+}
+
+function u(t3, e2, i2, s2, n2, r2) {
+    if (n2) {
+        const o2 = h(e2, i2, s2, r2);
+        t3.p(o2, n2);
+    }
+}
+
+function d(t3) {
+    if (t3.ctx.length > 32) {
+        const e2 = [],
+            i2 = t3.ctx.length / 32;
+        for (let t4 = 0; t4 < i2; t4++)
+            e2[t4] = -1;
+        return e2;
+    }
+    return -1;
+}
+
+function f(t3) {
+    return null == t3 ? "" : t3;
+}
+const p = "undefined" != typeof window;
+let m = p ? () => window.performance.now() : () => Date.now(),
+    g = p ? (t3) => requestAnimationFrame(t3) : t;
+const y = /* @__PURE__ */ new Set();
+
+function v(t3) {
+    y.forEach((e2) => {
+        e2.c(t3) || (y.delete(e2), e2.f());
+    }), 0 !== y.size && g(v);
+}
+
+function b(t3) {
+    let e2;
+    return 0 === y.size && g(v), {
+        promise: new Promise((i2) => {
+            y.add(e2 = {
+                c: t3,
+                f: i2
+            });
+        }),
+        abort() {
+            y.delete(e2);
+        }
+    };
+}
+
+function _(t3, e2) {
+    t3.appendChild(e2);
+}
+
+function w(t3, e2, i2) {
+    const s2 = x(t3);
+    if (!s2.getElementById(e2)) {
+        const t4 = P("style");
+        t4.id = e2, t4.textContent = i2, T(s2, t4);
+    }
+}
+
+function x(t3) {
+    if (!t3)
+        return document;
+    const e2 = t3.getRootNode ? t3.getRootNode() : t3.ownerDocument;
+    return e2 && e2.host ? e2 : t3.ownerDocument;
+}
+
+function k(t3) {
+    const e2 = P("style");
+    return e2.textContent = "/* empty */", T(x(t3), e2), e2.sheet;
+}
+
+function T(t3, e2) {
+    return _(t3.head || t3, e2), e2.sheet;
+}
+
+function S(t3, e2, i2) {
+    t3.insertBefore(e2, i2 || null);
+}
+
+function E(t3) {
+    t3.parentNode && t3.parentNode.removeChild(t3);
+}
+
+function C(t3, e2) {
+    for (let i2 = 0; i2 < t3.length; i2 += 1)
+        t3[i2] && t3[i2].d(e2);
+}
+
+function P(t3) {
+    return document.createElement(t3);
+}
+
+function R(t3) {
+    return document.createElementNS("http://www.w3.org/2000/svg", t3);
+}
+
+function D(t3) {
+    return document.createTextNode(t3);
+}
+
+function $() {
+    return D(" ");
+}
+
+function z() {
+    return D("");
+}
+
+function B(t3, e2, i2, s2) {
+    return t3.addEventListener(e2, i2, s2), () => t3.removeEventListener(e2, i2, s2);
+}
+
+function U(t3, e2, i2) {
+    null == i2 ? t3.removeAttribute(e2) : t3.getAttribute(e2) !== i2 && t3.setAttribute(e2, i2);
+}
+
+function j(t3) {
+    return "" === t3 ? null : +t3;
+}
+
+function H(t3, e2) {
+    e2 = "" + e2, t3.data !== e2 && (t3.data = e2);
+}
+
+function q(t3, e2) {
+    t3.value = null == e2 ? "" : e2;
+}
+
+function G(t3, e2, i2, s2) {
+    null == i2 ? t3.style.removeProperty(e2) : t3.style.setProperty(e2, i2, s2 ? "important" : "");
+}
+
+function Y(t3, e2, i2) {
+    t3.classList.toggle(e2, !!i2);
+}
+
+function it(t3, e2, {
+    bubbles: i2 = false,
+    cancelable: s2 = false
+} = {}) {
+    return new CustomEvent(t3, {
+        detail: e2,
+        bubbles: i2,
+        cancelable: s2
+    });
+}
+const st = /* @__PURE__ */ new Map();
+let rt, ht = 0;
+
+function ct(t3, e2, i2, s2, n2, r2, o2, a2 = 0) {
+    const l2 = 16.666 / s2;
+    let h2 = "{\n";
+    for (let t4 = 0; t4 <= 1; t4 += l2) {
+        const s3 = e2 + (i2 - e2) * r2(t4);
+        h2 += 100 * t4 + `%{${o2(s3, 1 - s3)}}
+`;
+    }
+    const c2 = h2 + `100% {${o2(i2, 1 - i2)}}
+}`,
+        u2 = `__svelte_${function(t4) {
+    let e3 = 5381, i3 = t4.length;
+    for (; i3--; )
+      e3 = (e3 << 5) - e3 ^ t4.charCodeAt(i3);
+    return e3 >>> 0;
+  }(c2)}_${a2}`,
+        d2 = x(t3),
+        {
+            stylesheet: f2,
+            rules: p2
+        } = st.get(d2) || function(t4, e3) {
+            const i3 = {
+                stylesheet: k(e3),
+                rules: {}
+            };
+            return st.set(t4, i3), i3;
+        }(d2, t3);
+    p2[u2] || (p2[u2] = true, f2.insertRule(`@keyframes ${u2} ${c2}`, f2.cssRules.length));
+    const m2 = t3.style.animation || "";
+    return t3.style.animation = `${m2 ? `${m2}, ` : ""}${u2} ${s2}ms linear ${n2}ms 1 both`, ht += 1, u2;
+}
+
+function ut(t3, e2) {
+    const i2 = (t3.style.animation || "").split(", "),
+        s2 = i2.filter(e2 ? (t4) => t4.indexOf(e2) < 0 : (t4) => -1 === t4.indexOf("__svelte")),
+        n2 = i2.length - s2.length;
+    n2 && (t3.style.animation = s2.join(", "), ht -= n2, ht || g(() => {
+        ht || (st.forEach((t4) => {
+            const {
+                ownerNode: e3
+            } = t4.stylesheet;
+            e3 && E(e3);
+        }), st.clear());
+    }));
+}
+
+function dt(t3) {
+    rt = t3;
+}
+
+function ft() {
+    if (!rt)
+        throw new Error("Function called outside component initialization");
+    return rt;
+}
+
+function pt(t3) {
+    ft().$$.on_mount.push(t3);
+}
+
+function yt(t3) {
+    ft().$$.on_destroy.push(t3);
+}
+
+function bt() {
+    const t3 = ft();
+    return (e2, i2, {
+        cancelable: s2 = false
+    } = {}) => {
+        const n2 = t3.$$.callbacks[e2];
+        if (n2) {
+            const r2 = it(e2, i2, {
+                cancelable: s2
+            });
+            return n2.slice().forEach((e3) => {
+                e3.call(t3, r2);
+            }), !r2.defaultPrevented;
+        }
+        return true;
+    };
+}
+const _t = [],
+    xt = [];
+let kt = [];
+const St = [],
+    It = Promise.resolve();
+let Mt = false;
+
+function At() {
+    Mt || (Mt = true, It.then(te));
+}
+
+function Lt() {
+    return At(), It;
+}
+
+function Ot(t3) {
+    kt.push(t3);
+}
+const Ht = /* @__PURE__ */ new Set();
+let Qt, Jt = 0;
+
+function te() {
+    if (0 !== Jt)
+        return;
+    const t3 = rt;
+    do {
+        try {
+            for (; Jt < _t.length;) {
+                const t4 = _t[Jt];
+                Jt++, dt(t4), ee(t4.$$);
+            }
+        } catch (t4) {
+            throw _t.length = 0, Jt = 0, t4;
+        }
+        for (dt(null), _t.length = 0, Jt = 0; xt.length;)
+            xt.pop()();
+        for (let t4 = 0; t4 < kt.length; t4 += 1) {
+            const e2 = kt[t4];
+            Ht.has(e2) || (Ht.add(e2), e2());
+        }
+        kt.length = 0;
+    } while (_t.length);
+    for (; St.length;)
+        St.pop()();
+    Mt = false, Ht.clear(), dt(t3);
+}
+
+function ee(t3) {
+    if (null !== t3.fragment) {
+        t3.update(), n(t3.before_update);
+        const e2 = t3.dirty;
+        t3.dirty = [-1], t3.fragment && t3.fragment.p(t3.ctx, e2), t3.after_update.forEach(Ot);
+    }
+}
+
+function ie() {
+    return Qt || (Qt = Promise.resolve(), Qt.then(() => {
+        Qt = null;
+    })), Qt;
+}
+
+function se(t3, e2, i2) {
+    t3.dispatchEvent(it(`${e2 ? "intro" : "outro"}${i2}`));
+}
+const ne = /* @__PURE__ */ new Set();
+let re;
+
+function oe() {
+    re = {
+        r: 0,
+        c: [],
+        p: re
+    };
+}
+
+function ae() {
+    re.r || n(re.c), re = re.p;
+}
+
+function le(t3, e2) {
+    t3 && t3.i && (ne.delete(t3), t3.i(e2));
+}
+
+function he(t3, e2, i2, s2) {
+    if (t3 && t3.o) {
+        if (ne.has(t3))
+            return;
+        ne.add(t3), re.c.push(() => {
+            ne.delete(t3), s2 && (i2 && t3.d(1), s2());
+        }), t3.o(e2);
+    } else
+        s2 && s2();
+}
+const ce = {
+    duration: 0
+};
+
+function ue(t3) {
+    return void 0 !== (t3 == null ? void 0 : t3.length) ? t3 : Array.from(t3);
+}
+
+function de(t3, e2) {
+    t3.d(1), e2.delete(t3.key);
+}
+
+function fe(t3, e2) {
+    he(t3, 1, 1, () => {
+        e2.delete(t3.key);
+    });
+}
+
+function pe(t3, e2, i2, s2, r2, o2, a2, l2, h2, c2, u2, d2) {
+    let f2 = t3.length,
+        p2 = o2.length,
+        m2 = f2;
+    const g2 = {};
+    for (; m2--;)
+        g2[t3[m2].key] = m2;
+    const y2 = [],
+        v2 = /* @__PURE__ */ new Map(),
+        b2 = /* @__PURE__ */ new Map(),
+        _2 = [];
+    for (m2 = p2; m2--;) {
+        const t4 = d2(r2, o2, m2),
+            n2 = i2(t4);
+        let l3 = a2.get(n2);
+        l3 ? s2 && _2.push(() => l3.p(t4, e2)) : (l3 = c2(n2, t4), l3.c()), v2.set(n2, y2[m2] = l3), n2 in g2 && b2.set(n2, Math.abs(m2 - g2[n2]));
+    }
+    const w2 = /* @__PURE__ */ new Set(),
+        x2 = /* @__PURE__ */ new Set();
+
+    function k2(t4) {
+        le(t4, 1), t4.m(l2, u2), a2.set(t4.key, t4), u2 = t4.first, p2--;
+    }
+    for (; f2 && p2;) {
+        const e3 = y2[p2 - 1],
+            i3 = t3[f2 - 1],
+            s3 = e3.key,
+            n2 = i3.key;
+        e3 === i3 ? (u2 = e3.first, f2--, p2--) : v2.has(n2) ? !a2.has(s3) || w2.has(s3) ? k2(e3) : x2.has(n2) ? f2-- : b2.get(s3) > b2.get(n2) ? (x2.add(s3), k2(e3)) : (w2.add(n2), f2--) : (h2(i3, a2), f2--);
+    }
+    for (; f2--;) {
+        const e3 = t3[f2];
+        v2.has(e3.key) || h2(e3, a2);
+    }
+    for (; p2;)
+        k2(y2[p2 - 1]);
+    return n(_2), y2;
+}
+
+function me(t3) {
+    t3 && t3.c();
+}
+
+function ge(t3, e2, s2) {
+    const {
+        fragment: o2,
+        after_update: a2
+    } = t3.$$;
+    o2 && o2.m(e2, s2), Ot(() => {
+        const e3 = t3.$$.on_mount.map(i).filter(r);
+        t3.$$.on_destroy ? t3.$$.on_destroy.push(...e3) : n(e3), t3.$$.on_mount = [];
+    }), a2.forEach(Ot);
+}
+
+function ye(t3, e2) {
+    const i2 = t3.$$;
+    null !== i2.fragment && (! function(t4) {
+        const e3 = [],
+            i3 = [];
+        kt.forEach((s2) => -1 === t4.indexOf(s2) ? e3.push(s2) : i3.push(s2)), i3.forEach((t5) => t5()), kt = e3;
+    }(i2.after_update), n(i2.on_destroy), i2.fragment && i2.fragment.d(e2), i2.on_destroy = i2.fragment = null, i2.ctx = []);
+}
+
+function ve(e2, i2, r2, o2, a2, l2, h2, c2 = [-1]) {
+    const u2 = rt;
+    dt(e2);
+    const d2 = e2.$$ = {
+        fragment: null,
+        ctx: [],
+        props: l2,
+        update: t,
+        not_equal: a2,
+        bound: s(),
+        on_mount: [],
+        on_destroy: [],
+        on_disconnect: [],
+        before_update: [],
+        after_update: [],
+        context: new Map(i2.context || (u2 ? u2.$$.context : [])),
+        callbacks: s(),
+        dirty: c2,
+        skip_bound: false,
+        root: i2.target || u2.$$.root
+    };
+    h2 && h2(d2.root);
+    let f2 = false;
+    if (d2.ctx = r2 ? r2(e2, i2.props || {}, (t3, i3, ...s2) => {
+            const n2 = s2.length ? s2[0] : i3;
+            return d2.ctx && a2(d2.ctx[t3], d2.ctx[t3] = n2) && (!d2.skip_bound && d2.bound[t3] && d2.bound[t3](n2), f2 && function(t4, e3) {
+                -1 === t4.$$.dirty[0] && (_t.push(t4), At(), t4.$$.dirty.fill(0)), t4.$$.dirty[e3 / 31 | 0] |= 1 << e3 % 31;
+            }(e2, t3)), i3;
+        }) : [], d2.update(), f2 = true, n(d2.before_update), d2.fragment = !!o2 && o2(d2.ctx), i2.target) {
+        if (i2.hydrate) {
+            const t3 = function(t4) {
+                return Array.from(t4.childNodes);
+            }(i2.target);
+            d2.fragment && d2.fragment.l(t3), t3.forEach(E);
+        } else
+            d2.fragment && d2.fragment.c();
+        i2.intro && le(e2.$$.fragment), ge(e2, i2.target, i2.anchor), te();
+    }
+    dt(u2);
+}
+let be;
+
+function _e(t3, e2, i2, s2) {
+    var _a2;
+    const n2 = (_a2 = i2[t3]) == null ? void 0 : _a2.type;
+    if (e2 = "Boolean" === n2 && "boolean" != typeof e2 ? null != e2 : e2, !s2 || !i2[t3])
+        return e2;
+    if ("toAttribute" === s2)
+        switch (n2) {
+            case "Object":
+            case "Array":
+                return null == e2 ? null : JSON.stringify(e2);
+            case "Boolean":
+                return e2 ? "" : null;
+            case "Number":
+                return null == e2 ? null : e2;
+            default:
+                return e2;
+        }
+    else
+        switch (n2) {
+            case "Object":
+            case "Array":
+                return e2 && JSON.parse(e2);
+            case "Boolean":
+            default:
+                return e2;
+            case "Number":
+                return null != e2 ? +e2 : e2;
+        }
+}
+
+function we(t3, e2, i2, s2, n2) {
+    const r2 = class extends be {
+        constructor() {
+            super(t3, i2, n2), this.$$p_d = e2;
+        }
+        static get observedAttributes() {
+            return Object.keys(e2).map((t4) => (e2[t4].attribute || t4).toLowerCase());
+        }
+    };
+    return Object.keys(e2).forEach((t4) => {
+        Object.defineProperty(r2.prototype, t4, {
+            get() {
+                return this.$$c && t4 in this.$$c ? this.$$c[t4] : this.$$d[t4];
+            },
+            set(i3) {
+                var _a2;
+                i3 = _e(t4, i3, e2), this.$$d[t4] = i3, (_a2 = this.$$c) == null ? void 0 : _a2.$set({
+                    [t4]: i3
+                });
+            }
+        });
+    }), s2.forEach((t4) => {
+        Object.defineProperty(r2.prototype, t4, {
+            get() {
+                var _a2;
+                return (_a2 = this.$$c) == null ? void 0 : _a2[t4];
+            }
+        });
+    }), t3.element = r2, r2;
+}
+"function" == typeof HTMLElement && (be = class extends HTMLElement {
+    constructor(t3, e2, i2) {
+        super();
+        __publicField(this, "$$ctor");
+        __publicField(this, "$$s");
+        __publicField(this, "$$c");
+        __publicField(this, "$$cn", false);
+        __publicField(this, "$$d", {});
+        __publicField(this, "$$r", false);
+        __publicField(this, "$$p_d", {});
+        __publicField(this, "$$l", {});
+        __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
+        this.$$ctor = t3, this.$$s = e2, i2 && this.attachShadow({
+            mode: "open"
+        });
+    }
+    addEventListener(t3, e2, i2) {
+        if (this.$$l[t3] = this.$$l[t3] || [], this.$$l[t3].push(e2), this.$$c) {
+            const i3 = this.$$c.$on(t3, e2);
+            this.$$l_u.set(e2, i3);
+        }
+        super.addEventListener(t3, e2, i2);
+    }
+    removeEventListener(t3, e2, i2) {
+        if (super.removeEventListener(t3, e2, i2), this.$$c) {
+            const t4 = this.$$l_u.get(e2);
+            t4 && (t4(), this.$$l_u.delete(e2));
+        }
+    }
+    async connectedCallback() {
+        if (this.$$cn = true, !this.$$c) {
+            let t3 = function(t4) {
+                return () => {
+                    let e3;
+                    return {
+                        c: function() {
+                            e3 = P("slot"), "default" !== t4 && U(e3, "name", t4);
+                        },
+                        m: function(t5, i3) {
+                            S(t5, e3, i3);
+                        },
+                        d: function(t5) {
+                            t5 && E(e3);
+                        }
+                    };
+                };
+            };
+            if (await Promise.resolve(), !this.$$cn)
+                return;
+            const e2 = {},
+                i2 = function(t4) {
+                    const e3 = {};
+                    return t4.childNodes.forEach((t5) => {
+                        e3[t5.slot || "default"] = true;
+                    }), e3;
+                }(this);
+            for (const n2 of this.$$s)
+                n2 in i2 && (e2[n2] = [t3(n2)]);
+            for (const r2 of this.attributes) {
+                const o2 = this.$$g_p(r2.name);
+                o2 in this.$$d || (this.$$d[o2] = _e(o2, r2.value, this.$$p_d, "toProp"));
+            }
+            this.$$c = new this.$$ctor({
+                target: this.shadowRoot || this,
+                props: {
+                    ...this.$$d,
+                    $$slots: e2,
+                    $$scope: {
+                        ctx: []
+                    }
+                }
+            });
+            const s2 = () => {
+                this.$$r = true;
+                for (const t4 in this.$$p_d)
+                    if (this.$$d[t4] = this.$$c.$$.ctx[this.$$c.$$.props[t4]], this.$$p_d[t4].reflect) {
+                        const e3 = _e(t4, this.$$d[t4], this.$$p_d, "toAttribute");
+                        null == e3 ? this.removeAttribute(t4) : this.setAttribute(this.$$p_d[t4].attribute || t4, e3);
+                    }
+                this.$$r = false;
+            };
+            this.$$c.$$.after_update.push(s2), s2();
+            for (const a2 in this.$$l)
+                for (const l2 of this.$$l[a2]) {
+                    const h2 = this.$$c.$on(a2, l2);
+                    this.$$l_u.set(l2, h2);
+                }
+            this.$$l = {};
+        }
+    }
+    attributeChangedCallback(t3, e2, i2) {
+        var _a2;
+        this.$$r || (t3 = this.$$g_p(t3), this.$$d[t3] = _e(t3, i2, this.$$p_d, "toProp"), (_a2 = this.$$c) == null ? void 0 : _a2.$set({
+            [t3]: this.$$d[t3]
+        }));
+    }
+    disconnectedCallback() {
+        this.$$cn = false, Promise.resolve().then(() => {
+            this.$$cn || (this.$$c.$destroy(), this.$$c = void 0);
+        });
+    }
+    $$g_p(t3) {
+        return Object.keys(this.$$p_d).find((e2) => this.$$p_d[e2].attribute === t3 || !this.$$p_d[e2].attribute && e2.toLowerCase() === t3) || t3;
+    }
+});
+class SvelteComponent {
+    constructor() {
+        __publicField(this, "$$");
+        __publicField(this, "$$set");
+    }
+    $destroy() {
+        ye(this, 1), this.$destroy = t;
+    }
+    $on(e2, i2) {
+        if (!r(i2))
+            return t;
+        const s2 = this.$$.callbacks[e2] || (this.$$.callbacks[e2] = []);
+        return s2.push(i2), () => {
+            const t3 = s2.indexOf(i2); -
+            1 !== t3 && s2.splice(t3, 1);
+        };
+    }
+    $set(t3) {
+        var e2;
+        this.$$set && (e2 = t3, 0 !== Object.keys(e2).length) && (this.$$.skip_bound = true, this.$$set(t3), this.$$.skip_bound = false);
+    }
+}
+"undefined" != typeof window && (window.__svelte || (window.__svelte = {
+    v: /* @__PURE__ */ new Set()
+})).v.add("4");
+const xe = [{
+    backtest: ["startDate", "endDate", "version", "feeRatio", "taxRatio", "tradeAt", "market", "freq", "updateDate", "nextTradingDate", "livePerformanceStart", "stopLoss", "takeProfit"]
+}, {
+    profitability: ["annualReturn", "alpha", "beta", "avgNStock", "maxNStock"]
+}, {
+    risk: ["maxDrawdown", "avgDrawdown", "avgDrawdownDays", "valueAtRisk", "cvalueAtRisk"]
+}, {
+    ratio: ["sharpeRatio", "sortinoRatio", "calmarRatio", "profitFactor", "tailRatio"]
+}, {
+    winrate: ["winRate", "m12WinRate", "expectancy", "mae", "mfe"]
+}, {
+    liquidity: ["capacity", "disposalStockRatio", "warningStockRatio", "fullDeliveryStockRatio", "buyHigh", "sellLow"]
+}];
+
+function ke(t3) {
+    const e2 = {},
+        i2 = xe;
+    for (const s2 of i2)
+        for (const i3 in s2) {
+            e2[i3] = {};
+            for (const n2 of s2[i3])
+                e2[i3][n2] = t3[i3][n2];
+        }
+    return e2;
+}
+const Te = {
+    profitability: {
+        annualReturn: (t3) => t3 > 0.15,
+        alpha: (t3) => t3 > 0.1,
+        beta: (t3) => t3 < 0.8 && t3 > 0,
+        avgNStock: (t3) => t3 >= 5,
+        maxNStock: (t3) => t3 <= 20
+    },
+    risk: {
+        maxDrawdown: (t3) => t3 > -0.3,
+        avgDrawdown: (t3) => t3 > -0.1,
+        avgDrawdownDays: (t3) => t3 < 40,
+        volatility: (t3) => t3 < 0.2,
+        valueAtRisk: (t3) => t3 > -0.07,
+        cvalueAtRisk: (t3) => t3 > -0.1
+    },
+    ratio: {
+        sharpeRatio: (t3) => t3 > 1.3,
+        sortinoRatio: (t3) => t3 > 1.8,
+        calmarRatio: (t3) => t3 > 0.9,
+        profitFactor: (t3) => t3 > 1.5,
+        tailRatio: (t3) => t3 > 1
+    },
+    winrate: {
+        winRate: (t3) => t3 > 0.55,
+        m12WinRate: (t3) => t3 > 0.7,
+        expectancy: (t3) => t3 > 0.02,
+        mae: (t3) => t3 > -0.1,
+        mfe: (t3) => t3 > 0.1
+    },
+    liquidity: {
+        capacity: (t3) => t3 > 5e5,
+        disposalStockRatio: (t3) => t3 < 0.05,
+        warningStockRatio: (t3) => t3 < 0.05,
+        fullDeliveryStockRatio: (t3) => t3 < 0.05,
+        buyHigh: (t3) => t3 < 0.05,
+        sellLow: (t3) => t3 < 0.05
+    }
+};
+
+function Se(t3) {
+    const e2 = {
+        profitability: 0,
+        risk: 0,
+        ratio: 0,
+        winrate: 0,
+        liquidity: 0
+    };
+    for (const i2 in Te)
+        for (const s2 in Te[i2])
+            Te[i2][s2](t3[i2][s2]) && (e2[i2]++, "liquidity" === i2 && "capacity" === s2 && (e2[i2] += 10));
+    for (const t4 in e2) {
+        let i2 = Object.keys(Te[t4]).length;
+        "liquidity" === t4 && (i2 += 10), e2[t4] = e2[t4] / i2;
+    }
+    return e2;
+}
+class MetricDisplay {
+    constructor() {
+        this.percentage = (t3) => (100 * t3).toFixed(1), this.sign = (t3) => "string" == typeof t3 && "-" != t3[0] || "number" == typeof t3 && t3 > 0 ? "+" + String(t3) : String(t3), this.color = (t3) => t3 > 0 ? "text-rise" : "text-fall", this.formatter = {
+            annualReturn: (t3) => this.sign(this.percentage(t3)),
+            alpha: (t3) => this.sign(this.percentage(t3)),
+            avgNStock: (t3) => t3.toFixed(0),
+            maxNStock: (t3) => t3.toFixed(0),
+            maxDrawdown: (t3) => this.sign(this.percentage(t3)),
+            avgDrawdown: (t3) => this.sign(this.percentage(t3)),
+            valueAtRisk: (t3) => this.sign(this.percentage(t3)),
+            cvalueAtRisk: (t3) => this.sign(this.percentage(t3)),
+            winRate: (t3) => this.percentage(t3),
+            m12WinRate: (t3) => this.percentage(t3),
+            expectancy: (t3) => this.sign(this.percentage(t3)),
+            mae: (t3) => this.sign(this.percentage(t3)),
+            mfe: (t3) => this.sign(this.percentage(t3)),
+            smallCapRatio: (t3) => this.percentage(t3),
+            capacity: (t3) => (t3 / 1e4).toFixed(0),
+            disposalStockRatio: (t3) => this.percentage(t3),
+            warningStockRatio: (t3) => this.percentage(t3),
+            fullDeliveryStockRatio: (t3) => this.percentage(t3),
+            buyHigh: (t3) => this.percentage(t3),
+            sellLow: (t3) => this.percentage(t3)
+        }, this.units = {
+            annualReturn: "%",
+            alpha: "%",
+            avgNStock: "檔",
+            maxNStock: "檔",
+            maxDrawdown: "%",
+            avgDrawdown: "%",
+            avgDrawdownDays: "天",
+            valueAtRisk: "%",
+            cvalueAtRisk: "%",
+            winRate: "%",
+            m12WinRate: "%",
+            expectancy: "%",
+            mae: "%",
+            mfe: "%",
+            smallCapRatio: "%",
+            capacity: "萬",
+            disposalStockRatio: "%",
+            warningStockRatio: "%",
+            fullDeliveryStockRatio: "%",
+            buyHigh: "%",
+            sellLow: "%"
+        };
+    }
+    format(t3, e2) {
+        if (t3 in this.formatter)
+            try {
+                return this.formatter[t3](e2);
+            } catch {}
+        try {
+            return String(e2.toFixed(2));
+        } catch {}
+        return String(e2);
+    }
+    getUnit(t3) {
+        return t3 in this.units ? this.units[t3] : "";
+    }
+}
+
+function Ee(t3, e2, i2, s2) {
+    let n2 = e2.length,
+        r2 = void 0 !== i2 ? i2 : 0,
+        o2 = void 0 !== s2 ? s2 : n2 - 1,
+        a2 = r2 + Math.floor((o2 - r2) / 2);
+    0 !== n2 ? t3 >= e2[o2] ? e2.splice(o2 + 1, 0, t3) : t3 < e2[r2] ? e2.splice(r2, 0, t3) : r2 >= o2 || (t3 <= e2[a2] ? Ee(t3, e2, r2, a2) : t3 > e2[a2] && Ee(t3, e2, a2 + 1, o2)) : e2.push(t3);
+}
+
+function Ce(t3, e2, i2) {
+    let s2 = [],
+        n2 = [];
+    t3.slice(0, i2).forEach((t4) => Ee(t4, s2));
+    for (let r2 = i2; r2 < t3.length; r2++)
+        n2.push(s2[Math.floor(i2 * e2)]), s2.splice(s2.indexOf(t3[r2 - i2]), 1), Ee(t3[r2], s2);
+    return n2.push(s2[Math.floor(i2 * e2)]), n2;
+}
+class Report {
+    constructor(t3, e2, i2, s2, n2) {
+        this.timestamps = t3, this.strategy = e2, this.benchmark = i2, this.trades = s2, this.metrics = n2;
+    }
+    createTradingviewSeries(t3, e2 = 0, i2 = -1, s2 = 500) {
+        const n2 = this.timestamps.map((e3, i3) => ({
+                time: e3,
+                value: this[t3][i3]
+            })).slice(this.indexOfTimestamps(e2), this.indexOfTimestamps(i2) + 1),
+            r2 = this.timestamps.map((t4, e3) => 0 === e3 || t4.substring(0, 7) !== this.timestamps[e3 - 1].substring(0, 7)),
+            o2 = Math.round(n2.length / s2);
+        return n2.filter((t4, e3) => e3 % o2 == 0 || e3 === n2.length - 1 || r2[e3]);
+    }
+    indexOfTimestamps(t3) {
+        return "string" == typeof t3 ? function(t4, e2) {
+            let i2 = 0,
+                s2 = t4.length - 1,
+                n2 = -1;
+            for (; i2 <= s2;) {
+                const r2 = Math.ceil((i2 + s2) / 2);
+                if (t4[r2] === e2)
+                    return r2;
+                t4[r2] < e2 ? (n2 = r2, i2 = r2 + 1) : (n2 = r2, s2 = r2 - 1);
+            }
+            return e2 < t4[n2] && (n2 -= 1), n2;
+        }(this.timestamps, t3) : t3 < 0 ? Math.min(Math.max(this.timestamps.length + t3, 0), this.timestamps.length - 1) : t3;
+    }
+    calculateAnnualReturn(t3) {
+        const e2 = {};
+        let i2 = this[t3][0];
+        for (let s2 = 1; s2 < this.timestamps.length; s2++) {
+            const n2 = new Date(this.timestamps[s2]).getFullYear();
+            if (s2 === this.timestamps.length - 1 || new Date(this.timestamps[s2 + 1]).getFullYear() !== n2) {
+                const r2 = this[t3][s2];
+                e2[n2] = r2 / i2 - 1, i2 = r2;
+            }
+        }
+        return e2;
+    }
+    calculateMonthlyReturn(t3) {
+        const e2 = {};
+        let i2 = this[t3][0];
+        for (let s2 = 1; s2 < this.timestamps.length; s2++) {
+            const n2 = new Date(this.timestamps[s2]),
+                r2 = n2.getFullYear(),
+                o2 = n2.getMonth() + 1;
+            if (s2 === this.timestamps.length - 1 || new Date(this.timestamps[s2 + 1]).getMonth() + 1 !== o2) {
+                const n3 = this[t3][s2];
+                e2[`${r2}${o2}`] = n3 / i2 - 1, i2 = n3;
+            }
+        }
+        return e2;
+    }
+    calculateMostRecentNDayReturn(t3, e2) {
+        const i2 = this[t3],
+            s2 = i2.length,
+            n2 = {};
+        for (const t4 of e2) {
+            const e3 = parseInt(t4);
+            if (s2 < e3)
+                continue;
+            const r2 = 100 * (i2[s2 - 1] / i2[s2 - e3 - 1] - 1);
+            n2[t4] = r2;
+        }
+        return n2;
+    }
+    createTradingViewDrawdown(t3, e2 = 100) {
+        let i2 = 100,
+            s2 = [];
+        const n2 = this[t3];
+        for (let t4 = 0; t4 < this.timestamps.length; t4 += 1)
+            i2 = Math.max(n2[t4], i2), s2.push(n2[t4] / i2 * 100 - 100);
+        const r2 = Math.round(s2.length / e2);
+        const o2 = function(t4, e3) {
+            let i3 = [],
+                s3 = [];
+            for (let n3 = 0; n3 < t4.length; n3++) {
+                for (; i3.length > 0 && t4[n3] < t4[i3[i3.length - 1]];)
+                    i3.pop();
+                i3.push(n3), i3[0] < n3 - e3 + 1 && i3.shift(), n3 >= e3 - 1 && s3.push(t4[i3[0]]);
+            }
+            return s3;
+        }(s2, r2);
+        let a2 = this.timestamps.map((t4, e3) => ({
+            time: t4,
+            value: o2[e3]
+        }));
+        return a2.filter((t4, e3) => e3 % r2 == 0 || e3 === a2.length - 1);
+    }
+    calculateDrawdown(t3) {
+        let e2 = 0,
+            i2 = 1,
+            s2 = 1,
+            n2 = 0,
+            r2 = [];
+        const o2 = this[t3];
+        for (let t4 = 0; t4 < this.timestamps.length; t4 += 1) {
+            const a3 = o2[t4];
+            if (a3 > i2)
+                t4 - e2 >= 2 && r2.push({
+                    maxDrawdown: s2 - 1,
+                    start: e2,
+                    end: t4,
+                    at: n2
+                }), e2 = t4, i2 = a3, s2 = 1, n2 = t4;
+            else {
+                const e3 = a3 / i2;
+                s2 > e3 && (s2 = e3, n2 = t4);
+            }
+        }
+        r2.sort((t4, e3) => -(t4.end - t4.start) + (e3.end - e3.start));
+        const a2 = r2.slice(0, 5);
+        r2.sort((t4, e3) => t4.maxDrawdown - e3.maxDrawdown);
+        return [r2.slice(0, 5), a2];
+    }
+    calculateSharpe(t3, e2, i2) {
+        let s2 = [],
+            n2 = 0,
+            r2 = 0,
+            o2 = [],
+            a2 = [];
+        const l2 = this[t3];
+        for (let t4 = 1; t4 < l2.length; t4++) {
+            let h2 = l2[t4] / l2[t4 - 1] - 1;
+            o2.push(h2), n2 += h2;
+            let c2 = n2 / i2,
+                u2 = (h2 - c2) * (h2 - c2);
+            if (a2.push(u2), r2 += u2, t4 >= i2) {
+                n2 -= o2.shift(), r2 -= a2.shift();
+            }
+            if (t4 >= i2 - 1) {
+                let t5 = r2 / i2,
+                    n3 = (c2 - e2) / Math.sqrt(t5);
+                s2.push(n3);
+            }
+        }
+        return s2.map((t4, e3) => ({
+            time: this.timestamps[e3 + i2 - 1],
+            value: t4 * Math.sqrt(i2)
+        }));
+    }
+    calculateSortino(t3, e2, i2) {
+        let s2 = [],
+            n2 = 0,
+            r2 = 0,
+            o2 = [],
+            a2 = [];
+        const l2 = this[t3];
+        for (let t4 = 1; t4 < l2.length; t4++) {
+            let h2 = l2[t4] / l2[t4 - 1] - 1;
+            n2 += h2, o2.push(h2);
+            let c2 = n2 / i2,
+                u2 = (h2 - c2) * (h2 - c2);
+            if (a2.push(u2), h2 < e2 && (r2 += u2), t4 >= i2) {
+                let t5 = o2.shift(),
+                    i3 = a2.shift();
+                n2 -= t5, t5 < e2 && (r2 -= i3);
+            }
+            if (t4 >= i2 - 1) {
+                let t5 = r2 / i2,
+                    n3 = (c2 - e2) / Math.sqrt(t5);
+                s2.push(n3);
+            }
+        }
+        return s2.map((t4, e3) => ({
+            time: this.timestamps[e3 + i2 - 1],
+            value: t4 * Math.sqrt(i2)
+        }));
+    }
+    calculateVolitility(t3, e2, i2) {
+        let s2 = [],
+            n2 = 0,
+            r2 = 0,
+            o2 = [],
+            a2 = [];
+        const l2 = this[t3];
+        for (let t4 = 1; t4 < l2.length; t4++) {
+            let e3 = l2[t4] / l2[t4 - 1] - 1;
+            n2 += e3, o2.push(e3);
+            let h2 = n2 / i2,
+                c2 = (e3 - h2) * (e3 - h2);
+            if (r2 += c2, a2.push(c2), t4 >= i2) {
+                n2 -= o2.shift(), r2 -= a2.shift();
+            }
+            if (t4 >= i2 - 1) {
+                let t5 = r2 / i2,
+                    e4 = Math.sqrt(t5);
+                s2.push(e4);
+            }
+        }
+        return s2.map((t4, e3) => ({
+            time: this.timestamps[e3 + i2 - 1],
+            value: t4 * Math.sqrt(i2)
+        }));
+    }
+    calculateTailRatio(t3, e2) {
+        let i2 = this[t3];
+        i2 = i2.map((t4, e3) => t4 / i2[e3 - 1] - 1), i2[0] = 0;
+        const s2 = Ce(i2, 0.95, e2),
+            n2 = Ce(i2, 0.05, e2);
+        return s2.map((t4, e3) => Math.abs(t4 / n2[e3])).map((t4, i3) => ({
+            time: this.timestamps[i3 + e2 - 1],
+            value: t4
+        }));
+    }
+}
+
+function Ie(t3) {
+    return t3 + 0.5 | 0;
+}
+const Me = (t3, e2, i2) => Math.max(Math.min(t3, i2), e2);
+
+function Pe(t3) {
+    return Me(Ie(2.55 * t3), 0, 255);
+}
+
+function Re(t3) {
+    return Me(Ie(255 * t3), 0, 255);
+}
+
+function Ae(t3) {
+    return Me(Ie(t3 / 2.55) / 100, 0, 1);
+}
+
+function De(t3) {
+    return Me(Ie(100 * t3), 0, 100);
+}
+const Le = {
+        0: 0,
+        1: 1,
+        2: 2,
+        3: 3,
+        4: 4,
+        5: 5,
+        6: 6,
+        7: 7,
+        8: 8,
+        9: 9,
+        A: 10,
+        B: 11,
+        C: 12,
+        D: 13,
+        E: 14,
+        F: 15,
+        a: 10,
+        b: 11,
+        c: 12,
+        d: 13,
+        e: 14,
+        f: 15
+    },
+    Oe = [..."0123456789ABCDEF"],
+    Fe = (t3) => Oe[15 & t3],
+    Ne = (t3) => Oe[(240 & t3) >> 4] + Oe[15 & t3],
+    $e = (t3) => (240 & t3) >> 4 == (15 & t3);
+
+function Ve(t3) {
+    var e2 = ((t4) => $e(t4.r) && $e(t4.g) && $e(t4.b) && $e(t4.a))(t3) ? Fe : Ne;
+    return t3 ? "#" + e2(t3.r) + e2(t3.g) + e2(t3.b) + ((t4, e3) => t4 < 255 ? e3(t4) : "")(t3.a, e2) : void 0;
+}
+const ze = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
+
+function Be(t3, e2, i2) {
+    const s2 = e2 * Math.min(i2, 1 - i2),
+        n2 = (e3, n3 = (e3 + t3 / 30) % 12) => i2 - s2 * Math.max(Math.min(n3 - 3, 9 - n3, 1), -1);
+    return [n2(0), n2(8), n2(4)];
+}
+
+function Ue(t3, e2, i2) {
+    const s2 = (s3, n2 = (s3 + t3 / 60) % 6) => i2 - i2 * e2 * Math.max(Math.min(n2, 4 - n2, 1), 0);
+    return [s2(5), s2(3), s2(1)];
+}
+
+function je(t3, e2, i2) {
+    const s2 = Be(t3, 1, 0.5);
+    let n2;
+    for (e2 + i2 > 1 && (n2 = 1 / (e2 + i2), e2 *= n2, i2 *= n2), n2 = 0; n2 < 3; n2++)
+        s2[n2] *= 1 - e2 - i2, s2[n2] += e2;
+    return s2;
+}
+
+function He(t3) {
+    const e2 = t3.r / 255,
+        i2 = t3.g / 255,
+        s2 = t3.b / 255,
+        n2 = Math.max(e2, i2, s2),
+        r2 = Math.min(e2, i2, s2),
+        o2 = (n2 + r2) / 2;
+    let a2, l2, h2;
+    return n2 !== r2 && (h2 = n2 - r2, l2 = o2 > 0.5 ? h2 / (2 - n2 - r2) : h2 / (n2 + r2), a2 = function(t4, e3, i3, s3, n3) {
+        return t4 === n3 ? (e3 - i3) / s3 + (e3 < i3 ? 6 : 0) : e3 === n3 ? (i3 - t4) / s3 + 2 : (t4 - e3) / s3 + 4;
+    }(e2, i2, s2, h2, n2), a2 = 60 * a2 + 0.5), [0 | a2, l2 || 0, o2];
+}
+
+function We(t3, e2, i2, s2) {
+    return (Array.isArray(e2) ? t3(e2[0], e2[1], e2[2]) : t3(e2, i2, s2)).map(Re);
+}
+
+function qe(t3, e2, i2) {
+    return We(Be, t3, e2, i2);
+}
+
+function Ke(t3) {
+    return (t3 % 360 + 360) % 360;
+}
+
+function Ge(t3) {
+    const e2 = ze.exec(t3);
+    let i2, s2 = 255;
+    if (!e2)
+        return;
+    e2[5] !== i2 && (s2 = e2[6] ? Pe(+e2[5]) : Re(+e2[5]));
+    const n2 = Ke(+e2[2]),
+        r2 = +e2[3] / 100,
+        o2 = +e2[4] / 100;
+    return i2 = "hwb" === e2[1] ? function(t4, e3, i3) {
+        return We(je, t4, e3, i3);
+    }(n2, r2, o2) : "hsv" === e2[1] ? function(t4, e3, i3) {
+        return We(Ue, t4, e3, i3);
+    }(n2, r2, o2) : qe(n2, r2, o2), {
+        r: i2[0],
+        g: i2[1],
+        b: i2[2],
+        a: s2
+    };
+}
+const Ye = {
+        x: "dark",
+        Z: "light",
+        Y: "re",
+        X: "blu",
+        W: "gr",
+        V: "medium",
+        U: "slate",
+        A: "ee",
+        T: "ol",
+        S: "or",
+        B: "ra",
+        C: "lateg",
+        D: "ights",
+        R: "in",
+        Q: "turquois",
+        E: "hi",
+        P: "ro",
+        O: "al",
+        N: "le",
+        M: "de",
+        L: "yello",
+        F: "en",
+        K: "ch",
+        G: "arks",
+        H: "ea",
+        I: "ightg",
+        J: "wh"
+    },
+    Qe = {
+        OiceXe: "f0f8ff",
+        antiquewEte: "faebd7",
+        aqua: "ffff",
+        aquamarRe: "7fffd4",
+        azuY: "f0ffff",
+        beige: "f5f5dc",
+        bisque: "ffe4c4",
+        black: "0",
+        blanKedOmond: "ffebcd",
+        Xe: "ff",
+        XeviTet: "8a2be2",
+        bPwn: "a52a2a",
+        burlywood: "deb887",
+        caMtXe: "5f9ea0",
+        KartYuse: "7fff00",
+        KocTate: "d2691e",
+        cSO: "ff7f50",
+        cSnflowerXe: "6495ed",
+        cSnsilk: "fff8dc",
+        crimson: "dc143c",
+        cyan: "ffff",
+        xXe: "8b",
+        xcyan: "8b8b",
+        xgTMnPd: "b8860b",
+        xWay: "a9a9a9",
+        xgYF: "6400",
+        xgYy: "a9a9a9",
+        xkhaki: "bdb76b",
+        xmagFta: "8b008b",
+        xTivegYF: "556b2f",
+        xSange: "ff8c00",
+        xScEd: "9932cc",
+        xYd: "8b0000",
+        xsOmon: "e9967a",
+        xsHgYF: "8fbc8f",
+        xUXe: "483d8b",
+        xUWay: "2f4f4f",
+        xUgYy: "2f4f4f",
+        xQe: "ced1",
+        xviTet: "9400d3",
+        dAppRk: "ff1493",
+        dApskyXe: "bfff",
+        dimWay: "696969",
+        dimgYy: "696969",
+        dodgerXe: "1e90ff",
+        fiYbrick: "b22222",
+        flSOwEte: "fffaf0",
+        foYstWAn: "228b22",
+        fuKsia: "ff00ff",
+        gaRsbSo: "dcdcdc",
+        ghostwEte: "f8f8ff",
+        gTd: "ffd700",
+        gTMnPd: "daa520",
+        Way: "808080",
+        gYF: "8000",
+        gYFLw: "adff2f",
+        gYy: "808080",
+        honeyMw: "f0fff0",
+        hotpRk: "ff69b4",
+        RdianYd: "cd5c5c",
+        Rdigo: "4b0082",
+        ivSy: "fffff0",
+        khaki: "f0e68c",
+        lavFMr: "e6e6fa",
+        lavFMrXsh: "fff0f5",
+        lawngYF: "7cfc00",
+        NmoncEffon: "fffacd",
+        ZXe: "add8e6",
+        ZcSO: "f08080",
+        Zcyan: "e0ffff",
+        ZgTMnPdLw: "fafad2",
+        ZWay: "d3d3d3",
+        ZgYF: "90ee90",
+        ZgYy: "d3d3d3",
+        ZpRk: "ffb6c1",
+        ZsOmon: "ffa07a",
+        ZsHgYF: "20b2aa",
+        ZskyXe: "87cefa",
+        ZUWay: "778899",
+        ZUgYy: "778899",
+        ZstAlXe: "b0c4de",
+        ZLw: "ffffe0",
+        lime: "ff00",
+        limegYF: "32cd32",
+        lRF: "faf0e6",
+        magFta: "ff00ff",
+        maPon: "800000",
+        VaquamarRe: "66cdaa",
+        VXe: "cd",
+        VScEd: "ba55d3",
+        VpurpN: "9370db",
+        VsHgYF: "3cb371",
+        VUXe: "7b68ee",
+        VsprRggYF: "fa9a",
+        VQe: "48d1cc",
+        VviTetYd: "c71585",
+        midnightXe: "191970",
+        mRtcYam: "f5fffa",
+        mistyPse: "ffe4e1",
+        moccasR: "ffe4b5",
+        navajowEte: "ffdead",
+        navy: "80",
+        Tdlace: "fdf5e6",
+        Tive: "808000",
+        TivedBb: "6b8e23",
+        Sange: "ffa500",
+        SangeYd: "ff4500",
+        ScEd: "da70d6",
+        pOegTMnPd: "eee8aa",
+        pOegYF: "98fb98",
+        pOeQe: "afeeee",
+        pOeviTetYd: "db7093",
+        papayawEp: "ffefd5",
+        pHKpuff: "ffdab9",
+        peru: "cd853f",
+        pRk: "ffc0cb",
+        plum: "dda0dd",
+        powMrXe: "b0e0e6",
+        purpN: "800080",
+        YbeccapurpN: "663399",
+        Yd: "ff0000",
+        Psybrown: "bc8f8f",
+        PyOXe: "4169e1",
+        saddNbPwn: "8b4513",
+        sOmon: "fa8072",
+        sandybPwn: "f4a460",
+        sHgYF: "2e8b57",
+        sHshell: "fff5ee",
+        siFna: "a0522d",
+        silver: "c0c0c0",
+        skyXe: "87ceeb",
+        UXe: "6a5acd",
+        UWay: "708090",
+        UgYy: "708090",
+        snow: "fffafa",
+        sprRggYF: "ff7f",
+        stAlXe: "4682b4",
+        tan: "d2b48c",
+        teO: "8080",
+        tEstN: "d8bfd8",
+        tomato: "ff6347",
+        Qe: "40e0d0",
+        viTet: "ee82ee",
+        JHt: "f5deb3",
+        wEte: "ffffff",
+        wEtesmoke: "f5f5f5",
+        Lw: "ffff00",
+        LwgYF: "9acd32"
+    };
+let Xe;
+
+function Je(t3) {
+    Xe || (Xe = function() {
+        const t4 = {},
+            e3 = Object.keys(Qe),
+            i2 = Object.keys(Ye);
+        let s2, n2, r2, o2, a2;
+        for (s2 = 0; s2 < e3.length; s2++) {
+            for (o2 = a2 = e3[s2], n2 = 0; n2 < i2.length; n2++)
+                r2 = i2[n2], a2 = a2.replace(r2, Ye[r2]);
+            r2 = parseInt(Qe[o2], 16), t4[a2] = [r2 >> 16 & 255, r2 >> 8 & 255, 255 & r2];
+        }
+        return t4;
+    }(), Xe.transparent = [0, 0, 0, 0]);
+    const e2 = Xe[t3.toLowerCase()];
+    return e2 && {
+        r: e2[0],
+        g: e2[1],
+        b: e2[2],
+        a: 4 === e2.length ? e2[3] : 255
+    };
+}
+const Ze = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
+const ti = (t3) => t3 <= 31308e-7 ? 12.92 * t3 : 1.055 * Math.pow(t3, 1 / 2.4) - 0.055,
+    ei = (t3) => t3 <= 0.04045 ? t3 / 12.92 : Math.pow((t3 + 0.055) / 1.055, 2.4);
+
+function si(t3, e2, i2) {
+    if (t3) {
+        let s2 = He(t3);
+        s2[e2] = Math.max(0, Math.min(s2[e2] + s2[e2] * i2, 0 === e2 ? 360 : 1)), s2 = qe(s2), t3.r = s2[0], t3.g = s2[1], t3.b = s2[2];
+    }
+}
+
+function ni(t3, e2) {
+    return t3 ? Object.assign(e2 || {}, t3) : t3;
+}
+
+function ri(t3) {
+    var e2 = {
+        r: 0,
+        g: 0,
+        b: 0,
+        a: 255
+    };
+    return Array.isArray(t3) ? t3.length >= 3 && (e2 = {
+        r: t3[0],
+        g: t3[1],
+        b: t3[2],
+        a: 255
+    }, t3.length > 3 && (e2.a = Re(t3[3]))) : (e2 = ni(t3, {
+        r: 0,
+        g: 0,
+        b: 0,
+        a: 1
+    })).a = Re(e2.a), e2;
+}
+
+function ai(t3) {
+    return "r" === t3.charAt(0) ? function(t4) {
+        const e2 = Ze.exec(t4);
+        let i2, s2, n2, r2 = 255;
+        if (e2) {
+            if (e2[7] !== i2) {
+                const t5 = +e2[7];
+                r2 = e2[8] ? Pe(t5) : Me(255 * t5, 0, 255);
+            }
+            return i2 = +e2[1], s2 = +e2[3], n2 = +e2[5], i2 = 255 & (e2[2] ? Pe(i2) : Me(i2, 0, 255)), s2 = 255 & (e2[4] ? Pe(s2) : Me(s2, 0, 255)), n2 = 255 & (e2[6] ? Pe(n2) : Me(n2, 0, 255)), {
+                r: i2,
+                g: s2,
+                b: n2,
+                a: r2
+            };
+        }
+    }(t3) : Ge(t3);
+}
+class Color {
+    constructor(t3) {
+        if (t3 instanceof Color)
+            return t3;
+        const e2 = typeof t3;
+        let i2;
+        var s2, n2, r2;
+        "object" === e2 ? i2 = ri(t3) : "string" === e2 && (r2 = (s2 = t3).length, "#" === s2[0] && (4 === r2 || 5 === r2 ? n2 = {
+            r: 255 & 17 * Le[s2[1]],
+            g: 255 & 17 * Le[s2[2]],
+            b: 255 & 17 * Le[s2[3]],
+            a: 5 === r2 ? 17 * Le[s2[4]] : 255
+        } : 7 !== r2 && 9 !== r2 || (n2 = {
+            r: Le[s2[1]] << 4 | Le[s2[2]],
+            g: Le[s2[3]] << 4 | Le[s2[4]],
+            b: Le[s2[5]] << 4 | Le[s2[6]],
+            a: 9 === r2 ? Le[s2[7]] << 4 | Le[s2[8]] : 255
+        })), i2 = n2 || Je(t3) || ai(t3)), this._rgb = i2, this._valid = !!i2;
+    }
+    get valid() {
+        return this._valid;
+    }
+    get rgb() {
+        var t3 = ni(this._rgb);
+        return t3 && (t3.a = Ae(t3.a)), t3;
+    }
+    set rgb(t3) {
+        this._rgb = ri(t3);
+    }
+    rgbString() {
+        return this._valid ? function(t3) {
+            return t3 && (t3.a < 255 ? `rgba(${t3.r}, ${t3.g}, ${t3.b}, ${Ae(t3.a)})` : `rgb(${t3.r}, ${t3.g}, ${t3.b})`);
+        }(this._rgb) : void 0;
+    }
+    hexString() {
+        return this._valid ? Ve(this._rgb) : void 0;
+    }
+    hslString() {
+        return this._valid ? function(t3) {
+            if (!t3)
+                return;
+            const e2 = He(t3),
+                i2 = e2[0],
+                s2 = De(e2[1]),
+                n2 = De(e2[2]);
+            return t3.a < 255 ? `hsla(${i2}, ${s2}%, ${n2}%, ${Ae(t3.a)})` : `hsl(${i2}, ${s2}%, ${n2}%)`;
+        }(this._rgb) : void 0;
+    }
+    mix(t3, e2) {
+        if (t3) {
+            const i2 = this.rgb,
+                s2 = t3.rgb;
+            let n2;
+            const r2 = e2 === n2 ? 0.5 : e2,
+                o2 = 2 * r2 - 1,
+                a2 = i2.a - s2.a,
+                l2 = ((o2 * a2 == -1 ? o2 : (o2 + a2) / (1 + o2 * a2)) + 1) / 2;
+            n2 = 1 - l2, i2.r = 255 & l2 * i2.r + n2 * s2.r + 0.5, i2.g = 255 & l2 * i2.g + n2 * s2.g + 0.5, i2.b = 255 & l2 * i2.b + n2 * s2.b + 0.5, i2.a = r2 * i2.a + (1 - r2) * s2.a, this.rgb = i2;
+        }
+        return this;
+    }
+    interpolate(t3, e2) {
+        return t3 && (this._rgb = function(t4, e3, i2) {
+            const s2 = ei(Ae(t4.r)),
+                n2 = ei(Ae(t4.g)),
+                r2 = ei(Ae(t4.b));
+            return {
+                r: Re(ti(s2 + i2 * (ei(Ae(e3.r)) - s2))),
+                g: Re(ti(n2 + i2 * (ei(Ae(e3.g)) - n2))),
+                b: Re(ti(r2 + i2 * (ei(Ae(e3.b)) - r2))),
+                a: t4.a + i2 * (e3.a - t4.a)
+            };
+        }(this._rgb, t3._rgb, e2)), this;
+    }
+    clone() {
+        return new Color(this.rgb);
+    }
+    alpha(t3) {
+        return this._rgb.a = Re(t3), this;
+    }
+    clearer(t3) {
+        return this._rgb.a *= 1 - t3, this;
+    }
+    greyscale() {
+        const t3 = this._rgb,
+            e2 = Ie(0.3 * t3.r + 0.59 * t3.g + 0.11 * t3.b);
+        return t3.r = t3.g = t3.b = e2, this;
+    }
+    opaquer(t3) {
+        return this._rgb.a *= 1 + t3, this;
+    }
+    negate() {
+        const t3 = this._rgb;
+        return t3.r = 255 - t3.r, t3.g = 255 - t3.g, t3.b = 255 - t3.b, this;
+    }
+    lighten(t3) {
+        return si(this._rgb, 2, t3), this;
+    }
+    darken(t3) {
+        return si(this._rgb, 2, -t3), this;
+    }
+    saturate(t3) {
+        return si(this._rgb, 1, t3), this;
+    }
+    desaturate(t3) {
+        return si(this._rgb, 1, -t3), this;
+    }
+    rotate(t3) {
+        return function(t4, e2) {
+            var i2 = He(t4);
+            i2[0] = Ke(i2[0] + e2), i2 = qe(i2), t4.r = i2[0], t4.g = i2[1], t4.b = i2[2];
+        }(this._rgb, t3), this;
+    }
+}
+
+function li() {}
+const hi = (() => {
+    let t3 = 0;
+    return () => t3++;
+})();
+
+function ci(t3) {
+    return null == t3;
+}
+
+function ui(t3) {
+    if (Array.isArray && Array.isArray(t3))
+        return true;
+    const e2 = Object.prototype.toString.call(t3);
+    return "[object" === e2.slice(0, 7) && "Array]" === e2.slice(-6);
+}
+
+function yi(t3) {
+    return null !== t3 && "[object Object]" === Object.prototype.toString.call(t3);
+}
+
+function _i(t3) {
+    return ("number" == typeof t3 || t3 instanceof Number) && isFinite(+t3);
+}
+
+function ki(t3, e2) {
+    return _i(t3) ? t3 : e2;
+}
+
+function Ti(t3, e2) {
+    return void 0 === t3 ? e2 : t3;
+}
+
+function Si(t3, e2, i2) {
+    if (t3 && "function" == typeof t3.call)
+        return t3.apply(i2, e2);
+}
+
+function Ei(t3, e2, i2, s2) {
+    let n2, r2, o2;
+    if (ui(t3))
+        if (r2 = t3.length, s2)
+            for (n2 = r2 - 1; n2 >= 0; n2--)
+                e2.call(i2, t3[n2], n2);
+        else
+            for (n2 = 0; n2 < r2; n2++)
+                e2.call(i2, t3[n2], n2);
+    else if (yi(t3))
+        for (o2 = Object.keys(t3), r2 = o2.length, n2 = 0; n2 < r2; n2++)
+            e2.call(i2, t3[o2[n2]], o2[n2]);
+}
+
+function Ii(t3, e2) {
+    let i2, s2, n2, r2;
+    if (!t3 || !e2 || t3.length !== e2.length)
+        return false;
+    for (i2 = 0, s2 = t3.length; i2 < s2; ++i2)
+        if (n2 = t3[i2], r2 = e2[i2], n2.datasetIndex !== r2.datasetIndex || n2.index !== r2.index)
+            return false;
+    return true;
+}
+
+function Li(t3) {
+    if (ui(t3))
+        return t3.map(Li);
+    if (yi(t3)) {
+        const e2 = /* @__PURE__ */ Object.create(null),
+            i2 = Object.keys(t3),
+            s2 = i2.length;
+        let n2 = 0;
+        for (; n2 < s2; ++n2)
+            e2[i2[n2]] = Li(t3[i2[n2]]);
+        return e2;
+    }
+    return t3;
+}
+
+function Oi(t3) {
+    return -1 === ["__proto__", "prototype", "constructor"].indexOf(t3);
+}
+
+function Fi(t3, e2, i2, s2) {
+    if (!Oi(t3))
+        return;
+    const n2 = e2[t3],
+        r2 = i2[t3];
+    yi(n2) && yi(r2) ? Ni(n2, r2, s2) : e2[t3] = Li(r2);
+}
+
+function Ni(t3, e2, i2) {
+    const s2 = ui(e2) ? e2 : [e2],
+        n2 = s2.length;
+    if (!yi(t3))
+        return t3;
+    const r2 = (i2 = i2 || {}).merger || Fi;
+    let o2;
+    for (let e3 = 0; e3 < n2; ++e3) {
+        if (o2 = s2[e3], !yi(o2))
+            continue;
+        const n3 = Object.keys(o2);
+        for (let e4 = 0, s3 = n3.length; e4 < s3; ++e4)
+            r2(n3[e4], t3, o2, i2);
+    }
+    return t3;
+}
+
+function Vi(t3, e2) {
+    return Ni(t3, e2, {
+        merger: zi
+    });
+}
+
+function zi(t3, e2, i2) {
+    if (!Oi(t3))
+        return;
+    const s2 = e2[t3],
+        n2 = i2[t3];
+    yi(s2) && yi(n2) ? Vi(s2, n2) : Object.prototype.hasOwnProperty.call(e2, t3) || (e2[t3] = Li(n2));
+}
+const Ui = {
+    "": (t3) => t3,
+    x: (t3) => t3.x,
+    y: (t3) => t3.y
+};
+
+function ji(t3, e2) {
+    const i2 = Ui[e2] || (Ui[e2] = function(t4) {
+        const e3 = function(t5) {
+            const e4 = t5.split("."),
+                i3 = [];
+            let s2 = "";
+            for (const t6 of e4)
+                s2 += t6, s2.endsWith("\\") ? s2 = s2.slice(0, -1) + "." : (i3.push(s2), s2 = "");
+            return i3;
+        }(t4);
+        return (t5) => {
+            for (const i3 of e3) {
+                if ("" === i3)
+                    break;
+                t5 = t5 && t5[i3];
+            }
+            return t5;
+        };
+    }(e2));
+    return i2(t3);
+}
+
+function Wi(t3) {
+    return t3.charAt(0).toUpperCase() + t3.slice(1);
+}
+const qi = (t3) => void 0 !== t3,
+    Gi = (t3) => "function" == typeof t3,
+    Yi = (t3, e2) => {
+        if (t3.size !== e2.size)
+            return false;
+        for (const i2 of t3)
+            if (!e2.has(i2))
+                return false;
+        return true;
+    };
+const Qi = Math.PI,
+    Xi = 2 * Qi,
+    Ji = Xi + Qi,
+    ts = Number.POSITIVE_INFINITY,
+    es = Qi / 180,
+    is = Qi / 2,
+    ss = Qi / 4,
+    ns = 2 * Qi / 3,
+    rs = Math.log10,
+    os = Math.sign;
+
+function as(t3, e2, i2) {
+    return Math.abs(t3 - e2) < i2;
+}
+
+function ls(t3) {
+    const e2 = Math.round(t3);
+    t3 = as(t3, e2, t3 / 1e3) ? e2 : t3;
+    const i2 = Math.pow(10, Math.floor(rs(t3))),
+        s2 = t3 / i2;
+    return (s2 <= 1 ? 1 : s2 <= 2 ? 2 : s2 <= 5 ? 5 : 10) * i2;
+}
+
+function hs(t3) {
+    return !isNaN(parseFloat(t3)) && isFinite(t3);
+}
+
+function cs(t3, e2, i2) {
+    let s2, n2, r2;
+    for (s2 = 0, n2 = t3.length; s2 < n2; s2++)
+        r2 = t3[s2][i2], isNaN(r2) || (e2.min = Math.min(e2.min, r2), e2.max = Math.max(e2.max, r2));
+}
+
+function us(t3) {
+    return t3 * (Qi / 180);
+}
+
+function ds(t3) {
+    return t3 * (180 / Qi);
+}
+
+function fs(t3) {
+    if (!_i(t3))
+        return;
+    let e2 = 1,
+        i2 = 0;
+    for (; Math.round(t3 * e2) / e2 !== t3;)
+        e2 *= 10, i2++;
+    return i2;
+}
+
+function ps(t3, e2) {
+    return Math.sqrt(Math.pow(e2.x - t3.x, 2) + Math.pow(e2.y - t3.y, 2));
+}
+
+function ms(t3, e2) {
+    return (t3 - e2 + Ji) % Xi - Qi;
+}
+
+function gs(t3) {
+    return (t3 % Xi + Xi) % Xi;
+}
+
+function ys(t3, e2, i2, s2) {
+    const n2 = gs(t3),
+        r2 = gs(e2),
+        o2 = gs(i2),
+        a2 = gs(r2 - n2),
+        l2 = gs(o2 - n2),
+        h2 = gs(n2 - r2),
+        c2 = gs(n2 - o2);
+    return n2 === r2 || n2 === o2 || s2 && r2 === o2 || a2 > l2 && h2 < c2;
+}
+
+function vs(t3, e2, i2) {
+    return Math.max(e2, Math.min(i2, t3));
+}
+
+function bs(t3, e2, i2, s2 = 1e-6) {
+    return t3 >= Math.min(e2, i2) - s2 && t3 <= Math.max(e2, i2) + s2;
+}
+
+function _s(t3, e2, i2) {
+    i2 = i2 || ((i3) => t3[i3] < e2);
+    let s2, n2 = t3.length - 1,
+        r2 = 0;
+    for (; n2 - r2 > 1;)
+        s2 = r2 + n2 >> 1, i2(s2) ? r2 = s2 : n2 = s2;
+    return {
+        lo: r2,
+        hi: n2
+    };
+}
+const ws = (t3, e2, i2, s2) => _s(t3, i2, s2 ? (s3) => {
+        const n2 = t3[s3][e2];
+        return n2 < i2 || n2 === i2 && t3[s3 + 1][e2] === i2;
+    } : (s3) => t3[s3][e2] < i2),
+    xs = (t3, e2, i2) => _s(t3, i2, (s2) => t3[s2][e2] >= i2);
+const ks = ["push", "pop", "shift", "splice", "unshift"];
+
+function Ts(t3, e2) {
+    const i2 = t3._chartjs;
+    if (!i2)
+        return;
+    const s2 = i2.listeners,
+        n2 = s2.indexOf(e2); -
+    1 !== n2 && s2.splice(n2, 1), s2.length > 0 || (ks.forEach((e3) => {
+        delete t3[e3];
+    }), delete t3._chartjs);
+}
+
+function Es(t3) {
+    const e2 = new Set(t3);
+    return e2.size === t3.length ? t3 : Array.from(e2);
+}
+const Cs = "undefined" == typeof window ? function(t3) {
+    return t3();
+} : window.requestAnimationFrame;
+
+function Is(t3, e2) {
+    let i2 = [],
+        s2 = false;
+    return function(...n2) {
+        i2 = n2, s2 || (s2 = true, Cs.call(window, () => {
+            s2 = false, t3.apply(e2, i2);
+        }));
+    };
+}
+const Ms = (t3, e2, i2) => "start" === t3 ? e2 : "end" === t3 ? i2 : (e2 + i2) / 2;
+const Ps = (t3) => 0 === t3 || 1 === t3,
+    Rs = (t3, e2, i2) => -Math.pow(2, 10 * (t3 -= 1)) * Math.sin((t3 - e2) * Xi / i2),
+    As = (t3, e2, i2) => Math.pow(2, -10 * t3) * Math.sin((t3 - e2) * Xi / i2) + 1,
+    Ds = {
+        linear: (t3) => t3,
+        easeInQuad: (t3) => t3 * t3,
+        easeOutQuad: (t3) => -t3 * (t3 - 2),
+        easeInOutQuad: (t3) => (t3 /= 0.5) < 1 ? 0.5 * t3 * t3 : -0.5 * (--t3 * (t3 - 2) - 1),
+        easeInCubic: (t3) => t3 * t3 * t3,
+        easeOutCubic: (t3) => (t3 -= 1) * t3 * t3 + 1,
+        easeInOutCubic: (t3) => (t3 /= 0.5) < 1 ? 0.5 * t3 * t3 * t3 : 0.5 * ((t3 -= 2) * t3 * t3 + 2),
+        easeInQuart: (t3) => t3 * t3 * t3 * t3,
+        easeOutQuart: (t3) => -((t3 -= 1) * t3 * t3 * t3 - 1),
+        easeInOutQuart: (t3) => (t3 /= 0.5) < 1 ? 0.5 * t3 * t3 * t3 * t3 : -0.5 * ((t3 -= 2) * t3 * t3 * t3 - 2),
+        easeInQuint: (t3) => t3 * t3 * t3 * t3 * t3,
+        easeOutQuint: (t3) => (t3 -= 1) * t3 * t3 * t3 * t3 + 1,
+        easeInOutQuint: (t3) => (t3 /= 0.5) < 1 ? 0.5 * t3 * t3 * t3 * t3 * t3 : 0.5 * ((t3 -= 2) * t3 * t3 * t3 * t3 + 2),
+        easeInSine: (t3) => 1 - Math.cos(t3 * is),
+        easeOutSine: (t3) => Math.sin(t3 * is),
+        easeInOutSine: (t3) => -0.5 * (Math.cos(Qi * t3) - 1),
+        easeInExpo: (t3) => 0 === t3 ? 0 : Math.pow(2, 10 * (t3 - 1)),
+        easeOutExpo: (t3) => 1 === t3 ? 1 : 1 - Math.pow(2, -10 * t3),
+        easeInOutExpo: (t3) => Ps(t3) ? t3 : t3 < 0.5 ? 0.5 * Math.pow(2, 10 * (2 * t3 - 1)) : 0.5 * (2 - Math.pow(2, -10 * (2 * t3 - 1))),
+        easeInCirc: (t3) => t3 >= 1 ? t3 : -(Math.sqrt(1 - t3 * t3) - 1),
+        easeOutCirc: (t3) => Math.sqrt(1 - (t3 -= 1) * t3),
+        easeInOutCirc: (t3) => (t3 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t3 * t3) - 1) : 0.5 * (Math.sqrt(1 - (t3 -= 2) * t3) + 1),
+        easeInElastic: (t3) => Ps(t3) ? t3 : Rs(t3, 0.075, 0.3),
+        easeOutElastic: (t3) => Ps(t3) ? t3 : As(t3, 0.075, 0.3),
+        easeInOutElastic(t3) {
+            const e2 = 0.1125;
+            return Ps(t3) ? t3 : t3 < 0.5 ? 0.5 * Rs(2 * t3, e2, 0.45) : 0.5 + 0.5 * As(2 * t3 - 1, e2, 0.45);
+        },
+        easeInBack(t3) {
+            const e2 = 1.70158;
+            return t3 * t3 * ((e2 + 1) * t3 - e2);
+        },
+        easeOutBack(t3) {
+            const e2 = 1.70158;
+            return (t3 -= 1) * t3 * ((e2 + 1) * t3 + e2) + 1;
+        },
+        easeInOutBack(t3) {
+            let e2 = 1.70158;
+            return (t3 /= 0.5) < 1 ? t3 * t3 * ((1 + (e2 *= 1.525)) * t3 - e2) * 0.5 : 0.5 * ((t3 -= 2) * t3 * ((1 + (e2 *= 1.525)) * t3 + e2) + 2);
+        },
+        easeInBounce: (t3) => 1 - Ds.easeOutBounce(1 - t3),
+        easeOutBounce(t3) {
+            const e2 = 7.5625,
+                i2 = 2.75;
+            return t3 < 1 / i2 ? e2 * t3 * t3 : t3 < 2 / i2 ? e2 * (t3 -= 1.5 / i2) * t3 + 0.75 : t3 < 2.5 / i2 ? e2 * (t3 -= 2.25 / i2) * t3 + 0.9375 : e2 * (t3 -= 2.625 / i2) * t3 + 0.984375;
+        },
+        easeInOutBounce: (t3) => t3 < 0.5 ? 0.5 * Ds.easeInBounce(2 * t3) : 0.5 * Ds.easeOutBounce(2 * t3 - 1) + 0.5
+    };
+
+function Ls(t3) {
+    if (t3 && "object" == typeof t3) {
+        const e2 = t3.toString();
+        return "[object CanvasPattern]" === e2 || "[object CanvasGradient]" === e2;
+    }
+    return false;
+}
+
+function Os(t3) {
+    return Ls(t3) ? t3 : new Color(t3);
+}
+
+function Fs(t3) {
+    return Ls(t3) ? t3 : new Color(t3).saturate(0.5).darken(0.1).hexString();
+}
+const Vs = ["x", "y", "borderWidth", "radius", "tension"],
+    zs = ["color", "borderColor", "backgroundColor"];
+const Bs = /* @__PURE__ */ new Map();
+
+function Us(t3, e2, i2) {
+    return function(t4, e3) {
+        e3 = e3 || {};
+        const i3 = t4 + JSON.stringify(e3);
+        let s2 = Bs.get(i3);
+        return s2 || (s2 = new Intl.NumberFormat(t4, e3), Bs.set(i3, s2)), s2;
+    }(e2, i2).format(t3);
+}
+const Hs = {
+    values: (t3) => ui(t3) ? t3 : "" + t3,
+    numeric(t3, e2, i2) {
+        if (0 === t3)
+            return "0";
+        const s2 = this.chart.options.locale;
+        let n2, r2 = t3;
+        if (i2.length > 1) {
+            const e3 = Math.max(Math.abs(i2[0].value), Math.abs(i2[i2.length - 1].value));
+            (e3 < 1e-4 || e3 > 1e15) && (n2 = "scientific"), r2 = function(t4, e4) {
+                let i3 = e4.length > 3 ? e4[2].value - e4[1].value : e4[1].value - e4[0].value;
+                Math.abs(i3) >= 1 && t4 !== Math.floor(t4) && (i3 = t4 - Math.floor(t4));
+                return i3;
+            }(t3, i2);
+        }
+        const o2 = rs(Math.abs(r2)),
+            a2 = isNaN(o2) ? 1 : Math.max(Math.min(-1 * Math.floor(o2), 20), 0),
+            l2 = {
+                notation: n2,
+                minimumFractionDigits: a2,
+                maximumFractionDigits: a2
+            };
+        return Object.assign(l2, this.options.ticks.format), Us(t3, s2, l2);
+    },
+    logarithmic(t3, e2, i2) {
+        if (0 === t3)
+            return "0";
+        const s2 = i2[e2].significand || t3 / Math.pow(10, Math.floor(rs(t3)));
+        return [1, 2, 3, 5, 10, 15].includes(s2) || e2 > 0.8 * i2.length ? Hs.numeric.call(this, t3, e2, i2) : "";
+    }
+};
+var Ks = {
+    formatters: Hs
+};
+const Gs = /* @__PURE__ */ Object.create(null),
+    Ys = /* @__PURE__ */ Object.create(null);
+
+function Qs(t3, e2) {
+    if (!e2)
+        return t3;
+    const i2 = e2.split(".");
+    for (let e3 = 0, s2 = i2.length; e3 < s2; ++e3) {
+        const s3 = i2[e3];
+        t3 = t3[s3] || (t3[s3] = /* @__PURE__ */ Object.create(null));
+    }
+    return t3;
+}
+
+function Xs(t3, e2, i2) {
+    return "string" == typeof e2 ? Ni(Qs(t3, e2), i2) : Ni(Qs(t3, ""), e2);
+}
+class Defaults {
+    constructor(t3, e2) {
+        this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (t4) => t4.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"], this.font = {
+            family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
+            size: 12,
+            style: "normal",
+            lineHeight: 1.2,
+            weight: null
+        }, this.hover = {}, this.hoverBackgroundColor = (t4, e3) => Fs(e3.backgroundColor), this.hoverBorderColor = (t4, e3) => Fs(e3.borderColor), this.hoverColor = (t4, e3) => Fs(e3.color), this.indexAxis = "x", this.interaction = {
+            mode: "nearest",
+            intersect: true,
+            includeInvisible: false
+        }, this.maintainAspectRatio = true, this.onHover = null, this.onClick = null, this.parsing = true, this.plugins = {}, this.responsive = true, this.scale = void 0, this.scales = {}, this.showLine = true, this.drawActiveElementsOnTop = true, this.describe(t3), this.apply(e2);
+    }
+    set(t3, e2) {
+        return Xs(this, t3, e2);
+    }
+    get(t3) {
+        return Qs(this, t3);
+    }
+    describe(t3, e2) {
+        return Xs(Ys, t3, e2);
+    }
+    override(t3, e2) {
+        return Xs(Gs, t3, e2);
+    }
+    route(t3, e2, i2, s2) {
+        const n2 = Qs(this, t3),
+            r2 = Qs(this, i2),
+            o2 = "_" + e2;
+        Object.defineProperties(n2, {
+            [o2]: {
+                value: n2[e2],
+                writable: true
+            },
+            [e2]: {
+                enumerable: true,
+                get() {
+                    const t4 = this[o2],
+                        e3 = r2[s2];
+                    return yi(t4) ? Object.assign({}, e3, t4) : Ti(t4, e3);
+                },
+                set(t4) {
+                    this[o2] = t4;
+                }
+            }
+        });
+    }
+    apply(t3) {
+        t3.forEach((t4) => t4(this));
+    }
+}
+var Js = new Defaults({
+    _scriptable: (t3) => !t3.startsWith("on"),
+    _indexable: (t3) => "events" !== t3,
+    hover: {
+        _fallback: "interaction"
+    },
+    interaction: {
+        _scriptable: false,
+        _indexable: false
+    }
+}, [function(t3) {
+    t3.set("animation", {
+        delay: void 0,
+        duration: 1e3,
+        easing: "easeOutQuart",
+        fn: void 0,
+        from: void 0,
+        loop: void 0,
+        to: void 0,
+        type: void 0
+    }), t3.describe("animation", {
+        _fallback: false,
+        _indexable: false,
+        _scriptable: (t4) => "onProgress" !== t4 && "onComplete" !== t4 && "fn" !== t4
+    }), t3.set("animations", {
+        colors: {
+            type: "color",
+            properties: zs
+        },
+        numbers: {
+            type: "number",
+            properties: Vs
+        }
+    }), t3.describe("animations", {
+        _fallback: "animation"
+    }), t3.set("transitions", {
+        active: {
+            animation: {
+                duration: 400
+            }
+        },
+        resize: {
+            animation: {
+                duration: 0
+            }
+        },
+        show: {
+            animations: {
+                colors: {
+                    from: "transparent"
+                },
+                visible: {
+                    type: "boolean",
+                    duration: 0
+                }
+            }
+        },
+        hide: {
+            animations: {
+                colors: {
+                    to: "transparent"
+                },
+                visible: {
+                    type: "boolean",
+                    easing: "linear",
+                    fn: (t4) => 0 | t4
+                }
+            }
+        }
+    });
+}, function(t3) {
+    t3.set("layout", {
+        autoPadding: true,
+        padding: {
+            top: 0,
+            right: 0,
+            bottom: 0,
+            left: 0
+        }
+    });
+}, function(t3) {
+    t3.set("scale", {
+        display: true,
+        offset: false,
+        reverse: false,
+        beginAtZero: false,
+        bounds: "ticks",
+        clip: true,
+        grace: 0,
+        grid: {
+            display: true,
+            lineWidth: 1,
+            drawOnChartArea: true,
+            drawTicks: true,
+            tickLength: 8,
+            tickWidth: (t4, e2) => e2.lineWidth,
+            tickColor: (t4, e2) => e2.color,
+            offset: false
+        },
+        border: {
+            display: true,
+            dash: [],
+            dashOffset: 0,
+            width: 1
+        },
+        title: {
+            display: false,
+            text: "",
+            padding: {
+                top: 4,
+                bottom: 4
+            }
+        },
+        ticks: {
+            minRotation: 0,
+            maxRotation: 50,
+            mirror: false,
+            textStrokeWidth: 0,
+            textStrokeColor: "",
+            padding: 3,
+            display: true,
+            autoSkip: true,
+            autoSkipPadding: 3,
+            labelOffset: 0,
+            callback: Ks.formatters.values,
+            minor: {},
+            major: {},
+            align: "center",
+            crossAlign: "near",
+            showLabelBackdrop: false,
+            backdropColor: "rgba(255, 255, 255, 0.75)",
+            backdropPadding: 2
+        }
+    }), t3.route("scale.ticks", "color", "", "color"), t3.route("scale.grid", "color", "", "borderColor"), t3.route("scale.border", "color", "", "borderColor"), t3.route("scale.title", "color", "", "color"), t3.describe("scale", {
+        _fallback: false,
+        _scriptable: (t4) => !t4.startsWith("before") && !t4.startsWith("after") && "callback" !== t4 && "parser" !== t4,
+        _indexable: (t4) => "borderDash" !== t4 && "tickBorderDash" !== t4 && "dash" !== t4
+    }), t3.describe("scales", {
+        _fallback: "scale"
+    }), t3.describe("scale.ticks", {
+        _scriptable: (t4) => "backdropPadding" !== t4 && "callback" !== t4,
+        _indexable: (t4) => "backdropPadding" !== t4
+    });
+}]);
+
+function Zs(t3, e2, i2, s2, n2) {
+    let r2 = e2[n2];
+    return r2 || (r2 = e2[n2] = t3.measureText(n2).width, i2.push(n2)), r2 > s2 && (s2 = r2), s2;
+}
+
+function tn(t3, e2, i2) {
+    const s2 = t3.currentDevicePixelRatio,
+        n2 = 0 !== i2 ? Math.max(i2 / 2, 0.5) : 0;
+    return Math.round((e2 - n2) * s2) / s2 + n2;
+}
+
+function en(t3, e2) {
+    (e2 = e2 || t3.getContext("2d")).save(), e2.resetTransform(), e2.clearRect(0, 0, t3.width, t3.height), e2.restore();
+}
+
+function sn(t3, e2, i2, s2) {
+    ! function(t4, e3, i3, s3, n2) {
+        let r2, o2, a2, l2, h2, c2, u2, d2;
+        const f2 = e3.pointStyle,
+            p2 = e3.rotation,
+            m2 = e3.radius;
+        let g2 = (p2 || 0) * es;
+        if (f2 && "object" == typeof f2 && (r2 = f2.toString(), "[object HTMLImageElement]" === r2 || "[object HTMLCanvasElement]" === r2))
+            return t4.save(), t4.translate(i3, s3), t4.rotate(g2), t4.drawImage(f2, -f2.width / 2, -f2.height / 2, f2.width, f2.height), void t4.restore();
+        if (isNaN(m2) || m2 <= 0)
+            return;
+        switch (t4.beginPath(), f2) {
+            default:
+                n2 ? t4.ellipse(i3, s3, n2 / 2, m2, 0, 0, Xi) : t4.arc(i3, s3, m2, 0, Xi), t4.closePath();
+                break;
+            case "triangle":
+                c2 = n2 ? n2 / 2 : m2, t4.moveTo(i3 + Math.sin(g2) * c2, s3 - Math.cos(g2) * m2), g2 += ns, t4.lineTo(i3 + Math.sin(g2) * c2, s3 - Math.cos(g2) * m2), g2 += ns, t4.lineTo(i3 + Math.sin(g2) * c2, s3 - Math.cos(g2) * m2), t4.closePath();
+                break;
+            case "rectRounded":
+                h2 = 0.516 * m2, l2 = m2 - h2, o2 = Math.cos(g2 + ss) * l2, u2 = Math.cos(g2 + ss) * (n2 ? n2 / 2 - h2 : l2), a2 = Math.sin(g2 + ss) * l2, d2 = Math.sin(g2 + ss) * (n2 ? n2 / 2 - h2 : l2), t4.arc(i3 - u2, s3 - a2, h2, g2 - Qi, g2 - is), t4.arc(i3 + d2, s3 - o2, h2, g2 - is, g2), t4.arc(i3 + u2, s3 + a2, h2, g2, g2 + is), t4.arc(i3 - d2, s3 + o2, h2, g2 + is, g2 + Qi), t4.closePath();
+                break;
+            case "rect":
+                if (!p2) {
+                    l2 = Math.SQRT1_2 * m2, c2 = n2 ? n2 / 2 : l2, t4.rect(i3 - c2, s3 - l2, 2 * c2, 2 * l2);
+                    break;
+                }
+                g2 += ss;
+            case "rectRot":
+                u2 = Math.cos(g2) * (n2 ? n2 / 2 : m2), o2 = Math.cos(g2) * m2, a2 = Math.sin(g2) * m2, d2 = Math.sin(g2) * (n2 ? n2 / 2 : m2), t4.moveTo(i3 - u2, s3 - a2), t4.lineTo(i3 + d2, s3 - o2), t4.lineTo(i3 + u2, s3 + a2), t4.lineTo(i3 - d2, s3 + o2), t4.closePath();
+                break;
+            case "crossRot":
+                g2 += ss;
+            case "cross":
+                u2 = Math.cos(g2) * (n2 ? n2 / 2 : m2), o2 = Math.cos(g2) * m2, a2 = Math.sin(g2) * m2, d2 = Math.sin(g2) * (n2 ? n2 / 2 : m2), t4.moveTo(i3 - u2, s3 - a2), t4.lineTo(i3 + u2, s3 + a2), t4.moveTo(i3 + d2, s3 - o2), t4.lineTo(i3 - d2, s3 + o2);
+                break;
+            case "star":
+                u2 = Math.cos(g2) * (n2 ? n2 / 2 : m2), o2 = Math.cos(g2) * m2, a2 = Math.sin(g2) * m2, d2 = Math.sin(g2) * (n2 ? n2 / 2 : m2), t4.moveTo(i3 - u2, s3 - a2), t4.lineTo(i3 + u2, s3 + a2), t4.moveTo(i3 + d2, s3 - o2), t4.lineTo(i3 - d2, s3 + o2), g2 += ss, u2 = Math.cos(g2) * (n2 ? n2 / 2 : m2), o2 = Math.cos(g2) * m2, a2 = Math.sin(g2) * m2, d2 = Math.sin(g2) * (n2 ? n2 / 2 : m2), t4.moveTo(i3 - u2, s3 - a2), t4.lineTo(i3 + u2, s3 + a2), t4.moveTo(i3 + d2, s3 - o2), t4.lineTo(i3 - d2, s3 + o2);
+                break;
+            case "line":
+                o2 = n2 ? n2 / 2 : Math.cos(g2) * m2, a2 = Math.sin(g2) * m2, t4.moveTo(i3 - o2, s3 - a2), t4.lineTo(i3 + o2, s3 + a2);
+                break;
+            case "dash":
+                t4.moveTo(i3, s3), t4.lineTo(i3 + Math.cos(g2) * (n2 ? n2 / 2 : m2), s3 + Math.sin(g2) * m2);
+                break;
+            case false:
+                t4.closePath();
+        }
+        t4.fill(), e3.borderWidth > 0 && t4.stroke();
+    }(t3, e2, i2, s2, null);
+}
+
+function nn(t3, e2, i2) {
+    return i2 = i2 || 0.5, !e2 || t3 && t3.x > e2.left - i2 && t3.x < e2.right + i2 && t3.y > e2.top - i2 && t3.y < e2.bottom + i2;
+}
+
+function ln(t3, e2) {
+    t3.save(), t3.beginPath(), t3.rect(e2.left, e2.top, e2.right - e2.left, e2.bottom - e2.top), t3.clip();
+}
+
+function un(t3) {
+    t3.restore();
+}
+
+function fn(t3, e2, i2, s2, n2) {
+    if (!e2)
+        return t3.lineTo(i2.x, i2.y);
+    if ("middle" === n2) {
+        const s3 = (e2.x + i2.x) / 2;
+        t3.lineTo(s3, e2.y), t3.lineTo(s3, i2.y);
+    } else
+        "after" === n2 != !!s2 ? t3.lineTo(e2.x, i2.y) : t3.lineTo(i2.x, e2.y);
+    t3.lineTo(i2.x, i2.y);
+}
+
+function pn(t3, e2, i2, s2) {
+    if (!e2)
+        return t3.lineTo(i2.x, i2.y);
+    t3.bezierCurveTo(s2 ? e2.cp1x : e2.cp2x, s2 ? e2.cp1y : e2.cp2y, s2 ? i2.cp2x : i2.cp1x, s2 ? i2.cp2y : i2.cp1y, i2.x, i2.y);
+}
+
+function mn(t3, e2, i2, s2, n2) {
+    if (n2.strikethrough || n2.underline) {
+        const r2 = t3.measureText(s2),
+            o2 = e2 - r2.actualBoundingBoxLeft,
+            a2 = e2 + r2.actualBoundingBoxRight,
+            l2 = i2 - r2.actualBoundingBoxAscent,
+            h2 = i2 + r2.actualBoundingBoxDescent,
+            c2 = n2.strikethrough ? (l2 + h2) / 2 : h2;
+        t3.strokeStyle = t3.fillStyle, t3.beginPath(), t3.lineWidth = n2.decorationWidth || 2, t3.moveTo(o2, c2), t3.lineTo(a2, c2), t3.stroke();
+    }
+}
+
+function yn(t3, e2) {
+    const i2 = t3.fillStyle;
+    t3.fillStyle = e2.color, t3.fillRect(e2.left, e2.top, e2.width, e2.height), t3.fillStyle = i2;
+}
+
+function vn(t3, e2, i2, s2, n2, r2 = {}) {
+    const o2 = ui(e2) ? e2 : [e2],
+        a2 = r2.strokeWidth > 0 && "" !== r2.strokeColor;
+    let l2, h2;
+    for (t3.save(), t3.font = n2.string, function(t4, e3) {
+            e3.translation && t4.translate(e3.translation[0], e3.translation[1]), ci(e3.rotation) || t4.rotate(e3.rotation), e3.color && (t4.fillStyle = e3.color), e3.textAlign && (t4.textAlign = e3.textAlign), e3.textBaseline && (t4.textBaseline = e3.textBaseline);
+        }(t3, r2), l2 = 0; l2 < o2.length; ++l2)
+        h2 = o2[l2], r2.backdrop && yn(t3, r2.backdrop), a2 && (r2.strokeColor && (t3.strokeStyle = r2.strokeColor), ci(r2.strokeWidth) || (t3.lineWidth = r2.strokeWidth), t3.strokeText(h2, i2, s2, r2.maxWidth)), t3.fillText(h2, i2, s2, r2.maxWidth), mn(t3, i2, s2, h2, r2), s2 += Number(n2.lineHeight);
+    t3.restore();
+}
+
+function bn(t3, e2) {
+    const {
+        x: i2,
+        y: s2,
+        w: n2,
+        h: r2,
+        radius: o2
+    } = e2;
+    t3.arc(i2 + o2.topLeft, s2 + o2.topLeft, o2.topLeft, 1.5 * Qi, Qi, true), t3.lineTo(i2, s2 + r2 - o2.bottomLeft), t3.arc(i2 + o2.bottomLeft, s2 + r2 - o2.bottomLeft, o2.bottomLeft, Qi, is, true), t3.lineTo(i2 + n2 - o2.bottomRight, s2 + r2), t3.arc(i2 + n2 - o2.bottomRight, s2 + r2 - o2.bottomRight, o2.bottomRight, is, 0, true), t3.lineTo(i2 + n2, s2 + o2.topRight), t3.arc(i2 + n2 - o2.topRight, s2 + o2.topRight, o2.topRight, 0, -is, true), t3.lineTo(i2 + o2.topLeft, s2);
+}
+const kn = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/,
+    Tn = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
+
+function En(t3, e2) {
+    const i2 = ("" + t3).match(kn);
+    if (!i2 || "normal" === i2[1])
+        return 1.2 * e2;
+    switch (t3 = +i2[2], i2[3]) {
+        case "px":
+            return t3;
+        case "%":
+            t3 /= 100;
+    }
+    return e2 * t3;
+}
+const Cn = (t3) => +t3 || 0;
+
+function Pn(t3, e2) {
+    const i2 = {},
+        s2 = yi(e2),
+        n2 = s2 ? Object.keys(e2) : e2,
+        r2 = yi(t3) ? s2 ? (i3) => Ti(t3[i3], t3[e2[i3]]) : (e3) => t3[e3] : () => t3;
+    for (const t4 of n2)
+        i2[t4] = Cn(r2(t4));
+    return i2;
+}
+
+function Rn(t3) {
+    return Pn(t3, {
+        top: "y",
+        right: "x",
+        bottom: "y",
+        left: "x"
+    });
+}
+
+function Dn(t3) {
+    return Pn(t3, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
+}
+
+function Ln(t3) {
+    const e2 = Rn(t3);
+    return e2.width = e2.left + e2.right, e2.height = e2.top + e2.bottom, e2;
+}
+
+function On(t3, e2) {
+    t3 = t3 || {}, e2 = e2 || Js.font;
+    let i2 = Ti(t3.size, e2.size);
+    "string" == typeof i2 && (i2 = parseInt(i2, 10));
+    let s2 = Ti(t3.style, e2.style);
+    s2 && !("" + s2).match(Tn) && (console.warn('Invalid font style specified: "' + s2 + '"'), s2 = void 0);
+    const n2 = {
+        family: Ti(t3.family, e2.family),
+        lineHeight: En(Ti(t3.lineHeight, e2.lineHeight), i2),
+        size: i2,
+        style: s2,
+        weight: Ti(t3.weight, e2.weight),
+        string: ""
+    };
+    return n2.string = function(t4) {
+        return !t4 || ci(t4.size) || ci(t4.family) ? null : (t4.style ? t4.style + " " : "") + (t4.weight ? t4.weight + " " : "") + t4.size + "px " + t4.family;
+    }(n2), n2;
+}
+
+function Fn(t3, e2, i2, s2) {
+    let n2, r2, o2, a2 = true;
+    for (n2 = 0, r2 = t3.length; n2 < r2; ++n2)
+        if (o2 = t3[n2], void 0 !== o2 && (void 0 !== e2 && "function" == typeof o2 && (o2 = o2(e2), a2 = false), void 0 !== i2 && ui(o2) && (o2 = o2[i2 % o2.length], a2 = false), void 0 !== o2))
+            return s2 && !a2 && (s2.cacheable = false), o2;
+}
+
+function Nn(t3, e2, i2) {
+    const {
+        min: s2,
+        max: n2
+    } = t3, r2 = (a2 = (n2 - s2) / 2, "string" == typeof(o2 = e2) && o2.endsWith("%") ? parseFloat(o2) / 100 * a2 : +o2);
+    var o2, a2;
+    const l2 = (t4, e3) => i2 && 0 === t4 ? 0 : t4 + e3;
+    return {
+        min: l2(s2, -Math.abs(r2)),
+        max: l2(n2, r2)
+    };
+}
+
+function $n(t3, e2) {
+    return Object.assign(Object.create(t3), e2);
+}
+
+function Vn(t3, e2 = [""], i2, s2, n2 = () => t3[0]) {
+    const r2 = i2 || t3;
+    void 0 === s2 && (s2 = er("_fallback", t3));
+    const o2 = {
+        [Symbol.toStringTag]: "Object",
+        _cacheable: true,
+        _scopes: t3,
+        _rootScopes: r2,
+        _fallback: s2,
+        _getTarget: n2,
+        override: (i3) => Vn([i3, ...t3], e2, r2, s2)
+    };
+    return new Proxy(o2, {
+        deleteProperty: (e3, i3) => (delete e3[i3], delete e3._keys, delete t3[0][i3], true),
+        get: (i3, s3) => Hn(i3, s3, () => function(t4, e3, i4, s4) {
+            let n3;
+            for (const r3 of e3)
+                if (n3 = er(Un(r3, t4), i4), void 0 !== n3)
+                    return jn(t4, n3) ? Zn(i4, s4, t4, n3) : n3;
+        }(s3, e2, t3, i3)),
+        getOwnPropertyDescriptor: (t4, e3) => Reflect.getOwnPropertyDescriptor(t4._scopes[0], e3),
+        getPrototypeOf: () => Reflect.getPrototypeOf(t3[0]),
+        has: (t4, e3) => ir(t4).includes(e3),
+        ownKeys: (t4) => ir(t4),
+        set(t4, e3, i3) {
+            const s3 = t4._storage || (t4._storage = n2());
+            return t4[e3] = s3[e3] = i3, delete t4._keys, true;
+        }
+    });
+}
+
+function zn(t3, e2, i2, s2) {
+    const n2 = {
+        _cacheable: false,
+        _proxy: t3,
+        _context: e2,
+        _subProxy: i2,
+        _stack: /* @__PURE__ */ new Set(),
+        _descriptors: Bn(t3, s2),
+        setContext: (e3) => zn(t3, e3, i2, s2),
+        override: (n3) => zn(t3.override(n3), e2, i2, s2)
+    };
+    return new Proxy(n2, {
+        deleteProperty: (e3, i3) => (delete e3[i3], delete t3[i3], true),
+        get: (t4, e3, i3) => Hn(t4, e3, () => function(t5, e4, i4) {
+            const {
+                _proxy: s3,
+                _context: n3,
+                _subProxy: r2,
+                _descriptors: o2
+            } = t5;
+            let a2 = s3[e4];
+            Gi(a2) && o2.isScriptable(e4) && (a2 = function(t6, e5, i5, s4) {
+                const {
+                    _proxy: n4,
+                    _context: r3,
+                    _subProxy: o3,
+                    _stack: a3
+                } = i5;
+                if (a3.has(t6))
+                    throw new Error("Recursion detected: " + Array.from(a3).join("->") + "->" + t6);
+                a3.add(t6);
+                let l2 = e5(r3, o3 || s4);
+                a3.delete(t6), jn(t6, l2) && (l2 = Zn(n4._scopes, n4, t6, l2));
+                return l2;
+            }(e4, a2, t5, i4));
+            ui(a2) && a2.length && (a2 = function(t6, e5, i5, s4) {
+                const {
+                    _proxy: n4,
+                    _context: r3,
+                    _subProxy: o3,
+                    _descriptors: a3
+                } = i5;
+                if (void 0 !== r3.index && s4(t6))
+                    return e5[r3.index % e5.length];
+                if (yi(e5[0])) {
+                    const i6 = e5,
+                        s5 = n4._scopes.filter((t7) => t7 !== i6);
+                    e5 = [];
+                    for (const l2 of i6) {
+                        const i7 = Zn(s5, n4, t6, l2);
+                        e5.push(zn(i7, r3, o3 && o3[t6], a3));
+                    }
+                }
+                return e5;
+            }(e4, a2, t5, o2.isIndexable));
+            jn(e4, a2) && (a2 = zn(a2, n3, r2 && r2[e4], o2));
+            return a2;
+        }(t4, e3, i3)),
+        getOwnPropertyDescriptor: (e3, i3) => e3._descriptors.allKeys ? Reflect.has(t3, i3) ? {
+            enumerable: true,
+            configurable: true
+        } : void 0 : Reflect.getOwnPropertyDescriptor(t3, i3),
+        getPrototypeOf: () => Reflect.getPrototypeOf(t3),
+        has: (e3, i3) => Reflect.has(t3, i3),
+        ownKeys: () => Reflect.ownKeys(t3),
+        set: (e3, i3, s3) => (t3[i3] = s3, delete e3[i3], true)
+    });
+}
+
+function Bn(t3, e2 = {
+    scriptable: true,
+    indexable: true
+}) {
+    const {
+        _scriptable: i2 = e2.scriptable,
+        _indexable: s2 = e2.indexable,
+        _allKeys: n2 = e2.allKeys
+    } = t3;
+    return {
+        allKeys: n2,
+        scriptable: i2,
+        indexable: s2,
+        isScriptable: Gi(i2) ? i2 : () => i2,
+        isIndexable: Gi(s2) ? s2 : () => s2
+    };
+}
+const Un = (t3, e2) => t3 ? t3 + Wi(e2) : e2,
+    jn = (t3, e2) => yi(e2) && "adapters" !== t3 && (null === Object.getPrototypeOf(e2) || e2.constructor === Object);
+
+function Hn(t3, e2, i2) {
+    if (Object.prototype.hasOwnProperty.call(t3, e2))
+        return t3[e2];
+    const s2 = i2();
+    return t3[e2] = s2, s2;
+}
+
+function qn(t3, e2, i2) {
+    return Gi(t3) ? t3(e2, i2) : t3;
+}
+const Gn = (t3, e2) => true === t3 ? e2 : "string" == typeof t3 ? ji(e2, t3) : void 0;
+
+function Jn(t3, e2, i2, s2, n2) {
+    for (const r2 of e2) {
+        const e3 = Gn(i2, r2);
+        if (e3) {
+            t3.add(e3);
+            const r3 = qn(e3._fallback, i2, n2);
+            if (void 0 !== r3 && r3 !== i2 && r3 !== s2)
+                return r3;
+        } else if (false === e3 && void 0 !== s2 && i2 !== s2)
+            return null;
+    }
+    return false;
+}
+
+function Zn(t3, e2, i2, s2) {
+    const n2 = e2._rootScopes,
+        r2 = qn(e2._fallback, i2, s2),
+        o2 = [...t3, ...n2],
+        a2 = /* @__PURE__ */ new Set();
+    a2.add(s2);
+    let l2 = tr(a2, o2, i2, r2 || i2, s2);
+    return null !== l2 && ((void 0 === r2 || r2 === i2 || (l2 = tr(a2, o2, r2, l2, s2), null !== l2)) && Vn(Array.from(a2), [""], n2, r2, () => function(t4, e3, i3) {
+        const s3 = t4._getTarget();
+        e3 in s3 || (s3[e3] = {});
+        const n3 = s3[e3];
+        if (ui(n3) && yi(i3))
+            return i3;
+        return n3 || {};
+    }(e2, i2, s2)));
+}
+
+function tr(t3, e2, i2, s2, n2) {
+    for (; i2;)
+        i2 = Jn(t3, e2, i2, s2, n2);
+    return i2;
+}
+
+function er(t3, e2) {
+    for (const i2 of e2) {
+        if (!i2)
+            continue;
+        const e3 = i2[t3];
+        if (void 0 !== e3)
+            return e3;
+    }
+}
+
+function ir(t3) {
+    let e2 = t3._keys;
+    return e2 || (e2 = t3._keys = function(t4) {
+        const e3 = /* @__PURE__ */ new Set();
+        for (const i2 of t4)
+            for (const t5 of Object.keys(i2).filter((t6) => !t6.startsWith("_")))
+                e3.add(t5);
+        return Array.from(e3);
+    }(t3._scopes)), e2;
+}
+const sr = Number.EPSILON || 1e-14,
+    nr = (t3, e2) => e2 < t3.length && !t3[e2].skip && t3[e2],
+    rr = (t3) => "x" === t3 ? "y" : "x";
+
+function or(t3, e2, i2, s2) {
+    const n2 = t3.skip ? e2 : t3,
+        r2 = e2,
+        o2 = i2.skip ? e2 : i2,
+        a2 = ps(r2, n2),
+        l2 = ps(o2, r2);
+    let h2 = a2 / (a2 + l2),
+        c2 = l2 / (a2 + l2);
+    h2 = isNaN(h2) ? 0 : h2, c2 = isNaN(c2) ? 0 : c2;
+    const u2 = s2 * h2,
+        d2 = s2 * c2;
+    return {
+        previous: {
+            x: r2.x - u2 * (o2.x - n2.x),
+            y: r2.y - u2 * (o2.y - n2.y)
+        },
+        next: {
+            x: r2.x + d2 * (o2.x - n2.x),
+            y: r2.y + d2 * (o2.y - n2.y)
+        }
+    };
+}
+
+function ar(t3, e2 = "x") {
+    const i2 = rr(e2),
+        s2 = t3.length,
+        n2 = Array(s2).fill(0),
+        r2 = Array(s2);
+    let o2, a2, l2, h2 = nr(t3, 0);
+    for (o2 = 0; o2 < s2; ++o2)
+        if (a2 = l2, l2 = h2, h2 = nr(t3, o2 + 1), l2) {
+            if (h2) {
+                const t4 = h2[e2] - l2[e2];
+                n2[o2] = 0 !== t4 ? (h2[i2] - l2[i2]) / t4 : 0;
+            }
+            r2[o2] = a2 ? h2 ? os(n2[o2 - 1]) !== os(n2[o2]) ? 0 : (n2[o2 - 1] + n2[o2]) / 2 : n2[o2 - 1] : n2[o2];
+        }!
+    function(t4, e3, i3) {
+        const s3 = t4.length;
+        let n3, r3, o3, a3, l3, h3 = nr(t4, 0);
+        for (let c2 = 0; c2 < s3 - 1; ++c2)
+            l3 = h3, h3 = nr(t4, c2 + 1), l3 && h3 && (as(e3[c2], 0, sr) ? i3[c2] = i3[c2 + 1] = 0 : (n3 = i3[c2] / e3[c2], r3 = i3[c2 + 1] / e3[c2], a3 = Math.pow(n3, 2) + Math.pow(r3, 2), a3 <= 9 || (o3 = 3 / Math.sqrt(a3), i3[c2] = n3 * o3 * e3[c2], i3[c2 + 1] = r3 * o3 * e3[c2])));
+    }(t3, n2, r2),
+    function(t4, e3, i3 = "x") {
+        const s3 = rr(i3),
+            n3 = t4.length;
+        let r3, o3, a3, l3 = nr(t4, 0);
+        for (let h3 = 0; h3 < n3; ++h3) {
+            if (o3 = a3, a3 = l3, l3 = nr(t4, h3 + 1), !a3)
+                continue;
+            const n4 = a3[i3],
+                c2 = a3[s3];
+            o3 && (r3 = (n4 - o3[i3]) / 3, a3[`cp1${i3}`] = n4 - r3, a3[`cp1${s3}`] = c2 - r3 * e3[h3]), l3 && (r3 = (l3[i3] - n4) / 3, a3[`cp2${i3}`] = n4 + r3, a3[`cp2${s3}`] = c2 + r3 * e3[h3]);
+        }
+    }(t3, r2, e2);
+}
+
+function lr(t3, e2, i2) {
+    return Math.max(Math.min(t3, i2), e2);
+}
+
+function hr(t3, e2, i2, s2, n2) {
+    let r2, o2, a2, l2;
+    if (e2.spanGaps && (t3 = t3.filter((t4) => !t4.skip)), "monotone" === e2.cubicInterpolationMode)
+        ar(t3, n2);
+    else {
+        let i3 = s2 ? t3[t3.length - 1] : t3[0];
+        for (r2 = 0, o2 = t3.length; r2 < o2; ++r2)
+            a2 = t3[r2], l2 = or(i3, a2, t3[Math.min(r2 + 1, o2 - (s2 ? 0 : 1)) % o2], e2.tension), a2.cp1x = l2.previous.x, a2.cp1y = l2.previous.y, a2.cp2x = l2.next.x, a2.cp2y = l2.next.y, i3 = a2;
+    }
+    e2.capBezierPoints && function(t4, e3) {
+        let i3, s3, n3, r3, o3, a3 = nn(t4[0], e3);
+        for (i3 = 0, s3 = t4.length; i3 < s3; ++i3)
+            o3 = r3, r3 = a3, a3 = i3 < s3 - 1 && nn(t4[i3 + 1], e3), r3 && (n3 = t4[i3], o3 && (n3.cp1x = lr(n3.cp1x, e3.left, e3.right), n3.cp1y = lr(n3.cp1y, e3.top, e3.bottom)), a3 && (n3.cp2x = lr(n3.cp2x, e3.left, e3.right), n3.cp2y = lr(n3.cp2y, e3.top, e3.bottom)));
+    }(t3, i2);
+}
+
+function cr() {
+    return "undefined" != typeof window && "undefined" != typeof document;
+}
+
+function ur(t3) {
+    let e2 = t3.parentNode;
+    return e2 && "[object ShadowRoot]" === e2.toString() && (e2 = e2.host), e2;
+}
+
+function dr(t3, e2, i2) {
+    let s2;
+    return "string" == typeof t3 ? (s2 = parseInt(t3, 10), -1 !== t3.indexOf("%") && (s2 = s2 / 100 * e2.parentNode[i2])) : s2 = t3, s2;
+}
+const fr = (t3) => t3.ownerDocument.defaultView.getComputedStyle(t3, null);
+const pr = ["top", "right", "bottom", "left"];
+
+function mr(t3, e2, i2) {
+    const s2 = {};
+    i2 = i2 ? "-" + i2 : "";
+    for (let n2 = 0; n2 < 4; n2++) {
+        const r2 = pr[n2];
+        s2[r2] = parseFloat(t3[e2 + "-" + r2 + i2]) || 0;
+    }
+    return s2.width = s2.left + s2.right, s2.height = s2.top + s2.bottom, s2;
+}
+const gr = (t3, e2, i2) => (t3 > 0 || e2 > 0) && (!i2 || !i2.shadowRoot);
+
+function yr(t3, e2) {
+    if ("native" in t3)
+        return t3;
+    const {
+        canvas: i2,
+        currentDevicePixelRatio: s2
+    } = e2, n2 = fr(i2), r2 = "border-box" === n2.boxSizing, o2 = mr(n2, "padding"), a2 = mr(n2, "border", "width"), {
+        x: l2,
+        y: h2,
+        box: c2
+    } = function(t4, e3) {
+        const i3 = t4.touches,
+            s3 = i3 && i3.length ? i3[0] : t4,
+            {
+                offsetX: n3,
+                offsetY: r3
+            } = s3;
+        let o3, a3, l3 = false;
+        if (gr(n3, r3, t4.target))
+            o3 = n3, a3 = r3;
+        else {
+            const t5 = e3.getBoundingClientRect();
+            o3 = s3.clientX - t5.left, a3 = s3.clientY - t5.top, l3 = true;
+        }
+        return {
+            x: o3,
+            y: a3,
+            box: l3
+        };
+    }(t3, i2), u2 = o2.left + (c2 && a2.left), d2 = o2.top + (c2 && a2.top);
+    let {
+        width: f2,
+        height: p2
+    } = e2;
+    return r2 && (f2 -= o2.width + a2.width, p2 -= o2.height + a2.height), {
+        x: Math.round((l2 - u2) / f2 * i2.width / s2),
+        y: Math.round((h2 - d2) / p2 * i2.height / s2)
+    };
+}
+const vr = (t3) => Math.round(10 * t3) / 10;
+
+function br(t3, e2, i2, s2) {
+    const n2 = fr(t3),
+        r2 = mr(n2, "margin"),
+        o2 = dr(n2.maxWidth, t3, "clientWidth") || ts,
+        a2 = dr(n2.maxHeight, t3, "clientHeight") || ts,
+        l2 = function(t4, e3, i3) {
+            let s3, n3;
+            if (void 0 === e3 || void 0 === i3) {
+                const r3 = ur(t4);
+                if (r3) {
+                    const t5 = r3.getBoundingClientRect(),
+                        o3 = fr(r3),
+                        a3 = mr(o3, "border", "width"),
+                        l3 = mr(o3, "padding");
+                    e3 = t5.width - l3.width - a3.width, i3 = t5.height - l3.height - a3.height, s3 = dr(o3.maxWidth, r3, "clientWidth"), n3 = dr(o3.maxHeight, r3, "clientHeight");
+                } else
+                    e3 = t4.clientWidth, i3 = t4.clientHeight;
+            }
+            return {
+                width: e3,
+                height: i3,
+                maxWidth: s3 || ts,
+                maxHeight: n3 || ts
+            };
+        }(t3, e2, i2);
+    let {
+        width: h2,
+        height: c2
+    } = l2;
+    if ("content-box" === n2.boxSizing) {
+        const t4 = mr(n2, "border", "width"),
+            e3 = mr(n2, "padding");
+        h2 -= e3.width + t4.width, c2 -= e3.height + t4.height;
+    }
+    h2 = Math.max(0, h2 - r2.width), c2 = Math.max(0, s2 ? h2 / s2 : c2 - r2.height), h2 = vr(Math.min(h2, o2, l2.maxWidth)), c2 = vr(Math.min(c2, a2, l2.maxHeight)), h2 && !c2 && (c2 = vr(h2 / 2));
+    return (void 0 !== e2 || void 0 !== i2) && s2 && l2.height && c2 > l2.height && (c2 = l2.height, h2 = vr(Math.floor(c2 * s2))), {
+        width: h2,
+        height: c2
+    };
+}
+
+function _r(t3, e2, i2) {
+    const s2 = e2 || 1,
+        n2 = Math.floor(t3.height * s2),
+        r2 = Math.floor(t3.width * s2);
+    t3.height = Math.floor(t3.height), t3.width = Math.floor(t3.width);
+    const o2 = t3.canvas;
+    return o2.style && (i2 || !o2.style.height && !o2.style.width) && (o2.style.height = `${t3.height}px`, o2.style.width = `${t3.width}px`), (t3.currentDevicePixelRatio !== s2 || o2.height !== n2 || o2.width !== r2) && (t3.currentDevicePixelRatio = s2, o2.height = n2, o2.width = r2, t3.ctx.setTransform(s2, 0, 0, s2, 0, 0), true);
+}
+const wr = function() {
+    let t3 = false;
+    try {
+        const e2 = {
+            get passive() {
+                return t3 = true, false;
+            }
+        };
+        window.addEventListener("test", null, e2), window.removeEventListener("test", null, e2);
+    } catch (t4) {}
+    return t3;
+}();
+
+function xr(t3, e2) {
+    const i2 = function(t4, e3) {
+            return fr(t4).getPropertyValue(e3);
+        }(t3, e2),
+        s2 = i2 && i2.match(/^(\d+)(\.\d+)?px$/);
+    return s2 ? +s2[1] : void 0;
+}
+
+function kr(t3, e2, i2, s2) {
+    return {
+        x: t3.x + i2 * (e2.x - t3.x),
+        y: t3.y + i2 * (e2.y - t3.y)
+    };
+}
+
+function Tr(t3, e2, i2, s2) {
+    return {
+        x: t3.x + i2 * (e2.x - t3.x),
+        y: "middle" === s2 ? i2 < 0.5 ? t3.y : e2.y : "after" === s2 ? i2 < 1 ? t3.y : e2.y : i2 > 0 ? e2.y : t3.y
+    };
+}
+
+function Sr(t3, e2, i2, s2) {
+    const n2 = {
+            x: t3.cp2x,
+            y: t3.cp2y
+        },
+        r2 = {
+            x: e2.cp1x,
+            y: e2.cp1y
+        },
+        o2 = kr(t3, n2, i2),
+        a2 = kr(n2, r2, i2),
+        l2 = kr(r2, e2, i2),
+        h2 = kr(o2, a2, i2),
+        c2 = kr(a2, l2, i2);
+    return kr(h2, c2, i2);
+}
+
+function Er(t3, e2, i2) {
+    return t3 ? function(t4, e3) {
+        return {
+            x: (i3) => t4 + t4 + e3 - i3,
+            setWidth(t5) {
+                e3 = t5;
+            },
+            textAlign: (t5) => "center" === t5 ? t5 : "right" === t5 ? "left" : "right",
+            xPlus: (t5, e4) => t5 - e4,
+            leftForLtr: (t5, e4) => t5 - e4
+        };
+    }(e2, i2) : {
+        x: (t4) => t4,
+        setWidth(t4) {},
+        textAlign: (t4) => t4,
+        xPlus: (t4, e3) => t4 + e3,
+        leftForLtr: (t4, e3) => t4
+    };
+}
+
+function Cr(t3) {
+    return "angle" === t3 ? {
+        between: ys,
+        compare: ms,
+        normalize: gs
+    } : {
+        between: bs,
+        compare: (t4, e2) => t4 - e2,
+        normalize: (t4) => t4
+    };
+}
+
+function Ir({
+    start: t3,
+    end: e2,
+    count: i2,
+    loop: s2,
+    style: n2
+}) {
+    return {
+        start: t3 % i2,
+        end: e2 % i2,
+        loop: s2 && (e2 - t3 + 1) % i2 == 0,
+        style: n2
+    };
+}
+
+function Mr(t3, e2, i2) {
+    if (!i2)
+        return [t3];
+    const {
+        property: s2,
+        start: n2,
+        end: r2
+    } = i2, o2 = e2.length, {
+        compare: a2,
+        between: l2,
+        normalize: h2
+    } = Cr(s2), {
+        start: c2,
+        end: u2,
+        loop: d2,
+        style: f2
+    } = function(t4, e3, i3) {
+        const {
+            property: s3,
+            start: n3,
+            end: r3
+        } = i3, {
+            between: o3,
+            normalize: a3
+        } = Cr(s3), l3 = e3.length;
+        let h3, c3, {
+            start: u3,
+            end: d3,
+            loop: f3
+        } = t4;
+        if (f3) {
+            for (u3 += l3, d3 += l3, h3 = 0, c3 = l3; h3 < c3 && o3(a3(e3[u3 % l3][s3]), n3, r3); ++h3)
+                u3--, d3--;
+            u3 %= l3, d3 %= l3;
+        }
+        return d3 < u3 && (d3 += l3), {
+            start: u3,
+            end: d3,
+            loop: f3,
+            style: t4.style
+        };
+    }(t3, e2, i2), p2 = [];
+    let m2, g2, y2, v2 = false,
+        b2 = null;
+    const _2 = () => v2 || l2(n2, y2, m2) && 0 !== a2(n2, y2),
+        w2 = () => !v2 || 0 === a2(r2, m2) || l2(r2, y2, m2);
+    for (let t4 = c2, i3 = c2; t4 <= u2; ++t4)
+        g2 = e2[t4 % o2], g2.skip || (m2 = h2(g2[s2]), m2 !== y2 && (v2 = l2(m2, n2, r2), null === b2 && _2() && (b2 = 0 === a2(m2, n2) ? t4 : i3), null !== b2 && w2() && (p2.push(Ir({
+            start: b2,
+            end: t4,
+            loop: d2,
+            count: o2,
+            style: f2
+        })), b2 = null), i3 = t4, y2 = m2));
+    return null !== b2 && p2.push(Ir({
+        start: b2,
+        end: u2,
+        loop: d2,
+        count: o2,
+        style: f2
+    })), p2;
+}
+
+function Pr(t3, e2, i2, s2) {
+    return s2 && s2.setContext && i2 ? function(t4, e3, i3, s3) {
+        const n2 = t4._chart.getContext(),
+            r2 = Rr(t4.options),
+            {
+                _datasetIndex: o2,
+                options: {
+                    spanGaps: a2
+                }
+            } = t4,
+            l2 = i3.length,
+            h2 = [];
+        let c2 = r2,
+            u2 = e3[0].start,
+            d2 = u2;
+
+        function f2(t5, e4, s4, n3) {
+            const r3 = a2 ? -1 : 1;
+            if (t5 !== e4) {
+                for (t5 += l2; i3[t5 % l2].skip;)
+                    t5 -= r3;
+                for (; i3[e4 % l2].skip;)
+                    e4 += r3;
+                t5 % l2 != e4 % l2 && (h2.push({
+                    start: t5 % l2,
+                    end: e4 % l2,
+                    loop: s4,
+                    style: n3
+                }), c2 = n3, u2 = e4 % l2);
+            }
+        }
+        for (const t5 of e3) {
+            u2 = a2 ? u2 : t5.start;
+            let e4, r3 = i3[u2 % l2];
+            for (d2 = u2 + 1; d2 <= t5.end; d2++) {
+                const a3 = i3[d2 % l2];
+                e4 = Rr(s3.setContext($n(n2, {
+                    type: "segment",
+                    p0: r3,
+                    p1: a3,
+                    p0DataIndex: (d2 - 1) % l2,
+                    p1DataIndex: d2 % l2,
+                    datasetIndex: o2
+                }))), Ar(e4, c2) && f2(u2, d2 - 1, t5.loop, c2), r3 = a3, c2 = e4;
+            }
+            u2 < d2 - 1 && f2(u2, d2 - 1, t5.loop, c2);
+        }
+        return h2;
+    }(t3, e2, i2, s2) : e2;
+}
+
+function Rr(t3) {
+    return {
+        backgroundColor: t3.backgroundColor,
+        borderCapStyle: t3.borderCapStyle,
+        borderDash: t3.borderDash,
+        borderDashOffset: t3.borderDashOffset,
+        borderJoinStyle: t3.borderJoinStyle,
+        borderWidth: t3.borderWidth,
+        borderColor: t3.borderColor
+    };
+}
+
+function Ar(t3, e2) {
+    if (!e2)
+        return false;
+    const i2 = [],
+        s2 = function(t4, e3) {
+            return Ls(e3) ? (i2.includes(e3) || i2.push(e3), i2.indexOf(e3)) : e3;
+        };
+    return JSON.stringify(t3, s2) !== JSON.stringify(e2, s2);
+}
+class Animator {
+    constructor() {
+        this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = false, this._lastDate = void 0;
+    }
+    _notify(t3, e2, i2, s2) {
+        const n2 = e2.listeners[s2],
+            r2 = e2.duration;
+        n2.forEach((s3) => s3({
+            chart: t3,
+            initial: e2.initial,
+            numSteps: r2,
+            currentStep: Math.min(i2 - e2.start, r2)
+        }));
+    }
+    _refresh() {
+        this._request || (this._running = true, this._request = Cs.call(window, () => {
+            this._update(), this._request = null, this._running && this._refresh();
+        }));
+    }
+    _update(t3 = Date.now()) {
+        let e2 = 0;
+        this._charts.forEach((i2, s2) => {
+            if (!i2.running || !i2.items.length)
+                return;
+            const n2 = i2.items;
+            let r2, o2 = n2.length - 1,
+                a2 = false;
+            for (; o2 >= 0; --o2)
+                r2 = n2[o2], r2._active ? (r2._total > i2.duration && (i2.duration = r2._total), r2.tick(t3), a2 = true) : (n2[o2] = n2[n2.length - 1], n2.pop());
+            a2 && (s2.draw(), this._notify(s2, i2, t3, "progress")), n2.length || (i2.running = false, this._notify(s2, i2, t3, "complete"), i2.initial = false), e2 += n2.length;
+        }), this._lastDate = t3, 0 === e2 && (this._running = false);
+    }
+    _getAnims(t3) {
+        const e2 = this._charts;
+        let i2 = e2.get(t3);
+        return i2 || (i2 = {
+            running: false,
+            initial: true,
+            items: [],
+            listeners: {
+                complete: [],
+                progress: []
+            }
+        }, e2.set(t3, i2)), i2;
+    }
+    listen(t3, e2, i2) {
+        this._getAnims(t3).listeners[e2].push(i2);
+    }
+    add(t3, e2) {
+        e2 && e2.length && this._getAnims(t3).items.push(...e2);
+    }
+    has(t3) {
+        return this._getAnims(t3).items.length > 0;
+    }
+    start(t3) {
+        const e2 = this._charts.get(t3);
+        e2 && (e2.running = true, e2.start = Date.now(), e2.duration = e2.items.reduce((t4, e3) => Math.max(t4, e3._duration), 0), this._refresh());
+    }
+    running(t3) {
+        if (!this._running)
+            return false;
+        const e2 = this._charts.get(t3);
+        return !!(e2 && e2.running && e2.items.length);
+    }
+    stop(t3) {
+        const e2 = this._charts.get(t3);
+        if (!e2 || !e2.items.length)
+            return;
+        const i2 = e2.items;
+        let s2 = i2.length - 1;
+        for (; s2 >= 0; --s2)
+            i2[s2].cancel();
+        e2.items = [], this._notify(t3, e2, Date.now(), "complete");
+    }
+    remove(t3) {
+        return this._charts.delete(t3);
+    }
+}
+var Dr = new Animator();
+const Lr = "transparent",
+    Or = {
+        boolean: (t3, e2, i2) => i2 > 0.5 ? e2 : t3,
+        color(t3, e2, i2) {
+            const s2 = Os(t3 || Lr),
+                n2 = s2.valid && Os(e2 || Lr);
+            return n2 && n2.valid ? n2.mix(s2, i2).hexString() : e2;
+        },
+        number: (t3, e2, i2) => t3 + (e2 - t3) * i2
+    };
+class Animation {
+    constructor(t3, e2, i2, s2) {
+        const n2 = e2[i2];
+        s2 = Fn([t3.to, s2, n2, t3.from]);
+        const r2 = Fn([t3.from, n2, s2]);
+        this._active = true, this._fn = t3.fn || Or[t3.type || typeof r2], this._easing = Ds[t3.easing] || Ds.linear, this._start = Math.floor(Date.now() + (t3.delay || 0)), this._duration = this._total = Math.floor(t3.duration), this._loop = !!t3.loop, this._target = e2, this._prop = i2, this._from = r2, this._to = s2, this._promises = void 0;
+    }
+    active() {
+        return this._active;
+    }
+    update(t3, e2, i2) {
+        if (this._active) {
+            this._notify(false);
+            const s2 = this._target[this._prop],
+                n2 = i2 - this._start,
+                r2 = this._duration - n2;
+            this._start = i2, this._duration = Math.floor(Math.max(r2, t3.duration)), this._total += n2, this._loop = !!t3.loop, this._to = Fn([t3.to, e2, s2, t3.from]), this._from = Fn([t3.from, s2, e2]);
+        }
+    }
+    cancel() {
+        this._active && (this.tick(Date.now()), this._active = false, this._notify(false));
+    }
+    tick(t3) {
+        const e2 = t3 - this._start,
+            i2 = this._duration,
+            s2 = this._prop,
+            n2 = this._from,
+            r2 = this._loop,
+            o2 = this._to;
+        let a2;
+        if (this._active = n2 !== o2 && (r2 || e2 < i2), !this._active)
+            return this._target[s2] = o2, void this._notify(true);
+        e2 < 0 ? this._target[s2] = n2 : (a2 = e2 / i2 % 2, a2 = r2 && a2 > 1 ? 2 - a2 : a2, a2 = this._easing(Math.min(1, Math.max(0, a2))), this._target[s2] = this._fn(n2, o2, a2));
+    }
+    wait() {
+        const t3 = this._promises || (this._promises = []);
+        return new Promise((e2, i2) => {
+            t3.push({
+                res: e2,
+                rej: i2
+            });
+        });
+    }
+    _notify(t3) {
+        const e2 = t3 ? "res" : "rej",
+            i2 = this._promises || [];
+        for (let t4 = 0; t4 < i2.length; t4++)
+            i2[t4][e2]();
+    }
+}
+class Animations {
+    constructor(t3, e2) {
+        this._chart = t3, this._properties = /* @__PURE__ */ new Map(), this.configure(e2);
+    }
+    configure(t3) {
+        if (!yi(t3))
+            return;
+        const e2 = Object.keys(Js.animation),
+            i2 = this._properties;
+        Object.getOwnPropertyNames(t3).forEach((s2) => {
+            const n2 = t3[s2];
+            if (!yi(n2))
+                return;
+            const r2 = {};
+            for (const t4 of e2)
+                r2[t4] = n2[t4];
+            (ui(n2.properties) && n2.properties || [s2]).forEach((t4) => {
+                t4 !== s2 && i2.has(t4) || i2.set(t4, r2);
+            });
+        });
+    }
+    _animateOptions(t3, e2) {
+        const i2 = e2.options,
+            s2 = function(t4, e3) {
+                if (!e3)
+                    return;
+                let i3 = t4.options;
+                if (!i3)
+                    return void(t4.options = e3);
+                i3.$shared && (t4.options = i3 = Object.assign({}, i3, {
+                    $shared: false,
+                    $animations: {}
+                }));
+                return i3;
+            }(t3, i2);
+        if (!s2)
+            return [];
+        const n2 = this._createAnimations(s2, i2);
+        return i2.$shared && function(t4, e3) {
+            const i3 = [],
+                s3 = Object.keys(e3);
+            for (let e4 = 0; e4 < s3.length; e4++) {
+                const n3 = t4[s3[e4]];
+                n3 && n3.active() && i3.push(n3.wait());
+            }
+            return Promise.all(i3);
+        }(t3.options.$animations, i2).then(() => {
+            t3.options = i2;
+        }, () => {}), n2;
+    }
+    _createAnimations(t3, e2) {
+        const i2 = this._properties,
+            s2 = [],
+            n2 = t3.$animations || (t3.$animations = {}),
+            r2 = Object.keys(e2),
+            o2 = Date.now();
+        let a2;
+        for (a2 = r2.length - 1; a2 >= 0; --a2) {
+            const l2 = r2[a2];
+            if ("$" === l2.charAt(0))
+                continue;
+            if ("options" === l2) {
+                s2.push(...this._animateOptions(t3, e2));
+                continue;
+            }
+            const h2 = e2[l2];
+            let c2 = n2[l2];
+            const u2 = i2.get(l2);
+            if (c2) {
+                if (u2 && c2.active()) {
+                    c2.update(u2, h2, o2);
+                    continue;
+                }
+                c2.cancel();
+            }
+            u2 && u2.duration ? (n2[l2] = c2 = new Animation(u2, t3, l2, h2), s2.push(c2)) : t3[l2] = h2;
+        }
+        return s2;
+    }
+    update(t3, e2) {
+        if (0 === this._properties.size)
+            return void Object.assign(t3, e2);
+        const i2 = this._createAnimations(t3, e2);
+        return i2.length ? (Dr.add(this._chart, i2), true) : void 0;
+    }
+}
+
+function Fr(t3, e2) {
+    const i2 = t3 && t3.options || {},
+        s2 = i2.reverse,
+        n2 = void 0 === i2.min ? e2 : 0,
+        r2 = void 0 === i2.max ? e2 : 0;
+    return {
+        start: s2 ? r2 : n2,
+        end: s2 ? n2 : r2
+    };
+}
+
+function Nr(t3, e2) {
+    const i2 = [],
+        s2 = t3._getSortedDatasetMetas(e2);
+    let n2, r2;
+    for (n2 = 0, r2 = s2.length; n2 < r2; ++n2)
+        i2.push(s2[n2].index);
+    return i2;
+}
+
+function $r(t3, e2, i2, s2 = {}) {
+    const n2 = t3.keys,
+        r2 = "single" === s2.mode;
+    let o2, a2, l2, h2;
+    if (null !== e2) {
+        for (o2 = 0, a2 = n2.length; o2 < a2; ++o2) {
+            if (l2 = +n2[o2], l2 === i2) {
+                if (s2.all)
+                    continue;
+                break;
+            }
+            h2 = t3.values[l2], _i(h2) && (r2 || 0 === e2 || os(e2) === os(h2)) && (e2 += h2);
+        }
+        return e2;
+    }
+}
+
+function Vr(t3, e2) {
+    const i2 = t3 && t3.options.stacked;
+    return i2 || void 0 === i2 && void 0 !== e2.stack;
+}
+
+function zr(t3, e2, i2) {
+    const s2 = t3[e2] || (t3[e2] = {});
+    return s2[i2] || (s2[i2] = {});
+}
+
+function Br(t3, e2, i2, s2) {
+    for (const n2 of e2.getMatchingVisibleMetas(s2).reverse()) {
+        const e3 = t3[n2.index];
+        if (i2 && e3 > 0 || !i2 && e3 < 0)
+            return n2.index;
+    }
+    return null;
+}
+
+function Ur(t3, e2) {
+    const {
+        chart: i2,
+        _cachedMeta: s2
+    } = t3, n2 = i2._stacks || (i2._stacks = {}), {
+        iScale: r2,
+        vScale: o2,
+        index: a2
+    } = s2, l2 = r2.axis, h2 = o2.axis, c2 = function(t4, e3, i3) {
+        return `${t4.id}.${e3.id}.${i3.stack || i3.type}`;
+    }(r2, o2, s2), u2 = e2.length;
+    let d2;
+    for (let t4 = 0; t4 < u2; ++t4) {
+        const i3 = e2[t4],
+            {
+                [l2]: r3,
+                [h2]: u3
+            } = i3;
+        d2 = (i3._stacks || (i3._stacks = {}))[h2] = zr(n2, c2, r3), d2[a2] = u3, d2._top = Br(d2, o2, true, s2.type), d2._bottom = Br(d2, o2, false, s2.type);
+        (d2._visualValues || (d2._visualValues = {}))[a2] = u3;
+    }
+}
+
+function jr(t3, e2) {
+    const i2 = t3.scales;
+    return Object.keys(i2).filter((t4) => i2[t4].axis === e2).shift();
+}
+
+function Hr(t3, e2) {
+    const i2 = t3.controller.index,
+        s2 = t3.vScale && t3.vScale.axis;
+    if (s2) {
+        e2 = e2 || t3._parsed;
+        for (const t4 of e2) {
+            const e3 = t4._stacks;
+            if (!e3 || void 0 === e3[s2] || void 0 === e3[s2][i2])
+                return;
+            delete e3[s2][i2], void 0 !== e3[s2]._visualValues && void 0 !== e3[s2]._visualValues[i2] && delete e3[s2]._visualValues[i2];
+        }
+    }
+}
+const Wr = (t3) => "reset" === t3 || "none" === t3,
+    qr = (t3, e2) => e2 ? t3 : Object.assign({}, t3);
+class DatasetController {
+    constructor(t3, e2) {
+        this.chart = t3, this._ctx = t3.ctx, this.index = e2, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = false, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = false, this.supportsDecimation = false, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();
+    }
+    initialize() {
+        const t3 = this._cachedMeta;
+        this.configure(), this.linkScales(), t3._stacked = Vr(t3.vScale, t3), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
+    }
+    updateIndex(t3) {
+        this.index !== t3 && Hr(this._cachedMeta), this.index = t3;
+    }
+    linkScales() {
+        const t3 = this.chart,
+            e2 = this._cachedMeta,
+            i2 = this.getDataset(),
+            s2 = (t4, e3, i3, s3) => "x" === t4 ? e3 : "r" === t4 ? s3 : i3,
+            n2 = e2.xAxisID = Ti(i2.xAxisID, jr(t3, "x")),
+            r2 = e2.yAxisID = Ti(i2.yAxisID, jr(t3, "y")),
+            o2 = e2.rAxisID = Ti(i2.rAxisID, jr(t3, "r")),
+            a2 = e2.indexAxis,
+            l2 = e2.iAxisID = s2(a2, n2, r2, o2),
+            h2 = e2.vAxisID = s2(a2, r2, n2, o2);
+        e2.xScale = this.getScaleForId(n2), e2.yScale = this.getScaleForId(r2), e2.rScale = this.getScaleForId(o2), e2.iScale = this.getScaleForId(l2), e2.vScale = this.getScaleForId(h2);
+    }
+    getDataset() {
+        return this.chart.data.datasets[this.index];
+    }
+    getMeta() {
+        return this.chart.getDatasetMeta(this.index);
+    }
+    getScaleForId(t3) {
+        return this.chart.scales[t3];
+    }
+    _getOtherScale(t3) {
+        const e2 = this._cachedMeta;
+        return t3 === e2.iScale ? e2.vScale : e2.iScale;
+    }
+    reset() {
+        this._update("reset");
+    }
+    _destroy() {
+        const t3 = this._cachedMeta;
+        this._data && Ts(this._data, this), t3._stacked && Hr(t3);
+    }
+    _dataCheck() {
+        const t3 = this.getDataset(),
+            e2 = t3.data || (t3.data = []),
+            i2 = this._data;
+        if (yi(e2))
+            this._data = function(t4) {
+                const e3 = Object.keys(t4),
+                    i3 = new Array(e3.length);
+                let s3, n3, r2;
+                for (s3 = 0, n3 = e3.length; s3 < n3; ++s3)
+                    r2 = e3[s3], i3[s3] = {
+                        x: r2,
+                        y: t4[r2]
+                    };
+                return i3;
+            }(e2);
+        else if (i2 !== e2) {
+            if (i2) {
+                Ts(i2, this);
+                const t4 = this._cachedMeta;
+                Hr(t4), t4._parsed = [];
+            }
+            e2 && Object.isExtensible(e2) && (n2 = this, (s2 = e2)._chartjs ? s2._chartjs.listeners.push(n2) : (Object.defineProperty(s2, "_chartjs", {
+                configurable: true,
+                enumerable: false,
+                value: {
+                    listeners: [n2]
+                }
+            }), ks.forEach((t4) => {
+                const e3 = "_onData" + Wi(t4),
+                    i3 = s2[t4];
+                Object.defineProperty(s2, t4, {
+                    configurable: true,
+                    enumerable: false,
+                    value(...t5) {
+                        const n3 = i3.apply(this, t5);
+                        return s2._chartjs.listeners.forEach((i4) => {
+                            "function" == typeof i4[e3] && i4[e3](...t5);
+                        }), n3;
+                    }
+                });
+            }))), this._syncList = [], this._data = e2;
+        }
+        var s2, n2;
+    }
+    addElements() {
+        const t3 = this._cachedMeta;
+        this._dataCheck(), this.datasetElementType && (t3.dataset = new this.datasetElementType());
+    }
+    buildOrUpdateElements(t3) {
+        const e2 = this._cachedMeta,
+            i2 = this.getDataset();
+        let s2 = false;
+        this._dataCheck();
+        const n2 = e2._stacked;
+        e2._stacked = Vr(e2.vScale, e2), e2.stack !== i2.stack && (s2 = true, Hr(e2), e2.stack = i2.stack), this._resyncElements(t3), (s2 || n2 !== e2._stacked) && Ur(this, e2._parsed);
+    }
+    configure() {
+        const t3 = this.chart.config,
+            e2 = t3.datasetScopeKeys(this._type),
+            i2 = t3.getOptionScopes(this.getDataset(), e2, true);
+        this.options = t3.createResolver(i2, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
+    }
+    parse(t3, e2) {
+        const {
+            _cachedMeta: i2,
+            _data: s2
+        } = this, {
+            iScale: n2,
+            _stacked: r2
+        } = i2, o2 = n2.axis;
+        let a2, l2, h2, c2 = 0 === t3 && e2 === s2.length || i2._sorted,
+            u2 = t3 > 0 && i2._parsed[t3 - 1];
+        if (false === this._parsing)
+            i2._parsed = s2, i2._sorted = true, h2 = s2;
+        else {
+            h2 = ui(s2[t3]) ? this.parseArrayData(i2, s2, t3, e2) : yi(s2[t3]) ? this.parseObjectData(i2, s2, t3, e2) : this.parsePrimitiveData(i2, s2, t3, e2);
+            const n3 = () => null === l2[o2] || u2 && l2[o2] < u2[o2];
+            for (a2 = 0; a2 < e2; ++a2)
+                i2._parsed[a2 + t3] = l2 = h2[a2], c2 && (n3() && (c2 = false), u2 = l2);
+            i2._sorted = c2;
+        }
+        r2 && Ur(this, h2);
+    }
+    parsePrimitiveData(t3, e2, i2, s2) {
+        const {
+            iScale: n2,
+            vScale: r2
+        } = t3, o2 = n2.axis, a2 = r2.axis, l2 = n2.getLabels(), h2 = n2 === r2, c2 = new Array(s2);
+        let u2, d2, f2;
+        for (u2 = 0, d2 = s2; u2 < d2; ++u2)
+            f2 = u2 + i2, c2[u2] = {
+                [o2]: h2 || n2.parse(l2[f2], f2),
+                [a2]: r2.parse(e2[f2], f2)
+            };
+        return c2;
+    }
+    parseArrayData(t3, e2, i2, s2) {
+        const {
+            xScale: n2,
+            yScale: r2
+        } = t3, o2 = new Array(s2);
+        let a2, l2, h2, c2;
+        for (a2 = 0, l2 = s2; a2 < l2; ++a2)
+            h2 = a2 + i2, c2 = e2[h2], o2[a2] = {
+                x: n2.parse(c2[0], h2),
+                y: r2.parse(c2[1], h2)
+            };
+        return o2;
+    }
+    parseObjectData(t3, e2, i2, s2) {
+        const {
+            xScale: n2,
+            yScale: r2
+        } = t3, {
+            xAxisKey: o2 = "x",
+            yAxisKey: a2 = "y"
+        } = this._parsing, l2 = new Array(s2);
+        let h2, c2, u2, d2;
+        for (h2 = 0, c2 = s2; h2 < c2; ++h2)
+            u2 = h2 + i2, d2 = e2[u2], l2[h2] = {
+                x: n2.parse(ji(d2, o2), u2),
+                y: r2.parse(ji(d2, a2), u2)
+            };
+        return l2;
+    }
+    getParsed(t3) {
+        return this._cachedMeta._parsed[t3];
+    }
+    getDataElement(t3) {
+        return this._cachedMeta.data[t3];
+    }
+    applyStack(t3, e2, i2) {
+        const s2 = this.chart,
+            n2 = this._cachedMeta,
+            r2 = e2[t3.axis];
+        return $r({
+            keys: Nr(s2, true),
+            values: e2._stacks[t3.axis]._visualValues
+        }, r2, n2.index, {
+            mode: i2
+        });
+    }
+    updateRangeFromParsed(t3, e2, i2, s2) {
+        const n2 = i2[e2.axis];
+        let r2 = null === n2 ? NaN : n2;
+        const o2 = s2 && i2._stacks[e2.axis];
+        s2 && o2 && (s2.values = o2, r2 = $r(s2, n2, this._cachedMeta.index)), t3.min = Math.min(t3.min, r2), t3.max = Math.max(t3.max, r2);
+    }
+    getMinMax(t3, e2) {
+        const i2 = this._cachedMeta,
+            s2 = i2._parsed,
+            n2 = i2._sorted && t3 === i2.iScale,
+            r2 = s2.length,
+            o2 = this._getOtherScale(t3),
+            a2 = ((t4, e3, i3) => t4 && !e3.hidden && e3._stacked && {
+                keys: Nr(i3, true),
+                values: null
+            })(e2, i2, this.chart),
+            l2 = {
+                min: Number.POSITIVE_INFINITY,
+                max: Number.NEGATIVE_INFINITY
+            },
+            {
+                min: h2,
+                max: c2
+            } = function(t4) {
+                const {
+                    min: e3,
+                    max: i3,
+                    minDefined: s3,
+                    maxDefined: n3
+                } = t4.getUserBounds();
+                return {
+                    min: s3 ? e3 : Number.NEGATIVE_INFINITY,
+                    max: n3 ? i3 : Number.POSITIVE_INFINITY
+                };
+            }(o2);
+        let u2, d2;
+
+        function f2() {
+            d2 = s2[u2];
+            const e3 = d2[o2.axis];
+            return !_i(d2[t3.axis]) || h2 > e3 || c2 < e3;
+        }
+        for (u2 = 0; u2 < r2 && (f2() || (this.updateRangeFromParsed(l2, t3, d2, a2), !n2)); ++u2)
+        ;
+        if (n2) {
+            for (u2 = r2 - 1; u2 >= 0; --u2)
+                if (!f2()) {
+                    this.updateRangeFromParsed(l2, t3, d2, a2);
+                    break;
+                }
+        }
+        return l2;
+    }
+    getAllParsedValues(t3) {
+        const e2 = this._cachedMeta._parsed,
+            i2 = [];
+        let s2, n2, r2;
+        for (s2 = 0, n2 = e2.length; s2 < n2; ++s2)
+            r2 = e2[s2][t3.axis], _i(r2) && i2.push(r2);
+        return i2;
+    }
+    getMaxOverflow() {
+        return false;
+    }
+    getLabelAndValue(t3) {
+        const e2 = this._cachedMeta,
+            i2 = e2.iScale,
+            s2 = e2.vScale,
+            n2 = this.getParsed(t3);
+        return {
+            label: i2 ? "" + i2.getLabelForValue(n2[i2.axis]) : "",
+            value: s2 ? "" + s2.getLabelForValue(n2[s2.axis]) : ""
+        };
+    }
+    _update(t3) {
+        const e2 = this._cachedMeta;
+        this.update(t3 || "default"), e2._clip = function(t4) {
+            let e3, i2, s2, n2;
+            return yi(t4) ? (e3 = t4.top, i2 = t4.right, s2 = t4.bottom, n2 = t4.left) : e3 = i2 = s2 = n2 = t4, {
+                top: e3,
+                right: i2,
+                bottom: s2,
+                left: n2,
+                disabled: false === t4
+            };
+        }(Ti(this.options.clip, function(t4, e3, i2) {
+            if (false === i2)
+                return false;
+            const s2 = Fr(t4, i2),
+                n2 = Fr(e3, i2);
+            return {
+                top: n2.end,
+                right: s2.end,
+                bottom: n2.start,
+                left: s2.start
+            };
+        }(e2.xScale, e2.yScale, this.getMaxOverflow())));
+    }
+    update(t3) {}
+    draw() {
+        const t3 = this._ctx,
+            e2 = this.chart,
+            i2 = this._cachedMeta,
+            s2 = i2.data || [],
+            n2 = e2.chartArea,
+            r2 = [],
+            o2 = this._drawStart || 0,
+            a2 = this._drawCount || s2.length - o2,
+            l2 = this.options.drawActiveElementsOnTop;
+        let h2;
+        for (i2.dataset && i2.dataset.draw(t3, n2, o2, a2), h2 = o2; h2 < o2 + a2; ++h2) {
+            const e3 = s2[h2];
+            e3.hidden || (e3.active && l2 ? r2.push(e3) : e3.draw(t3, n2));
+        }
+        for (h2 = 0; h2 < r2.length; ++h2)
+            r2[h2].draw(t3, n2);
+    }
+    getStyle(t3, e2) {
+        const i2 = e2 ? "active" : "default";
+        return void 0 === t3 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(i2) : this.resolveDataElementOptions(t3 || 0, i2);
+    }
+    getContext(t3, e2, i2) {
+        const s2 = this.getDataset();
+        let n2;
+        if (t3 >= 0 && t3 < this._cachedMeta.data.length) {
+            const e3 = this._cachedMeta.data[t3];
+            n2 = e3.$context || (e3.$context = function(t4, e4, i3) {
+                return $n(t4, {
+                    active: false,
+                    dataIndex: e4,
+                    parsed: void 0,
+                    raw: void 0,
+                    element: i3,
+                    index: e4,
+                    mode: "default",
+                    type: "data"
+                });
+            }(this.getContext(), t3, e3)), n2.parsed = this.getParsed(t3), n2.raw = s2.data[t3], n2.index = n2.dataIndex = t3;
+        } else
+            n2 = this.$context || (this.$context = function(t4, e3) {
+                return $n(t4, {
+                    active: false,
+                    dataset: void 0,
+                    datasetIndex: e3,
+                    index: e3,
+                    mode: "default",
+                    type: "dataset"
+                });
+            }(this.chart.getContext(), this.index)), n2.dataset = s2, n2.index = n2.datasetIndex = this.index;
+        return n2.active = !!e2, n2.mode = i2, n2;
+    }
+    resolveDatasetElementOptions(t3) {
+        return this._resolveElementOptions(this.datasetElementType.id, t3);
+    }
+    resolveDataElementOptions(t3, e2) {
+        return this._resolveElementOptions(this.dataElementType.id, e2, t3);
+    }
+    _resolveElementOptions(t3, e2 = "default", i2) {
+        const s2 = "active" === e2,
+            n2 = this._cachedDataOpts,
+            r2 = t3 + "-" + e2,
+            o2 = n2[r2],
+            a2 = this.enableOptionSharing && qi(i2);
+        if (o2)
+            return qr(o2, a2);
+        const l2 = this.chart.config,
+            h2 = l2.datasetElementScopeKeys(this._type, t3),
+            c2 = s2 ? [`${t3}Hover`, "hover", t3, ""] : [t3, ""],
+            u2 = l2.getOptionScopes(this.getDataset(), h2),
+            d2 = Object.keys(Js.elements[t3]),
+            f2 = l2.resolveNamedOptions(u2, d2, () => this.getContext(i2, s2, e2), c2);
+        return f2.$shared && (f2.$shared = a2, n2[r2] = Object.freeze(qr(f2, a2))), f2;
+    }
+    _resolveAnimations(t3, e2, i2) {
+        const s2 = this.chart,
+            n2 = this._cachedDataOpts,
+            r2 = `animation-${e2}`,
+            o2 = n2[r2];
+        if (o2)
+            return o2;
+        let a2;
+        if (false !== s2.options.animation) {
+            const s3 = this.chart.config,
+                n3 = s3.datasetAnimationScopeKeys(this._type, e2),
+                r3 = s3.getOptionScopes(this.getDataset(), n3);
+            a2 = s3.createResolver(r3, this.getContext(t3, i2, e2));
+        }
+        const l2 = new Animations(s2, a2 && a2.animations);
+        return a2 && a2._cacheable && (n2[r2] = Object.freeze(l2)), l2;
+    }
+    getSharedOptions(t3) {
+        if (t3.$shared)
+            return this._sharedOptions || (this._sharedOptions = Object.assign({}, t3));
+    }
+    includeOptions(t3, e2) {
+        return !e2 || Wr(t3) || this.chart._animationsDisabled;
+    }
+    _getSharedOptions(t3, e2) {
+        const i2 = this.resolveDataElementOptions(t3, e2),
+            s2 = this._sharedOptions,
+            n2 = this.getSharedOptions(i2),
+            r2 = this.includeOptions(e2, n2) || n2 !== s2;
+        return this.updateSharedOptions(n2, e2, i2), {
+            sharedOptions: n2,
+            includeOptions: r2
+        };
+    }
+    updateElement(t3, e2, i2, s2) {
+        Wr(s2) ? Object.assign(t3, i2) : this._resolveAnimations(e2, s2).update(t3, i2);
+    }
+    updateSharedOptions(t3, e2, i2) {
+        t3 && !Wr(e2) && this._resolveAnimations(void 0, e2).update(t3, i2);
+    }
+    _setStyle(t3, e2, i2, s2) {
+        t3.active = s2;
+        const n2 = this.getStyle(e2, s2);
+        this._resolveAnimations(e2, i2, s2).update(t3, {
+            options: !s2 && this.getSharedOptions(n2) || n2
+        });
+    }
+    removeHoverStyle(t3, e2, i2) {
+        this._setStyle(t3, i2, "active", false);
+    }
+    setHoverStyle(t3, e2, i2) {
+        this._setStyle(t3, i2, "active", true);
+    }
+    _removeDatasetHoverStyle() {
+        const t3 = this._cachedMeta.dataset;
+        t3 && this._setStyle(t3, void 0, "active", false);
+    }
+    _setDatasetHoverStyle() {
+        const t3 = this._cachedMeta.dataset;
+        t3 && this._setStyle(t3, void 0, "active", true);
+    }
+    _resyncElements(t3) {
+        const e2 = this._data,
+            i2 = this._cachedMeta.data;
+        for (const [t4, e3, i3] of this._syncList)
+            this[t4](e3, i3);
+        this._syncList = [];
+        const s2 = i2.length,
+            n2 = e2.length,
+            r2 = Math.min(n2, s2);
+        r2 && this.parse(0, r2), n2 > s2 ? this._insertElements(s2, n2 - s2, t3) : n2 < s2 && this._removeElements(n2, s2 - n2);
+    }
+    _insertElements(t3, e2, i2 = true) {
+        const s2 = this._cachedMeta,
+            n2 = s2.data,
+            r2 = t3 + e2;
+        let o2;
+        const a2 = (t4) => {
+            for (t4.length += e2, o2 = t4.length - 1; o2 >= r2; o2--)
+                t4[o2] = t4[o2 - e2];
+        };
+        for (a2(n2), o2 = t3; o2 < r2; ++o2)
+            n2[o2] = new this.dataElementType();
+        this._parsing && a2(s2._parsed), this.parse(t3, e2), i2 && this.updateElements(n2, t3, e2, "reset");
+    }
+    updateElements(t3, e2, i2, s2) {}
+    _removeElements(t3, e2) {
+        const i2 = this._cachedMeta;
+        if (this._parsing) {
+            const s2 = i2._parsed.splice(t3, e2);
+            i2._stacked && Hr(i2, s2);
+        }
+        i2.data.splice(t3, e2);
+    }
+    _sync(t3) {
+        if (this._parsing)
+            this._syncList.push(t3);
+        else {
+            const [e2, i2, s2] = t3;
+            this[e2](i2, s2);
+        }
+        this.chart._dataChanges.push([this.index, ...t3]);
+    }
+    _onDataPush() {
+        const t3 = arguments.length;
+        this._sync(["_insertElements", this.getDataset().data.length - t3, t3]);
+    }
+    _onDataPop() {
+        this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]);
+    }
+    _onDataShift() {
+        this._sync(["_removeElements", 0, 1]);
+    }
+    _onDataSplice(t3, e2) {
+        e2 && this._sync(["_removeElements", t3, e2]);
+        const i2 = arguments.length - 2;
+        i2 && this._sync(["_insertElements", t3, i2]);
+    }
+    _onDataUnshift() {
+        this._sync(["_insertElements", 0, arguments.length]);
+    }
+}
+__publicField(DatasetController, "defaults", {});
+__publicField(DatasetController, "datasetElementType", null);
+__publicField(DatasetController, "dataElementType", null);
+
+function Kr(t3) {
+    const e2 = t3.iScale,
+        i2 = function(t4, e3) {
+            if (!t4._cache.$bar) {
+                const i3 = t4.getMatchingVisibleMetas(e3);
+                let s3 = [];
+                for (let e4 = 0, n3 = i3.length; e4 < n3; e4++)
+                    s3 = s3.concat(i3[e4].controller.getAllParsedValues(t4));
+                t4._cache.$bar = Es(s3.sort((t5, e4) => t5 - e4));
+            }
+            return t4._cache.$bar;
+        }(e2, t3.type);
+    let s2, n2, r2, o2, a2 = e2._length;
+    const l2 = () => {
+        32767 !== r2 && -32768 !== r2 && (qi(o2) && (a2 = Math.min(a2, Math.abs(r2 - o2) || a2)), o2 = r2);
+    };
+    for (s2 = 0, n2 = i2.length; s2 < n2; ++s2)
+        r2 = e2.getPixelForValue(i2[s2]), l2();
+    for (o2 = void 0, s2 = 0, n2 = e2.ticks.length; s2 < n2; ++s2)
+        r2 = e2.getPixelForTick(s2), l2();
+    return a2;
+}
+
+function Gr(t3, e2, i2, s2) {
+    return ui(t3) ? function(t4, e3, i3, s3) {
+        const n2 = i3.parse(t4[0], s3),
+            r2 = i3.parse(t4[1], s3),
+            o2 = Math.min(n2, r2),
+            a2 = Math.max(n2, r2);
+        let l2 = o2,
+            h2 = a2;
+        Math.abs(o2) > Math.abs(a2) && (l2 = a2, h2 = o2), e3[i3.axis] = h2, e3._custom = {
+            barStart: l2,
+            barEnd: h2,
+            start: n2,
+            end: r2,
+            min: o2,
+            max: a2
+        };
+    }(t3, e2, i2, s2) : e2[i2.axis] = i2.parse(t3, s2), e2;
+}
+
+function Yr(t3, e2, i2, s2) {
+    const n2 = t3.iScale,
+        r2 = t3.vScale,
+        o2 = n2.getLabels(),
+        a2 = n2 === r2,
+        l2 = [];
+    let h2, c2, u2, d2;
+    for (h2 = i2, c2 = i2 + s2; h2 < c2; ++h2)
+        d2 = e2[h2], u2 = {}, u2[n2.axis] = a2 || n2.parse(o2[h2], h2), l2.push(Gr(d2, u2, r2, h2));
+    return l2;
+}
+
+function Qr(t3) {
+    return t3 && void 0 !== t3.barStart && void 0 !== t3.barEnd;
+}
+
+function Xr(t3, e2, i2, s2) {
+    let n2 = e2.borderSkipped;
+    const r2 = {};
+    if (!n2)
+        return void(t3.borderSkipped = r2);
+    if (true === n2)
+        return void(t3.borderSkipped = {
+            top: true,
+            right: true,
+            bottom: true,
+            left: true
+        });
+    const {
+        start: o2,
+        end: a2,
+        reverse: l2,
+        top: h2,
+        bottom: c2
+    } = function(t4) {
+        let e3, i3, s3, n3, r3;
+        return t4.horizontal ? (e3 = t4.base > t4.x, i3 = "left", s3 = "right") : (e3 = t4.base < t4.y, i3 = "bottom", s3 = "top"), e3 ? (n3 = "end", r3 = "start") : (n3 = "start", r3 = "end"), {
+            start: i3,
+            end: s3,
+            reverse: e3,
+            top: n3,
+            bottom: r3
+        };
+    }(t3);
+    "middle" === n2 && i2 && (t3.enableBorderRadius = true, (i2._top || 0) === s2 ? n2 = h2 : (i2._bottom || 0) === s2 ? n2 = c2 : (r2[Jr(c2, o2, a2, l2)] = true, n2 = h2)), r2[Jr(n2, o2, a2, l2)] = true, t3.borderSkipped = r2;
+}
+
+function Jr(t3, e2, i2, s2) {
+    var n2, r2, o2;
+    return s2 ? (o2 = i2, t3 = Zr(t3 = (n2 = t3) === (r2 = e2) ? o2 : n2 === o2 ? r2 : n2, i2, e2)) : t3 = Zr(t3, e2, i2), t3;
+}
+
+function Zr(t3, e2, i2) {
+    return "start" === t3 ? e2 : "end" === t3 ? i2 : t3;
+}
+
+function to(t3, {
+    inflateAmount: e2
+}, i2) {
+    t3.inflateAmount = "auto" === e2 ? 1 === i2 ? 0.33 : 0 : e2;
+}
+class BarController extends DatasetController {
+    parsePrimitiveData(t3, e2, i2, s2) {
+        return Yr(t3, e2, i2, s2);
+    }
+    parseArrayData(t3, e2, i2, s2) {
+        return Yr(t3, e2, i2, s2);
+    }
+    parseObjectData(t3, e2, i2, s2) {
+        const {
+            iScale: n2,
+            vScale: r2
+        } = t3, {
+            xAxisKey: o2 = "x",
+            yAxisKey: a2 = "y"
+        } = this._parsing, l2 = "x" === n2.axis ? o2 : a2, h2 = "x" === r2.axis ? o2 : a2, c2 = [];
+        let u2, d2, f2, p2;
+        for (u2 = i2, d2 = i2 + s2; u2 < d2; ++u2)
+            p2 = e2[u2], f2 = {}, f2[n2.axis] = n2.parse(ji(p2, l2), u2), c2.push(Gr(ji(p2, h2), f2, r2, u2));
+        return c2;
+    }
+    updateRangeFromParsed(t3, e2, i2, s2) {
+        super.updateRangeFromParsed(t3, e2, i2, s2);
+        const n2 = i2._custom;
+        n2 && e2 === this._cachedMeta.vScale && (t3.min = Math.min(t3.min, n2.min), t3.max = Math.max(t3.max, n2.max));
+    }
+    getMaxOverflow() {
+        return 0;
+    }
+    getLabelAndValue(t3) {
+        const e2 = this._cachedMeta,
+            {
+                iScale: i2,
+                vScale: s2
+            } = e2,
+            n2 = this.getParsed(t3),
+            r2 = n2._custom,
+            o2 = Qr(r2) ? "[" + r2.start + ", " + r2.end + "]" : "" + s2.getLabelForValue(n2[s2.axis]);
+        return {
+            label: "" + i2.getLabelForValue(n2[i2.axis]),
+            value: o2
+        };
+    }
+    initialize() {
+        this.enableOptionSharing = true, super.initialize();
+        this._cachedMeta.stack = this.getDataset().stack;
+    }
+    update(t3) {
+        const e2 = this._cachedMeta;
+        this.updateElements(e2.data, 0, e2.data.length, t3);
+    }
+    updateElements(t3, e2, i2, s2) {
+        const n2 = "reset" === s2,
+            {
+                index: r2,
+                _cachedMeta: {
+                    vScale: o2
+                }
+            } = this,
+            a2 = o2.getBasePixel(),
+            l2 = o2.isHorizontal(),
+            h2 = this._getRuler(),
+            {
+                sharedOptions: c2,
+                includeOptions: u2
+            } = this._getSharedOptions(e2, s2);
+        for (let d2 = e2; d2 < e2 + i2; d2++) {
+            const e3 = this.getParsed(d2),
+                i3 = n2 || ci(e3[o2.axis]) ? {
+                    base: a2,
+                    head: a2
+                } : this._calculateBarValuePixels(d2),
+                f2 = this._calculateBarIndexPixels(d2, h2),
+                p2 = (e3._stacks || {})[o2.axis],
+                m2 = {
+                    horizontal: l2,
+                    base: i3.base,
+                    enableBorderRadius: !p2 || Qr(e3._custom) || r2 === p2._top || r2 === p2._bottom,
+                    x: l2 ? i3.head : f2.center,
+                    y: l2 ? f2.center : i3.head,
+                    height: l2 ? f2.size : Math.abs(i3.size),
+                    width: l2 ? Math.abs(i3.size) : f2.size
+                };
+            u2 && (m2.options = c2 || this.resolveDataElementOptions(d2, t3[d2].active ? "active" : s2));
+            const g2 = m2.options || t3[d2].options;
+            Xr(m2, g2, p2, r2), to(m2, g2, h2.ratio), this.updateElement(t3[d2], d2, m2, s2);
+        }
+    }
+    _getStacks(t3, e2) {
+        const {
+            iScale: i2
+        } = this._cachedMeta, s2 = i2.getMatchingVisibleMetas(this._type).filter((t4) => t4.controller.options.grouped), n2 = i2.options.stacked, r2 = [], o2 = (t4) => {
+            const i3 = t4.controller.getParsed(e2),
+                s3 = i3 && i3[t4.vScale.axis];
+            if (ci(s3) || isNaN(s3))
+                return true;
+        };
+        for (const i3 of s2)
+            if ((void 0 === e2 || !o2(i3)) && ((false === n2 || -1 === r2.indexOf(i3.stack) || void 0 === n2 && void 0 === i3.stack) && r2.push(i3.stack), i3.index === t3))
+                break;
+        return r2.length || r2.push(void 0), r2;
+    }
+    _getStackCount(t3) {
+        return this._getStacks(void 0, t3).length;
+    }
+    _getStackIndex(t3, e2, i2) {
+        const s2 = this._getStacks(t3, i2),
+            n2 = void 0 !== e2 ? s2.indexOf(e2) : -1;
+        return -1 === n2 ? s2.length - 1 : n2;
+    }
+    _getRuler() {
+        const t3 = this.options,
+            e2 = this._cachedMeta,
+            i2 = e2.iScale,
+            s2 = [];
+        let n2, r2;
+        for (n2 = 0, r2 = e2.data.length; n2 < r2; ++n2)
+            s2.push(i2.getPixelForValue(this.getParsed(n2)[i2.axis], n2));
+        const o2 = t3.barThickness;
+        return {
+            min: o2 || Kr(e2),
+            pixels: s2,
+            start: i2._startPixel,
+            end: i2._endPixel,
+            stackCount: this._getStackCount(),
+            scale: i2,
+            grouped: t3.grouped,
+            ratio: o2 ? 1 : t3.categoryPercentage * t3.barPercentage
+        };
+    }
+    _calculateBarValuePixels(t3) {
+        const {
+            _cachedMeta: {
+                vScale: e2,
+                _stacked: i2,
+                index: s2
+            },
+            options: {
+                base: n2,
+                minBarLength: r2
+            }
+        } = this, o2 = n2 || 0, a2 = this.getParsed(t3), l2 = a2._custom, h2 = Qr(l2);
+        let c2, u2, d2 = a2[e2.axis],
+            f2 = 0,
+            p2 = i2 ? this.applyStack(e2, a2, i2) : d2;
+        p2 !== d2 && (f2 = p2 - d2, p2 = d2), h2 && (d2 = l2.barStart, p2 = l2.barEnd - l2.barStart, 0 !== d2 && os(d2) !== os(l2.barEnd) && (f2 = 0), f2 += d2);
+        const m2 = ci(n2) || h2 ? f2 : n2;
+        let g2 = e2.getPixelForValue(m2);
+        if (c2 = this.chart.getDataVisibility(t3) ? e2.getPixelForValue(f2 + p2) : g2, u2 = c2 - g2, Math.abs(u2) < r2) {
+            u2 = function(t5, e3, i3) {
+                return 0 !== t5 ? os(t5) : (e3.isHorizontal() ? 1 : -1) * (e3.min >= i3 ? 1 : -1);
+            }(u2, e2, o2) * r2, d2 === o2 && (g2 -= u2 / 2);
+            const t4 = e2.getPixelForDecimal(0),
+                n3 = e2.getPixelForDecimal(1),
+                l3 = Math.min(t4, n3),
+                f3 = Math.max(t4, n3);
+            g2 = Math.max(Math.min(g2, f3), l3), c2 = g2 + u2, i2 && !h2 && (a2._stacks[e2.axis]._visualValues[s2] = e2.getValueForPixel(c2) - e2.getValueForPixel(g2));
+        }
+        if (g2 === e2.getPixelForValue(o2)) {
+            const t4 = os(u2) * e2.getLineWidthForValue(o2) / 2;
+            g2 += t4, u2 -= t4;
+        }
+        return {
+            size: u2,
+            base: g2,
+            head: c2,
+            center: c2 + u2 / 2
+        };
+    }
+    _calculateBarIndexPixels(t3, e2) {
+        const i2 = e2.scale,
+            s2 = this.options,
+            n2 = s2.skipNull,
+            r2 = Ti(s2.maxBarThickness, 1 / 0);
+        let o2, a2;
+        if (e2.grouped) {
+            const i3 = n2 ? this._getStackCount(t3) : e2.stackCount,
+                l2 = "flex" === s2.barThickness ? function(t4, e3, i4, s3) {
+                    const n3 = e3.pixels,
+                        r3 = n3[t4];
+                    let o3 = t4 > 0 ? n3[t4 - 1] : null,
+                        a3 = t4 < n3.length - 1 ? n3[t4 + 1] : null;
+                    const l3 = i4.categoryPercentage;
+                    null === o3 && (o3 = r3 - (null === a3 ? e3.end - e3.start : a3 - r3)), null === a3 && (a3 = r3 + r3 - o3);
+                    const h3 = r3 - (r3 - Math.min(o3, a3)) / 2 * l3;
+                    return {
+                        chunk: Math.abs(a3 - o3) / 2 * l3 / s3,
+                        ratio: i4.barPercentage,
+                        start: h3
+                    };
+                }(t3, e2, s2, i3) : function(t4, e3, i4, s3) {
+                    const n3 = i4.barThickness;
+                    let r3, o3;
+                    return ci(n3) ? (r3 = e3.min * i4.categoryPercentage, o3 = i4.barPercentage) : (r3 = n3 * s3, o3 = 1), {
+                        chunk: r3 / s3,
+                        ratio: o3,
+                        start: e3.pixels[t4] - r3 / 2
+                    };
+                }(t3, e2, s2, i3),
+                h2 = this._getStackIndex(this.index, this._cachedMeta.stack, n2 ? t3 : void 0);
+            o2 = l2.start + l2.chunk * h2 + l2.chunk / 2, a2 = Math.min(r2, l2.chunk * l2.ratio);
+        } else
+            o2 = i2.getPixelForValue(this.getParsed(t3)[i2.axis], t3), a2 = Math.min(r2, e2.min * e2.ratio);
+        return {
+            base: o2 - a2 / 2,
+            head: o2 + a2 / 2,
+            center: o2,
+            size: a2
+        };
+    }
+    draw() {
+        const t3 = this._cachedMeta,
+            e2 = t3.vScale,
+            i2 = t3.data,
+            s2 = i2.length;
+        let n2 = 0;
+        for (; n2 < s2; ++n2)
+            null !== this.getParsed(n2)[e2.axis] && i2[n2].draw(this._ctx);
+    }
+}
+__publicField(BarController, "id", "bar");
+__publicField(BarController, "defaults", {
+    datasetElementType: false,
+    dataElementType: "bar",
+    categoryPercentage: 0.8,
+    barPercentage: 0.9,
+    grouped: true,
+    animations: {
+        numbers: {
+            type: "number",
+            properties: ["x", "y", "base", "width", "height"]
+        }
+    }
+});
+__publicField(BarController, "overrides", {
+    scales: {
+        _index_: {
+            type: "category",
+            offset: true,
+            grid: {
+                offset: true
+            }
+        },
+        _value_: {
+            type: "linear",
+            beginAtZero: true
+        }
+    }
+});
+class BubbleController extends DatasetController {
+    initialize() {
+        this.enableOptionSharing = true, super.initialize();
+    }
+    parsePrimitiveData(t3, e2, i2, s2) {
+        const n2 = super.parsePrimitiveData(t3, e2, i2, s2);
+        for (let t4 = 0; t4 < n2.length; t4++)
+            n2[t4]._custom = this.resolveDataElementOptions(t4 + i2).radius;
+        return n2;
+    }
+    parseArrayData(t3, e2, i2, s2) {
+        const n2 = super.parseArrayData(t3, e2, i2, s2);
+        for (let t4 = 0; t4 < n2.length; t4++) {
+            const s3 = e2[i2 + t4];
+            n2[t4]._custom = Ti(s3[2], this.resolveDataElementOptions(t4 + i2).radius);
+        }
+        return n2;
+    }
+    parseObjectData(t3, e2, i2, s2) {
+        const n2 = super.parseObjectData(t3, e2, i2, s2);
+        for (let t4 = 0; t4 < n2.length; t4++) {
+            const s3 = e2[i2 + t4];
+            n2[t4]._custom = Ti(s3 && s3.r && +s3.r, this.resolveDataElementOptions(t4 + i2).radius);
+        }
+        return n2;
+    }
+    getMaxOverflow() {
+        const t3 = this._cachedMeta.data;
+        let e2 = 0;
+        for (let i2 = t3.length - 1; i2 >= 0; --i2)
+            e2 = Math.max(e2, t3[i2].size(this.resolveDataElementOptions(i2)) / 2);
+        return e2 > 0 && e2;
+    }
+    getLabelAndValue(t3) {
+        const e2 = this._cachedMeta,
+            i2 = this.chart.data.labels || [],
+            {
+                xScale: s2,
+                yScale: n2
+            } = e2,
+            r2 = this.getParsed(t3),
+            o2 = s2.getLabelForValue(r2.x),
+            a2 = n2.getLabelForValue(r2.y),
+            l2 = r2._custom;
+        return {
+            label: i2[t3] || "",
+            value: "(" + o2 + ", " + a2 + (l2 ? ", " + l2 : "") + ")"
+        };
+    }
+    update(t3) {
+        const e2 = this._cachedMeta.data;
+        this.updateElements(e2, 0, e2.length, t3);
+    }
+    updateElements(t3, e2, i2, s2) {
+        const n2 = "reset" === s2,
+            {
+                iScale: r2,
+                vScale: o2
+            } = this._cachedMeta,
+            {
+                sharedOptions: a2,
+                includeOptions: l2
+            } = this._getSharedOptions(e2, s2),
+            h2 = r2.axis,
+            c2 = o2.axis;
+        for (let u2 = e2; u2 < e2 + i2; u2++) {
+            const e3 = t3[u2],
+                i3 = !n2 && this.getParsed(u2),
+                d2 = {},
+                f2 = d2[h2] = n2 ? r2.getPixelForDecimal(0.5) : r2.getPixelForValue(i3[h2]),
+                p2 = d2[c2] = n2 ? o2.getBasePixel() : o2.getPixelForValue(i3[c2]);
+            d2.skip = isNaN(f2) || isNaN(p2), l2 && (d2.options = a2 || this.resolveDataElementOptions(u2, e3.active ? "active" : s2), n2 && (d2.options.radius = 0)), this.updateElement(e3, u2, d2, s2);
+        }
+    }
+    resolveDataElementOptions(t3, e2) {
+        const i2 = this.getParsed(t3);
+        let s2 = super.resolveDataElementOptions(t3, e2);
+        s2.$shared && (s2 = Object.assign({}, s2, {
+            $shared: false
+        }));
+        const n2 = s2.radius;
+        return "active" !== e2 && (s2.radius = 0), s2.radius += Ti(i2 && i2._custom, n2), s2;
+    }
+}
+__publicField(BubbleController, "id", "bubble");
+__publicField(BubbleController, "defaults", {
+    datasetElementType: false,
+    dataElementType: "point",
+    animations: {
+        numbers: {
+            type: "number",
+            properties: ["x", "y", "borderWidth", "radius"]
+        }
+    }
+});
+__publicField(BubbleController, "overrides", {
+    scales: {
+        x: {
+            type: "linear"
+        },
+        y: {
+            type: "linear"
+        }
+    }
+});
+class LineController extends DatasetController {
+    initialize() {
+        this.enableOptionSharing = true, this.supportsDecimation = true, super.initialize();
+    }
+    update(t3) {
+        const e2 = this._cachedMeta,
+            {
+                dataset: i2,
+                data: s2 = [],
+                _dataset: n2
+            } = e2,
+            r2 = this.chart._animationsDisabled;
+        let {
+            start: o2,
+            count: a2
+        } = function(t4, e3, i3) {
+            const s3 = e3.length;
+            let n3 = 0,
+                r3 = s3;
+            if (t4._sorted) {
+                const {
+                    iScale: o3,
+                    _parsed: a3
+                } = t4, l3 = o3.axis, {
+                    min: h2,
+                    max: c2,
+                    minDefined: u2,
+                    maxDefined: d2
+                } = o3.getUserBounds();
+                u2 && (n3 = vs(Math.min(ws(a3, l3, h2).lo, i3 ? s3 : ws(e3, l3, o3.getPixelForValue(h2)).lo), 0, s3 - 1)), r3 = d2 ? vs(Math.max(ws(a3, o3.axis, c2, true).hi + 1, i3 ? 0 : ws(e3, l3, o3.getPixelForValue(c2), true).hi + 1), n3, s3) - n3 : s3 - n3;
+            }
+            return {
+                start: n3,
+                count: r3
+            };
+        }(e2, s2, r2);
+        this._drawStart = o2, this._drawCount = a2,
+            function(t4) {
+                const {
+                    xScale: e3,
+                    yScale: i3,
+                    _scaleRanges: s3
+                } = t4, n3 = {
+                    xmin: e3.min,
+                    xmax: e3.max,
+                    ymin: i3.min,
+                    ymax: i3.max
+                };
+                if (!s3)
+                    return t4._scaleRanges = n3, true;
+                const r3 = s3.xmin !== e3.min || s3.xmax !== e3.max || s3.ymin !== i3.min || s3.ymax !== i3.max;
+                return Object.assign(s3, n3), r3;
+            }(e2) && (o2 = 0, a2 = s2.length), i2._chart = this.chart, i2._datasetIndex = this.index, i2._decimated = !!n2._decimated, i2.points = s2;
+        const l2 = this.resolveDatasetElementOptions(t3);
+        this.options.showLine || (l2.borderWidth = 0), l2.segment = this.options.segment, this.updateElement(i2, void 0, {
+            animated: !r2,
+            options: l2
+        }, t3), this.updateElements(s2, o2, a2, t3);
+    }
+    updateElements(t3, e2, i2, s2) {
+        const n2 = "reset" === s2,
+            {
+                iScale: r2,
+                vScale: o2,
+                _stacked: a2,
+                _dataset: l2
+            } = this._cachedMeta,
+            {
+                sharedOptions: h2,
+                includeOptions: c2
+            } = this._getSharedOptions(e2, s2),
+            u2 = r2.axis,
+            d2 = o2.axis,
+            {
+                spanGaps: f2,
+                segment: p2
+            } = this.options,
+            m2 = hs(f2) ? f2 : Number.POSITIVE_INFINITY,
+            g2 = this.chart._animationsDisabled || n2 || "none" === s2,
+            y2 = e2 + i2,
+            v2 = t3.length;
+        let b2 = e2 > 0 && this.getParsed(e2 - 1);
+        for (let i3 = 0; i3 < v2; ++i3) {
+            const f3 = t3[i3],
+                v3 = g2 ? f3 : {};
+            if (i3 < e2 || i3 >= y2) {
+                v3.skip = true;
+                continue;
+            }
+            const _2 = this.getParsed(i3),
+                w2 = ci(_2[d2]),
+                x2 = v3[u2] = r2.getPixelForValue(_2[u2], i3),
+                k2 = v3[d2] = n2 || w2 ? o2.getBasePixel() : o2.getPixelForValue(a2 ? this.applyStack(o2, _2, a2) : _2[d2], i3);
+            v3.skip = isNaN(x2) || isNaN(k2) || w2, v3.stop = i3 > 0 && Math.abs(_2[u2] - b2[u2]) > m2, p2 && (v3.parsed = _2, v3.raw = l2.data[i3]), c2 && (v3.options = h2 || this.resolveDataElementOptions(i3, f3.active ? "active" : s2)), g2 || this.updateElement(f3, i3, v3, s2), b2 = _2;
+        }
+    }
+    getMaxOverflow() {
+        const t3 = this._cachedMeta,
+            e2 = t3.dataset,
+            i2 = e2.options && e2.options.borderWidth || 0,
+            s2 = t3.data || [];
+        if (!s2.length)
+            return i2;
+        const n2 = s2[0].size(this.resolveDataElementOptions(0)),
+            r2 = s2[s2.length - 1].size(this.resolveDataElementOptions(s2.length - 1));
+        return Math.max(i2, n2, r2) / 2;
+    }
+    draw() {
+        const t3 = this._cachedMeta;
+        t3.dataset.updateControlPoints(this.chart.chartArea, t3.iScale.axis), super.draw();
+    }
+}
+__publicField(LineController, "id", "line");
+__publicField(LineController, "defaults", {
+    datasetElementType: "line",
+    dataElementType: "point",
+    showLine: true,
+    spanGaps: false
+});
+__publicField(LineController, "overrides", {
+    scales: {
+        _index_: {
+            type: "category"
+        },
+        _value_: {
+            type: "linear"
+        }
+    }
+});
+
+function eo(t3, e2, i2, s2) {
+    const {
+        controller: n2,
+        data: r2,
+        _sorted: o2
+    } = t3, a2 = n2._cachedMeta.iScale;
+    if (a2 && e2 === a2.axis && "r" !== e2 && o2 && r2.length) {
+        const t4 = a2._reversePixels ? xs : ws;
+        if (!s2)
+            return t4(r2, e2, i2);
+        if (n2._sharedOptions) {
+            const s3 = r2[0],
+                n3 = "function" == typeof s3.getRange && s3.getRange(e2);
+            if (n3) {
+                const s4 = t4(r2, e2, i2 - n3),
+                    o3 = t4(r2, e2, i2 + n3);
+                return {
+                    lo: s4.lo,
+                    hi: o3.hi
+                };
+            }
+        }
+    }
+    return {
+        lo: 0,
+        hi: r2.length - 1
+    };
+}
+
+function io(t3, e2, i2, s2, n2) {
+    const r2 = t3.getSortedVisibleDatasetMetas(),
+        o2 = i2[e2];
+    for (let t4 = 0, i3 = r2.length; t4 < i3; ++t4) {
+        const {
+            index: i4,
+            data: a2
+        } = r2[t4], {
+            lo: l2,
+            hi: h2
+        } = eo(r2[t4], e2, o2, n2);
+        for (let t5 = l2; t5 <= h2; ++t5) {
+            const e3 = a2[t5];
+            e3.skip || s2(e3, i4, t5);
+        }
+    }
+}
+
+function so(t3, e2, i2, s2, n2) {
+    const r2 = [];
+    if (!n2 && !t3.isPointInArea(e2))
+        return r2;
+    return io(t3, i2, e2, function(i3, o2, a2) {
+        (n2 || nn(i3, t3.chartArea, 0)) && i3.inRange(e2.x, e2.y, s2) && r2.push({
+            element: i3,
+            datasetIndex: o2,
+            index: a2
+        });
+    }, true), r2;
+}
+
+function no(t3, e2, i2, s2) {
+    let n2 = [];
+    return io(t3, i2, e2, function(t4, i3, r2) {
+        const {
+            startAngle: o2,
+            endAngle: a2
+        } = t4.getProps(["startAngle", "endAngle"], s2), {
+            angle: l2
+        } = function(t5, e3) {
+            const i4 = e3.x - t5.x,
+                s3 = e3.y - t5.y,
+                n3 = Math.sqrt(i4 * i4 + s3 * s3);
+            let r3 = Math.atan2(s3, i4);
+            return r3 < -0.5 * Qi && (r3 += Xi), {
+                angle: r3,
+                distance: n3
+            };
+        }(t4, {
+            x: e2.x,
+            y: e2.y
+        });
+        ys(l2, o2, a2) && n2.push({
+            element: t4,
+            datasetIndex: i3,
+            index: r2
+        });
+    }), n2;
+}
+
+function ro(t3, e2, i2, s2, n2, r2) {
+    let o2 = [];
+    const a2 = function(t4) {
+        const e3 = -1 !== t4.indexOf("x"),
+            i3 = -1 !== t4.indexOf("y");
+        return function(t5, s3) {
+            const n3 = e3 ? Math.abs(t5.x - s3.x) : 0,
+                r3 = i3 ? Math.abs(t5.y - s3.y) : 0;
+            return Math.sqrt(Math.pow(n3, 2) + Math.pow(r3, 2));
+        };
+    }(i2);
+    let l2 = Number.POSITIVE_INFINITY;
+    return io(t3, i2, e2, function(i3, h2, c2) {
+        const u2 = i3.inRange(e2.x, e2.y, n2);
+        if (s2 && !u2)
+            return;
+        const d2 = i3.getCenterPoint(n2);
+        if (!(!!r2 || t3.isPointInArea(d2)) && !u2)
+            return;
+        const f2 = a2(e2, d2);
+        f2 < l2 ? (o2 = [{
+            element: i3,
+            datasetIndex: h2,
+            index: c2
+        }], l2 = f2) : f2 === l2 && o2.push({
+            element: i3,
+            datasetIndex: h2,
+            index: c2
+        });
+    }), o2;
+}
+
+function oo(t3, e2, i2, s2, n2, r2) {
+    return r2 || t3.isPointInArea(e2) ? "r" !== i2 || s2 ? ro(t3, e2, i2, s2, n2, r2) : no(t3, e2, i2, n2) : [];
+}
+
+function ao(t3, e2, i2, s2, n2) {
+    const r2 = [],
+        o2 = "x" === i2 ? "inXRange" : "inYRange";
+    let a2 = false;
+    return io(t3, i2, e2, (t4, s3, l2) => {
+        t4[o2](e2[i2], n2) && (r2.push({
+            element: t4,
+            datasetIndex: s3,
+            index: l2
+        }), a2 = a2 || t4.inRange(e2.x, e2.y, n2));
+    }), s2 && !a2 ? [] : r2;
+}
+var lo = {
+    evaluateInteractionItems: io,
+    modes: {
+        index(t3, e2, i2, s2) {
+            const n2 = yr(e2, t3),
+                r2 = i2.axis || "x",
+                o2 = i2.includeInvisible || false,
+                a2 = i2.intersect ? so(t3, n2, r2, s2, o2) : oo(t3, n2, r2, false, s2, o2),
+                l2 = [];
+            return a2.length ? (t3.getSortedVisibleDatasetMetas().forEach((t4) => {
+                const e3 = a2[0].index,
+                    i3 = t4.data[e3];
+                i3 && !i3.skip && l2.push({
+                    element: i3,
+                    datasetIndex: t4.index,
+                    index: e3
+                });
+            }), l2) : [];
+        },
+        dataset(t3, e2, i2, s2) {
+            const n2 = yr(e2, t3),
+                r2 = i2.axis || "xy",
+                o2 = i2.includeInvisible || false;
+            let a2 = i2.intersect ? so(t3, n2, r2, s2, o2) : oo(t3, n2, r2, false, s2, o2);
+            if (a2.length > 0) {
+                const e3 = a2[0].datasetIndex,
+                    i3 = t3.getDatasetMeta(e3).data;
+                a2 = [];
+                for (let t4 = 0; t4 < i3.length; ++t4)
+                    a2.push({
+                        element: i3[t4],
+                        datasetIndex: e3,
+                        index: t4
+                    });
+            }
+            return a2;
+        },
+        point: (t3, e2, i2, s2) => so(t3, yr(e2, t3), i2.axis || "xy", s2, i2.includeInvisible || false),
+        nearest(t3, e2, i2, s2) {
+            const n2 = yr(e2, t3),
+                r2 = i2.axis || "xy",
+                o2 = i2.includeInvisible || false;
+            return oo(t3, n2, r2, i2.intersect, s2, o2);
+        },
+        x: (t3, e2, i2, s2) => ao(t3, yr(e2, t3), "x", i2.intersect, s2),
+        y: (t3, e2, i2, s2) => ao(t3, yr(e2, t3), "y", i2.intersect, s2)
+    }
+};
+const ho = ["left", "top", "right", "bottom"];
+
+function co(t3, e2) {
+    return t3.filter((t4) => t4.pos === e2);
+}
+
+function uo(t3, e2) {
+    return t3.filter((t4) => -1 === ho.indexOf(t4.pos) && t4.box.axis === e2);
+}
+
+function fo(t3, e2) {
+    return t3.sort((t4, i2) => {
+        const s2 = e2 ? i2 : t4,
+            n2 = e2 ? t4 : i2;
+        return s2.weight === n2.weight ? s2.index - n2.index : s2.weight - n2.weight;
+    });
+}
+
+function po(t3, e2) {
+    const i2 = function(t4) {
+            const e3 = {};
+            for (const i3 of t4) {
+                const {
+                    stack: t5,
+                    pos: s3,
+                    stackWeight: n3
+                } = i3;
+                if (!t5 || !ho.includes(s3))
+                    continue;
+                const r3 = e3[t5] || (e3[t5] = {
+                    count: 0,
+                    placed: 0,
+                    weight: 0,
+                    size: 0
+                });
+                r3.count++, r3.weight += n3;
+            }
+            return e3;
+        }(t3),
+        {
+            vBoxMaxWidth: s2,
+            hBoxMaxHeight: n2
+        } = e2;
+    let r2, o2, a2;
+    for (r2 = 0, o2 = t3.length; r2 < o2; ++r2) {
+        a2 = t3[r2];
+        const {
+            fullSize: o3
+        } = a2.box, l2 = i2[a2.stack], h2 = l2 && a2.stackWeight / l2.weight;
+        a2.horizontal ? (a2.width = h2 ? h2 * s2 : o3 && e2.availableWidth, a2.height = n2) : (a2.width = s2, a2.height = h2 ? h2 * n2 : o3 && e2.availableHeight);
+    }
+    return i2;
+}
+
+function mo(t3, e2, i2, s2) {
+    return Math.max(t3[i2], e2[i2]) + Math.max(t3[s2], e2[s2]);
+}
+
+function go(t3, e2) {
+    t3.top = Math.max(t3.top, e2.top), t3.left = Math.max(t3.left, e2.left), t3.bottom = Math.max(t3.bottom, e2.bottom), t3.right = Math.max(t3.right, e2.right);
+}
+
+function yo(t3, e2, i2, s2) {
+    const {
+        pos: n2,
+        box: r2
+    } = i2, o2 = t3.maxPadding;
+    if (!yi(n2)) {
+        i2.size && (t3[n2] -= i2.size);
+        const e3 = s2[i2.stack] || {
+            size: 0,
+            count: 1
+        };
+        e3.size = Math.max(e3.size, i2.horizontal ? r2.height : r2.width), i2.size = e3.size / e3.count, t3[n2] += i2.size;
+    }
+    r2.getPadding && go(o2, r2.getPadding());
+    const a2 = Math.max(0, e2.outerWidth - mo(o2, t3, "left", "right")),
+        l2 = Math.max(0, e2.outerHeight - mo(o2, t3, "top", "bottom")),
+        h2 = a2 !== t3.w,
+        c2 = l2 !== t3.h;
+    return t3.w = a2, t3.h = l2, i2.horizontal ? {
+        same: h2,
+        other: c2
+    } : {
+        same: c2,
+        other: h2
+    };
+}
+
+function vo(t3, e2) {
+    const i2 = e2.maxPadding;
+
+    function s2(t4) {
+        const s3 = {
+            left: 0,
+            top: 0,
+            right: 0,
+            bottom: 0
+        };
+        return t4.forEach((t5) => {
+            s3[t5] = Math.max(e2[t5], i2[t5]);
+        }), s3;
+    }
+    return s2(t3 ? ["left", "right"] : ["top", "bottom"]);
+}
+
+function bo(t3, e2, i2, s2) {
+    const n2 = [];
+    let r2, o2, a2, l2, h2, c2;
+    for (r2 = 0, o2 = t3.length, h2 = 0; r2 < o2; ++r2) {
+        a2 = t3[r2], l2 = a2.box, l2.update(a2.width || e2.w, a2.height || e2.h, vo(a2.horizontal, e2));
+        const {
+            same: o3,
+            other: u2
+        } = yo(e2, i2, a2, s2);
+        h2 |= o3 && n2.length, c2 = c2 || u2, l2.fullSize || n2.push(a2);
+    }
+    return h2 && bo(n2, e2, i2, s2) || c2;
+}
+
+function _o(t3, e2, i2, s2, n2) {
+    t3.top = i2, t3.left = e2, t3.right = e2 + s2, t3.bottom = i2 + n2, t3.width = s2, t3.height = n2;
+}
+
+function wo(t3, e2, i2, s2) {
+    const n2 = i2.padding;
+    let {
+        x: r2,
+        y: o2
+    } = e2;
+    for (const a2 of t3) {
+        const t4 = a2.box,
+            l2 = s2[a2.stack] || {
+                count: 1,
+                placed: 0,
+                weight: 1
+            },
+            h2 = a2.stackWeight / l2.weight || 1;
+        if (a2.horizontal) {
+            const s3 = e2.w * h2,
+                r3 = l2.size || t4.height;
+            qi(l2.start) && (o2 = l2.start), t4.fullSize ? _o(t4, n2.left, o2, i2.outerWidth - n2.right - n2.left, r3) : _o(t4, e2.left + l2.placed, o2, s3, r3), l2.start = o2, l2.placed += s3, o2 = t4.bottom;
+        } else {
+            const s3 = e2.h * h2,
+                o3 = l2.size || t4.width;
+            qi(l2.start) && (r2 = l2.start), t4.fullSize ? _o(t4, r2, n2.top, o3, i2.outerHeight - n2.bottom - n2.top) : _o(t4, r2, e2.top + l2.placed, o3, s3), l2.start = r2, l2.placed += s3, r2 = t4.right;
+        }
+    }
+    e2.x = r2, e2.y = o2;
+}
+var xo = {
+    addBox(t3, e2) {
+        t3.boxes || (t3.boxes = []), e2.fullSize = e2.fullSize || false, e2.position = e2.position || "top", e2.weight = e2.weight || 0, e2._layers = e2._layers || function() {
+            return [{
+                z: 0,
+                draw(t4) {
+                    e2.draw(t4);
+                }
+            }];
+        }, t3.boxes.push(e2);
+    },
+    removeBox(t3, e2) {
+        const i2 = t3.boxes ? t3.boxes.indexOf(e2) : -1; -
+        1 !== i2 && t3.boxes.splice(i2, 1);
+    },
+    configure(t3, e2, i2) {
+        e2.fullSize = i2.fullSize, e2.position = i2.position, e2.weight = i2.weight;
+    },
+    update(t3, e2, i2, s2) {
+        if (!t3)
+            return;
+        const n2 = Ln(t3.options.layout.padding),
+            r2 = Math.max(e2 - n2.width, 0),
+            o2 = Math.max(i2 - n2.height, 0),
+            a2 = function(t4) {
+                const e3 = function(t5) {
+                        const e4 = [];
+                        let i4, s4, n4, r4, o4, a4;
+                        for (i4 = 0, s4 = (t5 || []).length; i4 < s4; ++i4)
+                            n4 = t5[i4], {
+                                position: r4,
+                                options: {
+                                    stack: o4,
+                                    stackWeight: a4 = 1
+                                }
+                            } = n4, e4.push({
+                                index: i4,
+                                box: n4,
+                                pos: r4,
+                                horizontal: n4.isHorizontal(),
+                                weight: n4.weight,
+                                stack: o4 && r4 + o4,
+                                stackWeight: a4
+                            });
+                        return e4;
+                    }(t4),
+                    i3 = fo(e3.filter((t5) => t5.box.fullSize), true),
+                    s3 = fo(co(e3, "left"), true),
+                    n3 = fo(co(e3, "right")),
+                    r3 = fo(co(e3, "top"), true),
+                    o3 = fo(co(e3, "bottom")),
+                    a3 = uo(e3, "x"),
+                    l3 = uo(e3, "y");
+                return {
+                    fullSize: i3,
+                    leftAndTop: s3.concat(r3),
+                    rightAndBottom: n3.concat(l3).concat(o3).concat(a3),
+                    chartArea: co(e3, "chartArea"),
+                    vertical: s3.concat(n3).concat(l3),
+                    horizontal: r3.concat(o3).concat(a3)
+                };
+            }(t3.boxes),
+            l2 = a2.vertical,
+            h2 = a2.horizontal;
+        Ei(t3.boxes, (t4) => {
+            "function" == typeof t4.beforeLayout && t4.beforeLayout();
+        });
+        const c2 = l2.reduce((t4, e3) => e3.box.options && false === e3.box.options.display ? t4 : t4 + 1, 0) || 1,
+            u2 = Object.freeze({
+                outerWidth: e2,
+                outerHeight: i2,
+                padding: n2,
+                availableWidth: r2,
+                availableHeight: o2,
+                vBoxMaxWidth: r2 / 2 / c2,
+                hBoxMaxHeight: o2 / 2
+            }),
+            d2 = Object.assign({}, n2);
+        go(d2, Ln(s2));
+        const f2 = Object.assign({
+                maxPadding: d2,
+                w: r2,
+                h: o2,
+                x: n2.left,
+                y: n2.top
+            }, n2),
+            p2 = po(l2.concat(h2), u2);
+        bo(a2.fullSize, f2, u2, p2), bo(l2, f2, u2, p2), bo(h2, f2, u2, p2) && bo(l2, f2, u2, p2),
+            function(t4) {
+                const e3 = t4.maxPadding;
+
+                function i3(i4) {
+                    const s3 = Math.max(e3[i4] - t4[i4], 0);
+                    return t4[i4] += s3, s3;
+                }
+                t4.y += i3("top"), t4.x += i3("left"), i3("right"), i3("bottom");
+            }(f2), wo(a2.leftAndTop, f2, u2, p2), f2.x += f2.w, f2.y += f2.h, wo(a2.rightAndBottom, f2, u2, p2), t3.chartArea = {
+                left: f2.left,
+                top: f2.top,
+                right: f2.left + f2.w,
+                bottom: f2.top + f2.h,
+                height: f2.h,
+                width: f2.w
+            }, Ei(a2.chartArea, (e3) => {
+                const i3 = e3.box;
+                Object.assign(i3, t3.chartArea), i3.update(f2.w, f2.h, {
+                    left: 0,
+                    top: 0,
+                    right: 0,
+                    bottom: 0
+                });
+            });
+    }
+};
+class BasePlatform {
+    acquireContext(t3, e2) {}
+    releaseContext(t3) {
+        return false;
+    }
+    addEventListener(t3, e2, i2) {}
+    removeEventListener(t3, e2, i2) {}
+    getDevicePixelRatio() {
+        return 1;
+    }
+    getMaximumSize(t3, e2, i2, s2) {
+        return e2 = Math.max(0, e2 || t3.width), i2 = i2 || t3.height, {
+            width: e2,
+            height: Math.max(0, s2 ? Math.floor(e2 / s2) : i2)
+        };
+    }
+    isAttached(t3) {
+        return true;
+    }
+    updateConfig(t3) {}
+}
+class BasicPlatform extends BasePlatform {
+    acquireContext(t3) {
+        return t3 && t3.getContext && t3.getContext("2d") || null;
+    }
+    updateConfig(t3) {
+        t3.options.animation = false;
+    }
+}
+const ko = "$chartjs",
+    To = {
+        touchstart: "mousedown",
+        touchmove: "mousemove",
+        touchend: "mouseup",
+        pointerenter: "mouseenter",
+        pointerdown: "mousedown",
+        pointermove: "mousemove",
+        pointerup: "mouseup",
+        pointerleave: "mouseout",
+        pointerout: "mouseout"
+    },
+    So = (t3) => null === t3 || "" === t3;
+const Eo = !!wr && {
+    passive: true
+};
+
+function Co(t3, e2, i2) {
+    t3.canvas.removeEventListener(e2, i2, Eo);
+}
+
+function Io(t3, e2) {
+    for (const i2 of t3)
+        if (i2 === e2 || i2.contains(e2))
+            return true;
+}
+
+function Mo(t3, e2, i2) {
+    const s2 = t3.canvas,
+        n2 = new MutationObserver((t4) => {
+            let e3 = false;
+            for (const i3 of t4)
+                e3 = e3 || Io(i3.addedNodes, s2), e3 = e3 && !Io(i3.removedNodes, s2);
+            e3 && i2();
+        });
+    return n2.observe(document, {
+        childList: true,
+        subtree: true
+    }), n2;
+}
+
+function Po(t3, e2, i2) {
+    const s2 = t3.canvas,
+        n2 = new MutationObserver((t4) => {
+            let e3 = false;
+            for (const i3 of t4)
+                e3 = e3 || Io(i3.removedNodes, s2), e3 = e3 && !Io(i3.addedNodes, s2);
+            e3 && i2();
+        });
+    return n2.observe(document, {
+        childList: true,
+        subtree: true
+    }), n2;
+}
+const Ro = /* @__PURE__ */ new Map();
+let Ao = 0;
+
+function Do() {
+    const t3 = window.devicePixelRatio;
+    t3 !== Ao && (Ao = t3, Ro.forEach((e2, i2) => {
+        i2.currentDevicePixelRatio !== t3 && e2();
+    }));
+}
+
+function Lo(t3, e2, i2) {
+    const s2 = t3.canvas,
+        n2 = s2 && ur(s2);
+    if (!n2)
+        return;
+    const r2 = Is((t4, e3) => {
+            const s3 = n2.clientWidth;
+            i2(t4, e3), s3 < n2.clientWidth && i2();
+        }, window),
+        o2 = new ResizeObserver((t4) => {
+            const e3 = t4[0],
+                i3 = e3.contentRect.width,
+                s3 = e3.contentRect.height;
+            0 === i3 && 0 === s3 || r2(i3, s3);
+        });
+    return o2.observe(n2),
+        function(t4, e3) {
+            Ro.size || window.addEventListener("resize", Do), Ro.set(t4, e3);
+        }(t3, r2), o2;
+}
+
+function Oo(t3, e2, i2) {
+    i2 && i2.disconnect(), "resize" === e2 && function(t4) {
+        Ro.delete(t4), Ro.size || window.removeEventListener("resize", Do);
+    }(t3);
+}
+
+function Fo(t3, e2, i2) {
+    const s2 = t3.canvas,
+        n2 = Is((e3) => {
+            null !== t3.ctx && i2(function(t4, e4) {
+                const i3 = To[t4.type] || t4.type,
+                    {
+                        x: s3,
+                        y: n3
+                    } = yr(t4, e4);
+                return {
+                    type: i3,
+                    chart: e4,
+                    native: t4,
+                    x: void 0 !== s3 ? s3 : null,
+                    y: void 0 !== n3 ? n3 : null
+                };
+            }(e3, t3));
+        }, t3);
+    return function(t4, e3, i3) {
+        t4.addEventListener(e3, i3, Eo);
+    }(s2, e2, n2), n2;
+}
+class DomPlatform extends BasePlatform {
+    acquireContext(t3, e2) {
+        const i2 = t3 && t3.getContext && t3.getContext("2d");
+        return i2 && i2.canvas === t3 ? (function(t4, e3) {
+            const i3 = t4.style,
+                s2 = t4.getAttribute("height"),
+                n2 = t4.getAttribute("width");
+            if (t4[ko] = {
+                    initial: {
+                        height: s2,
+                        width: n2,
+                        style: {
+                            display: i3.display,
+                            height: i3.height,
+                            width: i3.width
+                        }
+                    }
+                }, i3.display = i3.display || "block", i3.boxSizing = i3.boxSizing || "border-box", So(n2)) {
+                const e4 = xr(t4, "width");
+                void 0 !== e4 && (t4.width = e4);
+            }
+            if (So(s2))
+                if ("" === t4.style.height)
+                    t4.height = t4.width / (e3 || 2);
+                else {
+                    const e4 = xr(t4, "height");
+                    void 0 !== e4 && (t4.height = e4);
+                }
+        }(t3, e2), i2) : null;
+    }
+    releaseContext(t3) {
+        const e2 = t3.canvas;
+        if (!e2[ko])
+            return false;
+        const i2 = e2[ko].initial;
+        ["height", "width"].forEach((t4) => {
+            const s3 = i2[t4];
+            ci(s3) ? e2.removeAttribute(t4) : e2.setAttribute(t4, s3);
+        });
+        const s2 = i2.style || {};
+        return Object.keys(s2).forEach((t4) => {
+            e2.style[t4] = s2[t4];
+        }), e2.width = e2.width, delete e2[ko], true;
+    }
+    addEventListener(t3, e2, i2) {
+        this.removeEventListener(t3, e2);
+        const s2 = t3.$proxies || (t3.$proxies = {}),
+            n2 = {
+                attach: Mo,
+                detach: Po,
+                resize: Lo
+            } [e2] || Fo;
+        s2[e2] = n2(t3, e2, i2);
+    }
+    removeEventListener(t3, e2) {
+        const i2 = t3.$proxies || (t3.$proxies = {}),
+            s2 = i2[e2];
+        if (!s2)
+            return;
+        ({
+            attach: Oo,
+            detach: Oo,
+            resize: Oo
+        } [e2] || Co)(t3, e2, s2), i2[e2] = void 0;
+    }
+    getDevicePixelRatio() {
+        return window.devicePixelRatio;
+    }
+    getMaximumSize(t3, e2, i2, s2) {
+        return br(t3, e2, i2, s2);
+    }
+    isAttached(t3) {
+        const e2 = ur(t3);
+        return !(!e2 || !e2.isConnected);
+    }
+}
+class Element {
+    constructor() {
+        __publicField(this, "x");
+        __publicField(this, "y");
+        __publicField(this, "active", false);
+        __publicField(this, "options");
+        __publicField(this, "$animations");
+    }
+    tooltipPosition(t3) {
+        const {
+            x: e2,
+            y: i2
+        } = this.getProps(["x", "y"], t3);
+        return {
+            x: e2,
+            y: i2
+        };
+    }
+    hasValue() {
+        return hs(this.x) && hs(this.y);
+    }
+    getProps(t3, e2) {
+        const i2 = this.$animations;
+        if (!e2 || !i2)
+            return this;
+        const s2 = {};
+        return t3.forEach((t4) => {
+            s2[t4] = i2[t4] && i2[t4].active() ? i2[t4]._to : this[t4];
+        }), s2;
+    }
+}
+__publicField(Element, "defaults", {});
+__publicField(Element, "defaultRoutes");
+
+function No(t3, e2) {
+    const i2 = t3.options.ticks,
+        s2 = function(t4) {
+            const e3 = t4.options.offset,
+                i3 = t4._tickSize(),
+                s3 = t4._length / i3 + (e3 ? 0 : 1),
+                n3 = t4._maxLength / i3;
+            return Math.floor(Math.min(s3, n3));
+        }(t3),
+        n2 = Math.min(i2.maxTicksLimit || s2, s2),
+        r2 = i2.major.enabled ? function(t4) {
+            const e3 = [];
+            let i3, s3;
+            for (i3 = 0, s3 = t4.length; i3 < s3; i3++)
+                t4[i3].major && e3.push(i3);
+            return e3;
+        }(e2) : [],
+        o2 = r2.length,
+        a2 = r2[0],
+        l2 = r2[o2 - 1],
+        h2 = [];
+    if (o2 > n2)
+        return function(t4, e3, i3, s3) {
+            let n3, r3 = 0,
+                o3 = i3[0];
+            for (s3 = Math.ceil(s3), n3 = 0; n3 < t4.length; n3++)
+                n3 === o3 && (e3.push(t4[n3]), r3++, o3 = i3[r3 * s3]);
+        }(e2, h2, r2, o2 / n2), h2;
+    const c2 = function(t4, e3, i3) {
+        const s3 = function(t5) {
+                const e4 = t5.length;
+                let i4, s4;
+                if (e4 < 2)
+                    return false;
+                for (s4 = t5[0], i4 = 1; i4 < e4; ++i4)
+                    if (t5[i4] - t5[i4 - 1] !== s4)
+                        return false;
+                return s4;
+            }(t4),
+            n3 = e3.length / i3;
+        if (!s3)
+            return Math.max(n3, 1);
+        const r3 = function(t5) {
+            const e4 = [],
+                i4 = Math.sqrt(t5);
+            let s4;
+            for (s4 = 1; s4 < i4; s4++)
+                t5 % s4 == 0 && (e4.push(s4), e4.push(t5 / s4));
+            return i4 === (0 | i4) && e4.push(i4), e4.sort((t6, e5) => t6 - e5).pop(), e4;
+        }(s3);
+        for (let t5 = 0, e4 = r3.length - 1; t5 < e4; t5++) {
+            const e5 = r3[t5];
+            if (e5 > n3)
+                return e5;
+        }
+        return Math.max(n3, 1);
+    }(r2, e2, n2);
+    if (o2 > 0) {
+        let t4, i3;
+        const s3 = o2 > 1 ? Math.round((l2 - a2) / (o2 - 1)) : null;
+        for ($o(e2, h2, c2, ci(s3) ? 0 : a2 - s3, a2), t4 = 0, i3 = o2 - 1; t4 < i3; t4++)
+            $o(e2, h2, c2, r2[t4], r2[t4 + 1]);
+        return $o(e2, h2, c2, l2, ci(s3) ? e2.length : l2 + s3), h2;
+    }
+    return $o(e2, h2, c2), h2;
+}
+
+function $o(t3, e2, i2, s2, n2) {
+    const r2 = Ti(s2, 0),
+        o2 = Math.min(Ti(n2, t3.length), t3.length);
+    let a2, l2, h2, c2 = 0;
+    for (i2 = Math.ceil(i2), n2 && (a2 = n2 - s2, i2 = a2 / Math.floor(a2 / i2)), h2 = r2; h2 < 0;)
+        c2++, h2 = Math.round(r2 + c2 * i2);
+    for (l2 = Math.max(r2, 0); l2 < o2; l2++)
+        l2 === h2 && (e2.push(t3[l2]), c2++, h2 = Math.round(r2 + c2 * i2));
+}
+const Vo = (t3, e2, i2) => "top" === e2 || "left" === e2 ? t3[e2] + i2 : t3[e2] - i2,
+    zo = (t3, e2) => Math.min(e2 || t3, t3);
+
+function Bo(t3, e2) {
+    const i2 = [],
+        s2 = t3.length / e2,
+        n2 = t3.length;
+    let r2 = 0;
+    for (; r2 < n2; r2 += s2)
+        i2.push(t3[Math.floor(r2)]);
+    return i2;
+}
+
+function Uo(t3, e2, i2) {
+    const s2 = t3.ticks.length,
+        n2 = Math.min(e2, s2 - 1),
+        r2 = t3._startPixel,
+        o2 = t3._endPixel,
+        a2 = 1e-6;
+    let l2, h2 = t3.getPixelForTick(n2);
+    if (!(i2 && (l2 = 1 === s2 ? Math.max(h2 - r2, o2 - h2) : 0 === e2 ? (t3.getPixelForTick(1) - h2) / 2 : (h2 - t3.getPixelForTick(n2 - 1)) / 2, h2 += n2 < e2 ? l2 : -l2, h2 < r2 - a2 || h2 > o2 + a2)))
+        return h2;
+}
+
+function jo(t3) {
+    return t3.drawTicks ? t3.tickLength : 0;
+}
+
+function Ho(t3, e2) {
+    if (!t3.display)
+        return 0;
+    const i2 = On(t3.font, e2),
+        s2 = Ln(t3.padding);
+    return (ui(t3.text) ? t3.text.length : 1) * i2.lineHeight + s2.height;
+}
+
+function Wo(t3, e2, i2) {
+    let s2 = ((t4) => "start" === t4 ? "left" : "end" === t4 ? "right" : "center")(t3);
+    return (i2 && "right" !== e2 || !i2 && "right" === e2) && (s2 = ((t4) => "left" === t4 ? "right" : "right" === t4 ? "left" : t4)(s2)), s2;
+}
+class Scale extends Element {
+    constructor(t3) {
+        super(), this.id = t3.id, this.type = t3.type, this.options = void 0, this.ctx = t3.ctx, this.chart = t3.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
+            left: 0,
+            right: 0,
+            top: 0,
+            bottom: 0
+        }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = false, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = false, this.$context = void 0;
+    }
+    init(t3) {
+        this.options = t3.setContext(this.getContext()), this.axis = t3.axis, this._userMin = this.parse(t3.min), this._userMax = this.parse(t3.max), this._suggestedMin = this.parse(t3.suggestedMin), this._suggestedMax = this.parse(t3.suggestedMax);
+    }
+    parse(t3, e2) {
+        return t3;
+    }
+    getUserBounds() {
+        let {
+            _userMin: t3,
+            _userMax: e2,
+            _suggestedMin: i2,
+            _suggestedMax: s2
+        } = this;
+        return t3 = ki(t3, Number.POSITIVE_INFINITY), e2 = ki(e2, Number.NEGATIVE_INFINITY), i2 = ki(i2, Number.POSITIVE_INFINITY), s2 = ki(s2, Number.NEGATIVE_INFINITY), {
+            min: ki(t3, i2),
+            max: ki(e2, s2),
+            minDefined: _i(t3),
+            maxDefined: _i(e2)
+        };
+    }
+    getMinMax(t3) {
+        let e2, {
+            min: i2,
+            max: s2,
+            minDefined: n2,
+            maxDefined: r2
+        } = this.getUserBounds();
+        if (n2 && r2)
+            return {
+                min: i2,
+                max: s2
+            };
+        const o2 = this.getMatchingVisibleMetas();
+        for (let a2 = 0, l2 = o2.length; a2 < l2; ++a2)
+            e2 = o2[a2].controller.getMinMax(this, t3), n2 || (i2 = Math.min(i2, e2.min)), r2 || (s2 = Math.max(s2, e2.max));
+        return i2 = r2 && i2 > s2 ? s2 : i2, s2 = n2 && i2 > s2 ? i2 : s2, {
+            min: ki(i2, ki(s2, i2)),
+            max: ki(s2, ki(i2, s2))
+        };
+    }
+    getPadding() {
+        return {
+            left: this.paddingLeft || 0,
+            top: this.paddingTop || 0,
+            right: this.paddingRight || 0,
+            bottom: this.paddingBottom || 0
+        };
+    }
+    getTicks() {
+        return this.ticks;
+    }
+    getLabels() {
+        const t3 = this.chart.data;
+        return this.options.labels || (this.isHorizontal() ? t3.xLabels : t3.yLabels) || t3.labels || [];
+    }
+    getLabelItems(t3 = this.chart.chartArea) {
+        return this._labelItems || (this._labelItems = this._computeLabelItems(t3));
+    }
+    beforeLayout() {
+        this._cache = {}, this._dataLimitsCached = false;
+    }
+    beforeUpdate() {
+        Si(this.options.beforeUpdate, [this]);
+    }
+    update(t3, e2, i2) {
+        const {
+            beginAtZero: s2,
+            grace: n2,
+            ticks: r2
+        } = this.options, o2 = r2.sampleSize;
+        this.beforeUpdate(), this.maxWidth = t3, this.maxHeight = e2, this._margins = i2 = Object.assign({
+            left: 0,
+            right: 0,
+            top: 0,
+            bottom: 0
+        }, i2), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + i2.left + i2.right : this.height + i2.top + i2.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = Nn(this, n2, s2), this._dataLimitsCached = true), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
+        const a2 = o2 < this.ticks.length;
+        this._convertTicksToLabels(a2 ? Bo(this.ticks, o2) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), r2.display && (r2.autoSkip || "auto" === r2.source) && (this.ticks = No(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), a2 && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
+    }
+    configure() {
+        let t3, e2, i2 = this.options.reverse;
+        this.isHorizontal() ? (t3 = this.left, e2 = this.right) : (t3 = this.top, e2 = this.bottom, i2 = !i2), this._startPixel = t3, this._endPixel = e2, this._reversePixels = i2, this._length = e2 - t3, this._alignToPixels = this.options.alignToPixels;
+    }
+    afterUpdate() {
+        Si(this.options.afterUpdate, [this]);
+    }
+    beforeSetDimensions() {
+        Si(this.options.beforeSetDimensions, [this]);
+    }
+    setDimensions() {
+        this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
+    }
+    afterSetDimensions() {
+        Si(this.options.afterSetDimensions, [this]);
+    }
+    _callHooks(t3) {
+        this.chart.notifyPlugins(t3, this.getContext()), Si(this.options[t3], [this]);
+    }
+    beforeDataLimits() {
+        this._callHooks("beforeDataLimits");
+    }
+    determineDataLimits() {}
+    afterDataLimits() {
+        this._callHooks("afterDataLimits");
+    }
+    beforeBuildTicks() {
+        this._callHooks("beforeBuildTicks");
+    }
+    buildTicks() {
+        return [];
+    }
+    afterBuildTicks() {
+        this._callHooks("afterBuildTicks");
+    }
+    beforeTickToLabelConversion() {
+        Si(this.options.beforeTickToLabelConversion, [this]);
+    }
+    generateTickLabels(t3) {
+        const e2 = this.options.ticks;
+        let i2, s2, n2;
+        for (i2 = 0, s2 = t3.length; i2 < s2; i2++)
+            n2 = t3[i2], n2.label = Si(e2.callback, [n2.value, i2, t3], this);
+    }
+    afterTickToLabelConversion() {
+        Si(this.options.afterTickToLabelConversion, [this]);
+    }
+    beforeCalculateLabelRotation() {
+        Si(this.options.beforeCalculateLabelRotation, [this]);
+    }
+    calculateLabelRotation() {
+        const t3 = this.options,
+            e2 = t3.ticks,
+            i2 = zo(this.ticks.length, t3.ticks.maxTicksLimit),
+            s2 = e2.minRotation || 0,
+            n2 = e2.maxRotation;
+        let r2, o2, a2, l2 = s2;
+        if (!this._isVisible() || !e2.display || s2 >= n2 || i2 <= 1 || !this.isHorizontal())
+            return void(this.labelRotation = s2);
+        const h2 = this._getLabelSizes(),
+            c2 = h2.widest.width,
+            u2 = h2.highest.height,
+            d2 = vs(this.chart.width - c2, 0, this.maxWidth);
+        r2 = t3.offset ? this.maxWidth / i2 : d2 / (i2 - 1), c2 + 6 > r2 && (r2 = d2 / (i2 - (t3.offset ? 0.5 : 1)), o2 = this.maxHeight - jo(t3.grid) - e2.padding - Ho(t3.title, this.chart.options.font), a2 = Math.sqrt(c2 * c2 + u2 * u2), l2 = ds(Math.min(Math.asin(vs((h2.highest.height + 6) / r2, -1, 1)), Math.asin(vs(o2 / a2, -1, 1)) - Math.asin(vs(u2 / a2, -1, 1)))), l2 = Math.max(s2, Math.min(n2, l2))), this.labelRotation = l2;
+    }
+    afterCalculateLabelRotation() {
+        Si(this.options.afterCalculateLabelRotation, [this]);
+    }
+    afterAutoSkip() {}
+    beforeFit() {
+        Si(this.options.beforeFit, [this]);
+    }
+    fit() {
+        const t3 = {
+                width: 0,
+                height: 0
+            },
+            {
+                chart: e2,
+                options: {
+                    ticks: i2,
+                    title: s2,
+                    grid: n2
+                }
+            } = this,
+            r2 = this._isVisible(),
+            o2 = this.isHorizontal();
+        if (r2) {
+            const r3 = Ho(s2, e2.options.font);
+            if (o2 ? (t3.width = this.maxWidth, t3.height = jo(n2) + r3) : (t3.height = this.maxHeight, t3.width = jo(n2) + r3), i2.display && this.ticks.length) {
+                const {
+                    first: e3,
+                    last: s3,
+                    widest: n3,
+                    highest: r4
+                } = this._getLabelSizes(), a2 = 2 * i2.padding, l2 = us(this.labelRotation), h2 = Math.cos(l2), c2 = Math.sin(l2);
+                if (o2) {
+                    const e4 = i2.mirror ? 0 : c2 * n3.width + h2 * r4.height;
+                    t3.height = Math.min(this.maxHeight, t3.height + e4 + a2);
+                } else {
+                    const e4 = i2.mirror ? 0 : h2 * n3.width + c2 * r4.height;
+                    t3.width = Math.min(this.maxWidth, t3.width + e4 + a2);
+                }
+                this._calculatePadding(e3, s3, c2, h2);
+            }
+        }
+        this._handleMargins(), o2 ? (this.width = this._length = e2.width - this._margins.left - this._margins.right, this.height = t3.height) : (this.width = t3.width, this.height = this._length = e2.height - this._margins.top - this._margins.bottom);
+    }
+    _calculatePadding(t3, e2, i2, s2) {
+        const {
+            ticks: {
+                align: n2,
+                padding: r2
+            },
+            position: o2
+        } = this.options, a2 = 0 !== this.labelRotation, l2 = "top" !== o2 && "x" === this.axis;
+        if (this.isHorizontal()) {
+            const o3 = this.getPixelForTick(0) - this.left,
+                h2 = this.right - this.getPixelForTick(this.ticks.length - 1);
+            let c2 = 0,
+                u2 = 0;
+            a2 ? l2 ? (c2 = s2 * t3.width, u2 = i2 * e2.height) : (c2 = i2 * t3.height, u2 = s2 * e2.width) : "start" === n2 ? u2 = e2.width : "end" === n2 ? c2 = t3.width : "inner" !== n2 && (c2 = t3.width / 2, u2 = e2.width / 2), this.paddingLeft = Math.max((c2 - o3 + r2) * this.width / (this.width - o3), 0), this.paddingRight = Math.max((u2 - h2 + r2) * this.width / (this.width - h2), 0);
+        } else {
+            let i3 = e2.height / 2,
+                s3 = t3.height / 2;
+            "start" === n2 ? (i3 = 0, s3 = t3.height) : "end" === n2 && (i3 = e2.height, s3 = 0), this.paddingTop = i3 + r2, this.paddingBottom = s3 + r2;
+        }
+    }
+    _handleMargins() {
+        this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
+    }
+    afterFit() {
+        Si(this.options.afterFit, [this]);
+    }
+    isHorizontal() {
+        const {
+            axis: t3,
+            position: e2
+        } = this.options;
+        return "top" === e2 || "bottom" === e2 || "x" === t3;
+    }
+    isFullSize() {
+        return this.options.fullSize;
+    }
+    _convertTicksToLabels(t3) {
+        let e2, i2;
+        for (this.beforeTickToLabelConversion(), this.generateTickLabels(t3), e2 = 0, i2 = t3.length; e2 < i2; e2++)
+            ci(t3[e2].label) && (t3.splice(e2, 1), i2--, e2--);
+        this.afterTickToLabelConversion();
+    }
+    _getLabelSizes() {
+        let t3 = this._labelSizes;
+        if (!t3) {
+            const e2 = this.options.ticks.sampleSize;
+            let i2 = this.ticks;
+            e2 < i2.length && (i2 = Bo(i2, e2)), this._labelSizes = t3 = this._computeLabelSizes(i2, i2.length, this.options.ticks.maxTicksLimit);
+        }
+        return t3;
+    }
+    _computeLabelSizes(t3, e2, i2) {
+        const {
+            ctx: s2,
+            _longestTextCache: n2
+        } = this, r2 = [], o2 = [], a2 = Math.floor(e2 / zo(e2, i2));
+        let l2, h2, c2, u2, d2, f2, p2, m2, g2, y2, v2, b2 = 0,
+            _2 = 0;
+        for (l2 = 0; l2 < e2; l2 += a2) {
+            if (u2 = t3[l2].label, d2 = this._resolveTickFontOptions(l2), s2.font = f2 = d2.string, p2 = n2[f2] = n2[f2] || {
+                    data: {},
+                    gc: []
+                }, m2 = d2.lineHeight, g2 = y2 = 0, ci(u2) || ui(u2)) {
+                if (ui(u2))
+                    for (h2 = 0, c2 = u2.length; h2 < c2; ++h2)
+                        v2 = u2[h2], ci(v2) || ui(v2) || (g2 = Zs(s2, p2.data, p2.gc, g2, v2), y2 += m2);
+            } else
+                g2 = Zs(s2, p2.data, p2.gc, g2, u2), y2 = m2;
+            r2.push(g2), o2.push(y2), b2 = Math.max(g2, b2), _2 = Math.max(y2, _2);
+        }! function(t4, e3) {
+            Ei(t4, (t5) => {
+                const i3 = t5.gc,
+                    s3 = i3.length / 2;
+                let n3;
+                if (s3 > e3) {
+                    for (n3 = 0; n3 < s3; ++n3)
+                        delete t5.data[i3[n3]];
+                    i3.splice(0, s3);
+                }
+            });
+        }(n2, e2);
+        const w2 = r2.indexOf(b2),
+            x2 = o2.indexOf(_2),
+            k2 = (t4) => ({
+                width: r2[t4] || 0,
+                height: o2[t4] || 0
+            });
+        return {
+            first: k2(0),
+            last: k2(e2 - 1),
+            widest: k2(w2),
+            highest: k2(x2),
+            widths: r2,
+            heights: o2
+        };
+    }
+    getLabelForValue(t3) {
+        return t3;
+    }
+    getPixelForValue(t3, e2) {
+        return NaN;
+    }
+    getValueForPixel(t3) {}
+    getPixelForTick(t3) {
+        const e2 = this.ticks;
+        return t3 < 0 || t3 > e2.length - 1 ? null : this.getPixelForValue(e2[t3].value);
+    }
+    getPixelForDecimal(t3) {
+        this._reversePixels && (t3 = 1 - t3);
+        const e2 = this._startPixel + t3 * this._length;
+        return vs(this._alignToPixels ? tn(this.chart, e2, 0) : e2, -32768, 32767);
+    }
+    getDecimalForPixel(t3) {
+        const e2 = (t3 - this._startPixel) / this._length;
+        return this._reversePixels ? 1 - e2 : e2;
+    }
+    getBasePixel() {
+        return this.getPixelForValue(this.getBaseValue());
+    }
+    getBaseValue() {
+        const {
+            min: t3,
+            max: e2
+        } = this;
+        return t3 < 0 && e2 < 0 ? e2 : t3 > 0 && e2 > 0 ? t3 : 0;
+    }
+    getContext(t3) {
+        const e2 = this.ticks || [];
+        if (t3 >= 0 && t3 < e2.length) {
+            const i2 = e2[t3];
+            return i2.$context || (i2.$context = function(t4, e3, i3) {
+                return $n(t4, {
+                    tick: i3,
+                    index: e3,
+                    type: "tick"
+                });
+            }(this.getContext(), t3, i2));
+        }
+        return this.$context || (this.$context = function(t4, e3) {
+            return $n(t4, {
+                scale: e3,
+                type: "scale"
+            });
+        }(this.chart.getContext(), this));
+    }
+    _tickSize() {
+        const t3 = this.options.ticks,
+            e2 = us(this.labelRotation),
+            i2 = Math.abs(Math.cos(e2)),
+            s2 = Math.abs(Math.sin(e2)),
+            n2 = this._getLabelSizes(),
+            r2 = t3.autoSkipPadding || 0,
+            o2 = n2 ? n2.widest.width + r2 : 0,
+            a2 = n2 ? n2.highest.height + r2 : 0;
+        return this.isHorizontal() ? a2 * i2 > o2 * s2 ? o2 / i2 : a2 / s2 : a2 * s2 < o2 * i2 ? a2 / i2 : o2 / s2;
+    }
+    _isVisible() {
+        const t3 = this.options.display;
+        return "auto" !== t3 ? !!t3 : this.getMatchingVisibleMetas().length > 0;
+    }
+    _computeGridLineItems(t3) {
+        const e2 = this.axis,
+            i2 = this.chart,
+            s2 = this.options,
+            {
+                grid: n2,
+                position: r2,
+                border: o2
+            } = s2,
+            a2 = n2.offset,
+            l2 = this.isHorizontal(),
+            h2 = this.ticks.length + (a2 ? 1 : 0),
+            c2 = jo(n2),
+            u2 = [],
+            d2 = o2.setContext(this.getContext()),
+            f2 = d2.display ? d2.width : 0,
+            p2 = f2 / 2,
+            m2 = function(t4) {
+                return tn(i2, t4, f2);
+            };
+        let g2, y2, v2, b2, _2, w2, x2, k2, T2, S2, E2, C2;
+        if ("top" === r2)
+            g2 = m2(this.bottom), w2 = this.bottom - c2, k2 = g2 - p2, S2 = m2(t3.top) + p2, C2 = t3.bottom;
+        else if ("bottom" === r2)
+            g2 = m2(this.top), S2 = t3.top, C2 = m2(t3.bottom) - p2, w2 = g2 + p2, k2 = this.top + c2;
+        else if ("left" === r2)
+            g2 = m2(this.right), _2 = this.right - c2, x2 = g2 - p2, T2 = m2(t3.left) + p2, E2 = t3.right;
+        else if ("right" === r2)
+            g2 = m2(this.left), T2 = t3.left, E2 = m2(t3.right) - p2, _2 = g2 + p2, x2 = this.left + c2;
+        else if ("x" === e2) {
+            if ("center" === r2)
+                g2 = m2((t3.top + t3.bottom) / 2 + 0.5);
+            else if (yi(r2)) {
+                const t4 = Object.keys(r2)[0],
+                    e3 = r2[t4];
+                g2 = m2(this.chart.scales[t4].getPixelForValue(e3));
+            }
+            S2 = t3.top, C2 = t3.bottom, w2 = g2 + p2, k2 = w2 + c2;
+        } else if ("y" === e2) {
+            if ("center" === r2)
+                g2 = m2((t3.left + t3.right) / 2);
+            else if (yi(r2)) {
+                const t4 = Object.keys(r2)[0],
+                    e3 = r2[t4];
+                g2 = m2(this.chart.scales[t4].getPixelForValue(e3));
+            }
+            _2 = g2 - p2, x2 = _2 - c2, T2 = t3.left, E2 = t3.right;
+        }
+        const P2 = Ti(s2.ticks.maxTicksLimit, h2),
+            R2 = Math.max(1, Math.ceil(h2 / P2));
+        for (y2 = 0; y2 < h2; y2 += R2) {
+            const t4 = this.getContext(y2),
+                e3 = n2.setContext(t4),
+                s3 = o2.setContext(t4),
+                r3 = e3.lineWidth,
+                h3 = e3.color,
+                c3 = s3.dash || [],
+                d3 = s3.dashOffset,
+                f3 = e3.tickWidth,
+                p3 = e3.tickColor,
+                m3 = e3.tickBorderDash || [],
+                g3 = e3.tickBorderDashOffset;
+            v2 = Uo(this, y2, a2), void 0 !== v2 && (b2 = tn(i2, v2, r3), l2 ? _2 = x2 = T2 = E2 = b2 : w2 = k2 = S2 = C2 = b2, u2.push({
+                tx1: _2,
+                ty1: w2,
+                tx2: x2,
+                ty2: k2,
+                x1: T2,
+                y1: S2,
+                x2: E2,
+                y2: C2,
+                width: r3,
+                color: h3,
+                borderDash: c3,
+                borderDashOffset: d3,
+                tickWidth: f3,
+                tickColor: p3,
+                tickBorderDash: m3,
+                tickBorderDashOffset: g3
+            }));
+        }
+        return this._ticksLength = h2, this._borderValue = g2, u2;
+    }
+    _computeLabelItems(t3) {
+        const e2 = this.axis,
+            i2 = this.options,
+            {
+                position: s2,
+                ticks: n2
+            } = i2,
+            r2 = this.isHorizontal(),
+            o2 = this.ticks,
+            {
+                align: a2,
+                crossAlign: l2,
+                padding: h2,
+                mirror: c2
+            } = n2,
+            u2 = jo(i2.grid),
+            d2 = u2 + h2,
+            f2 = c2 ? -h2 : d2,
+            p2 = -us(this.labelRotation),
+            m2 = [];
+        let g2, y2, v2, b2, _2, w2, x2, k2, T2, S2, E2, C2, P2 = "middle";
+        if ("top" === s2)
+            w2 = this.bottom - f2, x2 = this._getXAxisLabelAlignment();
+        else if ("bottom" === s2)
+            w2 = this.top + f2, x2 = this._getXAxisLabelAlignment();
+        else if ("left" === s2) {
+            const t4 = this._getYAxisLabelAlignment(u2);
+            x2 = t4.textAlign, _2 = t4.x;
+        } else if ("right" === s2) {
+            const t4 = this._getYAxisLabelAlignment(u2);
+            x2 = t4.textAlign, _2 = t4.x;
+        } else if ("x" === e2) {
+            if ("center" === s2)
+                w2 = (t3.top + t3.bottom) / 2 + d2;
+            else if (yi(s2)) {
+                const t4 = Object.keys(s2)[0],
+                    e3 = s2[t4];
+                w2 = this.chart.scales[t4].getPixelForValue(e3) + d2;
+            }
+            x2 = this._getXAxisLabelAlignment();
+        } else if ("y" === e2) {
+            if ("center" === s2)
+                _2 = (t3.left + t3.right) / 2 - d2;
+            else if (yi(s2)) {
+                const t4 = Object.keys(s2)[0],
+                    e3 = s2[t4];
+                _2 = this.chart.scales[t4].getPixelForValue(e3);
+            }
+            x2 = this._getYAxisLabelAlignment(u2).textAlign;
+        }
+        "y" === e2 && ("start" === a2 ? P2 = "top" : "end" === a2 && (P2 = "bottom"));
+        const R2 = this._getLabelSizes();
+        for (g2 = 0, y2 = o2.length; g2 < y2; ++g2) {
+            v2 = o2[g2], b2 = v2.label;
+            const t4 = n2.setContext(this.getContext(g2));
+            k2 = this.getPixelForTick(g2) + n2.labelOffset, T2 = this._resolveTickFontOptions(g2), S2 = T2.lineHeight, E2 = ui(b2) ? b2.length : 1;
+            const e3 = E2 / 2,
+                i3 = t4.color,
+                a3 = t4.textStrokeColor,
+                h3 = t4.textStrokeWidth;
+            let u3, d3 = x2;
+            if (r2 ? (_2 = k2, "inner" === x2 && (d3 = g2 === y2 - 1 ? this.options.reverse ? "left" : "right" : 0 === g2 ? this.options.reverse ? "right" : "left" : "center"), C2 = "top" === s2 ? "near" === l2 || 0 !== p2 ? -E2 * S2 + S2 / 2 : "center" === l2 ? -R2.highest.height / 2 - e3 * S2 + S2 : -R2.highest.height + S2 / 2 : "near" === l2 || 0 !== p2 ? S2 / 2 : "center" === l2 ? R2.highest.height / 2 - e3 * S2 : R2.highest.height - E2 * S2, c2 && (C2 *= -1), 0 === p2 || t4.showLabelBackdrop || (_2 += S2 / 2 * Math.sin(p2))) : (w2 = k2, C2 = (1 - E2) * S2 / 2), t4.showLabelBackdrop) {
+                const e4 = Ln(t4.backdropPadding),
+                    i4 = R2.heights[g2],
+                    s3 = R2.widths[g2];
+                let n3 = C2 - e4.top,
+                    r3 = 0 - e4.left;
+                switch (P2) {
+                    case "middle":
+                        n3 -= i4 / 2;
+                        break;
+                    case "bottom":
+                        n3 -= i4;
+                }
+                switch (x2) {
+                    case "center":
+                        r3 -= s3 / 2;
+                        break;
+                    case "right":
+                        r3 -= s3;
+                }
+                u3 = {
+                    left: r3,
+                    top: n3,
+                    width: s3 + e4.width,
+                    height: i4 + e4.height,
+                    color: t4.backdropColor
+                };
+            }
+            m2.push({
+                label: b2,
+                font: T2,
+                textOffset: C2,
+                options: {
+                    rotation: p2,
+                    color: i3,
+                    strokeColor: a3,
+                    strokeWidth: h3,
+                    textAlign: d3,
+                    textBaseline: P2,
+                    translation: [_2, w2],
+                    backdrop: u3
+                }
+            });
+        }
+        return m2;
+    }
+    _getXAxisLabelAlignment() {
+        const {
+            position: t3,
+            ticks: e2
+        } = this.options;
+        if (-us(this.labelRotation))
+            return "top" === t3 ? "left" : "right";
+        let i2 = "center";
+        return "start" === e2.align ? i2 = "left" : "end" === e2.align ? i2 = "right" : "inner" === e2.align && (i2 = "inner"), i2;
+    }
+    _getYAxisLabelAlignment(t3) {
+        const {
+            position: e2,
+            ticks: {
+                crossAlign: i2,
+                mirror: s2,
+                padding: n2
+            }
+        } = this.options, r2 = t3 + n2, o2 = this._getLabelSizes().widest.width;
+        let a2, l2;
+        return "left" === e2 ? s2 ? (l2 = this.right + n2, "near" === i2 ? a2 = "left" : "center" === i2 ? (a2 = "center", l2 += o2 / 2) : (a2 = "right", l2 += o2)) : (l2 = this.right - r2, "near" === i2 ? a2 = "right" : "center" === i2 ? (a2 = "center", l2 -= o2 / 2) : (a2 = "left", l2 = this.left)) : "right" === e2 ? s2 ? (l2 = this.left + n2, "near" === i2 ? a2 = "right" : "center" === i2 ? (a2 = "center", l2 -= o2 / 2) : (a2 = "left", l2 -= o2)) : (l2 = this.left + r2, "near" === i2 ? a2 = "left" : "center" === i2 ? (a2 = "center", l2 += o2 / 2) : (a2 = "right", l2 = this.right)) : a2 = "right", {
+            textAlign: a2,
+            x: l2
+        };
+    }
+    _computeLabelArea() {
+        if (this.options.ticks.mirror)
+            return;
+        const t3 = this.chart,
+            e2 = this.options.position;
+        return "left" === e2 || "right" === e2 ? {
+            top: 0,
+            left: this.left,
+            bottom: t3.height,
+            right: this.right
+        } : "top" === e2 || "bottom" === e2 ? {
+            top: this.top,
+            left: 0,
+            bottom: this.bottom,
+            right: t3.width
+        } : void 0;
+    }
+    drawBackground() {
+        const {
+            ctx: t3,
+            options: {
+                backgroundColor: e2
+            },
+            left: i2,
+            top: s2,
+            width: n2,
+            height: r2
+        } = this;
+        e2 && (t3.save(), t3.fillStyle = e2, t3.fillRect(i2, s2, n2, r2), t3.restore());
+    }
+    getLineWidthForValue(t3) {
+        const e2 = this.options.grid;
+        if (!this._isVisible() || !e2.display)
+            return 0;
+        const i2 = this.ticks.findIndex((e3) => e3.value === t3);
+        if (i2 >= 0) {
+            return e2.setContext(this.getContext(i2)).lineWidth;
+        }
+        return 0;
+    }
+    drawGrid(t3) {
+        const e2 = this.options.grid,
+            i2 = this.ctx,
+            s2 = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t3));
+        let n2, r2;
+        const o2 = (t4, e3, s3) => {
+            s3.width && s3.color && (i2.save(), i2.lineWidth = s3.width, i2.strokeStyle = s3.color, i2.setLineDash(s3.borderDash || []), i2.lineDashOffset = s3.borderDashOffset, i2.beginPath(), i2.moveTo(t4.x, t4.y), i2.lineTo(e3.x, e3.y), i2.stroke(), i2.restore());
+        };
+        if (e2.display)
+            for (n2 = 0, r2 = s2.length; n2 < r2; ++n2) {
+                const t4 = s2[n2];
+                e2.drawOnChartArea && o2({
+                    x: t4.x1,
+                    y: t4.y1
+                }, {
+                    x: t4.x2,
+                    y: t4.y2
+                }, t4), e2.drawTicks && o2({
+                    x: t4.tx1,
+                    y: t4.ty1
+                }, {
+                    x: t4.tx2,
+                    y: t4.ty2
+                }, {
+                    color: t4.tickColor,
+                    width: t4.tickWidth,
+                    borderDash: t4.tickBorderDash,
+                    borderDashOffset: t4.tickBorderDashOffset
+                });
+            }
+    }
+    drawBorder() {
+        const {
+            chart: t3,
+            ctx: e2,
+            options: {
+                border: i2,
+                grid: s2
+            }
+        } = this, n2 = i2.setContext(this.getContext()), r2 = i2.display ? n2.width : 0;
+        if (!r2)
+            return;
+        const o2 = s2.setContext(this.getContext(0)).lineWidth,
+            a2 = this._borderValue;
+        let l2, h2, c2, u2;
+        this.isHorizontal() ? (l2 = tn(t3, this.left, r2) - r2 / 2, h2 = tn(t3, this.right, o2) + o2 / 2, c2 = u2 = a2) : (c2 = tn(t3, this.top, r2) - r2 / 2, u2 = tn(t3, this.bottom, o2) + o2 / 2, l2 = h2 = a2), e2.save(), e2.lineWidth = n2.width, e2.strokeStyle = n2.color, e2.beginPath(), e2.moveTo(l2, c2), e2.lineTo(h2, u2), e2.stroke(), e2.restore();
+    }
+    drawLabels(t3) {
+        if (!this.options.ticks.display)
+            return;
+        const e2 = this.ctx,
+            i2 = this._computeLabelArea();
+        i2 && ln(e2, i2);
+        const s2 = this.getLabelItems(t3);
+        for (const t4 of s2) {
+            const i3 = t4.options,
+                s3 = t4.font;
+            vn(e2, t4.label, 0, t4.textOffset, s3, i3);
+        }
+        i2 && un(e2);
+    }
+    drawTitle() {
+        const {
+            ctx: t3,
+            options: {
+                position: e2,
+                title: i2,
+                reverse: s2
+            }
+        } = this;
+        if (!i2.display)
+            return;
+        const n2 = On(i2.font),
+            r2 = Ln(i2.padding),
+            o2 = i2.align;
+        let a2 = n2.lineHeight / 2;
+        "bottom" === e2 || "center" === e2 || yi(e2) ? (a2 += r2.bottom, ui(i2.text) && (a2 += n2.lineHeight * (i2.text.length - 1))) : a2 += r2.top;
+        const {
+            titleX: l2,
+            titleY: h2,
+            maxWidth: c2,
+            rotation: u2
+        } = function(t4, e3, i3, s3) {
+            const {
+                top: n3,
+                left: r3,
+                bottom: o3,
+                right: a3,
+                chart: l3
+            } = t4, {
+                chartArea: h3,
+                scales: c3
+            } = l3;
+            let u3, d2, f2, p2 = 0;
+            const m2 = o3 - n3,
+                g2 = a3 - r3;
+            if (t4.isHorizontal()) {
+                if (d2 = Ms(s3, r3, a3), yi(i3)) {
+                    const t5 = Object.keys(i3)[0],
+                        s4 = i3[t5];
+                    f2 = c3[t5].getPixelForValue(s4) + m2 - e3;
+                } else
+                    f2 = "center" === i3 ? (h3.bottom + h3.top) / 2 + m2 - e3 : Vo(t4, i3, e3);
+                u3 = a3 - r3;
+            } else {
+                if (yi(i3)) {
+                    const t5 = Object.keys(i3)[0],
+                        s4 = i3[t5];
+                    d2 = c3[t5].getPixelForValue(s4) - g2 + e3;
+                } else
+                    d2 = "center" === i3 ? (h3.left + h3.right) / 2 - g2 + e3 : Vo(t4, i3, e3);
+                f2 = Ms(s3, o3, n3), p2 = "left" === i3 ? -is : is;
+            }
+            return {
+                titleX: d2,
+                titleY: f2,
+                maxWidth: u3,
+                rotation: p2
+            };
+        }(this, a2, e2, o2);
+        vn(t3, i2.text, 0, 0, n2, {
+            color: i2.color,
+            maxWidth: c2,
+            rotation: u2,
+            textAlign: Wo(o2, e2, s2),
+            textBaseline: "middle",
+            translation: [l2, h2]
+        });
+    }
+    draw(t3) {
+        this._isVisible() && (this.drawBackground(), this.drawGrid(t3), this.drawBorder(), this.drawTitle(), this.drawLabels(t3));
+    }
+    _layers() {
+        const t3 = this.options,
+            e2 = t3.ticks && t3.ticks.z || 0,
+            i2 = Ti(t3.grid && t3.grid.z, -1),
+            s2 = Ti(t3.border && t3.border.z, 0);
+        return this._isVisible() && this.draw === Scale.prototype.draw ? [{
+            z: i2,
+            draw: (t4) => {
+                this.drawBackground(), this.drawGrid(t4), this.drawTitle();
+            }
+        }, {
+            z: s2,
+            draw: () => {
+                this.drawBorder();
+            }
+        }, {
+            z: e2,
+            draw: (t4) => {
+                this.drawLabels(t4);
+            }
+        }] : [{
+            z: e2,
+            draw: (t4) => {
+                this.draw(t4);
+            }
+        }];
+    }
+    getMatchingVisibleMetas(t3) {
+        const e2 = this.chart.getSortedVisibleDatasetMetas(),
+            i2 = this.axis + "AxisID",
+            s2 = [];
+        let n2, r2;
+        for (n2 = 0, r2 = e2.length; n2 < r2; ++n2) {
+            const r3 = e2[n2];
+            r3[i2] !== this.id || t3 && r3.type !== t3 || s2.push(r3);
+        }
+        return s2;
+    }
+    _resolveTickFontOptions(t3) {
+        return On(this.options.ticks.setContext(this.getContext(t3)).font);
+    }
+    _maxDigits() {
+        const t3 = this._resolveTickFontOptions(0).lineHeight;
+        return (this.isHorizontal() ? this.width : this.height) / t3;
+    }
+}
+class TypedRegistry {
+    constructor(t3, e2, i2) {
+        this.type = t3, this.scope = e2, this.override = i2, this.items = /* @__PURE__ */ Object.create(null);
+    }
+    isForType(t3) {
+        return Object.prototype.isPrototypeOf.call(this.type.prototype, t3.prototype);
+    }
+    register(t3) {
+        const e2 = Object.getPrototypeOf(t3);
+        let i2;
+        (function(t4) {
+            return "id" in t4 && "defaults" in t4;
+        })(e2) && (i2 = this.register(e2));
+        const s2 = this.items,
+            n2 = t3.id,
+            r2 = this.scope + "." + n2;
+        if (!n2)
+            throw new Error("class does not have id: " + t3);
+        return n2 in s2 || (s2[n2] = t3, function(t4, e3, i3) {
+            const s3 = Ni( /* @__PURE__ */ Object.create(null), [i3 ? Js.get(i3) : {}, Js.get(e3), t4.defaults]);
+            Js.set(e3, s3), t4.defaultRoutes && function(t5, e4) {
+                Object.keys(e4).forEach((i4) => {
+                    const s4 = i4.split("."),
+                        n3 = s4.pop(),
+                        r3 = [t5].concat(s4).join("."),
+                        o2 = e4[i4].split("."),
+                        a2 = o2.pop(),
+                        l2 = o2.join(".");
+                    Js.route(r3, n3, l2, a2);
+                });
+            }(e3, t4.defaultRoutes);
+            t4.descriptors && Js.describe(e3, t4.descriptors);
+        }(t3, r2, i2), this.override && Js.override(t3.id, t3.overrides)), r2;
+    }
+    get(t3) {
+        return this.items[t3];
+    }
+    unregister(t3) {
+        const e2 = this.items,
+            i2 = t3.id,
+            s2 = this.scope;
+        i2 in e2 && delete e2[i2], s2 && i2 in Js[s2] && (delete Js[s2][i2], this.override && delete Gs[i2]);
+    }
+}
+class Registry {
+    constructor() {
+        this.controllers = new TypedRegistry(DatasetController, "datasets", true), this.elements = new TypedRegistry(Element, "elements"), this.plugins = new TypedRegistry(Object, "plugins"), this.scales = new TypedRegistry(Scale, "scales"), this._typedRegistries = [this.controllers, this.scales, this.elements];
+    }
+    add(...t3) {
+        this._each("register", t3);
+    }
+    remove(...t3) {
+        this._each("unregister", t3);
+    }
+    addControllers(...t3) {
+        this._each("register", t3, this.controllers);
+    }
+    addElements(...t3) {
+        this._each("register", t3, this.elements);
+    }
+    addPlugins(...t3) {
+        this._each("register", t3, this.plugins);
+    }
+    addScales(...t3) {
+        this._each("register", t3, this.scales);
+    }
+    getController(t3) {
+        return this._get(t3, this.controllers, "controller");
+    }
+    getElement(t3) {
+        return this._get(t3, this.elements, "element");
+    }
+    getPlugin(t3) {
+        return this._get(t3, this.plugins, "plugin");
+    }
+    getScale(t3) {
+        return this._get(t3, this.scales, "scale");
+    }
+    removeControllers(...t3) {
+        this._each("unregister", t3, this.controllers);
+    }
+    removeElements(...t3) {
+        this._each("unregister", t3, this.elements);
+    }
+    removePlugins(...t3) {
+        this._each("unregister", t3, this.plugins);
+    }
+    removeScales(...t3) {
+        this._each("unregister", t3, this.scales);
+    }
+    _each(t3, e2, i2) {
+        [...e2].forEach((e3) => {
+            const s2 = i2 || this._getRegistryForType(e3);
+            i2 || s2.isForType(e3) || s2 === this.plugins && e3.id ? this._exec(t3, s2, e3) : Ei(e3, (e4) => {
+                const s3 = i2 || this._getRegistryForType(e4);
+                this._exec(t3, s3, e4);
+            });
+        });
+    }
+    _exec(t3, e2, i2) {
+        const s2 = Wi(t3);
+        Si(i2["before" + s2], [], i2), e2[t3](i2), Si(i2["after" + s2], [], i2);
+    }
+    _getRegistryForType(t3) {
+        for (let e2 = 0; e2 < this._typedRegistries.length; e2++) {
+            const i2 = this._typedRegistries[e2];
+            if (i2.isForType(t3))
+                return i2;
+        }
+        return this.plugins;
+    }
+    _get(t3, e2, i2) {
+        const s2 = e2.get(t3);
+        if (void 0 === s2)
+            throw new Error('"' + t3 + '" is not a registered ' + i2 + ".");
+        return s2;
+    }
+}
+var qo = new Registry();
+class PluginService {
+    constructor() {
+        this._init = [];
+    }
+    notify(t3, e2, i2, s2) {
+        "beforeInit" === e2 && (this._init = this._createDescriptors(t3, true), this._notify(this._init, t3, "install"));
+        const n2 = s2 ? this._descriptors(t3).filter(s2) : this._descriptors(t3),
+            r2 = this._notify(n2, t3, e2, i2);
+        return "afterDestroy" === e2 && (this._notify(n2, t3, "stop"), this._notify(this._init, t3, "uninstall")), r2;
+    }
+    _notify(t3, e2, i2, s2) {
+        s2 = s2 || {};
+        for (const n2 of t3) {
+            const t4 = n2.plugin;
+            if (false === Si(t4[i2], [e2, s2, n2.options], t4) && s2.cancelable)
+                return false;
+        }
+        return true;
+    }
+    invalidate() {
+        ci(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
+    }
+    _descriptors(t3) {
+        if (this._cache)
+            return this._cache;
+        const e2 = this._cache = this._createDescriptors(t3);
+        return this._notifyStateChanges(t3), e2;
+    }
+    _createDescriptors(t3, e2) {
+        const i2 = t3 && t3.config,
+            s2 = Ti(i2.options && i2.options.plugins, {}),
+            n2 = function(t4) {
+                const e3 = {},
+                    i3 = [],
+                    s3 = Object.keys(qo.plugins.items);
+                for (let t5 = 0; t5 < s3.length; t5++)
+                    i3.push(qo.getPlugin(s3[t5]));
+                const n3 = t4.plugins || [];
+                for (let t5 = 0; t5 < n3.length; t5++) {
+                    const s4 = n3[t5]; -
+                    1 === i3.indexOf(s4) && (i3.push(s4), e3[s4.id] = true);
+                }
+                return {
+                    plugins: i3,
+                    localIds: e3
+                };
+            }(i2);
+        return false !== s2 || e2 ? function(t4, {
+            plugins: e3,
+            localIds: i3
+        }, s3, n3) {
+            const r2 = [],
+                o2 = t4.getContext();
+            for (const a2 of e3) {
+                const e4 = a2.id,
+                    l2 = Ko(s3[e4], n3);
+                null !== l2 && r2.push({
+                    plugin: a2,
+                    options: Go(t4.config, {
+                        plugin: a2,
+                        local: i3[e4]
+                    }, l2, o2)
+                });
+            }
+            return r2;
+        }(t3, n2, s2, e2) : [];
+    }
+    _notifyStateChanges(t3) {
+        const e2 = this._oldCache || [],
+            i2 = this._cache,
+            s2 = (t4, e3) => t4.filter((t5) => !e3.some((e4) => t5.plugin.id === e4.plugin.id));
+        this._notify(s2(e2, i2), t3, "stop"), this._notify(s2(i2, e2), t3, "start");
+    }
+}
+
+function Ko(t3, e2) {
+    return e2 || false !== t3 ? true === t3 ? {} : t3 : null;
+}
+
+function Go(t3, {
+    plugin: e2,
+    local: i2
+}, s2, n2) {
+    const r2 = t3.pluginScopeKeys(e2),
+        o2 = t3.getOptionScopes(s2, r2);
+    return i2 && e2.defaults && o2.push(e2.defaults), t3.createResolver(o2, n2, [""], {
+        scriptable: false,
+        indexable: false,
+        allKeys: true
+    });
+}
+
+function Yo(t3, e2) {
+    const i2 = Js.datasets[t3] || {};
+    return ((e2.datasets || {})[t3] || {}).indexAxis || e2.indexAxis || i2.indexAxis || "x";
+}
+
+function Qo(t3) {
+    if ("x" === t3 || "y" === t3 || "r" === t3)
+        return t3;
+}
+
+function Xo(t3) {
+    return "top" === t3 || "bottom" === t3 ? "x" : "left" === t3 || "right" === t3 ? "y" : void 0;
+}
+
+function Jo(t3, ...e2) {
+    if (Qo(t3))
+        return t3;
+    for (const i2 of e2) {
+        const e3 = i2.axis || Xo(i2.position) || t3.length > 1 && Qo(t3[0].toLowerCase());
+        if (e3)
+            return e3;
+    }
+    throw new Error(`Cannot determine type of '${t3}' axis. Please provide 'axis' or 'position' option.`);
+}
+
+function Zo(t3, e2, i2) {
+    if (i2[e2 + "AxisID"] === t3)
+        return {
+            axis: e2
+        };
+}
+
+function ta(t3, e2) {
+    const i2 = Gs[t3.type] || {
+            scales: {}
+        },
+        s2 = e2.scales || {},
+        n2 = Yo(t3.type, e2),
+        r2 = /* @__PURE__ */ Object.create(null);
+    return Object.keys(s2).forEach((e3) => {
+        const o2 = s2[e3];
+        if (!yi(o2))
+            return console.error(`Invalid scale configuration for scale: ${e3}`);
+        if (o2._proxy)
+            return console.warn(`Ignoring resolver passed as options for scale: ${e3}`);
+        const a2 = Jo(e3, o2, function(t4, e4) {
+                if (e4.data && e4.data.datasets) {
+                    const i3 = e4.data.datasets.filter((e5) => e5.xAxisID === t4 || e5.yAxisID === t4);
+                    if (i3.length)
+                        return Zo(t4, "x", i3[0]) || Zo(t4, "y", i3[0]);
+                }
+                return {};
+            }(e3, t3), Js.scales[o2.type]),
+            l2 = function(t4, e4) {
+                return t4 === e4 ? "_index_" : "_value_";
+            }(a2, n2),
+            h2 = i2.scales || {};
+        r2[e3] = Vi( /* @__PURE__ */ Object.create(null), [{
+            axis: a2
+        }, o2, h2[a2], h2[l2]]);
+    }), t3.data.datasets.forEach((i3) => {
+        const n3 = i3.type || t3.type,
+            o2 = i3.indexAxis || Yo(n3, e2),
+            a2 = (Gs[n3] || {}).scales || {};
+        Object.keys(a2).forEach((t4) => {
+            const e3 = function(t5, e4) {
+                    let i4 = t5;
+                    return "_index_" === t5 ? i4 = e4 : "_value_" === t5 && (i4 = "x" === e4 ? "y" : "x"), i4;
+                }(t4, o2),
+                n4 = i3[e3 + "AxisID"] || e3;
+            r2[n4] = r2[n4] || /* @__PURE__ */ Object.create(null), Vi(r2[n4], [{
+                axis: e3
+            }, s2[n4], a2[t4]]);
+        });
+    }), Object.keys(r2).forEach((t4) => {
+        const e3 = r2[t4];
+        Vi(e3, [Js.scales[e3.type], Js.scale]);
+    }), r2;
+}
+
+function ea(t3) {
+    const e2 = t3.options || (t3.options = {});
+    e2.plugins = Ti(e2.plugins, {}), e2.scales = ta(t3, e2);
+}
+
+function ia(t3) {
+    return (t3 = t3 || {}).datasets = t3.datasets || [], t3.labels = t3.labels || [], t3;
+}
+const sa = /* @__PURE__ */ new Map(),
+    na = /* @__PURE__ */ new Set();
+
+function ra(t3, e2) {
+    let i2 = sa.get(t3);
+    return i2 || (i2 = e2(), sa.set(t3, i2), na.add(i2)), i2;
+}
+const oa = (t3, e2, i2) => {
+    const s2 = ji(e2, i2);
+    void 0 !== s2 && t3.add(s2);
+};
+class Config {
+    constructor(t3) {
+        this._config = function(t4) {
+            return (t4 = t4 || {}).data = ia(t4.data), ea(t4), t4;
+        }(t3), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
+    }
+    get platform() {
+        return this._config.platform;
+    }
+    get type() {
+        return this._config.type;
+    }
+    set type(t3) {
+        this._config.type = t3;
+    }
+    get data() {
+        return this._config.data;
+    }
+    set data(t3) {
+        this._config.data = ia(t3);
+    }
+    get options() {
+        return this._config.options;
+    }
+    set options(t3) {
+        this._config.options = t3;
+    }
+    get plugins() {
+        return this._config.plugins;
+    }
+    update() {
+        const t3 = this._config;
+        this.clearCache(), ea(t3);
+    }
+    clearCache() {
+        this._scopeCache.clear(), this._resolverCache.clear();
+    }
+    datasetScopeKeys(t3) {
+        return ra(t3, () => [
+            [`datasets.${t3}`, ""]
+        ]);
+    }
+    datasetAnimationScopeKeys(t3, e2) {
+        return ra(`${t3}.transition.${e2}`, () => [
+            [`datasets.${t3}.transitions.${e2}`, `transitions.${e2}`],
+            [`datasets.${t3}`, ""]
+        ]);
+    }
+    datasetElementScopeKeys(t3, e2) {
+        return ra(`${t3}-${e2}`, () => [
+            [`datasets.${t3}.elements.${e2}`, `datasets.${t3}`, `elements.${e2}`, ""]
+        ]);
+    }
+    pluginScopeKeys(t3) {
+        const e2 = t3.id;
+        return ra(`${this.type}-plugin-${e2}`, () => [
+            [`plugins.${e2}`, ...t3.additionalOptionScopes || []]
+        ]);
+    }
+    _cachedScopes(t3, e2) {
+        const i2 = this._scopeCache;
+        let s2 = i2.get(t3);
+        return s2 && !e2 || (s2 = /* @__PURE__ */ new Map(), i2.set(t3, s2)), s2;
+    }
+    getOptionScopes(t3, e2, i2) {
+        const {
+            options: s2,
+            type: n2
+        } = this, r2 = this._cachedScopes(t3, i2), o2 = r2.get(e2);
+        if (o2)
+            return o2;
+        const a2 = /* @__PURE__ */ new Set();
+        e2.forEach((e3) => {
+            t3 && (a2.add(t3), e3.forEach((e4) => oa(a2, t3, e4))), e3.forEach((t4) => oa(a2, s2, t4)), e3.forEach((t4) => oa(a2, Gs[n2] || {}, t4)), e3.forEach((t4) => oa(a2, Js, t4)), e3.forEach((t4) => oa(a2, Ys, t4));
+        });
+        const l2 = Array.from(a2);
+        return 0 === l2.length && l2.push( /* @__PURE__ */ Object.create(null)), na.has(e2) && r2.set(e2, l2), l2;
+    }
+    chartOptionScopes() {
+        const {
+            options: t3,
+            type: e2
+        } = this;
+        return [t3, Gs[e2] || {}, Js.datasets[e2] || {}, {
+            type: e2
+        }, Js, Ys];
+    }
+    resolveNamedOptions(t3, e2, i2, s2 = [""]) {
+        const n2 = {
+                $shared: true
+            },
+            {
+                resolver: r2,
+                subPrefixes: o2
+            } = aa(this._resolverCache, t3, s2);
+        let a2 = r2;
+        if (function(t4, e3) {
+                const {
+                    isScriptable: i3,
+                    isIndexable: s3
+                } = Bn(t4);
+                for (const n3 of e3) {
+                    const e4 = i3(n3),
+                        r3 = s3(n3),
+                        o3 = (r3 || e4) && t4[n3];
+                    if (e4 && (Gi(o3) || la(o3)) || r3 && ui(o3))
+                        return true;
+                }
+                return false;
+            }(r2, e2)) {
+            n2.$shared = false;
+            a2 = zn(r2, i2 = Gi(i2) ? i2() : i2, this.createResolver(t3, i2, o2));
+        }
+        for (const t4 of e2)
+            n2[t4] = a2[t4];
+        return n2;
+    }
+    createResolver(t3, e2, i2 = [""], s2) {
+        const {
+            resolver: n2
+        } = aa(this._resolverCache, t3, i2);
+        return yi(e2) ? zn(n2, e2, void 0, s2) : n2;
+    }
+}
+
+function aa(t3, e2, i2) {
+    let s2 = t3.get(e2);
+    s2 || (s2 = /* @__PURE__ */ new Map(), t3.set(e2, s2));
+    const n2 = i2.join();
+    let r2 = s2.get(n2);
+    if (!r2) {
+        r2 = {
+            resolver: Vn(e2, i2),
+            subPrefixes: i2.filter((t4) => !t4.toLowerCase().includes("hover"))
+        }, s2.set(n2, r2);
+    }
+    return r2;
+}
+const la = (t3) => yi(t3) && Object.getOwnPropertyNames(t3).reduce((e2, i2) => e2 || Gi(t3[i2]), false);
+const ha = ["top", "bottom", "left", "right", "chartArea"];
+
+function ca(t3, e2) {
+    return "top" === t3 || "bottom" === t3 || -1 === ha.indexOf(t3) && "x" === e2;
+}
+
+function ua(t3, e2) {
+    return function(i2, s2) {
+        return i2[t3] === s2[t3] ? i2[e2] - s2[e2] : i2[t3] - s2[t3];
+    };
+}
+
+function da(t3) {
+    const e2 = t3.chart,
+        i2 = e2.options.animation;
+    e2.notifyPlugins("afterRender"), Si(i2 && i2.onComplete, [t3], e2);
+}
+
+function fa(t3) {
+    const e2 = t3.chart,
+        i2 = e2.options.animation;
+    Si(i2 && i2.onProgress, [t3], e2);
+}
+
+function pa(t3) {
+    return cr() && "string" == typeof t3 ? t3 = document.getElementById(t3) : t3 && t3.length && (t3 = t3[0]), t3 && t3.canvas && (t3 = t3.canvas), t3;
+}
+const ma = {},
+    ga = (t3) => {
+        const e2 = pa(t3);
+        return Object.values(ma).filter((t4) => t4.canvas === e2).pop();
+    };
+
+function ya(t3, e2, i2) {
+    const s2 = Object.keys(t3);
+    for (const n2 of s2) {
+        const s3 = +n2;
+        if (s3 >= e2) {
+            const r2 = t3[n2];
+            delete t3[n2], (i2 > 0 || s3 > e2) && (t3[s3 + i2] = r2);
+        }
+    }
+}
+
+function va(t3, e2, i2) {
+    return t3.options.clip ? t3[i2] : e2[i2];
+}
+class Chart {
+    static register(...t3) {
+        qo.add(...t3), ba();
+    }
+    static unregister(...t3) {
+        qo.remove(...t3), ba();
+    }
+    constructor(t3, e2) {
+        const i2 = this.config = new Config(e2),
+            s2 = pa(t3),
+            n2 = ga(s2);
+        if (n2)
+            throw new Error("Canvas is already in use. Chart with ID '" + n2.id + "' must be destroyed before the canvas with ID '" + n2.canvas.id + "' can be reused.");
+        const r2 = i2.createResolver(i2.chartOptionScopes(), this.getContext());
+        this.platform = new(i2.platform || function(t4) {
+            return !cr() || "undefined" != typeof OffscreenCanvas && t4 instanceof OffscreenCanvas ? BasicPlatform : DomPlatform;
+        }(s2))(), this.platform.updateConfig(i2);
+        const o2 = this.platform.acquireContext(s2, r2.aspectRatio),
+            a2 = o2 && o2.canvas,
+            l2 = a2 && a2.height,
+            h2 = a2 && a2.width;
+        this.id = hi(), this.ctx = o2, this.canvas = a2, this.width = h2, this.height = l2, this._options = r2, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new PluginService(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = false, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = function(t4, e3) {
+            let i3;
+            return function(...s3) {
+                return e3 ? (clearTimeout(i3), i3 = setTimeout(t4, e3, s3)) : t4.apply(this, s3), e3;
+            };
+        }((t4) => this.update(t4), r2.resizeDelay || 0), this._dataChanges = [], ma[this.id] = this, o2 && a2 ? (Dr.listen(this, "complete", da), Dr.listen(this, "progress", fa), this._initialize(), this.attached && this.update()) : console.error("Failed to create chart: can't acquire context from the given item");
+    }
+    get aspectRatio() {
+        const {
+            options: {
+                aspectRatio: t3,
+                maintainAspectRatio: e2
+            },
+            width: i2,
+            height: s2,
+            _aspectRatio: n2
+        } = this;
+        return ci(t3) ? e2 && n2 ? n2 : s2 ? i2 / s2 : null : t3;
+    }
+    get data() {
+        return this.config.data;
+    }
+    set data(t3) {
+        this.config.data = t3;
+    }
+    get options() {
+        return this._options;
+    }
+    set options(t3) {
+        this.config.options = t3;
+    }
+    get registry() {
+        return qo;
+    }
+    _initialize() {
+        return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : _r(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
+    }
+    clear() {
+        return en(this.canvas, this.ctx), this;
+    }
+    stop() {
+        return Dr.stop(this), this;
+    }
+    resize(t3, e2) {
+        Dr.running(this) ? this._resizeBeforeDraw = {
+            width: t3,
+            height: e2
+        } : this._resize(t3, e2);
+    }
+    _resize(t3, e2) {
+        const i2 = this.options,
+            s2 = this.canvas,
+            n2 = i2.maintainAspectRatio && this.aspectRatio,
+            r2 = this.platform.getMaximumSize(s2, t3, e2, n2),
+            o2 = i2.devicePixelRatio || this.platform.getDevicePixelRatio(),
+            a2 = this.width ? "resize" : "attach";
+        this.width = r2.width, this.height = r2.height, this._aspectRatio = this.aspectRatio, _r(this, o2, true) && (this.notifyPlugins("resize", {
+            size: r2
+        }), Si(i2.onResize, [this, r2], this), this.attached && this._doResize(a2) && this.render());
+    }
+    ensureScalesHaveIDs() {
+        Ei(this.options.scales || {}, (t3, e2) => {
+            t3.id = e2;
+        });
+    }
+    buildOrUpdateScales() {
+        const t3 = this.options,
+            e2 = t3.scales,
+            i2 = this.scales,
+            s2 = Object.keys(i2).reduce((t4, e3) => (t4[e3] = false, t4), {});
+        let n2 = [];
+        e2 && (n2 = n2.concat(Object.keys(e2).map((t4) => {
+            const i3 = e2[t4],
+                s3 = Jo(t4, i3),
+                n3 = "r" === s3,
+                r2 = "x" === s3;
+            return {
+                options: i3,
+                dposition: n3 ? "chartArea" : r2 ? "bottom" : "left",
+                dtype: n3 ? "radialLinear" : r2 ? "category" : "linear"
+            };
+        }))), Ei(n2, (e3) => {
+            const n3 = e3.options,
+                r2 = n3.id,
+                o2 = Jo(r2, n3),
+                a2 = Ti(n3.type, e3.dtype);
+            void 0 !== n3.position && ca(n3.position, o2) === ca(e3.dposition) || (n3.position = e3.dposition), s2[r2] = true;
+            let l2 = null;
+            if (r2 in i2 && i2[r2].type === a2)
+                l2 = i2[r2];
+            else {
+                l2 = new(qo.getScale(a2))({
+                    id: r2,
+                    type: a2,
+                    ctx: this.ctx,
+                    chart: this
+                }), i2[l2.id] = l2;
+            }
+            l2.init(n3, t3);
+        }), Ei(s2, (t4, e3) => {
+            t4 || delete i2[e3];
+        }), Ei(i2, (t4) => {
+            xo.configure(this, t4, t4.options), xo.addBox(this, t4);
+        });
+    }
+    _updateMetasets() {
+        const t3 = this._metasets,
+            e2 = this.data.datasets.length,
+            i2 = t3.length;
+        if (t3.sort((t4, e3) => t4.index - e3.index), i2 > e2) {
+            for (let t4 = e2; t4 < i2; ++t4)
+                this._destroyDatasetMeta(t4);
+            t3.splice(e2, i2 - e2);
+        }
+        this._sortedMetasets = t3.slice(0).sort(ua("order", "index"));
+    }
+    _removeUnreferencedMetasets() {
+        const {
+            _metasets: t3,
+            data: {
+                datasets: e2
+            }
+        } = this;
+        t3.length > e2.length && delete this._stacks, t3.forEach((t4, i2) => {
+            0 === e2.filter((e3) => e3 === t4._dataset).length && this._destroyDatasetMeta(i2);
+        });
+    }
+    buildOrUpdateControllers() {
+        const t3 = [],
+            e2 = this.data.datasets;
+        let i2, s2;
+        for (this._removeUnreferencedMetasets(), i2 = 0, s2 = e2.length; i2 < s2; i2++) {
+            const s3 = e2[i2];
+            let n2 = this.getDatasetMeta(i2);
+            const r2 = s3.type || this.config.type;
+            if (n2.type && n2.type !== r2 && (this._destroyDatasetMeta(i2), n2 = this.getDatasetMeta(i2)), n2.type = r2, n2.indexAxis = s3.indexAxis || Yo(r2, this.options), n2.order = s3.order || 0, n2.index = i2, n2.label = "" + s3.label, n2.visible = this.isDatasetVisible(i2), n2.controller)
+                n2.controller.updateIndex(i2), n2.controller.linkScales();
+            else {
+                const e3 = qo.getController(r2),
+                    {
+                        datasetElementType: s4,
+                        dataElementType: o2
+                    } = Js.datasets[r2];
+                Object.assign(e3, {
+                    dataElementType: qo.getElement(o2),
+                    datasetElementType: s4 && qo.getElement(s4)
+                }), n2.controller = new e3(this, i2), t3.push(n2.controller);
+            }
+        }
+        return this._updateMetasets(), t3;
+    }
+    _resetElements() {
+        Ei(this.data.datasets, (t3, e2) => {
+            this.getDatasetMeta(e2).controller.reset();
+        }, this);
+    }
+    reset() {
+        this._resetElements(), this.notifyPlugins("reset");
+    }
+    update(t3) {
+        const e2 = this.config;
+        e2.update();
+        const i2 = this._options = e2.createResolver(e2.chartOptionScopes(), this.getContext()),
+            s2 = this._animationsDisabled = !i2.animation;
+        if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), false === this.notifyPlugins("beforeUpdate", {
+                mode: t3,
+                cancelable: true
+            }))
+            return;
+        const n2 = this.buildOrUpdateControllers();
+        this.notifyPlugins("beforeElementsUpdate");
+        let r2 = 0;
+        for (let t4 = 0, e3 = this.data.datasets.length; t4 < e3; t4++) {
+            const {
+                controller: e4
+            } = this.getDatasetMeta(t4), i3 = !s2 && -1 === n2.indexOf(e4);
+            e4.buildOrUpdateElements(i3), r2 = Math.max(+e4.getMaxOverflow(), r2);
+        }
+        r2 = this._minPadding = i2.layout.autoPadding ? r2 : 0, this._updateLayout(r2), s2 || Ei(n2, (t4) => {
+            t4.reset();
+        }), this._updateDatasets(t3), this.notifyPlugins("afterUpdate", {
+            mode: t3
+        }), this._layers.sort(ua("z", "_idx"));
+        const {
+            _active: o2,
+            _lastEvent: a2
+        } = this;
+        a2 ? this._eventHandler(a2, true) : o2.length && this._updateHoverStyles(o2, o2, true), this.render();
+    }
+    _updateScales() {
+        Ei(this.scales, (t3) => {
+            xo.removeBox(this, t3);
+        }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
+    }
+    _checkEventBindings() {
+        const t3 = this.options,
+            e2 = new Set(Object.keys(this._listeners)),
+            i2 = new Set(t3.events);
+        Yi(e2, i2) && !!this._responsiveListeners === t3.responsive || (this.unbindEvents(), this.bindEvents());
+    }
+    _updateHiddenIndices() {
+        const {
+            _hiddenIndices: t3
+        } = this, e2 = this._getUniformDataChanges() || [];
+        for (const {
+                method: i2,
+                start: s2,
+                count: n2
+            }
+            of e2) {
+            ya(t3, s2, "_removeElements" === i2 ? -n2 : n2);
+        }
+    }
+    _getUniformDataChanges() {
+        const t3 = this._dataChanges;
+        if (!t3 || !t3.length)
+            return;
+        this._dataChanges = [];
+        const e2 = this.data.datasets.length,
+            i2 = (e3) => new Set(t3.filter((t4) => t4[0] === e3).map((t4, e4) => e4 + "," + t4.splice(1).join(","))),
+            s2 = i2(0);
+        for (let t4 = 1; t4 < e2; t4++)
+            if (!Yi(s2, i2(t4)))
+                return;
+        return Array.from(s2).map((t4) => t4.split(",")).map((t4) => ({
+            method: t4[1],
+            start: +t4[2],
+            count: +t4[3]
+        }));
+    }
+    _updateLayout(t3) {
+        if (false === this.notifyPlugins("beforeLayout", {
+                cancelable: true
+            }))
+            return;
+        xo.update(this, this.width, this.height, t3);
+        const e2 = this.chartArea,
+            i2 = e2.width <= 0 || e2.height <= 0;
+        this._layers = [], Ei(this.boxes, (t4) => {
+            i2 && "chartArea" === t4.position || (t4.configure && t4.configure(), this._layers.push(...t4._layers()));
+        }, this), this._layers.forEach((t4, e3) => {
+            t4._idx = e3;
+        }), this.notifyPlugins("afterLayout");
+    }
+    _updateDatasets(t3) {
+        if (false !== this.notifyPlugins("beforeDatasetsUpdate", {
+                mode: t3,
+                cancelable: true
+            })) {
+            for (let t4 = 0, e2 = this.data.datasets.length; t4 < e2; ++t4)
+                this.getDatasetMeta(t4).controller.configure();
+            for (let e2 = 0, i2 = this.data.datasets.length; e2 < i2; ++e2)
+                this._updateDataset(e2, Gi(t3) ? t3({
+                    datasetIndex: e2
+                }) : t3);
+            this.notifyPlugins("afterDatasetsUpdate", {
+                mode: t3
+            });
+        }
+    }
+    _updateDataset(t3, e2) {
+        const i2 = this.getDatasetMeta(t3),
+            s2 = {
+                meta: i2,
+                index: t3,
+                mode: e2,
+                cancelable: true
+            };
+        false !== this.notifyPlugins("beforeDatasetUpdate", s2) && (i2.controller._update(e2), s2.cancelable = false, this.notifyPlugins("afterDatasetUpdate", s2));
+    }
+    render() {
+        false !== this.notifyPlugins("beforeRender", {
+            cancelable: true
+        }) && (Dr.has(this) ? this.attached && !Dr.running(this) && Dr.start(this) : (this.draw(), da({
+            chart: this
+        })));
+    }
+    draw() {
+        let t3;
+        if (this._resizeBeforeDraw) {
+            const {
+                width: t4,
+                height: e3
+            } = this._resizeBeforeDraw;
+            this._resize(t4, e3), this._resizeBeforeDraw = null;
+        }
+        if (this.clear(), this.width <= 0 || this.height <= 0)
+            return;
+        if (false === this.notifyPlugins("beforeDraw", {
+                cancelable: true
+            }))
+            return;
+        const e2 = this._layers;
+        for (t3 = 0; t3 < e2.length && e2[t3].z <= 0; ++t3)
+            e2[t3].draw(this.chartArea);
+        for (this._drawDatasets(); t3 < e2.length; ++t3)
+            e2[t3].draw(this.chartArea);
+        this.notifyPlugins("afterDraw");
+    }
+    _getSortedDatasetMetas(t3) {
+        const e2 = this._sortedMetasets,
+            i2 = [];
+        let s2, n2;
+        for (s2 = 0, n2 = e2.length; s2 < n2; ++s2) {
+            const n3 = e2[s2];
+            t3 && !n3.visible || i2.push(n3);
+        }
+        return i2;
+    }
+    getSortedVisibleDatasetMetas() {
+        return this._getSortedDatasetMetas(true);
+    }
+    _drawDatasets() {
+        if (false === this.notifyPlugins("beforeDatasetsDraw", {
+                cancelable: true
+            }))
+            return;
+        const t3 = this.getSortedVisibleDatasetMetas();
+        for (let e2 = t3.length - 1; e2 >= 0; --e2)
+            this._drawDataset(t3[e2]);
+        this.notifyPlugins("afterDatasetsDraw");
+    }
+    _drawDataset(t3) {
+        const e2 = this.ctx,
+            i2 = t3._clip,
+            s2 = !i2.disabled,
+            n2 = function(t4, e3) {
+                const {
+                    xScale: i3,
+                    yScale: s3
+                } = t4;
+                return i3 && s3 ? {
+                    left: va(i3, e3, "left"),
+                    right: va(i3, e3, "right"),
+                    top: va(s3, e3, "top"),
+                    bottom: va(s3, e3, "bottom")
+                } : e3;
+            }(t3, this.chartArea),
+            r2 = {
+                meta: t3,
+                index: t3.index,
+                cancelable: true
+            };
+        false !== this.notifyPlugins("beforeDatasetDraw", r2) && (s2 && ln(e2, {
+            left: false === i2.left ? 0 : n2.left - i2.left,
+            right: false === i2.right ? this.width : n2.right + i2.right,
+            top: false === i2.top ? 0 : n2.top - i2.top,
+            bottom: false === i2.bottom ? this.height : n2.bottom + i2.bottom
+        }), t3.controller.draw(), s2 && un(e2), r2.cancelable = false, this.notifyPlugins("afterDatasetDraw", r2));
+    }
+    isPointInArea(t3) {
+        return nn(t3, this.chartArea, this._minPadding);
+    }
+    getElementsAtEventForMode(t3, e2, i2, s2) {
+        const n2 = lo.modes[e2];
+        return "function" == typeof n2 ? n2(this, t3, i2, s2) : [];
+    }
+    getDatasetMeta(t3) {
+        const e2 = this.data.datasets[t3],
+            i2 = this._metasets;
+        let s2 = i2.filter((t4) => t4 && t4._dataset === e2).pop();
+        return s2 || (s2 = {
+            type: null,
+            data: [],
+            dataset: null,
+            controller: null,
+            hidden: null,
+            xAxisID: null,
+            yAxisID: null,
+            order: e2 && e2.order || 0,
+            index: t3,
+            _dataset: e2,
+            _parsed: [],
+            _sorted: false
+        }, i2.push(s2)), s2;
+    }
+    getContext() {
+        return this.$context || (this.$context = $n(null, {
+            chart: this,
+            type: "chart"
+        }));
+    }
+    getVisibleDatasetCount() {
+        return this.getSortedVisibleDatasetMetas().length;
+    }
+    isDatasetVisible(t3) {
+        const e2 = this.data.datasets[t3];
+        if (!e2)
+            return false;
+        const i2 = this.getDatasetMeta(t3);
+        return "boolean" == typeof i2.hidden ? !i2.hidden : !e2.hidden;
+    }
+    setDatasetVisibility(t3, e2) {
+        this.getDatasetMeta(t3).hidden = !e2;
+    }
+    toggleDataVisibility(t3) {
+        this._hiddenIndices[t3] = !this._hiddenIndices[t3];
+    }
+    getDataVisibility(t3) {
+        return !this._hiddenIndices[t3];
+    }
+    _updateVisibility(t3, e2, i2) {
+        const s2 = i2 ? "show" : "hide",
+            n2 = this.getDatasetMeta(t3),
+            r2 = n2.controller._resolveAnimations(void 0, s2);
+        qi(e2) ? (n2.data[e2].hidden = !i2, this.update()) : (this.setDatasetVisibility(t3, i2), r2.update(n2, {
+            visible: i2
+        }), this.update((e3) => e3.datasetIndex === t3 ? s2 : void 0));
+    }
+    hide(t3, e2) {
+        this._updateVisibility(t3, e2, false);
+    }
+    show(t3, e2) {
+        this._updateVisibility(t3, e2, true);
+    }
+    _destroyDatasetMeta(t3) {
+        const e2 = this._metasets[t3];
+        e2 && e2.controller && e2.controller._destroy(), delete this._metasets[t3];
+    }
+    _stop() {
+        let t3, e2;
+        for (this.stop(), Dr.remove(this), t3 = 0, e2 = this.data.datasets.length; t3 < e2; ++t3)
+            this._destroyDatasetMeta(t3);
+    }
+    destroy() {
+        this.notifyPlugins("beforeDestroy");
+        const {
+            canvas: t3,
+            ctx: e2
+        } = this;
+        this._stop(), this.config.clearCache(), t3 && (this.unbindEvents(), en(t3, e2), this.platform.releaseContext(e2), this.canvas = null, this.ctx = null), delete ma[this.id], this.notifyPlugins("afterDestroy");
+    }
+    toBase64Image(...t3) {
+        return this.canvas.toDataURL(...t3);
+    }
+    bindEvents() {
+        this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = true;
+    }
+    bindUserEvents() {
+        const t3 = this._listeners,
+            e2 = this.platform,
+            i2 = (i3, s3) => {
+                e2.addEventListener(this, i3, s3), t3[i3] = s3;
+            },
+            s2 = (t4, e3, i3) => {
+                t4.offsetX = e3, t4.offsetY = i3, this._eventHandler(t4);
+            };
+        Ei(this.options.events, (t4) => i2(t4, s2));
+    }
+    bindResponsiveEvents() {
+        this._responsiveListeners || (this._responsiveListeners = {});
+        const t3 = this._responsiveListeners,
+            e2 = this.platform,
+            i2 = (i3, s3) => {
+                e2.addEventListener(this, i3, s3), t3[i3] = s3;
+            },
+            s2 = (i3, s3) => {
+                t3[i3] && (e2.removeEventListener(this, i3, s3), delete t3[i3]);
+            },
+            n2 = (t4, e3) => {
+                this.canvas && this.resize(t4, e3);
+            };
+        let r2;
+        const o2 = () => {
+            s2("attach", o2), this.attached = true, this.resize(), i2("resize", n2), i2("detach", r2);
+        };
+        r2 = () => {
+            this.attached = false, s2("resize", n2), this._stop(), this._resize(0, 0), i2("attach", o2);
+        }, e2.isAttached(this.canvas) ? o2() : r2();
+    }
+    unbindEvents() {
+        Ei(this._listeners, (t3, e2) => {
+            this.platform.removeEventListener(this, e2, t3);
+        }), this._listeners = {}, Ei(this._responsiveListeners, (t3, e2) => {
+            this.platform.removeEventListener(this, e2, t3);
+        }), this._responsiveListeners = void 0;
+    }
+    updateHoverStyle(t3, e2, i2) {
+        const s2 = i2 ? "set" : "remove";
+        let n2, r2, o2, a2;
+        for ("dataset" === e2 && (n2 = this.getDatasetMeta(t3[0].datasetIndex), n2.controller["_" + s2 + "DatasetHoverStyle"]()), o2 = 0, a2 = t3.length; o2 < a2; ++o2) {
+            r2 = t3[o2];
+            const e3 = r2 && this.getDatasetMeta(r2.datasetIndex).controller;
+            e3 && e3[s2 + "HoverStyle"](r2.element, r2.datasetIndex, r2.index);
+        }
+    }
+    getActiveElements() {
+        return this._active || [];
+    }
+    setActiveElements(t3) {
+        const e2 = this._active || [],
+            i2 = t3.map(({
+                datasetIndex: t4,
+                index: e3
+            }) => {
+                const i3 = this.getDatasetMeta(t4);
+                if (!i3)
+                    throw new Error("No dataset found at index " + t4);
+                return {
+                    datasetIndex: t4,
+                    element: i3.data[e3],
+                    index: e3
+                };
+            });
+        !Ii(i2, e2) && (this._active = i2, this._lastEvent = null, this._updateHoverStyles(i2, e2));
+    }
+    notifyPlugins(t3, e2, i2) {
+        return this._plugins.notify(this, t3, e2, i2);
+    }
+    isPluginEnabled(t3) {
+        return 1 === this._plugins._cache.filter((e2) => e2.plugin.id === t3).length;
+    }
+    _updateHoverStyles(t3, e2, i2) {
+        const s2 = this.options.hover,
+            n2 = (t4, e3) => t4.filter((t5) => !e3.some((e4) => t5.datasetIndex === e4.datasetIndex && t5.index === e4.index)),
+            r2 = n2(e2, t3),
+            o2 = i2 ? t3 : n2(t3, e2);
+        r2.length && this.updateHoverStyle(r2, s2.mode, false), o2.length && s2.mode && this.updateHoverStyle(o2, s2.mode, true);
+    }
+    _eventHandler(t3, e2) {
+        const i2 = {
+                event: t3,
+                replay: e2,
+                cancelable: true,
+                inChartArea: this.isPointInArea(t3)
+            },
+            s2 = (e3) => (e3.options.events || this.options.events).includes(t3.native.type);
+        if (false === this.notifyPlugins("beforeEvent", i2, s2))
+            return;
+        const n2 = this._handleEvent(t3, e2, i2.inChartArea);
+        return i2.cancelable = false, this.notifyPlugins("afterEvent", i2, s2), (n2 || i2.changed) && this.render(), this;
+    }
+    _handleEvent(t3, e2, i2) {
+        const {
+            _active: s2 = [],
+            options: n2
+        } = this, r2 = e2, o2 = this._getActiveElements(t3, s2, i2, r2), a2 = function(t4) {
+            return "mouseup" === t4.type || "click" === t4.type || "contextmenu" === t4.type;
+        }(t3), l2 = function(t4, e3, i3, s3) {
+            return i3 && "mouseout" !== t4.type ? s3 ? e3 : t4 : null;
+        }(t3, this._lastEvent, i2, a2);
+        i2 && (this._lastEvent = null, Si(n2.onHover, [t3, o2, this], this), a2 && Si(n2.onClick, [t3, o2, this], this));
+        const h2 = !Ii(o2, s2);
+        return (h2 || e2) && (this._active = o2, this._updateHoverStyles(o2, s2, e2)), this._lastEvent = l2, h2;
+    }
+    _getActiveElements(t3, e2, i2, s2) {
+        if ("mouseout" === t3.type)
+            return [];
+        if (!i2)
+            return e2;
+        const n2 = this.options.hover;
+        return this.getElementsAtEventForMode(t3, n2.mode, n2, s2);
+    }
+}
+__publicField(Chart, "defaults", Js);
+__publicField(Chart, "instances", ma);
+__publicField(Chart, "overrides", Gs);
+__publicField(Chart, "registry", qo);
+__publicField(Chart, "version", "4.4.0");
+__publicField(Chart, "getChart", ga);
+
+function ba() {
+    return Ei(Chart.instances, (t3) => t3._plugins.invalidate());
+}
+
+function _a(t3, e2, i2 = e2) {
+    t3.lineCap = Ti(i2.borderCapStyle, e2.borderCapStyle), t3.setLineDash(Ti(i2.borderDash, e2.borderDash)), t3.lineDashOffset = Ti(i2.borderDashOffset, e2.borderDashOffset), t3.lineJoin = Ti(i2.borderJoinStyle, e2.borderJoinStyle), t3.lineWidth = Ti(i2.borderWidth, e2.borderWidth), t3.strokeStyle = Ti(i2.borderColor, e2.borderColor);
+}
+
+function wa(t3, e2, i2) {
+    t3.lineTo(i2.x, i2.y);
+}
+
+function xa(t3, e2, i2 = {}) {
+    const s2 = t3.length,
+        {
+            start: n2 = 0,
+            end: r2 = s2 - 1
+        } = i2,
+        {
+            start: o2,
+            end: a2
+        } = e2,
+        l2 = Math.max(n2, o2),
+        h2 = Math.min(r2, a2),
+        c2 = n2 < o2 && r2 < o2 || n2 > a2 && r2 > a2;
+    return {
+        count: s2,
+        start: l2,
+        loop: e2.loop,
+        ilen: h2 < l2 && !c2 ? s2 + h2 - l2 : h2 - l2
+    };
+}
+
+function ka(t3, e2, i2, s2) {
+    const {
+        points: n2,
+        options: r2
+    } = e2, {
+        count: o2,
+        start: a2,
+        loop: l2,
+        ilen: h2
+    } = xa(n2, i2, s2), c2 = function(t4) {
+        return t4.stepped ? fn : t4.tension || "monotone" === t4.cubicInterpolationMode ? pn : wa;
+    }(r2);
+    let u2, d2, f2, {
+        move: p2 = true,
+        reverse: m2
+    } = s2 || {};
+    for (u2 = 0; u2 <= h2; ++u2)
+        d2 = n2[(a2 + (m2 ? h2 - u2 : u2)) % o2], d2.skip || (p2 ? (t3.moveTo(d2.x, d2.y), p2 = false) : c2(t3, f2, d2, m2, r2.stepped), f2 = d2);
+    return l2 && (d2 = n2[(a2 + (m2 ? h2 : 0)) % o2], c2(t3, f2, d2, m2, r2.stepped)), !!l2;
+}
+
+function Ta(t3, e2, i2, s2) {
+    const n2 = e2.points,
+        {
+            count: r2,
+            start: o2,
+            ilen: a2
+        } = xa(n2, i2, s2),
+        {
+            move: l2 = true,
+            reverse: h2
+        } = s2 || {};
+    let c2, u2, d2, f2, p2, m2, g2 = 0,
+        y2 = 0;
+    const v2 = (t4) => (o2 + (h2 ? a2 - t4 : t4)) % r2,
+        b2 = () => {
+            f2 !== p2 && (t3.lineTo(g2, p2), t3.lineTo(g2, f2), t3.lineTo(g2, m2));
+        };
+    for (l2 && (u2 = n2[v2(0)], t3.moveTo(u2.x, u2.y)), c2 = 0; c2 <= a2; ++c2) {
+        if (u2 = n2[v2(c2)], u2.skip)
+            continue;
+        const e3 = u2.x,
+            i3 = u2.y,
+            s3 = 0 | e3;
+        s3 === d2 ? (i3 < f2 ? f2 = i3 : i3 > p2 && (p2 = i3), g2 = (y2 * g2 + e3) / ++y2) : (b2(), t3.lineTo(e3, i3), d2 = s3, y2 = 0, f2 = p2 = i3), m2 = i3;
+    }
+    b2();
+}
+
+function Sa(t3) {
+    const e2 = t3.options,
+        i2 = e2.borderDash && e2.borderDash.length;
+    return !(t3._decimated || t3._loop || e2.tension || "monotone" === e2.cubicInterpolationMode || e2.stepped || i2) ? Ta : ka;
+}
+const Ea = "function" == typeof Path2D;
+
+function Ca(t3, e2, i2, s2) {
+    Ea && !e2.options.segment ? function(t4, e3, i3, s3) {
+        let n2 = e3._path;
+        n2 || (n2 = e3._path = new Path2D(), e3.path(n2, i3, s3) && n2.closePath()), _a(t4, e3.options), t4.stroke(n2);
+    }(t3, e2, i2, s2) : function(t4, e3, i3, s3) {
+        const {
+            segments: n2,
+            options: r2
+        } = e3, o2 = Sa(e3);
+        for (const a2 of n2)
+            _a(t4, r2, a2.style), t4.beginPath(), o2(t4, e3, a2, {
+                start: i3,
+                end: i3 + s3 - 1
+            }) && t4.closePath(), t4.stroke();
+    }(t3, e2, i2, s2);
+}
+class LineElement extends Element {
+    constructor(t3) {
+        super(), this.animated = true, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = false, this._pointsUpdated = false, this._datasetIndex = void 0, t3 && Object.assign(this, t3);
+    }
+    updateControlPoints(t3, e2) {
+        const i2 = this.options;
+        if ((i2.tension || "monotone" === i2.cubicInterpolationMode) && !i2.stepped && !this._pointsUpdated) {
+            const s2 = i2.spanGaps ? this._loop : this._fullLoop;
+            hr(this._points, i2, t3, s2, e2), this._pointsUpdated = true;
+        }
+    }
+    set points(t3) {
+        this._points = t3, delete this._segments, delete this._path, this._pointsUpdated = false;
+    }
+    get points() {
+        return this._points;
+    }
+    get segments() {
+        return this._segments || (this._segments = function(t3, e2) {
+            const i2 = t3.points,
+                s2 = t3.options.spanGaps,
+                n2 = i2.length;
+            if (!n2)
+                return [];
+            const r2 = !!t3._loop,
+                {
+                    start: o2,
+                    end: a2
+                } = function(t4, e3, i3, s3) {
+                    let n3 = 0,
+                        r3 = e3 - 1;
+                    if (i3 && !s3)
+                        for (; n3 < e3 && !t4[n3].skip;)
+                            n3++;
+                    for (; n3 < e3 && t4[n3].skip;)
+                        n3++;
+                    for (n3 %= e3, i3 && (r3 += n3); r3 > n3 && t4[r3 % e3].skip;)
+                        r3--;
+                    return r3 %= e3, {
+                        start: n3,
+                        end: r3
+                    };
+                }(i2, n2, r2, s2);
+            return Pr(t3, true === s2 ? [{
+                start: o2,
+                end: a2,
+                loop: r2
+            }] : function(t4, e3, i3, s3) {
+                const n3 = t4.length,
+                    r3 = [];
+                let o3, a3 = e3,
+                    l2 = t4[e3];
+                for (o3 = e3 + 1; o3 <= i3; ++o3) {
+                    const i4 = t4[o3 % n3];
+                    i4.skip || i4.stop ? l2.skip || (s3 = false, r3.push({
+                        start: e3 % n3,
+                        end: (o3 - 1) % n3,
+                        loop: s3
+                    }), e3 = a3 = i4.stop ? o3 : null) : (a3 = o3, l2.skip && (e3 = o3)), l2 = i4;
+                }
+                return null !== a3 && r3.push({
+                    start: e3 % n3,
+                    end: a3 % n3,
+                    loop: s3
+                }), r3;
+            }(i2, o2, a2 < o2 ? a2 + n2 : a2, !!t3._fullLoop && 0 === o2 && a2 === n2 - 1), i2, e2);
+        }(this, this.options.segment));
+    }
+    first() {
+        const t3 = this.segments,
+            e2 = this.points;
+        return t3.length && e2[t3[0].start];
+    }
+    last() {
+        const t3 = this.segments,
+            e2 = this.points,
+            i2 = t3.length;
+        return i2 && e2[t3[i2 - 1].end];
+    }
+    interpolate(t3, e2) {
+        const i2 = this.options,
+            s2 = t3[e2],
+            n2 = this.points,
+            r2 = function(t4, e3) {
+                const i3 = [],
+                    s3 = t4.segments;
+                for (let n3 = 0; n3 < s3.length; n3++) {
+                    const r3 = Mr(s3[n3], t4.points, e3);
+                    r3.length && i3.push(...r3);
+                }
+                return i3;
+            }(this, {
+                property: e2,
+                start: s2,
+                end: s2
+            });
+        if (!r2.length)
+            return;
+        const o2 = [],
+            a2 = function(t4) {
+                return t4.stepped ? Tr : t4.tension || "monotone" === t4.cubicInterpolationMode ? Sr : kr;
+            }(i2);
+        let l2, h2;
+        for (l2 = 0, h2 = r2.length; l2 < h2; ++l2) {
+            const {
+                start: h3,
+                end: c2
+            } = r2[l2], u2 = n2[h3], d2 = n2[c2];
+            if (u2 === d2) {
+                o2.push(u2);
+                continue;
+            }
+            const f2 = a2(u2, d2, Math.abs((s2 - u2[e2]) / (d2[e2] - u2[e2])), i2.stepped);
+            f2[e2] = t3[e2], o2.push(f2);
+        }
+        return 1 === o2.length ? o2[0] : o2;
+    }
+    pathSegment(t3, e2, i2) {
+        return Sa(this)(t3, this, e2, i2);
+    }
+    path(t3, e2, i2) {
+        const s2 = this.segments,
+            n2 = Sa(this);
+        let r2 = this._loop;
+        e2 = e2 || 0, i2 = i2 || this.points.length - e2;
+        for (const o2 of s2)
+            r2 &= n2(t3, this, o2, {
+                start: e2,
+                end: e2 + i2 - 1
+            });
+        return !!r2;
+    }
+    draw(t3, e2, i2, s2) {
+        const n2 = this.options || {};
+        (this.points || []).length && n2.borderWidth && (t3.save(), Ca(t3, this, i2, s2), t3.restore()), this.animated && (this._pointsUpdated = false, this._path = void 0);
+    }
+}
+__publicField(LineElement, "id", "line");
+__publicField(LineElement, "defaults", {
+    borderCapStyle: "butt",
+    borderDash: [],
+    borderDashOffset: 0,
+    borderJoinStyle: "miter",
+    borderWidth: 3,
+    capBezierPoints: true,
+    cubicInterpolationMode: "default",
+    fill: false,
+    spanGaps: false,
+    stepped: false,
+    tension: 0
+});
+__publicField(LineElement, "defaultRoutes", {
+    backgroundColor: "backgroundColor",
+    borderColor: "borderColor"
+});
+__publicField(LineElement, "descriptors", {
+    _scriptable: true,
+    _indexable: (t3) => "borderDash" !== t3 && "fill" !== t3
+});
+
+function Ia(t3, e2, i2, s2) {
+    const n2 = t3.options,
+        {
+            [i2]: r2
+        } = t3.getProps([i2], s2);
+    return Math.abs(e2 - r2) < n2.radius + n2.hitRadius;
+}
+class PointElement extends Element {
+    constructor(t3) {
+        super();
+        __publicField(this, "parsed");
+        __publicField(this, "skip");
+        __publicField(this, "stop");
+        this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t3 && Object.assign(this, t3);
+    }
+    inRange(t3, e2, i2) {
+        const s2 = this.options,
+            {
+                x: n2,
+                y: r2
+            } = this.getProps(["x", "y"], i2);
+        return Math.pow(t3 - n2, 2) + Math.pow(e2 - r2, 2) < Math.pow(s2.hitRadius + s2.radius, 2);
+    }
+    inXRange(t3, e2) {
+        return Ia(this, t3, "x", e2);
+    }
+    inYRange(t3, e2) {
+        return Ia(this, t3, "y", e2);
+    }
+    getCenterPoint(t3) {
+        const {
+            x: e2,
+            y: i2
+        } = this.getProps(["x", "y"], t3);
+        return {
+            x: e2,
+            y: i2
+        };
+    }
+    size(t3) {
+        let e2 = (t3 = t3 || this.options || {}).radius || 0;
+        e2 = Math.max(e2, e2 && t3.hoverRadius || 0);
+        return 2 * (e2 + (e2 && t3.borderWidth || 0));
+    }
+    draw(t3, e2) {
+        const i2 = this.options;
+        this.skip || i2.radius < 0.1 || !nn(this, e2, this.size(i2) / 2) || (t3.strokeStyle = i2.borderColor, t3.lineWidth = i2.borderWidth, t3.fillStyle = i2.backgroundColor, sn(t3, i2, this.x, this.y));
+    }
+    getRange() {
+        const t3 = this.options || {};
+        return t3.radius + t3.hitRadius;
+    }
+}
+__publicField(PointElement, "id", "point");
+__publicField(PointElement, "defaults", {
+    borderWidth: 1,
+    hitRadius: 1,
+    hoverBorderWidth: 1,
+    hoverRadius: 4,
+    pointStyle: "circle",
+    radius: 3,
+    rotation: 0
+});
+__publicField(PointElement, "defaultRoutes", {
+    backgroundColor: "backgroundColor",
+    borderColor: "borderColor"
+});
+
+function Ma(t3, e2) {
+    const {
+        x: i2,
+        y: s2,
+        base: n2,
+        width: r2,
+        height: o2
+    } = t3.getProps(["x", "y", "base", "width", "height"], e2);
+    let a2, l2, h2, c2, u2;
+    return t3.horizontal ? (u2 = o2 / 2, a2 = Math.min(i2, n2), l2 = Math.max(i2, n2), h2 = s2 - u2, c2 = s2 + u2) : (u2 = r2 / 2, a2 = i2 - u2, l2 = i2 + u2, h2 = Math.min(s2, n2), c2 = Math.max(s2, n2)), {
+        left: a2,
+        top: h2,
+        right: l2,
+        bottom: c2
+    };
+}
+
+function Pa(t3, e2, i2, s2) {
+    return t3 ? 0 : vs(e2, i2, s2);
+}
+
+function Ra(t3) {
+    const e2 = Ma(t3),
+        i2 = e2.right - e2.left,
+        s2 = e2.bottom - e2.top,
+        n2 = function(t4, e3, i3) {
+            const s3 = t4.options.borderWidth,
+                n3 = t4.borderSkipped,
+                r3 = Rn(s3);
+            return {
+                t: Pa(n3.top, r3.top, 0, i3),
+                r: Pa(n3.right, r3.right, 0, e3),
+                b: Pa(n3.bottom, r3.bottom, 0, i3),
+                l: Pa(n3.left, r3.left, 0, e3)
+            };
+        }(t3, i2 / 2, s2 / 2),
+        r2 = function(t4, e3, i3) {
+            const {
+                enableBorderRadius: s3
+            } = t4.getProps(["enableBorderRadius"]), n3 = t4.options.borderRadius, r3 = Dn(n3), o2 = Math.min(e3, i3), a2 = t4.borderSkipped, l2 = s3 || yi(n3);
+            return {
+                topLeft: Pa(!l2 || a2.top || a2.left, r3.topLeft, 0, o2),
+                topRight: Pa(!l2 || a2.top || a2.right, r3.topRight, 0, o2),
+                bottomLeft: Pa(!l2 || a2.bottom || a2.left, r3.bottomLeft, 0, o2),
+                bottomRight: Pa(!l2 || a2.bottom || a2.right, r3.bottomRight, 0, o2)
+            };
+        }(t3, i2 / 2, s2 / 2);
+    return {
+        outer: {
+            x: e2.left,
+            y: e2.top,
+            w: i2,
+            h: s2,
+            radius: r2
+        },
+        inner: {
+            x: e2.left + n2.l,
+            y: e2.top + n2.t,
+            w: i2 - n2.l - n2.r,
+            h: s2 - n2.t - n2.b,
+            radius: {
+                topLeft: Math.max(0, r2.topLeft - Math.max(n2.t, n2.l)),
+                topRight: Math.max(0, r2.topRight - Math.max(n2.t, n2.r)),
+                bottomLeft: Math.max(0, r2.bottomLeft - Math.max(n2.b, n2.l)),
+                bottomRight: Math.max(0, r2.bottomRight - Math.max(n2.b, n2.r))
+            }
+        }
+    };
+}
+
+function Aa(t3, e2, i2, s2) {
+    const n2 = null === e2,
+        r2 = null === i2,
+        o2 = t3 && !(n2 && r2) && Ma(t3, s2);
+    return o2 && (n2 || bs(e2, o2.left, o2.right)) && (r2 || bs(i2, o2.top, o2.bottom));
+}
+
+function Da(t3, e2) {
+    t3.rect(e2.x, e2.y, e2.w, e2.h);
+}
+
+function La(t3, e2, i2 = {}) {
+    const s2 = t3.x !== i2.x ? -e2 : 0,
+        n2 = t3.y !== i2.y ? -e2 : 0,
+        r2 = (t3.x + t3.w !== i2.x + i2.w ? e2 : 0) - s2,
+        o2 = (t3.y + t3.h !== i2.y + i2.h ? e2 : 0) - n2;
+    return {
+        x: t3.x + s2,
+        y: t3.y + n2,
+        w: t3.w + r2,
+        h: t3.h + o2,
+        radius: t3.radius
+    };
+}
+class BarElement extends Element {
+    constructor(t3) {
+        super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t3 && Object.assign(this, t3);
+    }
+    draw(t3) {
+        const {
+            inflateAmount: e2,
+            options: {
+                borderColor: i2,
+                backgroundColor: s2
+            }
+        } = this, {
+            inner: n2,
+            outer: r2
+        } = Ra(this), o2 = (a2 = r2.radius).topLeft || a2.topRight || a2.bottomLeft || a2.bottomRight ? bn : Da;
+        var a2;
+        t3.save(), r2.w === n2.w && r2.h === n2.h || (t3.beginPath(), o2(t3, La(r2, e2, n2)), t3.clip(), o2(t3, La(n2, -e2, r2)), t3.fillStyle = i2, t3.fill("evenodd")), t3.beginPath(), o2(t3, La(n2, e2)), t3.fillStyle = s2, t3.fill(), t3.restore();
+    }
+    inRange(t3, e2, i2) {
+        return Aa(this, t3, e2, i2);
+    }
+    inXRange(t3, e2) {
+        return Aa(this, t3, null, e2);
+    }
+    inYRange(t3, e2) {
+        return Aa(this, null, t3, e2);
+    }
+    getCenterPoint(t3) {
+        const {
+            x: e2,
+            y: i2,
+            base: s2,
+            horizontal: n2
+        } = this.getProps(["x", "y", "base", "horizontal"], t3);
+        return {
+            x: n2 ? (e2 + s2) / 2 : e2,
+            y: n2 ? i2 : (i2 + s2) / 2
+        };
+    }
+    getRange(t3) {
+        return "x" === t3 ? this.width / 2 : this.height / 2;
+    }
+}
+__publicField(BarElement, "id", "bar");
+__publicField(BarElement, "defaults", {
+    borderSkipped: "start",
+    borderWidth: 0,
+    borderRadius: 0,
+    inflateAmount: "auto",
+    pointStyle: void 0
+});
+__publicField(BarElement, "defaultRoutes", {
+    backgroundColor: "backgroundColor",
+    borderColor: "borderColor"
+});
+const Oa = {
+    average(t3) {
+        if (!t3.length)
+            return false;
+        let e2, i2, s2 = 0,
+            n2 = 0,
+            r2 = 0;
+        for (e2 = 0, i2 = t3.length; e2 < i2; ++e2) {
+            const i3 = t3[e2].element;
+            if (i3 && i3.hasValue()) {
+                const t4 = i3.tooltipPosition();
+                s2 += t4.x, n2 += t4.y, ++r2;
+            }
+        }
+        return {
+            x: s2 / r2,
+            y: n2 / r2
+        };
+    },
+    nearest(t3, e2) {
+        if (!t3.length)
+            return false;
+        let i2, s2, n2, r2 = e2.x,
+            o2 = e2.y,
+            a2 = Number.POSITIVE_INFINITY;
+        for (i2 = 0, s2 = t3.length; i2 < s2; ++i2) {
+            const s3 = t3[i2].element;
+            if (s3 && s3.hasValue()) {
+                const t4 = ps(e2, s3.getCenterPoint());
+                t4 < a2 && (a2 = t4, n2 = s3);
+            }
+        }
+        if (n2) {
+            const t4 = n2.tooltipPosition();
+            r2 = t4.x, o2 = t4.y;
+        }
+        return {
+            x: r2,
+            y: o2
+        };
+    }
+};
+
+function Fa(t3, e2) {
+    return e2 && (ui(e2) ? Array.prototype.push.apply(t3, e2) : t3.push(e2)), t3;
+}
+
+function Na(t3) {
+    return ("string" == typeof t3 || t3 instanceof String) && t3.indexOf("\n") > -1 ? t3.split("\n") : t3;
+}
+
+function $a(t3, e2) {
+    const {
+        element: i2,
+        datasetIndex: s2,
+        index: n2
+    } = e2, r2 = t3.getDatasetMeta(s2).controller, {
+        label: o2,
+        value: a2
+    } = r2.getLabelAndValue(n2);
+    return {
+        chart: t3,
+        label: o2,
+        parsed: r2.getParsed(n2),
+        raw: t3.data.datasets[s2].data[n2],
+        formattedValue: a2,
+        dataset: r2.getDataset(),
+        dataIndex: n2,
+        datasetIndex: s2,
+        element: i2
+    };
+}
+
+function Va(t3, e2) {
+    const i2 = t3.chart.ctx,
+        {
+            body: s2,
+            footer: n2,
+            title: r2
+        } = t3,
+        {
+            boxWidth: o2,
+            boxHeight: a2
+        } = e2,
+        l2 = On(e2.bodyFont),
+        h2 = On(e2.titleFont),
+        c2 = On(e2.footerFont),
+        u2 = r2.length,
+        d2 = n2.length,
+        f2 = s2.length,
+        p2 = Ln(e2.padding);
+    let m2 = p2.height,
+        g2 = 0,
+        y2 = s2.reduce((t4, e3) => t4 + e3.before.length + e3.lines.length + e3.after.length, 0);
+    if (y2 += t3.beforeBody.length + t3.afterBody.length, u2 && (m2 += u2 * h2.lineHeight + (u2 - 1) * e2.titleSpacing + e2.titleMarginBottom), y2) {
+        m2 += f2 * (e2.displayColors ? Math.max(a2, l2.lineHeight) : l2.lineHeight) + (y2 - f2) * l2.lineHeight + (y2 - 1) * e2.bodySpacing;
+    }
+    d2 && (m2 += e2.footerMarginTop + d2 * c2.lineHeight + (d2 - 1) * e2.footerSpacing);
+    let v2 = 0;
+    const b2 = function(t4) {
+        g2 = Math.max(g2, i2.measureText(t4).width + v2);
+    };
+    return i2.save(), i2.font = h2.string, Ei(t3.title, b2), i2.font = l2.string, Ei(t3.beforeBody.concat(t3.afterBody), b2), v2 = e2.displayColors ? o2 + 2 + e2.boxPadding : 0, Ei(s2, (t4) => {
+        Ei(t4.before, b2), Ei(t4.lines, b2), Ei(t4.after, b2);
+    }), v2 = 0, i2.font = c2.string, Ei(t3.footer, b2), i2.restore(), g2 += p2.width, {
+        width: g2,
+        height: m2
+    };
+}
+
+function za(t3, e2, i2, s2) {
+    const {
+        x: n2,
+        width: r2
+    } = i2, {
+        width: o2,
+        chartArea: {
+            left: a2,
+            right: l2
+        }
+    } = t3;
+    let h2 = "center";
+    return "center" === s2 ? h2 = n2 <= (a2 + l2) / 2 ? "left" : "right" : n2 <= r2 / 2 ? h2 = "left" : n2 >= o2 - r2 / 2 && (h2 = "right"),
+        function(t4, e3, i3, s3) {
+            const {
+                x: n3,
+                width: r3
+            } = s3, o3 = i3.caretSize + i3.caretPadding;
+            return "left" === t4 && n3 + r3 + o3 > e3.width || "right" === t4 && n3 - r3 - o3 < 0 || void 0;
+        }(h2, t3, e2, i2) && (h2 = "center"), h2;
+}
+
+function Ba(t3, e2, i2) {
+    const s2 = i2.yAlign || e2.yAlign || function(t4, e3) {
+        const {
+            y: i3,
+            height: s3
+        } = e3;
+        return i3 < s3 / 2 ? "top" : i3 > t4.height - s3 / 2 ? "bottom" : "center";
+    }(t3, i2);
+    return {
+        xAlign: i2.xAlign || e2.xAlign || za(t3, e2, i2, s2),
+        yAlign: s2
+    };
+}
+
+function Ua(t3, e2, i2, s2) {
+    const {
+        caretSize: n2,
+        caretPadding: r2,
+        cornerRadius: o2
+    } = t3, {
+        xAlign: a2,
+        yAlign: l2
+    } = i2, h2 = n2 + r2, {
+        topLeft: c2,
+        topRight: u2,
+        bottomLeft: d2,
+        bottomRight: f2
+    } = Dn(o2);
+    let p2 = function(t4, e3) {
+        let {
+            x: i3,
+            width: s3
+        } = t4;
+        return "right" === e3 ? i3 -= s3 : "center" === e3 && (i3 -= s3 / 2), i3;
+    }(e2, a2);
+    const m2 = function(t4, e3, i3) {
+        let {
+            y: s3,
+            height: n3
+        } = t4;
+        return "top" === e3 ? s3 += i3 : s3 -= "bottom" === e3 ? n3 + i3 : n3 / 2, s3;
+    }(e2, l2, h2);
+    return "center" === l2 ? "left" === a2 ? p2 += h2 : "right" === a2 && (p2 -= h2) : "left" === a2 ? p2 -= Math.max(c2, d2) + n2 : "right" === a2 && (p2 += Math.max(u2, f2) + n2), {
+        x: vs(p2, 0, s2.width - e2.width),
+        y: vs(m2, 0, s2.height - e2.height)
+    };
+}
+
+function ja(t3, e2, i2) {
+    const s2 = Ln(i2.padding);
+    return "center" === e2 ? t3.x + t3.width / 2 : "right" === e2 ? t3.x + t3.width - s2.right : t3.x + s2.left;
+}
+
+function Ha(t3) {
+    return Fa([], Na(t3));
+}
+
+function Wa(t3, e2) {
+    const i2 = e2 && e2.dataset && e2.dataset.tooltip && e2.dataset.tooltip.callbacks;
+    return i2 ? t3.override(i2) : t3;
+}
+const qa = {
+    beforeTitle: li,
+    title(t3) {
+        if (t3.length > 0) {
+            const e2 = t3[0],
+                i2 = e2.chart.data.labels,
+                s2 = i2 ? i2.length : 0;
+            if (this && this.options && "dataset" === this.options.mode)
+                return e2.dataset.label || "";
+            if (e2.label)
+                return e2.label;
+            if (s2 > 0 && e2.dataIndex < s2)
+                return i2[e2.dataIndex];
+        }
+        return "";
+    },
+    afterTitle: li,
+    beforeBody: li,
+    beforeLabel: li,
+    label(t3) {
+        if (this && this.options && "dataset" === this.options.mode)
+            return t3.label + ": " + t3.formattedValue || t3.formattedValue;
+        let e2 = t3.dataset.label || "";
+        e2 && (e2 += ": ");
+        const i2 = t3.formattedValue;
+        return ci(i2) || (e2 += i2), e2;
+    },
+    labelColor(t3) {
+        const e2 = t3.chart.getDatasetMeta(t3.datasetIndex).controller.getStyle(t3.dataIndex);
+        return {
+            borderColor: e2.borderColor,
+            backgroundColor: e2.backgroundColor,
+            borderWidth: e2.borderWidth,
+            borderDash: e2.borderDash,
+            borderDashOffset: e2.borderDashOffset,
+            borderRadius: 0
+        };
+    },
+    labelTextColor() {
+        return this.options.bodyColor;
+    },
+    labelPointStyle(t3) {
+        const e2 = t3.chart.getDatasetMeta(t3.datasetIndex).controller.getStyle(t3.dataIndex);
+        return {
+            pointStyle: e2.pointStyle,
+            rotation: e2.rotation
+        };
+    },
+    afterLabel: li,
+    afterBody: li,
+    beforeFooter: li,
+    footer: li,
+    afterFooter: li
+};
+
+function Ka(t3, e2, i2, s2) {
+    const n2 = t3[e2].call(i2, s2);
+    return void 0 === n2 ? qa[e2].call(i2, s2) : n2;
+}
+class Tooltip extends Element {
+    constructor(t3) {
+        super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t3.chart, this.options = t3.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
+    }
+    initialize(t3) {
+        this.options = t3, this._cachedAnimations = void 0, this.$context = void 0;
+    }
+    _resolveAnimations() {
+        const t3 = this._cachedAnimations;
+        if (t3)
+            return t3;
+        const e2 = this.chart,
+            i2 = this.options.setContext(this.getContext()),
+            s2 = i2.enabled && e2.options.animation && i2.animations,
+            n2 = new Animations(this.chart, s2);
+        return s2._cacheable && (this._cachedAnimations = Object.freeze(n2)), n2;
+    }
+    getContext() {
+        return this.$context || (this.$context = function(t3, e2, i2) {
+            return $n(t3, {
+                tooltip: e2,
+                tooltipItems: i2,
+                type: "tooltip"
+            });
+        }(this.chart.getContext(), this, this._tooltipItems));
+    }
+    getTitle(t3, e2) {
+        const {
+            callbacks: i2
+        } = e2, s2 = Ka(i2, "beforeTitle", this, t3), n2 = Ka(i2, "title", this, t3), r2 = Ka(i2, "afterTitle", this, t3);
+        let o2 = [];
+        return o2 = Fa(o2, Na(s2)), o2 = Fa(o2, Na(n2)), o2 = Fa(o2, Na(r2)), o2;
+    }
+    getBeforeBody(t3, e2) {
+        return Ha(Ka(e2.callbacks, "beforeBody", this, t3));
+    }
+    getBody(t3, e2) {
+        const {
+            callbacks: i2
+        } = e2, s2 = [];
+        return Ei(t3, (t4) => {
+            const e3 = {
+                    before: [],
+                    lines: [],
+                    after: []
+                },
+                n2 = Wa(i2, t4);
+            Fa(e3.before, Na(Ka(n2, "beforeLabel", this, t4))), Fa(e3.lines, Ka(n2, "label", this, t4)), Fa(e3.after, Na(Ka(n2, "afterLabel", this, t4))), s2.push(e3);
+        }), s2;
+    }
+    getAfterBody(t3, e2) {
+        return Ha(Ka(e2.callbacks, "afterBody", this, t3));
+    }
+    getFooter(t3, e2) {
+        const {
+            callbacks: i2
+        } = e2, s2 = Ka(i2, "beforeFooter", this, t3), n2 = Ka(i2, "footer", this, t3), r2 = Ka(i2, "afterFooter", this, t3);
+        let o2 = [];
+        return o2 = Fa(o2, Na(s2)), o2 = Fa(o2, Na(n2)), o2 = Fa(o2, Na(r2)), o2;
+    }
+    _createItems(t3) {
+        const e2 = this._active,
+            i2 = this.chart.data,
+            s2 = [],
+            n2 = [],
+            r2 = [];
+        let o2, a2, l2 = [];
+        for (o2 = 0, a2 = e2.length; o2 < a2; ++o2)
+            l2.push($a(this.chart, e2[o2]));
+        return t3.filter && (l2 = l2.filter((e3, s3, n3) => t3.filter(e3, s3, n3, i2))), t3.itemSort && (l2 = l2.sort((e3, s3) => t3.itemSort(e3, s3, i2))), Ei(l2, (e3) => {
+            const i3 = Wa(t3.callbacks, e3);
+            s2.push(Ka(i3, "labelColor", this, e3)), n2.push(Ka(i3, "labelPointStyle", this, e3)), r2.push(Ka(i3, "labelTextColor", this, e3));
+        }), this.labelColors = s2, this.labelPointStyles = n2, this.labelTextColors = r2, this.dataPoints = l2, l2;
+    }
+    update(t3, e2) {
+        const i2 = this.options.setContext(this.getContext()),
+            s2 = this._active;
+        let n2, r2 = [];
+        if (s2.length) {
+            const t4 = Oa[i2.position].call(this, s2, this._eventPosition);
+            r2 = this._createItems(i2), this.title = this.getTitle(r2, i2), this.beforeBody = this.getBeforeBody(r2, i2), this.body = this.getBody(r2, i2), this.afterBody = this.getAfterBody(r2, i2), this.footer = this.getFooter(r2, i2);
+            const e3 = this._size = Va(this, i2),
+                o2 = Object.assign({}, t4, e3),
+                a2 = Ba(this.chart, i2, o2),
+                l2 = Ua(i2, o2, a2, this.chart);
+            this.xAlign = a2.xAlign, this.yAlign = a2.yAlign, n2 = {
+                opacity: 1,
+                x: l2.x,
+                y: l2.y,
+                width: e3.width,
+                height: e3.height,
+                caretX: t4.x,
+                caretY: t4.y
+            };
+        } else
+            0 !== this.opacity && (n2 = {
+                opacity: 0
+            });
+        this._tooltipItems = r2, this.$context = void 0, n2 && this._resolveAnimations().update(this, n2), t3 && i2.external && i2.external.call(this, {
+            chart: this.chart,
+            tooltip: this,
+            replay: e2
+        });
+    }
+    drawCaret(t3, e2, i2, s2) {
+        const n2 = this.getCaretPosition(t3, i2, s2);
+        e2.lineTo(n2.x1, n2.y1), e2.lineTo(n2.x2, n2.y2), e2.lineTo(n2.x3, n2.y3);
+    }
+    getCaretPosition(t3, e2, i2) {
+        const {
+            xAlign: s2,
+            yAlign: n2
+        } = this, {
+            caretSize: r2,
+            cornerRadius: o2
+        } = i2, {
+            topLeft: a2,
+            topRight: l2,
+            bottomLeft: h2,
+            bottomRight: c2
+        } = Dn(o2), {
+            x: u2,
+            y: d2
+        } = t3, {
+            width: f2,
+            height: p2
+        } = e2;
+        let m2, g2, y2, v2, b2, _2;
+        return "center" === n2 ? (b2 = d2 + p2 / 2, "left" === s2 ? (m2 = u2, g2 = m2 - r2, v2 = b2 + r2, _2 = b2 - r2) : (m2 = u2 + f2, g2 = m2 + r2, v2 = b2 - r2, _2 = b2 + r2), y2 = m2) : (g2 = "left" === s2 ? u2 + Math.max(a2, h2) + r2 : "right" === s2 ? u2 + f2 - Math.max(l2, c2) - r2 : this.caretX, "top" === n2 ? (v2 = d2, b2 = v2 - r2, m2 = g2 - r2, y2 = g2 + r2) : (v2 = d2 + p2, b2 = v2 + r2, m2 = g2 + r2, y2 = g2 - r2), _2 = v2), {
+            x1: m2,
+            x2: g2,
+            x3: y2,
+            y1: v2,
+            y2: b2,
+            y3: _2
+        };
+    }
+    drawTitle(t3, e2, i2) {
+        const s2 = this.title,
+            n2 = s2.length;
+        let r2, o2, a2;
+        if (n2) {
+            const l2 = Er(i2.rtl, this.x, this.width);
+            for (t3.x = ja(this, i2.titleAlign, i2), e2.textAlign = l2.textAlign(i2.titleAlign), e2.textBaseline = "middle", r2 = On(i2.titleFont), o2 = i2.titleSpacing, e2.fillStyle = i2.titleColor, e2.font = r2.string, a2 = 0; a2 < n2; ++a2)
+                e2.fillText(s2[a2], l2.x(t3.x), t3.y + r2.lineHeight / 2), t3.y += r2.lineHeight + o2, a2 + 1 === n2 && (t3.y += i2.titleMarginBottom - o2);
+        }
+    }
+    _drawColorBox(t3, e2, i2, s2, n2) {
+        const r2 = this.labelColors[i2],
+            o2 = this.labelPointStyles[i2],
+            {
+                boxHeight: a2,
+                boxWidth: l2
+            } = n2,
+            h2 = On(n2.bodyFont),
+            c2 = ja(this, "left", n2),
+            u2 = s2.x(c2),
+            d2 = a2 < h2.lineHeight ? (h2.lineHeight - a2) / 2 : 0,
+            f2 = e2.y + d2;
+        if (n2.usePointStyle) {
+            const e3 = {
+                    radius: Math.min(l2, a2) / 2,
+                    pointStyle: o2.pointStyle,
+                    rotation: o2.rotation,
+                    borderWidth: 1
+                },
+                i3 = s2.leftForLtr(u2, l2) + l2 / 2,
+                h3 = f2 + a2 / 2;
+            t3.strokeStyle = n2.multiKeyBackground, t3.fillStyle = n2.multiKeyBackground, sn(t3, e3, i3, h3), t3.strokeStyle = r2.borderColor, t3.fillStyle = r2.backgroundColor, sn(t3, e3, i3, h3);
+        } else {
+            t3.lineWidth = yi(r2.borderWidth) ? Math.max(...Object.values(r2.borderWidth)) : r2.borderWidth || 1, t3.strokeStyle = r2.borderColor, t3.setLineDash(r2.borderDash || []), t3.lineDashOffset = r2.borderDashOffset || 0;
+            const e3 = s2.leftForLtr(u2, l2),
+                i3 = s2.leftForLtr(s2.xPlus(u2, 1), l2 - 2),
+                o3 = Dn(r2.borderRadius);
+            Object.values(o3).some((t4) => 0 !== t4) ? (t3.beginPath(), t3.fillStyle = n2.multiKeyBackground, bn(t3, {
+                x: e3,
+                y: f2,
+                w: l2,
+                h: a2,
+                radius: o3
+            }), t3.fill(), t3.stroke(), t3.fillStyle = r2.backgroundColor, t3.beginPath(), bn(t3, {
+                x: i3,
+                y: f2 + 1,
+                w: l2 - 2,
+                h: a2 - 2,
+                radius: o3
+            }), t3.fill()) : (t3.fillStyle = n2.multiKeyBackground, t3.fillRect(e3, f2, l2, a2), t3.strokeRect(e3, f2, l2, a2), t3.fillStyle = r2.backgroundColor, t3.fillRect(i3, f2 + 1, l2 - 2, a2 - 2));
+        }
+        t3.fillStyle = this.labelTextColors[i2];
+    }
+    drawBody(t3, e2, i2) {
+        const {
+            body: s2
+        } = this, {
+            bodySpacing: n2,
+            bodyAlign: r2,
+            displayColors: o2,
+            boxHeight: a2,
+            boxWidth: l2,
+            boxPadding: h2
+        } = i2, c2 = On(i2.bodyFont);
+        let u2 = c2.lineHeight,
+            d2 = 0;
+        const f2 = Er(i2.rtl, this.x, this.width),
+            p2 = function(i3) {
+                e2.fillText(i3, f2.x(t3.x + d2), t3.y + u2 / 2), t3.y += u2 + n2;
+            },
+            m2 = f2.textAlign(r2);
+        let g2, y2, v2, b2, _2, w2, x2;
+        for (e2.textAlign = r2, e2.textBaseline = "middle", e2.font = c2.string, t3.x = ja(this, m2, i2), e2.fillStyle = i2.bodyColor, Ei(this.beforeBody, p2), d2 = o2 && "right" !== m2 ? "center" === r2 ? l2 / 2 + h2 : l2 + 2 + h2 : 0, b2 = 0, w2 = s2.length; b2 < w2; ++b2) {
+            for (g2 = s2[b2], y2 = this.labelTextColors[b2], e2.fillStyle = y2, Ei(g2.before, p2), v2 = g2.lines, o2 && v2.length && (this._drawColorBox(e2, t3, b2, f2, i2), u2 = Math.max(c2.lineHeight, a2)), _2 = 0, x2 = v2.length; _2 < x2; ++_2)
+                p2(v2[_2]), u2 = c2.lineHeight;
+            Ei(g2.after, p2);
+        }
+        d2 = 0, u2 = c2.lineHeight, Ei(this.afterBody, p2), t3.y -= n2;
+    }
+    drawFooter(t3, e2, i2) {
+        const s2 = this.footer,
+            n2 = s2.length;
+        let r2, o2;
+        if (n2) {
+            const a2 = Er(i2.rtl, this.x, this.width);
+            for (t3.x = ja(this, i2.footerAlign, i2), t3.y += i2.footerMarginTop, e2.textAlign = a2.textAlign(i2.footerAlign), e2.textBaseline = "middle", r2 = On(i2.footerFont), e2.fillStyle = i2.footerColor, e2.font = r2.string, o2 = 0; o2 < n2; ++o2)
+                e2.fillText(s2[o2], a2.x(t3.x), t3.y + r2.lineHeight / 2), t3.y += r2.lineHeight + i2.footerSpacing;
+        }
+    }
+    drawBackground(t3, e2, i2, s2) {
+        const {
+            xAlign: n2,
+            yAlign: r2
+        } = this, {
+            x: o2,
+            y: a2
+        } = t3, {
+            width: l2,
+            height: h2
+        } = i2, {
+            topLeft: c2,
+            topRight: u2,
+            bottomLeft: d2,
+            bottomRight: f2
+        } = Dn(s2.cornerRadius);
+        e2.fillStyle = s2.backgroundColor, e2.strokeStyle = s2.borderColor, e2.lineWidth = s2.borderWidth, e2.beginPath(), e2.moveTo(o2 + c2, a2), "top" === r2 && this.drawCaret(t3, e2, i2, s2), e2.lineTo(o2 + l2 - u2, a2), e2.quadraticCurveTo(o2 + l2, a2, o2 + l2, a2 + u2), "center" === r2 && "right" === n2 && this.drawCaret(t3, e2, i2, s2), e2.lineTo(o2 + l2, a2 + h2 - f2), e2.quadraticCurveTo(o2 + l2, a2 + h2, o2 + l2 - f2, a2 + h2), "bottom" === r2 && this.drawCaret(t3, e2, i2, s2), e2.lineTo(o2 + d2, a2 + h2), e2.quadraticCurveTo(o2, a2 + h2, o2, a2 + h2 - d2), "center" === r2 && "left" === n2 && this.drawCaret(t3, e2, i2, s2), e2.lineTo(o2, a2 + c2), e2.quadraticCurveTo(o2, a2, o2 + c2, a2), e2.closePath(), e2.fill(), s2.borderWidth > 0 && e2.stroke();
+    }
+    _updateAnimationTarget(t3) {
+        const e2 = this.chart,
+            i2 = this.$animations,
+            s2 = i2 && i2.x,
+            n2 = i2 && i2.y;
+        if (s2 || n2) {
+            const i3 = Oa[t3.position].call(this, this._active, this._eventPosition);
+            if (!i3)
+                return;
+            const r2 = this._size = Va(this, t3),
+                o2 = Object.assign({}, i3, this._size),
+                a2 = Ba(e2, t3, o2),
+                l2 = Ua(t3, o2, a2, e2);
+            s2._to === l2.x && n2._to === l2.y || (this.xAlign = a2.xAlign, this.yAlign = a2.yAlign, this.width = r2.width, this.height = r2.height, this.caretX = i3.x, this.caretY = i3.y, this._resolveAnimations().update(this, l2));
+        }
+    }
+    _willRender() {
+        return !!this.opacity;
+    }
+    draw(t3) {
+        const e2 = this.options.setContext(this.getContext());
+        let i2 = this.opacity;
+        if (!i2)
+            return;
+        this._updateAnimationTarget(e2);
+        const s2 = {
+                width: this.width,
+                height: this.height
+            },
+            n2 = {
+                x: this.x,
+                y: this.y
+            };
+        i2 = Math.abs(i2) < 1e-3 ? 0 : i2;
+        const r2 = Ln(e2.padding),
+            o2 = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
+        e2.enabled && o2 && (t3.save(), t3.globalAlpha = i2, this.drawBackground(n2, t3, s2, e2), function(t4, e3) {
+            let i3, s3;
+            "ltr" !== e3 && "rtl" !== e3 || (i3 = t4.canvas.style, s3 = [i3.getPropertyValue("direction"), i3.getPropertyPriority("direction")], i3.setProperty("direction", e3, "important"), t4.prevTextDirection = s3);
+        }(t3, e2.textDirection), n2.y += r2.top, this.drawTitle(n2, t3, e2), this.drawBody(n2, t3, e2), this.drawFooter(n2, t3, e2), function(t4, e3) {
+            void 0 !== e3 && (delete t4.prevTextDirection, t4.canvas.style.setProperty("direction", e3[0], e3[1]));
+        }(t3, e2.textDirection), t3.restore());
+    }
+    getActiveElements() {
+        return this._active || [];
+    }
+    setActiveElements(t3, e2) {
+        const i2 = this._active,
+            s2 = t3.map(({
+                datasetIndex: t4,
+                index: e3
+            }) => {
+                const i3 = this.chart.getDatasetMeta(t4);
+                if (!i3)
+                    throw new Error("Cannot find a dataset at index " + t4);
+                return {
+                    datasetIndex: t4,
+                    element: i3.data[e3],
+                    index: e3
+                };
+            }),
+            n2 = !Ii(i2, s2),
+            r2 = this._positionChanged(s2, e2);
+        (n2 || r2) && (this._active = s2, this._eventPosition = e2, this._ignoreReplayEvents = true, this.update(true));
+    }
+    handleEvent(t3, e2, i2 = true) {
+        if (e2 && this._ignoreReplayEvents)
+            return false;
+        this._ignoreReplayEvents = false;
+        const s2 = this.options,
+            n2 = this._active || [],
+            r2 = this._getActiveElements(t3, n2, e2, i2),
+            o2 = this._positionChanged(r2, t3),
+            a2 = e2 || !Ii(r2, n2) || o2;
+        return a2 && (this._active = r2, (s2.enabled || s2.external) && (this._eventPosition = {
+            x: t3.x,
+            y: t3.y
+        }, this.update(true, e2))), a2;
+    }
+    _getActiveElements(t3, e2, i2, s2) {
+        const n2 = this.options;
+        if ("mouseout" === t3.type)
+            return [];
+        if (!s2)
+            return e2;
+        const r2 = this.chart.getElementsAtEventForMode(t3, n2.mode, n2, i2);
+        return n2.reverse && r2.reverse(), r2;
+    }
+    _positionChanged(t3, e2) {
+        const {
+            caretX: i2,
+            caretY: s2,
+            options: n2
+        } = this, r2 = Oa[n2.position].call(this, t3, e2);
+        return false !== r2 && (i2 !== r2.x || s2 !== r2.y);
+    }
+}
+__publicField(Tooltip, "positioners", Oa);
+var Ga = {
+    id: "tooltip",
+    _element: Tooltip,
+    positioners: Oa,
+    afterInit(t3, e2, i2) {
+        i2 && (t3.tooltip = new Tooltip({
+            chart: t3,
+            options: i2
+        }));
+    },
+    beforeUpdate(t3, e2, i2) {
+        t3.tooltip && t3.tooltip.initialize(i2);
+    },
+    reset(t3, e2, i2) {
+        t3.tooltip && t3.tooltip.initialize(i2);
+    },
+    afterDraw(t3) {
+        const e2 = t3.tooltip;
+        if (e2 && e2._willRender()) {
+            const i2 = {
+                tooltip: e2
+            };
+            if (false === t3.notifyPlugins("beforeTooltipDraw", {
+                    ...i2,
+                    cancelable: true
+                }))
+                return;
+            e2.draw(t3.ctx), t3.notifyPlugins("afterTooltipDraw", i2);
+        }
+    },
+    afterEvent(t3, e2) {
+        if (t3.tooltip) {
+            const i2 = e2.replay;
+            t3.tooltip.handleEvent(e2.event, i2, e2.inChartArea) && (e2.changed = true);
+        }
+    },
+    defaults: {
+        enabled: true,
+        external: null,
+        position: "average",
+        backgroundColor: "rgba(0,0,0,0.8)",
+        titleColor: "#fff",
+        titleFont: {
+            weight: "bold"
+        },
+        titleSpacing: 2,
+        titleMarginBottom: 6,
+        titleAlign: "left",
+        bodyColor: "#fff",
+        bodySpacing: 2,
+        bodyFont: {},
+        bodyAlign: "left",
+        footerColor: "#fff",
+        footerSpacing: 2,
+        footerMarginTop: 6,
+        footerFont: {
+            weight: "bold"
+        },
+        footerAlign: "left",
+        padding: 6,
+        caretPadding: 2,
+        caretSize: 5,
+        cornerRadius: 6,
+        boxHeight: (t3, e2) => e2.bodyFont.size,
+        boxWidth: (t3, e2) => e2.bodyFont.size,
+        multiKeyBackground: "#fff",
+        displayColors: true,
+        boxPadding: 0,
+        borderColor: "rgba(0,0,0,0)",
+        borderWidth: 0,
+        animation: {
+            duration: 400,
+            easing: "easeOutQuart"
+        },
+        animations: {
+            numbers: {
+                type: "number",
+                properties: ["x", "y", "width", "height", "caretX", "caretY"]
+            },
+            opacity: {
+                easing: "linear",
+                duration: 200
+            }
+        },
+        callbacks: qa
+    },
+    defaultRoutes: {
+        bodyFont: "font",
+        footerFont: "font",
+        titleFont: "font"
+    },
+    descriptors: {
+        _scriptable: (t3) => "filter" !== t3 && "itemSort" !== t3 && "external" !== t3,
+        _indexable: false,
+        callbacks: {
+            _scriptable: false,
+            _indexable: false
+        },
+        animation: {
+            _fallback: false
+        },
+        animations: {
+            _fallback: "animation"
+        }
+    },
+    additionalOptionScopes: ["interaction"]
+};
+
+function Ya(t3, e2, i2, s2) {
+    const n2 = t3.indexOf(e2);
+    if (-1 === n2)
+        return ((t4, e3, i3, s3) => ("string" == typeof e3 ? (i3 = t4.push(e3) - 1, s3.unshift({
+            index: i3,
+            label: e3
+        })) : isNaN(e3) && (i3 = null), i3))(t3, e2, i2, s2);
+    return n2 !== t3.lastIndexOf(e2) ? i2 : n2;
+}
+
+function Qa(t3) {
+    const e2 = this.getLabels();
+    return t3 >= 0 && t3 < e2.length ? e2[t3] : t3;
+}
+class CategoryScale extends Scale {
+    constructor(t3) {
+        super(t3), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];
+    }
+    init(t3) {
+        const e2 = this._addedLabels;
+        if (e2.length) {
+            const t4 = this.getLabels();
+            for (const {
+                    index: i2,
+                    label: s2
+                }
+                of e2)
+                t4[i2] === s2 && t4.splice(i2, 1);
+            this._addedLabels = [];
+        }
+        super.init(t3);
+    }
+    parse(t3, e2) {
+        if (ci(t3))
+            return null;
+        const i2 = this.getLabels();
+        return ((t4, e3) => null === t4 ? null : vs(Math.round(t4), 0, e3))(e2 = isFinite(e2) && i2[e2] === t3 ? e2 : Ya(i2, t3, Ti(e2, t3), this._addedLabels), i2.length - 1);
+    }
+    determineDataLimits() {
+        const {
+            minDefined: t3,
+            maxDefined: e2
+        } = this.getUserBounds();
+        let {
+            min: i2,
+            max: s2
+        } = this.getMinMax(true);
+        "ticks" === this.options.bounds && (t3 || (i2 = 0), e2 || (s2 = this.getLabels().length - 1)), this.min = i2, this.max = s2;
+    }
+    buildTicks() {
+        const t3 = this.min,
+            e2 = this.max,
+            i2 = this.options.offset,
+            s2 = [];
+        let n2 = this.getLabels();
+        n2 = 0 === t3 && e2 === n2.length - 1 ? n2 : n2.slice(t3, e2 + 1), this._valueRange = Math.max(n2.length - (i2 ? 0 : 1), 1), this._startValue = this.min - (i2 ? 0.5 : 0);
+        for (let i3 = t3; i3 <= e2; i3++)
+            s2.push({
+                value: i3
+            });
+        return s2;
+    }
+    getLabelForValue(t3) {
+        return Qa.call(this, t3);
+    }
+    configure() {
+        super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);
+    }
+    getPixelForValue(t3) {
+        return "number" != typeof t3 && (t3 = this.parse(t3)), null === t3 ? NaN : this.getPixelForDecimal((t3 - this._startValue) / this._valueRange);
+    }
+    getPixelForTick(t3) {
+        const e2 = this.ticks;
+        return t3 < 0 || t3 > e2.length - 1 ? null : this.getPixelForValue(e2[t3].value);
+    }
+    getValueForPixel(t3) {
+        return Math.round(this._startValue + this.getDecimalForPixel(t3) * this._valueRange);
+    }
+    getBasePixel() {
+        return this.bottom;
+    }
+}
+__publicField(CategoryScale, "id", "category");
+__publicField(CategoryScale, "defaults", {
+    ticks: {
+        callback: Qa
+    }
+});
+
+function Xa(t3, e2) {
+    const i2 = [],
+        {
+            bounds: s2,
+            step: n2,
+            min: r2,
+            max: o2,
+            precision: a2,
+            count: l2,
+            maxTicks: h2,
+            maxDigits: c2,
+            includeBounds: u2
+        } = t3,
+        d2 = n2 || 1,
+        f2 = h2 - 1,
+        {
+            min: p2,
+            max: m2
+        } = e2,
+        g2 = !ci(r2),
+        y2 = !ci(o2),
+        v2 = !ci(l2),
+        b2 = (m2 - p2) / (c2 + 1);
+    let _2, w2, x2, k2, T2 = ls((m2 - p2) / f2 / d2) * d2;
+    if (T2 < 1e-14 && !g2 && !y2)
+        return [{
+            value: p2
+        }, {
+            value: m2
+        }];
+    k2 = Math.ceil(m2 / T2) - Math.floor(p2 / T2), k2 > f2 && (T2 = ls(k2 * T2 / f2 / d2) * d2), ci(a2) || (_2 = Math.pow(10, a2), T2 = Math.ceil(T2 * _2) / _2), "ticks" === s2 ? (w2 = Math.floor(p2 / T2) * T2, x2 = Math.ceil(m2 / T2) * T2) : (w2 = p2, x2 = m2), g2 && y2 && n2 && function(t4, e3) {
+        const i3 = Math.round(t4);
+        return i3 - e3 <= t4 && i3 + e3 >= t4;
+    }((o2 - r2) / n2, T2 / 1e3) ? (k2 = Math.round(Math.min((o2 - r2) / T2, h2)), T2 = (o2 - r2) / k2, w2 = r2, x2 = o2) : v2 ? (w2 = g2 ? r2 : w2, x2 = y2 ? o2 : x2, k2 = l2 - 1, T2 = (x2 - w2) / k2) : (k2 = (x2 - w2) / T2, k2 = as(k2, Math.round(k2), T2 / 1e3) ? Math.round(k2) : Math.ceil(k2));
+    const S2 = Math.max(fs(T2), fs(w2));
+    _2 = Math.pow(10, ci(a2) ? S2 : a2), w2 = Math.round(w2 * _2) / _2, x2 = Math.round(x2 * _2) / _2;
+    let E2 = 0;
+    for (g2 && (u2 && w2 !== r2 ? (i2.push({
+            value: r2
+        }), w2 < r2 && E2++, as(Math.round((w2 + E2 * T2) * _2) / _2, r2, Ja(r2, b2, t3)) && E2++) : w2 < r2 && E2++); E2 < k2; ++E2) {
+        const t4 = Math.round((w2 + E2 * T2) * _2) / _2;
+        if (y2 && t4 > o2)
+            break;
+        i2.push({
+            value: t4
+        });
+    }
+    return y2 && u2 && x2 !== o2 ? i2.length && as(i2[i2.length - 1].value, o2, Ja(o2, b2, t3)) ? i2[i2.length - 1].value = o2 : i2.push({
+        value: o2
+    }) : y2 && x2 !== o2 || i2.push({
+        value: x2
+    }), i2;
+}
+
+function Ja(t3, e2, {
+    horizontal: i2,
+    minRotation: s2
+}) {
+    const n2 = us(s2),
+        r2 = (i2 ? Math.sin(n2) : Math.cos(n2)) || 1e-3,
+        o2 = 0.75 * e2 * ("" + t3).length;
+    return Math.min(e2 / r2, o2);
+}
+class LinearScaleBase extends Scale {
+    constructor(t3) {
+        super(t3), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
+    }
+    parse(t3, e2) {
+        return ci(t3) || ("number" == typeof t3 || t3 instanceof Number) && !isFinite(+t3) ? null : +t3;
+    }
+    handleTickRangeOptions() {
+        const {
+            beginAtZero: t3
+        } = this.options, {
+            minDefined: e2,
+            maxDefined: i2
+        } = this.getUserBounds();
+        let {
+            min: s2,
+            max: n2
+        } = this;
+        const r2 = (t4) => s2 = e2 ? s2 : t4,
+            o2 = (t4) => n2 = i2 ? n2 : t4;
+        if (t3) {
+            const t4 = os(s2),
+                e3 = os(n2);
+            t4 < 0 && e3 < 0 ? o2(0) : t4 > 0 && e3 > 0 && r2(0);
+        }
+        if (s2 === n2) {
+            let e3 = 0 === n2 ? 1 : Math.abs(0.05 * n2);
+            o2(n2 + e3), t3 || r2(s2 - e3);
+        }
+        this.min = s2, this.max = n2;
+    }
+    getTickLimit() {
+        const t3 = this.options.ticks;
+        let e2, {
+            maxTicksLimit: i2,
+            stepSize: s2
+        } = t3;
+        return s2 ? (e2 = Math.ceil(this.max / s2) - Math.floor(this.min / s2) + 1, e2 > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${s2} would result generating up to ${e2} ticks. Limiting to 1000.`), e2 = 1e3)) : (e2 = this.computeTickLimit(), i2 = i2 || 11), i2 && (e2 = Math.min(i2, e2)), e2;
+    }
+    computeTickLimit() {
+        return Number.POSITIVE_INFINITY;
+    }
+    buildTicks() {
+        const t3 = this.options,
+            e2 = t3.ticks;
+        let i2 = this.getTickLimit();
+        i2 = Math.max(2, i2);
+        const s2 = Xa({
+            maxTicks: i2,
+            bounds: t3.bounds,
+            min: t3.min,
+            max: t3.max,
+            precision: e2.precision,
+            step: e2.stepSize,
+            count: e2.count,
+            maxDigits: this._maxDigits(),
+            horizontal: this.isHorizontal(),
+            minRotation: e2.minRotation || 0,
+            includeBounds: false !== e2.includeBounds
+        }, this._range || this);
+        return "ticks" === t3.bounds && cs(s2, this, "value"), t3.reverse ? (s2.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), s2;
+    }
+    configure() {
+        const t3 = this.ticks;
+        let e2 = this.min,
+            i2 = this.max;
+        if (super.configure(), this.options.offset && t3.length) {
+            const s2 = (i2 - e2) / Math.max(t3.length - 1, 1) / 2;
+            e2 -= s2, i2 += s2;
+        }
+        this._startValue = e2, this._endValue = i2, this._valueRange = i2 - e2;
+    }
+    getLabelForValue(t3) {
+        return Us(t3, this.chart.options.locale, this.options.ticks.format);
+    }
+}
+class LinearScale extends LinearScaleBase {
+    determineDataLimits() {
+        const {
+            min: t3,
+            max: e2
+        } = this.getMinMax(true);
+        this.min = _i(t3) ? t3 : 0, this.max = _i(e2) ? e2 : 1, this.handleTickRangeOptions();
+    }
+    computeTickLimit() {
+        const t3 = this.isHorizontal(),
+            e2 = t3 ? this.width : this.height,
+            i2 = us(this.options.ticks.minRotation),
+            s2 = (t3 ? Math.sin(i2) : Math.cos(i2)) || 1e-3,
+            n2 = this._resolveTickFontOptions(0);
+        return Math.ceil(e2 / Math.min(40, n2.lineHeight / s2));
+    }
+    getPixelForValue(t3) {
+        return null === t3 ? NaN : this.getPixelForDecimal((t3 - this._startValue) / this._valueRange);
+    }
+    getValueForPixel(t3) {
+        return this._startValue + this.getDecimalForPixel(t3) * this._valueRange;
+    }
+}
+__publicField(LinearScale, "id", "linear");
+__publicField(LinearScale, "defaults", {
+    ticks: {
+        callback: Ks.formatters.numeric
+    }
+});
+Ks.formatters.logarithmic;
+Ks.formatters.numeric;
+const Za = {
+    welcome: "Welcome to inlang",
+    title: "相信數據。科學投資",
+    subtitle: "科技驅動投資革命，數據分析引領市場趨勢，現在就跳上科技潮流，創造真正的被動收入！",
+    actionButton: "我要掀起投資革命",
+    profitability: {
+        historicalReturn: "歷史績效",
+        stockList: "持股報酬",
+        monthlyReturn: "月報酬",
+        monthlyWinRatio: "月勝率",
+        avgMonthlyReturn: "平均月報酬"
+    },
+    "profitability.YearlyCompareWithBenchmark": "與大盤年報酬比較",
+    "profitability.yearlyWinRate": "贏大盤",
+    strategy: "策略",
+    benchmark: "大盤",
+    "profitability.exceedReturn": "超額報酬",
+    average: "平均",
+    "risk.drawdownPercentage": "回檔幅度",
+    "risk.drawdowPeriods": "虧損歷史",
+    tabs: {
+        profitability: "獲利能力",
+        risk: "抗風險能力",
+        ratio: "風險報酬比",
+        winrate: "勝率期望值",
+        liquidity: "交易流動性"
+    },
+    metrics: {
+        backtest: {
+            startDate: "開始日期",
+            endDate: "結束日期",
+            version: "版本",
+            feeRatio: "費用比率",
+            taxRatio: "稅收比率",
+            tradeAt: "交易於（收盤或開盤）",
+            market: "市場",
+            freq: "頻率",
+            updateDate: "更新日期",
+            nextTradingDate: "下一交易日",
+            livePerformanceStart: "實時表現開始日期",
+            stopLoss: "止損百分比",
+            takeProfit: "獲利百分比"
+        },
+        profitability: {
+            annualReturn: "年度回報",
+            alpha: "阿爾法（Alpha）",
+            beta: "貝塔（Beta）",
+            avgNStock: "平均持有股票數",
+            maxNStock: "最大持有股票數"
+        },
+        risk: {
+            maxDrawdown: "最大回檔",
+            avgDrawdown: "平均回檔",
+            avgDrawdownDays: "平均回檔時間（天）",
+            volatility: "波動性",
+            valueAtRisk: "價值風險（VaR）",
+            cvalueAtRisk: "條件價值風險（CVaR）",
+            newHighTimeRank: "再次創新高時間排名",
+            worst10Strategy: "策略前十大",
+            worst10Benchmark: "大盤前十大",
+            days: "days"
+        },
+        ratio: {
+            sharpeRatio: "Sharpe Ratio",
+            sortinoRatio: "Sortino Ratio",
+            calmarRatio: "Calmar Ratio",
+            profitFactor: "Profit Factor",
+            tailRatio: "Tail Ratio",
+            worseThanBenchmark: "小於大盤"
+        },
+        winrate: {
+            winRate: "逐筆交易勝率",
+            m12WinRate: "使用策略12個月勝大盤",
+            expectancy: "期望值",
+            mae: "最大不利偏移",
+            mfe: "最大有利偏移"
+        },
+        liquidity: {
+            smallCapRatio: "小市值比率",
+            capacity: "胃納量",
+            disposalStockRatio: "處置股",
+            warningStockRatio: "警告股",
+            fullDeliveryStockRatio: "全額交付股",
+            buyHigh: "買在漲停",
+            sellLow: "賣在跌停"
+        },
+        stocks: {
+            stockId: "名稱代號",
+            return: "報酬",
+            entry: "進場",
+            exit: "出場",
+            position: "持倉",
+            entryPrice: "進場價格",
+            exitPrice: "出場價格",
+            entrySig: "進場訊號",
+            exitSig: "出場訊號",
+            mae: "不利偏移",
+            gmfe: "有利偏移",
+            bmfe: "虧損前有利偏移",
+            mdd: "最大回檔",
+            pdays: "持倉天数"
+        }
+    },
+    "metrics.ratio.tailRatio": "極端風報比 (Tail Ratio)",
+    "metrics.ratio.sharpeRatio": "夏普比率(Sharpe Ratio)",
+    "notebook.private_draft": "儲存草稿",
+    "notebook.save_draft": "儲存",
+    "notebook.go_public": "準備發布",
+    "notebook.update_public": "更新發布",
+    "notebook.category.python": "Python",
+    "notebook.category.market": "股市",
+    "notebook.category.algorithm": "演算法",
+    "notebook.category.tool": "工具",
+    "notebook.category.metric": "策略指標",
+    "notebook.category.indicator": "財經指標",
+    "notebook.category.ai": "機器學習AI",
+    position: {
+        sl: "停損",
+        tp: "停利",
+        resample: "換股頻率",
+        entryTradePrice: "進場時機",
+        exitTradePrice: "出場時機",
+        scheduled: "預定換股日",
+        dataFreq: "回測頻率",
+        created: "更新時間",
+        entryDate: "進場日期",
+        exitDate: "出場日期",
+        currentPrice: "價格",
+        profit: "盈虧",
+        currentWeight: "持股比例",
+        RSV: "多空力道",
+        resampleValue: {
+            "30M": "每30分鐘",
+            H: "每1小時",
+            "4H": "每4小時",
+            D: "每1天",
+            W: "每1週",
+            "W-Mon": "每週一",
+            "W-Tue": "每週二",
+            "W-Wed": "每週三",
+            "W-Thu": "每週四",
+            "W-Fri": "每週五",
+            M: "每個月",
+            "2M": "每2個月",
+            MRE: "每月收入公佈日",
+            Q: "每1季度",
+            HY: "每半年",
+            Y: "每1年",
+            null: "無"
+        },
+        open: "開盤",
+        close: "收盤",
+        type: {
+            entry: "進場",
+            entry_f: "將進場",
+            exit: "出場",
+            exit_p: "已出場",
+            hold: "持有",
+            sl: "停損",
+            tp: "停利",
+            sl_: "已停損",
+            tp_: "已停利"
+        }
+    },
+    "position.assetName": "標的名稱",
+    "position.action": "動作",
+    "metrics.ratio.yearlySharpeRatio": "每年夏普與大盤比較",
+    "metrics.ratio.betterThanBenchmark": "大於大盤：",
+    "metrics.ratio.year": "年",
+    "metrics.ratio.timeBetterThanBenchmark": "大於大盤的時間：",
+    "metrics.ratio.yearlyTailRatio": "每年極端風報比與大盤比較",
+    "metrics.ratio.volatility": "策略報酬率波動 (Volitility)",
+    "metrics.winrate.returnDistribution": "報酬分布",
+    "metrics.winrate.distributionInfo1": "有 5% 的機率，交易將有",
+    "metrics.winrate.distributionInfo2": " % 以上的虧損",
+    "metrics.winrate.return": "報酬率",
+    "metrics.winrate.maemfe": "交易最大偏移",
+    "metrics.winrate.stoploss": "停損設定：",
+    "metrics.winrate.none": "無",
+    "metrics.winrate.extraProfitLoss": "停損造成的額外盈虧：",
+    "metrics.winrate.stoplossRatio": "停損的交易比例：",
+    "metrics.winrate.maeReturn": "報酬與最大不利偏移",
+    "metrics.winrate.simulatedStopLoss": "模擬停損",
+    "metrics.winrate.simulatedTakeProfit": "模擬停利",
+    "metrics.winrate.takeProfit": "停利設定：",
+    "metrics.winrate.extraProfitLossTakingProfit": "停利造成的額外盈虧：",
+    "metrics.winrate.takeProfitRatio": "停利的交易比例：",
+    "metrics.winrate.mfeReturn": "報酬與最大有利偏移",
+    "metrics.liquidity.portfolioCapacity": "投資組合胃納量",
+    "metrics.liquidity.safeLiquidityTradeRatio": "安全流動性交易的佔比",
+    "metrics.liquidity.averageReturn": "平均報酬",
+    "metrics.liquidity.totalInvestment": "投資總資金",
+    "metrics.liquidity.marketCap": "交易標的的市值",
+    "metrics.liquidity.tradeRatio": "交易的佔比",
+    "metrics.liquidity.tradeRatioMarketCap": "市值門檻",
+    "metrics.liquidity.tradeRatioEntryVolume": "買進成交量門檻",
+    "metrics.liquidity.tradeRatioExitVolume": "交易的佔比",
+    "metrics.liquidity.volumeThreshold": "當天成交量",
+    "metrics.liquidity.exitVolume": "出場當天成交量",
+    "metrics.liquidity.entryVolume": "進場當天成交量",
+    "metrics.liquidity.marketCapThreshold": "市值門檻",
+    "metrics.liquidity.portfolioCapacityDescription": "當資金量達到 {v1} 時，將有 {v2}%的機率，買到流動性低的股票(低成交量、價差大、價格易波動)。",
+    "metrics.liquidity.marketCapDescription": "市值 {v1} 以上的交易佔 {v2}%。",
+    "metrics.liquidity.entryVolumeDescription": "買入當天成交量 {v1} 張以上的交易佔 {v2}%。",
+    "metrics.liquidity.exitVolumeDescription": "賣出當天成交量 {v1} 張以上的交易佔 {v2}%。",
+    "metrics.ratio.rollingTailRatio": "每年極端風報比 (Tail Ratio)",
+    "profitability.yearlyReturn": "年報酬",
+    "profitability.benchmarkYearlyReturn": "大盤年報酬",
+    "profitability.year": "年",
+    "metrics.risk.worstDrawdownPeriod": "跌幅排名",
+    "profitability.all": "全部",
+    "profitability.recent": "近年",
+    "metric.description": {
+        backtest: {
+            startDate: "回測的開始日期",
+            endDate: "回測的結束日期",
+            version: "回測的版本",
+            feeRatio: "交易的手續費比率",
+            taxRatio: "交易的稅率",
+            tradeAt: "交易是在市場收盤還是開盤時執行",
+            market: "進行回測的市場",
+            freq: "回測使用的數據頻率",
+            updateDate: "回測最後更新的日期",
+            nextTradingDate: "回測後的下一個交易日期",
+            livePerformanceStart: "實時性能跟踪開始的日期",
+            stopLoss: "允許的最大損失以停止交易",
+            takeProfit: "退出交易的利潤目標"
+        },
+        profitability: {
+            annualReturn: "策略的年度回報",
+            alpha: "相對於基準的策略的風險調整後表現的衡量",
+            beta: "策略對市場變動的敏感性的衡量",
+            avgNStock: "投資組合中持有的平均股票數",
+            maxNStock: "投資組合中持有的最大股票數"
+        },
+        risk: {
+            maxDrawdown: "從高點到低谷的最大百分比下降",
+            avgDrawdown: "從高點到低谷的平均百分比下降",
+            avgDrawdownDays: "平均回撤天數",
+            volatility: "策略回報的標準差",
+            valueAtRisk: "給定信心區間的指定期間內預期的最大損失",
+            cvalueAtRisk: "發生指定不良事件後的預期損失"
+        },
+        ratio: {
+            sharpeRatio: "風險調整後表現的衡量",
+            sortinoRatio: "只考慮下行波動性的風險調整後表現的衡量",
+            calmarRatio: "年度回報與最大回撤的比率",
+            profitFactor: "總利潤與總損失的比率",
+            tailRatio: "右尾（贏）與左尾（輸）的比率"
+        },
+        winrate: {
+            winRate: "盈利交易的百分比",
+            m12WinRate: "12個月滾動勝率",
+            expectancy: "每筆交易預期贏得（或損失）的平均金額",
+            mae: "最大不利運動，或交易盈利前的最大損失",
+            mfe: "最大有利運動，或交易變成損失前的最大利潤"
+        },
+        liquidity: {
+            capacity: "不影響市場價格可以部署的最大資本金額",
+            disposalStockRatio: "可以輕易出售的股票比率",
+            warningStockRatio: "可能存在流動性問題的股票比率",
+            fullDeliveryStockRatio: "需要全額交付的股票比率",
+            buyHigh: "購買高價股票的傾向",
+            sellLow: "賣出低價股票的傾向"
+        }
+    },
+    "metrics.condition": "達成條件",
+    "strategy.code": "程式碼",
+    "strategy.return": "報酬",
+    "strategy.betterThanBenchmark": "贏大盤",
+    "strategy.worseThanBenchmark": "輸大盤",
+    "strategy.annualReturn": "年度報酬",
+    "strategy.maxDrawdown": "最大回檔",
+    "strategy.sharpeRatio": "夏普比率",
+    "strategy.period": {
+        W: "週",
+        M: "月",
+        Q: "季",
+        HY: "半年",
+        Y: "年",
+        All: "全部"
+    },
+    "strategy.tabs": {
+        position: "選股",
+        analyze: "分析",
+        course: "教學"
+    }
+};
+
+function tl(t3, e2 = "") {
+    let i2 = {};
+    for (let s2 in t3)
+        "object" == typeof t3[s2] && null !== t3[s2] ? Object.assign(i2, tl(t3[s2], e2 + s2 + ".")) : i2[e2 + s2] = t3[s2];
+    return i2;
+}
+const el = tl({
+        welcome: "Welcome to inlang",
+        title: "Data Driven, Scientific Investment",
+        subtitle: "Technology-driven investment revolution. Jump on the tech wave now and create passive income!",
+        actionButton: "start revolution",
+        profitability: {
+            historicalReturn: "Historical Performance",
+            stockList: "Stock Returns",
+            monthlyReturn: "Monthly Return",
+            monthlyWinRatio: "Monthly Win Rate",
+            avgMonthlyReturn: "Average Monthly Return"
+        },
+        "profitability.YearlyCompareWithBenchmark": "Annual Return Relative to the Benchmark",
+        "profitability.yearlyWinRate": "Outperformed Benchmark:",
+        strategy: "Strategy",
+        benchmark: "Benchmark",
+        "profitability.exceedReturn": "Excess Return",
+        average: "Average",
+        "risk.drawdownPercentage": "Historical Drawdown Percentage",
+        "risk.drawdowPeriods": "Loss Historical Performance",
+        tabs: {
+            profitability: "Profitability",
+            risk: "Risk Resistance",
+            ratio: "Risk-Reward Ratio",
+            winrate: "Trade Analaysis",
+            liquidity: "Stock Liquidity"
+        },
+        metrics: {
+            backtest: {
+                startDate: "Start Date",
+                endDate: "End Date",
+                version: "Version",
+                feeRatio: "Fee Ratio",
+                taxRatio: "Tax Ratio",
+                tradeAt: "Trade At (Close or Open)",
+                market: "Market",
+                freq: "Frequency",
+                updateDate: "Update Date",
+                nextTradingDate: "Next Trading Date",
+                livePerformanceStart: "Live Performance Start Date",
+                stopLoss: "Stop Loss Percentage",
+                takeProfit: "Take Profit Percentage"
+            },
+            profitability: {
+                annualReturn: "Annual Return",
+                alpha: "Alpha",
+                beta: "Beta",
+                avgNStock: "Average Stock Count",
+                maxNStock: "Max stocks Count"
+            },
+            risk: {
+                maxDrawdown: "Maximum Drawdown",
+                avgDrawdown: "Average Drawdown",
+                avgDrawdownDays: "Average Days",
+                volatility: "Volatility",
+                valueAtRisk: "Value At Risk (VaR)",
+                cvalueAtRisk: "CVaR",
+                days: "days"
+            },
+            ratio: {
+                sharpeRatio: "Sharpe Ratio",
+                sortinoRatio: "Sortino Ratio",
+                calmarRatio: "Calmar Ratio",
+                profitFactor: "Profit Factor",
+                tailRatio: "Tail Ratio",
+                worseThanBenchmark: "Underperform Benchmark:"
+            },
+            winrate: {
+                winRate: "Win Rate",
+                m12WinRate: "12-Month Win Rate",
+                expectancy: "Expectancy",
+                mae: "MAE",
+                mfe: "MFE"
+            },
+            liquidity: {
+                smallCapRatio: "Small Cap Ratio",
+                capacity: "Capacity",
+                disposalStockRatio: "Disposal Stocks",
+                warningStockRatio: "Warning Stocks",
+                fullDeliveryStockRatio: "Full Delivery Stock",
+                buyHigh: "Buy High",
+                sellLow: "sell Low"
+            },
+            stocks: {
+                stockId: "Stock ID",
+                return: "Return",
+                entry: "Entry",
+                exit: "Exit",
+                position: "Position",
+                entryPrice: "Entry Price",
+                exitPrice: "Exit Price",
+                entrySig: "Entry Signal",
+                exitSig: "Exit Signal",
+                mae: "MAE",
+                gmfe: "MFE",
+                bmfe: "BMFE",
+                mdd: "Maximum Drawdown",
+                pdays: "Holding Days"
+            }
+        },
+        "metrics.risk.worst10Benchmark": "Worst benchmark periods",
+        "metrics.risk.worst10Strategy": "Worst strategy periods",
+        "metrics.risk.newHighTimeRank": "Longest Drawdown Periods",
+        "metrics.ratio.sharpeRatio": "Rolling Sharpe Ratio",
+        position: {
+            sl: "Stop Loss",
+            tp: "Take Profit",
+            resample: "Resample Frequency",
+            entryTradePrice: "Entry Price",
+            exitTradePrice: "Exit Price",
+            scheduled: "Scheduled Resample Date",
+            dataFreq: "Backtest Frequency",
+            created: "Updated Time",
+            entryDate: "Entry Date",
+            exitDate: "Exit Date",
+            currentPrice: "Price",
+            profit: "Profit/Loss",
+            currentWeight: "Holding Percentage",
+            RSV: "Bullish/Bearish Power",
+            resampleValue: {
+                "30M": "Every 30 Minutes",
+                H: "Every 1 Hour",
+                "4H": "Every 4 Hours",
+                D: "Every Day",
+                W: "Every Week",
+                "W-Mon": "Every Monday",
+                "W-Tue": "Every Tuesday",
+                "W-Wed": "Every Wednesday",
+                "W-Thu": "Every Thursday",
+                "W-Fri": "Every Friday",
+                M: "Every Month",
+                "2M": "Every 2 Months",
+                MRE: "Monthly Earnings Release Date",
+                Q: "Every Quarter",
+                HY: "Every Half Year",
+                Y: "Every Year",
+                null: "None"
+            },
+            open: "Open",
+            close: "Close",
+            type: {
+                entry: "Entry",
+                entry_f: "Will Enter",
+                exit: "Exit",
+                exit_p: "Exited",
+                hold: "Hold",
+                sl: "Stop Loss",
+                tp: "Take Profit",
+                sl_: "Stopped Out",
+                tp_: "Took Profit"
+            }
+        },
+        "position.assetName": "Asset Name",
+        "position.action": "Action",
+        "metrics.ratio.yearlySharpeRatio": "Annual Sharpe Ratio Compared to Benchmark",
+        "metrics.ratio.betterThanBenchmark": "Outperformed Benchmark:",
+        "metrics.ratio.year": "Year",
+        "metrics.ratio.timeBetterThanBenchmark": "Outperformed Benchmark:",
+        "metrics.ratio.yearlyTailRatio": "Annual Tail Risk Ratio Compared to Benchmark",
+        "metrics.ratio.volatility": "Strategy Return Volatility",
+        "metrics.winrate.returnDistribution": "Return Distribution",
+        "metrics.winrate.distributionInfo1": "There's a 5% chance that the trade will have",
+        "metrics.winrate.distributionInfo2": " % or more loss",
+        "metrics.winrate.return": "Return Rate",
+        "metrics.winrate.maemfe": "Trade Maximum Excursion",
+        "metrics.winrate.stoploss": "Stop Loss Setting:",
+        "metrics.winrate.none": "None",
+        "metrics.winrate.extraProfitLoss": "Extra Profit/Loss Due to Stop Loss:",
+        "metrics.winrate.stoplossRatio": "Trade Ratio with Stop Loss:",
+        "metrics.winrate.maeReturn": "Return vs. Maximum Adverse Excursion",
+        "metrics.winrate.simulatedStopLoss": "Simulated Stop Loss",
+        "metrics.winrate.simulatedTakeProfit": "Simulated Take Profit",
+        "metrics.winrate.takeProfit": "Take Profit Setting:",
+        "metrics.winrate.extraProfitLossTakingProfit": "Extra Profit/Loss Due to Take Profit:",
+        "metrics.winrate.takeProfitRatio": "Trade Ratio with Take Profit:",
+        "metrics.winrate.mfeReturn": "Return vs. Maximum Favorable Excursion",
+        "metrics.liquidity.portfolioCapacity": "Portfolio Capacity",
+        "metrics.liquidity.safeLiquidityTradeRatio": "Safe Liquidity Trade Ratio",
+        "metrics.liquidity.averageReturn": "Average Return",
+        "metrics.liquidity.totalInvestment": "Total Investment",
+        "metrics.liquidity.marketCap": "Trading Asset Market Cap",
+        "metrics.liquidity.tradeRatio": "Trade Ratio",
+        "metrics.liquidity.tradeRatioMarketCap": "Market Cap Threshold",
+        "metrics.liquidity.tradeRatioEntryVolume": "Entry Volume Threshold",
+        "metrics.liquidity.tradeRatioExitVolume": "Exit Volume Threshold",
+        "metrics.liquidity.volumeThreshold": "Entry Day Volume",
+        "metrics.liquidity.exitVolume": "Exit Day Volume",
+        "metrics.liquidity.entryVolume": "Entry Day Volume",
+        "metrics.liquidity.marketCapThreshold": "Market Cap Threshold",
+        "metrics.liquidity.portfolioCapacityDescription": "When the fund amount reaches {v1}, there's a {v2}% chance of buying stocks with low liquidity (Low daily volume, wide spread, price volatility).",
+        "metrics.liquidity.marketCapDescription": "Trades with a market cap above {v1} account for {v2}%.",
+        "metrics.liquidity.entryVolumeDescription": "Trades with an entry volume above {v1} shares account for {v2}%.",
+        "metrics.liquidity.exitVolumeDescription": "Trades with an exit volume above {v1} shares account for {v2}%.",
+        "metrics.ratio.rollingTailRatio": "Rolling Tail Ratio",
+        "profitability.yearlyReturn": "Yearly Return",
+        "profitability.benchmarkYearlyReturn": "Benchmark Yearly Return",
+        "profitability.year": "years",
+        "metrics.risk.worstDrawdownPeriod": "Worst Drawdown",
+        "profitability.all": "All",
+        "profitability.recent": "Recent",
+        "metric.description": {
+            backtest: {
+                startDate: "The starting date of the backtest",
+                endDate: "The ending date of the backtest",
+                version: "Version of the backtest",
+                feeRatio: "Ratio of fees applied to trades",
+                taxRatio: "Ratio of taxes applied to trades",
+                tradeAt: "Whether trades are executed at the close or open of the market",
+                market: "The market in which the backtest is conducted",
+                freq: "Frequency of data used in the backtest",
+                updateDate: "The date the backtest was last updated",
+                nextTradingDate: "The next trading date after the backtest",
+                livePerformanceStart: "The date when live performance tracking starts",
+                stopLoss: "The maximum loss allowed before stopping a trade",
+                takeProfit: "The profit target to exit a trade"
+            },
+            profitability: {
+                annualReturn: "The yearly return of the strategy",
+                alpha: "Measure of the strategy's performance on a risk-adjusted basis relative to a benchmark",
+                beta: "Measure of the strategy's sensitivity to market movements",
+                avgNStock: "Average number of stocks held in the portfolio",
+                maxNStock: "Maximum number of stocks held in the portfolio"
+            },
+            risk: {
+                maxDrawdown: "The maximum percentage decline from a peak to a trough",
+                avgDrawdown: "The average percentage decline from a peak to a trough",
+                avgDrawdownDays: "Average number of days for a drawdown",
+                volatility: "Standard deviation of the strategy's returns",
+                valueAtRisk: "The maximum loss expected over a specified period for a given confidence interval",
+                cvalueAtRisk: "Conditional Value at Risk, or the expected loss given that a specified bad event has occurred"
+            },
+            ratio: {
+                sharpeRatio: "Measure of risk-adjusted performance",
+                sortinoRatio: "Measure of risk-adjusted performance that only considers downside volatility",
+                calmarRatio: "Ratio of annual return to maximum drawdown",
+                profitFactor: "Ratio of gross profit to gross loss",
+                tailRatio: "Ratio of the right tail (wins) to the left tail (losses)"
+            },
+            winrate: {
+                winRate: "Percentage of trades that were profitable",
+                m12WinRate: "12-month rolling win rate",
+                expectancy: "Average amount that can be expected to be won (or lost) per trade",
+                mae: "Maximum Adverse Excursion, or the maximum loss before a trade becomes profitable",
+                mfe: "Maximum Favorable Excursion, or the maximum profit before a trade turns into a loss"
+            },
+            liquidity: {
+                capacity: "The maximum amount of capital that can be deployed without affecting market prices",
+                disposalStockRatio: "Ratio of stocks that can be easily sold",
+                warningStockRatio: "Ratio of stocks that may present liquidity issues",
+                fullDeliveryStockRatio: "Ratio of stocks that require full delivery",
+                buyHigh: "Measure of the tendency to buy stocks at high prices",
+                sellLow: "Measure of the tendency to sell stocks at low prices"
+            }
+        },
+        "metrics.condition": "Criteria",
+        "strategy.code": "Code",
+        "strategy.return": "Return",
+        "strategy.betterThanBenchmark": "Outperformed Benchmark",
+        "strategy.worseThanBenchmark": "Underperform Benchmark",
+        "strategy.annualReturn": "Annual Return",
+        "strategy.maxDrawdown": "Maximum Drawdown",
+        "strategy.sharpeRatio": "Sharpe Ratio",
+        "strategy.period": {
+            W: "W",
+            M: "M",
+            Q: "Q",
+            HY: "HY",
+            Y: "Y",
+            All: "All"
+        },
+        "strategy.tabs": {
+            position: "Position",
+            analyze: "Analysis",
+            course: "Course"
+        }
+    }),
+    il = tl(Za),
+    sl = (t3) => el[t3],
+    nl = (t3) => il[t3];
+
+function rl(e2) {
+    let i2, s2, n2, r2, o2, a2, l2, h2, c2, u2, d2, f2, p2, m2, g2, y2, v2, b2, w2, x2, k2, T2, C2, R2, z2, B2, j2, q2, G2, Y2, it2, st2, rt2, ht2, ct2, ut2, dt2, ft2, pt2, yt2, bt2, _t2, xt2, kt2, St2, It2, Mt2, At2, Lt2, Ot2, Ht2, Qt2, Jt2, te2, ee2, ie2, se2, ne2, re2, oe2, ae2, le2, he2, ce2, ue2, de2, fe2, pe2, me2, ge2, ye2, ve2, be2, _e2, we2, xe2, ke2, Te2, Se2, Ee2, Ce2, Ie2, Me2, Pe2, Re2 = e2[1]("metrics.liquidity.portfolioCapacity") + "",
+        Ae2 = e2[1]("metrics.liquidity.portfolioCapacityDescription").replace("{v1}", e2[2](Object.keys(e2[3].mean)[1], "zh")).replace("{v2}", (100 * (1 - Object.values(e2[3].portion)[1])).toFixed(1)) + "",
+        De2 = e2[1]("metrics.liquidity.safeLiquidityTradeRatio") + "",
+        Le2 = e2[1]("metrics.liquidity.averageReturn") + "",
+        Oe2 = e2[1]("metrics.liquidity.totalInvestment") + "",
+        Fe2 = e2[1]("metrics.liquidity.marketCap") + "",
+        Ne2 = e2[1]("metrics.liquidity.marketCapDescription").replace("{v1}", e2[2](Object.keys(e2[4].mean)[2], "zh")).replace("{v2}", (100 * Object.values(e2[4].portion)[2]).toFixed(1)) + "",
+        $e2 = e2[1]("metrics.liquidity.tradeRatio") + "",
+        Ve2 = e2[1]("metrics.liquidity.averageReturn") + "",
+        ze2 = e2[1]("metrics.liquidity.marketCapThreshold") + "",
+        Be2 = e2[1]("metrics.liquidity.entryVolume") + "",
+        Ue2 = e2[1]("metrics.liquidity.entryVolumeDescription").replace("{v1}", e2[2](Object.keys(e2[5].mean)[2], "zh")).replace("{v2}", (100 * Object.values(e2[5].portion)[2]).toFixed(1)) + "",
+        je2 = e2[1]("metrics.liquidity.tradeRatio") + "",
+        He2 = e2[1]("metrics.liquidity.averageReturn") + "",
+        We2 = e2[1]("metrics.liquidity.volumeThreshold") + "",
+        qe2 = e2[1]("metrics.liquidity.exitVolume") + "",
+        Ke2 = e2[1]("metrics.liquidity.exitVolumeDescription").replace("{v1}", e2[2](Object.keys(e2[6].mean)[2], "zh")).replace("{v2}", (100 * Object.values(e2[6].portion)[2]).toFixed(1)) + "",
+        Ge2 = e2[1]("metrics.liquidity.tradeRatioExitVolume") + "",
+        Ye2 = e2[1]("metrics.liquidity.averageReturn") + "",
+        Qe2 = e2[1]("metrics.liquidity.volumeThreshold") + "";
+    return {
+        c() {
+            i2 = P("div"), s2 = P("div"), n2 = P("h3"), r2 = D(Re2), o2 = $(), a2 = P("p"), l2 = D(Ae2), h2 = $(), c2 = P("div"), u2 = P("p"), d2 = D(De2), f2 = $(), p2 = P("div"), m2 = $(), g2 = P("p"), y2 = D(Le2), v2 = $(), b2 = P("canvas"), w2 = $(), x2 = P("p"), k2 = D(Oe2), T2 = $(), C2 = P("div"), R2 = P("h3"), z2 = D(Fe2), B2 = $(), j2 = P("p"), q2 = D(Ne2), G2 = $(), Y2 = P("div"), it2 = P("p"), st2 = D($e2), rt2 = $(), ht2 = P("div"), ct2 = $(), ut2 = P("p"), dt2 = D(Ve2), ft2 = $(), pt2 = P("canvas"), yt2 = $(), bt2 = P("p"), _t2 = D(ze2), xt2 = $(), kt2 = P("div"), St2 = P("h3"), It2 = D(Be2), Mt2 = $(), At2 = P("p"), Lt2 = D(Ue2), Ot2 = $(), Ht2 = P("div"), Qt2 = P("p"), Jt2 = D(je2), te2 = $(), ee2 = P("div"), ie2 = $(), se2 = P("p"), ne2 = D(He2), re2 = $(), oe2 = P("canvas"), ae2 = $(), le2 = P("p"), he2 = D(We2), ce2 = $(), ue2 = P("div"), de2 = P("h3"), fe2 = D(qe2), pe2 = $(), me2 = P("p"), ge2 = D(Ke2), ye2 = $(), ve2 = P("div"), be2 = P("p"), _e2 = D(Ge2), we2 = $(), xe2 = P("div"), ke2 = $(), Te2 = P("p"), Se2 = D(Ye2), Ee2 = $(), Ce2 = P("canvas"), Ie2 = $(), Me2 = P("p"), Pe2 = D(Qe2), U(n2, "class", "font-bold text-3xl text-center text-base-content-200"), U(a2, "class", "mt-1 text-center"), U(u2, "class", "text-primary"), U(p2, "class", "flex-grow"), U(g2, "class", "text-secondary"), U(c2, "class", "flex mt-6"), U(b2, "width", "400"), U(b2, "height", "200"), U(x2, "class", "text-center mt-4"), U(s2, "class", "col-span-2 md:col-span-1 p-2 md:p-8 pt-8 md:border rounded-xl"), U(R2, "class", "font-bold text-3xl text-center text-base-content-200"), U(j2, "class", "mt-1 text-center"), U(it2, "class", "text-primary"), U(ht2, "class", "flex-grow"), U(ut2, "class", "text-secondary"), U(Y2, "class", "flex mt-6"), U(pt2, "width", "400"), U(pt2, "height", "200"), U(bt2, "class", "text-center mt-4"), U(C2, "class", "col-span-2 md:col-span-1 p-2 md:p-8 pt-8 md:border rounded-xl"), U(St2, "class", "font-bold text-3xl text-cneter text-center"), U(At2, "class", "mt-1 text-center text-base-content-200"), U(Qt2, "class", "text-primary"), U(ee2, "class", "flex-grow"), U(se2, "class", "text-secondary"), U(Ht2, "class", "flex mt-6"), U(oe2, "width", "400"), U(oe2, "height", "200"), U(le2, "class", "text-center mt-4"), U(kt2, "class", "col-span-2 md:col-span-1 p-2 md:p-8 pt-8 md:border rounded-xl"), U(de2, "class", "font-bold text-3xl text-center text-base-content-200"), U(me2, "class", "mt-1 text-center"), U(be2, "class", "text-primary"), U(xe2, "class", "flex-grow"), U(Te2, "class", "text-secondary"), U(ve2, "class", "flex mt-6"), U(Ce2, "width", "400"), U(Ce2, "height", "200"), U(Me2, "class", "text-center mt-4"), U(ue2, "class", "col-span-2 md:col-span-1 p-2 md:p-8 pt-8 md:border rounded-xl"), U(i2, "class", "grid grid-cols-2 text-base-content-200 gap-4");
+        },
+        m(t3, E2) {
+            S(t3, i2, E2), _(i2, s2), _(s2, n2), _(n2, r2), _(s2, o2), _(s2, a2), _(a2, l2), _(s2, h2), _(s2, c2), _(c2, u2), _(u2, d2), _(c2, f2), _(c2, p2), _(c2, m2), _(c2, g2), _(g2, y2), _(s2, v2), _(s2, b2), e2[12](b2), _(s2, w2), _(s2, x2), _(x2, k2), _(i2, T2), _(i2, C2), _(C2, R2), _(R2, z2), _(C2, B2), _(C2, j2), _(j2, q2), _(C2, G2), _(C2, Y2), _(Y2, it2), _(it2, st2), _(Y2, rt2), _(Y2, ht2), _(Y2, ct2), _(Y2, ut2), _(ut2, dt2), _(C2, ft2), _(C2, pt2), e2[13](pt2), _(C2, yt2), _(C2, bt2), _(bt2, _t2), _(i2, xt2), _(i2, kt2), _(kt2, St2), _(St2, It2), _(kt2, Mt2), _(kt2, At2), _(At2, Lt2), _(kt2, Ot2), _(kt2, Ht2), _(Ht2, Qt2), _(Qt2, Jt2), _(Ht2, te2), _(Ht2, ee2), _(Ht2, ie2), _(Ht2, se2), _(se2, ne2), _(kt2, re2), _(kt2, oe2), e2[14](oe2), _(kt2, ae2), _(kt2, le2), _(le2, he2), _(i2, ce2), _(i2, ue2), _(ue2, de2), _(de2, fe2), _(ue2, pe2), _(ue2, me2), _(me2, ge2), _(ue2, ye2), _(ue2, ve2), _(ve2, be2), _(be2, _e2), _(ve2, we2), _(ve2, xe2), _(ve2, ke2), _(ve2, Te2), _(Te2, Se2), _(ue2, Ee2), _(ue2, Ce2), e2[15](Ce2), _(ue2, Ie2), _(ue2, Me2), _(Me2, Pe2);
+        },
+        p(t3, [e3]) {
+            2 & e3 && Re2 !== (Re2 = t3[1]("metrics.liquidity.portfolioCapacity") + "") && H(r2, Re2), 2 & e3 && Ae2 !== (Ae2 = t3[1]("metrics.liquidity.portfolioCapacityDescription").replace("{v1}", t3[2](Object.keys(t3[3].mean)[1], "zh")).replace("{v2}", (100 * (1 - Object.values(t3[3].portion)[1])).toFixed(1)) + "") && H(l2, Ae2), 2 & e3 && De2 !== (De2 = t3[1]("metrics.liquidity.safeLiquidityTradeRatio") + "") && H(d2, De2), 2 & e3 && Le2 !== (Le2 = t3[1]("metrics.liquidity.averageReturn") + "") && H(y2, Le2), 2 & e3 && Oe2 !== (Oe2 = t3[1]("metrics.liquidity.totalInvestment") + "") && H(k2, Oe2), 2 & e3 && Fe2 !== (Fe2 = t3[1]("metrics.liquidity.marketCap") + "") && H(z2, Fe2), 2 & e3 && Ne2 !== (Ne2 = t3[1]("metrics.liquidity.marketCapDescription").replace("{v1}", t3[2](Object.keys(t3[4].mean)[2], "zh")).replace("{v2}", (100 * Object.values(t3[4].portion)[2]).toFixed(1)) + "") && H(q2, Ne2), 2 & e3 && $e2 !== ($e2 = t3[1]("metrics.liquidity.tradeRatio") + "") && H(st2, $e2), 2 & e3 && Ve2 !== (Ve2 = t3[1]("metrics.liquidity.averageReturn") + "") && H(dt2, Ve2), 2 & e3 && ze2 !== (ze2 = t3[1]("metrics.liquidity.marketCapThreshold") + "") && H(_t2, ze2), 2 & e3 && Be2 !== (Be2 = t3[1]("metrics.liquidity.entryVolume") + "") && H(It2, Be2), 2 & e3 && Ue2 !== (Ue2 = t3[1]("metrics.liquidity.entryVolumeDescription").replace("{v1}", t3[2](Object.keys(t3[5].mean)[2], "zh")).replace("{v2}", (100 * Object.values(t3[5].portion)[2]).toFixed(1)) + "") && H(Lt2, Ue2), 2 & e3 && je2 !== (je2 = t3[1]("metrics.liquidity.tradeRatio") + "") && H(Jt2, je2), 2 & e3 && He2 !== (He2 = t3[1]("metrics.liquidity.averageReturn") + "") && H(ne2, He2), 2 & e3 && We2 !== (We2 = t3[1]("metrics.liquidity.volumeThreshold") + "") && H(he2, We2), 2 & e3 && qe2 !== (qe2 = t3[1]("metrics.liquidity.exitVolume") + "") && H(fe2, qe2), 2 & e3 && Ke2 !== (Ke2 = t3[1]("metrics.liquidity.exitVolumeDescription").replace("{v1}", t3[2](Object.keys(t3[6].mean)[2], "zh")).replace("{v2}", (100 * Object.values(t3[6].portion)[2]).toFixed(1)) + "") && H(ge2, Ke2), 2 & e3 && Ge2 !== (Ge2 = t3[1]("metrics.liquidity.tradeRatioExitVolume") + "") && H(_e2, Ge2), 2 & e3 && Ye2 !== (Ye2 = t3[1]("metrics.liquidity.averageReturn") + "") && H(Se2, Ye2), 2 & e3 && Qe2 !== (Qe2 = t3[1]("metrics.liquidity.volumeThreshold") + "") && H(Pe2, Qe2);
+        },
+        i: t,
+        o: t,
+        d(t3) {
+            t3 && E(i2), e2[12](null), e2[13](null), e2[14](null), e2[15](null);
+        }
+    };
+}
+
+function ol(t3, e2) {
+    const i2 = t3.filter((t4) => null !== t4);
+    if (0 === i2.length)
+        return 0;
+    const s2 = i2.sort((t4, e3) => t4 - e3),
+        n2 = (s2.length - 1) * e2,
+        r2 = Math.floor(n2),
+        o2 = n2 - r2;
+    return void 0 !== s2[r2 + 1] ? s2[r2] + o2 * (s2[r2 + 1] - s2[r2]) : s2[r2];
+}
+
+function al(t3, e2, i2 = 5) {
+    let s2 = {},
+        n2 = {};
+    t3 = t3.filter((t4) => null !== t4[e2] && void 0 !== t4[e2]);
+    for (let r2 of function(t4, e3 = 5) {
+            let i3 = [],
+                s3 = [5, 10];
+            for (; i3.length < t4;) {
+                for (let n3 of s3)
+                    if (i3.push(n3 * Math.pow(10, e3)), i3.length === t4)
+                        break;
+                e3 += 1;
+            }
+            return i3;
+        }(100, i2)) {
+        let i3 = t3.map((t4) => t4[e2]);
+        i3.sort((t4, e3) => t4 - e3);
+        let o2 = i3.findIndex((t4) => t4 > r2) / i3.length,
+            a2 = t3.filter((t4) => t4[e2] > r2).map((t4) => t4.return);
+        if (0 === o2 && (n2 = {}, s2 = {}), n2[r2] = ol(a2, 0.5), s2[r2] = 1 - o2, s2[r2] < 0.2)
+            break;
+    }
+    return {
+        portion: s2,
+        mean: n2
+    };
+}
+
+function ll(t3, e2, i2) {
+    let s2, {
+        lang: n2 = "en"
+    } = e2;
+    Chart.register(LinearScale, BarController, CategoryScale, BarElement, LineController, LineElement, PointElement, Ga), Chart.defaults.font.color = "red";
+    let {
+        browser: r2
+    } = e2, {
+        report: o2
+    } = e2, {
+        theme: a2 = "light"
+    } = e2;
+
+    function l2(t4, e3 = "zh") {
+        return "en" === n2 ? Math.abs(t4) >= 1e9 ? t4 / 1e9 + "B" : Math.abs(t4) >= 1e6 ? t4 / 1e6 + "M" : Math.abs(t4) >= 1e3 ? t4 / 1e3 + "K" : t4 : "zh" === e3 ? Math.abs(t4) >= 1e8 ? t4 / 1e8 + "億" : Math.abs(t4) >= 1e7 ? t4 / 1e7 + "千萬" : Math.abs(t4) >= 1e6 ? t4 / 1e6 + "百萬" : Math.abs(t4) >= 1e4 ? t4 / 1e4 + "萬" : t4 : void 0;
+    }
+
+    function h2(t4, e3, i3) {
+        return new Chart(e3, {
+            type: "bar",
+            data: {
+                labels: Object.keys(t4.portion),
+                datasets: [{
+                    label: "Data",
+                    data: Object.values(t4.portion),
+                    backgroundColor: "light" === a2 ? "#725bf5" : "#7a64f5",
+                    yAxisID: "y-axis-1",
+                    barPercentage: 0.2,
+                    order: 1
+                }, {
+                    label: "Line Data",
+                    data: Object.values(t4.mean),
+                    type: "line",
+                    fill: false,
+                    borderColor: "#f16365",
+                    borderWidth: 5,
+                    pointBackgroundColor: "#f16365",
+                    pointBorderColor: "#f16365",
+                    yAxisID: "y-axis-2",
+                    order: 0
+                }]
+            },
+            options: {
+                responsive: true,
+                maintainAspectRatio: true,
+                scales: {
+                    x: {
+                        type: "category",
+                        ticks: {
+                            color: "light" === a2 ? "#000000aa" : "#FFFFFFaa",
+                            callback: (e4) => l2(Object.keys(t4.portion)[e4], "zh") + i3 + "以上"
+                        },
+                        grid: {
+                            color: "#77777755",
+                            tickBorderDash: [2, 2]
+                        }
+                    },
+                    "y-axis-1": {
+                        display: true,
+                        position: "left",
+                        beginAtZero: true,
+                        ticks: {
+                            callback: (t5) => (100 * t5).toFixed(0) + "%",
+                            color: "light" === a2 ? "#000000aa" : "#FFFFFFaa"
+                        },
+                        grid: {
+                            color: "#77777755",
+                            tickBorderDash: [2, 2]
+                        }
+                    },
+                    "y-axis-2": {
+                        display: true,
+                        position: "right",
+                        ticks: {
+                            callback: (t5) => (100 * t5).toFixed(1) + "%",
+                            color: "light" === a2 ? "#000000aa" : "#FFFFFFaa"
+                        },
+                        grid: {
+                            drawOnChartArea: false,
+                            color: "#77777755",
+                            tickBorderDash: [2, 2]
+                        }
+                    }
+                }
+            }
+        });
+    }
+    o2.trades.forEach((t4) => {
+        t4.acceptMoneyFlow = (0.05 * t4["turnover@entry_date"] / t4.position + 0.05 * t4["turnover@entry_date"] / t4.position) / 2, "zh-tw" === n2 ? (t4["volume_@entry_date"] = t4["volume@entry_date"] / 1e3, t4["volume_@exit_date"] = t4["volume@exit_date"] / 1e3) : (t4["volume_@entry_date"] = t4["volume@entry_date"], t4["volume_@exit_date"] = t4["volume@exit_date"]);
+    });
+    const c2 = al(o2.trades, "acceptMoneyFlow", 5),
+        u2 = al(o2.trades, "market_value@entry_date", 5),
+        d2 = al(o2.trades, "volume_@entry_date", 1),
+        f2 = al(o2.trades, "volume_@exit_date", 1);
+    let p2 = {},
+        m2 = {};
+
+    function g2() {
+        p2.moneyFlow && (p2.moneyFlow.destroy(), delete p2.moneyFlow);
+        const t4 = m2.moneyFlow.getContext("2d");
+        p2.moneyFlow = h2(c2, t4, "元"), p2.marketValue && (p2.marketValue.destroy(), delete p2.marketValue);
+        const e3 = m2.marketValue.getContext("2d");
+        p2.marketValue = h2(u2, e3, "元"), p2.entryVolume && p2.entryVolume.destroy();
+        const i3 = m2.entryVolume.getContext("2d");
+        p2.entryVolume = h2(d2, i3, "張"), p2.exitVolume && p2.exitVolume.destroy();
+        const s3 = m2.exitVolume.getContext("2d");
+        p2.exitVolume = h2(f2, s3, "張");
+    }
+    let y2 = false;
+    return pt(() => {
+        r2 && (g2(), i2(11, y2 = true));
+    }), t3.$$set = (t4) => {
+        "lang" in t4 && i2(7, n2 = t4.lang), "browser" in t4 && i2(8, r2 = t4.browser), "report" in t4 && i2(9, o2 = t4.report), "theme" in t4 && i2(10, a2 = t4.theme);
+    }, t3.$$.update = () => {
+        128 & t3.$$.dirty && i2(1, s2 = (t4) => "en" === n2 ? sl(t4) : nl(t4)), 3072 & t3.$$.dirty && a2 && y2 && g2();
+    }, [m2, s2, l2, c2, u2, d2, f2, n2, r2, o2, a2, y2, function(t4) {
+        xt[t4 ? "unshift" : "push"](() => {
+            m2.moneyFlow = t4, i2(0, m2);
+        });
+    }, function(t4) {
+        xt[t4 ? "unshift" : "push"](() => {
+            m2.marketValue = t4, i2(0, m2);
+        });
+    }, function(t4) {
+        xt[t4 ? "unshift" : "push"](() => {
+            m2.entryVolume = t4, i2(0, m2);
+        });
+    }, function(t4) {
+        xt[t4 ? "unshift" : "push"](() => {
+            m2.exitVolume = t4, i2(0, m2);
+        });
+    }];
+}
+class Liquidity extends SvelteComponent {
+    constructor(t3) {
+        super(), ve(this, t3, ll, rl, o, {
+            lang: 7,
+            browser: 8,
+            report: 9,
+            theme: 10
+        });
+    }
+    get lang() {
+        return this.$$.ctx[7];
+    }
+    set lang(t3) {
+        this.$$set({
+            lang: t3
+        }), te();
+    }
+    get browser() {
+        return this.$$.ctx[8];
+    }
+    set browser(t3) {
+        this.$$set({
+            browser: t3
+        }), te();
+    }
+    get report() {
+        return this.$$.ctx[9];
+    }
+    set report(t3) {
+        this.$$set({
+            report: t3
+        }), te();
+    }
+    get theme() {
+        return this.$$.ctx[10];
+    }
+    set theme(t3) {
+        this.$$set({
+            theme: t3
+        }), te();
+    }
+}
+
+function hl(t3) {
+    var e2 = t3.width,
+        i2 = t3.height;
+    if (e2 < 0)
+        throw new Error("Negative width is not allowed for Size");
+    if (i2 < 0)
+        throw new Error("Negative height is not allowed for Size");
+    return {
+        width: e2,
+        height: i2
+    };
+}
+
+function cl(t3, e2) {
+    return t3.width === e2.width && t3.height === e2.height;
+}
+we(Liquidity, {
+    lang: {},
+    browser: {},
+    report: {},
+    theme: {}
+}, [], [], true);
+var ul = function() {
+    function t3(t4) {
+        var e2 = this;
+        this._resolutionListener = function() {
+            return e2._onResolutionChanged();
+        }, this._resolutionMediaQueryList = null, this._observers = [], this._window = t4, this._installResolutionListener();
+    }
+    return t3.prototype.dispose = function() {
+        this._uninstallResolutionListener(), this._window = null;
+    }, Object.defineProperty(t3.prototype, "value", {
+        get: function() {
+            return this._window.devicePixelRatio;
+        },
+        enumerable: false,
+        configurable: true
+    }), t3.prototype.subscribe = function(t4) {
+        var e2 = this,
+            i2 = {
+                next: t4
+            };
+        return this._observers.push(i2), {
+            unsubscribe: function() {
+                e2._observers = e2._observers.filter(function(t5) {
+                    return t5 !== i2;
+                });
+            }
+        };
+    }, t3.prototype._installResolutionListener = function() {
+        if (null !== this._resolutionMediaQueryList)
+            throw new Error("Resolution listener is already installed");
+        var t4 = this._window.devicePixelRatio;
+        this._resolutionMediaQueryList = this._window.matchMedia("all and (resolution: ".concat(t4, "dppx)")), this._resolutionMediaQueryList.addListener(this._resolutionListener);
+    }, t3.prototype._uninstallResolutionListener = function() {
+        null !== this._resolutionMediaQueryList && (this._resolutionMediaQueryList.removeListener(this._resolutionListener), this._resolutionMediaQueryList = null);
+    }, t3.prototype._reinstallResolutionListener = function() {
+        this._uninstallResolutionListener(), this._installResolutionListener();
+    }, t3.prototype._onResolutionChanged = function() {
+        var t4 = this;
+        this._observers.forEach(function(e2) {
+            return e2.next(t4._window.devicePixelRatio);
+        }), this._reinstallResolutionListener();
+    }, t3;
+}();
+var dl = function() {
+    function t3(t4, e2, i2) {
+        var s2;
+        this._canvasElement = null, this._bitmapSizeChangedListeners = [], this._suggestedBitmapSize = null, this._suggestedBitmapSizeChangedListeners = [], this._devicePixelRatioObservable = null, this._canvasElementResizeObserver = null, this._canvasElement = t4, this._canvasElementClientSize = hl({
+            width: this._canvasElement.clientWidth,
+            height: this._canvasElement.clientHeight
+        }), this._transformBitmapSize = null != e2 ? e2 : function(t5) {
+            return t5;
+        }, this._allowResizeObserver = null === (s2 = null == i2 ? void 0 : i2.allowResizeObserver) || void 0 === s2 || s2, this._chooseAndInitObserver();
+    }
+    return t3.prototype.dispose = function() {
+        var t4, e2;
+        if (null === this._canvasElement)
+            throw new Error("Object is disposed");
+        null === (t4 = this._canvasElementResizeObserver) || void 0 === t4 || t4.disconnect(), this._canvasElementResizeObserver = null, null === (e2 = this._devicePixelRatioObservable) || void 0 === e2 || e2.dispose(), this._devicePixelRatioObservable = null, this._suggestedBitmapSizeChangedListeners.length = 0, this._bitmapSizeChangedListeners.length = 0, this._canvasElement = null;
+    }, Object.defineProperty(t3.prototype, "canvasElement", {
+        get: function() {
+            if (null === this._canvasElement)
+                throw new Error("Object is disposed");
+            return this._canvasElement;
+        },
+        enumerable: false,
+        configurable: true
+    }), Object.defineProperty(t3.prototype, "canvasElementClientSize", {
+        get: function() {
+            return this._canvasElementClientSize;
+        },
+        enumerable: false,
+        configurable: true
+    }), Object.defineProperty(t3.prototype, "bitmapSize", {
+        get: function() {
+            return hl({
+                width: this.canvasElement.width,
+                height: this.canvasElement.height
+            });
+        },
+        enumerable: false,
+        configurable: true
+    }), t3.prototype.resizeCanvasElement = function(t4) {
+        this._canvasElementClientSize = hl(t4), this.canvasElement.style.width = "".concat(this._canvasElementClientSize.width, "px"), this.canvasElement.style.height = "".concat(this._canvasElementClientSize.height, "px"), this._invalidateBitmapSize();
+    }, t3.prototype.subscribeBitmapSizeChanged = function(t4) {
+        this._bitmapSizeChangedListeners.push(t4);
+    }, t3.prototype.unsubscribeBitmapSizeChanged = function(t4) {
+        this._bitmapSizeChangedListeners = this._bitmapSizeChangedListeners.filter(function(e2) {
+            return e2 !== t4;
+        });
+    }, Object.defineProperty(t3.prototype, "suggestedBitmapSize", {
+        get: function() {
+            return this._suggestedBitmapSize;
+        },
+        enumerable: false,
+        configurable: true
+    }), t3.prototype.subscribeSuggestedBitmapSizeChanged = function(t4) {
+        this._suggestedBitmapSizeChangedListeners.push(t4);
+    }, t3.prototype.unsubscribeSuggestedBitmapSizeChanged = function(t4) {
+        this._suggestedBitmapSizeChangedListeners = this._suggestedBitmapSizeChangedListeners.filter(function(e2) {
+            return e2 !== t4;
+        });
+    }, t3.prototype.applySuggestedBitmapSize = function() {
+        if (null !== this._suggestedBitmapSize) {
+            var t4 = this._suggestedBitmapSize;
+            this._suggestedBitmapSize = null, this._resizeBitmap(t4), this._emitSuggestedBitmapSizeChanged(t4, this._suggestedBitmapSize);
+        }
+    }, t3.prototype._resizeBitmap = function(t4) {
+        var e2 = this.bitmapSize;
+        cl(e2, t4) || (this.canvasElement.width = t4.width, this.canvasElement.height = t4.height, this._emitBitmapSizeChanged(e2, t4));
+    }, t3.prototype._emitBitmapSizeChanged = function(t4, e2) {
+        var i2 = this;
+        this._bitmapSizeChangedListeners.forEach(function(s2) {
+            return s2.call(i2, t4, e2);
+        });
+    }, t3.prototype._suggestNewBitmapSize = function(t4) {
+        var e2 = this._suggestedBitmapSize,
+            i2 = hl(this._transformBitmapSize(t4, this._canvasElementClientSize)),
+            s2 = cl(this.bitmapSize, i2) ? null : i2;
+        null === e2 && null === s2 || null !== e2 && null !== s2 && cl(e2, s2) || (this._suggestedBitmapSize = s2, this._emitSuggestedBitmapSizeChanged(e2, s2));
+    }, t3.prototype._emitSuggestedBitmapSizeChanged = function(t4, e2) {
+        var i2 = this;
+        this._suggestedBitmapSizeChangedListeners.forEach(function(s2) {
+            return s2.call(i2, t4, e2);
+        });
+    }, t3.prototype._chooseAndInitObserver = function() {
+        var t4 = this;
+        this._allowResizeObserver ? new Promise(function(t5) {
+            var e2 = new ResizeObserver(function(i2) {
+                t5(i2.every(function(t6) {
+                    return "devicePixelContentBoxSize" in t6;
+                })), e2.disconnect();
+            });
+            e2.observe(document.body, {
+                box: "device-pixel-content-box"
+            });
+        }).catch(function() {
+            return false;
+        }).then(function(e2) {
+            return e2 ? t4._initResizeObserver() : t4._initDevicePixelRatioObservable();
+        }) : this._initDevicePixelRatioObservable();
+    }, t3.prototype._initDevicePixelRatioObservable = function() {
+        var t4 = this;
+        if (null !== this._canvasElement) {
+            var e2 = fl(this._canvasElement);
+            if (null === e2)
+                throw new Error("No window is associated with the canvas");
+            this._devicePixelRatioObservable = function(t5) {
+                return new ul(t5);
+            }(e2), this._devicePixelRatioObservable.subscribe(function() {
+                return t4._invalidateBitmapSize();
+            }), this._invalidateBitmapSize();
+        }
+    }, t3.prototype._invalidateBitmapSize = function() {
+        var t4, e2;
+        if (null !== this._canvasElement) {
+            var i2 = fl(this._canvasElement);
+            if (null !== i2) {
+                var s2 = null !== (e2 = null === (t4 = this._devicePixelRatioObservable) || void 0 === t4 ? void 0 : t4.value) && void 0 !== e2 ? e2 : i2.devicePixelRatio,
+                    n2 = this._canvasElement.getClientRects(),
+                    r2 = void 0 !== n2[0] ? function(t5, e3) {
+                        return hl({
+                            width: Math.round(t5.left * e3 + t5.width * e3) - Math.round(t5.left * e3),
+                            height: Math.round(t5.top * e3 + t5.height * e3) - Math.round(t5.top * e3)
+                        });
+                    }(n2[0], s2) : hl({
+                        width: this._canvasElementClientSize.width * s2,
+                        height: this._canvasElementClientSize.height * s2
+                    });
+                this._suggestNewBitmapSize(r2);
+            }
+        }
+    }, t3.prototype._initResizeObserver = function() {
+        var t4 = this;
+        null !== this._canvasElement && (this._canvasElementResizeObserver = new ResizeObserver(function(e2) {
+            var i2 = e2.find(function(e3) {
+                return e3.target === t4._canvasElement;
+            });
+            if (i2 && i2.devicePixelContentBoxSize && i2.devicePixelContentBoxSize[0]) {
+                var s2 = i2.devicePixelContentBoxSize[0],
+                    n2 = hl({
+                        width: s2.inlineSize,
+                        height: s2.blockSize
+                    });
+                t4._suggestNewBitmapSize(n2);
+            }
+        }), this._canvasElementResizeObserver.observe(this._canvasElement, {
+            box: "device-pixel-content-box"
+        }));
+    }, t3;
+}();
+
+function fl(t3) {
+    return t3.ownerDocument.defaultView;
+}
+var pl, ml, gl, yl = function() {
+    function t3(t4, e2, i2) {
+        if (0 === e2.width || 0 === e2.height)
+            throw new TypeError("Rendering target could only be created on a media with positive width and height");
+        if (this._mediaSize = e2, 0 === i2.width || 0 === i2.height)
+            throw new TypeError("Rendering target could only be created using a bitmap with positive integer width and height");
+        this._bitmapSize = i2, this._context = t4;
+    }
+    return t3.prototype.useMediaCoordinateSpace = function(t4) {
+        try {
+            return this._context.save(), this._context.setTransform(1, 0, 0, 1, 0, 0), this._context.scale(this._horizontalPixelRatio, this._verticalPixelRatio), t4({
+                context: this._context,
+                mediaSize: this._mediaSize
+            });
+        } finally {
+            this._context.restore();
+        }
+    }, t3.prototype.useBitmapCoordinateSpace = function(t4) {
+        try {
+            return this._context.save(), this._context.setTransform(1, 0, 0, 1, 0, 0), t4({
+                context: this._context,
+                mediaSize: this._mediaSize,
+                bitmapSize: this._bitmapSize,
+                horizontalPixelRatio: this._horizontalPixelRatio,
+                verticalPixelRatio: this._verticalPixelRatio
+            });
+        } finally {
+            this._context.restore();
+        }
+    }, Object.defineProperty(t3.prototype, "_horizontalPixelRatio", {
+        get: function() {
+            return this._bitmapSize.width / this._mediaSize.width;
+        },
+        enumerable: false,
+        configurable: true
+    }), Object.defineProperty(t3.prototype, "_verticalPixelRatio", {
+        get: function() {
+            return this._bitmapSize.height / this._mediaSize.height;
+        },
+        enumerable: false,
+        configurable: true
+    }), t3;
+}();
+
+function vl(t3, e2) {
+    var i2 = t3.canvasElementClientSize;
+    if (0 === i2.width || 0 === i2.height)
+        return null;
+    var s2 = t3.bitmapSize;
+    if (0 === s2.width || 0 === s2.height)
+        return null;
+    var n2 = t3.canvasElement.getContext("2d", e2);
+    return null === n2 ? null : new yl(n2, i2, s2);
+}
+
+function bl(t3, e2) {
+    const i2 = {
+        0: [],
+        1: [t3.lineWidth, t3.lineWidth],
+        2: [2 * t3.lineWidth, 2 * t3.lineWidth],
+        3: [6 * t3.lineWidth, 6 * t3.lineWidth],
+        4: [t3.lineWidth, 4 * t3.lineWidth]
+    } [e2];
+    t3.setLineDash(i2);
+}
+
+function _l(t3, e2, i2, s2) {
+    t3.beginPath();
+    const n2 = t3.lineWidth % 2 ? 0.5 : 0;
+    t3.moveTo(i2, e2 + n2), t3.lineTo(s2, e2 + n2), t3.stroke();
+}
+
+function wl(t3, e2) {
+    if (!t3)
+        throw new Error("Assertion failed" + (e2 ? ": " + e2 : ""));
+}
+
+function xl(t3) {
+    if (void 0 === t3)
+        throw new Error("Value is undefined");
+    return t3;
+}
+
+function kl(t3) {
+    if (null === t3)
+        throw new Error("Value is null");
+    return t3;
+}
+
+function Tl(t3) {
+    return kl(xl(t3));
+}
+(gl = pl || (pl = {}))[gl.Simple = 0] = "Simple", gl[gl.WithSteps = 1] = "WithSteps", gl[gl.Curved = 2] = "Curved",
+    function(t3) {
+        t3[t3.Solid = 0] = "Solid", t3[t3.Dotted = 1] = "Dotted", t3[t3.Dashed = 2] = "Dashed", t3[t3.LargeDashed = 3] = "LargeDashed", t3[t3.SparseDotted = 4] = "SparseDotted";
+    }(ml || (ml = {}));
+const Sl = {
+    khaki: "#f0e68c",
+    azure: "#f0ffff",
+    aliceblue: "#f0f8ff",
+    ghostwhite: "#f8f8ff",
+    gold: "#ffd700",
+    goldenrod: "#daa520",
+    gainsboro: "#dcdcdc",
+    gray: "#808080",
+    green: "#008000",
+    honeydew: "#f0fff0",
+    floralwhite: "#fffaf0",
+    lightblue: "#add8e6",
+    lightcoral: "#f08080",
+    lemonchiffon: "#fffacd",
+    hotpink: "#ff69b4",
+    lightyellow: "#ffffe0",
+    greenyellow: "#adff2f",
+    lightgoldenrodyellow: "#fafad2",
+    limegreen: "#32cd32",
+    linen: "#faf0e6",
+    lightcyan: "#e0ffff",
+    magenta: "#f0f",
+    maroon: "#800000",
+    olive: "#808000",
+    orange: "#ffa500",
+    oldlace: "#fdf5e6",
+    mediumblue: "#0000cd",
+    transparent: "#0000",
+    lime: "#0f0",
+    lightpink: "#ffb6c1",
+    mistyrose: "#ffe4e1",
+    moccasin: "#ffe4b5",
+    midnightblue: "#191970",
+    orchid: "#da70d6",
+    mediumorchid: "#ba55d3",
+    mediumturquoise: "#48d1cc",
+    orangered: "#ff4500",
+    royalblue: "#4169e1",
+    powderblue: "#b0e0e6",
+    red: "#f00",
+    coral: "#ff7f50",
+    turquoise: "#40e0d0",
+    white: "#fff",
+    whitesmoke: "#f5f5f5",
+    wheat: "#f5deb3",
+    teal: "#008080",
+    steelblue: "#4682b4",
+    bisque: "#ffe4c4",
+    aquamarine: "#7fffd4",
+    aqua: "#0ff",
+    sienna: "#a0522d",
+    silver: "#c0c0c0",
+    springgreen: "#00ff7f",
+    antiquewhite: "#faebd7",
+    burlywood: "#deb887",
+    brown: "#a52a2a",
+    beige: "#f5f5dc",
+    chocolate: "#d2691e",
+    chartreuse: "#7fff00",
+    cornflowerblue: "#6495ed",
+    cornsilk: "#fff8dc",
+    crimson: "#dc143c",
+    cadetblue: "#5f9ea0",
+    tomato: "#ff6347",
+    fuchsia: "#f0f",
+    blue: "#00f",
+    salmon: "#fa8072",
+    blanchedalmond: "#ffebcd",
+    slateblue: "#6a5acd",
+    slategray: "#708090",
+    thistle: "#d8bfd8",
+    tan: "#d2b48c",
+    cyan: "#0ff",
+    darkblue: "#00008b",
+    darkcyan: "#008b8b",
+    darkgoldenrod: "#b8860b",
+    darkgray: "#a9a9a9",
+    blueviolet: "#8a2be2",
+    black: "#000",
+    darkmagenta: "#8b008b",
+    darkslateblue: "#483d8b",
+    darkkhaki: "#bdb76b",
+    darkorchid: "#9932cc",
+    darkorange: "#ff8c00",
+    darkgreen: "#006400",
+    darkred: "#8b0000",
+    dodgerblue: "#1e90ff",
+    darkslategray: "#2f4f4f",
+    dimgray: "#696969",
+    deepskyblue: "#00bfff",
+    firebrick: "#b22222",
+    forestgreen: "#228b22",
+    indigo: "#4b0082",
+    ivory: "#fffff0",
+    lavenderblush: "#fff0f5",
+    feldspar: "#d19275",
+    indianred: "#cd5c5c",
+    lightgreen: "#90ee90",
+    lightgrey: "#d3d3d3",
+    lightskyblue: "#87cefa",
+    lightslategray: "#789",
+    lightslateblue: "#8470ff",
+    snow: "#fffafa",
+    lightseagreen: "#20b2aa",
+    lightsalmon: "#ffa07a",
+    darksalmon: "#e9967a",
+    darkviolet: "#9400d3",
+    mediumpurple: "#9370d8",
+    mediumaquamarine: "#66cdaa",
+    skyblue: "#87ceeb",
+    lavender: "#e6e6fa",
+    lightsteelblue: "#b0c4de",
+    mediumvioletred: "#c71585",
+    mintcream: "#f5fffa",
+    navajowhite: "#ffdead",
+    navy: "#000080",
+    olivedrab: "#6b8e23",
+    palevioletred: "#d87093",
+    violetred: "#d02090",
+    yellow: "#ff0",
+    yellowgreen: "#9acd32",
+    lawngreen: "#7cfc00",
+    pink: "#ffc0cb",
+    paleturquoise: "#afeeee",
+    palegoldenrod: "#eee8aa",
+    darkolivegreen: "#556b2f",
+    darkseagreen: "#8fbc8f",
+    darkturquoise: "#00ced1",
+    peachpuff: "#ffdab9",
+    deeppink: "#ff1493",
+    violet: "#ee82ee",
+    palegreen: "#98fb98",
+    mediumseagreen: "#3cb371",
+    peru: "#cd853f",
+    saddlebrown: "#8b4513",
+    sandybrown: "#f4a460",
+    rosybrown: "#bc8f8f",
+    purple: "#800080",
+    seagreen: "#2e8b57",
+    seashell: "#fff5ee",
+    papayawhip: "#ffefd5",
+    mediumslateblue: "#7b68ee",
+    plum: "#dda0dd",
+    mediumspringgreen: "#00fa9a"
+};
+
+function El(t3) {
+    return t3 < 0 ? 0 : t3 > 255 ? 255 : Math.round(t3) || 0;
+}
+
+function Cl(t3) {
+    return t3 <= 0 || t3 > 0 ? t3 < 0 ? 0 : t3 > 1 ? 1 : Math.round(1e4 * t3) / 1e4 : 0;
+}
+const Il = /^#([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])?$/i,
+    Ml = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i,
+    Pl = /^rgb\(\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*\)$/,
+    Rl = /^rgba\(\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?[\d]{0,10}(?:\.\d+)?)\s*\)$/;
+
+function Al(t3) {
+    (t3 = t3.toLowerCase()) in Sl && (t3 = Sl[t3]);
+    {
+        const e2 = Rl.exec(t3) || Pl.exec(t3);
+        if (e2)
+            return [El(parseInt(e2[1], 10)), El(parseInt(e2[2], 10)), El(parseInt(e2[3], 10)), Cl(e2.length < 5 ? 1 : parseFloat(e2[4]))];
+    } {
+        const e2 = Ml.exec(t3);
+        if (e2)
+            return [El(parseInt(e2[1], 16)), El(parseInt(e2[2], 16)), El(parseInt(e2[3], 16)), 1];
+    } {
+        const e2 = Il.exec(t3);
+        if (e2)
+            return [El(17 * parseInt(e2[1], 16)), El(17 * parseInt(e2[2], 16)), El(17 * parseInt(e2[3], 16)), 1];
+    }
+    throw new Error(`Cannot parse color: ${t3}`);
+}
+
+function Dl(t3) {
+    const e2 = Al(t3);
+    return {
+        t: `rgb(${e2[0]}, ${e2[1]}, ${e2[2]})`,
+        i: (i2 = e2, 0.199 * i2[0] + 0.687 * i2[1] + 0.114 * i2[2] > 160 ? "black" : "white")
+    };
+    var i2;
+}
+let Ll = class M {
+    constructor() {
+        this.h = [];
+    }
+    l(t3, e2, i2) {
+        const s2 = {
+            o: t3,
+            _: e2,
+            u: true === i2
+        };
+        this.h.push(s2);
+    }
+    p(t3) {
+        const e2 = this.h.findIndex((e3) => t3 === e3.o);
+        e2 > -1 && this.h.splice(e2, 1);
+    }
+    v(t3) {
+        this.h = this.h.filter((e2) => e2._ !== t3);
+    }
+    m(t3, e2, i2) {
+        const s2 = [...this.h];
+        this.h = this.h.filter((t4) => !t4.u), s2.forEach((s3) => s3.o(t3, e2, i2));
+    }
+    g() {
+        return this.h.length > 0;
+    }
+    M() {
+        this.h = [];
+    }
+};
+
+function Ol(t3, ...e2) {
+    for (const i2 of e2)
+        for (const e3 in i2)
+            void 0 !== i2[e3] && ("object" != typeof i2[e3] || void 0 === t3[e3] ? t3[e3] = i2[e3] : Ol(t3[e3], i2[e3]));
+    return t3;
+}
+
+function Fl(t3) {
+    return "number" == typeof t3 && isFinite(t3);
+}
+
+function Nl(t3) {
+    return "number" == typeof t3 && t3 % 1 == 0;
+}
+
+function $l(t3) {
+    return "string" == typeof t3;
+}
+
+function Vl(t3) {
+    return "boolean" == typeof t3;
+}
+
+function zl(t3) {
+    const e2 = t3;
+    if (!e2 || "object" != typeof e2)
+        return e2;
+    let i2, s2, n2;
+    for (s2 in i2 = Array.isArray(e2) ? [] : {}, e2)
+        e2.hasOwnProperty(s2) && (n2 = e2[s2], i2[s2] = n2 && "object" == typeof n2 ? zl(n2) : n2);
+    return i2;
+}
+
+function Bl(t3) {
+    return null !== t3;
+}
+
+function Ul(t3) {
+    return null === t3 ? void 0 : t3;
+}
+const jl = "-apple-system, BlinkMacSystemFont, 'Trebuchet MS', Roboto, Ubuntu, sans-serif";
+
+function Hl(t3, e2, i2) {
+    return void 0 === e2 && (e2 = jl), `${i2 = void 0 !== i2 ? `${i2} ` : ""}${t3}px ${e2}`;
+}
+let Wl = class O {
+    constructor() {
+        this.q = [];
+    }
+    Y(t3) {
+        this.q = t3;
+    }
+    X(t3, e2, i2) {
+        this.q.forEach((s2) => {
+            s2.X(t3, e2, i2);
+        });
+    }
+};
+class L {
+    X(t3, e2, i2) {
+        t3.useMediaCoordinateSpace((t4) => this.Z(t4, e2, i2));
+    }
+    K(t3, e2, i2) {
+        t3.useMediaCoordinateSpace((t4) => this.G(t4, e2, i2));
+    }
+    G(t3, e2, i2) {}
+}
+let ql = class I extends L {
+    constructor() {
+        super(...arguments), this.J = null;
+    }
+    tt(t3) {
+        this.J = t3;
+    }
+    Z({
+        context: t3
+    }) {
+        if (null === this.J || null === this.J.it)
+            return;
+        const e2 = this.J.it,
+            i2 = this.J,
+            s2 = (s3) => {
+                t3.beginPath();
+                for (let n2 = e2.to - 1; n2 >= e2.from; --n2) {
+                    const e3 = i2.nt[n2];
+                    t3.moveTo(e3.st, e3.et), t3.arc(e3.st, e3.et, s3, 0, 2 * Math.PI);
+                }
+                t3.fill();
+            };
+        i2.rt > 0 && (t3.fillStyle = i2.ht, s2(i2.lt + i2.rt)), t3.fillStyle = i2.ot, s2(i2.lt);
+    }
+};
+
+function Kl() {
+    return {
+        nt: [{
+            st: 0,
+            et: 0,
+            _t: 0,
+            ut: 0
+        }],
+        ot: "",
+        ht: "",
+        lt: 0,
+        rt: 0,
+        it: null
+    };
+}
+const Gl = {
+    from: 0,
+    to: 1
+};
+let Yl = class N {
+        X(t3, e2, i2) {
+            t3.useBitmapCoordinateSpace((t4) => this.Z(t4, e2, i2));
+        }
+    },
+    Ql = class F extends Yl {
+        constructor(t3) {
+            super(), this.zt = t3;
+        }
+        Z({
+            context: t3,
+            bitmapSize: e2,
+            horizontalPixelRatio: i2,
+            verticalPixelRatio: s2
+        }) {
+            if (null === this.zt)
+                return;
+            const n2 = this.zt.Vt.Ct,
+                r2 = this.zt.Nt.Ct;
+            if (!n2 && !r2)
+                return;
+            const o2 = Math.round(this.zt.st * i2),
+                a2 = Math.round(this.zt.et * s2);
+            t3.lineCap = "butt", n2 && o2 >= 0 && (t3.lineWidth = Math.floor(this.zt.Vt.rt * i2), t3.strokeStyle = this.zt.Vt.D, t3.fillStyle = this.zt.Vt.D, bl(t3, this.zt.Vt.Ft), function(t4, e3, i3, s3) {
+                t4.beginPath();
+                const n3 = t4.lineWidth % 2 ? 0.5 : 0;
+                t4.moveTo(e3 + n3, 0), t4.lineTo(e3 + n3, s3), t4.stroke();
+            }(t3, o2, 0, e2.height)), r2 && a2 >= 0 && (t3.lineWidth = Math.floor(this.zt.Nt.rt * s2), t3.strokeStyle = this.zt.Nt.D, t3.fillStyle = this.zt.Nt.D, bl(t3, this.zt.Nt.Ft), _l(t3, a2, 0, e2.width));
+        }
+    };
+
+function Xl(t3, e2, i2, s2, n2, r2) {
+    t3.fillRect(e2 + r2, i2, s2 - 2 * r2, r2), t3.fillRect(e2 + r2, i2 + n2 - r2, s2 - 2 * r2, r2), t3.fillRect(e2, i2, r2, n2), t3.fillRect(e2 + s2 - r2, i2, r2, n2);
+}
+
+function Jl(t3, e2, i2, s2, n2, r2) {
+    t3.save(), t3.globalCompositeOperation = "copy", t3.fillStyle = r2, t3.fillRect(e2, i2, s2, n2), t3.restore();
+}
+
+function Zl(t3, e2) {
+    return Array.isArray(t3) ? t3.map((t4) => 0 === t4 ? t4 : t4 + e2) : t3 + e2;
+}
+
+function th(t3, e2, i2, s2, n2, r2) {
+    let o2, a2, l2, h2;
+    if (Array.isArray(r2))
+        if (2 === r2.length) {
+            const t4 = Math.max(0, r2[0]),
+                e3 = Math.max(0, r2[1]);
+            o2 = t4, a2 = t4, l2 = e3, h2 = e3;
+        } else {
+            if (4 !== r2.length)
+                throw new Error("Wrong border radius - it should be like css border radius");
+            o2 = Math.max(0, r2[0]), a2 = Math.max(0, r2[1]), l2 = Math.max(0, r2[2]), h2 = Math.max(0, r2[3]);
+        }
+    else {
+        const t4 = Math.max(0, r2);
+        o2 = t4, a2 = t4, l2 = t4, h2 = t4;
+    }
+    t3.beginPath(), t3.moveTo(e2 + o2, i2), t3.lineTo(e2 + s2 - a2, i2), 0 !== a2 && t3.arcTo(e2 + s2, i2, e2 + s2, i2 + a2, a2), t3.lineTo(e2 + s2, i2 + n2 - l2), 0 !== l2 && t3.arcTo(e2 + s2, i2 + n2, e2 + s2 - l2, i2 + n2, l2), t3.lineTo(e2 + h2, i2 + n2), 0 !== h2 && t3.arcTo(e2, i2 + n2, e2, i2 + n2 - h2, h2), t3.lineTo(e2, i2 + o2), 0 !== o2 && t3.arcTo(e2, i2, e2 + o2, i2, o2);
+}
+
+function eh(t3, e2, i2, s2, n2, r2, o2 = 0, a2 = 0, l2 = "") {
+    if (t3.save(), !o2 || !l2 || l2 === r2)
+        return th(t3, e2, i2, s2, n2, a2), t3.fillStyle = r2, t3.fill(), void t3.restore();
+    const h2 = o2 / 2;
+    "transparent" !== r2 && (th(t3, e2 + o2, i2 + o2, s2 - 2 * o2, n2 - 2 * o2, Zl(a2, -o2)), t3.fillStyle = r2, t3.fill()), "transparent" !== l2 && (th(t3, e2 + h2, i2 + h2, s2 - o2, n2 - o2, Zl(a2, -h2)), t3.lineWidth = o2, t3.strokeStyle = l2, t3.closePath(), t3.stroke()), t3.restore();
+}
+
+function ih(t3, e2, i2, s2, n2, r2, o2) {
+    t3.save(), t3.globalCompositeOperation = "copy";
+    const a2 = t3.createLinearGradient(0, 0, 0, n2);
+    a2.addColorStop(0, r2), a2.addColorStop(1, o2), t3.fillStyle = a2, t3.fillRect(e2, i2, s2, n2), t3.restore();
+}
+let sh = class X {
+        constructor(t3, e2) {
+            this.tt(t3, e2);
+        }
+        tt(t3, e2) {
+            this.zt = t3, this.Kt = e2;
+        }
+        It(t3, e2) {
+            return this.zt.Ct ? t3.T + t3.I + t3.A : 0;
+        }
+        X(t3, e2, i2, s2) {
+            if (!this.zt.Ct || 0 === this.zt.Gt.length)
+                return;
+            const n2 = this.zt.D,
+                r2 = this.Kt.t,
+                o2 = t3.useBitmapCoordinateSpace((t4) => {
+                    const o3 = t4.context;
+                    o3.font = e2.P;
+                    const a2 = this.Jt(t4, e2, i2, s2),
+                        l2 = a2.Qt,
+                        h2 = (t5, e3) => {
+                            a2.ti ? eh(o3, l2.ii, l2.ni, l2.si, l2.ei, t5, l2.ri, [l2.lt, 0, 0, l2.lt], e3) : eh(o3, l2.hi, l2.ni, l2.si, l2.ei, t5, l2.ri, [0, l2.lt, l2.lt, 0], e3);
+                        };
+                    return h2(r2, "transparent"), this.zt.li && (o3.fillStyle = n2, o3.fillRect(l2.hi, l2.ai, l2.oi - l2.hi, l2._i)), h2("transparent", r2), this.zt.ui && (o3.fillStyle = e2.B, o3.fillRect(a2.ti ? l2.ci - l2.ri : 0, l2.ni, l2.ri, l2.di - l2.ni)), a2;
+                });
+            t3.useMediaCoordinateSpace(({
+                context: t4
+            }) => {
+                const i3 = o2.fi;
+                t4.font = e2.P, t4.textAlign = o2.ti ? "right" : "left", t4.textBaseline = "middle", t4.fillStyle = n2, t4.fillText(this.zt.Gt, i3.pi, (i3.ni + i3.di) / 2 + i3.vi);
+            });
+        }
+        Jt(t3, e2, i2, s2) {
+            var n2;
+            const {
+                context: r2,
+                bitmapSize: o2,
+                mediaSize: a2,
+                horizontalPixelRatio: l2,
+                verticalPixelRatio: h2
+            } = t3, c2 = this.zt.li || !this.zt.mi ? e2.C : 0, u2 = this.zt.bi ? e2.k : 0, d2 = e2.I + this.Kt.gi, f2 = e2.A + this.Kt.wi, p2 = e2.O, m2 = e2.L, g2 = this.zt.Gt, y2 = e2.T, v2 = i2.Mi(r2, g2), b2 = Math.ceil(i2.Si(r2, g2)), _2 = y2 + d2 + f2, w2 = e2.k + p2 + m2 + b2 + c2, x2 = Math.max(1, Math.floor(h2));
+            let k2 = Math.round(_2 * h2);
+            k2 % 2 != x2 % 2 && (k2 += 1);
+            const T2 = u2 > 0 ? Math.max(1, Math.floor(u2 * l2)) : 0,
+                S2 = Math.round(w2 * l2),
+                E2 = Math.round(c2 * l2),
+                C2 = null !== (n2 = this.Kt.xi) && void 0 !== n2 ? n2 : this.Kt.yi,
+                P2 = Math.round(C2 * h2) - Math.floor(0.5 * h2),
+                R2 = Math.floor(P2 + x2 / 2 - k2 / 2),
+                D2 = R2 + k2,
+                $2 = "right" === s2,
+                z2 = $2 ? a2.width - u2 : u2,
+                B2 = $2 ? o2.width - T2 : T2;
+            let U2, j2, H2;
+            return $2 ? (U2 = B2 - S2, j2 = B2 - E2, H2 = z2 - c2 - p2 - u2) : (U2 = B2 + S2, j2 = B2 + E2, H2 = z2 + c2 + p2), {
+                ti: $2,
+                Qt: {
+                    ni: R2,
+                    ai: P2,
+                    di: D2,
+                    si: S2,
+                    ei: k2,
+                    lt: 2 * l2,
+                    ri: T2,
+                    ii: U2,
+                    hi: B2,
+                    oi: j2,
+                    _i: x2,
+                    ci: o2.width
+                },
+                fi: {
+                    ni: R2 / h2,
+                    di: D2 / h2,
+                    pi: H2,
+                    vi: v2
+                }
+            };
+        }
+    },
+    nh = class Z {
+        constructor(t3) {
+            this.ki = {
+                yi: 0,
+                t: "#000",
+                wi: 0,
+                gi: 0
+            }, this.Ci = {
+                Gt: "",
+                Ct: false,
+                li: true,
+                mi: false,
+                Ot: "",
+                D: "#FFF",
+                ui: false,
+                bi: false
+            }, this.Ti = {
+                Gt: "",
+                Ct: false,
+                li: false,
+                mi: true,
+                Ot: "",
+                D: "#FFF",
+                ui: true,
+                bi: true
+            }, this.vt = true, this.Pi = new(t3 || sh)(this.Ci, this.ki), this.Ri = new(t3 || sh)(this.Ti, this.ki);
+        }
+        Gt() {
+            return this.Di(), this.Ci.Gt;
+        }
+        yi() {
+            return this.Di(), this.ki.yi;
+        }
+        gt() {
+            this.vt = true;
+        }
+        It(t3, e2 = false) {
+            return Math.max(this.Pi.It(t3, e2), this.Ri.It(t3, e2));
+        }
+        Bi() {
+            return this.ki.xi || 0;
+        }
+        Ai(t3) {
+            this.ki.xi = t3;
+        }
+        Oi() {
+            return this.Di(), this.Ci.Ct || this.Ti.Ct;
+        }
+        Li() {
+            return this.Di(), this.Ci.Ct;
+        }
+        Mt(t3) {
+            return this.Di(), this.Ci.li = this.Ci.li && t3.F().ticksVisible, this.Ti.li = this.Ti.li && t3.F().ticksVisible, this.Pi.tt(this.Ci, this.ki), this.Ri.tt(this.Ti, this.ki), this.Pi;
+        }
+        Ii() {
+            return this.Di(), this.Pi.tt(this.Ci, this.ki), this.Ri.tt(this.Ti, this.ki), this.Ri;
+        }
+        Di() {
+            this.vt && (this.Ci.li = true, this.Ti.li = false, this.Ei(this.Ci, this.Ti, this.ki));
+        }
+    },
+    rh = class K extends nh {
+        constructor(t3, e2, i2) {
+            super(), this.$t = t3, this.zi = e2, this.Vi = i2;
+        }
+        Ei(t3, e2, i2) {
+            t3.Ct = false;
+            const s2 = this.$t.F().horzLine;
+            if (!s2.labelVisible)
+                return;
+            const n2 = this.zi.Tt();
+            if (!this.$t.Ct() || this.zi.Ni() || null === n2)
+                return;
+            const r2 = Dl(s2.labelBackgroundColor);
+            i2.t = r2.t, t3.D = r2.i;
+            const o2 = 2 / 12 * this.zi.T();
+            i2.gi = o2, i2.wi = o2;
+            const a2 = this.Vi(this.zi);
+            i2.yi = a2.yi, t3.Gt = this.zi.Fi(a2.ut, n2), t3.Ct = true;
+        }
+    };
+const oh = /[1-9]/g;
+class tt {
+    constructor() {
+        this.Yi = null, this.Xi = 0;
+    }
+    Zi() {
+        return this.Xi;
+    }
+    Ki(t3) {
+        this.Xi = t3;
+    }
+    Bt() {
+        return this.Yi;
+    }
+    Gi(t3) {
+        this.Yi = t3;
+    }
+    Ji(t3) {
+        return [];
+    }
+    Qi() {
+        return [];
+    }
+    Ct() {
+        return true;
+    }
+}
+var ah;
+! function(t3) {
+    t3[t3.Normal = 0] = "Normal", t3[t3.Magnet = 1] = "Magnet";
+}(ah || (ah = {}));
+class nt extends tt {
+    constructor(t3, e2) {
+        super(), this.tn = null, this.nn = NaN, this.sn = 0, this.en = true, this.rn = /* @__PURE__ */ new Map(), this.hn = false, this.ln = NaN, this.an = NaN, this.on = NaN, this._n = NaN, this.Hi = t3, this.un = e2, this.cn = new class V {
+            constructor(t4, e3) {
+                this.ct = new Wl(), this.dt = [], this.ft = [], this.vt = true, this.N = t4, this.bt = e3, this.ct.Y(this.dt);
+            }
+            gt(t4) {
+                const e3 = this.N.wt();
+                e3.length !== this.dt.length && (this.ft = e3.map(Kl), this.dt = this.ft.map((t5) => {
+                    const e4 = new ql();
+                    return e4.tt(t5), e4;
+                }), this.ct.Y(this.dt)), this.vt = true;
+            }
+            Mt() {
+                return this.vt && (this.St(), this.vt = false), this.ct;
+            }
+            St() {
+                const t4 = this.N.wt(),
+                    e3 = this.bt.xt(),
+                    i3 = this.N.yt();
+                t4.forEach((t5, s2) => {
+                    var n2;
+                    const r2 = this.ft[s2],
+                        o2 = t5.kt(e3);
+                    if (null === o2 || !t5.Ct())
+                        return void(r2.it = null);
+                    const a2 = kl(t5.Tt());
+                    r2.ot = o2.Pt, r2.lt = o2.lt, r2.rt = o2.Rt, r2.nt[0].ut = o2.ut, r2.nt[0].et = t5.Bt().Dt(o2.ut, a2.At), r2.ht = null !== (n2 = o2.Ot) && void 0 !== n2 ? n2 : this.N.Lt(r2.nt[0].et / t5.Bt().It()), r2.nt[0]._t = e3, r2.nt[0].st = i3.Et(e3), r2.it = Gl;
+                });
+            }
+        }(t3, this), this.dn = ((t4, e3) => (i3) => {
+            const s2 = e3(),
+                n2 = t4();
+            if (i3 === kl(this.tn).fn())
+                return {
+                    ut: n2,
+                    yi: s2
+                };
+            {
+                const t5 = kl(i3.Tt());
+                return {
+                    ut: i3.pn(s2, t5),
+                    yi: s2
+                };
+            }
+        })(() => this.nn, () => this.an);
+        const i2 = ((t4, e3) => () => {
+            const i3 = this.Hi.yt().vn(t4()),
+                s2 = e3();
+            return i3 && Number.isFinite(s2) ? {
+                _t: i3,
+                yi: s2
+            } : null;
+        })(() => this.sn, () => this.Xt());
+        this.mn = new class Q {
+            constructor(t4, e3, i3) {
+                this.vt = true, this.jt = new class J {
+                    constructor() {
+                        this.zt = null;
+                    }
+                    tt(t5) {
+                        this.zt = t5;
+                    }
+                    X(t5, e4) {
+                        if (null === this.zt || false === this.zt.Ct || 0 === this.zt.Gt.length)
+                            return;
+                        const i4 = t5.useMediaCoordinateSpace(({
+                            context: t6
+                        }) => (t6.font = e4.P, Math.round(e4.Wi.Si(t6, kl(this.zt).Gt, oh))));
+                        if (i4 <= 0)
+                            return;
+                        const s2 = e4.ji,
+                            n2 = i4 + 2 * s2,
+                            r2 = n2 / 2,
+                            o2 = this.zt.$i;
+                        let a2 = this.zt.yi,
+                            l2 = Math.floor(a2 - r2) + 0.5;
+                        l2 < 0 ? (a2 += Math.abs(0 - l2), l2 = Math.floor(a2 - r2) + 0.5) : l2 + n2 > o2 && (a2 -= Math.abs(o2 - (l2 + n2)), l2 = Math.floor(a2 - r2) + 0.5);
+                        const h2 = l2 + n2,
+                            c2 = Math.ceil(0 + e4.k + e4.C + e4.I + e4.T + e4.A);
+                        t5.useBitmapCoordinateSpace(({
+                            context: t6,
+                            horizontalPixelRatio: i5,
+                            verticalPixelRatio: s3
+                        }) => {
+                            const n3 = kl(this.zt);
+                            t6.fillStyle = n3.t;
+                            const r3 = Math.round(l2 * i5),
+                                o3 = Math.round(0 * s3),
+                                a3 = Math.round(h2 * i5),
+                                u2 = Math.round(c2 * s3),
+                                d2 = Math.round(2 * i5);
+                            if (t6.beginPath(), t6.moveTo(r3, o3), t6.lineTo(r3, u2 - d2), t6.arcTo(r3, u2, r3 + d2, u2, d2), t6.lineTo(a3 - d2, u2), t6.arcTo(a3, u2, a3, u2 - d2, d2), t6.lineTo(a3, o3), t6.fill(), n3.li) {
+                                const r4 = Math.round(n3.yi * i5),
+                                    a4 = o3,
+                                    l3 = Math.round((a4 + e4.C) * s3);
+                                t6.fillStyle = n3.D;
+                                const h3 = Math.max(1, Math.floor(i5)),
+                                    c3 = Math.floor(0.5 * i5);
+                                t6.fillRect(r4 - c3, a4, h3, l3 - a4);
+                            }
+                        }), t5.useMediaCoordinateSpace(({
+                            context: t6
+                        }) => {
+                            const i5 = kl(this.zt),
+                                n3 = 0 + e4.k + e4.C + e4.I + e4.T / 2;
+                            t6.font = e4.P, t6.textAlign = "left", t6.textBaseline = "middle", t6.fillStyle = i5.D;
+                            const r3 = e4.Wi.Mi(t6, "Apr0");
+                            t6.translate(l2 + s2, n3 + r3), t6.fillText(i5.Gt, 0, 0);
+                        });
+                    }
+                }(), this.Wt = {
+                    Ct: false,
+                    t: "#4c525e",
+                    D: "white",
+                    Gt: "",
+                    $i: 0,
+                    yi: NaN,
+                    li: true
+                }, this.bt = t4, this.Hi = e3, this.Vi = i3;
+            }
+            gt() {
+                this.vt = true;
+            }
+            Mt() {
+                return this.vt && (this.St(), this.vt = false), this.jt.tt(this.Wt), this.jt;
+            }
+            St() {
+                const t4 = this.Wt;
+                t4.Ct = false;
+                const e3 = this.bt.F().vertLine;
+                if (!e3.labelVisible)
+                    return;
+                const i3 = this.Hi.yt();
+                if (i3.Ni())
+                    return;
+                t4.$i = i3.$i();
+                const s2 = this.Vi();
+                if (null === s2)
+                    return;
+                t4.yi = s2.yi;
+                const n2 = i3.Ui(this.bt.xt());
+                t4.Gt = i3.qi(kl(n2)), t4.Ct = true;
+                const r2 = Dl(e3.labelBackgroundColor);
+                t4.t = r2.t, t4.D = r2.i, t4.li = i3.F().ticksVisible;
+            }
+        }(this, t3, i2), this.bn = new class W {
+            constructor(t4) {
+                this.vt = true, this.Wt = {
+                    Vt: {
+                        rt: 1,
+                        Ft: 0,
+                        D: "",
+                        Ct: false
+                    },
+                    Nt: {
+                        rt: 1,
+                        Ft: 0,
+                        D: "",
+                        Ct: false
+                    },
+                    st: 0,
+                    et: 0
+                }, this.jt = new Ql(this.Wt), this.$t = t4;
+            }
+            gt() {
+                this.vt = true;
+            }
+            Mt() {
+                return this.vt && (this.St(), this.vt = false), this.jt;
+            }
+            St() {
+                const t4 = this.$t.Ct(),
+                    e3 = kl(this.$t.Ht()),
+                    i3 = e3.Ut().F().crosshair,
+                    s2 = this.Wt;
+                s2.Nt.Ct = t4 && this.$t.qt(e3), s2.Vt.Ct = t4 && this.$t.Yt(), s2.Nt.rt = i3.horzLine.width, s2.Nt.Ft = i3.horzLine.style, s2.Nt.D = i3.horzLine.color, s2.Vt.rt = i3.vertLine.width, s2.Vt.Ft = i3.vertLine.style, s2.Vt.D = i3.vertLine.color, s2.st = this.$t.Xt(), s2.et = this.$t.Zt();
+            }
+        }(this);
+    }
+    F() {
+        return this.un;
+    }
+    gn(t3, e2) {
+        this.on = t3, this._n = e2;
+    }
+    wn() {
+        this.on = NaN, this._n = NaN;
+    }
+    Mn() {
+        return this.on;
+    }
+    Sn() {
+        return this._n;
+    }
+    xn(t3, e2, i2) {
+        this.hn || (this.hn = true), this.en = true, this.yn(t3, e2, i2);
+    }
+    xt() {
+        return this.sn;
+    }
+    Xt() {
+        return this.ln;
+    }
+    Zt() {
+        return this.an;
+    }
+    Ct() {
+        return this.en;
+    }
+    kn() {
+        this.en = false, this.Cn(), this.nn = NaN, this.ln = NaN, this.an = NaN, this.tn = null, this.wn();
+    }
+    Tn(t3) {
+        return null !== this.tn ? [this.bn, this.cn] : [];
+    }
+    qt(t3) {
+        return t3 === this.tn && this.un.horzLine.visible;
+    }
+    Yt() {
+        return this.un.vertLine.visible;
+    }
+    Pn(t3, e2) {
+        this.en && this.tn === t3 || this.rn.clear();
+        const i2 = [];
+        return this.tn === t3 && i2.push(this.Rn(this.rn, e2, this.dn)), i2;
+    }
+    Qi() {
+        return this.en ? [this.mn] : [];
+    }
+    Ht() {
+        return this.tn;
+    }
+    Dn() {
+        this.bn.gt(), this.rn.forEach((t3) => t3.gt()), this.mn.gt(), this.cn.gt();
+    }
+    Bn(t3) {
+        return t3 && !t3.fn().Ni() ? t3.fn() : null;
+    }
+    yn(t3, e2, i2) {
+        this.An(t3, e2, i2) && this.Dn();
+    }
+    An(t3, e2, i2) {
+        const s2 = this.ln,
+            n2 = this.an,
+            r2 = this.nn,
+            o2 = this.sn,
+            a2 = this.tn,
+            l2 = this.Bn(i2);
+        this.sn = t3, this.ln = isNaN(t3) ? NaN : this.Hi.yt().Et(t3), this.tn = i2;
+        const h2 = null !== l2 ? l2.Tt() : null;
+        return null !== l2 && null !== h2 ? (this.nn = e2, this.an = l2.Dt(e2, h2)) : (this.nn = NaN, this.an = NaN), s2 !== this.ln || n2 !== this.an || o2 !== this.sn || r2 !== this.nn || a2 !== this.tn;
+    }
+    Cn() {
+        const t3 = this.Hi.wt().map((t4) => t4.Ln().On()).filter(Bl),
+            e2 = 0 === t3.length ? null : Math.max(...t3);
+        this.sn = null !== e2 ? e2 : NaN;
+    }
+    Rn(t3, e2, i2) {
+        let s2 = t3.get(e2);
+        return void 0 === s2 && (s2 = new rh(this, e2, i2), t3.set(e2, s2)), s2;
+    }
+}
+
+function lh(t3) {
+    return "left" === t3 || "right" === t3;
+}
+class et {
+    constructor(t3) {
+        this.In = /* @__PURE__ */ new Map(), this.En = [], this.zn = t3;
+    }
+    Vn(t3, e2) {
+        const i2 = function(t4, e3) {
+            return void 0 === t4 ? e3 : {
+                Nn: Math.max(t4.Nn, e3.Nn),
+                Fn: t4.Fn || e3.Fn
+            };
+        }(this.In.get(t3), e2);
+        this.In.set(t3, i2);
+    }
+    Wn() {
+        return this.zn;
+    }
+    jn(t3) {
+        const e2 = this.In.get(t3);
+        return void 0 === e2 ? {
+            Nn: this.zn
+        } : {
+            Nn: Math.max(this.zn, e2.Nn),
+            Fn: e2.Fn
+        };
+    }
+    $n() {
+        this.Hn(), this.En = [{
+            Un: 0
+        }];
+    }
+    qn(t3) {
+        this.Hn(), this.En = [{
+            Un: 1,
+            At: t3
+        }];
+    }
+    Yn(t3) {
+        this.Xn(), this.En.push({
+            Un: 5,
+            At: t3
+        });
+    }
+    Hn() {
+        this.Xn(), this.En.push({
+            Un: 6
+        });
+    }
+    Zn() {
+        this.Hn(), this.En = [{
+            Un: 4
+        }];
+    }
+    Kn(t3) {
+        this.Hn(), this.En.push({
+            Un: 2,
+            At: t3
+        });
+    }
+    Gn(t3) {
+        this.Hn(), this.En.push({
+            Un: 3,
+            At: t3
+        });
+    }
+    Jn() {
+        return this.En;
+    }
+    Qn(t3) {
+        for (const e2 of t3.En)
+            this.ts(e2);
+        this.zn = Math.max(this.zn, t3.zn), t3.In.forEach((t4, e2) => {
+            this.Vn(e2, t4);
+        });
+    }
+    static ns() {
+        return new et(2);
+    }
+    static ss() {
+        return new et(3);
+    }
+    ts(t3) {
+        switch (t3.Un) {
+            case 0:
+                this.$n();
+                break;
+            case 1:
+                this.qn(t3.At);
+                break;
+            case 2:
+                this.Kn(t3.At);
+                break;
+            case 3:
+                this.Gn(t3.At);
+                break;
+            case 4:
+                this.Zn();
+                break;
+            case 5:
+                this.Yn(t3.At);
+                break;
+            case 6:
+                this.Xn();
+        }
+    }
+    Xn() {
+        const t3 = this.En.findIndex((t4) => 5 === t4.Un); -
+        1 !== t3 && this.En.splice(t3, 1);
+    }
+}
+
+function hh(t3, e2) {
+    if (!Fl(t3))
+        return "n/a";
+    if (!Nl(e2))
+        throw new TypeError("invalid length");
+    if (e2 < 0 || e2 > 16)
+        throw new TypeError("invalid length");
+    return 0 === e2 ? t3.toString() : ("0000000000000000" + t3.toString()).slice(-e2);
+}
+class lt {
+    constructor(t3, e2) {
+        if (e2 || (e2 = 1), Fl(t3) && Nl(t3) || (t3 = 100), t3 < 0)
+            throw new TypeError("invalid base");
+        this.zi = t3, this.es = e2, this.rs();
+    }
+    format(t3) {
+        const e2 = t3 < 0 ? "−" : "";
+        return t3 = Math.abs(t3), e2 + this.hs(t3);
+    }
+    rs() {
+        if (this.ls = 0, this.zi > 0 && this.es > 0) {
+            let t3 = this.zi;
+            for (; t3 > 1;)
+                t3 /= 10, this.ls++;
+        }
+    }
+    hs(t3) {
+        const e2 = this.zi / this.es;
+        let i2 = Math.floor(t3),
+            s2 = "";
+        const n2 = void 0 !== this.ls ? this.ls : NaN;
+        if (e2 > 1) {
+            let r2 = +(Math.round(t3 * e2) - i2 * e2).toFixed(this.ls);
+            r2 >= e2 && (r2 -= e2, i2 += 1), s2 = "." + hh(+r2.toFixed(this.ls) * this.es, n2);
+        } else
+            i2 = Math.round(i2 * e2) / e2, n2 > 0 && (s2 = "." + hh(0, n2));
+        return i2.toFixed(0) + s2;
+    }
+}
+class at extends lt {
+    constructor(t3 = 100) {
+        super(t3);
+    }
+    format(t3) {
+        return `${super.format(t3)}%`;
+    }
+}
+class ot {
+    constructor(t3) {
+        this.os = t3;
+    }
+    format(t3) {
+        let e2 = "";
+        return t3 < 0 && (e2 = "-", t3 = -t3), t3 < 995 ? e2 + this._s(t3) : t3 < 999995 ? e2 + this._s(t3 / 1e3) + "K" : t3 < 999999995 ? (t3 = 1e3 * Math.round(t3 / 1e3), e2 + this._s(t3 / 1e6) + "M") : (t3 = 1e6 * Math.round(t3 / 1e6), e2 + this._s(t3 / 1e9) + "B");
+    }
+    _s(t3) {
+        let e2;
+        const i2 = Math.pow(10, this.os);
+        return e2 = (t3 = Math.round(t3 * i2) / i2) >= 1e-15 && t3 < 1 ? t3.toFixed(this.os).replace(/\.?0+$/, "") : String(t3), e2.replace(/(\.[1-9]*)0+$/, (t4, e3) => e3);
+    }
+}
+
+function ch(t3, e2, i2, s2, n2, r2, o2) {
+    if (0 === e2.length || s2.from >= e2.length || s2.to <= 0)
+        return;
+    const a2 = t3.context,
+        l2 = e2[s2.from];
+    let h2 = r2(t3, l2),
+        c2 = l2;
+    if (s2.to - s2.from < 2) {
+        const t4 = n2 / 2;
+        a2.beginPath();
+        const e3 = {
+                st: l2.st - t4,
+                et: l2.et
+            },
+            i3 = {
+                st: l2.st + t4,
+                et: l2.et
+            };
+        return a2.moveTo(e3.st, e3.et), a2.lineTo(i3.st, i3.et), void o2(a2, h2, e3, i3);
+    }
+    const u2 = (t4, e3) => {
+        o2(a2, h2, c2, e3), a2.beginPath(), h2 = t4, c2 = e3;
+    };
+    let d2 = c2;
+    a2.beginPath(), a2.moveTo(l2.st, l2.et);
+    for (let n3 = s2.from + 1; n3 < s2.to; ++n3) {
+        d2 = e2[n3];
+        const s3 = r2(t3, d2);
+        switch (i2) {
+            case 0:
+                a2.lineTo(d2.st, d2.et);
+                break;
+            case 1:
+                a2.lineTo(d2.st, e2[n3 - 1].et), s3 !== h2 && (u2(s3, d2), a2.lineTo(d2.st, e2[n3 - 1].et)), a2.lineTo(d2.st, d2.et);
+                break;
+            case 2: {
+                const [t4, i3] = ph(e2, n3 - 1, n3);
+                a2.bezierCurveTo(t4.st, t4.et, i3.st, i3.et, d2.st, d2.et);
+                break;
+            }
+        }
+        1 !== i2 && s3 !== h2 && (u2(s3, d2), a2.moveTo(d2.st, d2.et));
+    }
+    (c2 !== d2 || c2 === d2 && 1 === i2) && o2(a2, h2, c2, d2);
+}
+const uh = 6;
+
+function dh(t3, e2) {
+    return {
+        st: t3.st - e2.st,
+        et: t3.et - e2.et
+    };
+}
+
+function fh(t3, e2) {
+    return {
+        st: t3.st / e2,
+        et: t3.et / e2
+    };
+}
+
+function ph(t3, e2, i2) {
+    const s2 = Math.max(0, e2 - 1),
+        n2 = Math.min(t3.length - 1, i2 + 1);
+    var r2, o2;
+    return [(r2 = t3[e2], o2 = fh(dh(t3[i2], t3[s2]), uh), {
+        st: r2.st + o2.st,
+        et: r2.et + o2.et
+    }), dh(t3[i2], fh(dh(t3[n2], t3[e2]), uh))];
+}
+
+function mh(t3, e2, i2, s2, n2) {
+    e2.lineTo(n2.st, t3), e2.lineTo(s2.st, t3), e2.closePath(), e2.fillStyle = i2, e2.fill();
+}
+class vt extends L {
+    constructor() {
+        super(...arguments), this.J = null;
+    }
+    tt(t3) {
+        this.J = t3;
+    }
+    Z(t3) {
+        var e2;
+        if (null === this.J)
+            return;
+        const {
+            nt: i2,
+            it: s2,
+            us: n2,
+            rt: r2,
+            Ft: o2,
+            cs: a2
+        } = this.J, l2 = null !== (e2 = this.J.ds) && void 0 !== e2 ? e2 : this.J.fs ? 0 : t3.mediaSize.height;
+        if (null === s2)
+            return;
+        const h2 = t3.context;
+        h2.lineCap = "butt", h2.lineJoin = "round", h2.lineWidth = r2, bl(h2, o2), h2.lineWidth = 1, ch(t3, i2, a2, s2, n2, this.ps.bind(this), mh.bind(null, l2));
+    }
+}
+class mt extends vt {
+    constructor() {
+        super(...arguments), this.vs = null;
+    }
+    ps(t3, e2) {
+        const {
+            context: i2,
+            mediaSize: s2
+        } = t3, {
+            bs: n2,
+            gs: r2
+        } = e2, o2 = s2.height;
+        if (null !== this.vs && this.vs.topColor === n2 && this.vs.bottomColor === r2 && this.vs.bottom === o2)
+            return this.vs.fillStyle;
+        const a2 = i2.createLinearGradient(0, 0, 0, o2);
+        return a2.addColorStop(0, n2), a2.addColorStop(1, r2), this.vs = {
+            topColor: n2,
+            bottomColor: r2,
+            fillStyle: a2,
+            bottom: o2
+        }, a2;
+    }
+}
+
+function gh(t3, e2) {
+    t3.strokeStyle = e2, t3.stroke();
+}
+class gt extends L {
+    constructor() {
+        super(...arguments), this.J = null;
+    }
+    tt(t3) {
+        this.J = t3;
+    }
+    Z(t3) {
+        if (null === this.J)
+            return;
+        const {
+            nt: e2,
+            it: i2,
+            us: s2,
+            cs: n2,
+            rt: r2,
+            Ft: o2
+        } = this.J;
+        if (null === i2)
+            return;
+        const a2 = t3.context;
+        a2.lineCap = "butt", a2.lineWidth = r2, bl(a2, o2), a2.lineJoin = "round", ch(t3, e2, n2, i2, s2, this.ws.bind(this), gh);
+    }
+}
+class wt extends gt {
+    ws(t3, e2) {
+        return e2.ot;
+    }
+}
+
+function yh(t3, e2, i2, s2 = 0, n2 = t3.length) {
+    let r2 = n2 - s2;
+    for (; 0 < r2;) {
+        const n3 = r2 >> 1,
+            o2 = s2 + n3;
+        i2(t3[o2], e2) ? (s2 = o2 + 1, r2 -= n3 + 1) : r2 = n3;
+    }
+    return s2;
+}
+
+function vh(t3, e2, i2, s2 = 0, n2 = t3.length) {
+    let r2 = n2 - s2;
+    for (; 0 < r2;) {
+        const n3 = r2 >> 1,
+            o2 = s2 + n3;
+        i2(e2, t3[o2]) ? r2 = n3 : (s2 = o2 + 1, r2 -= n3 + 1);
+    }
+    return s2;
+}
+
+function bh(t3, e2) {
+    return t3._t < e2;
+}
+
+function _h(t3, e2) {
+    return t3 < e2._t;
+}
+
+function wh(t3, e2, i2) {
+    const s2 = e2.Ms(),
+        n2 = e2.ci(),
+        r2 = yh(t3, s2, bh),
+        o2 = vh(t3, n2, _h);
+    if (!i2)
+        return {
+            from: r2,
+            to: o2
+        };
+    let a2 = r2,
+        l2 = o2;
+    return r2 > 0 && r2 < t3.length && t3[r2]._t >= s2 && (a2 = r2 - 1), o2 > 0 && o2 < t3.length && t3[o2 - 1]._t <= n2 && (l2 = o2 + 1), {
+        from: a2,
+        to: l2
+    };
+}
+class Ct {
+    constructor(t3, e2, i2) {
+        this.Ss = true, this.xs = true, this.ys = true, this.ks = [], this.Cs = null, this.Ts = t3, this.Ps = e2, this.Rs = i2;
+    }
+    gt(t3) {
+        this.Ss = true, "data" === t3 && (this.xs = true), "options" === t3 && (this.ys = true);
+    }
+    Mt() {
+        return this.Ts.Ct() ? (this.Ds(), null === this.Cs ? null : this.Bs) : null;
+    }
+    As() {
+        this.ks = this.ks.map((t3) => Object.assign(Object.assign({}, t3), this.Ts.Ls().Os(t3._t)));
+    }
+    Is() {
+        this.Cs = null;
+    }
+    Ds() {
+        this.xs && (this.Es(), this.xs = false), this.ys && (this.As(), this.ys = false), this.Ss && (this.zs(), this.Ss = false);
+    }
+    zs() {
+        const t3 = this.Ts.Bt(),
+            e2 = this.Ps.yt();
+        if (this.Is(), e2.Ni() || t3.Ni())
+            return;
+        const i2 = e2.Vs();
+        if (null === i2)
+            return;
+        if (0 === this.Ts.Ln().Ns())
+            return;
+        const s2 = this.Ts.Tt();
+        null !== s2 && (this.Cs = wh(this.ks, i2, this.Rs), this.Fs(t3, e2, s2.At), this.Ws());
+    }
+}
+class Tt extends Ct {
+    constructor(t3, e2) {
+        super(t3, e2, true);
+    }
+    Fs(t3, e2, i2) {
+        e2.js(this.ks, Ul(this.Cs)), t3.$s(this.ks, i2, Ul(this.Cs));
+    }
+    Hs(t3, e2) {
+        return {
+            _t: t3,
+            ut: e2,
+            st: NaN,
+            et: NaN
+        };
+    }
+    Es() {
+        const t3 = this.Ts.Ls();
+        this.ks = this.Ts.Ln().Us().map((e2) => {
+            const i2 = e2.At[3];
+            return this.qs(e2.Ys, i2, t3);
+        });
+    }
+}
+class Pt extends Tt {
+    constructor(t3, e2) {
+        super(t3, e2), this.Bs = new Wl(), this.Xs = new mt(), this.Zs = new wt(), this.Bs.Y([this.Xs, this.Zs]);
+    }
+    qs(t3, e2, i2) {
+        return Object.assign(Object.assign({}, this.Hs(t3, e2)), i2.Os(t3));
+    }
+    Ws() {
+        const t3 = this.Ts.F();
+        this.Xs.tt({
+            cs: t3.lineType,
+            nt: this.ks,
+            Ft: t3.lineStyle,
+            rt: t3.lineWidth,
+            ds: null,
+            fs: t3.invertFilledArea,
+            it: this.Cs,
+            us: this.Ps.yt().Ks()
+        }), this.Zs.tt({
+            cs: t3.lineType,
+            nt: this.ks,
+            Ft: t3.lineStyle,
+            rt: t3.lineWidth,
+            it: this.Cs,
+            us: this.Ps.yt().Ks()
+        });
+    }
+}
+class Rt extends Yl {
+    constructor() {
+        super(...arguments), this.zt = null, this.Gs = 0, this.Js = 0;
+    }
+    tt(t3) {
+        this.zt = t3;
+    }
+    Z({
+        context: t3,
+        horizontalPixelRatio: e2,
+        verticalPixelRatio: i2
+    }) {
+        if (null === this.zt || 0 === this.zt.Ln.length || null === this.zt.it)
+            return;
+        this.Gs = this.Qs(e2), this.Gs >= 2 && Math.max(1, Math.floor(e2)) % 2 != this.Gs % 2 && this.Gs--, this.Js = this.zt.te ? Math.min(this.Gs, Math.floor(e2)) : this.Gs;
+        let s2 = null;
+        const n2 = this.Js <= this.Gs && this.zt.Ks >= Math.floor(1.5 * e2);
+        for (let r2 = this.zt.it.from; r2 < this.zt.it.to; ++r2) {
+            const o2 = this.zt.Ln[r2];
+            s2 !== o2.ie && (t3.fillStyle = o2.ie, s2 = o2.ie);
+            const a2 = Math.floor(0.5 * this.Js),
+                l2 = Math.round(o2.st * e2),
+                h2 = l2 - a2,
+                c2 = this.Js,
+                u2 = h2 + c2 - 1,
+                d2 = Math.min(o2.ne, o2.se),
+                f2 = Math.max(o2.ne, o2.se),
+                p2 = Math.round(d2 * i2) - a2,
+                m2 = Math.round(f2 * i2) + a2,
+                g2 = Math.max(m2 - p2, this.Js);
+            t3.fillRect(h2, p2, c2, g2);
+            const y2 = Math.ceil(1.5 * this.Gs);
+            if (n2) {
+                if (this.zt.ee) {
+                    const e4 = l2 - y2;
+                    let s4 = Math.max(p2, Math.round(o2.re * i2) - a2),
+                        n4 = s4 + c2 - 1;
+                    n4 > p2 + g2 - 1 && (n4 = p2 + g2 - 1, s4 = n4 - c2 + 1), t3.fillRect(e4, s4, h2 - e4, n4 - s4 + 1);
+                }
+                const e3 = l2 + y2;
+                let s3 = Math.max(p2, Math.round(o2.he * i2) - a2),
+                    n3 = s3 + c2 - 1;
+                n3 > p2 + g2 - 1 && (n3 = p2 + g2 - 1, s3 = n3 - c2 + 1), t3.fillRect(u2 + 1, s3, e3 - u2, n3 - s3 + 1);
+            }
+        }
+    }
+    Qs(t3) {
+        const e2 = Math.floor(t3);
+        return Math.max(e2, Math.floor(function(t4, e3) {
+            return Math.floor(0.3 * t4 * e3);
+        }(kl(this.zt).Ks, t3)));
+    }
+}
+class Dt extends Ct {
+    constructor(t3, e2) {
+        super(t3, e2, false);
+    }
+    Fs(t3, e2, i2) {
+        e2.js(this.ks, Ul(this.Cs)), t3.le(this.ks, i2, Ul(this.Cs));
+    }
+    ae(t3, e2, i2) {
+        return {
+            _t: t3,
+            oe: e2.At[0],
+            _e: e2.At[1],
+            ue: e2.At[2],
+            ce: e2.At[3],
+            st: NaN,
+            re: NaN,
+            ne: NaN,
+            se: NaN,
+            he: NaN
+        };
+    }
+    Es() {
+        const t3 = this.Ts.Ls();
+        this.ks = this.Ts.Ln().Us().map((e2) => this.qs(e2.Ys, e2, t3));
+    }
+}
+class Bt extends Dt {
+    constructor() {
+        super(...arguments), this.Bs = new Rt();
+    }
+    qs(t3, e2, i2) {
+        return Object.assign(Object.assign({}, this.ae(t3, e2, i2)), i2.Os(t3));
+    }
+    Ws() {
+        const t3 = this.Ts.F();
+        this.Bs.tt({
+            Ln: this.ks,
+            Ks: this.Ps.yt().Ks(),
+            ee: t3.openVisible,
+            te: t3.thinBars,
+            it: this.Cs
+        });
+    }
+}
+
+function xh(t3, e2, i2) {
+    return Math.min(Math.max(t3, e2), i2);
+}
+
+function kh(t3, e2, i2) {
+    return e2 - t3 <= i2;
+}
+
+function Th(t3) {
+    return t3 <= 0 ? NaN : Math.log(t3) / Math.log(10);
+}
+
+function Sh(t3) {
+    const e2 = Math.ceil(t3);
+    return e2 % 2 == 0 ? e2 - 1 : e2;
+}
+class Et extends vt {
+    constructor() {
+        super(...arguments), this.vs = null;
+    }
+    ps(t3, e2) {
+        var i2;
+        const {
+            context: s2,
+            mediaSize: n2
+        } = t3, r2 = this.J, {
+            de: o2,
+            fe: a2,
+            pe: l2,
+            ve: h2
+        } = e2, c2 = null !== (i2 = r2.ds) && void 0 !== i2 ? i2 : n2.height, u2 = n2.height;
+        if (null !== this.vs && this.vs.topFillColor1 === o2 && this.vs.topFillColor2 === a2 && this.vs.bottomFillColor1 === l2 && this.vs.bottomFillColor2 === h2 && this.vs.baseLevelCoordinate === c2 && this.vs.bottom === u2)
+            return this.vs.fillStyle;
+        const d2 = s2.createLinearGradient(0, 0, 0, u2),
+            f2 = xh(c2 / u2, 0, 1);
+        return d2.addColorStop(0, o2), d2.addColorStop(f2, a2), d2.addColorStop(f2, l2), d2.addColorStop(1, h2), this.vs = {
+            topFillColor1: o2,
+            topFillColor2: a2,
+            bottomFillColor1: l2,
+            bottomFillColor2: h2,
+            fillStyle: d2,
+            baseLevelCoordinate: c2,
+            bottom: u2
+        }, d2;
+    }
+}
+class zt extends gt {
+    constructor() {
+        super(...arguments), this.me = null;
+    }
+    ws(t3, e2) {
+        const {
+            context: i2,
+            mediaSize: s2
+        } = t3, n2 = this.J, {
+            be: r2,
+            ge: o2
+        } = e2, {
+            ds: a2
+        } = n2, l2 = s2.height;
+        if (null !== this.me && this.me.topLineColor === r2 && this.me.bottomLineColor === o2 && this.me.baseLevelCoordinate === a2 && this.me.bottom === l2)
+            return this.me.strokeStyle;
+        const h2 = i2.createLinearGradient(0, 0, 0, l2),
+            c2 = xh(a2 / l2, 0, 1);
+        return h2.addColorStop(0, r2), h2.addColorStop(c2, r2), h2.addColorStop(c2, o2), h2.addColorStop(1, o2), this.me = {
+            topLineColor: r2,
+            bottomLineColor: o2,
+            strokeStyle: h2,
+            baseLevelCoordinate: a2,
+            bottom: l2
+        }, h2;
+    }
+}
+class Vt extends Tt {
+    constructor(t3, e2) {
+        super(t3, e2), this.Bs = new Wl(), this.we = new Et(), this.Me = new zt(), this.Bs.Y([this.we, this.Me]);
+    }
+    qs(t3, e2, i2) {
+        return Object.assign(Object.assign({}, this.Hs(t3, e2)), i2.Os(t3));
+    }
+    Ws() {
+        const t3 = this.Ts.Tt();
+        if (null === t3)
+            return;
+        const e2 = this.Ts.F(),
+            i2 = this.Ts.Bt().Dt(e2.baseValue.price, t3.At),
+            s2 = this.Ps.yt().Ks();
+        this.we.tt({
+            nt: this.ks,
+            rt: e2.lineWidth,
+            Ft: e2.lineStyle,
+            cs: e2.lineType,
+            ds: i2,
+            fs: false,
+            it: this.Cs,
+            us: s2
+        }), this.Me.tt({
+            nt: this.ks,
+            rt: e2.lineWidth,
+            Ft: e2.lineStyle,
+            cs: e2.lineType,
+            ds: i2,
+            it: this.Cs,
+            us: s2
+        });
+    }
+}
+class Nt extends Yl {
+    constructor() {
+        super(...arguments), this.zt = null, this.Gs = 0;
+    }
+    tt(t3) {
+        this.zt = t3;
+    }
+    Z(t3) {
+        if (null === this.zt || 0 === this.zt.Ln.length || null === this.zt.it)
+            return;
+        const {
+            horizontalPixelRatio: e2
+        } = t3;
+        this.Gs = function(t4, e3) {
+            if (t4 >= 2.5 && t4 <= 4)
+                return Math.floor(3 * e3);
+            const i3 = 1 - 0.2 * Math.atan(Math.max(4, t4) - 4) / (0.5 * Math.PI),
+                s3 = Math.floor(t4 * i3 * e3),
+                n2 = Math.floor(t4 * e3),
+                r2 = Math.min(s3, n2);
+            return Math.max(Math.floor(e3), r2);
+        }(this.zt.Ks, e2), this.Gs >= 2 && Math.floor(e2) % 2 != this.Gs % 2 && this.Gs--;
+        const i2 = this.zt.Ln;
+        this.zt.Se && this.xe(t3, i2, this.zt.it), this.zt.ui && this.ye(t3, i2, this.zt.it);
+        const s2 = this.ke(e2);
+        (!this.zt.ui || this.Gs > 2 * s2) && this.Ce(t3, i2, this.zt.it);
+    }
+    xe(t3, e2, i2) {
+        if (null === this.zt)
+            return;
+        const {
+            context: s2,
+            horizontalPixelRatio: n2,
+            verticalPixelRatio: r2
+        } = t3;
+        let o2 = "",
+            a2 = Math.min(Math.floor(n2), Math.floor(this.zt.Ks * n2));
+        a2 = Math.max(Math.floor(n2), Math.min(a2, this.Gs));
+        const l2 = Math.floor(0.5 * a2);
+        let h2 = null;
+        for (let t4 = i2.from; t4 < i2.to; t4++) {
+            const i3 = e2[t4];
+            i3.Te !== o2 && (s2.fillStyle = i3.Te, o2 = i3.Te);
+            const c2 = Math.round(Math.min(i3.re, i3.he) * r2),
+                u2 = Math.round(Math.max(i3.re, i3.he) * r2),
+                d2 = Math.round(i3.ne * r2),
+                f2 = Math.round(i3.se * r2);
+            let p2 = Math.round(n2 * i3.st) - l2;
+            const m2 = p2 + a2 - 1;
+            null !== h2 && (p2 = Math.max(h2 + 1, p2), p2 = Math.min(p2, m2));
+            const g2 = m2 - p2 + 1;
+            s2.fillRect(p2, d2, g2, c2 - d2), s2.fillRect(p2, u2 + 1, g2, f2 - u2), h2 = m2;
+        }
+    }
+    ke(t3) {
+        let e2 = Math.floor(1 * t3);
+        this.Gs <= 2 * e2 && (e2 = Math.floor(0.5 * (this.Gs - 1)));
+        const i2 = Math.max(Math.floor(t3), e2);
+        return this.Gs <= 2 * i2 ? Math.max(Math.floor(t3), Math.floor(1 * t3)) : i2;
+    }
+    ye(t3, e2, i2) {
+        if (null === this.zt)
+            return;
+        const {
+            context: s2,
+            horizontalPixelRatio: n2,
+            verticalPixelRatio: r2
+        } = t3;
+        let o2 = "";
+        const a2 = this.ke(n2);
+        let l2 = null;
+        for (let t4 = i2.from; t4 < i2.to; t4++) {
+            const i3 = e2[t4];
+            i3.Pe !== o2 && (s2.fillStyle = i3.Pe, o2 = i3.Pe);
+            let h2 = Math.round(i3.st * n2) - Math.floor(0.5 * this.Gs);
+            const c2 = h2 + this.Gs - 1,
+                u2 = Math.round(Math.min(i3.re, i3.he) * r2),
+                d2 = Math.round(Math.max(i3.re, i3.he) * r2);
+            if (null !== l2 && (h2 = Math.max(l2 + 1, h2), h2 = Math.min(h2, c2)), this.zt.Ks * n2 > 2 * a2)
+                Xl(s2, h2, u2, c2 - h2 + 1, d2 - u2 + 1, a2);
+            else {
+                const t5 = c2 - h2 + 1;
+                s2.fillRect(h2, u2, t5, d2 - u2 + 1);
+            }
+            l2 = c2;
+        }
+    }
+    Ce(t3, e2, i2) {
+        if (null === this.zt)
+            return;
+        const {
+            context: s2,
+            horizontalPixelRatio: n2,
+            verticalPixelRatio: r2
+        } = t3;
+        let o2 = "";
+        const a2 = this.ke(n2);
+        for (let t4 = i2.from; t4 < i2.to; t4++) {
+            const i3 = e2[t4];
+            let l2 = Math.round(Math.min(i3.re, i3.he) * r2),
+                h2 = Math.round(Math.max(i3.re, i3.he) * r2),
+                c2 = Math.round(i3.st * n2) - Math.floor(0.5 * this.Gs),
+                u2 = c2 + this.Gs - 1;
+            if (i3.ie !== o2) {
+                const t5 = i3.ie;
+                s2.fillStyle = t5, o2 = t5;
+            }
+            this.zt.ui && (c2 += a2, l2 += a2, u2 -= a2, h2 -= a2), l2 > h2 || s2.fillRect(c2, l2, u2 - c2 + 1, h2 - l2 + 1);
+        }
+    }
+}
+class Ft extends Dt {
+    constructor() {
+        super(...arguments), this.Bs = new Nt();
+    }
+    qs(t3, e2, i2) {
+        return Object.assign(Object.assign({}, this.ae(t3, e2, i2)), i2.Os(t3));
+    }
+    Ws() {
+        const t3 = this.Ts.F();
+        this.Bs.tt({
+            Ln: this.ks,
+            Ks: this.Ps.yt().Ks(),
+            Se: t3.wickVisible,
+            ui: t3.borderVisible,
+            it: this.Cs
+        });
+    }
+}
+class Wt extends Yl {
+    constructor() {
+        super(...arguments), this.zt = null, this.Re = [];
+    }
+    tt(t3) {
+        this.zt = t3, this.Re = [];
+    }
+    Z({
+        context: t3,
+        horizontalPixelRatio: e2,
+        verticalPixelRatio: i2
+    }) {
+        if (null === this.zt || 0 === this.zt.nt.length || null === this.zt.it)
+            return;
+        this.Re.length || this.De(e2);
+        const s2 = Math.max(1, Math.floor(i2)),
+            n2 = Math.round(this.zt.Be * i2) - Math.floor(s2 / 2),
+            r2 = n2 + s2;
+        for (let e3 = this.zt.it.from; e3 < this.zt.it.to; e3++) {
+            const o2 = this.zt.nt[e3],
+                a2 = this.Re[e3 - this.zt.it.from],
+                l2 = Math.round(o2.et * i2);
+            let h2, c2;
+            t3.fillStyle = o2.ie, l2 <= n2 ? (h2 = l2, c2 = r2) : (h2 = n2, c2 = l2 - Math.floor(s2 / 2) + s2), t3.fillRect(a2.Ms, h2, a2.ci - a2.Ms + 1, c2 - h2);
+        }
+    }
+    De(t3) {
+        if (null === this.zt || 0 === this.zt.nt.length || null === this.zt.it)
+            return void(this.Re = []);
+        const e2 = Math.ceil(this.zt.Ks * t3) <= 1 ? 0 : Math.max(1, Math.floor(t3)),
+            i2 = Math.round(this.zt.Ks * t3) - e2;
+        this.Re = new Array(this.zt.it.to - this.zt.it.from);
+        for (let e3 = this.zt.it.from; e3 < this.zt.it.to; e3++) {
+            const s3 = this.zt.nt[e3],
+                n2 = Math.round(s3.st * t3);
+            let r2, o2;
+            if (i2 % 2) {
+                const t4 = (i2 - 1) / 2;
+                r2 = n2 - t4, o2 = n2 + t4;
+            } else {
+                const t4 = i2 / 2;
+                r2 = n2 - t4, o2 = n2 + t4 - 1;
+            }
+            this.Re[e3 - this.zt.it.from] = {
+                Ms: r2,
+                ci: o2,
+                Ae: n2,
+                Oe: s3.st * t3,
+                _t: s3._t
+            };
+        }
+        for (let t4 = this.zt.it.from + 1; t4 < this.zt.it.to; t4++) {
+            const i3 = this.Re[t4 - this.zt.it.from],
+                s3 = this.Re[t4 - this.zt.it.from - 1];
+            i3._t === s3._t + 1 && i3.Ms - s3.ci !== e2 + 1 && (s3.Ae > s3.Oe ? s3.ci = i3.Ms - e2 - 1 : i3.Ms = s3.ci + e2 + 1);
+        }
+        let s2 = Math.ceil(this.zt.Ks * t3);
+        for (let t4 = this.zt.it.from; t4 < this.zt.it.to; t4++) {
+            const e3 = this.Re[t4 - this.zt.it.from];
+            e3.ci < e3.Ms && (e3.ci = e3.Ms);
+            const i3 = e3.ci - e3.Ms + 1;
+            s2 = Math.min(i3, s2);
+        }
+        if (e2 > 0 && s2 < 4)
+            for (let t4 = this.zt.it.from; t4 < this.zt.it.to; t4++) {
+                const e3 = this.Re[t4 - this.zt.it.from];
+                e3.ci - e3.Ms + 1 > s2 && (e3.Ae > e3.Oe ? e3.ci -= 1 : e3.Ms += 1);
+            }
+    }
+}
+class jt extends Tt {
+    constructor() {
+        super(...arguments), this.Bs = new Wt();
+    }
+    qs(t3, e2, i2) {
+        return Object.assign(Object.assign({}, this.Hs(t3, e2)), i2.Os(t3));
+    }
+    Ws() {
+        const t3 = {
+            nt: this.ks,
+            Ks: this.Ps.yt().Ks(),
+            it: this.Cs,
+            Be: this.Ts.Bt().Dt(this.Ts.F().base, kl(this.Ts.Tt()).At)
+        };
+        this.Bs.tt(t3);
+    }
+}
+class $t extends Tt {
+    constructor() {
+        super(...arguments), this.Bs = new wt();
+    }
+    qs(t3, e2, i2) {
+        return Object.assign(Object.assign({}, this.Hs(t3, e2)), i2.Os(t3));
+    }
+    Ws() {
+        const t3 = this.Ts.F(),
+            e2 = {
+                nt: this.ks,
+                Ft: t3.lineStyle,
+                cs: t3.lineType,
+                rt: t3.lineWidth,
+                it: this.Cs,
+                us: this.Ps.yt().Ks()
+            };
+        this.Bs.tt(e2);
+    }
+}
+const Eh = /[2-9]/g;
+class Ut {
+    constructor(t3 = 50) {
+        this.Le = 0, this.Ie = 1, this.Ee = 1, this.ze = {}, this.Ve = /* @__PURE__ */ new Map(), this.Ne = t3;
+    }
+    Fe() {
+        this.Le = 0, this.Ve.clear(), this.Ie = 1, this.Ee = 1, this.ze = {};
+    }
+    Si(t3, e2, i2) {
+        return this.We(t3, e2, i2).width;
+    }
+    Mi(t3, e2, i2) {
+        const s2 = this.We(t3, e2, i2);
+        return ((s2.actualBoundingBoxAscent || 0) - (s2.actualBoundingBoxDescent || 0)) / 2;
+    }
+    We(t3, e2, i2) {
+        const s2 = i2 || Eh,
+            n2 = String(e2).replace(s2, "0");
+        if (this.Ve.has(n2))
+            return xl(this.Ve.get(n2)).je;
+        if (this.Le === this.Ne) {
+            const t4 = this.ze[this.Ee];
+            delete this.ze[this.Ee], this.Ve.delete(t4), this.Ee++, this.Le--;
+        }
+        t3.save(), t3.textBaseline = "middle";
+        const r2 = t3.measureText(n2);
+        return t3.restore(), 0 === r2.width && e2.length || (this.Ve.set(n2, {
+            je: r2,
+            $e: this.Ie
+        }), this.ze[this.Ie] = n2, this.Le++, this.Ie++), r2;
+    }
+}
+class qt {
+    constructor(t3) {
+        this.He = null, this.S = null, this.Ue = "right", this.qe = t3;
+    }
+    Ye(t3, e2, i2) {
+        this.He = t3, this.S = e2, this.Ue = i2;
+    }
+    X(t3) {
+        null !== this.S && null !== this.He && this.He.X(t3, this.S, this.qe, this.Ue);
+    }
+}
+class Yt {
+    constructor(t3, e2, i2) {
+        this.Xe = t3, this.qe = new Ut(50), this.Ze = e2, this.N = i2, this.W = -1, this.jt = new qt(this.qe);
+    }
+    Mt() {
+        const t3 = this.N.Ke(this.Ze);
+        if (null === t3)
+            return null;
+        const e2 = t3.Ge(this.Ze) ? t3.Je() : this.Ze.Bt();
+        if (null === e2)
+            return null;
+        const i2 = t3.Qe(e2);
+        if ("overlay" === i2)
+            return null;
+        const s2 = this.N.tr();
+        return s2.T !== this.W && (this.W = s2.T, this.qe.Fe()), this.jt.Ye(this.Xe.Ii(), s2, i2), this.jt;
+    }
+}
+class Xt extends Yl {
+    constructor() {
+        super(...arguments), this.zt = null;
+    }
+    tt(t3) {
+        this.zt = t3;
+    }
+    ir(t3, e2) {
+        var i2;
+        if (!(null === (i2 = this.zt) || void 0 === i2 ? void 0 : i2.Ct))
+            return null;
+        const {
+            et: s2,
+            rt: n2,
+            nr: r2
+        } = this.zt;
+        return e2 >= s2 - n2 - 7 && e2 <= s2 + n2 + 7 ? {
+            sr: this.zt,
+            nr: r2
+        } : null;
+    }
+    Z({
+        context: t3,
+        bitmapSize: e2,
+        horizontalPixelRatio: i2,
+        verticalPixelRatio: s2
+    }) {
+        if (null === this.zt)
+            return;
+        if (false === this.zt.Ct)
+            return;
+        const n2 = Math.round(this.zt.et * s2);
+        n2 < 0 || n2 > e2.height || (t3.lineCap = "butt", t3.strokeStyle = this.zt.D, t3.lineWidth = Math.floor(this.zt.rt * i2), bl(t3, this.zt.Ft), _l(t3, n2, 0, e2.width));
+    }
+}
+class Zt {
+    constructor(t3) {
+        this.er = {
+            et: 0,
+            D: "rgba(0, 0, 0, 0)",
+            rt: 1,
+            Ft: 0,
+            Ct: false
+        }, this.rr = new Xt(), this.vt = true, this.Ts = t3, this.Ps = t3.Ut(), this.rr.tt(this.er);
+    }
+    gt() {
+        this.vt = true;
+    }
+    Mt() {
+        return this.Ts.Ct() ? (this.vt && (this.hr(), this.vt = false), this.rr) : null;
+    }
+}
+class Kt extends Zt {
+    constructor(t3) {
+        super(t3);
+    }
+    hr() {
+        this.er.Ct = false;
+        const t3 = this.Ts.Bt(),
+            e2 = t3.lr().lr;
+        if (2 !== e2 && 3 !== e2)
+            return;
+        const i2 = this.Ts.F();
+        if (!i2.baseLineVisible || !this.Ts.Ct())
+            return;
+        const s2 = this.Ts.Tt();
+        null !== s2 && (this.er.Ct = true, this.er.et = t3.Dt(s2.At, s2.At), this.er.D = i2.baseLineColor, this.er.rt = i2.baseLineWidth, this.er.Ft = i2.baseLineStyle);
+    }
+}
+class Gt extends Yl {
+    constructor() {
+        super(...arguments), this.zt = null;
+    }
+    tt(t3) {
+        this.zt = t3;
+    }
+    ar() {
+        return this.zt;
+    }
+    Z({
+        context: t3,
+        horizontalPixelRatio: e2,
+        verticalPixelRatio: i2
+    }) {
+        const s2 = this.zt;
+        if (null === s2)
+            return;
+        const n2 = Math.max(1, Math.floor(e2)),
+            r2 = n2 % 2 / 2,
+            o2 = Math.round(s2.Oe.x * e2) + r2,
+            a2 = s2.Oe.y * i2;
+        t3.fillStyle = s2._r, t3.beginPath();
+        const l2 = Math.max(2, 1.5 * s2.ur) * e2;
+        t3.arc(o2, a2, l2, 0, 2 * Math.PI, false), t3.fill(), t3.fillStyle = s2.cr, t3.beginPath(), t3.arc(o2, a2, s2.lt * e2, 0, 2 * Math.PI, false), t3.fill(), t3.lineWidth = n2, t3.strokeStyle = s2.dr, t3.beginPath(), t3.arc(o2, a2, s2.lt * e2 + n2 / 2, 0, 2 * Math.PI, false), t3.stroke();
+    }
+}
+const Ch = [{
+    pr: 0,
+    vr: 0.25,
+    mr: 4,
+    br: 10,
+    gr: 0.25,
+    wr: 0,
+    Mr: 0.4,
+    Sr: 0.8
+}, {
+    pr: 0.25,
+    vr: 0.525,
+    mr: 10,
+    br: 14,
+    gr: 0,
+    wr: 0,
+    Mr: 0.8,
+    Sr: 0
+}, {
+    pr: 0.525,
+    vr: 1,
+    mr: 14,
+    br: 14,
+    gr: 0,
+    wr: 0,
+    Mr: 0,
+    Sr: 0
+}];
+
+function Ih(t3, e2, i2, s2) {
+    return function(t4, e3) {
+        if ("transparent" === t4)
+            return t4;
+        const i3 = Al(t4),
+            s3 = i3[3];
+        return `rgba(${i3[0]}, ${i3[1]}, ${i3[2]}, ${e3 * s3})`;
+    }(t3, i2 + (s2 - i2) * e2);
+}
+
+function Mh(t3, e2) {
+    const i2 = t3 % 2600 / 2600;
+    let s2;
+    for (const t4 of Ch)
+        if (i2 >= t4.pr && i2 <= t4.vr) {
+            s2 = t4;
+            break;
+        }
+    wl(void 0 !== s2, "Last price animation internal logic error");
+    const n2 = (i2 - s2.pr) / (s2.vr - s2.pr);
+    return {
+        cr: Ih(e2, n2, s2.gr, s2.wr),
+        dr: Ih(e2, n2, s2.Mr, s2.Sr),
+        lt: (r2 = n2, o2 = s2.mr, a2 = s2.br, o2 + (a2 - o2) * r2)
+    };
+    var r2, o2, a2;
+}
+class ii {
+    constructor(t3) {
+        this.jt = new Gt(), this.vt = true, this.yr = true, this.kr = performance.now(), this.Cr = this.kr - 1, this.Tr = t3;
+    }
+    Pr() {
+        this.Cr = this.kr - 1, this.gt();
+    }
+    Rr() {
+        if (this.gt(), 2 === this.Tr.F().lastPriceAnimation) {
+            const t3 = performance.now(),
+                e2 = this.Cr - t3;
+            if (e2 > 0)
+                return void(e2 < 650 && (this.Cr += 2600));
+            this.kr = t3, this.Cr = t3 + 2600;
+        }
+    }
+    gt() {
+        this.vt = true;
+    }
+    Dr() {
+        this.yr = true;
+    }
+    Ct() {
+        return 0 !== this.Tr.F().lastPriceAnimation;
+    }
+    Br() {
+        switch (this.Tr.F().lastPriceAnimation) {
+            case 0:
+                return false;
+            case 1:
+                return true;
+            case 2:
+                return performance.now() <= this.Cr;
+        }
+    }
+    Mt() {
+        return this.vt ? (this.St(), this.vt = false, this.yr = false) : this.yr && (this.Ar(), this.yr = false), this.jt;
+    }
+    St() {
+        this.jt.tt(null);
+        const t3 = this.Tr.Ut().yt(),
+            e2 = t3.Vs(),
+            i2 = this.Tr.Tt();
+        if (null === e2 || null === i2)
+            return;
+        const s2 = this.Tr.Or(true);
+        if (s2.Lr || !e2.Ir(s2.Ys))
+            return;
+        const n2 = {
+                x: t3.Et(s2.Ys),
+                y: this.Tr.Bt().Dt(s2.ut, i2.At)
+            },
+            r2 = s2.D,
+            o2 = this.Tr.F().lineWidth,
+            a2 = Mh(this.Er(), r2);
+        this.jt.tt({
+            _r: r2,
+            ur: o2,
+            cr: a2.cr,
+            dr: a2.dr,
+            lt: a2.lt,
+            Oe: n2
+        });
+    }
+    Ar() {
+        const t3 = this.jt.ar();
+        if (null !== t3) {
+            const e2 = Mh(this.Er(), t3._r);
+            t3.cr = e2.cr, t3.dr = e2.dr, t3.lt = e2.lt;
+        }
+    }
+    Er() {
+        return this.Br() ? performance.now() - this.kr : 2599;
+    }
+}
+
+function Ph(t3, e2) {
+    return Sh(Math.min(Math.max(t3, 12), 30) * e2);
+}
+
+function Rh(t3, e2) {
+    switch (t3) {
+        case "arrowDown":
+        case "arrowUp":
+            return Ph(e2, 1);
+        case "circle":
+            return Ph(e2, 0.8);
+        case "square":
+            return Ph(e2, 0.7);
+    }
+}
+
+function Ah(t3) {
+    return function(t4) {
+        const e2 = Math.ceil(t4);
+        return e2 % 2 != 0 ? e2 - 1 : e2;
+    }(Ph(t3, 1));
+}
+
+function Dh(t3) {
+    return Math.max(Ph(t3, 0.1), 3);
+}
+
+function Lh(t3, e2, i2, s2, n2) {
+    const r2 = Rh("square", i2),
+        o2 = (r2 - 1) / 2,
+        a2 = t3 - o2,
+        l2 = e2 - o2;
+    return s2 >= a2 && s2 <= a2 + r2 && n2 >= l2 && n2 <= l2 + r2;
+}
+
+function Oh(t3, e2, i2, s2, n2) {
+    const r2 = (Rh("arrowUp", n2) - 1) / 2,
+        o2 = (Sh(n2 / 2) - 1) / 2;
+    e2.beginPath(), t3 ? (e2.moveTo(i2 - r2, s2), e2.lineTo(i2, s2 - r2), e2.lineTo(i2 + r2, s2), e2.lineTo(i2 + o2, s2), e2.lineTo(i2 + o2, s2 + r2), e2.lineTo(i2 - o2, s2 + r2), e2.lineTo(i2 - o2, s2)) : (e2.moveTo(i2 - r2, s2), e2.lineTo(i2, s2 + r2), e2.lineTo(i2 + r2, s2), e2.lineTo(i2 + o2, s2), e2.lineTo(i2 + o2, s2 - r2), e2.lineTo(i2 - o2, s2 - r2), e2.lineTo(i2 - o2, s2)), e2.fill();
+}
+class oi extends L {
+    constructor() {
+        super(...arguments), this.zt = null, this.qe = new Ut(), this.W = -1, this.j = "", this.zr = "";
+    }
+    tt(t3) {
+        this.zt = t3;
+    }
+    Ye(t3, e2) {
+        this.W === t3 && this.j === e2 || (this.W = t3, this.j = e2, this.zr = Hl(t3, e2), this.qe.Fe());
+    }
+    ir(t3, e2) {
+        if (null === this.zt || null === this.zt.it)
+            return null;
+        for (let i2 = this.zt.it.from; i2 < this.zt.it.to; i2++) {
+            const s2 = this.zt.nt[i2];
+            if (Nh(s2, t3, e2))
+                return {
+                    sr: s2.Vr,
+                    nr: s2.nr
+                };
+        }
+        return null;
+    }
+    Z({
+        context: t3
+    }, e2, i2) {
+        if (null !== this.zt && null !== this.zt.it) {
+            t3.textBaseline = "middle", t3.font = this.zr;
+            for (let e3 = this.zt.it.from; e3 < this.zt.it.to; e3++) {
+                const i3 = this.zt.nt[e3];
+                void 0 !== i3.Gt && (i3.Gt.$i = this.qe.Si(t3, i3.Gt.Nr), i3.Gt.It = this.W, i3.Gt.st = i3.st - i3.Gt.$i / 2), Fh(i3, t3);
+            }
+        }
+    }
+}
+
+function Fh(t3, e2) {
+    e2.fillStyle = t3.D, void 0 !== t3.Gt && function(t4, e3, i2, s2) {
+            t4.fillText(e3, i2, s2);
+        }(e2, t3.Gt.Nr, t3.Gt.st, t3.Gt.et),
+        function(t4, e3) {
+            if (0 !== t4.Ns) {
+                switch (t4.Fr) {
+                    case "arrowDown":
+                        return void Oh(false, e3, t4.st, t4.et, t4.Ns);
+                    case "arrowUp":
+                        return void Oh(true, e3, t4.st, t4.et, t4.Ns);
+                    case "circle":
+                        return void
+                        function(t5, e4, i2, s2) {
+                            const n2 = (Rh("circle", s2) - 1) / 2;
+                            t5.beginPath(), t5.arc(e4, i2, n2, 0, 2 * Math.PI, false), t5.fill();
+                        }(e3, t4.st, t4.et, t4.Ns);
+                    case "square":
+                        return void
+                        function(t5, e4, i2, s2) {
+                            const n2 = Rh("square", s2),
+                                r2 = (n2 - 1) / 2,
+                                o2 = e4 - r2,
+                                a2 = i2 - r2;
+                            t5.fillRect(o2, a2, n2, n2);
+                        }(e3, t4.st, t4.et, t4.Ns);
+                }
+                t4.Fr;
+            }
+        }(t3, e2);
+}
+
+function Nh(t3, e2, i2) {
+    return !(void 0 === t3.Gt || ! function(t4, e3, i3, s2, n2, r2) {
+        const o2 = s2 / 2;
+        return n2 >= t4 && n2 <= t4 + i3 && r2 >= e3 - o2 && r2 <= e3 + o2;
+    }(t3.Gt.st, t3.Gt.et, t3.Gt.$i, t3.Gt.It, e2, i2)) || function(t4, e3, i3) {
+        if (0 === t4.Ns)
+            return false;
+        switch (t4.Fr) {
+            case "arrowDown":
+            case "arrowUp":
+                return function(t5, e4, i4, s2, n2, r2) {
+                    return Lh(e4, i4, s2, n2, r2);
+                }(0, t4.st, t4.et, t4.Ns, e3, i3);
+            case "circle":
+                return function(t5, e4, i4, s2, n2) {
+                    const r2 = 2 + Rh("circle", i4) / 2,
+                        o2 = t5 - s2,
+                        a2 = e4 - n2;
+                    return Math.sqrt(o2 * o2 + a2 * a2) <= r2;
+                }(t4.st, t4.et, t4.Ns, e3, i3);
+            case "square":
+                return Lh(t4.st, t4.et, t4.Ns, e3, i3);
+        }
+    }(t3, e2, i2);
+}
+
+function $h(t3, e2, i2, s2, n2, r2, o2, a2, l2) {
+    const h2 = Fl(i2) ? i2 : i2.ce,
+        c2 = Fl(i2) ? i2 : i2._e,
+        u2 = Fl(i2) ? i2 : i2.ue,
+        d2 = Fl(e2.size) ? Math.max(e2.size, 0) : 1,
+        f2 = Ah(a2.Ks()) * d2,
+        p2 = f2 / 2;
+    switch (t3.Ns = f2, e2.position) {
+        case "inBar":
+            return t3.et = o2.Dt(h2, l2), void(void 0 !== t3.Gt && (t3.Gt.et = t3.et + p2 + r2 + 0.6 * n2));
+        case "aboveBar":
+            return t3.et = o2.Dt(c2, l2) - p2 - s2.Wr, void 0 !== t3.Gt && (t3.Gt.et = t3.et - p2 - 0.6 * n2, s2.Wr += 1.2 * n2), void(s2.Wr += f2 + r2);
+        case "belowBar":
+            return t3.et = o2.Dt(u2, l2) + p2 + s2.jr, void 0 !== t3.Gt && (t3.Gt.et = t3.et + p2 + r2 + 0.6 * n2, s2.jr += 1.2 * n2), void(s2.jr += f2 + r2);
+    }
+    e2.position;
+}
+class di {
+    constructor(t3, e2) {
+        this.vt = true, this.$r = true, this.Hr = true, this.Ur = null, this.jt = new oi(), this.Tr = t3, this.Hi = e2, this.zt = {
+            nt: [],
+            it: null
+        };
+    }
+    gt(t3) {
+        this.vt = true, this.Hr = true, "data" === t3 && (this.$r = true);
+    }
+    Mt(t3) {
+        if (!this.Tr.Ct())
+            return null;
+        this.vt && this.qr();
+        const e2 = this.Hi.F().layout;
+        return this.jt.Ye(e2.fontSize, e2.fontFamily), this.jt.tt(this.zt), this.jt;
+    }
+    Yr() {
+        if (this.Hr) {
+            if (this.Tr.Xr().length > 0) {
+                const t3 = this.Hi.yt().Ks(),
+                    e2 = Dh(t3),
+                    i2 = 1.5 * Ah(t3) + 2 * e2;
+                this.Ur = {
+                    above: i2,
+                    below: i2
+                };
+            } else
+                this.Ur = null;
+            this.Hr = false;
+        }
+        return this.Ur;
+    }
+    qr() {
+        const t3 = this.Tr.Bt(),
+            e2 = this.Hi.yt(),
+            i2 = this.Tr.Xr();
+        this.$r && (this.zt.nt = i2.map((t4) => ({
+            _t: t4.time,
+            st: 0,
+            et: 0,
+            Ns: 0,
+            Fr: t4.shape,
+            D: t4.color,
+            Vr: t4.internalId,
+            nr: t4.id,
+            Gt: void 0
+        })), this.$r = false);
+        const s2 = this.Hi.F().layout;
+        this.zt.it = null;
+        const n2 = e2.Vs();
+        if (null === n2)
+            return;
+        const r2 = this.Tr.Tt();
+        if (null === r2)
+            return;
+        if (0 === this.zt.nt.length)
+            return;
+        let o2 = NaN;
+        const a2 = Dh(e2.Ks()),
+            l2 = {
+                Wr: a2,
+                jr: a2
+            };
+        this.zt.it = wh(this.zt.nt, n2, true);
+        for (let n3 = this.zt.it.from; n3 < this.zt.it.to; n3++) {
+            const h2 = i2[n3];
+            h2.time !== o2 && (l2.Wr = a2, l2.jr = a2, o2 = h2.time);
+            const c2 = this.zt.nt[n3];
+            c2.st = e2.Et(h2.time), void 0 !== h2.text && h2.text.length > 0 && (c2.Gt = {
+                Nr: h2.text,
+                st: 0,
+                et: 0,
+                $i: 0,
+                It: 0
+            });
+            const u2 = this.Tr.Zr(h2.time);
+            null !== u2 && $h(c2, h2, u2, l2, s2.fontSize, a2, t3, e2, r2.At);
+        }
+        this.vt = false;
+    }
+}
+class fi extends Zt {
+    constructor(t3) {
+        super(t3);
+    }
+    hr() {
+        const t3 = this.er;
+        t3.Ct = false;
+        const e2 = this.Ts.F();
+        if (!e2.priceLineVisible || !this.Ts.Ct())
+            return;
+        const i2 = this.Ts.Or(0 === e2.priceLineSource);
+        i2.Lr || (t3.Ct = true, t3.et = i2.yi, t3.D = this.Ts.Kr(i2.D), t3.rt = e2.priceLineWidth, t3.Ft = e2.priceLineStyle);
+    }
+}
+class pi extends nh {
+    constructor(t3) {
+        super(), this.$t = t3;
+    }
+    Ei(t3, e2, i2) {
+        t3.Ct = false, e2.Ct = false;
+        const s2 = this.$t;
+        if (!s2.Ct())
+            return;
+        const n2 = s2.F(),
+            r2 = n2.lastValueVisible,
+            o2 = "" !== s2.Gr(),
+            a2 = 0 === n2.seriesLastValueMode,
+            l2 = s2.Or(false);
+        if (l2.Lr)
+            return;
+        r2 && (t3.Gt = this.Jr(l2, r2, a2), t3.Ct = 0 !== t3.Gt.length), (o2 || a2) && (e2.Gt = this.Qr(l2, r2, o2, a2), e2.Ct = e2.Gt.length > 0);
+        const h2 = s2.Kr(l2.D),
+            c2 = Dl(h2);
+        i2.t = c2.t, i2.yi = l2.yi, e2.Ot = s2.Ut().Lt(l2.yi / s2.Bt().It()), t3.Ot = h2, t3.D = c2.i, e2.D = c2.i;
+    }
+    Qr(t3, e2, i2, s2) {
+        let n2 = "";
+        const r2 = this.$t.Gr();
+        return i2 && 0 !== r2.length && (n2 += `${r2} `), e2 && s2 && (n2 += this.$t.Bt().th() ? t3.ih : t3.nh), n2.trim();
+    }
+    Jr(t3, e2, i2) {
+        return e2 ? i2 ? this.$t.Bt().th() ? t3.nh : t3.ih : t3.Gt : "";
+    }
+}
+class vi {
+    constructor(t3, e2) {
+        this.sh = t3, this.eh = e2;
+    }
+    rh(t3) {
+        return null !== t3 && this.sh === t3.sh && this.eh === t3.eh;
+    }
+    hh() {
+        return new vi(this.sh, this.eh);
+    }
+    lh() {
+        return this.sh;
+    }
+    ah() {
+        return this.eh;
+    }
+    oh() {
+        return this.eh - this.sh;
+    }
+    Ni() {
+        return this.eh === this.sh || Number.isNaN(this.eh) || Number.isNaN(this.sh);
+    }
+    Qn(t3) {
+        return null === t3 ? this : new vi(Math.min(this.lh(), t3.lh()), Math.max(this.ah(), t3.ah()));
+    }
+    _h(t3) {
+        if (!Fl(t3))
+            return;
+        if (0 == this.eh - this.sh)
+            return;
+        const e2 = 0.5 * (this.eh + this.sh);
+        let i2 = this.eh - e2,
+            s2 = this.sh - e2;
+        i2 *= t3, s2 *= t3, this.eh = e2 + i2, this.sh = e2 + s2;
+    }
+    uh(t3) {
+        Fl(t3) && (this.eh += t3, this.sh += t3);
+    }
+    dh() {
+        return {
+            minValue: this.sh,
+            maxValue: this.eh
+        };
+    }
+    static fh(t3) {
+        return null === t3 ? null : new vi(t3.minValue, t3.maxValue);
+    }
+}
+class mi {
+    constructor(t3, e2) {
+        this.ph = t3, this.mh = e2 || null;
+    }
+    bh() {
+        return this.ph;
+    }
+    gh() {
+        return this.mh;
+    }
+    dh() {
+        return null === this.ph ? null : {
+            priceRange: this.ph.dh(),
+            margins: this.mh || void 0
+        };
+    }
+    static fh(t3) {
+        return null === t3 ? null : new mi(vi.fh(t3.priceRange), t3.margins);
+    }
+}
+class bi extends Zt {
+    constructor(t3, e2) {
+        super(t3), this.wh = e2;
+    }
+    hr() {
+        const t3 = this.er;
+        t3.Ct = false;
+        const e2 = this.wh.F();
+        if (!this.Ts.Ct() || !e2.lineVisible)
+            return;
+        const i2 = this.wh.Mh();
+        null !== i2 && (t3.Ct = true, t3.et = i2, t3.D = e2.color, t3.rt = e2.lineWidth, t3.Ft = e2.lineStyle, t3.nr = this.wh.F().id);
+    }
+}
+class gi extends nh {
+    constructor(t3, e2) {
+        super(), this.Tr = t3, this.wh = e2;
+    }
+    Ei(t3, e2, i2) {
+        t3.Ct = false, e2.Ct = false;
+        const s2 = this.wh.F(),
+            n2 = s2.axisLabelVisible,
+            r2 = "" !== s2.title,
+            o2 = this.Tr;
+        if (!n2 || !o2.Ct())
+            return;
+        const a2 = this.wh.Mh();
+        if (null === a2)
+            return;
+        r2 && (e2.Gt = s2.title, e2.Ct = true), e2.Ot = o2.Ut().Lt(a2 / o2.Bt().It()), t3.Gt = this.Sh(s2.price), t3.Ct = true;
+        const l2 = Dl(s2.axisLabelColor || s2.color);
+        i2.t = l2.t;
+        const h2 = s2.axisLabelTextColor || l2.i;
+        t3.D = h2, e2.D = h2, i2.yi = a2;
+    }
+    Sh(t3) {
+        const e2 = this.Tr.Tt();
+        return null === e2 ? "" : this.Tr.Bt().Fi(t3, e2.At);
+    }
+}
+class wi {
+    constructor(t3, e2) {
+        this.Tr = t3, this.un = e2, this.xh = new bi(t3, this), this.Xe = new gi(t3, this), this.yh = new Yt(this.Xe, t3, t3.Ut());
+    }
+    kh(t3) {
+        Ol(this.un, t3), this.gt(), this.Tr.Ut().Ch();
+    }
+    F() {
+        return this.un;
+    }
+    Th() {
+        return this.xh;
+    }
+    Ph() {
+        return this.yh;
+    }
+    Rh() {
+        return this.Xe;
+    }
+    gt() {
+        this.xh.gt(), this.Xe.gt();
+    }
+    Mh() {
+        const t3 = this.Tr,
+            e2 = t3.Bt();
+        if (t3.Ut().yt().Ni() || e2.Ni())
+            return null;
+        const i2 = t3.Tt();
+        return null === i2 ? null : e2.Dt(this.un.price, i2.At);
+    }
+}
+class Mi extends tt {
+    constructor(t3) {
+        super(), this.Hi = t3;
+    }
+    Ut() {
+        return this.Hi;
+    }
+}
+const Vh = {
+    Bar: (t3, e2, i2, s2) => {
+        var n2;
+        const r2 = e2.upColor,
+            o2 = e2.downColor,
+            a2 = kl(t3(i2, s2)),
+            l2 = Tl(a2.At[0]) <= Tl(a2.At[3]);
+        return {
+            ie: null !== (n2 = a2.D) && void 0 !== n2 ? n2 : l2 ? r2 : o2
+        };
+    },
+    Candlestick: (t3, e2, i2, s2) => {
+        var n2, r2, o2;
+        const a2 = e2.upColor,
+            l2 = e2.downColor,
+            h2 = e2.borderUpColor,
+            c2 = e2.borderDownColor,
+            u2 = e2.wickUpColor,
+            d2 = e2.wickDownColor,
+            f2 = kl(t3(i2, s2)),
+            p2 = Tl(f2.At[0]) <= Tl(f2.At[3]);
+        return {
+            ie: null !== (n2 = f2.D) && void 0 !== n2 ? n2 : p2 ? a2 : l2,
+            Pe: null !== (r2 = f2.Ot) && void 0 !== r2 ? r2 : p2 ? h2 : c2,
+            Te: null !== (o2 = f2.Dh) && void 0 !== o2 ? o2 : p2 ? u2 : d2
+        };
+    },
+    Area: (t3, e2, i2, s2) => {
+        var n2, r2, o2, a2;
+        const l2 = kl(t3(i2, s2));
+        return {
+            ie: null !== (n2 = l2.ot) && void 0 !== n2 ? n2 : e2.lineColor,
+            ot: null !== (r2 = l2.ot) && void 0 !== r2 ? r2 : e2.lineColor,
+            bs: null !== (o2 = l2.bs) && void 0 !== o2 ? o2 : e2.topColor,
+            gs: null !== (a2 = l2.gs) && void 0 !== a2 ? a2 : e2.bottomColor
+        };
+    },
+    Baseline: (t3, e2, i2, s2) => {
+        var n2, r2, o2, a2, l2, h2;
+        const c2 = kl(t3(i2, s2));
+        return {
+            ie: c2.At[3] >= e2.baseValue.price ? e2.topLineColor : e2.bottomLineColor,
+            be: null !== (n2 = c2.be) && void 0 !== n2 ? n2 : e2.topLineColor,
+            ge: null !== (r2 = c2.ge) && void 0 !== r2 ? r2 : e2.bottomLineColor,
+            de: null !== (o2 = c2.de) && void 0 !== o2 ? o2 : e2.topFillColor1,
+            fe: null !== (a2 = c2.fe) && void 0 !== a2 ? a2 : e2.topFillColor2,
+            pe: null !== (l2 = c2.pe) && void 0 !== l2 ? l2 : e2.bottomFillColor1,
+            ve: null !== (h2 = c2.ve) && void 0 !== h2 ? h2 : e2.bottomFillColor2
+        };
+    },
+    Line: (t3, e2, i2, s2) => {
+        var n2, r2;
+        const o2 = kl(t3(i2, s2));
+        return {
+            ie: null !== (n2 = o2.D) && void 0 !== n2 ? n2 : e2.color,
+            ot: null !== (r2 = o2.D) && void 0 !== r2 ? r2 : e2.color
+        };
+    },
+    Histogram: (t3, e2, i2, s2) => {
+        var n2;
+        return {
+            ie: null !== (n2 = kl(t3(i2, s2)).D) && void 0 !== n2 ? n2 : e2.color
+        };
+    }
+};
+class xi {
+    constructor(t3) {
+        this.Bh = (t4, e2) => void 0 !== e2 ? e2.At : this.Tr.Ln().Ah(t4), this.Tr = t3, this.Oh = Vh[t3.Lh()];
+    }
+    Os(t3, e2) {
+        return this.Oh(this.Bh, this.Tr.F(), t3, e2);
+    }
+}
+var zh;
+! function(t3) {
+    t3[t3.NearestLeft = -1] = "NearestLeft", t3[t3.None = 0] = "None", t3[t3.NearestRight = 1] = "NearestRight";
+}(zh || (zh = {}));
+const Bh = 30;
+class Ci {
+    constructor() {
+        this.Ih = [], this.Eh = /* @__PURE__ */ new Map(), this.zh = /* @__PURE__ */ new Map();
+    }
+    Vh() {
+        return this.Ns() > 0 ? this.Ih[this.Ih.length - 1] : null;
+    }
+    Nh() {
+        return this.Ns() > 0 ? this.Fh(0) : null;
+    }
+    On() {
+        return this.Ns() > 0 ? this.Fh(this.Ih.length - 1) : null;
+    }
+    Ns() {
+        return this.Ih.length;
+    }
+    Ni() {
+        return 0 === this.Ns();
+    }
+    Ir(t3) {
+        return null !== this.Wh(t3, 0);
+    }
+    Ah(t3) {
+        return this.jh(t3);
+    }
+    jh(t3, e2 = 0) {
+        const i2 = this.Wh(t3, e2);
+        return null === i2 ? null : Object.assign(Object.assign({}, this.$h(i2)), {
+            Ys: this.Fh(i2)
+        });
+    }
+    Us() {
+        return this.Ih;
+    }
+    Hh(t3, e2, i2) {
+        if (this.Ni())
+            return null;
+        let s2 = null;
+        for (const n2 of i2)
+            s2 = Uh(s2, this.Uh(t3, e2, n2));
+        return s2;
+    }
+    tt(t3) {
+        this.zh.clear(), this.Eh.clear(), this.Ih = t3;
+    }
+    Fh(t3) {
+        return this.Ih[t3].Ys;
+    }
+    $h(t3) {
+        return this.Ih[t3];
+    }
+    Wh(t3, e2) {
+        const i2 = this.qh(t3);
+        if (null === i2 && 0 !== e2)
+            switch (e2) {
+                case -1:
+                    return this.Yh(t3);
+                case 1:
+                    return this.Xh(t3);
+                default:
+                    throw new TypeError("Unknown search mode");
+            }
+        return i2;
+    }
+    Yh(t3) {
+        let e2 = this.Zh(t3);
+        return e2 > 0 && (e2 -= 1), e2 !== this.Ih.length && this.Fh(e2) < t3 ? e2 : null;
+    }
+    Xh(t3) {
+        const e2 = this.Kh(t3);
+        return e2 !== this.Ih.length && t3 < this.Fh(e2) ? e2 : null;
+    }
+    qh(t3) {
+        const e2 = this.Zh(t3);
+        return e2 === this.Ih.length || t3 < this.Ih[e2].Ys ? null : e2;
+    }
+    Zh(t3) {
+        return yh(this.Ih, t3, (t4, e2) => t4.Ys < e2);
+    }
+    Kh(t3) {
+        return vh(this.Ih, t3, (t4, e2) => e2.Ys > t4);
+    }
+    Gh(t3, e2, i2) {
+        let s2 = null;
+        for (let n2 = t3; n2 < e2; n2++) {
+            const t4 = this.Ih[n2].At[i2];
+            Number.isNaN(t4) || (null === s2 ? s2 = {
+                Jh: t4,
+                Qh: t4
+            } : (t4 < s2.Jh && (s2.Jh = t4), t4 > s2.Qh && (s2.Qh = t4)));
+        }
+        return s2;
+    }
+    Uh(t3, e2, i2) {
+        if (this.Ni())
+            return null;
+        let s2 = null;
+        const n2 = kl(this.Nh()),
+            r2 = kl(this.On()),
+            o2 = Math.max(t3, n2),
+            a2 = Math.min(e2, r2),
+            l2 = Math.ceil(o2 / Bh) * Bh,
+            h2 = Math.max(l2, Math.floor(a2 / Bh) * Bh);
+        {
+            const t4 = this.Zh(o2),
+                n3 = this.Kh(Math.min(a2, l2, e2));
+            s2 = Uh(s2, this.Gh(t4, n3, i2));
+        }
+        let c2 = this.Eh.get(i2);
+        void 0 === c2 && (c2 = /* @__PURE__ */ new Map(), this.Eh.set(i2, c2));
+        for (let t4 = Math.max(l2 + 1, o2); t4 < h2; t4 += Bh) {
+            const e3 = Math.floor(t4 / Bh);
+            let n3 = c2.get(e3);
+            if (void 0 === n3) {
+                const t5 = this.Zh(e3 * Bh),
+                    s3 = this.Kh((e3 + 1) * Bh - 1);
+                n3 = this.Gh(t5, s3, i2), c2.set(e3, n3);
+            }
+            s2 = Uh(s2, n3);
+        } {
+            const t4 = this.Zh(h2),
+                e3 = this.Kh(a2);
+            s2 = Uh(s2, this.Gh(t4, e3, i2));
+        }
+        return s2;
+    }
+}
+
+function Uh(t3, e2) {
+    return null === t3 ? e2 : null === e2 ? t3 : {
+        Jh: Math.min(t3.Jh, e2.Jh),
+        Qh: Math.max(t3.Qh, e2.Qh)
+    };
+}
+class Pi extends Mi {
+    constructor(t3, e2, i2) {
+        super(t3), this.zt = new Ci(), this.xh = new fi(this), this.tl = [], this.il = new Kt(this), this.nl = null, this.sl = null, this.el = [], this.rl = [], this.hl = null, this.un = e2, this.ll = i2;
+        const s2 = new pi(this);
+        this.rn = [s2], this.yh = new Yt(s2, this, t3), "Area" !== i2 && "Line" !== i2 && "Baseline" !== i2 || (this.nl = new ii(this)), this.al(), this.ol();
+    }
+    M() {
+        null !== this.hl && clearTimeout(this.hl);
+    }
+    Kr(t3) {
+        return this.un.priceLineColor || t3;
+    }
+    Or(t3) {
+        const e2 = {
+                Lr: true
+            },
+            i2 = this.Bt();
+        if (this.Ut().yt().Ni() || i2.Ni() || this.zt.Ni())
+            return e2;
+        const s2 = this.Ut().yt().Vs(),
+            n2 = this.Tt();
+        if (null === s2 || null === n2)
+            return e2;
+        let r2, o2;
+        if (t3) {
+            const t4 = this.zt.Vh();
+            if (null === t4)
+                return e2;
+            r2 = t4, o2 = t4.Ys;
+        } else {
+            const t4 = this.zt.jh(s2.ci(), -1);
+            if (null === t4)
+                return e2;
+            if (r2 = this.zt.Ah(t4.Ys), null === r2)
+                return e2;
+            o2 = t4.Ys;
+        }
+        const a2 = r2.At[3],
+            l2 = this.Ls().Os(o2, {
+                At: r2
+            }),
+            h2 = i2.Dt(a2, n2.At);
+        return {
+            Lr: false,
+            ut: a2,
+            Gt: i2.Fi(a2, n2.At),
+            ih: i2._l(a2),
+            nh: i2.ul(a2, n2.At),
+            D: l2.ie,
+            yi: h2,
+            Ys: o2
+        };
+    }
+    Ls() {
+        return null !== this.sl || (this.sl = new xi(this)), this.sl;
+    }
+    F() {
+        return this.un;
+    }
+    kh(t3) {
+        const e2 = t3.priceScaleId;
+        void 0 !== e2 && e2 !== this.un.priceScaleId && this.Ut().cl(this, e2), Ol(this.un, t3), void 0 !== t3.priceFormat && (this.al(), this.Ut().dl()), this.Ut().fl(this), this.Ut().pl(), this.bn.gt("options");
+    }
+    tt(t3, e2) {
+        this.zt.tt(t3), this.vl(), this.bn.gt("data"), this.cn.gt("data"), null !== this.nl && (e2 && e2.ml ? this.nl.Rr() : 0 === t3.length && this.nl.Pr());
+        const i2 = this.Ut().Ke(this);
+        this.Ut().bl(i2), this.Ut().fl(this), this.Ut().pl(), this.Ut().Ch();
+    }
+    gl(t3) {
+        this.el = t3, this.vl();
+        const e2 = this.Ut().Ke(this);
+        this.cn.gt("data"), this.Ut().bl(e2), this.Ut().fl(this), this.Ut().pl(), this.Ut().Ch();
+    }
+    wl() {
+        return this.el;
+    }
+    Xr() {
+        return this.rl;
+    }
+    Ml(t3) {
+        const e2 = new wi(this, t3);
+        return this.tl.push(e2), this.Ut().fl(this), e2;
+    }
+    Sl(t3) {
+        const e2 = this.tl.indexOf(t3); -
+        1 !== e2 && this.tl.splice(e2, 1), this.Ut().fl(this);
+    }
+    Lh() {
+        return this.ll;
+    }
+    Tt() {
+        const t3 = this.xl();
+        return null === t3 ? null : {
+            At: t3.At[3],
+            yl: t3._t
+        };
+    }
+    xl() {
+        const t3 = this.Ut().yt().Vs();
+        if (null === t3)
+            return null;
+        const e2 = t3.Ms();
+        return this.zt.jh(e2, 1);
+    }
+    Ln() {
+        return this.zt;
+    }
+    Zr(t3) {
+        const e2 = this.zt.Ah(t3);
+        return null === e2 ? null : "Bar" === this.ll || "Candlestick" === this.ll ? {
+            oe: e2.At[0],
+            _e: e2.At[1],
+            ue: e2.At[2],
+            ce: e2.At[3]
+        } : e2.At[3];
+    }
+    kl(t3) {
+        const e2 = this.nl;
+        return null !== e2 && e2.Ct() ? (null === this.hl && e2.Br() && (this.hl = setTimeout(() => {
+            this.hl = null, this.Ut().Cl();
+        }, 0)), e2.Dr(), [e2]) : [];
+    }
+    Tn() {
+        const t3 = [];
+        this.Tl() || t3.push(this.il), t3.push(this.bn, this.xh, this.cn);
+        const e2 = this.tl.map((t4) => t4.Th());
+        return t3.push(...e2), t3;
+    }
+    Ji(t3) {
+        return [this.yh, ...this.tl.map((t4) => t4.Ph())];
+    }
+    Pn(t3, e2) {
+        if (e2 !== this.Yi && !this.Tl())
+            return [];
+        const i2 = [...this.rn];
+        for (const t4 of this.tl)
+            i2.push(t4.Rh());
+        return i2;
+    }
+    Pl(t3, e2) {
+        if (void 0 !== this.un.autoscaleInfoProvider) {
+            const i2 = this.un.autoscaleInfoProvider(() => {
+                const i3 = this.Rl(t3, e2);
+                return null === i3 ? null : i3.dh();
+            });
+            return mi.fh(i2);
+        }
+        return this.Rl(t3, e2);
+    }
+    Dl() {
+        return this.un.priceFormat.minMove;
+    }
+    Bl() {
+        return this.Al;
+    }
+    Dn() {
+        var t3;
+        this.bn.gt(), this.cn.gt();
+        for (const t4 of this.rn)
+            t4.gt();
+        for (const t4 of this.tl)
+            t4.gt();
+        this.xh.gt(), this.il.gt(), null === (t3 = this.nl) || void 0 === t3 || t3.gt();
+    }
+    Bt() {
+        return kl(super.Bt());
+    }
+    kt(t3) {
+        if ("Line" !== this.ll && "Area" !== this.ll && "Baseline" !== this.ll || !this.un.crosshairMarkerVisible)
+            return null;
+        const e2 = this.zt.Ah(t3);
+        return null === e2 ? null : {
+            ut: e2.At[3],
+            lt: this.Ol(),
+            Ot: this.Ll(),
+            Rt: this.Il(),
+            Pt: this.El(t3)
+        };
+    }
+    Gr() {
+        return this.un.title;
+    }
+    Ct() {
+        return this.un.visible;
+    }
+    Tl() {
+        return !lh(this.Bt().zl());
+    }
+    Rl(t3, e2) {
+        if (!Nl(t3) || !Nl(e2) || this.zt.Ni())
+            return null;
+        const i2 = "Line" === this.ll || "Area" === this.ll || "Baseline" === this.ll || "Histogram" === this.ll ? [3] : [2, 1],
+            s2 = this.zt.Hh(t3, e2, i2);
+        let n2 = null !== s2 ? new vi(s2.Jh, s2.Qh) : null;
+        if ("Histogram" === this.Lh()) {
+            const t4 = this.un.base,
+                e3 = new vi(t4, t4);
+            n2 = null !== n2 ? n2.Qn(e3) : e3;
+        }
+        return new mi(n2, this.cn.Yr());
+    }
+    Ol() {
+        switch (this.ll) {
+            case "Line":
+            case "Area":
+            case "Baseline":
+                return this.un.crosshairMarkerRadius;
+        }
+        return 0;
+    }
+    Ll() {
+        switch (this.ll) {
+            case "Line":
+            case "Area":
+            case "Baseline": {
+                const t3 = this.un.crosshairMarkerBorderColor;
+                if (0 !== t3.length)
+                    return t3;
+            }
+        }
+        return null;
+    }
+    Il() {
+        switch (this.ll) {
+            case "Line":
+            case "Area":
+            case "Baseline":
+                return this.un.crosshairMarkerBorderWidth;
+        }
+        return 0;
+    }
+    El(t3) {
+        switch (this.ll) {
+            case "Line":
+            case "Area":
+            case "Baseline": {
+                const t4 = this.un.crosshairMarkerBackgroundColor;
+                if (0 !== t4.length)
+                    return t4;
+            }
+        }
+        return this.Ls().Os(t3).ie;
+    }
+    al() {
+        switch (this.un.priceFormat.type) {
+            case "custom":
+                this.Al = {
+                    format: this.un.priceFormat.formatter
+                };
+                break;
+            case "volume":
+                this.Al = new ot(this.un.priceFormat.precision);
+                break;
+            case "percent":
+                this.Al = new at(this.un.priceFormat.precision);
+                break;
+            default: {
+                const t3 = Math.pow(10, this.un.priceFormat.precision);
+                this.Al = new lt(t3, this.un.priceFormat.minMove * t3);
+            }
+        }
+        null !== this.Yi && this.Yi.Vl();
+    }
+    vl() {
+        const t3 = this.Ut().yt();
+        if (!t3.Nl() || this.zt.Ni())
+            return void(this.rl = []);
+        const e2 = kl(this.zt.Nh());
+        this.rl = this.el.map((i2, s2) => {
+            const n2 = kl(t3.Fl(i2.time, true)),
+                r2 = n2 < e2 ? 1 : -1;
+            return {
+                time: kl(this.zt.jh(n2, r2)).Ys,
+                position: i2.position,
+                shape: i2.shape,
+                color: i2.color,
+                id: i2.id,
+                internalId: s2,
+                text: i2.text,
+                size: i2.size
+            };
+        });
+    }
+    ol() {
+        switch (this.cn = new di(this, this.Ut()), this.ll) {
+            case "Bar":
+                this.bn = new Bt(this, this.Ut());
+                break;
+            case "Candlestick":
+                this.bn = new Ft(this, this.Ut());
+                break;
+            case "Line":
+                this.bn = new $t(this, this.Ut());
+                break;
+            case "Area":
+                this.bn = new Pt(this, this.Ut());
+                break;
+            case "Baseline":
+                this.bn = new Vt(this, this.Ut());
+                break;
+            case "Histogram":
+                this.bn = new jt(this, this.Ut());
+                break;
+            default:
+                throw Error("Unknown chart style assigned: " + this.ll);
+        }
+    }
+}
+class Ri {
+    constructor(t3) {
+        this.un = t3;
+    }
+    Wl(t3, e2, i2) {
+        let s2 = t3;
+        if (0 === this.un.mode)
+            return s2;
+        const n2 = i2.fn(),
+            r2 = n2.Tt();
+        if (null === r2)
+            return s2;
+        const o2 = n2.Dt(t3, r2),
+            a2 = i2.jl().filter((t4) => t4 instanceof Pi).reduce((t4, s3) => {
+                if (i2.Ge(s3) || !s3.Ct())
+                    return t4;
+                const n3 = s3.Bt(),
+                    r3 = s3.Ln();
+                if (n3.Ni() || !r3.Ir(e2))
+                    return t4;
+                const o3 = r3.Ah(e2);
+                if (null === o3)
+                    return t4;
+                const a3 = Tl(s3.Tt());
+                return t4.concat([n3.Dt(o3.At[3], a3.At)]);
+            }, []);
+        if (0 === a2.length)
+            return s2;
+        a2.sort((t4, e3) => Math.abs(t4 - o2) - Math.abs(e3 - o2));
+        const l2 = a2[0];
+        return s2 = n2.pn(l2, r2), s2;
+    }
+}
+class Di extends Yl {
+    constructor() {
+        super(...arguments), this.zt = null;
+    }
+    tt(t3) {
+        this.zt = t3;
+    }
+    Z({
+        context: t3,
+        bitmapSize: e2,
+        horizontalPixelRatio: i2,
+        verticalPixelRatio: s2
+    }) {
+        if (null === this.zt)
+            return;
+        const n2 = Math.max(1, Math.floor(i2));
+        t3.lineWidth = n2,
+            function(t4, e3) {
+                t4.save(), t4.lineWidth % 2 && t4.translate(0.5, 0.5), e3(), t4.restore();
+            }(t3, () => {
+                const r2 = kl(this.zt);
+                if (r2.$l) {
+                    t3.strokeStyle = r2.Hl, bl(t3, r2.Ul), t3.beginPath();
+                    for (const s3 of r2.ql) {
+                        const r3 = Math.round(s3.Yl * i2);
+                        t3.moveTo(r3, -n2), t3.lineTo(r3, e2.height + n2);
+                    }
+                    t3.stroke();
+                }
+                if (r2.Xl) {
+                    t3.strokeStyle = r2.Zl, bl(t3, r2.Kl), t3.beginPath();
+                    for (const i3 of r2.Gl) {
+                        const r3 = Math.round(i3.Yl * s2);
+                        t3.moveTo(-n2, r3), t3.lineTo(e2.width + n2, r3);
+                    }
+                    t3.stroke();
+                }
+            });
+    }
+}
+class Bi {
+    constructor(t3) {
+        this.jt = new Di(), this.vt = true, this.tn = t3;
+    }
+    gt() {
+        this.vt = true;
+    }
+    Mt() {
+        if (this.vt) {
+            const t3 = this.tn.Ut().F().grid,
+                e2 = {
+                    Xl: t3.horzLines.visible,
+                    $l: t3.vertLines.visible,
+                    Zl: t3.horzLines.color,
+                    Hl: t3.vertLines.color,
+                    Kl: t3.horzLines.style,
+                    Ul: t3.vertLines.style,
+                    Gl: this.tn.fn().Jl(),
+                    ql: this.tn.Ut().yt().Jl() || []
+                };
+            this.jt.tt(e2), this.vt = false;
+        }
+        return this.jt;
+    }
+}
+class Ai {
+    constructor(t3) {
+        this.bn = new Bi(t3);
+    }
+    Th() {
+        return this.bn;
+    }
+}
+const jh = {
+    Ql: 4,
+    ta: 1e-4
+};
+
+function Hh(t3, e2) {
+    const i2 = 100 * (t3 - e2) / e2;
+    return e2 < 0 ? -i2 : i2;
+}
+
+function Wh(t3, e2) {
+    const i2 = Hh(t3.lh(), e2),
+        s2 = Hh(t3.ah(), e2);
+    return new vi(i2, s2);
+}
+
+function qh(t3, e2) {
+    const i2 = 100 * (t3 - e2) / e2 + 100;
+    return e2 < 0 ? -i2 : i2;
+}
+
+function Kh(t3, e2) {
+    const i2 = qh(t3.lh(), e2),
+        s2 = qh(t3.ah(), e2);
+    return new vi(i2, s2);
+}
+
+function Gh(t3, e2) {
+    const i2 = Math.abs(t3);
+    if (i2 < 1e-15)
+        return 0;
+    const s2 = Th(i2 + e2.ta) + e2.Ql;
+    return t3 < 0 ? -s2 : s2;
+}
+
+function Yh(t3, e2) {
+    const i2 = Math.abs(t3);
+    if (i2 < 1e-15)
+        return 0;
+    const s2 = Math.pow(10, i2 - e2.Ql) - e2.ta;
+    return t3 < 0 ? -s2 : s2;
+}
+
+function Qh(t3, e2) {
+    if (null === t3)
+        return null;
+    const i2 = Gh(t3.lh(), e2),
+        s2 = Gh(t3.ah(), e2);
+    return new vi(i2, s2);
+}
+
+function Xh(t3, e2) {
+    if (null === t3)
+        return null;
+    const i2 = Yh(t3.lh(), e2),
+        s2 = Yh(t3.ah(), e2);
+    return new vi(i2, s2);
+}
+
+function Jh(t3) {
+    if (null === t3)
+        return jh;
+    const e2 = Math.abs(t3.ah() - t3.lh());
+    if (e2 >= 1 || e2 < 1e-15)
+        return jh;
+    const i2 = Math.ceil(Math.abs(Math.log10(e2))),
+        s2 = jh.Ql + i2;
+    return {
+        Ql: s2,
+        ta: 1 / Math.pow(10, s2)
+    };
+}
+class $i {
+    constructor(t3, e2) {
+        if (this.ia = t3, this.na = e2, function(t4) {
+                if (t4 < 0)
+                    return false;
+                for (let e3 = t4; e3 > 1; e3 /= 10)
+                    if (e3 % 10 != 0)
+                        return false;
+                return true;
+            }(this.ia))
+            this.sa = [2, 2.5, 2];
+        else {
+            this.sa = [];
+            for (let t4 = this.ia; 1 !== t4;) {
+                if (t4 % 2 == 0)
+                    this.sa.push(2), t4 /= 2;
+                else {
+                    if (t4 % 5 != 0)
+                        throw new Error("unexpected base");
+                    this.sa.push(2, 2.5), t4 /= 5;
+                }
+                if (this.sa.length > 100)
+                    throw new Error("something wrong with base");
+            }
+        }
+    }
+    ea(t3, e2, i2) {
+        const s2 = 0 === this.ia ? 0 : 1 / this.ia;
+        let n2 = Math.pow(10, Math.max(0, Math.ceil(Th(t3 - e2)))),
+            r2 = 0,
+            o2 = this.na[0];
+        for (;;) {
+            const t4 = kh(n2, s2, 1e-14) && n2 > s2 + 1e-14,
+                e3 = kh(n2, i2 * o2, 1e-14),
+                a3 = kh(n2, 1, 1e-14);
+            if (!(t4 && e3 && a3))
+                break;
+            n2 /= o2, o2 = this.na[++r2 % this.na.length];
+        }
+        if (n2 <= s2 + 1e-14 && (n2 = s2), n2 = Math.max(1, n2), this.sa.length > 0 && (a2 = n2, 1, 1e-14, Math.abs(a2 - 1) < 1e-14))
+            for (r2 = 0, o2 = this.sa[0]; kh(n2, i2 * o2, 1e-14) && n2 > s2 + 1e-14;)
+                n2 /= o2, o2 = this.sa[++r2 % this.sa.length];
+        var a2;
+        return n2;
+    }
+}
+class Hi {
+    constructor(t3, e2, i2, s2) {
+        this.ra = [], this.zi = t3, this.ia = e2, this.ha = i2, this.la = s2;
+    }
+    ea(t3, e2) {
+        if (t3 < e2)
+            throw new Error("high < low");
+        const i2 = this.zi.It(),
+            s2 = (t3 - e2) * this.aa() / i2,
+            n2 = new $i(this.ia, [2, 2.5, 2]),
+            r2 = new $i(this.ia, [2, 2, 2.5]),
+            o2 = new $i(this.ia, [2.5, 2, 2]),
+            a2 = [];
+        return a2.push(n2.ea(t3, e2, s2), r2.ea(t3, e2, s2), o2.ea(t3, e2, s2)),
+            function(t4) {
+                if (t4.length < 1)
+                    throw Error("array is empty");
+                let e3 = t4[0];
+                for (let i3 = 1; i3 < t4.length; ++i3)
+                    t4[i3] < e3 && (e3 = t4[i3]);
+                return e3;
+            }(a2);
+    }
+    oa() {
+        const t3 = this.zi,
+            e2 = t3.Tt();
+        if (null === e2)
+            return void(this.ra = []);
+        const i2 = t3.It(),
+            s2 = this.ha(i2 - 1, e2),
+            n2 = this.ha(0, e2),
+            r2 = this.zi.F().entireTextOnly ? this._a() / 2 : 0,
+            o2 = r2,
+            a2 = i2 - 1 - r2,
+            l2 = Math.max(s2, n2),
+            h2 = Math.min(s2, n2);
+        if (l2 === h2)
+            return void(this.ra = []);
+        let c2 = this.ea(l2, h2),
+            u2 = l2 % c2;
+        u2 += u2 < 0 ? c2 : 0;
+        const d2 = l2 >= h2 ? 1 : -1;
+        let f2 = null,
+            p2 = 0;
+        for (let i3 = l2 - u2; i3 > h2; i3 -= c2) {
+            const s3 = this.la(i3, e2, true);
+            null !== f2 && Math.abs(s3 - f2) < this.aa() || s3 < o2 || s3 > a2 || (p2 < this.ra.length ? (this.ra[p2].Yl = s3, this.ra[p2].ua = t3.ca(i3)) : this.ra.push({
+                Yl: s3,
+                ua: t3.ca(i3)
+            }), p2++, f2 = s3, t3.da() && (c2 = this.ea(i3 * d2, h2)));
+        }
+        this.ra.length = p2;
+    }
+    Jl() {
+        return this.ra;
+    }
+    _a() {
+        return this.zi.T();
+    }
+    aa() {
+        return Math.ceil(2.5 * this._a());
+    }
+}
+
+function Zh(t3) {
+    return t3.slice().sort((t4, e2) => kl(t4.Zi()) - kl(e2.Zi()));
+}
+var tc;
+! function(t3) {
+    t3[t3.Normal = 0] = "Normal", t3[t3.Logarithmic = 1] = "Logarithmic", t3[t3.Percentage = 2] = "Percentage", t3[t3.IndexedTo100 = 3] = "IndexedTo100";
+}(tc || (tc = {}));
+const ec = new at(),
+    ic = new lt(100, 1);
+class Zi {
+    constructor(t3, e2, i2, s2) {
+        this.fa = 0, this.pa = null, this.ph = null, this.va = null, this.ma = {
+            ba: false,
+            ga: null
+        }, this.wa = 0, this.Ma = 0, this.Sa = new Ll(), this.xa = new Ll(), this.ya = [], this.ka = null, this.Ca = null, this.Ta = null, this.Pa = null, this.Al = ic, this.Ra = Jh(null), this.Da = t3, this.un = e2, this.Ba = i2, this.Aa = s2, this.Oa = new Hi(this, 100, this.La.bind(this), this.Ia.bind(this));
+    }
+    zl() {
+        return this.Da;
+    }
+    F() {
+        return this.un;
+    }
+    kh(t3) {
+        if (Ol(this.un, t3), this.Vl(), void 0 !== t3.mode && this.Ea({
+                lr: t3.mode
+            }), void 0 !== t3.scaleMargins) {
+            const e2 = xl(t3.scaleMargins.top),
+                i2 = xl(t3.scaleMargins.bottom);
+            if (e2 < 0 || e2 > 1)
+                throw new Error(`Invalid top margin - expect value between 0 and 1, given=${e2}`);
+            if (i2 < 0 || i2 > 1 || e2 + i2 > 1)
+                throw new Error(`Invalid bottom margin - expect value between 0 and 1, given=${i2}`);
+            if (e2 + i2 > 1)
+                throw new Error(`Invalid margins - sum of margins must be less than 1, given=${e2 + i2}`);
+            this.za(), this.Ca = null;
+        }
+    }
+    Va() {
+        return this.un.autoScale;
+    }
+    da() {
+        return 1 === this.un.mode;
+    }
+    th() {
+        return 2 === this.un.mode;
+    }
+    Na() {
+        return 3 === this.un.mode;
+    }
+    lr() {
+        return {
+            Fn: this.un.autoScale,
+            Fa: this.un.invertScale,
+            lr: this.un.mode
+        };
+    }
+    Ea(t3) {
+        const e2 = this.lr();
+        let i2 = null;
+        void 0 !== t3.Fn && (this.un.autoScale = t3.Fn), void 0 !== t3.lr && (this.un.mode = t3.lr, 2 !== t3.lr && 3 !== t3.lr || (this.un.autoScale = true), this.ma.ba = false), 1 === e2.lr && t3.lr !== e2.lr && (function(t4, e3) {
+            if (null === t4)
+                return false;
+            const i3 = Yh(t4.lh(), e3),
+                s3 = Yh(t4.ah(), e3);
+            return isFinite(i3) && isFinite(s3);
+        }(this.ph, this.Ra) ? (i2 = Xh(this.ph, this.Ra), null !== i2 && this.Wa(i2)) : this.un.autoScale = true), 1 === t3.lr && t3.lr !== e2.lr && (i2 = Qh(this.ph, this.Ra), null !== i2 && this.Wa(i2));
+        const s2 = e2.lr !== this.un.mode;
+        s2 && (2 === e2.lr || this.th()) && this.Vl(), s2 && (3 === e2.lr || this.Na()) && this.Vl(), void 0 !== t3.Fa && e2.Fa !== t3.Fa && (this.un.invertScale = t3.Fa, this.ja()), this.xa.m(e2, this.lr());
+    }
+    $a() {
+        return this.xa;
+    }
+    T() {
+        return this.Ba.fontSize;
+    }
+    It() {
+        return this.fa;
+    }
+    Ha(t3) {
+        this.fa !== t3 && (this.fa = t3, this.za(), this.Ca = null);
+    }
+    Ua() {
+        if (this.pa)
+            return this.pa;
+        const t3 = this.It() - this.qa() - this.Ya();
+        return this.pa = t3, t3;
+    }
+    bh() {
+        return this.Xa(), this.ph;
+    }
+    Wa(t3, e2) {
+        const i2 = this.ph;
+        (e2 || null === i2 && null !== t3 || null !== i2 && !i2.rh(t3)) && (this.Ca = null, this.ph = t3);
+    }
+    Ni() {
+        return this.Xa(), 0 === this.fa || !this.ph || this.ph.Ni();
+    }
+    Za(t3) {
+        return this.Fa() ? t3 : this.It() - 1 - t3;
+    }
+    Dt(t3, e2) {
+        return this.th() ? t3 = Hh(t3, e2) : this.Na() && (t3 = qh(t3, e2)), this.Ia(t3, e2);
+    }
+    $s(t3, e2, i2) {
+        this.Xa();
+        const s2 = this.Ya(),
+            n2 = kl(this.bh()),
+            r2 = n2.lh(),
+            o2 = n2.ah(),
+            a2 = this.Ua() - 1,
+            l2 = this.Fa(),
+            h2 = a2 / (o2 - r2),
+            c2 = void 0 === i2 ? 0 : i2.from,
+            u2 = void 0 === i2 ? t3.length : i2.to,
+            d2 = this.Ka();
+        for (let i3 = c2; i3 < u2; i3++) {
+            const n3 = t3[i3],
+                o3 = n3.ut;
+            if (isNaN(o3))
+                continue;
+            let a3 = o3;
+            null !== d2 && (a3 = d2(n3.ut, e2));
+            const c3 = s2 + h2 * (a3 - r2),
+                u3 = l2 ? c3 : this.fa - 1 - c3;
+            n3.et = u3;
+        }
+    }
+    le(t3, e2, i2) {
+        this.Xa();
+        const s2 = this.Ya(),
+            n2 = kl(this.bh()),
+            r2 = n2.lh(),
+            o2 = n2.ah(),
+            a2 = this.Ua() - 1,
+            l2 = this.Fa(),
+            h2 = a2 / (o2 - r2),
+            c2 = void 0 === i2 ? 0 : i2.from,
+            u2 = void 0 === i2 ? t3.length : i2.to,
+            d2 = this.Ka();
+        for (let i3 = c2; i3 < u2; i3++) {
+            const n3 = t3[i3];
+            let o3 = n3.oe,
+                a3 = n3._e,
+                c3 = n3.ue,
+                u3 = n3.ce;
+            null !== d2 && (o3 = d2(n3.oe, e2), a3 = d2(n3._e, e2), c3 = d2(n3.ue, e2), u3 = d2(n3.ce, e2));
+            let f2 = s2 + h2 * (o3 - r2),
+                p2 = l2 ? f2 : this.fa - 1 - f2;
+            n3.re = p2, f2 = s2 + h2 * (a3 - r2), p2 = l2 ? f2 : this.fa - 1 - f2, n3.ne = p2, f2 = s2 + h2 * (c3 - r2), p2 = l2 ? f2 : this.fa - 1 - f2, n3.se = p2, f2 = s2 + h2 * (u3 - r2), p2 = l2 ? f2 : this.fa - 1 - f2, n3.he = p2;
+        }
+    }
+    pn(t3, e2) {
+        const i2 = this.La(t3, e2);
+        return this.Ga(i2, e2);
+    }
+    Ga(t3, e2) {
+        let i2 = t3;
+        return this.th() ? i2 = function(t4, e3) {
+            return e3 < 0 && (t4 = -t4), t4 / 100 * e3 + e3;
+        }(i2, e2) : this.Na() && (i2 = function(t4, e3) {
+            return t4 -= 100, e3 < 0 && (t4 = -t4), t4 / 100 * e3 + e3;
+        }(i2, e2)), i2;
+    }
+    jl() {
+        return this.ya;
+    }
+    Ja() {
+        if (this.ka)
+            return this.ka;
+        let t3 = [];
+        for (let e2 = 0; e2 < this.ya.length; e2++) {
+            const i2 = this.ya[e2];
+            null === i2.Zi() && i2.Ki(e2 + 1), t3.push(i2);
+        }
+        return t3 = Zh(t3), this.ka = t3, this.ka;
+    }
+    Qa(t3) {
+        -1 === this.ya.indexOf(t3) && (this.ya.push(t3), this.Vl(), this.io());
+    }
+    no(t3) {
+        const e2 = this.ya.indexOf(t3);
+        if (-1 === e2)
+            throw new Error("source is not attached to scale");
+        this.ya.splice(e2, 1), 0 === this.ya.length && (this.Ea({
+            Fn: true
+        }), this.Wa(null)), this.Vl(), this.io();
+    }
+    Tt() {
+        let t3 = null;
+        for (const e2 of this.ya) {
+            const i2 = e2.Tt();
+            null !== i2 && (null === t3 || i2.yl < t3.yl) && (t3 = i2);
+        }
+        return null === t3 ? null : t3.At;
+    }
+    Fa() {
+        return this.un.invertScale;
+    }
+    Jl() {
+        const t3 = null === this.Tt();
+        if (null !== this.Ca && (t3 || this.Ca.so === t3))
+            return this.Ca.Jl;
+        this.Oa.oa();
+        const e2 = this.Oa.Jl();
+        return this.Ca = {
+            Jl: e2,
+            so: t3
+        }, this.Sa.m(), e2;
+    }
+    eo() {
+        return this.Sa;
+    }
+    ro(t3) {
+        this.th() || this.Na() || null === this.Ta && null === this.va && (this.Ni() || (this.Ta = this.fa - t3, this.va = kl(this.bh()).hh()));
+    }
+    ho(t3) {
+        if (this.th() || this.Na())
+            return;
+        if (null === this.Ta)
+            return;
+        this.Ea({
+            Fn: false
+        }), (t3 = this.fa - t3) < 0 && (t3 = 0);
+        let e2 = (this.Ta + 0.2 * (this.fa - 1)) / (t3 + 0.2 * (this.fa - 1));
+        const i2 = kl(this.va).hh();
+        e2 = Math.max(e2, 0.1), i2._h(e2), this.Wa(i2);
+    }
+    lo() {
+        this.th() || this.Na() || (this.Ta = null, this.va = null);
+    }
+    ao(t3) {
+        this.Va() || null === this.Pa && null === this.va && (this.Ni() || (this.Pa = t3, this.va = kl(this.bh()).hh()));
+    }
+    oo(t3) {
+        if (this.Va())
+            return;
+        if (null === this.Pa)
+            return;
+        const e2 = kl(this.bh()).oh() / (this.Ua() - 1);
+        let i2 = t3 - this.Pa;
+        this.Fa() && (i2 *= -1);
+        const s2 = i2 * e2,
+            n2 = kl(this.va).hh();
+        n2.uh(s2), this.Wa(n2, true), this.Ca = null;
+    }
+    _o() {
+        this.Va() || null !== this.Pa && (this.Pa = null, this.va = null);
+    }
+    Bl() {
+        return this.Al || this.Vl(), this.Al;
+    }
+    Fi(t3, e2) {
+        switch (this.un.mode) {
+            case 2:
+                return this.Bl().format(Hh(t3, e2));
+            case 3:
+                return this.Bl().format(qh(t3, e2));
+            default:
+                return this.Sh(t3);
+        }
+    }
+    ca(t3) {
+        switch (this.un.mode) {
+            case 2:
+            case 3:
+                return this.Bl().format(t3);
+            default:
+                return this.Sh(t3);
+        }
+    }
+    _l(t3) {
+        return this.Sh(t3, kl(this.uo()).Bl());
+    }
+    ul(t3, e2) {
+        return t3 = Hh(t3, e2), ec.format(t3);
+    }
+    co() {
+        return this.ya;
+    }
+    do(t3) {
+        this.ma = {
+            ga: t3,
+            ba: false
+        };
+    }
+    Dn() {
+        this.ya.forEach((t3) => t3.Dn());
+    }
+    Vl() {
+        this.Ca = null;
+        const t3 = this.uo();
+        let e2 = 100;
+        null !== t3 && (e2 = Math.round(1 / t3.Dl())), this.Al = ic, this.th() ? (this.Al = ec, e2 = 100) : this.Na() ? (this.Al = new lt(100, 1), e2 = 100) : null !== t3 && (this.Al = t3.Bl()), this.Oa = new Hi(this, e2, this.La.bind(this), this.Ia.bind(this)), this.Oa.oa();
+    }
+    io() {
+        this.ka = null;
+    }
+    uo() {
+        return this.ya[0] || null;
+    }
+    qa() {
+        return this.Fa() ? this.un.scaleMargins.bottom * this.It() + this.Ma : this.un.scaleMargins.top * this.It() + this.wa;
+    }
+    Ya() {
+        return this.Fa() ? this.un.scaleMargins.top * this.It() + this.wa : this.un.scaleMargins.bottom * this.It() + this.Ma;
+    }
+    Xa() {
+        this.ma.ba || (this.ma.ba = true, this.fo());
+    }
+    za() {
+        this.pa = null;
+    }
+    Ia(t3, e2) {
+        if (this.Xa(), this.Ni())
+            return 0;
+        t3 = this.da() && t3 ? Gh(t3, this.Ra) : t3;
+        const i2 = kl(this.bh()),
+            s2 = this.Ya() + (this.Ua() - 1) * (t3 - i2.lh()) / i2.oh();
+        return this.Za(s2);
+    }
+    La(t3, e2) {
+        if (this.Xa(), this.Ni())
+            return 0;
+        const i2 = this.Za(t3),
+            s2 = kl(this.bh()),
+            n2 = s2.lh() + s2.oh() * ((i2 - this.Ya()) / (this.Ua() - 1));
+        return this.da() ? Yh(n2, this.Ra) : n2;
+    }
+    ja() {
+        this.Ca = null, this.Oa.oa();
+    }
+    fo() {
+        const t3 = this.ma.ga;
+        if (null === t3)
+            return;
+        let e2 = null;
+        const i2 = this.co();
+        let s2 = 0,
+            n2 = 0;
+        for (const r3 of i2) {
+            if (!r3.Ct())
+                continue;
+            const i3 = r3.Tt();
+            if (null === i3)
+                continue;
+            const o3 = r3.Pl(t3.Ms(), t3.ci());
+            let a2 = o3 && o3.bh();
+            if (null !== a2) {
+                switch (this.un.mode) {
+                    case 1:
+                        a2 = Qh(a2, this.Ra);
+                        break;
+                    case 2:
+                        a2 = Wh(a2, i3.At);
+                        break;
+                    case 3:
+                        a2 = Kh(a2, i3.At);
+                }
+                if (e2 = null === e2 ? a2 : e2.Qn(kl(a2)), null !== o3) {
+                    const t4 = o3.gh();
+                    null !== t4 && (s2 = Math.max(s2, t4.above), n2 = Math.max(s2, t4.below));
+                }
+            }
+        }
+        if (s2 === this.wa && n2 === this.Ma || (this.wa = s2, this.Ma = n2, this.Ca = null, this.za()), null !== e2) {
+            if (e2.lh() === e2.ah()) {
+                const t4 = this.uo(),
+                    i3 = 5 * (null === t4 || this.th() || this.Na() ? 1 : t4.Dl());
+                this.da() && (e2 = Xh(e2, this.Ra)), e2 = new vi(e2.lh() - i3, e2.ah() + i3), this.da() && (e2 = Qh(e2, this.Ra));
+            }
+            if (this.da()) {
+                const t4 = Xh(e2, this.Ra),
+                    i3 = Jh(t4);
+                if (r2 = i3, o2 = this.Ra, r2.Ql !== o2.Ql || r2.ta !== o2.ta) {
+                    const s3 = null !== this.va ? Xh(this.va, this.Ra) : null;
+                    this.Ra = i3, e2 = Qh(t4, i3), null !== s3 && (this.va = Qh(s3, i3));
+                }
+            }
+            this.Wa(e2);
+        } else
+            null === this.ph && (this.Wa(new vi(-0.5, 0.5)), this.Ra = Jh(null));
+        var r2, o2;
+        this.ma.ba = true;
+    }
+    Ka() {
+        return this.th() ? Hh : this.Na() ? qh : this.da() ? (t3) => Gh(t3, this.Ra) : null;
+    }
+    Sh(t3, e2) {
+        return void 0 === this.Aa.priceFormatter ? (void 0 === e2 && (e2 = this.Bl()), e2.format(t3)) : this.Aa.priceFormatter(t3);
+    }
+}
+class Ki {
+    constructor(t3, e2) {
+        this.ya = [], this.po = /* @__PURE__ */ new Map(), this.fa = 0, this.vo = 0, this.mo = 1e3, this.ka = null, this.bo = new Ll(), this.wo = t3, this.Hi = e2, this.Mo = new Ai(this);
+        const i2 = e2.F();
+        this.So = this.xo("left", i2.leftPriceScale), this.yo = this.xo("right", i2.rightPriceScale), this.So.$a().l(this.ko.bind(this, this.So), this), this.yo.$a().l(this.ko.bind(this, this.yo), this), this.Co(i2);
+    }
+    Co(t3) {
+        if (t3.leftPriceScale && this.So.kh(t3.leftPriceScale), t3.rightPriceScale && this.yo.kh(t3.rightPriceScale), t3.localization && (this.So.Vl(), this.yo.Vl()), t3.overlayPriceScales) {
+            const e2 = Array.from(this.po.values());
+            for (const i2 of e2) {
+                const e3 = kl(i2[0].Bt());
+                e3.kh(t3.overlayPriceScales), t3.localization && e3.Vl();
+            }
+        }
+    }
+    To(t3) {
+        switch (t3) {
+            case "left":
+                return this.So;
+            case "right":
+                return this.yo;
+        }
+        return this.po.has(t3) ? xl(this.po.get(t3))[0].Bt() : null;
+    }
+    M() {
+        this.Ut().Po().v(this), this.So.$a().v(this), this.yo.$a().v(this), this.ya.forEach((t3) => {
+            t3.M && t3.M();
+        }), this.bo.m();
+    }
+    Ro() {
+        return this.mo;
+    }
+    Do(t3) {
+        this.mo = t3;
+    }
+    Ut() {
+        return this.Hi;
+    }
+    $i() {
+        return this.vo;
+    }
+    It() {
+        return this.fa;
+    }
+    Bo(t3) {
+        this.vo = t3, this.Ao();
+    }
+    Ha(t3) {
+        this.fa = t3, this.So.Ha(t3), this.yo.Ha(t3), this.ya.forEach((e2) => {
+            if (this.Ge(e2)) {
+                const i2 = e2.Bt();
+                null !== i2 && i2.Ha(t3);
+            }
+        }), this.Ao();
+    }
+    jl() {
+        return this.ya;
+    }
+    Ge(t3) {
+        const e2 = t3.Bt();
+        return null === e2 || this.So !== e2 && this.yo !== e2;
+    }
+    Qa(t3, e2, i2) {
+        const s2 = void 0 !== i2 ? i2 : this.Lo().Oo + 1;
+        this.Io(t3, e2, s2);
+    }
+    no(t3) {
+        const e2 = this.ya.indexOf(t3);
+        wl(-1 !== e2, "removeDataSource: invalid data source"), this.ya.splice(e2, 1);
+        const i2 = kl(t3.Bt()).zl();
+        if (this.po.has(i2)) {
+            const e3 = xl(this.po.get(i2)),
+                s3 = e3.indexOf(t3); -
+            1 !== s3 && (e3.splice(s3, 1), 0 === e3.length && this.po.delete(i2));
+        }
+        const s2 = t3.Bt();
+        s2 && s2.jl().indexOf(t3) >= 0 && s2.no(t3), null !== s2 && (s2.io(), this.Eo(s2)), this.ka = null;
+    }
+    Qe(t3) {
+        return t3 === this.So ? "left" : t3 === this.yo ? "right" : "overlay";
+    }
+    zo() {
+        return this.So;
+    }
+    Vo() {
+        return this.yo;
+    }
+    No(t3, e2) {
+        t3.ro(e2);
+    }
+    Fo(t3, e2) {
+        t3.ho(e2), this.Ao();
+    }
+    Wo(t3) {
+        t3.lo();
+    }
+    jo(t3, e2) {
+        t3.ao(e2);
+    }
+    $o(t3, e2) {
+        t3.oo(e2), this.Ao();
+    }
+    Ho(t3) {
+        t3._o();
+    }
+    Ao() {
+        this.ya.forEach((t3) => {
+            t3.Dn();
+        });
+    }
+    fn() {
+        let t3 = null;
+        return this.Hi.F().rightPriceScale.visible && 0 !== this.yo.jl().length ? t3 = this.yo : this.Hi.F().leftPriceScale.visible && 0 !== this.So.jl().length ? t3 = this.So : 0 !== this.ya.length && (t3 = this.ya[0].Bt()), null === t3 && (t3 = this.yo), t3;
+    }
+    Je() {
+        let t3 = null;
+        return this.Hi.F().rightPriceScale.visible ? t3 = this.yo : this.Hi.F().leftPriceScale.visible && (t3 = this.So), t3;
+    }
+    Eo(t3) {
+        null !== t3 && t3.Va() && this.Uo(t3);
+    }
+    qo(t3) {
+        const e2 = this.wo.Vs();
+        t3.Ea({
+            Fn: true
+        }), null !== e2 && t3.do(e2), this.Ao();
+    }
+    Yo() {
+        this.Uo(this.So), this.Uo(this.yo);
+    }
+    Xo() {
+        this.Eo(this.So), this.Eo(this.yo), this.ya.forEach((t3) => {
+            this.Ge(t3) && this.Eo(t3.Bt());
+        }), this.Ao(), this.Hi.Ch();
+    }
+    Ja() {
+        return null === this.ka && (this.ka = Zh(this.ya)), this.ka;
+    }
+    Zo() {
+        return this.bo;
+    }
+    Ko() {
+        return this.Mo;
+    }
+    Uo(t3) {
+        const e2 = t3.co();
+        if (e2 && e2.length > 0 && !this.wo.Ni()) {
+            const e3 = this.wo.Vs();
+            null !== e3 && t3.do(e3);
+        }
+        t3.Dn();
+    }
+    Lo() {
+        const t3 = this.Ja();
+        if (0 === t3.length)
+            return {
+                Go: 0,
+                Oo: 0
+            };
+        let e2 = 0,
+            i2 = 0;
+        for (let s2 = 0; s2 < t3.length; s2++) {
+            const n2 = t3[s2].Zi();
+            null !== n2 && (n2 < e2 && (e2 = n2), n2 > i2 && (i2 = n2));
+        }
+        return {
+            Go: e2,
+            Oo: i2
+        };
+    }
+    Io(t3, e2, i2) {
+        let s2 = this.To(e2);
+        if (null === s2 && (s2 = this.xo(e2, this.Hi.F().overlayPriceScales)), this.ya.push(t3), !lh(e2)) {
+            const i3 = this.po.get(e2) || [];
+            i3.push(t3), this.po.set(e2, i3);
+        }
+        s2.Qa(t3), t3.Gi(s2), t3.Ki(i2), this.Eo(s2), this.ka = null;
+    }
+    ko(t3, e2, i2) {
+        e2.lr !== i2.lr && this.Uo(t3);
+    }
+    xo(t3, e2) {
+        const i2 = Object.assign({
+                visible: true,
+                autoScale: true
+            }, zl(e2)),
+            s2 = new Zi(t3, i2, this.Hi.F().layout, this.Hi.F().localization);
+        return s2.Ha(this.It()), s2;
+    }
+}
+const sc = (t3) => t3.getUTCFullYear();
+class rn {
+    constructor(t3 = "yyyy-MM-dd", e2 = "default") {
+        this.Jo = t3, this.Qo = e2;
+    }
+    t_(t3) {
+        return function(t4, e2, i2) {
+            return e2.replace(/yyyy/g, ((t5) => hh(sc(t5), 4))(t4)).replace(/yy/g, ((t5) => hh(sc(t5) % 100, 2))(t4)).replace(/MMMM/g, ((t5, e3) => new Date(t5.getUTCFullYear(), t5.getUTCMonth(), 1).toLocaleString(e3, {
+                month: "long"
+            }))(t4, i2)).replace(/MMM/g, ((t5, e3) => new Date(t5.getUTCFullYear(), t5.getUTCMonth(), 1).toLocaleString(e3, {
+                month: "short"
+            }))(t4, i2)).replace(/MM/g, ((t5) => hh(((t6) => t6.getUTCMonth() + 1)(t5), 2))(t4)).replace(/dd/g, ((t5) => hh(((t6) => t6.getUTCDate())(t5), 2))(t4));
+        }(t3, this.Jo, this.Qo);
+    }
+}
+class hn {
+    constructor(t3) {
+        this.i_ = t3 || "%h:%m:%s";
+    }
+    t_(t3) {
+        return this.i_.replace("%h", hh(t3.getUTCHours(), 2)).replace("%m", hh(t3.getUTCMinutes(), 2)).replace("%s", hh(t3.getUTCSeconds(), 2));
+    }
+}
+const nc = {
+    n_: "yyyy-MM-dd",
+    s_: "%h:%m:%s",
+    e_: " ",
+    r_: "default"
+};
+class an {
+    constructor(t3 = {}) {
+        const e2 = Object.assign(Object.assign({}, nc), t3);
+        this.h_ = new rn(e2.n_, e2.r_), this.l_ = new hn(e2.s_), this.a_ = e2.e_;
+    }
+    t_(t3) {
+        return `${this.h_.t_(t3)}${this.a_}${this.l_.t_(t3)}`;
+    }
+}
+class on {
+    constructor(t3, e2 = 50) {
+        this.Le = 0, this.Ie = 1, this.Ee = 1, this.Ve = /* @__PURE__ */ new Map(), this.ze = /* @__PURE__ */ new Map(), this.o_ = t3, this.Ne = e2;
+    }
+    t_(t3) {
+        const e2 = t3._t,
+            i2 = void 0 === e2.__ ? new Date(1e3 * e2.u_).getTime() : new Date(Date.UTC(e2.__.year, e2.__.month - 1, e2.__.day)).getTime(),
+            s2 = this.Ve.get(i2);
+        if (void 0 !== s2)
+            return s2.c_;
+        if (this.Le === this.Ne) {
+            const t4 = this.ze.get(this.Ee);
+            this.ze.delete(this.Ee), this.Ve.delete(xl(t4)), this.Ee++, this.Le--;
+        }
+        const n2 = this.o_(t3);
+        return this.Ve.set(i2, {
+            c_: n2,
+            $e: this.Ie
+        }), this.ze.set(this.Ie, i2), this.Le++, this.Ie++, n2;
+    }
+}
+class _n {
+    constructor(t3, e2) {
+        wl(t3 <= e2, "right should be >= left"), this.d_ = t3, this.f_ = e2;
+    }
+    Ms() {
+        return this.d_;
+    }
+    ci() {
+        return this.f_;
+    }
+    p_() {
+        return this.f_ - this.d_ + 1;
+    }
+    Ir(t3) {
+        return this.d_ <= t3 && t3 <= this.f_;
+    }
+    rh(t3) {
+        return this.d_ === t3.Ms() && this.f_ === t3.ci();
+    }
+}
+
+function rc(t3, e2) {
+    return null === t3 || null === e2 ? t3 === e2 : t3.rh(e2);
+}
+class cn {
+    constructor() {
+        this.v_ = /* @__PURE__ */ new Map(), this.Ve = null;
+    }
+    m_(t3, e2) {
+        this.b_(e2), this.Ve = null;
+        for (let i2 = e2; i2 < t3.length; ++i2) {
+            const e3 = t3[i2];
+            let s2 = this.v_.get(e3.g_);
+            void 0 === s2 && (s2 = [], this.v_.set(e3.g_, s2)), s2.push({
+                Ys: i2,
+                _t: e3._t,
+                w_: e3.g_,
+                M_: e3.M_
+            });
+        }
+    }
+    S_(t3, e2) {
+        const i2 = Math.ceil(e2 / t3);
+        return null !== this.Ve && this.Ve.x_ === i2 || (this.Ve = {
+            Jl: this.y_(i2),
+            x_: i2
+        }), this.Ve.Jl;
+    }
+    b_(t3) {
+        if (0 === t3)
+            return void this.v_.clear();
+        const e2 = [];
+        this.v_.forEach((i2, s2) => {
+            t3 <= i2[0].Ys ? e2.push(s2) : i2.splice(yh(i2, t3, (e3) => e3.Ys < t3), 1 / 0);
+        });
+        for (const t4 of e2)
+            this.v_.delete(t4);
+    }
+    y_(t3) {
+        let e2 = [];
+        for (const i2 of Array.from(this.v_.keys()).sort((t4, e3) => e3 - t4)) {
+            if (!this.v_.get(i2))
+                continue;
+            const s2 = e2;
+            e2 = [];
+            const n2 = s2.length;
+            let r2 = 0;
+            const o2 = xl(this.v_.get(i2)),
+                a2 = o2.length;
+            let l2 = 1 / 0,
+                h2 = -1 / 0;
+            for (let i3 = 0; i3 < a2; i3++) {
+                const a3 = o2[i3],
+                    c2 = a3.Ys;
+                for (; r2 < n2;) {
+                    const t4 = s2[r2],
+                        i4 = t4.Ys;
+                    if (!(i4 < c2)) {
+                        l2 = i4;
+                        break;
+                    }
+                    r2++, e2.push(t4), h2 = i4, l2 = 1 / 0;
+                }
+                l2 - c2 >= t3 && c2 - h2 >= t3 && (e2.push(a3), h2 = c2);
+            }
+            for (; r2 < n2; r2++)
+                e2.push(s2[r2]);
+        }
+        return e2;
+    }
+}
+class dn {
+    constructor(t3) {
+        this.k_ = t3;
+    }
+    C_() {
+        return null === this.k_ ? null : new _n(Math.floor(this.k_.Ms()), Math.ceil(this.k_.ci()));
+    }
+    T_() {
+        return this.k_;
+    }
+    static P_() {
+        return new dn(null);
+    }
+}
+var oc, ac, lc, hc, cc;
+! function(t3) {
+    t3[t3.Year = 0] = "Year", t3[t3.Month = 1] = "Month", t3[t3.DayOfMonth = 2] = "DayOfMonth", t3[t3.Time = 3] = "Time", t3[t3.TimeWithSeconds = 4] = "TimeWithSeconds";
+}(oc || (oc = {}));
+class gn {
+    constructor(t3, e2, i2) {
+        this.vo = 0, this.R_ = null, this.D_ = [], this.Pa = null, this.Ta = null, this.B_ = new cn(), this.A_ = /* @__PURE__ */ new Map(), this.O_ = dn.P_(), this.L_ = true, this.I_ = new Ll(), this.E_ = new Ll(), this.z_ = new Ll(), this.V_ = null, this.N_ = null, this.F_ = [], this.un = e2, this.Aa = i2, this.W_ = e2.rightOffset, this.j_ = e2.barSpacing, this.Hi = t3, this.H_();
+    }
+    F() {
+        return this.un;
+    }
+    U_(t3) {
+        Ol(this.Aa, t3), this.q_(), this.H_();
+    }
+    kh(t3, e2) {
+        var i2;
+        Ol(this.un, t3), this.un.fixLeftEdge && this.Y_(), this.un.fixRightEdge && this.X_(), void 0 !== t3.barSpacing && this.Hi.Kn(t3.barSpacing), void 0 !== t3.rightOffset && this.Hi.Gn(t3.rightOffset), void 0 !== t3.minBarSpacing && this.Hi.Kn(null !== (i2 = t3.barSpacing) && void 0 !== i2 ? i2 : this.j_), this.q_(), this.H_(), this.z_.m();
+    }
+    vn(t3) {
+        var e2, i2;
+        return null !== (i2 = null === (e2 = this.D_[t3]) || void 0 === e2 ? void 0 : e2._t) && void 0 !== i2 ? i2 : null;
+    }
+    Ui(t3) {
+        var e2;
+        return null !== (e2 = this.D_[t3]) && void 0 !== e2 ? e2 : null;
+    }
+    Fl(t3, e2) {
+        if (this.D_.length < 1)
+            return null;
+        if (t3.u_ > this.D_[this.D_.length - 1]._t.u_)
+            return e2 ? this.D_.length - 1 : null;
+        const i2 = yh(this.D_, t3.u_, (t4, e3) => t4._t.u_ < e3);
+        return t3.u_ < this.D_[i2]._t.u_ ? e2 ? i2 : null : i2;
+    }
+    Ni() {
+        return 0 === this.vo || 0 === this.D_.length || null === this.R_;
+    }
+    Nl() {
+        return this.D_.length > 0;
+    }
+    Vs() {
+        return this.Z_(), this.O_.C_();
+    }
+    K_() {
+        return this.Z_(), this.O_.T_();
+    }
+    G_() {
+        const t3 = this.Vs();
+        if (null === t3)
+            return null;
+        const e2 = {
+            from: t3.Ms(),
+            to: t3.ci()
+        };
+        return this.J_(e2);
+    }
+    J_(t3) {
+        const e2 = Math.round(t3.from),
+            i2 = Math.round(t3.to),
+            s2 = kl(this.Q_()),
+            n2 = kl(this.tu());
+        return {
+            from: kl(this.vn(Math.max(s2, e2))),
+            to: kl(this.vn(Math.min(n2, i2)))
+        };
+    }
+    iu(t3) {
+        return {
+            from: kl(this.Fl(t3.from, true)),
+            to: kl(this.Fl(t3.to, true))
+        };
+    }
+    $i() {
+        return this.vo;
+    }
+    Bo(t3) {
+        if (!isFinite(t3) || t3 <= 0)
+            return;
+        if (this.vo === t3)
+            return;
+        const e2 = this.K_(),
+            i2 = this.vo;
+        if (this.vo = t3, this.L_ = true, this.un.lockVisibleTimeRangeOnResize && 0 !== i2) {
+            const e3 = this.j_ * t3 / i2;
+            this.j_ = e3;
+        }
+        if (this.un.fixLeftEdge && null !== e2 && e2.Ms() <= 0) {
+            const e3 = i2 - t3;
+            this.W_ -= Math.round(e3 / this.j_) + 1, this.L_ = true;
+        }
+        this.nu(), this.su();
+    }
+    Et(t3) {
+        if (this.Ni() || !Nl(t3))
+            return 0;
+        const e2 = this.eu() + this.W_ - t3;
+        return this.vo - (e2 + 0.5) * this.j_ - 1;
+    }
+    js(t3, e2) {
+        const i2 = this.eu(),
+            s2 = void 0 === e2 ? 0 : e2.from,
+            n2 = void 0 === e2 ? t3.length : e2.to;
+        for (let e3 = s2; e3 < n2; e3++) {
+            const s3 = t3[e3]._t,
+                n3 = i2 + this.W_ - s3,
+                r2 = this.vo - (n3 + 0.5) * this.j_ - 1;
+            t3[e3].st = r2;
+        }
+    }
+    ru(t3) {
+        return Math.ceil(this.hu(t3));
+    }
+    Gn(t3) {
+        this.L_ = true, this.W_ = t3, this.su(), this.Hi.lu(), this.Hi.Ch();
+    }
+    Ks() {
+        return this.j_;
+    }
+    Kn(t3) {
+        this.au(t3), this.su(), this.Hi.lu(), this.Hi.Ch();
+    }
+    ou() {
+        return this.W_;
+    }
+    Jl() {
+        if (this.Ni())
+            return null;
+        if (null !== this.N_)
+            return this.N_;
+        const t3 = this.j_,
+            e2 = 5 * (this.Hi.F().layout.fontSize + 4),
+            i2 = Math.round(e2 / t3),
+            s2 = kl(this.Vs()),
+            n2 = Math.max(s2.Ms(), s2.Ms() - i2),
+            r2 = Math.max(s2.ci(), s2.ci() - i2),
+            o2 = this.B_.S_(t3, e2),
+            a2 = this.Q_() + i2,
+            l2 = this.tu() - i2,
+            h2 = this._u(),
+            c2 = this.un.fixLeftEdge || h2,
+            u2 = this.un.fixRightEdge || h2;
+        let d2 = 0;
+        for (const t4 of o2) {
+            if (!(n2 <= t4.Ys && t4.Ys <= r2))
+                continue;
+            let i3;
+            d2 < this.F_.length ? (i3 = this.F_[d2], i3.Yl = this.Et(t4.Ys), i3.ua = this.uu(t4), i3.w_ = t4.w_) : (i3 = {
+                cu: false,
+                Yl: this.Et(t4.Ys),
+                ua: this.uu(t4),
+                w_: t4.w_
+            }, this.F_.push(i3)), this.j_ > e2 / 2 && !h2 ? i3.cu = false : i3.cu = c2 && t4.Ys <= a2 || u2 && t4.Ys >= l2, d2++;
+        }
+        return this.F_.length = d2, this.N_ = this.F_, this.F_;
+    }
+    du() {
+        this.L_ = true, this.Kn(this.un.barSpacing), this.Gn(this.un.rightOffset);
+    }
+    fu(t3) {
+        this.L_ = true, this.R_ = t3, this.su(), this.Y_();
+    }
+    pu(t3, e2) {
+        const i2 = this.hu(t3),
+            s2 = this.Ks(),
+            n2 = s2 + e2 * (s2 / 10);
+        this.Kn(n2), this.un.rightBarStaysOnScroll || this.Gn(this.ou() + (i2 - this.hu(t3)));
+    }
+    ro(t3) {
+        this.Pa && this._o(), null === this.Ta && null === this.V_ && (this.Ni() || (this.Ta = t3, this.vu()));
+    }
+    ho(t3) {
+        if (null === this.V_)
+            return;
+        const e2 = xh(this.vo - t3, 0, this.vo),
+            i2 = xh(this.vo - kl(this.Ta), 0, this.vo);
+        0 !== e2 && 0 !== i2 && this.Kn(this.V_.Ks * e2 / i2);
+    }
+    lo() {
+        null !== this.Ta && (this.Ta = null, this.mu());
+    }
+    ao(t3) {
+        null === this.Pa && null === this.V_ && (this.Ni() || (this.Pa = t3, this.vu()));
+    }
+    oo(t3) {
+        if (null === this.Pa)
+            return;
+        const e2 = (this.Pa - t3) / this.Ks();
+        this.W_ = kl(this.V_).ou + e2, this.L_ = true, this.su();
+    }
+    _o() {
+        null !== this.Pa && (this.Pa = null, this.mu());
+    }
+    bu() {
+        this.gu(this.un.rightOffset);
+    }
+    gu(t3, e2 = 400) {
+        if (!isFinite(t3))
+            throw new RangeError("offset is required and must be finite number");
+        if (!isFinite(e2) || e2 <= 0)
+            throw new RangeError("animationDuration (optional) must be finite positive number");
+        const i2 = this.W_,
+            s2 = performance.now();
+        this.Hi.Yn({
+            wu: (t4) => (t4 - s2) / e2 >= 1,
+            Mu: (n2) => {
+                const r2 = (n2 - s2) / e2;
+                return r2 >= 1 ? t3 : i2 + (t3 - i2) * r2;
+            }
+        });
+    }
+    gt(t3, e2) {
+        this.L_ = true, this.D_ = t3, this.B_.m_(t3, e2), this.su();
+    }
+    Su() {
+        return this.I_;
+    }
+    xu() {
+        return this.E_;
+    }
+    yu() {
+        return this.z_;
+    }
+    eu() {
+        return this.R_ || 0;
+    }
+    ku(t3) {
+        const e2 = t3.p_();
+        this.au(this.vo / e2), this.W_ = t3.ci() - this.eu(), this.su(), this.L_ = true, this.Hi.lu(), this.Hi.Ch();
+    }
+    Cu() {
+        const t3 = this.Q_(),
+            e2 = this.tu();
+        null !== t3 && null !== e2 && this.ku(new _n(t3, e2 + this.un.rightOffset));
+    }
+    Tu(t3) {
+        const e2 = new _n(t3.from, t3.to);
+        this.ku(e2);
+    }
+    qi(t3) {
+        return void 0 !== this.Aa.timeFormatter ? this.Aa.timeFormatter(t3.M_) : this.Pu.t_(new Date(1e3 * t3._t.u_));
+    }
+    _u() {
+        const {
+            handleScroll: t3,
+            handleScale: e2
+        } = this.Hi.F();
+        return !(t3.horzTouchDrag || t3.mouseWheel || t3.pressedMouseMove || t3.vertTouchDrag || e2.axisDoubleClickReset.time || e2.axisPressedMouseMove.time || e2.mouseWheel || e2.pinch);
+    }
+    Q_() {
+        return 0 === this.D_.length ? null : 0;
+    }
+    tu() {
+        return 0 === this.D_.length ? null : this.D_.length - 1;
+    }
+    Ru(t3) {
+        return (this.vo - 1 - t3) / this.j_;
+    }
+    hu(t3) {
+        const e2 = this.Ru(t3),
+            i2 = this.eu() + this.W_ - e2;
+        return Math.round(1e6 * i2) / 1e6;
+    }
+    au(t3) {
+        const e2 = this.j_;
+        this.j_ = t3, this.nu(), e2 !== this.j_ && (this.L_ = true, this.Du());
+    }
+    Z_() {
+        if (!this.L_)
+            return;
+        if (this.L_ = false, this.Ni())
+            return void this.Bu(dn.P_());
+        const t3 = this.eu(),
+            e2 = this.vo / this.j_,
+            i2 = this.W_ + t3,
+            s2 = new _n(i2 - e2 + 1, i2);
+        this.Bu(new dn(s2));
+    }
+    nu() {
+        const t3 = this.Au();
+        if (this.j_ < t3 && (this.j_ = t3, this.L_ = true), 0 !== this.vo) {
+            const t4 = 0.5 * this.vo;
+            this.j_ > t4 && (this.j_ = t4, this.L_ = true);
+        }
+    }
+    Au() {
+        return this.un.fixLeftEdge && this.un.fixRightEdge && 0 !== this.D_.length ? this.vo / this.D_.length : this.un.minBarSpacing;
+    }
+    su() {
+        const t3 = this.Ou();
+        this.W_ > t3 && (this.W_ = t3, this.L_ = true);
+        const e2 = this.Lu();
+        null !== e2 && this.W_ < e2 && (this.W_ = e2, this.L_ = true);
+    }
+    Lu() {
+        const t3 = this.Q_(),
+            e2 = this.R_;
+        return null === t3 || null === e2 ? null : t3 - e2 - 1 + (this.un.fixLeftEdge ? this.vo / this.j_ : Math.min(2, this.D_.length));
+    }
+    Ou() {
+        return this.un.fixRightEdge ? 0 : this.vo / this.j_ - Math.min(2, this.D_.length);
+    }
+    vu() {
+        this.V_ = {
+            Ks: this.Ks(),
+            ou: this.ou()
+        };
+    }
+    mu() {
+        this.V_ = null;
+    }
+    uu(t3) {
+        let e2 = this.A_.get(t3.w_);
+        return void 0 === e2 && (e2 = new on((t4) => this.Iu(t4)), this.A_.set(t3.w_, e2)), e2.t_(t3);
+    }
+    Iu(t3) {
+        const e2 = function(t4, e3, i2) {
+            switch (t4) {
+                case 0:
+                case 10:
+                    return e3 ? i2 ? 4 : 3 : 2;
+                case 20:
+                case 21:
+                case 22:
+                case 30:
+                case 31:
+                case 32:
+                case 33:
+                    return e3 ? 3 : 2;
+                case 50:
+                    return 2;
+                case 60:
+                    return 1;
+                case 70:
+                    return 0;
+            }
+        }(t3.w_, this.un.timeVisible, this.un.secondsVisible);
+        if (void 0 !== this.un.tickMarkFormatter) {
+            const i2 = this.un.tickMarkFormatter(t3.M_, e2, this.Aa.locale);
+            if (null !== i2)
+                return i2;
+        }
+        return function(t4, e3, i2) {
+            const s2 = {};
+            switch (e3) {
+                case 0:
+                    s2.year = "numeric";
+                    break;
+                case 1:
+                    s2.month = "short";
+                    break;
+                case 2:
+                    s2.day = "numeric";
+                    break;
+                case 3:
+                    s2.hour12 = false, s2.hour = "2-digit", s2.minute = "2-digit";
+                    break;
+                case 4:
+                    s2.hour12 = false, s2.hour = "2-digit", s2.minute = "2-digit", s2.second = "2-digit";
+            }
+            const n2 = void 0 === t4.__ ? new Date(1e3 * t4.u_) : new Date(Date.UTC(t4.__.year, t4.__.month - 1, t4.__.day));
+            return new Date(n2.getUTCFullYear(), n2.getUTCMonth(), n2.getUTCDate(), n2.getUTCHours(), n2.getUTCMinutes(), n2.getUTCSeconds(), n2.getUTCMilliseconds()).toLocaleString(i2, s2);
+        }(t3._t, e2, this.Aa.locale);
+    }
+    Bu(t3) {
+        const e2 = this.O_;
+        this.O_ = t3, rc(e2.C_(), this.O_.C_()) || this.I_.m(), rc(e2.T_(), this.O_.T_()) || this.E_.m(), this.Du();
+    }
+    Du() {
+        this.N_ = null;
+    }
+    q_() {
+        this.Du(), this.A_.clear();
+    }
+    H_() {
+        const t3 = this.Aa.dateFormat;
+        this.un.timeVisible ? this.Pu = new an({
+            n_: t3,
+            s_: this.un.secondsVisible ? "%h:%m:%s" : "%h:%m",
+            e_: "   ",
+            r_: this.Aa.locale
+        }) : this.Pu = new rn(t3, this.Aa.locale);
+    }
+    Y_() {
+        if (!this.un.fixLeftEdge)
+            return;
+        const t3 = this.Q_();
+        if (null === t3)
+            return;
+        const e2 = this.Vs();
+        if (null === e2)
+            return;
+        const i2 = e2.Ms() - t3;
+        if (i2 < 0) {
+            const t4 = this.W_ - i2 - 1;
+            this.Gn(t4);
+        }
+        this.nu();
+    }
+    X_() {
+        this.su(), this.nu();
+    }
+}
+class wn extends L {
+    constructor(t3) {
+        super(), this.Eu = /* @__PURE__ */ new Map(), this.zt = t3;
+    }
+    Z(t3) {}
+    G(t3) {
+        if (!this.zt.Ct)
+            return;
+        const {
+            context: e2,
+            mediaSize: i2
+        } = t3;
+        let s2 = 0;
+        for (const t4 of this.zt.zu) {
+            if (0 === t4.Gt.length)
+                continue;
+            e2.font = t4.P;
+            const n3 = this.Vu(e2, t4.Gt);
+            n3 > i2.width ? t4.pu = i2.width / n3 : t4.pu = 1, s2 += t4.Nu * t4.pu;
+        }
+        let n2 = 0;
+        switch (this.zt.Fu) {
+            case "top":
+                n2 = 0;
+                break;
+            case "center":
+                n2 = Math.max((i2.height - s2) / 2, 0);
+                break;
+            case "bottom":
+                n2 = Math.max(i2.height - s2, 0);
+        }
+        e2.fillStyle = this.zt.D;
+        for (const t4 of this.zt.zu) {
+            e2.save();
+            let s3 = 0;
+            switch (this.zt.Wu) {
+                case "left":
+                    e2.textAlign = "left", s3 = t4.Nu / 2;
+                    break;
+                case "center":
+                    e2.textAlign = "center", s3 = i2.width / 2;
+                    break;
+                case "right":
+                    e2.textAlign = "right", s3 = i2.width - 1 - t4.Nu / 2;
+            }
+            e2.translate(s3, n2), e2.textBaseline = "top", e2.font = t4.P, e2.scale(t4.pu, t4.pu), e2.fillText(t4.Gt, 0, t4.ju), e2.restore(), n2 += t4.Nu * t4.pu;
+        }
+    }
+    Vu(t3, e2) {
+        const i2 = this.$u(t3.font);
+        let s2 = i2.get(e2);
+        return void 0 === s2 && (s2 = t3.measureText(e2).width, i2.set(e2, s2)), s2;
+    }
+    $u(t3) {
+        let e2 = this.Eu.get(t3);
+        return void 0 === e2 && (e2 = /* @__PURE__ */ new Map(), this.Eu.set(t3, e2)), e2;
+    }
+}
+class Mn {
+    constructor(t3) {
+        this.vt = true, this.Wt = {
+            Ct: false,
+            D: "",
+            zu: [],
+            Fu: "center",
+            Wu: "center"
+        }, this.jt = new wn(this.Wt), this.$t = t3;
+    }
+    gt() {
+        this.vt = true;
+    }
+    Mt() {
+        return this.vt && (this.St(), this.vt = false), this.jt;
+    }
+    St() {
+        const t3 = this.$t.F(),
+            e2 = this.Wt;
+        e2.Ct = t3.visible, e2.Ct && (e2.D = t3.color, e2.Wu = t3.horzAlign, e2.Fu = t3.vertAlign, e2.zu = [{
+            Gt: t3.text,
+            P: Hl(t3.fontSize, t3.fontFamily, t3.fontStyle),
+            Nu: 1.2 * t3.fontSize,
+            ju: 0,
+            pu: 0
+        }]);
+    }
+}
+class Sn extends tt {
+    constructor(t3, e2) {
+        super(), this.un = e2, this.bn = new Mn(this);
+    }
+    Pn() {
+        return [];
+    }
+    Tn() {
+        return [this.bn];
+    }
+    F() {
+        return this.un;
+    }
+    Dn() {
+        this.bn.gt();
+    }
+}! function(t3) {
+    t3[t3.OnTouchEnd = 0] = "OnTouchEnd", t3[t3.OnNextTap = 1] = "OnNextTap";
+}(ac || (ac = {}));
+class xn {
+    constructor(t3, e2) {
+        this.Hu = [], this.Uu = [], this.vo = 0, this.qu = null, this.Yu = new Ll(), this.Xu = new Ll(), this.Zu = null, this.Ku = t3, this.un = e2, this.Gu = new class A {
+            constructor(t4) {
+                this.S = {
+                    k: 1,
+                    C: 5,
+                    T: NaN,
+                    P: "",
+                    R: "",
+                    D: "",
+                    B: "",
+                    A: 0,
+                    O: 0,
+                    L: 0,
+                    I: 0,
+                    V: 0
+                }, this.N = t4;
+            }
+            F() {
+                const t4 = this.S,
+                    e3 = this.W(),
+                    i2 = this.j();
+                return t4.T === e3 && t4.R === i2 || (t4.T = e3, t4.R = i2, t4.P = Hl(e3, i2), t4.I = 2.5 / 12 * e3, t4.A = t4.I, t4.O = e3 / 12 * t4.C, t4.L = e3 / 12 * t4.C, t4.V = 0), t4.D = this.$(), t4.B = this.H(), this.S;
+            }
+            $() {
+                return this.N.F().layout.textColor;
+            }
+            H() {
+                return this.N.U();
+            }
+            W() {
+                return this.N.F().layout.fontSize;
+            }
+            j() {
+                return this.N.F().layout.fontFamily;
+            }
+        }(this), this.wo = new gn(this, e2.timeScale, this.un.localization), this.bt = new nt(this, e2.crosshair), this.Ju = new Ri(e2.crosshair), this.Qu = new Sn(this, e2.watermark), this.tc(), this.Hu[0].Do(2e3), this.ic = this.nc(0), this.sc = this.nc(1);
+    }
+    dl() {
+        this.ec(et.ss());
+    }
+    Ch() {
+        this.ec(et.ns());
+    }
+    Cl() {
+        this.ec(new et(1));
+    }
+    fl(t3) {
+        const e2 = this.rc(t3);
+        this.ec(e2);
+    }
+    hc() {
+        return this.qu;
+    }
+    lc(t3) {
+        const e2 = this.qu;
+        this.qu = t3, null !== e2 && this.fl(e2.ac), null !== t3 && this.fl(t3.ac);
+    }
+    F() {
+        return this.un;
+    }
+    kh(t3) {
+        Ol(this.un, t3), this.Hu.forEach((e2) => e2.Co(t3)), void 0 !== t3.timeScale && this.wo.kh(t3.timeScale), void 0 !== t3.localization && this.wo.U_(t3.localization), (t3.leftPriceScale || t3.rightPriceScale) && this.Yu.m(), this.ic = this.nc(0), this.sc = this.nc(1), this.dl();
+    }
+    oc(t3, e2) {
+        if ("left" === t3)
+            return void this.kh({
+                leftPriceScale: e2
+            });
+        if ("right" === t3)
+            return void this.kh({
+                rightPriceScale: e2
+            });
+        const i2 = this._c(t3);
+        null !== i2 && (i2.Bt.kh(e2), this.Yu.m());
+    }
+    _c(t3) {
+        for (const e2 of this.Hu) {
+            const i2 = e2.To(t3);
+            if (null !== i2)
+                return {
+                    Ht: e2,
+                    Bt: i2
+                };
+        }
+        return null;
+    }
+    yt() {
+        return this.wo;
+    }
+    uc() {
+        return this.Hu;
+    }
+    cc() {
+        return this.Qu;
+    }
+    dc() {
+        return this.bt;
+    }
+    fc() {
+        return this.Xu;
+    }
+    vc(t3, e2) {
+        t3.Ha(e2), this.lu();
+    }
+    Bo(t3) {
+        this.vo = t3, this.wo.Bo(this.vo), this.Hu.forEach((e2) => e2.Bo(t3)), this.lu();
+    }
+    tc(t3) {
+        const e2 = new Ki(this.wo, this);
+        void 0 !== t3 ? this.Hu.splice(t3, 0, e2) : this.Hu.push(e2);
+        const i2 = void 0 === t3 ? this.Hu.length - 1 : t3,
+            s2 = et.ss();
+        return s2.Vn(i2, {
+            Nn: 0,
+            Fn: true
+        }), this.ec(s2), e2;
+    }
+    No(t3, e2, i2) {
+        t3.No(e2, i2);
+    }
+    Fo(t3, e2, i2) {
+        t3.Fo(e2, i2), this.pl(), this.ec(this.mc(t3, 2));
+    }
+    Wo(t3, e2) {
+        t3.Wo(e2), this.ec(this.mc(t3, 2));
+    }
+    jo(t3, e2, i2) {
+        e2.Va() || t3.jo(e2, i2);
+    }
+    $o(t3, e2, i2) {
+        e2.Va() || (t3.$o(e2, i2), this.pl(), this.ec(this.mc(t3, 2)));
+    }
+    Ho(t3, e2) {
+        e2.Va() || (t3.Ho(e2), this.ec(this.mc(t3, 2)));
+    }
+    qo(t3, e2) {
+        t3.qo(e2), this.ec(this.mc(t3, 2));
+    }
+    bc(t3) {
+        this.wo.ro(t3);
+    }
+    gc(t3, e2) {
+        const i2 = this.yt();
+        if (i2.Ni() || 0 === e2)
+            return;
+        const s2 = i2.$i();
+        t3 = Math.max(1, Math.min(t3, s2)), i2.pu(t3, e2), this.lu();
+    }
+    wc(t3) {
+        this.Mc(0), this.Sc(t3), this.xc();
+    }
+    yc(t3) {
+        this.wo.ho(t3), this.lu();
+    }
+    kc() {
+        this.wo.lo(), this.Ch();
+    }
+    Mc(t3) {
+        this.wo.ao(t3);
+    }
+    Sc(t3) {
+        this.wo.oo(t3), this.lu();
+    }
+    xc() {
+        this.wo._o(), this.Ch();
+    }
+    wt() {
+        return this.Uu;
+    }
+    Cc(t3, e2, i2, s2) {
+        this.bt.gn(t3, e2);
+        let n2 = NaN,
+            r2 = this.wo.ru(t3);
+        const o2 = this.wo.Vs();
+        null !== o2 && (r2 = Math.min(Math.max(o2.Ms(), r2), o2.ci()));
+        const a2 = s2.fn(),
+            l2 = a2.Tt();
+        null !== l2 && (n2 = a2.pn(e2, l2)), n2 = this.Ju.Wl(n2, r2, s2), this.bt.xn(r2, n2, s2), this.Cl(), this.Xu.m(this.bt.xt(), {
+            x: t3,
+            y: e2
+        }, i2);
+    }
+    Tc() {
+        this.dc().kn(), this.Cl(), this.Xu.m(null, null, null);
+    }
+    pl() {
+        const t3 = this.bt.Ht();
+        if (null !== t3) {
+            const e2 = this.bt.Mn(),
+                i2 = this.bt.Sn();
+            this.Cc(e2, i2, null, t3);
+        }
+        this.bt.Dn();
+    }
+    Pc(t3, e2, i2) {
+        const s2 = this.wo.vn(0);
+        void 0 !== e2 && void 0 !== i2 && this.wo.gt(e2, i2);
+        const n2 = this.wo.vn(0),
+            r2 = this.wo.eu(),
+            o2 = this.wo.Vs();
+        if (null !== o2 && null !== s2 && null !== n2) {
+            const e3 = o2.Ir(r2),
+                i3 = s2.u_ > n2.u_,
+                a2 = null !== t3 && t3 > r2 && !i3,
+                l2 = e3 && this.wo.F().shiftVisibleRangeOnNewBar;
+            if (a2 && !l2) {
+                const e4 = t3 - r2;
+                this.wo.Gn(this.wo.ou() - e4);
+            }
+        }
+        this.wo.fu(t3);
+    }
+    bl(t3) {
+        null !== t3 && t3.Xo();
+    }
+    Ke(t3) {
+        const e2 = this.Hu.find((e3) => e3.Ja().includes(t3));
+        return void 0 === e2 ? null : e2;
+    }
+    lu() {
+        this.Qu.Dn(), this.Hu.forEach((t3) => t3.Xo()), this.pl();
+    }
+    M() {
+        this.Hu.forEach((t3) => t3.M()), this.Hu.length = 0, this.un.localization.priceFormatter = void 0, this.un.localization.timeFormatter = void 0;
+    }
+    Rc() {
+        return this.Gu;
+    }
+    tr() {
+        return this.Gu.F();
+    }
+    Po() {
+        return this.Yu;
+    }
+    Dc(t3, e2) {
+        const i2 = this.Hu[0],
+            s2 = this.Bc(e2, t3, i2);
+        return this.Uu.push(s2), 1 === this.Uu.length ? this.dl() : this.Ch(), s2;
+    }
+    Ac(t3) {
+        const e2 = this.Ke(t3),
+            i2 = this.Uu.indexOf(t3);
+        wl(-1 !== i2, "Series not found"), this.Uu.splice(i2, 1), kl(e2).no(t3), t3.M && t3.M();
+    }
+    cl(t3, e2) {
+        const i2 = kl(this.Ke(t3));
+        i2.no(t3);
+        const s2 = this._c(e2);
+        if (null === s2) {
+            const s3 = t3.Zi();
+            i2.Qa(t3, e2, s3);
+        } else {
+            const n2 = s2.Ht === i2 ? t3.Zi() : void 0;
+            s2.Ht.Qa(t3, e2, n2);
+        }
+    }
+    Cu() {
+        const t3 = et.ns();
+        t3.$n(), this.ec(t3);
+    }
+    Oc(t3) {
+        const e2 = et.ns();
+        e2.qn(t3), this.ec(e2);
+    }
+    Zn() {
+        const t3 = et.ns();
+        t3.Zn(), this.ec(t3);
+    }
+    Kn(t3) {
+        const e2 = et.ns();
+        e2.Kn(t3), this.ec(e2);
+    }
+    Gn(t3) {
+        const e2 = et.ns();
+        e2.Gn(t3), this.ec(e2);
+    }
+    Yn(t3) {
+        const e2 = et.ns();
+        e2.Yn(t3), this.ec(e2);
+    }
+    Hn() {
+        const t3 = et.ns();
+        t3.Hn(), this.ec(t3);
+    }
+    Lc() {
+        return this.un.rightPriceScale.visible ? "right" : "left";
+    }
+    Ic() {
+        return this.sc;
+    }
+    U() {
+        return this.ic;
+    }
+    Lt(t3) {
+        const e2 = this.sc,
+            i2 = this.ic;
+        if (e2 === i2)
+            return e2;
+        if (t3 = Math.max(0, Math.min(100, Math.round(100 * t3))), null === this.Zu || this.Zu.bs !== i2 || this.Zu.gs !== e2)
+            this.Zu = {
+                bs: i2,
+                gs: e2,
+                Ec: /* @__PURE__ */ new Map()
+            };
+        else {
+            const e3 = this.Zu.Ec.get(t3);
+            if (void 0 !== e3)
+                return e3;
+        }
+        const s2 = function(t4, e3, i3) {
+            const [s3, n2, r2, o2] = Al(t4), [a2, l2, h2, c2] = Al(e3), u2 = [El(s3 + i3 * (a2 - s3)), El(n2 + i3 * (l2 - n2)), El(r2 + i3 * (h2 - r2)), Cl(o2 + i3 * (c2 - o2))];
+            return `rgba(${u2[0]}, ${u2[1]}, ${u2[2]}, ${u2[3]})`;
+        }(i2, e2, t3 / 100);
+        return this.Zu.Ec.set(t3, s2), s2;
+    }
+    mc(t3, e2) {
+        const i2 = new et(e2);
+        if (null !== t3) {
+            const s2 = this.Hu.indexOf(t3);
+            i2.Vn(s2, {
+                Nn: e2
+            });
+        }
+        return i2;
+    }
+    rc(t3, e2) {
+        return void 0 === e2 && (e2 = 2), this.mc(this.Ke(t3), e2);
+    }
+    ec(t3) {
+        this.Ku && this.Ku(t3), this.Hu.forEach((t4) => t4.Ko().Th().gt());
+    }
+    Bc(t3, e2, i2) {
+        const s2 = new Pi(this, t3, e2),
+            n2 = void 0 !== t3.priceScaleId ? t3.priceScaleId : this.Lc();
+        return i2.Qa(s2, n2), lh(n2) || s2.kh(t3), s2;
+    }
+    nc(t3) {
+        const e2 = this.un.layout;
+        return "gradient" === e2.background.type ? 0 === t3 ? e2.background.topColor : e2.background.bottomColor : e2.background.color;
+    }
+}
+
+function uc(t3) {
+    return !Fl(t3) && !$l(t3);
+}
+
+function dc(t3) {
+    return Fl(t3);
+}! function(t3) {
+    t3[t3.Disabled = 0] = "Disabled", t3[t3.Continuous = 1] = "Continuous", t3[t3.OnDataUpdate = 2] = "OnDataUpdate";
+}(lc || (lc = {})),
+function(t3) {
+    t3[t3.LastBar = 0] = "LastBar", t3[t3.LastVisible = 1] = "LastVisible";
+}(hc || (hc = {})),
+function(t3) {
+    t3.Solid = "solid", t3.VerticalGradient = "gradient";
+}(cc || (cc = {}));
+const fc = "undefined" != typeof window;
+
+function pc() {
+    return !!fc && window.navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
+}
+
+function mc() {
+    return !!fc && /iPhone|iPad|iPod/.test(window.navigator.platform);
+}
+
+function gc(t3) {
+    return t3 + t3 % 2;
+}
+
+function yc(t3, e2) {
+    return t3.zc - e2.zc;
+}
+
+function vc(t3, e2, i2) {
+    const s2 = (t3.zc - e2.zc) / (t3._t - e2._t);
+    return Math.sign(s2) * Math.min(Math.abs(s2), i2);
+}
+class An {
+    constructor(t3, e2, i2, s2) {
+        this.Vc = null, this.Nc = null, this.Fc = null, this.Wc = null, this.jc = null, this.$c = 0, this.Hc = 0, this.Uc = t3, this.qc = e2, this.Yc = i2, this.es = s2;
+    }
+    Xc(t3, e2) {
+        if (null !== this.Vc) {
+            if (this.Vc._t === e2)
+                return void(this.Vc.zc = t3);
+            if (Math.abs(this.Vc.zc - t3) < this.es)
+                return;
+        }
+        this.Wc = this.Fc, this.Fc = this.Nc, this.Nc = this.Vc, this.Vc = {
+            _t: e2,
+            zc: t3
+        };
+    }
+    pr(t3, e2) {
+        if (null === this.Vc || null === this.Nc)
+            return;
+        if (e2 - this.Vc._t > 50)
+            return;
+        let i2 = 0;
+        const s2 = vc(this.Vc, this.Nc, this.qc),
+            n2 = yc(this.Vc, this.Nc),
+            r2 = [s2],
+            o2 = [n2];
+        if (i2 += n2, null !== this.Fc) {
+            const t4 = vc(this.Nc, this.Fc, this.qc);
+            if (Math.sign(t4) === Math.sign(s2)) {
+                const e3 = yc(this.Nc, this.Fc);
+                if (r2.push(t4), o2.push(e3), i2 += e3, null !== this.Wc) {
+                    const t5 = vc(this.Fc, this.Wc, this.qc);
+                    if (Math.sign(t5) === Math.sign(s2)) {
+                        const e4 = yc(this.Fc, this.Wc);
+                        r2.push(t5), o2.push(e4), i2 += e4;
+                    }
+                }
+            }
+        }
+        let a2 = 0;
+        for (let t4 = 0; t4 < r2.length; ++t4)
+            a2 += o2[t4] / i2 * r2[t4];
+        Math.abs(a2) < this.Uc || (this.jc = {
+            zc: t3,
+            _t: e2
+        }, this.Hc = a2, this.$c = function(t4, e3) {
+            const i3 = Math.log(e3);
+            return Math.log(1 * i3 / -t4) / i3;
+        }(Math.abs(a2), this.Yc));
+    }
+    Mu(t3) {
+        const e2 = kl(this.jc),
+            i2 = t3 - e2._t;
+        return e2.zc + this.Hc * (Math.pow(this.Yc, i2) - 1) / Math.log(this.Yc);
+    }
+    wu(t3) {
+        return null === this.jc || this.Zc(t3) === this.$c;
+    }
+    Zc(t3) {
+        const e2 = t3 - kl(this.jc)._t;
+        return Math.min(e2, this.$c);
+    }
+}
+
+function bc(t3, e2) {
+    const i2 = kl(t3.ownerDocument).createElement("canvas");
+    t3.appendChild(i2);
+    const s2 = function(t4, e3) {
+        if ("device-pixel-content-box" === e3.type)
+            return new dl(t4, e3.transform, e3.options);
+        throw new Error("Unsupported binding target");
+    }(i2, {
+        type: "device-pixel-content-box",
+        options: {
+            allowResizeObserver: false
+        },
+        transform: (t4, e3) => ({
+            width: Math.max(t4.width, e3.width),
+            height: Math.max(t4.height, e3.height)
+        })
+    });
+    return s2.resizeCanvasElement(e2), s2;
+}
+class In {
+    constructor(t3, e2, i2) {
+        this.Kc = 0, this.Gc = null, this.Jc = {
+            st: Number.NEGATIVE_INFINITY,
+            et: Number.POSITIVE_INFINITY
+        }, this.Qc = 0, this.td = null, this.nd = {
+            st: Number.NEGATIVE_INFINITY,
+            et: Number.POSITIVE_INFINITY
+        }, this.sd = null, this.ed = false, this.rd = null, this.hd = null, this.ld = false, this.ad = false, this.od = false, this._d = null, this.ud = null, this.dd = null, this.fd = null, this.pd = null, this.vd = null, this.md = null, this.bd = 0, this.gd = false, this.wd = false, this.Md = false, this.Sd = 0, this.xd = null, this.yd = !mc(), this.kd = (t4) => {
+            this.Cd(t4);
+        }, this.Td = (t4) => {
+            if (this.Pd(t4)) {
+                const e3 = this.Rd(t4);
+                if (++this.Qc, this.td && this.Qc > 1) {
+                    const {
+                        Dd: i3
+                    } = this.Bd(xc(t4), this.nd);
+                    i3 < 30 && !this.od && this.Ad(e3, this.Ld.Od), this.Id();
+                }
+            } else {
+                const e3 = this.Rd(t4);
+                if (++this.Kc, this.Gc && this.Kc > 1) {
+                    const {
+                        Dd: i3
+                    } = this.Bd(xc(t4), this.Jc);
+                    i3 < 5 && !this.ad && this.Ed(e3, this.Ld.zd), this.Vd();
+                }
+            }
+        }, this.Nd = t3, this.Ld = e2, this.un = i2, this.Fd();
+    }
+    M() {
+        null !== this._d && (this._d(), this._d = null), null !== this.ud && (this.ud(), this.ud = null), null !== this.fd && (this.fd(), this.fd = null), null !== this.pd && (this.pd(), this.pd = null), null !== this.vd && (this.vd(), this.vd = null), null !== this.dd && (this.dd(), this.dd = null), this.Wd(), this.Vd();
+    }
+    jd(t3) {
+        this.fd && this.fd();
+        const e2 = this.$d.bind(this);
+        if (this.fd = () => {
+                this.Nd.removeEventListener("mousemove", e2);
+            }, this.Nd.addEventListener("mousemove", e2), this.Pd(t3))
+            return;
+        const i2 = this.Rd(t3);
+        this.Ed(i2, this.Ld.Hd), this.yd = true;
+    }
+    Vd() {
+        null !== this.Gc && clearTimeout(this.Gc), this.Kc = 0, this.Gc = null, this.Jc = {
+            st: Number.NEGATIVE_INFINITY,
+            et: Number.POSITIVE_INFINITY
+        };
+    }
+    Id() {
+        null !== this.td && clearTimeout(this.td), this.Qc = 0, this.td = null, this.nd = {
+            st: Number.NEGATIVE_INFINITY,
+            et: Number.POSITIVE_INFINITY
+        };
+    }
+    $d(t3) {
+        if (this.Md || null !== this.hd)
+            return;
+        if (this.Pd(t3))
+            return;
+        const e2 = this.Rd(t3);
+        this.Ed(e2, this.Ld.Ud), this.yd = true;
+    }
+    qd(t3) {
+        const e2 = Tc(t3.changedTouches, kl(this.xd));
+        if (null === e2)
+            return;
+        if (this.Sd = kc(t3), null !== this.md)
+            return;
+        if (this.wd)
+            return;
+        this.gd = true;
+        const i2 = this.Bd(xc(e2), kl(this.hd)),
+            {
+                Yd: s2,
+                Xd: n2,
+                Dd: r2
+            } = i2;
+        if (this.ld || !(r2 < 5)) {
+            if (!this.ld) {
+                const t4 = 0.5 * s2,
+                    e3 = n2 >= t4 && !this.un.Zd(),
+                    i3 = t4 > n2 && !this.un.Kd();
+                e3 || i3 || (this.wd = true), this.ld = true, this.od = true, this.Wd(), this.Id();
+            }
+            if (!this.wd) {
+                const i3 = this.Rd(t3, e2);
+                this.Ad(i3, this.Ld.Gd), wc(t3);
+            }
+        }
+    }
+    Jd(t3) {
+        if (0 !== t3.button)
+            return;
+        const e2 = this.Bd(xc(t3), kl(this.rd)),
+            {
+                Dd: i2
+            } = e2;
+        if (i2 >= 5 && (this.ad = true, this.Vd()), this.ad) {
+            const e3 = this.Rd(t3);
+            this.Ed(e3, this.Ld.Qd);
+        }
+    }
+    Bd(t3, e2) {
+        const i2 = Math.abs(e2.st - t3.st),
+            s2 = Math.abs(e2.et - t3.et);
+        return {
+            Yd: i2,
+            Xd: s2,
+            Dd: i2 + s2
+        };
+    }
+    tf(t3) {
+        let e2 = Tc(t3.changedTouches, kl(this.xd));
+        if (null === e2 && 0 === t3.touches.length && (e2 = t3.changedTouches[0]), null === e2)
+            return;
+        this.xd = null, this.Sd = kc(t3), this.Wd(), this.hd = null, this.vd && (this.vd(), this.vd = null);
+        const i2 = this.Rd(t3, e2);
+        if (this.Ad(i2, this.Ld.if), ++this.Qc, this.td && this.Qc > 1) {
+            const {
+                Dd: t4
+            } = this.Bd(xc(e2), this.nd);
+            t4 < 30 && !this.od && this.Ad(i2, this.Ld.Od), this.Id();
+        } else
+            this.od || (this.Ad(i2, this.Ld.nf), this.Ld.nf && wc(t3));
+        0 === this.Qc && wc(t3), 0 === t3.touches.length && this.ed && (this.ed = false, wc(t3));
+    }
+    Cd(t3) {
+        if (0 !== t3.button)
+            return;
+        const e2 = this.Rd(t3);
+        if (this.rd = null, this.Md = false, this.pd && (this.pd(), this.pd = null), pc() && this.Nd.ownerDocument.documentElement.removeEventListener("mouseleave", this.kd), !this.Pd(t3))
+            if (this.Ed(e2, this.Ld.sf), ++this.Kc, this.Gc && this.Kc > 1) {
+                const {
+                    Dd: i2
+                } = this.Bd(xc(t3), this.Jc);
+                i2 < 5 && !this.ad && this.Ed(e2, this.Ld.zd), this.Vd();
+            } else
+                this.ad || this.Ed(e2, this.Ld.ef);
+    }
+    Wd() {
+        null !== this.sd && (clearTimeout(this.sd), this.sd = null);
+    }
+    rf(t3) {
+        if (null !== this.xd)
+            return;
+        const e2 = t3.changedTouches[0];
+        this.xd = e2.identifier, this.Sd = kc(t3);
+        const i2 = this.Nd.ownerDocument.documentElement;
+        this.od = false, this.ld = false, this.wd = false, this.hd = xc(e2), this.vd && (this.vd(), this.vd = null);
+        {
+            const e3 = this.qd.bind(this),
+                s3 = this.tf.bind(this);
+            this.vd = () => {
+                i2.removeEventListener("touchmove", e3), i2.removeEventListener("touchend", s3);
+            }, i2.addEventListener("touchmove", e3, {
+                passive: false
+            }), i2.addEventListener("touchend", s3, {
+                passive: false
+            }), this.Wd(), this.sd = setTimeout(this.hf.bind(this, t3), 240);
+        }
+        const s2 = this.Rd(t3, e2);
+        this.Ad(s2, this.Ld.lf), this.td || (this.Qc = 0, this.td = setTimeout(this.Id.bind(this), 500), this.nd = xc(e2));
+    }
+    af(t3) {
+        if (0 !== t3.button)
+            return;
+        const e2 = this.Nd.ownerDocument.documentElement;
+        pc() && e2.addEventListener("mouseleave", this.kd), this.ad = false, this.rd = xc(t3), this.pd && (this.pd(), this.pd = null);
+        {
+            const t4 = this.Jd.bind(this),
+                i3 = this.Cd.bind(this);
+            this.pd = () => {
+                e2.removeEventListener("mousemove", t4), e2.removeEventListener("mouseup", i3);
+            }, e2.addEventListener("mousemove", t4), e2.addEventListener("mouseup", i3);
+        }
+        if (this.Md = true, this.Pd(t3))
+            return;
+        const i2 = this.Rd(t3);
+        this.Ed(i2, this.Ld._f), this.Gc || (this.Kc = 0, this.Gc = setTimeout(this.Vd.bind(this), 500), this.Jc = xc(t3));
+    }
+    Fd() {
+        this.Nd.addEventListener("mouseenter", this.jd.bind(this)), this.Nd.addEventListener("touchcancel", this.Wd.bind(this));
+        {
+            const t3 = this.Nd.ownerDocument,
+                e2 = (t4) => {
+                    this.Ld.uf && (t4.composed && this.Nd.contains(t4.composedPath()[0]) || t4.target && this.Nd.contains(t4.target) || this.Ld.uf());
+                };
+            this.ud = () => {
+                t3.removeEventListener("touchstart", e2);
+            }, this._d = () => {
+                t3.removeEventListener("mousedown", e2);
+            }, t3.addEventListener("mousedown", e2), t3.addEventListener("touchstart", e2, {
+                passive: true
+            });
+        }
+        mc() && (this.dd = () => {
+                this.Nd.removeEventListener("dblclick", this.Td);
+            }, this.Nd.addEventListener("dblclick", this.Td)), this.Nd.addEventListener("mouseleave", this.cf.bind(this)), this.Nd.addEventListener("touchstart", this.rf.bind(this), {
+                passive: true
+            }),
+            function(t3) {
+                fc && void 0 !== window.chrome && t3.addEventListener("mousedown", (t4) => {
+                    if (1 === t4.button)
+                        return t4.preventDefault(), false;
+                });
+            }(this.Nd), this.Nd.addEventListener("mousedown", this.af.bind(this)), this.df(), this.Nd.addEventListener("touchmove", () => {}, {
+                passive: false
+            });
+    }
+    df() {
+        void 0 === this.Ld.ff && void 0 === this.Ld.pf && void 0 === this.Ld.vf || (this.Nd.addEventListener("touchstart", (t3) => this.mf(t3.touches), {
+            passive: true
+        }), this.Nd.addEventListener("touchmove", (t3) => {
+            if (2 === t3.touches.length && null !== this.md && void 0 !== this.Ld.pf) {
+                const e2 = _c(t3.touches[0], t3.touches[1]) / this.bd;
+                this.Ld.pf(this.md, e2), wc(t3);
+            }
+        }, {
+            passive: false
+        }), this.Nd.addEventListener("touchend", (t3) => {
+            this.mf(t3.touches);
+        }));
+    }
+    mf(t3) {
+        1 === t3.length && (this.gd = false), 2 !== t3.length || this.gd || this.ed ? this.bf() : this.gf(t3);
+    }
+    gf(t3) {
+        const e2 = this.Nd.getBoundingClientRect() || {
+            left: 0,
+            top: 0
+        };
+        this.md = {
+            st: (t3[0].clientX - e2.left + (t3[1].clientX - e2.left)) / 2,
+            et: (t3[0].clientY - e2.top + (t3[1].clientY - e2.top)) / 2
+        }, this.bd = _c(t3[0], t3[1]), void 0 !== this.Ld.ff && this.Ld.ff(), this.Wd();
+    }
+    bf() {
+        null !== this.md && (this.md = null, void 0 !== this.Ld.vf && this.Ld.vf());
+    }
+    cf(t3) {
+        if (this.fd && this.fd(), this.Pd(t3))
+            return;
+        if (!this.yd)
+            return;
+        const e2 = this.Rd(t3);
+        this.Ed(e2, this.Ld.wf), this.yd = !mc();
+    }
+    hf(t3) {
+        const e2 = Tc(t3.touches, kl(this.xd));
+        if (null === e2)
+            return;
+        const i2 = this.Rd(t3, e2);
+        this.Ad(i2, this.Ld.Mf), this.od = true, this.ed = true;
+    }
+    Pd(t3) {
+        return t3.sourceCapabilities && void 0 !== t3.sourceCapabilities.firesTouchEvents ? t3.sourceCapabilities.firesTouchEvents : kc(t3) < this.Sd + 500;
+    }
+    Ad(t3, e2) {
+        e2 && e2.call(this.Ld, t3);
+    }
+    Ed(t3, e2) {
+        e2 && e2.call(this.Ld, t3);
+    }
+    Rd(t3, e2) {
+        const i2 = e2 || t3,
+            s2 = this.Nd.getBoundingClientRect() || {
+                left: 0,
+                top: 0
+            };
+        return {
+            clientX: i2.clientX,
+            clientY: i2.clientY,
+            pageX: i2.pageX,
+            pageY: i2.pageY,
+            screenX: i2.screenX,
+            screenY: i2.screenY,
+            localX: i2.clientX - s2.left,
+            localY: i2.clientY - s2.top,
+            ctrlKey: t3.ctrlKey,
+            altKey: t3.altKey,
+            shiftKey: t3.shiftKey,
+            metaKey: t3.metaKey,
+            Sf: !t3.type.startsWith("mouse") && "contextmenu" !== t3.type && "click" !== t3.type,
+            xf: t3.type,
+            yf: i2.target,
+            kf: t3.view,
+            Cf: () => {
+                "touchstart" !== t3.type && wc(t3);
+            }
+        };
+    }
+}
+
+function _c(t3, e2) {
+    const i2 = t3.clientX - e2.clientX,
+        s2 = t3.clientY - e2.clientY;
+    return Math.sqrt(i2 * i2 + s2 * s2);
+}
+
+function wc(t3) {
+    t3.cancelable && t3.preventDefault();
+}
+
+function xc(t3) {
+    return {
+        st: t3.pageX,
+        et: t3.pageY
+    };
+}
+
+function kc(t3) {
+    return t3.timeStamp || performance.now();
+}
+
+function Tc(t3, e2) {
+    for (let i2 = 0; i2 < t3.length; ++i2)
+        if (t3[i2].identifier === e2)
+            return t3[i2];
+    return null;
+}
+class Wn {
+    constructor(t3, e2, i2, s2) {
+        this.zi = null, this.Tf = null, this.Pf = false, this.Rf = new Ut(200), this.zr = null, this.Df = 0, this.Bf = false, this.Af = () => {
+            this.Bf || this.tn.Of().Ut().Ch();
+        }, this.Lf = () => {
+            this.Bf || this.tn.Of().Ut().Ch();
+        }, this.tn = t3, this.un = e2, this.Ba = e2.layout, this.Gu = i2, this.If = "left" === s2, this.Ef = document.createElement("div"), this.Ef.style.height = "100%", this.Ef.style.overflow = "hidden", this.Ef.style.width = "25px", this.Ef.style.left = "0", this.Ef.style.position = "relative", this.zf = bc(this.Ef, hl({
+            width: 16,
+            height: 16
+        })), this.zf.subscribeSuggestedBitmapSizeChanged(this.Af);
+        const n2 = this.zf.canvasElement;
+        n2.style.position = "absolute", n2.style.zIndex = "1", n2.style.left = "0", n2.style.top = "0", this.Vf = bc(this.Ef, hl({
+            width: 16,
+            height: 16
+        })), this.Vf.subscribeSuggestedBitmapSizeChanged(this.Lf);
+        const r2 = this.Vf.canvasElement;
+        r2.style.position = "absolute", r2.style.zIndex = "2", r2.style.left = "0", r2.style.top = "0";
+        const o2 = {
+            _f: this.Nf.bind(this),
+            lf: this.Nf.bind(this),
+            Qd: this.Ff.bind(this),
+            Gd: this.Ff.bind(this),
+            uf: this.Wf.bind(this),
+            sf: this.jf.bind(this),
+            if: this.jf.bind(this),
+            zd: this.$f.bind(this),
+            Od: this.$f.bind(this),
+            Hd: this.Hf.bind(this),
+            wf: this.Uf.bind(this)
+        };
+        this.qf = new In(this.Vf.canvasElement, o2, {
+            Zd: () => false,
+            Kd: () => true
+        });
+    }
+    M() {
+        this.qf.M(), this.Vf.unsubscribeSuggestedBitmapSizeChanged(this.Lf), this.Vf.dispose(), this.zf.unsubscribeSuggestedBitmapSizeChanged(this.Af), this.zf.dispose(), null !== this.zi && this.zi.eo().v(this), this.zi = null;
+    }
+    Yf() {
+        return this.Ef;
+    }
+    T() {
+        return this.Ba.fontSize;
+    }
+    Xf() {
+        const t3 = this.Gu.F();
+        return this.zr !== t3.P && (this.Rf.Fe(), this.zr = t3.P), t3;
+    }
+    Zf() {
+        if (null === this.zi)
+            return 0;
+        let t3 = 0;
+        const e2 = this.Xf(),
+            i2 = kl(this.zf.canvasElement.getContext("2d"));
+        i2.save();
+        const s2 = this.zi.Jl();
+        i2.font = this.Kf(), s2.length > 0 && (t3 = Math.max(this.Rf.Si(i2, s2[0].ua), this.Rf.Si(i2, s2[s2.length - 1].ua)));
+        const n2 = this.Gf();
+        for (let e3 = n2.length; e3--;) {
+            const s3 = this.Rf.Si(i2, n2[e3].Gt());
+            s3 > t3 && (t3 = s3);
+        }
+        const r2 = this.zi.Tt();
+        if (null !== r2 && null !== this.Tf) {
+            const e3 = this.zi.pn(1, r2),
+                s3 = this.zi.pn(this.Tf.height - 2, r2);
+            t3 = Math.max(t3, this.Rf.Si(i2, this.zi.Fi(Math.floor(Math.min(e3, s3)) + 0.11111111111111, r2)), this.Rf.Si(i2, this.zi.Fi(Math.ceil(Math.max(e3, s3)) - 0.11111111111111, r2)));
+        }
+        i2.restore();
+        const o2 = t3 || 34;
+        return gc(Math.ceil(e2.k + e2.C + e2.O + e2.L + 5 + o2));
+    }
+    Jf(t3) {
+        null !== this.Tf && cl(this.Tf, t3) || (this.Tf = t3, this.Bf = true, this.zf.resizeCanvasElement(t3), this.Vf.resizeCanvasElement(t3), this.Bf = false, this.Ef.style.width = `${t3.width}px`, this.Ef.style.height = `${t3.height}px`);
+    }
+    Qf() {
+        return kl(this.Tf).width;
+    }
+    Gi(t3) {
+        this.zi !== t3 && (null !== this.zi && this.zi.eo().v(this), this.zi = t3, t3.eo().l(this.Sa.bind(this), this));
+    }
+    Bt() {
+        return this.zi;
+    }
+    Fe() {
+        const t3 = this.tn.tp();
+        this.tn.Of().Ut().qo(t3, kl(this.Bt()));
+    }
+    ip(t3) {
+        if (null === this.Tf)
+            return;
+        if (1 !== t3) {
+            this.np(), this.zf.applySuggestedBitmapSize();
+            const t4 = vl(this.zf);
+            null !== t4 && (t4.useBitmapCoordinateSpace((t5) => {
+                this.sp(t5), this.ye(t5);
+            }), this.ep(t4), this.rp(t4));
+        }
+        this.Vf.applySuggestedBitmapSize();
+        const e2 = vl(this.Vf);
+        null !== e2 && (e2.useBitmapCoordinateSpace(({
+            context: t4,
+            bitmapSize: e3
+        }) => {
+            t4.clearRect(0, 0, e3.width, e3.height);
+        }), this.hp(e2));
+    }
+    lp() {
+        return this.zf.bitmapSize;
+    }
+    ap(t3, e2, i2) {
+        const s2 = this.lp();
+        s2.width > 0 && s2.height > 0 && t3.drawImage(this.zf.canvasElement, e2, i2);
+    }
+    gt() {
+        var t3;
+        null === (t3 = this.zi) || void 0 === t3 || t3.Jl();
+    }
+    Nf(t3) {
+        if (null === this.zi || this.zi.Ni() || !this.un.handleScale.axisPressedMouseMove.price)
+            return;
+        const e2 = this.tn.Of().Ut(),
+            i2 = this.tn.tp();
+        this.Pf = true, e2.No(i2, this.zi, t3.localY);
+    }
+    Ff(t3) {
+        if (null === this.zi || !this.un.handleScale.axisPressedMouseMove.price)
+            return;
+        const e2 = this.tn.Of().Ut(),
+            i2 = this.tn.tp(),
+            s2 = this.zi;
+        e2.Fo(i2, s2, t3.localY);
+    }
+    Wf() {
+        if (null === this.zi || !this.un.handleScale.axisPressedMouseMove.price)
+            return;
+        const t3 = this.tn.Of().Ut(),
+            e2 = this.tn.tp(),
+            i2 = this.zi;
+        this.Pf && (this.Pf = false, t3.Wo(e2, i2));
+    }
+    jf(t3) {
+        if (null === this.zi || !this.un.handleScale.axisPressedMouseMove.price)
+            return;
+        const e2 = this.tn.Of().Ut(),
+            i2 = this.tn.tp();
+        this.Pf = false, e2.Wo(i2, this.zi);
+    }
+    $f(t3) {
+        this.un.handleScale.axisDoubleClickReset.price && this.Fe();
+    }
+    Hf(t3) {
+        null !== this.zi && (!this.tn.Of().Ut().F().handleScale.axisPressedMouseMove.price || this.zi.th() || this.zi.Na() || this.op(1));
+    }
+    Uf(t3) {
+        this.op(0);
+    }
+    Gf() {
+        const t3 = [],
+            e2 = null === this.zi ? void 0 : this.zi;
+        return ((i2) => {
+            for (let s2 = 0; s2 < i2.length; ++s2) {
+                const n2 = i2[s2].Pn(this.tn.tp(), e2);
+                for (let e3 = 0; e3 < n2.length; e3++)
+                    t3.push(n2[e3]);
+            }
+        })(this.tn.tp().Ja()), t3;
+    }
+    sp({
+        context: t3,
+        bitmapSize: e2
+    }) {
+        const {
+            width: i2,
+            height: s2
+        } = e2, n2 = this.tn.tp().Ut(), r2 = n2.U(), o2 = n2.Ic();
+        r2 === o2 ? Jl(t3, 0, 0, i2, s2, r2) : ih(t3, 0, 0, i2, s2, r2, o2);
+    }
+    ye({
+        context: t3,
+        bitmapSize: e2,
+        horizontalPixelRatio: i2
+    }) {
+        if (null === this.Tf || null === this.zi || !this.zi.F().borderVisible)
+            return;
+        t3.fillStyle = this.zi.F().borderColor;
+        const s2 = Math.max(1, Math.floor(this.Xf().k * i2));
+        let n2;
+        n2 = this.If ? e2.width - s2 : 0, t3.fillRect(n2, 0, s2, e2.height);
+    }
+    ep(t3) {
+        if (null === this.Tf || null === this.zi)
+            return;
+        const e2 = this.zi.Jl(),
+            i2 = this.zi.F(),
+            s2 = this.Xf(),
+            n2 = this.If ? this.Tf.width - s2.C : 0;
+        i2.borderVisible && i2.ticksVisible && t3.useBitmapCoordinateSpace(({
+            context: t4,
+            horizontalPixelRatio: r2,
+            verticalPixelRatio: o2
+        }) => {
+            t4.fillStyle = i2.borderColor;
+            const a2 = Math.max(1, Math.floor(o2)),
+                l2 = Math.floor(0.5 * o2),
+                h2 = Math.round(s2.C * r2);
+            t4.beginPath();
+            for (const i3 of e2)
+                t4.rect(Math.floor(n2 * r2), Math.round(i3.Yl * o2) - l2, h2, a2);
+            t4.fill();
+        }), t3.useMediaCoordinateSpace(({
+            context: t4
+        }) => {
+            var r2;
+            t4.font = this.Kf(), t4.fillStyle = null !== (r2 = i2.textColor) && void 0 !== r2 ? r2 : this.Ba.textColor, t4.textAlign = this.If ? "right" : "left", t4.textBaseline = "middle";
+            const o2 = this.If ? Math.round(n2 - s2.O) : Math.round(n2 + s2.C + s2.O),
+                a2 = e2.map((e3) => this.Rf.Mi(t4, e3.ua));
+            for (let i3 = e2.length; i3--;) {
+                const s3 = e2[i3];
+                t4.fillText(s3.ua, o2, s3.Yl + a2[i3]);
+            }
+        });
+    }
+    np() {
+        if (null === this.Tf || null === this.zi)
+            return;
+        let t3 = this.Tf.height / 2;
+        const e2 = [],
+            i2 = this.zi.Ja().slice(),
+            s2 = this.tn.tp(),
+            n2 = this.Xf();
+        this.zi === s2.Je() && this.tn.tp().Ja().forEach((t4) => {
+            s2.Ge(t4) && i2.push(t4);
+        });
+        const r2 = this.zi.jl()[0],
+            o2 = this.zi;
+        i2.forEach((i3) => {
+            const n3 = i3.Pn(s2, o2);
+            n3.forEach((t4) => {
+                t4.Ai(null), t4.Oi() && e2.push(t4);
+            }), r2 === i3 && n3.length > 0 && (t3 = n3[0].yi());
+        }), e2.forEach((t4) => t4.Ai(t4.yi())), this.zi.F().alignLabels && this._p(e2, n2, t3);
+    }
+    _p(t3, e2, i2) {
+        if (null === this.Tf)
+            return;
+        const s2 = t3.filter((t4) => t4.yi() <= i2),
+            n2 = t3.filter((t4) => t4.yi() > i2);
+        s2.sort((t4, e3) => e3.yi() - t4.yi()), s2.length && n2.length && n2.push(s2[0]), n2.sort((t4, e3) => t4.yi() - e3.yi());
+        for (const i3 of t3) {
+            const t4 = Math.floor(i3.It(e2) / 2),
+                s3 = i3.yi();
+            s3 > -t4 && s3 < t4 && i3.Ai(t4), s3 > this.Tf.height - t4 && s3 < this.Tf.height + t4 && i3.Ai(this.Tf.height - t4);
+        }
+        for (let t4 = 1; t4 < s2.length; t4++) {
+            const i3 = s2[t4],
+                n3 = s2[t4 - 1],
+                r2 = n3.It(e2, false),
+                o2 = i3.yi(),
+                a2 = n3.Bi();
+            o2 > a2 - r2 && i3.Ai(a2 - r2);
+        }
+        for (let t4 = 1; t4 < n2.length; t4++) {
+            const i3 = n2[t4],
+                s3 = n2[t4 - 1],
+                r2 = s3.It(e2, true),
+                o2 = i3.yi(),
+                a2 = s3.Bi();
+            o2 < a2 + r2 && i3.Ai(a2 + r2);
+        }
+    }
+    rp(t3) {
+        if (null === this.Tf)
+            return;
+        const e2 = this.Gf(),
+            i2 = this.Xf(),
+            s2 = this.If ? "right" : "left";
+        e2.forEach((e3) => {
+            e3.Li() && e3.Mt(kl(this.zi)).X(t3, i2, this.Rf, s2);
+        });
+    }
+    hp(t3) {
+        if (null === this.Tf || null === this.zi)
+            return;
+        const e2 = this.tn.Of().Ut(),
+            i2 = [],
+            s2 = this.tn.tp(),
+            n2 = e2.dc().Pn(s2, this.zi);
+        n2.length && i2.push(n2);
+        const r2 = this.Xf(),
+            o2 = this.If ? "right" : "left";
+        i2.forEach((e3) => {
+            e3.forEach((e4) => {
+                e4.Mt(kl(this.zi)).X(t3, r2, this.Rf, o2);
+            });
+        });
+    }
+    op(t3) {
+        this.Ef.style.cursor = 1 === t3 ? "ns-resize" : "default";
+    }
+    Sa() {
+        const t3 = this.Zf();
+        this.Df < t3 && this.tn.Of().Ut().dl(), this.Df = t3;
+    }
+    Kf() {
+        return Hl(this.Ba.fontSize, this.Ba.fontFamily);
+    }
+}
+
+function Sc(t3, e2, i2, s2) {
+    t3.K && t3.K(e2, i2, s2);
+}
+
+function Ec(t3, e2, i2, s2) {
+    t3.X(e2, i2, s2);
+}
+
+function Cc(t3, e2) {
+    return t3.Tn(e2);
+}
+
+function Ic(t3, e2) {
+    return t3.Ji(e2);
+}
+
+function Mc(t3, e2) {
+    return void 0 !== t3.kl ? t3.kl(e2) : [];
+}
+class Yn {
+    constructor(t3, e2) {
+        this.Tf = hl({
+            width: 0,
+            height: 0
+        }), this.up = null, this.cp = null, this.dp = null, this.fp = false, this.pp = new Ll(), this.vp = 0, this.mp = false, this.bp = null, this.gp = false, this.wp = null, this.Mp = null, this.Bf = false, this.Af = () => {
+            this.Bf || null === this.Sp || this.Hi().Ch();
+        }, this.Lf = () => {
+            this.Bf || null === this.Sp || this.Hi().Ch();
+        }, this.xp = t3, this.Sp = e2, this.Sp.Zo().l(this.yp.bind(this), this, true), this.kp = document.createElement("td"), this.kp.style.padding = "0", this.kp.style.position = "relative";
+        const i2 = document.createElement("div");
+        i2.style.width = "100%", i2.style.height = "100%", i2.style.position = "relative", i2.style.overflow = "hidden", this.Cp = document.createElement("td"), this.Cp.style.padding = "0", this.Tp = document.createElement("td"), this.Tp.style.padding = "0", this.kp.appendChild(i2), this.zf = bc(i2, hl({
+            width: 16,
+            height: 16
+        })), this.zf.subscribeSuggestedBitmapSizeChanged(this.Af);
+        const s2 = this.zf.canvasElement;
+        s2.style.position = "absolute", s2.style.zIndex = "1", s2.style.left = "0", s2.style.top = "0", this.Vf = bc(i2, hl({
+            width: 16,
+            height: 16
+        })), this.Vf.subscribeSuggestedBitmapSizeChanged(this.Lf);
+        const n2 = this.Vf.canvasElement;
+        n2.style.position = "absolute", n2.style.zIndex = "2", n2.style.left = "0", n2.style.top = "0", this.Pp = document.createElement("tr"), this.Pp.appendChild(this.Cp), this.Pp.appendChild(this.kp), this.Pp.appendChild(this.Tp), this.Rp(), this.qf = new In(this.Vf.canvasElement, this, {
+            Zd: () => null === this.bp && !this.xp.F().handleScroll.vertTouchDrag,
+            Kd: () => null === this.bp && !this.xp.F().handleScroll.horzTouchDrag
+        });
+    }
+    M() {
+        null !== this.up && this.up.M(), null !== this.cp && this.cp.M(), this.Vf.unsubscribeSuggestedBitmapSizeChanged(this.Lf), this.Vf.dispose(), this.zf.unsubscribeSuggestedBitmapSizeChanged(this.Af), this.zf.dispose(), null !== this.Sp && this.Sp.Zo().v(this), this.qf.M();
+    }
+    tp() {
+        return kl(this.Sp);
+    }
+    Dp(t3) {
+        null !== this.Sp && this.Sp.Zo().v(this), this.Sp = t3, null !== this.Sp && this.Sp.Zo().l(Yn.prototype.yp.bind(this), this, true), this.Rp();
+    }
+    Of() {
+        return this.xp;
+    }
+    Yf() {
+        return this.Pp;
+    }
+    Rp() {
+        if (null !== this.Sp && (this.Bp(), 0 !== this.Hi().wt().length)) {
+            if (null !== this.up) {
+                const t3 = this.Sp.zo();
+                this.up.Gi(kl(t3));
+            }
+            if (null !== this.cp) {
+                const t3 = this.Sp.Vo();
+                this.cp.Gi(kl(t3));
+            }
+        }
+    }
+    Ap() {
+        null !== this.up && this.up.gt(), null !== this.cp && this.cp.gt();
+    }
+    Ro() {
+        return null !== this.Sp ? this.Sp.Ro() : 0;
+    }
+    Do(t3) {
+        this.Sp && this.Sp.Do(t3);
+    }
+    Hd(t3) {
+        if (!this.Sp)
+            return;
+        this.Op();
+        const e2 = t3.localX,
+            i2 = t3.localY;
+        this.Lp(e2, i2, t3);
+    }
+    _f(t3) {
+        this.Op(), this.Ip(), this.Lp(t3.localX, t3.localY, t3);
+    }
+    Ud(t3) {
+        if (!this.Sp)
+            return;
+        this.Op();
+        const e2 = t3.localX,
+            i2 = t3.localY;
+        this.Lp(e2, i2, t3);
+        const s2 = this.ir(e2, i2);
+        this.Hi().lc(s2 && {
+            ac: s2.ac,
+            Ep: s2.Ep
+        });
+    }
+    ef(t3) {
+        null !== this.Sp && (this.Op(), this.zp(t3));
+    }
+    Qd(t3) {
+        this.Op(), this.Vp(t3), this.Lp(t3.localX, t3.localY, t3);
+    }
+    sf(t3) {
+        null !== this.Sp && (this.Op(), this.mp = false, this.Np(t3));
+    }
+    nf(t3) {
+        null !== this.Sp && this.zp(t3);
+    }
+    Mf(t3) {
+        if (this.mp = true, null === this.bp) {
+            const e2 = {
+                x: t3.localX,
+                y: t3.localY
+            };
+            this.Fp(e2, e2, t3);
+        }
+    }
+    wf(t3) {
+        null !== this.Sp && (this.Op(), this.Sp.Ut().lc(null), this.Wp());
+    }
+    jp() {
+        return this.pp;
+    }
+    ff() {
+        this.vp = 1, this.Hi().Hn();
+    }
+    pf(t3, e2) {
+        if (!this.xp.F().handleScale.pinch)
+            return;
+        const i2 = 5 * (e2 - this.vp);
+        this.vp = e2, this.Hi().gc(t3.st, i2);
+    }
+    lf(t3) {
+        if (this.mp = false, this.gp = null !== this.bp, this.Ip(), null !== this.bp) {
+            const e2 = this.Hi().dc();
+            this.wp = {
+                x: e2.Xt(),
+                y: e2.Zt()
+            }, this.bp = {
+                x: t3.localX,
+                y: t3.localY
+            };
+        }
+    }
+    Gd(t3) {
+        if (null === this.Sp)
+            return;
+        const e2 = t3.localX,
+            i2 = t3.localY;
+        if (null === this.bp)
+            this.Vp(t3);
+        else {
+            this.gp = false;
+            const s2 = kl(this.wp),
+                n2 = s2.x + (e2 - this.bp.x),
+                r2 = s2.y + (i2 - this.bp.y);
+            this.Lp(n2, r2, t3);
+        }
+    }
+    if (t3) {
+        0 === this.Of().F().trackingMode.exitMode && (this.gp = true), this.$p(), this.Np(t3);
+    }
+    ir(t3, e2) {
+        const i2 = this.Sp;
+        if (null === i2)
+            return null;
+        const s2 = i2.Ja();
+        for (const n2 of s2) {
+            const s3 = this.Hp(n2.Tn(i2), t3, e2);
+            if (null !== s3)
+                return {
+                    ac: n2,
+                    kf: s3.kf,
+                    Ep: s3.Ep
+                };
+        }
+        return null;
+    }
+    Up(t3, e2) {
+        kl("left" === e2 ? this.up : this.cp).Jf(hl({
+            width: t3,
+            height: this.Tf.height
+        }));
+    }
+    qp() {
+        return this.Tf;
+    }
+    Jf(t3) {
+        cl(this.Tf, t3) || (this.Tf = t3, this.Bf = true, this.zf.resizeCanvasElement(t3), this.Vf.resizeCanvasElement(t3), this.Bf = false, this.kp.style.width = t3.width + "px", this.kp.style.height = t3.height + "px");
+    }
+    Yp() {
+        const t3 = kl(this.Sp);
+        t3.Eo(t3.zo()), t3.Eo(t3.Vo());
+        for (const e2 of t3.jl())
+            if (t3.Ge(e2)) {
+                const i2 = e2.Bt();
+                null !== i2 && t3.Eo(i2), e2.Dn();
+            }
+    }
+    lp() {
+        return this.zf.bitmapSize;
+    }
+    ap(t3, e2, i2) {
+        const s2 = this.lp();
+        s2.width > 0 && s2.height > 0 && t3.drawImage(this.zf.canvasElement, e2, i2);
+    }
+    ip(t3) {
+        if (0 === t3)
+            return;
+        if (null === this.Sp)
+            return;
+        if (t3 > 1 && this.Yp(), null !== this.up && this.up.ip(t3), null !== this.cp && this.cp.ip(t3), 1 !== t3) {
+            this.zf.applySuggestedBitmapSize();
+            const t4 = vl(this.zf);
+            null !== t4 && (t4.useBitmapCoordinateSpace((t5) => {
+                this.sp(t5);
+            }), this.Sp && (this.Xp(t4), this.Zp(t4), this.Kp(t4, Cc), this.Kp(t4, Ic)));
+        }
+        this.Vf.applySuggestedBitmapSize();
+        const e2 = vl(this.Vf);
+        null !== e2 && (e2.useBitmapCoordinateSpace(({
+            context: t4,
+            bitmapSize: e3
+        }) => {
+            t4.clearRect(0, 0, e3.width, e3.height);
+        }), this.Kp(e2, Mc), this.Gp(e2));
+    }
+    Jp() {
+        return this.up;
+    }
+    Qp() {
+        return this.cp;
+    }
+    yp() {
+        null !== this.Sp && this.Sp.Zo().v(this), this.Sp = null;
+    }
+    zp(t3) {
+        const e2 = t3.localX,
+            i2 = t3.localY;
+        this.pp.g() && this.pp.m(this.Hi().yt().ru(e2), {
+            x: e2,
+            y: i2
+        }, t3);
+    }
+    sp({
+        context: t3,
+        bitmapSize: e2
+    }) {
+        const {
+            width: i2,
+            height: s2
+        } = e2, n2 = this.Hi(), r2 = n2.U(), o2 = n2.Ic();
+        r2 === o2 ? Jl(t3, 0, 0, i2, s2, o2) : ih(t3, 0, 0, i2, s2, r2, o2);
+    }
+    Xp(t3) {
+        const e2 = kl(this.Sp).Ko().Th().Mt();
+        null !== e2 && e2.X(t3, false);
+    }
+    Zp(t3) {
+        const e2 = this.Hi().cc();
+        this.tv(t3, Cc, Sc, e2), this.tv(t3, Cc, Ec, e2);
+    }
+    Gp(t3) {
+        this.tv(t3, Cc, Ec, this.Hi().dc());
+    }
+    Kp(t3, e2) {
+        const i2 = kl(this.Sp).Ja();
+        for (const s2 of i2)
+            this.tv(t3, e2, Sc, s2);
+        for (const s2 of i2)
+            this.tv(t3, e2, Ec, s2);
+    }
+    tv(t3, e2, i2, s2) {
+        const n2 = kl(this.Sp),
+            r2 = e2(s2, n2),
+            o2 = n2.Ut().hc(),
+            a2 = null !== o2 && o2.ac === s2,
+            l2 = null !== o2 && a2 && void 0 !== o2.Ep ? o2.Ep.sr : void 0;
+        for (const e3 of r2) {
+            const s3 = e3.Mt();
+            null !== s3 && i2(s3, t3, a2, l2);
+        }
+    }
+    Hp(t3, e2, i2) {
+        for (const s2 of t3) {
+            const t4 = s2.Mt();
+            if (null !== t4 && t4.ir) {
+                const n2 = t4.ir(e2, i2);
+                if (null !== n2)
+                    return {
+                        kf: s2,
+                        Ep: n2
+                    };
+            }
+        }
+        return null;
+    }
+    Bp() {
+        if (null === this.Sp)
+            return;
+        const t3 = this.xp,
+            e2 = this.Sp.zo().F().visible,
+            i2 = this.Sp.Vo().F().visible;
+        e2 || null === this.up || (this.Cp.removeChild(this.up.Yf()), this.up.M(), this.up = null), i2 || null === this.cp || (this.Tp.removeChild(this.cp.Yf()), this.cp.M(), this.cp = null);
+        const s2 = t3.Ut().Rc();
+        e2 && null === this.up && (this.up = new Wn(this, t3.F(), s2, "left"), this.Cp.appendChild(this.up.Yf())), i2 && null === this.cp && (this.cp = new Wn(this, t3.F(), s2, "right"), this.Tp.appendChild(this.cp.Yf()));
+    }
+    iv(t3) {
+        return t3.Sf && this.mp || null !== this.bp;
+    }
+    nv(t3) {
+        return Math.max(0, Math.min(t3, this.Tf.width - 1));
+    }
+    sv(t3) {
+        return Math.max(0, Math.min(t3, this.Tf.height - 1));
+    }
+    Lp(t3, e2, i2) {
+        this.Hi().Cc(this.nv(t3), this.sv(e2), i2, kl(this.Sp));
+    }
+    Wp() {
+        this.Hi().Tc();
+    }
+    $p() {
+        this.gp && (this.bp = null, this.Wp());
+    }
+    Fp(t3, e2, i2) {
+        this.bp = t3, this.gp = false, this.Lp(e2.x, e2.y, i2);
+        const s2 = this.Hi().dc();
+        this.wp = {
+            x: s2.Xt(),
+            y: s2.Zt()
+        };
+    }
+    Hi() {
+        return this.xp.Ut();
+    }
+    Np(t3) {
+        if (!this.fp)
+            return;
+        const e2 = this.Hi(),
+            i2 = this.tp();
+        if (e2.Ho(i2, i2.fn()), this.dp = null, this.fp = false, e2.xc(), null !== this.Mp) {
+            const t4 = performance.now(),
+                i3 = e2.yt();
+            this.Mp.pr(i3.ou(), t4), this.Mp.wu(t4) || e2.Yn(this.Mp);
+        }
+    }
+    Op() {
+        this.bp = null;
+    }
+    Ip() {
+        if (this.Sp) {
+            if (this.Hi().Hn(), document.activeElement !== document.body && document.activeElement !== document.documentElement)
+                kl(document.activeElement).blur();
+            else {
+                const t3 = document.getSelection();
+                null !== t3 && t3.removeAllRanges();
+            }!this.Sp.fn().Ni() && this.Hi().yt().Ni();
+        }
+    }
+    Vp(t3) {
+        if (null === this.Sp)
+            return;
+        const e2 = this.Hi(),
+            i2 = e2.yt();
+        if (i2.Ni())
+            return;
+        const s2 = this.xp.F(),
+            n2 = s2.handleScroll,
+            r2 = s2.kineticScroll;
+        if ((!n2.pressedMouseMove || t3.Sf) && (!n2.horzTouchDrag && !n2.vertTouchDrag || !t3.Sf))
+            return;
+        const o2 = this.Sp.fn(),
+            a2 = performance.now();
+        if (null !== this.dp || this.iv(t3) || (this.dp = {
+                x: t3.clientX,
+                y: t3.clientY,
+                u_: a2,
+                ev: t3.localX,
+                rv: t3.localY
+            }), null !== this.dp && !this.fp && (this.dp.x !== t3.clientX || this.dp.y !== t3.clientY)) {
+            if (t3.Sf && r2.touch || !t3.Sf && r2.mouse) {
+                const t4 = i2.Ks();
+                this.Mp = new An(0.2 / t4, 7 / t4, 0.997, 15 / t4), this.Mp.Xc(i2.ou(), this.dp.u_);
+            } else
+                this.Mp = null;
+            o2.Ni() || e2.jo(this.Sp, o2, t3.localY), e2.Mc(t3.localX), this.fp = true;
+        }
+        this.fp && (o2.Ni() || e2.$o(this.Sp, o2, t3.localY), e2.Sc(t3.localX), null !== this.Mp && this.Mp.Xc(i2.ou(), a2));
+    }
+}
+class Xn {
+    constructor(t3, e2, i2, s2, n2) {
+        this.vt = true, this.Tf = hl({
+            width: 0,
+            height: 0
+        }), this.Af = () => this.ip(3), this.If = "left" === t3, this.Gu = i2.Rc, this.un = e2, this.hv = s2, this.lv = n2, this.Ef = document.createElement("div"), this.Ef.style.width = "25px", this.Ef.style.height = "100%", this.Ef.style.overflow = "hidden", this.zf = bc(this.Ef, hl({
+            width: 16,
+            height: 16
+        })), this.zf.subscribeSuggestedBitmapSizeChanged(this.Af);
+    }
+    M() {
+        this.zf.unsubscribeSuggestedBitmapSizeChanged(this.Af), this.zf.dispose();
+    }
+    Yf() {
+        return this.Ef;
+    }
+    qp() {
+        return this.Tf;
+    }
+    Jf(t3) {
+        cl(this.Tf, t3) || (this.Tf = t3, this.zf.resizeCanvasElement(t3), this.Ef.style.width = `${t3.width}px`, this.Ef.style.height = `${t3.height}px`, this.vt = true);
+    }
+    ip(t3) {
+        if (t3 < 3 && !this.vt)
+            return;
+        if (0 === this.Tf.width || 0 === this.Tf.height)
+            return;
+        this.vt = false, this.zf.applySuggestedBitmapSize();
+        const e2 = vl(this.zf);
+        null !== e2 && e2.useBitmapCoordinateSpace((t4) => {
+            this.sp(t4), this.ye(t4);
+        });
+    }
+    lp() {
+        return this.zf.bitmapSize;
+    }
+    ap(t3, e2, i2) {
+        const s2 = this.lp();
+        s2.width > 0 && s2.height > 0 && t3.drawImage(this.zf.canvasElement, e2, i2);
+    }
+    ye({
+        context: t3,
+        bitmapSize: e2,
+        horizontalPixelRatio: i2,
+        verticalPixelRatio: s2
+    }) {
+        if (!this.hv())
+            return;
+        t3.fillStyle = this.un.timeScale.borderColor;
+        const n2 = Math.floor(this.Gu.F().k * i2),
+            r2 = Math.floor(this.Gu.F().k * s2),
+            o2 = this.If ? e2.width - n2 : 0;
+        t3.fillRect(o2, 0, n2, r2);
+    }
+    sp({
+        context: t3,
+        bitmapSize: e2
+    }) {
+        Jl(t3, 0, 0, e2.width, e2.height, this.lv());
+    }
+}
+
+function Pc(t3, e2) {
+    return t3.w_ > e2.w_ ? t3 : e2;
+}
+class Kn {
+    constructor(t3) {
+        this.av = null, this.ov = null, this.S = null, this._v = false, this.Tf = hl({
+            width: 0,
+            height: 0
+        }), this.uv = new Ll(), this.Rf = new Ut(5), this.Bf = false, this.Af = () => {
+            this.Bf || this.xp.Ut().Ch();
+        }, this.Lf = () => {
+            this.Bf || this.xp.Ut().Ch();
+        }, this.xp = t3, this.un = t3.F().layout, this.cv = document.createElement("tr"), this.dv = document.createElement("td"), this.dv.style.padding = "0", this.fv = document.createElement("td"), this.fv.style.padding = "0", this.Ef = document.createElement("td"), this.Ef.style.height = "25px", this.Ef.style.padding = "0", this.pv = document.createElement("div"), this.pv.style.width = "100%", this.pv.style.height = "100%", this.pv.style.position = "relative", this.pv.style.overflow = "hidden", this.Ef.appendChild(this.pv), this.zf = bc(this.pv, hl({
+            width: 16,
+            height: 16
+        })), this.zf.subscribeSuggestedBitmapSizeChanged(this.Af);
+        const e2 = this.zf.canvasElement;
+        e2.style.position = "absolute", e2.style.zIndex = "1", e2.style.left = "0", e2.style.top = "0", this.Vf = bc(this.pv, hl({
+            width: 16,
+            height: 16
+        })), this.Vf.subscribeSuggestedBitmapSizeChanged(this.Lf);
+        const i2 = this.Vf.canvasElement;
+        i2.style.position = "absolute", i2.style.zIndex = "2", i2.style.left = "0", i2.style.top = "0", this.cv.appendChild(this.dv), this.cv.appendChild(this.Ef), this.cv.appendChild(this.fv), this.vv(), this.xp.Ut().Po().l(this.vv.bind(this), this), this.qf = new In(this.Vf.canvasElement, this, {
+            Zd: () => true,
+            Kd: () => false
+        });
+    }
+    M() {
+        this.qf.M(), null !== this.av && this.av.M(), null !== this.ov && this.ov.M(), this.Vf.unsubscribeSuggestedBitmapSizeChanged(this.Lf), this.Vf.dispose(), this.zf.unsubscribeSuggestedBitmapSizeChanged(this.Af), this.zf.dispose();
+    }
+    Yf() {
+        return this.cv;
+    }
+    mv() {
+        return this.av;
+    }
+    bv() {
+        return this.ov;
+    }
+    _f(t3) {
+        if (this._v)
+            return;
+        this._v = true;
+        const e2 = this.xp.Ut();
+        !e2.yt().Ni() && this.xp.F().handleScale.axisPressedMouseMove.time && e2.bc(t3.localX);
+    }
+    lf(t3) {
+        this._f(t3);
+    }
+    uf() {
+        const t3 = this.xp.Ut();
+        !t3.yt().Ni() && this._v && (this._v = false, this.xp.F().handleScale.axisPressedMouseMove.time && t3.kc());
+    }
+    Qd(t3) {
+        const e2 = this.xp.Ut();
+        !e2.yt().Ni() && this.xp.F().handleScale.axisPressedMouseMove.time && e2.yc(t3.localX);
+    }
+    Gd(t3) {
+        this.Qd(t3);
+    }
+    sf() {
+        this._v = false;
+        const t3 = this.xp.Ut();
+        t3.yt().Ni() && !this.xp.F().handleScale.axisPressedMouseMove.time || t3.kc();
+    }
+    if () {
+        this.sf();
+    }
+    zd() {
+        this.xp.F().handleScale.axisDoubleClickReset.time && this.xp.Ut().Zn();
+    }
+    Od() {
+        this.zd();
+    }
+    Hd() {
+        this.xp.Ut().F().handleScale.axisPressedMouseMove.time && this.op(1);
+    }
+    wf() {
+        this.op(0);
+    }
+    qp() {
+        return this.Tf;
+    }
+    gv() {
+        return this.uv;
+    }
+    wv(t3, e2, i2) {
+        cl(this.Tf, t3) || (this.Tf = t3, this.Bf = true, this.zf.resizeCanvasElement(t3), this.Vf.resizeCanvasElement(t3), this.Bf = false, this.Ef.style.width = `${t3.width}px`, this.Ef.style.height = `${t3.height}px`, this.uv.m(t3)), null !== this.av && this.av.Jf(hl({
+            width: e2,
+            height: t3.height
+        })), null !== this.ov && this.ov.Jf(hl({
+            width: i2,
+            height: t3.height
+        }));
+    }
+    Mv() {
+        const t3 = this.Sv();
+        return Math.ceil(t3.k + t3.C + t3.T + t3.I + t3.A + t3.xv);
+    }
+    gt() {
+        this.xp.Ut().yt().Jl();
+    }
+    lp() {
+        return this.zf.bitmapSize;
+    }
+    ap(t3, e2, i2) {
+        const s2 = this.lp();
+        s2.width > 0 && s2.height > 0 && t3.drawImage(this.zf.canvasElement, e2, i2);
+    }
+    ip(t3) {
+        if (0 === t3)
+            return;
+        if (1 !== t3) {
+            this.zf.applySuggestedBitmapSize();
+            const e3 = vl(this.zf);
+            null !== e3 && (e3.useBitmapCoordinateSpace((t4) => {
+                this.sp(t4), this.ye(t4);
+            }), this.ep(e3)), null !== this.av && this.av.ip(t3), null !== this.ov && this.ov.ip(t3);
+        }
+        this.Vf.applySuggestedBitmapSize();
+        const e2 = vl(this.Vf);
+        null !== e2 && (e2.useBitmapCoordinateSpace(({
+            context: t4,
+            bitmapSize: e3
+        }) => {
+            t4.clearRect(0, 0, e3.width, e3.height);
+        }), this.yv([this.xp.Ut().dc()], e2));
+    }
+    sp({
+        context: t3,
+        bitmapSize: e2
+    }) {
+        Jl(t3, 0, 0, e2.width, e2.height, this.xp.Ut().Ic());
+    }
+    ye({
+        context: t3,
+        bitmapSize: e2,
+        verticalPixelRatio: i2
+    }) {
+        if (this.xp.F().timeScale.borderVisible) {
+            t3.fillStyle = this.kv();
+            const s2 = Math.max(1, Math.floor(this.Sv().k * i2));
+            t3.fillRect(0, 0, e2.width, s2);
+        }
+    }
+    ep(t3) {
+        const e2 = this.xp.Ut().yt(),
+            i2 = e2.Jl();
+        if (!i2 || 0 === i2.length)
+            return;
+        let s2 = i2.reduce(Pc, i2[0]).w_;
+        s2 > 30 && s2 < 50 && (s2 = 30);
+        const n2 = this.Sv(),
+            r2 = e2.F();
+        r2.borderVisible && r2.ticksVisible && t3.useBitmapCoordinateSpace(({
+            context: t4,
+            horizontalPixelRatio: e3,
+            verticalPixelRatio: s3
+        }) => {
+            t4.strokeStyle = this.kv(), t4.fillStyle = this.kv();
+            const r3 = Math.max(1, Math.floor(e3)),
+                o2 = Math.floor(0.5 * e3);
+            t4.beginPath();
+            const a2 = Math.round(n2.C * s3);
+            for (let s4 = i2.length; s4--;) {
+                const n3 = Math.round(i2[s4].Yl * e3);
+                t4.rect(n3 - o2, 0, r3, a2);
+            }
+            t4.fill();
+        }), t3.useMediaCoordinateSpace(({
+            context: t4
+        }) => {
+            const e3 = n2.k + n2.C + n2.I + n2.T / 2;
+            t4.textAlign = "center", t4.textBaseline = "middle", t4.fillStyle = this.$(), t4.font = this.Kf();
+            for (const n3 of i2)
+                if (n3.w_ < s2) {
+                    const i3 = n3.cu ? this.Cv(t4, n3.Yl, n3.ua) : n3.Yl;
+                    t4.fillText(n3.ua, i3, e3);
+                }
+            t4.font = this.Tv();
+            for (const n3 of i2)
+                if (n3.w_ >= s2) {
+                    const i3 = n3.cu ? this.Cv(t4, n3.Yl, n3.ua) : n3.Yl;
+                    t4.fillText(n3.ua, i3, e3);
+                }
+        });
+    }
+    Cv(t3, e2, i2) {
+        const s2 = this.Rf.Si(t3, i2),
+            n2 = s2 / 2,
+            r2 = Math.floor(e2 - n2) + 0.5;
+        return r2 < 0 ? e2 += Math.abs(0 - r2) : r2 + s2 > this.Tf.width && (e2 -= Math.abs(this.Tf.width - (r2 + s2))), e2;
+    }
+    yv(t3, e2) {
+        const i2 = this.Sv();
+        for (const s2 of t3)
+            for (const t4 of s2.Qi())
+                t4.Mt().X(e2, i2);
+    }
+    kv() {
+        return this.xp.F().timeScale.borderColor;
+    }
+    $() {
+        return this.un.textColor;
+    }
+    W() {
+        return this.un.fontSize;
+    }
+    Kf() {
+        return Hl(this.W(), this.un.fontFamily);
+    }
+    Tv() {
+        return Hl(this.W(), this.un.fontFamily, "bold");
+    }
+    Sv() {
+        null === this.S && (this.S = {
+            k: 1,
+            V: NaN,
+            I: NaN,
+            A: NaN,
+            ji: NaN,
+            C: 5,
+            T: NaN,
+            P: "",
+            Wi: new Ut(),
+            xv: 0
+        });
+        const t3 = this.S,
+            e2 = this.Kf();
+        if (t3.P !== e2) {
+            const i2 = this.W();
+            t3.T = i2, t3.P = e2, t3.I = 3 * i2 / 12, t3.A = 3 * i2 / 12, t3.ji = 9 * i2 / 12, t3.V = 0, t3.xv = 4 * i2 / 12, t3.Wi.Fe();
+        }
+        return this.S;
+    }
+    op(t3) {
+        this.Ef.style.cursor = 1 === t3 ? "ew-resize" : "default";
+    }
+    vv() {
+        const t3 = this.xp.Ut(),
+            e2 = t3.F();
+        e2.leftPriceScale.visible || null === this.av || (this.dv.removeChild(this.av.Yf()), this.av.M(), this.av = null), e2.rightPriceScale.visible || null === this.ov || (this.fv.removeChild(this.ov.Yf()), this.ov.M(), this.ov = null);
+        const i2 = {
+                Rc: this.xp.Ut().Rc()
+            },
+            s2 = () => e2.leftPriceScale.borderVisible && t3.yt().F().borderVisible,
+            n2 = () => t3.Ic();
+        e2.leftPriceScale.visible && null === this.av && (this.av = new Xn("left", e2, i2, s2, n2), this.dv.appendChild(this.av.Yf())), e2.rightPriceScale.visible && null === this.ov && (this.ov = new Xn("right", e2, i2, s2, n2), this.fv.appendChild(this.ov.Yf()));
+    }
+}
+const Rc = !!fc && !!navigator.userAgentData && navigator.userAgentData.brands.some((t3) => t3.brand.includes("Chromium")) && !!fc && ((null === (Ac = null === navigator || void 0 === navigator ? void 0 : navigator.userAgentData) || void 0 === Ac ? void 0 : Ac.platform) ? "Windows" === navigator.userAgentData.platform : navigator.userAgent.toLowerCase().indexOf("win") >= 0);
+var Ac;
+class Qn {
+    constructor(t3, e2) {
+        var i2;
+        this.Pv = [], this.Rv = 0, this.fa = 0, this.vo = 0, this.Dv = 0, this.Bv = 0, this.Av = null, this.Ov = false, this.pp = new Ll(), this.Xu = new Ll(), this.Lv = null, this.Iv = t3, this.un = e2, this.cv = document.createElement("div"), this.cv.classList.add("tv-lightweight-charts"), this.cv.style.overflow = "hidden", this.cv.style.width = "100%", this.cv.style.height = "100%", (i2 = this.cv).style.userSelect = "none", i2.style.webkitUserSelect = "none", i2.style.msUserSelect = "none", i2.style.MozUserSelect = "none", i2.style.webkitTapHighlightColor = "transparent", this.Ev = document.createElement("table"), this.Ev.setAttribute("cellspacing", "0"), this.cv.appendChild(this.Ev), this.zv = this.Vv.bind(this), Dc(this.un) && this.Nv(true), this.Hi = new xn(this.Ku.bind(this), this.un), this.Ut().fc().l(this.Fv.bind(this), this), this.Wv = new Kn(this), this.Ev.appendChild(this.Wv.Yf());
+        const s2 = e2.autoSize && this.jv();
+        let n2 = this.un.width,
+            r2 = this.un.height;
+        if (s2 || 0 === n2 || 0 === r2) {
+            const e3 = t3.getBoundingClientRect();
+            n2 = n2 || e3.width, r2 = r2 || e3.height;
+        }
+        this.$v(n2, r2), this.Hv(), t3.appendChild(this.cv), this.Uv(), this.Hi.yt().yu().l(this.Hi.dl.bind(this.Hi), this), this.Hi.Po().l(this.Hi.dl.bind(this.Hi), this);
+    }
+    Ut() {
+        return this.Hi;
+    }
+    F() {
+        return this.un;
+    }
+    qv() {
+        return this.Pv;
+    }
+    Yv() {
+        return this.Wv;
+    }
+    M() {
+        this.Nv(false), 0 !== this.Rv && window.cancelAnimationFrame(this.Rv), this.Hi.fc().v(this), this.Hi.yt().yu().v(this), this.Hi.Po().v(this), this.Hi.M();
+        for (const t3 of this.Pv)
+            this.Ev.removeChild(t3.Yf()), t3.jp().v(this), t3.M();
+        this.Pv = [], kl(this.Wv).M(), null !== this.cv.parentElement && this.cv.parentElement.removeChild(this.cv), this.Xu.M(), this.pp.M(), this.Xv();
+    }
+    $v(t3, e2, i2 = false) {
+        if (this.fa === e2 && this.vo === t3)
+            return;
+        const s2 = function(t4) {
+            const e3 = Math.floor(t4.width),
+                i3 = Math.floor(t4.height);
+            return hl({
+                width: e3 - e3 % 2,
+                height: i3 - i3 % 2
+            });
+        }(hl({
+            width: t3,
+            height: e2
+        }));
+        this.fa = s2.height, this.vo = s2.width;
+        const n2 = this.fa + "px",
+            r2 = this.vo + "px";
+        kl(this.cv).style.height = n2, kl(this.cv).style.width = r2, this.Ev.style.height = n2, this.Ev.style.width = r2, i2 ? this.Zv(et.ss(), performance.now()) : this.Hi.dl();
+    }
+    ip(t3) {
+        void 0 === t3 && (t3 = et.ss());
+        for (let e2 = 0; e2 < this.Pv.length; e2++)
+            this.Pv[e2].ip(t3.jn(e2).Nn);
+        this.un.timeScale.visible && this.Wv.ip(t3.Wn());
+    }
+    kh(t3) {
+        const e2 = Dc(this.un);
+        this.Hi.kh(t3);
+        const i2 = Dc(this.un);
+        i2 !== e2 && this.Nv(i2), this.Uv(), this.Kv(t3);
+    }
+    jp() {
+        return this.pp;
+    }
+    fc() {
+        return this.Xu;
+    }
+    Gv() {
+        null !== this.Av && (this.Zv(this.Av, performance.now()), this.Av = null);
+        const t3 = this.Jv(null),
+            e2 = document.createElement("canvas");
+        e2.width = t3.width, e2.height = t3.height;
+        const i2 = kl(e2.getContext("2d"));
+        return this.Jv(i2), e2;
+    }
+    Qv(t3) {
+        return ("left" !== t3 || this.tm()) && ("right" !== t3 || this.im()) ? 0 === this.Pv.length ? 0 : kl("left" === t3 ? this.Pv[0].Jp() : this.Pv[0].Qp()).Qf() : 0;
+    }
+    nm() {
+        return this.un.autoSize && null !== this.Lv;
+    }
+    Kv(t3) {
+        (void 0 !== t3.autoSize || !this.Lv || void 0 === t3.width && void 0 === t3.height) && (t3.autoSize && !this.Lv && this.jv(), false === t3.autoSize && null !== this.Lv && this.Xv(), t3.autoSize || void 0 === t3.width && void 0 === t3.height || this.$v(t3.width || this.vo, t3.height || this.fa));
+    }
+    Jv(t3) {
+        let e2 = 0,
+            i2 = 0;
+        const s2 = this.Pv[0],
+            n2 = (e3, i3) => {
+                let s3 = 0;
+                for (let n3 = 0; n3 < this.Pv.length; n3++) {
+                    const r3 = this.Pv[n3],
+                        o2 = kl("left" === e3 ? r3.Jp() : r3.Qp()),
+                        a2 = o2.lp();
+                    null !== t3 && o2.ap(t3, i3, s3), s3 += a2.height;
+                }
+            };
+        this.tm() && (n2("left", 0), e2 += kl(s2.Jp()).lp().width);
+        for (let s3 = 0; s3 < this.Pv.length; s3++) {
+            const n3 = this.Pv[s3],
+                r3 = n3.lp();
+            null !== t3 && n3.ap(t3, e2, i2), i2 += r3.height;
+        }
+        e2 += s2.lp().width, this.im() && (n2("right", e2), e2 += kl(s2.Qp()).lp().width);
+        const r2 = (e3, i3, s3) => {
+            kl("left" === e3 ? this.Wv.mv() : this.Wv.bv()).ap(kl(t3), i3, s3);
+        };
+        if (this.un.timeScale.visible) {
+            const e3 = this.Wv.lp();
+            if (null !== t3) {
+                let n3 = 0;
+                this.tm() && (r2("left", n3, i2), n3 = kl(s2.Jp()).lp().width), this.Wv.ap(t3, n3, i2), n3 += e3.width, this.im() && r2("right", n3, i2);
+            }
+            i2 += e3.height;
+        }
+        return hl({
+            width: e2,
+            height: i2
+        });
+    }
+    sm() {
+        let t3 = 0,
+            e2 = 0,
+            i2 = 0;
+        for (const s3 of this.Pv)
+            this.tm() && (e2 = Math.max(e2, kl(s3.Jp()).Zf())), this.im() && (i2 = Math.max(i2, kl(s3.Qp()).Zf())), t3 += s3.Ro();
+        e2 = gc(e2), i2 = gc(i2);
+        const s2 = this.vo,
+            n2 = this.fa,
+            r2 = Math.max(s2 - e2 - i2, 0),
+            o2 = this.un.timeScale.visible;
+        let a2 = o2 ? this.Wv.Mv() : 0;
+        var l2;
+        a2 = (l2 = a2) + l2 % 2;
+        const h2 = 0 + a2,
+            c2 = n2 < h2 ? 0 : n2 - h2,
+            u2 = c2 / t3;
+        let d2 = 0;
+        for (let t4 = 0; t4 < this.Pv.length; ++t4) {
+            const s3 = this.Pv[t4];
+            s3.Dp(this.Hi.uc()[t4]);
+            let n3 = 0,
+                o3 = 0;
+            o3 = t4 === this.Pv.length - 1 ? c2 - d2 : Math.round(s3.Ro() * u2), n3 = Math.max(o3, 2), d2 += n3, s3.Jf(hl({
+                width: r2,
+                height: n3
+            })), this.tm() && s3.Up(e2, "left"), this.im() && s3.Up(i2, "right"), s3.tp() && this.Hi.vc(s3.tp(), n3);
+        }
+        this.Wv.wv(hl({
+            width: o2 ? r2 : 0,
+            height: a2
+        }), o2 ? e2 : 0, o2 ? i2 : 0), this.Hi.Bo(r2), this.Dv !== e2 && (this.Dv = e2), this.Bv !== i2 && (this.Bv = i2);
+    }
+    Nv(t3) {
+        t3 ? this.cv.addEventListener("wheel", this.zv, {
+            passive: false
+        }) : this.cv.removeEventListener("wheel", this.zv);
+    }
+    rm(t3) {
+        switch (t3.deltaMode) {
+            case t3.DOM_DELTA_PAGE:
+                return 120;
+            case t3.DOM_DELTA_LINE:
+                return 32;
+        }
+        return Rc ? 1 / window.devicePixelRatio : 1;
+    }
+    Vv(t3) {
+        if (!(0 !== t3.deltaX && this.un.handleScroll.mouseWheel || 0 !== t3.deltaY && this.un.handleScale.mouseWheel))
+            return;
+        const e2 = this.rm(t3),
+            i2 = e2 * t3.deltaX / 100,
+            s2 = -e2 * t3.deltaY / 100;
+        if (t3.cancelable && t3.preventDefault(), 0 !== s2 && this.un.handleScale.mouseWheel) {
+            const e3 = Math.sign(s2) * Math.min(1, Math.abs(s2)),
+                i3 = t3.clientX - this.cv.getBoundingClientRect().left;
+            this.Ut().gc(i3, e3);
+        }
+        0 !== i2 && this.un.handleScroll.mouseWheel && this.Ut().wc(-80 * i2);
+    }
+    Zv(t3, e2) {
+        var i2;
+        const s2 = t3.Wn();
+        3 === s2 && this.hm(), 3 !== s2 && 2 !== s2 || (this.lm(t3), this.am(t3, e2), this.Wv.gt(), this.Pv.forEach((t4) => {
+            t4.Ap();
+        }), 3 === (null === (i2 = this.Av) || void 0 === i2 ? void 0 : i2.Wn()) && (this.Av.Qn(t3), this.hm(), this.lm(this.Av), this.am(this.Av, e2), t3 = this.Av, this.Av = null)), this.ip(t3);
+    }
+    am(t3, e2) {
+        for (const i2 of t3.Jn())
+            this.ts(i2, e2);
+    }
+    lm(t3) {
+        const e2 = this.Hi.uc();
+        for (let i2 = 0; i2 < e2.length; i2++)
+            t3.jn(i2).Fn && e2[i2].Yo();
+    }
+    ts(t3, e2) {
+        const i2 = this.Hi.yt();
+        switch (t3.Un) {
+            case 0:
+                i2.Cu();
+                break;
+            case 1:
+                i2.Tu(t3.At);
+                break;
+            case 2:
+                i2.Kn(t3.At);
+                break;
+            case 3:
+                i2.Gn(t3.At);
+                break;
+            case 4:
+                i2.du();
+                break;
+            case 5:
+                t3.At.wu(e2) || i2.Gn(t3.At.Mu(e2));
+        }
+    }
+    Ku(t3) {
+        null !== this.Av ? this.Av.Qn(t3) : this.Av = t3, this.Ov || (this.Ov = true, this.Rv = window.requestAnimationFrame((t4) => {
+            if (this.Ov = false, this.Rv = 0, null !== this.Av) {
+                const e2 = this.Av;
+                this.Av = null, this.Zv(e2, t4);
+                for (const i2 of e2.Jn())
+                    if (5 === i2.Un && !i2.At.wu(t4)) {
+                        this.Ut().Yn(i2.At);
+                        break;
+                    }
+            }
+        }));
+    }
+    hm() {
+        this.Hv();
+    }
+    Hv() {
+        const t3 = this.Hi.uc(),
+            e2 = t3.length,
+            i2 = this.Pv.length;
+        for (let t4 = e2; t4 < i2; t4++) {
+            const t5 = xl(this.Pv.pop());
+            this.Ev.removeChild(t5.Yf()), t5.jp().v(this), t5.M();
+        }
+        for (let s2 = i2; s2 < e2; s2++) {
+            const e3 = new Yn(this, t3[s2]);
+            e3.jp().l(this.om.bind(this), this), this.Pv.push(e3), this.Ev.insertBefore(e3.Yf(), this.Wv.Yf());
+        }
+        for (let i3 = 0; i3 < e2; i3++) {
+            const e3 = t3[i3],
+                s2 = this.Pv[i3];
+            s2.tp() !== e3 ? s2.Dp(e3) : s2.Rp();
+        }
+        this.Uv(), this.sm();
+    }
+    _m(t3, e2, i2) {
+        var s2;
+        const n2 = /* @__PURE__ */ new Map();
+        let r2;
+        if (null !== t3 && this.Hi.wt().forEach((e3) => {
+                const i3 = e3.Ln().jh(t3);
+                null !== i3 && n2.set(e3, i3);
+            }), null !== t3) {
+            const e3 = null === (s2 = this.Hi.yt().Ui(t3)) || void 0 === s2 ? void 0 : s2.M_;
+            void 0 !== e3 && (r2 = e3);
+        }
+        const o2 = this.Ut().hc(),
+            a2 = null !== o2 && o2.ac instanceof Pi ? o2.ac : void 0,
+            l2 = null !== o2 && void 0 !== o2.Ep ? o2.Ep.nr : void 0;
+        return {
+            _t: r2,
+            Ys: null != t3 ? t3 : void 0,
+            um: null != e2 ? e2 : void 0,
+            dm: a2,
+            fm: n2,
+            pm: l2,
+            vm: null != i2 ? i2 : void 0
+        };
+    }
+    om(t3, e2, i2) {
+        this.pp.m(() => this._m(t3, e2, i2));
+    }
+    Fv(t3, e2, i2) {
+        this.Xu.m(() => this._m(t3, e2, i2));
+    }
+    Uv() {
+        const t3 = this.un.timeScale.visible ? "" : "none";
+        this.Wv.Yf().style.display = t3;
+    }
+    tm() {
+        return this.Pv[0].tp().zo().F().visible;
+    }
+    im() {
+        return this.Pv[0].tp().Vo().F().visible;
+    }
+    jv() {
+        return "ResizeObserver" in window && (this.Lv = new ResizeObserver((t3) => {
+            const e2 = t3.find((t4) => t4.target === this.Iv);
+            e2 && this.$v(e2.contentRect.width, e2.contentRect.height);
+        }), this.Lv.observe(this.Iv, {
+            box: "border-box"
+        }), true);
+    }
+    Xv() {
+        null !== this.Lv && this.Lv.disconnect();
+    }
+}
+
+function Dc(t3) {
+    return Boolean(t3.handleScroll.mouseWheel || t3.handleScale.mouseWheel);
+}
+
+function Lc(t3, e2, i2, s2) {
+    const n2 = i2.value,
+        r2 = {
+            Ys: e2,
+            _t: t3,
+            At: [n2, n2, n2, n2],
+            M_: s2
+        };
+    return void 0 !== i2.color && (r2.D = i2.color), r2;
+}
+
+function Oc(t3) {
+    return void 0 !== t3.At;
+}
+
+function Fc(t3) {
+    return (e2, i2, s2, n2) => {
+        return void 0 === (r2 = s2).open && void 0 === r2.value ? {
+            _t: e2,
+            Ys: i2,
+            M_: n2
+        } : t3(e2, i2, s2, n2);
+        var r2;
+    };
+}
+const Nc = {
+    Candlestick: Fc(function(t3, e2, i2, s2) {
+        const n2 = {
+            Ys: e2,
+            _t: t3,
+            At: [i2.open, i2.high, i2.low, i2.close],
+            M_: s2
+        };
+        return void 0 !== i2.color && (n2.D = i2.color), void 0 !== i2.borderColor && (n2.Ot = i2.borderColor), void 0 !== i2.wickColor && (n2.Dh = i2.wickColor), n2;
+    }),
+    Bar: Fc(function(t3, e2, i2, s2) {
+        const n2 = {
+            Ys: e2,
+            _t: t3,
+            At: [i2.open, i2.high, i2.low, i2.close],
+            M_: s2
+        };
+        return void 0 !== i2.color && (n2.D = i2.color), n2;
+    }),
+    Area: Fc(function(t3, e2, i2, s2) {
+        const n2 = i2.value,
+            r2 = {
+                Ys: e2,
+                _t: t3,
+                At: [n2, n2, n2, n2],
+                M_: s2
+            };
+        return void 0 !== i2.lineColor && (r2.ot = i2.lineColor), void 0 !== i2.topColor && (r2.bs = i2.topColor), void 0 !== i2.bottomColor && (r2.gs = i2.bottomColor), r2;
+    }),
+    Baseline: Fc(function(t3, e2, i2, s2) {
+        const n2 = i2.value,
+            r2 = {
+                Ys: e2,
+                _t: t3,
+                At: [n2, n2, n2, n2],
+                M_: s2
+            };
+        return void 0 !== i2.topLineColor && (r2.be = i2.topLineColor), void 0 !== i2.bottomLineColor && (r2.ge = i2.bottomLineColor), void 0 !== i2.topFillColor1 && (r2.de = i2.topFillColor1), void 0 !== i2.topFillColor2 && (r2.fe = i2.topFillColor2), void 0 !== i2.bottomFillColor1 && (r2.pe = i2.bottomFillColor1), void 0 !== i2.bottomFillColor2 && (r2.ve = i2.bottomFillColor2), r2;
+    }),
+    Histogram: Fc(Lc),
+    Line: Fc(Lc)
+};
+
+function $c(t3) {
+    return Nc[t3];
+}
+
+function Vc(t3) {
+    return 60 * t3 * 60 * 1e3;
+}
+
+function zc(t3) {
+    return 60 * t3 * 1e3;
+}
+const Bc = [{
+    bm: (1, 1e3),
+    w_: 10
+}, {
+    bm: zc(1),
+    w_: 20
+}, {
+    bm: zc(5),
+    w_: 21
+}, {
+    bm: zc(30),
+    w_: 22
+}, {
+    bm: Vc(1),
+    w_: 30
+}, {
+    bm: Vc(3),
+    w_: 31
+}, {
+    bm: Vc(6),
+    w_: 32
+}, {
+    bm: Vc(12),
+    w_: 33
+}];
+
+function Uc(t3, e2) {
+    if (t3.getUTCFullYear() !== e2.getUTCFullYear())
+        return 70;
+    if (t3.getUTCMonth() !== e2.getUTCMonth())
+        return 60;
+    if (t3.getUTCDate() !== e2.getUTCDate())
+        return 50;
+    for (let i2 = Bc.length - 1; i2 >= 0; --i2)
+        if (Math.floor(e2.getTime() / Bc[i2].bm) !== Math.floor(t3.getTime() / Bc[i2].bm))
+            return Bc[i2].w_;
+    return 0;
+}
+
+function jc(t3, e2 = 0) {
+    if (0 === t3.length)
+        return;
+    let i2 = 0 === e2 ? null : t3[e2 - 1]._t.u_,
+        s2 = null !== i2 ? new Date(1e3 * i2) : null,
+        n2 = 0;
+    for (let r2 = e2; r2 < t3.length; ++r2) {
+        const e3 = t3[r2],
+            o2 = new Date(1e3 * e3._t.u_);
+        null !== s2 && (e3.g_ = Uc(o2, s2)), n2 += e3._t.u_ - (i2 || e3._t.u_), i2 = e3._t.u_, s2 = o2;
+    }
+    if (0 === e2 && t3.length > 1) {
+        const e3 = Math.ceil(n2 / (t3.length - 1)),
+            i3 = new Date(1e3 * (t3[0]._t.u_ - e3));
+        t3[0].g_ = Uc(new Date(1e3 * t3[0]._t.u_), i3);
+    }
+}
+
+function Hc(t3) {
+    if (!uc(t3))
+        throw new Error("time must be of type BusinessDay");
+    const e2 = new Date(Date.UTC(t3.year, t3.month - 1, t3.day, 0, 0, 0, 0));
+    return {
+        u_: Math.round(e2.getTime() / 1e3),
+        __: t3
+    };
+}
+
+function Wc(t3) {
+    if (!dc(t3))
+        throw new Error("time must be of type isUTCTimestamp");
+    return {
+        u_: t3
+    };
+}
+
+function qc(t3) {
+    return 0 === t3.length ? null : uc(t3[0].time) ? Hc : Wc;
+}
+
+function Kc(t3) {
+    return dc(t3) ? Wc(t3) : uc(t3) ? Hc(t3) : Hc(Gc(t3));
+}
+
+function Gc(t3) {
+    const e2 = new Date(t3);
+    if (isNaN(e2.getTime()))
+        throw new Error(`Invalid date string=${t3}, expected format=yyyy-mm-dd`);
+    return {
+        day: e2.getUTCDate(),
+        month: e2.getUTCMonth() + 1,
+        year: e2.getUTCFullYear()
+    };
+}
+
+function Yc(t3) {
+    $l(t3.time) && (t3.time = Gc(t3.time));
+}
+
+function Qc(t3) {
+    return {
+        Ys: 0,
+        gm: /* @__PURE__ */ new Map(),
+        yl: t3
+    };
+}
+
+function Xc(t3) {
+    if (void 0 !== t3 && 0 !== t3.length)
+        return {
+            wm: t3[0]._t.u_,
+            Mm: t3[t3.length - 1]._t.u_
+        };
+}
+
+function Jc(t3) {
+    let e2;
+    return t3.forEach((t4) => {
+        void 0 === e2 && (e2 = t4.M_);
+    }), xl(e2);
+}
+
+function Zc(t3) {
+    void 0 === t3.M_ && (t3.M_ = t3.time);
+}
+class Ss {
+    constructor() {
+        this.Sm = /* @__PURE__ */ new Map(), this.xm = /* @__PURE__ */ new Map(), this.ym = /* @__PURE__ */ new Map(), this.km = [];
+    }
+    M() {
+        this.Sm.clear(), this.xm.clear(), this.ym.clear(), this.km = [];
+    }
+    Cm(t3, e2) {
+        let i2 = 0 !== this.Sm.size,
+            s2 = false;
+        const n2 = this.xm.get(t3);
+        if (void 0 !== n2)
+            if (1 === this.xm.size)
+                i2 = false, s2 = true, this.Sm.clear();
+            else
+                for (const e3 of this.km)
+                    e3.pointData.gm.delete(t3) && (s2 = true);
+        let r2 = [];
+        if (0 !== e2.length) {
+            const i3 = e2;
+            i3.forEach((t4) => Zc(t4)),
+                function(t4) {
+                    t4.forEach(Yc);
+                }(e2);
+            const n3 = kl(qc(e2)),
+                o3 = $c(t3.Lh());
+            r2 = i3.map((e3) => {
+                const i4 = n3(e3.time);
+                let r3 = this.Sm.get(i4.u_);
+                void 0 === r3 && (r3 = Qc(i4), this.Sm.set(i4.u_, r3), s2 = true);
+                const a2 = o3(i4, r3.Ys, e3, e3.M_);
+                return r3.gm.set(t3, a2), a2;
+            });
+        }
+        i2 && this.Tm(), this.Pm(t3, r2);
+        let o2 = -1;
+        if (s2) {
+            const t4 = [];
+            this.Sm.forEach((e3) => {
+                t4.push({
+                    g_: 0,
+                    _t: e3.yl,
+                    pointData: e3,
+                    M_: Jc(e3.gm)
+                });
+            }), t4.sort((t5, e3) => t5._t.u_ - e3._t.u_), o2 = this.Rm(t4);
+        }
+        return this.Dm(t3, o2, function(t4, e3) {
+            const i3 = Xc(t4),
+                s3 = Xc(e3);
+            if (void 0 !== i3 && void 0 !== s3)
+                return {
+                    ml: i3.Mm >= s3.Mm && i3.wm >= s3.wm
+                };
+        }(this.xm.get(t3), n2));
+    }
+    Ac(t3) {
+        return this.Cm(t3, []);
+    }
+    Bm(t3, e2) {
+        const i2 = e2;
+        Zc(i2), Yc(e2);
+        const s2 = kl(qc([e2]))(e2.time),
+            n2 = this.ym.get(t3);
+        if (void 0 !== n2 && s2.u_ < n2.u_)
+            throw new Error(`Cannot update oldest data, last time=${n2.u_}, new time=${s2.u_}`);
+        let r2 = this.Sm.get(s2.u_);
+        const o2 = void 0 === r2;
+        void 0 === r2 && (r2 = Qc(s2), this.Sm.set(s2.u_, r2));
+        const a2 = $c(t3.Lh())(s2, r2.Ys, e2, i2.M_);
+        r2.gm.set(t3, a2), this.Am(t3, a2);
+        const l2 = {
+            ml: Oc(a2)
+        };
+        if (!o2)
+            return this.Dm(t3, -1, l2);
+        const h2 = {
+                g_: 0,
+                _t: r2.yl,
+                pointData: r2,
+                M_: Jc(r2.gm)
+            },
+            c2 = yh(this.km, h2._t.u_, (t4, e3) => t4._t.u_ < e3);
+        this.km.splice(c2, 0, h2);
+        for (let t4 = c2; t4 < this.km.length; ++t4)
+            tu(this.km[t4].pointData, t4);
+        return jc(this.km, c2), this.Dm(t3, c2, l2);
+    }
+    Am(t3, e2) {
+        let i2 = this.xm.get(t3);
+        void 0 === i2 && (i2 = [], this.xm.set(t3, i2));
+        const s2 = 0 !== i2.length ? i2[i2.length - 1] : null;
+        null === s2 || e2._t.u_ > s2._t.u_ ? Oc(e2) && i2.push(e2) : Oc(e2) ? i2[i2.length - 1] = e2 : i2.splice(-1, 1), this.ym.set(t3, e2._t);
+    }
+    Pm(t3, e2) {
+        0 !== e2.length ? (this.xm.set(t3, e2.filter(Oc)), this.ym.set(t3, e2[e2.length - 1]._t)) : (this.xm.delete(t3), this.ym.delete(t3));
+    }
+    Tm() {
+        for (const t3 of this.km)
+            0 === t3.pointData.gm.size && this.Sm.delete(t3._t.u_);
+    }
+    Rm(t3) {
+        let e2 = -1;
+        for (let i2 = 0; i2 < this.km.length && i2 < t3.length; ++i2) {
+            const s2 = this.km[i2],
+                n2 = t3[i2];
+            if (s2._t.u_ !== n2._t.u_) {
+                e2 = i2;
+                break;
+            }
+            n2.g_ = s2.g_, tu(n2.pointData, i2);
+        }
+        if (-1 === e2 && this.km.length !== t3.length && (e2 = Math.min(this.km.length, t3.length)), -1 === e2)
+            return -1;
+        for (let i2 = e2; i2 < t3.length; ++i2)
+            tu(t3[i2].pointData, i2);
+        return jc(t3, e2), this.km = t3, e2;
+    }
+    Om() {
+        if (0 === this.xm.size)
+            return null;
+        let t3 = 0;
+        return this.xm.forEach((e2) => {
+            0 !== e2.length && (t3 = Math.max(t3, e2[e2.length - 1].Ys));
+        }), t3;
+    }
+    Dm(t3, e2, i2) {
+        const s2 = {
+            Lm: /* @__PURE__ */ new Map(),
+            yt: {
+                eu: this.Om()
+            }
+        };
+        if (-1 !== e2)
+            this.xm.forEach((e3, n2) => {
+                s2.Lm.set(n2, {
+                    ar: e3,
+                    Im: n2 === t3 ? i2 : void 0
+                });
+            }), this.xm.has(t3) || s2.Lm.set(t3, {
+                ar: [],
+                Im: i2
+            }), s2.yt.Em = this.km, s2.yt.zm = e2;
+        else {
+            const e3 = this.xm.get(t3);
+            s2.Lm.set(t3, {
+                ar: e3 || [],
+                Im: i2
+            });
+        }
+        return s2;
+    }
+}
+
+function tu(t3, e2) {
+    t3.Ys = e2, t3.gm.forEach((t4) => {
+        t4.Ys = e2;
+    });
+}
+
+function eu(t3) {
+    return {
+        value: t3.At[3],
+        time: t3.M_
+    };
+}
+
+function iu(t3) {
+    const e2 = eu(t3);
+    return void 0 !== t3.D && (e2.color = t3.D), e2;
+}
+
+function su(t3) {
+    return {
+        open: t3.At[0],
+        high: t3.At[1],
+        low: t3.At[2],
+        close: t3.At[3],
+        time: t3.M_
+    };
+}
+const nu = {
+    Area: function(t3) {
+        const e2 = eu(t3);
+        return void 0 !== t3.ot && (e2.lineColor = t3.ot), void 0 !== t3.bs && (e2.topColor = t3.bs), void 0 !== t3.gs && (e2.bottomColor = t3.gs), e2;
+    },
+    Line: iu,
+    Baseline: function(t3) {
+        const e2 = eu(t3);
+        return void 0 !== t3.be && (e2.topLineColor = t3.be), void 0 !== t3.ge && (e2.bottomLineColor = t3.ge), void 0 !== t3.de && (e2.topFillColor1 = t3.de), void 0 !== t3.fe && (e2.topFillColor2 = t3.fe), void 0 !== t3.pe && (e2.bottomFillColor1 = t3.pe), void 0 !== t3.ve && (e2.bottomFillColor2 = t3.ve), e2;
+    },
+    Histogram: iu,
+    Bar: function(t3) {
+        const e2 = su(t3);
+        return void 0 !== t3.D && (e2.color = t3.D), e2;
+    },
+    Candlestick: function(t3) {
+        const e2 = su(t3),
+            {
+                D: i2,
+                Ot: s2,
+                Dh: n2
+            } = t3;
+        return void 0 !== i2 && (e2.color = i2), void 0 !== s2 && (e2.borderColor = s2), void 0 !== n2 && (e2.wickColor = n2), e2;
+    }
+};
+
+function ru(t3) {
+    return nu[t3];
+}
+const ou = {
+        autoScale: true,
+        mode: 0,
+        invertScale: false,
+        alignLabels: true,
+        borderVisible: true,
+        borderColor: "#2B2B43",
+        entireTextOnly: false,
+        visible: false,
+        ticksVisible: false,
+        scaleMargins: {
+            bottom: 0.1,
+            top: 0.2
+        }
+    },
+    au = {
+        color: "rgba(0, 0, 0, 0)",
+        visible: false,
+        fontSize: 48,
+        fontFamily: jl,
+        fontStyle: "",
+        text: "",
+        horzAlign: "center",
+        vertAlign: "center"
+    },
+    lu = {
+        width: 0,
+        height: 0,
+        autoSize: false,
+        layout: {
+            background: {
+                type: "solid",
+                color: "#FFFFFF"
+            },
+            textColor: "#191919",
+            fontSize: 12,
+            fontFamily: jl
+        },
+        crosshair: {
+            vertLine: {
+                color: "#9598A1",
+                width: 1,
+                style: 3,
+                visible: true,
+                labelVisible: true,
+                labelBackgroundColor: "#131722"
+            },
+            horzLine: {
+                color: "#9598A1",
+                width: 1,
+                style: 3,
+                visible: true,
+                labelVisible: true,
+                labelBackgroundColor: "#131722"
+            },
+            mode: 1
+        },
+        grid: {
+            vertLines: {
+                color: "#D6DCDE",
+                style: 0,
+                visible: true
+            },
+            horzLines: {
+                color: "#D6DCDE",
+                style: 0,
+                visible: true
+            }
+        },
+        overlayPriceScales: Object.assign({}, ou),
+        leftPriceScale: Object.assign(Object.assign({}, ou), {
+            visible: false
+        }),
+        rightPriceScale: Object.assign(Object.assign({}, ou), {
+            visible: true
+        }),
+        timeScale: {
+            rightOffset: 0,
+            barSpacing: 6,
+            minBarSpacing: 0.5,
+            fixLeftEdge: false,
+            fixRightEdge: false,
+            lockVisibleTimeRangeOnResize: false,
+            rightBarStaysOnScroll: false,
+            borderVisible: true,
+            borderColor: "#2B2B43",
+            visible: true,
+            timeVisible: false,
+            secondsVisible: true,
+            shiftVisibleRangeOnNewBar: true,
+            ticksVisible: false
+        },
+        watermark: au,
+        localization: {
+            locale: fc ? navigator.language : "",
+            dateFormat: "dd MMM 'yy"
+        },
+        handleScroll: {
+            mouseWheel: true,
+            pressedMouseMove: true,
+            horzTouchDrag: true,
+            vertTouchDrag: true
+        },
+        handleScale: {
+            axisPressedMouseMove: {
+                time: true,
+                price: true
+            },
+            axisDoubleClickReset: {
+                time: true,
+                price: true
+            },
+            mouseWheel: true,
+            pinch: true
+        },
+        kineticScroll: {
+            mouse: false,
+            touch: true
+        },
+        trackingMode: {
+            exitMode: 1
+        }
+    },
+    hu = {
+        upColor: "#26a69a",
+        downColor: "#ef5350",
+        wickVisible: true,
+        borderVisible: true,
+        borderColor: "#378658",
+        borderUpColor: "#26a69a",
+        borderDownColor: "#ef5350",
+        wickColor: "#737375",
+        wickUpColor: "#26a69a",
+        wickDownColor: "#ef5350"
+    },
+    cu = {
+        upColor: "#26a69a",
+        downColor: "#ef5350",
+        openVisible: true,
+        thinBars: true
+    },
+    uu = {
+        color: "#2196f3",
+        lineStyle: 0,
+        lineWidth: 3,
+        lineType: 0,
+        crosshairMarkerVisible: true,
+        crosshairMarkerRadius: 4,
+        crosshairMarkerBorderColor: "",
+        crosshairMarkerBorderWidth: 2,
+        crosshairMarkerBackgroundColor: "",
+        lastPriceAnimation: 0
+    },
+    du = {
+        topColor: "rgba( 46, 220, 135, 0.4)",
+        bottomColor: "rgba( 40, 221, 100, 0)",
+        invertFilledArea: false,
+        lineColor: "#33D778",
+        lineStyle: 0,
+        lineWidth: 3,
+        lineType: 0,
+        crosshairMarkerVisible: true,
+        crosshairMarkerRadius: 4,
+        crosshairMarkerBorderColor: "",
+        crosshairMarkerBorderWidth: 2,
+        crosshairMarkerBackgroundColor: "",
+        lastPriceAnimation: 0
+    },
+    fu = {
+        baseValue: {
+            type: "price",
+            price: 0
+        },
+        topFillColor1: "rgba(38, 166, 154, 0.28)",
+        topFillColor2: "rgba(38, 166, 154, 0.05)",
+        topLineColor: "rgba(38, 166, 154, 1)",
+        bottomFillColor1: "rgba(239, 83, 80, 0.05)",
+        bottomFillColor2: "rgba(239, 83, 80, 0.28)",
+        bottomLineColor: "rgba(239, 83, 80, 1)",
+        lineWidth: 3,
+        lineStyle: 0,
+        lineType: 0,
+        crosshairMarkerVisible: true,
+        crosshairMarkerRadius: 4,
+        crosshairMarkerBorderColor: "",
+        crosshairMarkerBorderWidth: 2,
+        crosshairMarkerBackgroundColor: "",
+        lastPriceAnimation: 0
+    },
+    pu = {
+        color: "#26a69a",
+        base: 0
+    },
+    mu = {
+        title: "",
+        visible: true,
+        lastValueVisible: true,
+        priceLineVisible: true,
+        priceLineSource: 0,
+        priceLineWidth: 1,
+        priceLineColor: "",
+        priceLineStyle: 2,
+        baseLineVisible: true,
+        baseLineWidth: 1,
+        baseLineColor: "#B2B5BE",
+        baseLineStyle: 0,
+        priceFormat: {
+            type: "price",
+            precision: 2,
+            minMove: 0.01
+        }
+    };
+class Ns {
+    constructor(t3, e2) {
+        this.Vm = t3, this.Nm = e2;
+    }
+    applyOptions(t3) {
+        this.Vm.Ut().oc(this.Nm, t3);
+    }
+    options() {
+        return this.zi().F();
+    }
+    width() {
+        return lh(this.Nm) ? this.Vm.Qv(this.Nm) : 0;
+    }
+    zi() {
+        return kl(this.Vm.Ut()._c(this.Nm)).Bt;
+    }
+}
+const gu = {
+    color: "#FF0000",
+    price: 0,
+    lineStyle: 2,
+    lineWidth: 1,
+    lineVisible: true,
+    axisLabelVisible: true,
+    title: "",
+    axisLabelColor: "",
+    axisLabelTextColor: ""
+};
+class Ws {
+    constructor(t3) {
+        this.wh = t3;
+    }
+    applyOptions(t3) {
+        this.wh.kh(t3);
+    }
+    options() {
+        return this.wh.F();
+    }
+    Fm() {
+        return this.wh;
+    }
+}
+class js {
+    constructor(t3, e2, i2) {
+        this.Ts = t3, this.Wm = e2, this.jm = i2;
+    }
+    priceFormatter() {
+        return this.Ts.Bl();
+    }
+    priceToCoordinate(t3) {
+        const e2 = this.Ts.Tt();
+        return null === e2 ? null : this.Ts.Bt().Dt(t3, e2.At);
+    }
+    coordinateToPrice(t3) {
+        const e2 = this.Ts.Tt();
+        return null === e2 ? null : this.Ts.Bt().pn(t3, e2.At);
+    }
+    barsInLogicalRange(t3) {
+        if (null === t3)
+            return null;
+        const e2 = new dn(new _n(t3.from, t3.to)).C_(),
+            i2 = this.Ts.Ln();
+        if (i2.Ni())
+            return null;
+        const s2 = i2.jh(e2.Ms(), 1),
+            n2 = i2.jh(e2.ci(), -1),
+            r2 = kl(i2.Nh()),
+            o2 = kl(i2.On());
+        if (null !== s2 && null !== n2 && s2.Ys > n2.Ys)
+            return {
+                barsBefore: t3.from - r2,
+                barsAfter: o2 - t3.to
+            };
+        const a2 = {
+            barsBefore: null === s2 || s2.Ys === r2 ? t3.from - r2 : s2.Ys - r2,
+            barsAfter: null === n2 || n2.Ys === o2 ? o2 - t3.to : o2 - n2.Ys
+        };
+        return null !== s2 && null !== n2 && (a2.from = s2._t.__ || s2._t.u_, a2.to = n2._t.__ || n2._t.u_), a2;
+    }
+    setData(t3) {
+        this.Ts.Lh(), this.Wm.$m(this.Ts, t3);
+    }
+    update(t3) {
+        this.Ts.Lh(), this.Wm.Hm(this.Ts, t3);
+    }
+    dataByIndex(t3, e2) {
+        const i2 = this.Ts.Ln().jh(t3, e2);
+        return null === i2 ? null : ru(this.seriesType())(i2);
+    }
+    setMarkers(t3) {
+        const e2 = t3.map((t4) => Object.assign(Object.assign({}, t4), {
+            originalTime: t4.time,
+            time: Kc(t4.time)
+        }));
+        this.Ts.gl(e2);
+    }
+    markers() {
+        return this.Ts.wl().map((t3) => {
+            const {
+                originalTime: e2,
+                time: i2
+            } = t3, s2 = function(t4, e3) {
+                var i3 = {};
+                for (var s3 in t4)
+                    Object.prototype.hasOwnProperty.call(t4, s3) && e3.indexOf(s3) < 0 && (i3[s3] = t4[s3]);
+                if (null != t4 && "function" == typeof Object.getOwnPropertySymbols) {
+                    var n2 = 0;
+                    for (s3 = Object.getOwnPropertySymbols(t4); n2 < s3.length; n2++)
+                        e3.indexOf(s3[n2]) < 0 && Object.prototype.propertyIsEnumerable.call(t4, s3[n2]) && (i3[s3[n2]] = t4[s3[n2]]);
+                }
+                return i3;
+            }(t3, ["originalTime", "time"]);
+            return Object.assign({
+                time: e2
+            }, s2);
+        });
+    }
+    applyOptions(t3) {
+        this.Ts.kh(t3);
+    }
+    options() {
+        return zl(this.Ts.F());
+    }
+    priceScale() {
+        return this.jm.priceScale(this.Ts.Bt().zl());
+    }
+    createPriceLine(t3) {
+        const e2 = Ol(zl(gu), t3),
+            i2 = this.Ts.Ml(e2);
+        return new Ws(i2);
+    }
+    removePriceLine(t3) {
+        this.Ts.Sl(t3.Fm());
+    }
+    seriesType() {
+        return this.Ts.Lh();
+    }
+}
+class $s {
+    constructor(t3, e2) {
+        this.Um = new Ll(), this.E_ = new Ll(), this.uv = new Ll(), this.Hi = t3, this.wo = t3.yt(), this.Wv = e2, this.wo.Su().l(this.qm.bind(this)), this.wo.xu().l(this.Ym.bind(this)), this.Wv.gv().l(this.Xm.bind(this));
+    }
+    M() {
+        this.wo.Su().v(this), this.wo.xu().v(this), this.Wv.gv().v(this), this.Um.M(), this.E_.M(), this.uv.M();
+    }
+    scrollPosition() {
+        return this.wo.ou();
+    }
+    scrollToPosition(t3, e2) {
+        e2 ? this.wo.gu(t3, 1e3) : this.Hi.Gn(t3);
+    }
+    scrollToRealTime() {
+        this.wo.bu();
+    }
+    getVisibleRange() {
+        var t3, e2;
+        const i2 = this.wo.G_();
+        return null === i2 ? null : {
+            from: null !== (t3 = i2.from.__) && void 0 !== t3 ? t3 : i2.from.u_,
+            to: null !== (e2 = i2.to.__) && void 0 !== e2 ? e2 : i2.to.u_
+        };
+    }
+    setVisibleRange(t3) {
+        const e2 = {
+                from: Kc(t3.from),
+                to: Kc(t3.to)
+            },
+            i2 = this.wo.iu(e2);
+        this.Hi.Oc(i2);
+    }
+    getVisibleLogicalRange() {
+        const t3 = this.wo.K_();
+        return null === t3 ? null : {
+            from: t3.Ms(),
+            to: t3.ci()
+        };
+    }
+    setVisibleLogicalRange(t3) {
+        wl(t3.from <= t3.to, "The from index cannot be after the to index."), this.Hi.Oc(t3);
+    }
+    resetTimeScale() {
+        this.Hi.Zn();
+    }
+    fitContent() {
+        this.Hi.Cu();
+    }
+    logicalToCoordinate(t3) {
+        const e2 = this.Hi.yt();
+        return e2.Ni() ? null : e2.Et(t3);
+    }
+    coordinateToLogical(t3) {
+        return this.wo.Ni() ? null : this.wo.ru(t3);
+    }
+    timeToCoordinate(t3) {
+        const e2 = Kc(t3),
+            i2 = this.wo.Fl(e2, false);
+        return null === i2 ? null : this.wo.Et(i2);
+    }
+    coordinateToTime(t3) {
+        var e2;
+        const i2 = this.Hi.yt(),
+            s2 = i2.ru(t3),
+            n2 = i2.vn(s2);
+        return null === n2 ? null : null !== (e2 = n2.__) && void 0 !== e2 ? e2 : n2.u_;
+    }
+    width() {
+        return this.Wv.qp().width;
+    }
+    height() {
+        return this.Wv.qp().height;
+    }
+    subscribeVisibleTimeRangeChange(t3) {
+        this.Um.l(t3);
+    }
+    unsubscribeVisibleTimeRangeChange(t3) {
+        this.Um.p(t3);
+    }
+    subscribeVisibleLogicalRangeChange(t3) {
+        this.E_.l(t3);
+    }
+    unsubscribeVisibleLogicalRangeChange(t3) {
+        this.E_.p(t3);
+    }
+    subscribeSizeChange(t3) {
+        this.uv.l(t3);
+    }
+    unsubscribeSizeChange(t3) {
+        this.uv.p(t3);
+    }
+    applyOptions(t3) {
+        this.wo.kh(t3);
+    }
+    options() {
+        return zl(this.wo.F());
+    }
+    qm() {
+        this.Um.g() && this.Um.m(this.getVisibleRange());
+    }
+    Ym() {
+        this.E_.g() && this.E_.m(this.getVisibleLogicalRange());
+    }
+    Xm(t3) {
+        this.uv.m(t3.width, t3.height);
+    }
+}
+
+function yu(t3) {
+    return function(t4) {
+        if (Vl(t4.handleScale)) {
+            const e3 = t4.handleScale;
+            t4.handleScale = {
+                axisDoubleClickReset: {
+                    time: e3,
+                    price: e3
+                },
+                axisPressedMouseMove: {
+                    time: e3,
+                    price: e3
+                },
+                mouseWheel: e3,
+                pinch: e3
+            };
+        } else if (void 0 !== t4.handleScale) {
+            const {
+                axisPressedMouseMove: e3,
+                axisDoubleClickReset: i2
+            } = t4.handleScale;
+            Vl(e3) && (t4.handleScale.axisPressedMouseMove = {
+                time: e3,
+                price: e3
+            }), Vl(i2) && (t4.handleScale.axisDoubleClickReset = {
+                time: i2,
+                price: i2
+            });
+        }
+        const e2 = t4.handleScroll;
+        Vl(e2) && (t4.handleScroll = {
+            horzTouchDrag: e2,
+            vertTouchDrag: e2,
+            mouseWheel: e2,
+            pressedMouseMove: e2
+        });
+    }(t3), t3;
+}
+class qs {
+    constructor(t3, e2) {
+        this.Zm = new Ss(), this.Km = /* @__PURE__ */ new Map(), this.Gm = /* @__PURE__ */ new Map(), this.Jm = new Ll(), this.Qm = new Ll();
+        const i2 = void 0 === e2 ? zl(lu) : Ol(zl(lu), yu(e2));
+        this.Vm = new Qn(t3, i2), this.Vm.jp().l((t4) => {
+            this.Jm.g() && this.Jm.m(this.tb(t4()));
+        }, this), this.Vm.fc().l((t4) => {
+            this.Qm.g() && this.Qm.m(this.tb(t4()));
+        }, this);
+        const s2 = this.Vm.Ut();
+        this.ib = new $s(s2, this.Vm.Yv());
+    }
+    remove() {
+        this.Vm.jp().v(this), this.Vm.fc().v(this), this.ib.M(), this.Vm.M(), this.Km.clear(), this.Gm.clear(), this.Jm.M(), this.Qm.M(), this.Zm.M();
+    }
+    resize(t3, e2, i2) {
+        this.autoSizeActive() || this.Vm.$v(t3, e2, i2);
+    }
+    addAreaSeries(t3) {
+        return this.nb("Area", du, t3);
+    }
+    addBaselineSeries(t3) {
+        return this.nb("Baseline", fu, t3);
+    }
+    addBarSeries(t3) {
+        return this.nb("Bar", cu, t3);
+    }
+    addCandlestickSeries(t3 = {}) {
+        return function(t4) {
+            void 0 !== t4.borderColor && (t4.borderUpColor = t4.borderColor, t4.borderDownColor = t4.borderColor), void 0 !== t4.wickColor && (t4.wickUpColor = t4.wickColor, t4.wickDownColor = t4.wickColor);
+        }(t3), this.nb("Candlestick", hu, t3);
+    }
+    addHistogramSeries(t3) {
+        return this.nb("Histogram", pu, t3);
+    }
+    addLineSeries(t3) {
+        return this.nb("Line", uu, t3);
+    }
+    removeSeries(t3) {
+        const e2 = xl(this.Km.get(t3)),
+            i2 = this.Zm.Ac(e2);
+        this.Vm.Ut().Ac(e2), this.sb(i2), this.Km.delete(t3), this.Gm.delete(e2);
+    }
+    $m(t3, e2) {
+        this.sb(this.Zm.Cm(t3, e2));
+    }
+    Hm(t3, e2) {
+        this.sb(this.Zm.Bm(t3, e2));
+    }
+    subscribeClick(t3) {
+        this.Jm.l(t3);
+    }
+    unsubscribeClick(t3) {
+        this.Jm.p(t3);
+    }
+    subscribeCrosshairMove(t3) {
+        this.Qm.l(t3);
+    }
+    unsubscribeCrosshairMove(t3) {
+        this.Qm.p(t3);
+    }
+    priceScale(t3) {
+        return new Ns(this.Vm, t3);
+    }
+    timeScale() {
+        return this.ib;
+    }
+    applyOptions(t3) {
+        this.Vm.kh(yu(t3));
+    }
+    options() {
+        return this.Vm.F();
+    }
+    takeScreenshot() {
+        return this.Vm.Gv();
+    }
+    autoSizeActive() {
+        return this.Vm.nm();
+    }
+    nb(t3, e2, i2 = {}) {
+        ! function(t4) {
+            if (void 0 === t4 || "custom" === t4.type)
+                return;
+            const e3 = t4;
+            void 0 !== e3.minMove && void 0 === e3.precision && (e3.precision = function(t5) {
+                if (t5 >= 1)
+                    return 0;
+                let e4 = 0;
+                for (; e4 < 8; e4++) {
+                    const i3 = Math.round(t5);
+                    if (Math.abs(i3 - t5) < 1e-8)
+                        return e4;
+                    t5 *= 10;
+                }
+                return e4;
+            }(e3.minMove));
+        }(i2.priceFormat);
+        const s2 = Ol(zl(mu), zl(e2), i2),
+            n2 = this.Vm.Ut().Dc(t3, s2),
+            r2 = new js(n2, this, this);
+        return this.Km.set(r2, n2), this.Gm.set(n2, r2), r2;
+    }
+    sb(t3) {
+        const e2 = this.Vm.Ut();
+        e2.Pc(t3.yt.eu, t3.yt.Em, t3.yt.zm), t3.Lm.forEach((t4, e3) => e3.tt(t4.ar, t4.Im)), e2.lu();
+    }
+    eb(t3) {
+        return xl(this.Gm.get(t3));
+    }
+    tb(t3) {
+        const e2 = /* @__PURE__ */ new Map();
+        t3.fm.forEach((t4, i3) => {
+            const s2 = ru(i3.Lh())(t4);
+            wl(function(t5) {
+                return void 0 !== t5.open || void 0 !== t5.value;
+            }(s2)), e2.set(this.eb(i3), s2);
+        });
+        const i2 = void 0 === t3.dm ? void 0 : this.eb(t3.dm);
+        return {
+            time: t3._t,
+            logical: t3.Ys,
+            point: t3.um,
+            hoveredSeries: i2,
+            hoveredObjectId: t3.pm,
+            seriesData: e2,
+            sourceEvent: t3.vm
+        };
+    }
+}
+class TwChart {
+    constructor(t3, e2) {
+        this.series = [], this.colors = ["#725bf5", "#777777", "#1dcdbc", "#2b3440", "#ffffff", "#3abff8", "#36d399", "#fbbd23", "#f87272"], this.lightTheme = {
+            layout: {
+                textColor: "rgba(0, 0, 0, 0.5)"
+            }
+        }, this.darkTheme = {
+            layout: {
+                textColor: "rgba(255, 255, 255, 0.3)"
+            }
+        }, this.selectTheme = {
+            light: this.lightTheme,
+            dark: this.darkTheme
+        }, this.candlestickSeries = null, this.htmlEle = t3, this.series = [];
+        let i2 = {
+            autoSize: true,
+            localization: {
+                locale: "zh-TW",
+                dateFormat: "yyyy-MM-dd",
+                priceFormatter: (t4) => t4.toFixed(1)
+            },
+            rightPriceScale: {
+                scaleMargins: {
+                    top: 0.1,
+                    bottom: 0.1
+                },
+                mode: tc.Percentage,
+                borderVisible: false,
+                ticksVisible: true,
+                borderColor: "rgba(197, 203, 206, 1)"
+            },
+            timeScale: {
+                borderColor: "rgba(197, 203, 206, 1)",
+                borderVisible: false
+            },
+            handleScroll: {
+                pressedMouseMove: true,
+                mouseWheel: false
+            },
+            handleScale: {
+                mouseWheel: false,
+                pinch: true
+            },
+            layout: {
+                background: {
+                    type: cc.Solid,
+                    color: "transparent"
+                },
+                textColor: "black"
+            },
+            grid: {
+                vertLines: {
+                    color: "rgba(197, 203, 206, 0.0)",
+                    style: ml.Dotted,
+                    visible: false
+                },
+                horzLines: {
+                    color: "rgba(197, 203, 206, 0.0)",
+                    style: ml.Dotted,
+                    visible: false
+                }
+            },
+            crosshair: {
+                horzLine: {
+                    visible: false,
+                    labelVisible: true
+                },
+                vertLine: {
+                    visible: false,
+                    style: 0,
+                    width: 2,
+                    color: "rgba(32, 38, 46, 0.1)",
+                    labelVisible: true
+                }
+            }
+        };
+        e2 || (i2.rightPriceScale.mode = tc.Normal), this.chart = function(t4, e3) {
+            let i3;
+            if ($l(t4)) {
+                const e4 = document.getElementById(t4);
+                wl(null !== e4, `Cannot find element in DOM with id=${t4}`), i3 = e4;
+            } else
+                i3 = t4;
+            return new qs(i3, e3);
+        }(this.htmlEle, i2);
+    }
+    setTheme(t3) {
+        t3 && this.chart.applyOptions(this.selectTheme[t3]);
+    }
+    resetAreaSeries(t3) {
+        this.series[t3] && this.chart.removeSeries(this.series[t3]);
+        const e2 = this.colors[t3];
+        this.series[t3] = this.chart.addAreaSeries({
+            lineColor: e2,
+            topColor: e2 + "77",
+            bottomColor: e2 + "00",
+            priceLineVisible: false
+        });
+    }
+    setTimeScale(t3, e2) {
+        this.chart.timeScale().setVisibleRange({
+            from: t3.getTime() / 1e3,
+            to: e2.getTime() / 1e3
+        });
+    }
+    addCandlestickSeries() {
+        this.candlestickSeries && this.chart.removeSeries(this.candlestickSeries), this.candlestickSeries = this.chart.addCandlestickSeries({
+            upColor: "#4caf50",
+            downColor: "#f44336",
+            borderDownColor: "#f44336",
+            borderUpColor: "#4caf50",
+            wickDownColor: "#f44336",
+            wickUpColor: "#4caf50"
+        });
+    }
+    updateCandlestickSeriesData(t3) {
+        if (this.candlestickSeries) {
+            const e2 = t3.map((t4) => {
+                let e3;
+                return "string" != typeof t4.time ? null : (e3 = t4.time, {
+                    time: e3,
+                    open: t4.open,
+                    high: t4.high,
+                    low: t4.low,
+                    close: t4.close
+                });
+            }).filter((t4) => null !== t4);
+            this.candlestickSeries.setData(e2);
+        }
+    }
+}
+
+function vu(t3) {
+    return "red" === (t3 || "red") ? "#f16365" : "#1dcdbc";
+}
+
+function bu(t3) {
+    return "red" === (t3 || "red") ? "#1dcdbc" : "#f16365";
+}
+
+function _u(t3, e2, i2) {
+    const s2 = t3.slice();
+    return s2[19] = e2[i2], s2;
+}
+
+function wu(t3, e2, i2) {
+    const s2 = t3.slice();
+    return s2[22] = e2[i2], s2;
+}
+
+function xu(t3, e2, i2) {
+    const s2 = t3.slice();
+    return s2[22] = e2[i2], s2;
+}
+
+function ku(t3) {
+    let e2, i2, s2, n2, r2, o2, a2 = ue(t3[8]),
+        l2 = [];
+    for (let e3 = 0; e3 < a2.length; e3 += 1)
+        l2[e3] = Eu(xu(t3, a2, e3));
+    let h2 = ue(t3[4]),
+        c2 = [];
+    for (let e3 = 0; e3 < h2.length; e3 += 1)
+        c2[e3] = Iu(_u(t3, h2, e3));
+    return {
+        c() {
+            e2 = P("div"), i2 = P("table"), s2 = P("thead"), n2 = P("tr");
+            for (let t4 = 0; t4 < l2.length; t4 += 1)
+                l2[t4].c();
+            r2 = $(), o2 = P("tbody");
+            for (let t4 = 0; t4 < c2.length; t4 += 1)
+                c2[t4].c();
+            U(s2, "class", "sticky top-0 z-20"), U(o2, "class", "w-full overflow-x-scroll"), U(i2, "class", "table divide-y divide-gray-400 max-h-full overflow-x-auto"), U(e2, "class", "");
+        },
+        m(t4, a3) {
+            S(t4, e2, a3), _(e2, i2), _(i2, s2), _(s2, n2);
+            for (let t5 = 0; t5 < l2.length; t5 += 1)
+                l2[t5] && l2[t5].m(n2, null);
+            _(i2, r2), _(i2, o2);
+            for (let t5 = 0; t5 < c2.length; t5 += 1)
+                c2[t5] && c2[t5].m(o2, null);
+        },
+        p(t4, e3) {
+            if (302 & e3) {
+                let i3;
+                for (a2 = ue(t4[8]), i3 = 0; i3 < a2.length; i3 += 1) {
+                    const s3 = xu(t4, a2, i3);
+                    l2[i3] ? l2[i3].p(s3, e3) : (l2[i3] = Eu(s3), l2[i3].c(), l2[i3].m(n2, null));
+                }
+                for (; i3 < l2.length; i3 += 1)
+                    l2[i3].d(1);
+                l2.length = a2.length;
+            }
+            if (464 & e3) {
+                let i3;
+                for (h2 = ue(t4[4]), i3 = 0; i3 < h2.length; i3 += 1) {
+                    const s3 = _u(t4, h2, i3);
+                    c2[i3] ? c2[i3].p(s3, e3) : (c2[i3] = Iu(s3), c2[i3].c(), c2[i3].m(o2, null));
+                }
+                for (; i3 < c2.length; i3 += 1)
+                    c2[i3].d(1);
+                c2.length = h2.length;
+            }
+        },
+        d(t4) {
+            t4 && E(e2), C(l2, t4), C(c2, t4);
+        }
+    };
+}
+
+function Tu(t3) {
+    let e2, i2, s2, n2, r2, o2, a2, l2;
+    return {
+        c() {
+            e2 = R("svg"), i2 = R("g"), s2 = R("g"), n2 = R("g"), r2 = R("path"), a2 = R("path"), U(i2, "id", "SVGRepo_bgCarrier"), U(i2, "stroke-width", "0"), U(s2, "id", "SVGRepo_tracerCarrier"), U(s2, "stroke-linecap", "round"), U(s2, "stroke-linejoin", "round"), U(r2, "d", "M4 2C3.44772 2 3 2.44772 3 3C3 3.55228 3.44772 4 4 4H20C20.5523 4 21 3.55228 21 3C21 2.44772 20.5523 2 20 2H4Z"), U(r2, "fill", o2 = "dark" === t3[1] ? "#ffffff" : "black"), U(a2, "d", "M7.70711 15.2929L11 18.5858L11 8C11 7.44771 11.4477 7 12 7C12.5523 7 13 7.44771 13 8L13 18.5858L16.2929 15.2929C16.6834 14.9024 17.3166 14.9024 17.7071 15.2929C18.0976 15.6834 18.0976 16.3166 17.7071 16.7071L12.7071 21.7071C12.3166 22.0976 11.6834 22.0976 11.2929 21.7071L6.29289 16.7071C5.90237 16.3166 5.90237 15.6834 6.29289 15.2929C6.68342 14.9024 7.31658 14.9024 7.70711 15.2929Z"), U(a2, "fill", l2 = "dark" === t3[1] ? "#ffffff" : "black"), U(n2, "id", "SVGRepo_iconCarrier"), U(e2, "width", "12px"), U(e2, "height", "12px"), U(e2, "viewBox", "0 0 24 24"), U(e2, "fill", "none"), U(e2, "xmlns", "http://www.w3.org/2000/svg");
+        },
+        m(t4, o3) {
+            S(t4, e2, o3), _(e2, i2), _(e2, s2), _(e2, n2), _(n2, r2), _(n2, a2);
+        },
+        p(t4, e3) {
+            2 & e3 && o2 !== (o2 = "dark" === t4[1] ? "#ffffff" : "black") && U(r2, "fill", o2), 2 & e3 && l2 !== (l2 = "dark" === t4[1] ? "#ffffff" : "black") && U(a2, "fill", l2);
+        },
+        d(t4) {
+            t4 && E(e2);
+        }
+    };
+}
+
+function Su(t3) {
+    let e2, i2, s2, n2, r2, o2, a2, l2;
+    return {
+        c() {
+            e2 = R("svg"), i2 = R("g"), s2 = R("g"), n2 = R("g"), r2 = R("path"), a2 = R("path"), U(i2, "id", "SVGRepo_bgCarrier"), U(i2, "stroke-width", "0"), U(s2, "id", "SVGRepo_tracerCarrier"), U(r2, "d", "M6.29289 8.70711C6.68342 9.09763 7.31658 9.09763 7.70711 8.70711L11 5.41421L11 16C11 16.5523 11.4477 17 12 17C12.5523 17 13 16.5523 13 16L13 5.41421L16.2929 8.70711C16.6834 9.09763 17.3166 9.09763 17.7071 8.70711C18.0976 8.31658 18.0976 7.68342 17.7071 7.29289L12.7071 2.29289C12.3166 1.90237 11.6834 1.90237 11.2929 2.29289L6.29289 7.29289C5.90237 7.68342 5.90237 8.31658 6.29289 8.70711Z"), U(r2, "fill", o2 = "dark" === t3[1] ? "#ffffff" : "black"), U(a2, "d", "M4 22C3.44772 22 3 21.5523 3 21C3 20.4477 3.44772 20 4 20H20C20.5523 20 21 20.4477 21 21C21 21.5523 20.5523 22 20 22H4Z"), U(a2, "fill", l2 = "dark" === t3[1] ? "#ffffff" : "black"), U(n2, "id", "SVGRepo_iconCarrier"), U(e2, "width", "12px"), U(e2, "height", "12px"), U(e2, "viewBox", "0 0 24 24"), U(e2, "fill", "none"), U(e2, "xmlns", "http://www.w3.org/2000/svg");
+        },
+        m(t4, o3) {
+            S(t4, e2, o3), _(e2, i2), _(e2, s2), _(e2, n2), _(n2, r2), _(n2, a2);
+        },
+        p(t4, e3) {
+            2 & e3 && o2 !== (o2 = "dark" === t4[1] ? "#ffffff" : "black") && U(r2, "fill", o2), 2 & e3 && l2 !== (l2 = "dark" === t4[1] ? "#ffffff" : "black") && U(a2, "fill", l2);
+        },
+        d(t4) {
+            t4 && E(e2);
+        }
+    };
+}
+
+function Eu(t3) {
+    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2 = t3[5]("metrics.stocks." + t3[22]) + "";
+
+    function u2(t4, e3) {
+        return "dn" === t4[3] && t4[2] === t4[22] ? Su : "up" === t4[3] && t4[2] === t4[22] ? Tu : void 0;
+    }
+    let d2 = u2(t3),
+        f2 = d2 && d2(t3);
+
+    function p2() {
+        return t3[14](t3[22]);
+    }
+    return {
+        c() {
+            e2 = P("th"), i2 = P("button"), s2 = P("span"), n2 = D(c2), r2 = $(), o2 = P("span"), f2 && f2.c(), a2 = $(), U(o2, "class", "ml-1"), U(s2, "class", "break-keep flex cursor-pointer"), U(i2, "class", "badge badge-xs border-0 select-none hover:badge-primary hover:text-white p-3 ml-0 m-3 cursor-pointer rounded-md"), U(e2, "class", "whitespace-nowrap p-0 bg-base-200 " + ("stockId" === t3[22] ? "text-left sticky left-0" : "text-center"));
+        },
+        m(t4, c3) {
+            S(t4, e2, c3), _(e2, i2), _(i2, s2), _(s2, n2), _(s2, r2), _(s2, o2), f2 && f2.m(o2, null), _(e2, a2), l2 || (h2 = B(i2, "click", p2), l2 = true);
+        },
+        p(e3, i3) {
+            t3 = e3, 32 & i3 && c2 !== (c2 = t3[5]("metrics.stocks." + t3[22]) + "") && H(n2, c2), d2 === (d2 = u2(t3)) && f2 ? f2.p(t3, i3) : (f2 && f2.d(1), f2 = d2 && d2(t3), f2 && (f2.c(), f2.m(o2, null)));
+        },
+        d(t4) {
+            t4 && E(e2), f2 && f2.d(), l2 = false, h2();
+        }
+    };
+}
+
+function Cu(t3) {
+    let e2, i2, s2, n2 = (t3[22] in t3[6] ? t3[6][t3[22]](t3[19][t3[22]]) : t3[19][t3[22]]) + "";
+    return {
+        c() {
+            e2 = P("td"), i2 = D(n2), U(e2, "class", `whitespace-nowrap w-24 pr-2 py-1 p-0 ${"stockId" === t3[22] ? "text-left sticky left-0 z-10 bg-base-200" : "text-center"} `), U(e2, "style", s2 = `color: ${t3[22] in t3[7] ? t3[7][t3[22]](t3[19][t3[22]]) : ""}`);
+        },
+        m(t4, s3) {
+            S(t4, e2, s3), _(e2, i2);
+        },
+        p(t4, r2) {
+            16 & r2 && n2 !== (n2 = (t4[22] in t4[6] ? t4[6][t4[22]](t4[19][t4[22]]) : t4[19][t4[22]]) + "") && H(i2, n2), 16 & r2 && s2 !== (s2 = `color: ${t4[22] in t4[7] ? t4[7][t4[22]](t4[19][t4[22]]) : ""}`) && U(e2, "style", s2);
+        },
+        d(t4) {
+            t4 && E(e2);
+        }
+    };
+}
+
+function Iu(t3) {
+    let e2, i2, s2 = ue(t3[8]),
+        n2 = [];
+    for (let e3 = 0; e3 < s2.length; e3 += 1)
+        n2[e3] = Cu(wu(t3, s2, e3));
+    return {
+        c() {
+            e2 = P("tr");
+            for (let t4 = 0; t4 < n2.length; t4 += 1)
+                n2[t4].c();
+            i2 = $(), U(e2, "class", "hover py-0 pl-0");
+        },
+        m(t4, s3) {
+            S(t4, e2, s3);
+            for (let t5 = 0; t5 < n2.length; t5 += 1)
+                n2[t5] && n2[t5].m(e2, null);
+            _(e2, i2);
+        },
+        p(t4, r2) {
+            if (464 & r2) {
+                let o2;
+                for (s2 = ue(t4[8]), o2 = 0; o2 < s2.length; o2 += 1) {
+                    const a2 = wu(t4, s2, o2);
+                    n2[o2] ? n2[o2].p(a2, r2) : (n2[o2] = Cu(a2), n2[o2].c(), n2[o2].m(e2, i2));
+                }
+                for (; o2 < n2.length; o2 += 1)
+                    n2[o2].d(1);
+                n2.length = s2.length;
+            }
+        },
+        d(t4) {
+            t4 && E(e2), C(n2, t4);
+        }
+    };
+}
+
+function Mu(e2) {
+    let i2, s2 = e2[0] && 0 != e2[0].trades.length && ku(e2);
+    return {
+        c() {
+            s2 && s2.c(), i2 = z();
+        },
+        m(t3, e3) {
+            s2 && s2.m(t3, e3), S(t3, i2, e3);
+        },
+        p(t3, [e3]) {
+            t3[0] && 0 != t3[0].trades.length ? s2 ? s2.p(t3, e3) : (s2 = ku(t3), s2.c(), s2.m(i2.parentNode, i2)) : s2 && (s2.d(1), s2 = null);
+        },
+        i: t,
+        o: t,
+        d(t3) {
+            t3 && E(i2), s2 && s2.d(t3);
+        }
+    };
+}
+
+function Pu(t3, e2, i2) {
+    let s2, {
+            lang: n2 = "en"
+        } = e2,
+        {
+            browser: r2
+        } = e2,
+        {
+            report: o2
+        } = e2,
+        {
+            theme: a2 = "light"
+        } = e2,
+        {
+            candle: l2 = "red"
+        } = e2,
+        {
+            tstart: h2 = null
+        } = e2,
+        {
+            tend: c2 = null
+        } = e2;
+    pt(() => {});
+    const u2 = (t4) => t4 ? t4 == null ? void 0 : t4.toLocaleDateString() : null,
+        d2 = (t4) => (100 * t4).toFixed(1) + "%",
+        f2 = {
+            entry: u2,
+            exit: u2,
+            entrySig: u2,
+            exitSig: u2,
+            position: d2,
+            return: d2,
+            mae: d2,
+            gmfe: d2,
+            bmfe: d2,
+            mdd: d2
+        },
+        p2 = (t4) => t4 > 0 ? vu(l2) : bu(l2),
+        m2 = (t4) => h2 <= t4 && t4 <= c2 ? "underline" : "",
+        g2 = {
+            entry: m2,
+            exit: m2,
+            position: p2,
+            return: p2,
+            mae: p2,
+            mfe: p2,
+            mdd: p2,
+            gmfe: p2,
+            bmfe: p2
+        };
+    let y2 = "entry",
+        v2 = "dn",
+        b2 = [];
+    return t3.$$set = (t4) => {
+        "lang" in t4 && i2(9, n2 = t4.lang), "browser" in t4 && i2(10, r2 = t4.browser), "report" in t4 && i2(0, o2 = t4.report), "theme" in t4 && i2(1, a2 = t4.theme), "candle" in t4 && i2(11, l2 = t4.candle), "tstart" in t4 && i2(12, h2 = t4.tstart), "tend" in t4 && i2(13, c2 = t4.tend);
+    }, t3.$$.update = () => {
+        512 & t3.$$.dirty && i2(5, s2 = (t4) => "en" === n2 ? sl(t4) : nl(t4)), 12317 & t3.$$.dirty && (o2 || h2 || c2) && (i2(4, b2 = o2.trades.sort((t4, e3) => "up" === v2 ? t4[y2] > e3[y2] ? 1 : -1 : t4[y2] < e3[y2] ? 1 : -1)), h2 && c2 && i2(4, b2 = b2.filter((t4) => t4.entry && t4.exit && (t4.entry <= h2 && h2 <= t4.exit || t4.entry <= c2 && c2 <= t4.exit))), i2(4, b2 = b2.slice(0, 50).filter((t4) => Object.values(t4).every((t5) => null !== t5))));
+    }, [o2, a2, y2, v2, b2, s2, f2, g2, ["stockId", "return", "entry", "exit", "position", "entryPrice", "exitPrice", "entrySig", "exitSig", "mae", "gmfe", "bmfe", "mdd"], n2, r2, l2, h2, c2, (t4) => {
+        y2 !== t4 ? i2(2, y2 = t4) : i2(3, v2 = {
+            up: "dn",
+            dn: "up"
+        } [v2]);
+    }];
+}
+class Stocks extends SvelteComponent {
+    constructor(t3) {
+        super(), ve(this, t3, Pu, Mu, o, {
+            lang: 9,
+            browser: 10,
+            report: 0,
+            theme: 1,
+            candle: 11,
+            tstart: 12,
+            tend: 13
+        });
+    }
+    get lang() {
+        return this.$$.ctx[9];
+    }
+    set lang(t3) {
+        this.$$set({
+            lang: t3
+        }), te();
+    }
+    get browser() {
+        return this.$$.ctx[10];
+    }
+    set browser(t3) {
+        this.$$set({
+            browser: t3
+        }), te();
+    }
+    get report() {
+        return this.$$.ctx[0];
+    }
+    set report(t3) {
+        this.$$set({
+            report: t3
+        }), te();
+    }
+    get theme() {
+        return this.$$.ctx[1];
+    }
+    set theme(t3) {
+        this.$$set({
+            theme: t3
+        }), te();
+    }
+    get candle() {
+        return this.$$.ctx[11];
+    }
+    set candle(t3) {
+        this.$$set({
+            candle: t3
+        }), te();
+    }
+    get tstart() {
+        return this.$$.ctx[12];
+    }
+    set tstart(t3) {
+        this.$$set({
+            tstart: t3
+        }), te();
+    }
+    get tend() {
+        return this.$$.ctx[13];
+    }
+    set tend(t3) {
+        this.$$set({
+            tend: t3
+        }), te();
+    }
+}
+
+function Ru(e2) {
+    let i2, s2;
+    return {
+        c() {
+            i2 = R("svg"), s2 = R("use"), U(s2, "href", e2[3]), U(s2, "fill", e2[0]), U(s2, "stroke", e2[1]), U(i2, "class", e2[2]), U(i2, "aria-hidden", "true");
+        },
+        m(t3, e3) {
+            S(t3, i2, e3), _(i2, s2);
+        },
+        p(t3, [e3]) {
+            8 & e3 && U(s2, "href", t3[3]), 1 & e3 && U(s2, "fill", t3[0]), 2 & e3 && U(s2, "stroke", t3[1]), 4 & e3 && U(i2, "class", t3[2]);
+        },
+        i: t,
+        o: t,
+        d(t3) {
+            t3 && E(i2);
+        }
+    };
+}
+
+function Au(t3, e2, i2) {
+    let s2, {
+            prefix: n2 = "icon"
+        } = e2,
+        {
+            name: r2 = ""
+        } = e2,
+        {
+            color: o2 = "#333"
+        } = e2,
+        {
+            strokeColor: a2 = ""
+        } = e2,
+        {
+            className: l2 = ""
+        } = e2;
+    return t3.$$set = (t4) => {
+        "prefix" in t4 && i2(4, n2 = t4.prefix), "name" in t4 && i2(5, r2 = t4.name), "color" in t4 && i2(0, o2 = t4.color), "strokeColor" in t4 && i2(1, a2 = t4.strokeColor), "className" in t4 && i2(2, l2 = t4.className);
+    }, t3.$$.update = () => {
+        48 & t3.$$.dirty && i2(3, s2 = `#${n2}-${r2}`);
+    }, [o2, a2, l2, s2, n2, r2];
+}
+we(Stocks, {
+    lang: {},
+    browser: {},
+    report: {},
+    theme: {},
+    candle: {},
+    tstart: {},
+    tend: {}
+}, [], [], true);
+let Du = class Svgicon extends SvelteComponent {
+    constructor(t3) {
+        super(), ve(this, t3, Au, Ru, o, {
+            prefix: 4,
+            name: 5,
+            color: 0,
+            strokeColor: 1,
+            className: 2
+        });
+    }
+    get prefix() {
+        return this.$$.ctx[4];
+    }
+    set prefix(t3) {
+        this.$$set({
+            prefix: t3
+        }), te();
+    }
+    get name() {
+        return this.$$.ctx[5];
+    }
+    set name(t3) {
+        this.$$set({
+            name: t3
+        }), te();
+    }
+    get color() {
+        return this.$$.ctx[0];
+    }
+    set color(t3) {
+        this.$$set({
+            color: t3
+        }), te();
+    }
+    get strokeColor() {
+        return this.$$.ctx[1];
+    }
+    set strokeColor(t3) {
+        this.$$set({
+            strokeColor: t3
+        }), te();
+    }
+    get className() {
+        return this.$$.ctx[2];
+    }
+    set className(t3) {
+        this.$$set({
+            className: t3
+        }), te();
+    }
+};
+
+function Lu() {
+    const t3 = navigator.userAgent || navigator.vendor;
+    return /iPad|iPhone|iPod|android/i.test(t3);
+}
+
+function Ou() {
+    return window.self !== window.top;
+}
+
+function Fu(t3) {
+    w(t3, "svelte-13tqbdu", ".grid-cols-14.svelte-13tqbdu{grid-template-columns:repeat(14, minmax(0, 1fr))}");
+}
+
+function Nu(t3, e2, i2) {
+    const s2 = t3.slice();
+    return s2[50] = e2[i2], s2;
+}
+
+function $u(t3, e2, i2) {
+    const s2 = t3.slice();
+    return s2[53] = e2[i2], s2;
+}
+
+function Vu(t3, e2, i2) {
+    const s2 = t3.slice();
+    return s2[53] = e2[i2], s2;
+}
+
+function zu(t3, e2, i2) {
+    const s2 = t3.slice();
+    return s2[50] = e2[i2], s2;
+}
+
+function Bu(t3) {
+    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2 = t3[50] + "",
+        d2 = (100 * t3[6][t3[50]] || 0).toFixed(1) + "";
+
+    function f2() {
+        return t3[35](t3[50]);
+    }
+    return {
+        c() {
+            e2 = P("div"), i2 = P("span"), s2 = D(u2), n2 = $(), r2 = P("button"), o2 = D(d2), a2 = D("%"), U(i2, "class", "text-sm border-l pl-1"), U(r2, "class", "w-full py-1 px-2 text-sm"), U(r2, "style", l2 = `background:${t3[13][`${t3[50]}`]}`), U(e2, "class", "flex-l");
+        },
+        m(t4, l3) {
+            S(t4, e2, l3), _(e2, i2), _(i2, s2), _(e2, n2), _(e2, r2), _(r2, o2), _(r2, a2), h2 || (c2 = B(r2, "click", f2), h2 = true);
+        },
+        p(e3, i3) {
+            t3 = e3, 50331648 & i3[0] && u2 !== (u2 = t3[50] + "") && H(s2, u2), 50331712 & i3[0] && d2 !== (d2 = (100 * t3[6][t3[50]] || 0).toFixed(1) + "") && H(o2, d2), 50339840 & i3[0] && l2 !== (l2 = `background:${t3[13][`${t3[50]}`]}`) && U(r2, "style", l2);
+        },
+        d(t4) {
+            t4 && E(e2), h2 = false, c2();
+        }
+    };
+}
+
+function Uu(e2) {
+    let i2;
+    return {
+        c() {
+            i2 = P("div"), i2.textContent = `${e2[53]} 月`, U(i2, "class", "flex justify-center items-center");
+        },
+        m(t3, e3) {
+            S(t3, i2, e3);
+        },
+        p: t,
+        d(t3) {
+            t3 && E(i2);
+        }
+    };
+}
+
+function ju(t3) {
+    let e2, i2, s2, n2, r2, o2, a2, l2 = Ku((100 * (t3[7][`${t3[50]}${t3[53]}`] || 0)).toFixed(1)) + "";
+
+    function h2() {
+        return t3[37](t3[50], t3[53]);
+    }
+    return {
+        c() {
+            e2 = P("div"), i2 = D(l2), s2 = D("%"), U(e2, "class", n2 = f(`cursor-pointer flex justify-center items-center hover:text-base-content-300 hover:z-20 hover:outline hover:shadow-primary hover:outline-2 hover:outline-primary hover:border-none hover:rounded-lg hover:font-bold hover:text-2xl hover:-m-3 hover:shadow-lg 
+								${t3[50] === t3[10] ? "border-t-2 border-b-2 border-primary" : ""} 								${t3[50] === t3[10] && 1 == t3[53] ? "border-l-2 border-primary rounded-l-lg" : ""} 								${t3[50] === t3[10] && 12 == t3[53] ? "border-r-2 border-primary rounded-r-lg" : ""} 								${t3[53] === t3[9] && t3[50] === t3[10] ? "text-base-content-300 text-2xl -m-4 font-bold outline shadow-primary outline-2 outline-primary border-none rounded-lg z-20 shadow-2xl" : ""}`) + " svelte-13tqbdu"), U(e2, "style", r2 = `background:${t3[12][`${t3[50]}${t3[53]}`]}`);
+        },
+        m(t4, n3) {
+            S(t4, e2, n3), _(e2, i2), _(e2, s2), o2 || (a2 = B(e2, "click", h2), o2 = true);
+        },
+        p(s3, o3) {
+            t3 = s3, 50331776 & o3[0] && l2 !== (l2 = Ku((100 * (t3[7][`${t3[50]}${t3[53]}`] || 0)).toFixed(1)) + "") && H(i2, l2), 50333184 & o3[0] && n2 !== (n2 = f(`cursor-pointer flex justify-center items-center hover:text-base-content-300 hover:z-20 hover:outline hover:shadow-primary hover:outline-2 hover:outline-primary hover:border-none hover:rounded-lg hover:font-bold hover:text-2xl hover:-m-3 hover:shadow-lg 
+								${t3[50] === t3[10] ? "border-t-2 border-b-2 border-primary" : ""} 								${t3[50] === t3[10] && 1 == t3[53] ? "border-l-2 border-primary rounded-l-lg" : ""} 								${t3[50] === t3[10] && 12 == t3[53] ? "border-r-2 border-primary rounded-r-lg" : ""} 								${t3[53] === t3[9] && t3[50] === t3[10] ? "text-base-content-300 text-2xl -m-4 font-bold outline shadow-primary outline-2 outline-primary border-none rounded-lg z-20 shadow-2xl" : ""}`) + " svelte-13tqbdu") && U(e2, "class", n2), 50335744 & o3[0] && r2 !== (r2 = `background:${t3[12][`${t3[50]}${t3[53]}`]}`) && U(e2, "style", r2);
+        },
+        d(t4) {
+            t4 && E(e2), o2 = false, a2();
+        }
+    };
+}
+
+function Hu(t3) {
+    let e2, i2, s2, n2, r2, o2, a2, l2 = t3[50] + "",
+        h2 = t3[50] + "",
+        c2 = ue([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]),
+        u2 = [];
+    for (let e3 = 0; e3 < 12; e3 += 1)
+        u2[e3] = ju($u(t3, c2, e3));
+    return {
+        c() {
+            e2 = P("div"), i2 = D(l2), s2 = $();
+            for (let t4 = 0; t4 < 12; t4 += 1)
+                u2[t4].c();
+            n2 = $(), r2 = P("div"), o2 = D(h2), a2 = $(), U(e2, "class", "h-7 md:h-10 flex justify-start items-center"), U(r2, "class", "flex justify-center items-center border border-base-content/0");
+        },
+        m(t4, l3) {
+            S(t4, e2, l3), _(e2, i2), S(t4, s2, l3);
+            for (let e3 = 0; e3 < 12; e3 += 1)
+                u2[e3] && u2[e3].m(t4, l3);
+            S(t4, n2, l3), S(t4, r2, l3), _(r2, o2), _(r2, a2);
+        },
+        p(t4, e3) {
+            if (50331648 & e3[0] && l2 !== (l2 = t4[50] + "") && H(i2, l2), 520099504 & e3[0]) {
+                let i3;
+                for (c2 = ue([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]), i3 = 0; i3 < 12; i3 += 1) {
+                    const s3 = $u(t4, c2, i3);
+                    u2[i3] ? u2[i3].p(s3, e3) : (u2[i3] = ju(s3), u2[i3].c(), u2[i3].m(n2.parentNode, n2));
+                }
+                for (; i3 < 12; i3 += 1)
+                    u2[i3].d(1);
+            }
+            50331648 & e3[0] && h2 !== (h2 = t4[50] + "") && H(o2, h2);
+        },
+        d(t4) {
+            t4 && (E(e2), E(s2), E(n2), E(r2)), C(u2, t4);
+        }
+    };
+}
+
+function Wu(t3) {
+    var _a2, _b2;
+    let e2, i2, s2, n2 = ((_a2 = t3[23]) == null ? void 0 : _a2.toLocaleDateString()) + "",
+        r2 = ((_b2 = t3[22]) == null ? void 0 : _b2.toLocaleDateString()) + "";
+    return {
+        c() {
+            e2 = D(n2), i2 = D("~"), s2 = D(r2);
+        },
+        m(t4, n3) {
+            S(t4, e2, n3), S(t4, i2, n3), S(t4, s2, n3);
+        },
+        p(t4, i3) {
+            var _a3, _b3;
+            8388608 & i3[0] && n2 !== (n2 = ((_a3 = t4[23]) == null ? void 0 : _a3.toLocaleDateString()) + "") && H(e2, n2), 4194304 & i3[0] && r2 !== (r2 = ((_b3 = t4[22]) == null ? void 0 : _b3.toLocaleDateString()) + "") && H(s2, r2);
+        },
+        d(t4) {
+            t4 && (E(e2), E(i2), E(s2));
+        }
+    };
+}
+
+function qu(t3) {
+    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2, d2, p2, m2, g2, y2, v2, b2, w2, x2, k2, T2, R2, z2, j2, q2, Y2, it2, st2, rt2, ht2, ct2, ut2, dt2, ft2, pt2, yt2, bt2, _t2, xt2, kt2, St2, It2, Mt2, At2, Lt2, Ot2, Ht2, Qt2, Jt2, te2, ee2, ie2, se2, ne2, re2, oe2, ae2, ce2, de2, fe2, pe2, ve2, be2, _e2, we2, xe2, ke2, Te2, Se2, Ee2, Ce2, Ie2, Me2, Pe2, Re2, Ae2, De2, Le2, Oe2, Fe2, Ne2, $e2, Ve2, ze2, Be2, Ue2, je2, He2, We2, qe2, Ke2, Ge2, Ye2, Qe2, Xe2, Je2, Ze2, ti2, ei2, si2 = t3[19]("profitability.historicalReturn") + "",
+        ni2 = (t3[4] < 10 ? "0" + t3[4] : t3[4]) + "",
+        ri2 = t3[19]("profitability.monthlyReturn") + "",
+        ai2 = t3[19]("profitability.avgMonthlyReturn") + "",
+        li2 = Ku((100 * t3[21]).toFixed(2)) + "",
+        hi2 = t3[19]("profitability.monthlyWinRatio") + "",
+        ci2 = t3[20].toFixed(1) + "",
+        ui2 = t3[19]("profitability.monthlyReturn") + "",
+        yi2 = t3[19]("profitability.stockList") + "",
+        _i2 = t3[19]("profitability.YearlyCompareWithBenchmark") + "",
+        ki2 = t3[19]("profitability.yearlyWinRate") + "",
+        Ti2 = t3[15] + t3[16] + "",
+        Si2 = t3[19]("profitability.year") + "",
+        Ei2 = t3[19]("strategy") + "",
+        Ii2 = t3[19]("benchmark") + "",
+        Li2 = t3[19]("profitability.exceedReturn") + "",
+        Oi2 = t3[19]("average") + "",
+        Fi2 = Ku((100 * t3[14]).toFixed(2)) + "",
+        Ni2 = t3[19]("strategy") + "",
+        Vi2 = ue(Array.from(Array(t3[24] + 1).keys()).slice(t3[25])),
+        zi2 = [];
+    for (let e3 = 0; e3 < Vi2.length; e3 += 1)
+        zi2[e3] = Bu(zu(t3, Vi2, e3));
+    let Ui2 = ue([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]),
+        ji2 = [];
+    for (let e3 = 0; e3 < 12; e3 += 1)
+        ji2[e3] = Uu(Vu(t3, Ui2, e3));
+    let Wi2 = ue(Array.from(Array(t3[24] + 1).keys()).slice(t3[25])),
+        qi2 = [];
+    for (let e3 = 0; e3 < Wi2.length; e3 += 1)
+        qi2[e3] = Hu(Nu(t3, Wi2, e3));
+    let Gi2 = t3[5] && Wu(t3);
+    return re2 = new Stocks({
+        props: {
+            lang: t3[3],
+            report: t3[1],
+            theme: t3[2],
+            browser: t3[0],
+            tstart: t3[23],
+            tend: t3[22]
+        }
+    }), {
+        c() {
+            e2 = P("div"), i2 = P("div"), s2 = P("div"), n2 = P("h3"), r2 = D(si2), o2 = $(), a2 = P("div"), l2 = P("div"), h2 = $(), c2 = P("div"), u2 = D(t3[5]), d2 = D("-"), p2 = D(ni2), m2 = $(), g2 = P("div"), y2 = P("div");
+            for (let t4 = 0; t4 < zi2.length; t4 += 1)
+                zi2[t4].c();
+            v2 = $(), b2 = P("div"), w2 = P("button"), w2.textContent = "reset", x2 = $(), k2 = P("div"), T2 = P("h3"), R2 = D(ri2), z2 = $(), j2 = P("div"), q2 = P("span"), Y2 = D(ai2), it2 = D("："), st2 = D(li2), rt2 = D("%"), ht2 = $(), ct2 = P("span"), ut2 = D(hi2), dt2 = D("："), ft2 = D(ci2), pt2 = D("%"), yt2 = $(), bt2 = P("div"), _t2 = P("div"), xt2 = P("div"), kt2 = P("div"), St2 = D(ui2), It2 = $();
+            for (let t4 = 0; t4 < 12; t4 += 1)
+                ji2[t4].c();
+            Mt2 = $(), At2 = P("div"), Lt2 = $();
+            for (let t4 = 0; t4 < qi2.length; t4 += 1)
+                qi2[t4].c();
+            Ot2 = $(), Ht2 = P("div"), Qt2 = P("h3"), Jt2 = D(yi2), te2 = $(), ee2 = P("h4"), Gi2 && Gi2.c(), ie2 = $(), se2 = P("div"), ne2 = P("div"), me(re2.$$.fragment), oe2 = $(), ae2 = P("div"), ce2 = P("h3"), de2 = D(_i2), fe2 = $(), pe2 = P("div"), ve2 = P("span"), be2 = D(ki2), _e2 = D("："), we2 = $(), xe2 = D(t3[15]), ke2 = D(" / "), Te2 = D(Ti2), Se2 = $(), Ee2 = D(Si2), Ce2 = $(), Ie2 = P("div"), Me2 = P("div"), Pe2 = P("div"), Re2 = D(Ei2), Ae2 = $(), De2 = P("div"), Le2 = D(Ii2), Oe2 = $(), Fe2 = P("canvas"), Ne2 = $(), $e2 = P("div"), Ve2 = P("h3"), ze2 = D(Li2), Be2 = $(), Ue2 = P("div"), je2 = P("span"), He2 = D(Oi2), We2 = D("："), qe2 = D(Fi2), Ke2 = D("%\n			"), Ge2 = P("div"), Ye2 = P("div"), Qe2 = D(Ni2), Xe2 = $(), Je2 = P("canvas"), U(n2, "class", "text-2xl font-bold text-base-content-200"), U(l2, "class", "text-primary h-64 z-0"), U(c2, "class", "absolute bg-primary/10 rounded-lg font-bold text-center whitespace-nowrap text-base-content-100 text-sm flex justify-center items-start pt-2"), U(a2, "class", "relative overflow-hidden -mt-8"), U(w2, "class", "mt-6 py-1 px-2 bg-base-100"), U(b2, "class", "flex-l text-center text-sm"), U(y2, "class", "flex text-base-content-300 my-6"), U(g2, "class", "relative w-full overflow-x-auto no-scrollbar"), U(s2, "class", ""), U(i2, "class", "col-span-6 md:col-span-6 md:p-8 pt-8 md:border rounded-xl"), U(T2, "class", "text-base-content-200 text-2xl font-bold"), U(ct2, "class", "ml-4"), U(j2, "class", "flex mt-2 text-base-content-100"), U(kt2, "class", "h-5 md:h-10 flex justify-start items-center"), U(At2, "class", "flex justify-center items-center"), U(xt2, "class", "grid grid-cols-14 mt-3 text-xs text-base-content-200 rounded-xl min-w-[640px] pb-4 overflow-y-hidden svelte-13tqbdu"), U(_t2, "class", f(`overflow-x-auto
+				${Lu() ? "no-scrollbar" : "show-scrollbar"}
+			`) + " svelte-13tqbdu"), U(bt2, "class", "relative"), U(k2, "class", "col-span-6 md:col-span-6 md:p-8 pt-8 md:border sm:rounded-xl"), U(Qt2, "class", "text-base-content-200 text-2xl font-bold md:text-center"), U(ee2, "class", "mt-2 text-base-content-100 md:text-center"), U(ne2, "class", f(`overflow-auto max-h-72 text-base-content
+				${Lu() ? "no-scrollbar" : "show-scrollbar"}
+				`) + " svelte-13tqbdu"), U(se2, "class", "relative"), U(Ht2, "class", "col-span-6 md:col-span-6 md:p-8 pt-8 md:border sm:rounded-xl"), U(ce2, "class", "text-base-content-200 text-2xl font-bold md:text-center"), U(pe2, "class", "mt-2 text-base-content-100 md:text-center"), U(Pe2, "class", "badge rounded bg-primary text-white mr-2"), U(De2, "class", "badge rounded bg-gray-500 text-white"), U(Me2, "class", "text-sm mt-2 flex md:justify-center"), U(Fe2, "class", "h-48 mt-4"), G(Fe2, "width", "580px"), U(ae2, "class", "col-span-6 md:col-span-3 md:p-8 pt-8 md:border sm:rounded-xl"), U(Ve2, "class", "text-base-content-200 text-2xl font-bold md:text-center"), U(Ye2, "class", "badge rounded badge-primary text-white"), U(Ge2, "class", "text-sm mt-2 flex md:justify-center"), U(Je2, "class", "h-48 mt-4"), G(Je2, "width", "580px"), U(Ue2, "class", "mt-2 text-base-content-100 md:text-center"), U($e2, "class", "col-span-6 md:col-span-3 md:p-8 pt-8 md:border sm:rounded-xl"), U(e2, "class", "grid grid-cols-6 mb-2 gap-4");
+        },
+        m(f2, E2) {
+            S(f2, e2, E2), _(e2, i2), _(i2, s2), _(s2, n2), _(n2, r2), _(s2, o2), _(s2, a2), _(a2, l2), t3[33](l2), _(a2, h2), _(a2, c2), _(c2, u2), _(c2, d2), _(c2, p2), t3[34](c2), _(s2, m2), _(s2, g2), _(g2, y2);
+            for (let t4 = 0; t4 < zi2.length; t4 += 1)
+                zi2[t4] && zi2[t4].m(y2, null);
+            _(y2, v2), _(y2, b2), _(b2, w2), _(e2, x2), _(e2, k2), _(k2, T2), _(T2, R2), _(k2, z2), _(k2, j2), _(j2, q2), _(q2, Y2), _(q2, it2), _(q2, st2), _(q2, rt2), _(j2, ht2), _(j2, ct2), _(ct2, ut2), _(ct2, dt2), _(ct2, ft2), _(ct2, pt2), _(k2, yt2), _(k2, bt2), _(bt2, _t2), _(_t2, xt2), _(xt2, kt2), _(kt2, St2), _(xt2, It2);
+            for (let t4 = 0; t4 < 12; t4 += 1)
+                ji2[t4] && ji2[t4].m(xt2, null);
+            _(xt2, Mt2), _(xt2, At2), _(xt2, Lt2);
+            for (let t4 = 0; t4 < qi2.length; t4 += 1)
+                qi2[t4] && qi2[t4].m(xt2, null);
+            _(e2, Ot2), _(e2, Ht2), _(Ht2, Qt2), _(Qt2, Jt2), _(Ht2, te2), _(Ht2, ee2), Gi2 && Gi2.m(ee2, null), _(Ht2, ie2), _(Ht2, se2), _(se2, ne2), ge(re2, ne2, null), _(e2, oe2), _(e2, ae2), _(ae2, ce2), _(ce2, de2), _(ae2, fe2), _(ae2, pe2), _(pe2, ve2), _(ve2, be2), _(ve2, _e2), _(pe2, we2), _(pe2, xe2), _(pe2, ke2), _(pe2, Te2), _(pe2, Se2), _(pe2, Ee2), _(ae2, Ce2), _(ae2, Ie2), _(Ie2, Me2), _(Me2, Pe2), _(Pe2, Re2), _(Me2, Ae2), _(Me2, De2), _(De2, Le2), _(Ie2, Oe2), _(Ie2, Fe2), t3[38](Fe2), _(e2, Ne2), _(e2, $e2), _($e2, Ve2), _(Ve2, ze2), _($e2, Be2), _($e2, Ue2), _(Ue2, je2), _(je2, He2), _(je2, We2), _(Ue2, qe2), _(Ue2, Ke2), _(Ue2, Ge2), _(Ge2, Ye2), _(Ye2, Qe2), _(Ue2, Xe2), _(Ue2, Je2), t3[39](Je2), Ze2 = true, ti2 || (ei2 = B(w2, "click", t3[36]), ti2 = true);
+        },
+        p(t4, e3) {
+            if ((!Ze2 || 524288 & e3[0]) && si2 !== (si2 = t4[19]("profitability.historicalReturn") + "") && H(r2, si2), (!Ze2 || 32 & e3[0]) && H(u2, t4[5]), (!Ze2 || 16 & e3[0]) && ni2 !== (ni2 = (t4[4] < 10 ? "0" + t4[4] : t4[4]) + "") && H(p2, ni2), 452994112 & e3[0]) {
+                let i4;
+                for (Vi2 = ue(Array.from(Array(t4[24] + 1).keys()).slice(t4[25])), i4 = 0; i4 < Vi2.length; i4 += 1) {
+                    const s3 = zu(t4, Vi2, i4);
+                    zi2[i4] ? zi2[i4].p(s3, e3) : (zi2[i4] = Bu(s3), zi2[i4].c(), zi2[i4].m(y2, v2));
+                }
+                for (; i4 < zi2.length; i4 += 1)
+                    zi2[i4].d(1);
+                zi2.length = Vi2.length;
+            }
+            if ((!Ze2 || 524288 & e3[0]) && ri2 !== (ri2 = t4[19]("profitability.monthlyReturn") + "") && H(R2, ri2), (!Ze2 || 524288 & e3[0]) && ai2 !== (ai2 = t4[19]("profitability.avgMonthlyReturn") + "") && H(Y2, ai2), (!Ze2 || 2097152 & e3[0]) && li2 !== (li2 = Ku((100 * t4[21]).toFixed(2)) + "") && H(st2, li2), (!Ze2 || 524288 & e3[0]) && hi2 !== (hi2 = t4[19]("profitability.monthlyWinRatio") + "") && H(ut2, hi2), (!Ze2 || 1048576 & e3[0]) && ci2 !== (ci2 = t4[20].toFixed(1) + "") && H(ft2, ci2), (!Ze2 || 524288 & e3[0]) && ui2 !== (ui2 = t4[19]("profitability.monthlyReturn") + "") && H(St2, ui2), 520099504 & e3[0]) {
+                let i4;
+                for (Wi2 = ue(Array.from(Array(t4[24] + 1).keys()).slice(t4[25])), i4 = 0; i4 < Wi2.length; i4 += 1) {
+                    const s3 = Nu(t4, Wi2, i4);
+                    qi2[i4] ? qi2[i4].p(s3, e3) : (qi2[i4] = Hu(s3), qi2[i4].c(), qi2[i4].m(xt2, null));
+                }
+                for (; i4 < qi2.length; i4 += 1)
+                    qi2[i4].d(1);
+                qi2.length = Wi2.length;
+            }
+            (!Ze2 || 524288 & e3[0]) && yi2 !== (yi2 = t4[19]("profitability.stockList") + "") && H(Jt2, yi2), t4[5] ? Gi2 ? Gi2.p(t4, e3) : (Gi2 = Wu(t4), Gi2.c(), Gi2.m(ee2, null)) : Gi2 && (Gi2.d(1), Gi2 = null);
+            const i3 = {};
+            8 & e3[0] && (i3.lang = t4[3]), 2 & e3[0] && (i3.report = t4[1]), 4 & e3[0] && (i3.theme = t4[2]), 1 & e3[0] && (i3.browser = t4[0]), 8388608 & e3[0] && (i3.tstart = t4[23]), 4194304 & e3[0] && (i3.tend = t4[22]), re2.$set(i3), (!Ze2 || 524288 & e3[0]) && _i2 !== (_i2 = t4[19]("profitability.YearlyCompareWithBenchmark") + "") && H(de2, _i2), (!Ze2 || 524288 & e3[0]) && ki2 !== (ki2 = t4[19]("profitability.yearlyWinRate") + "") && H(be2, ki2), (!Ze2 || 32768 & e3[0]) && H(xe2, t4[15]), (!Ze2 || 98304 & e3[0]) && Ti2 !== (Ti2 = t4[15] + t4[16] + "") && H(Te2, Ti2), (!Ze2 || 524288 & e3[0]) && Si2 !== (Si2 = t4[19]("profitability.year") + "") && H(Ee2, Si2), (!Ze2 || 524288 & e3[0]) && Ei2 !== (Ei2 = t4[19]("strategy") + "") && H(Re2, Ei2), (!Ze2 || 524288 & e3[0]) && Ii2 !== (Ii2 = t4[19]("benchmark") + "") && H(Le2, Ii2), (!Ze2 || 524288 & e3[0]) && Li2 !== (Li2 = t4[19]("profitability.exceedReturn") + "") && H(ze2, Li2), (!Ze2 || 524288 & e3[0]) && Oi2 !== (Oi2 = t4[19]("average") + "") && H(He2, Oi2), (!Ze2 || 16384 & e3[0]) && Fi2 !== (Fi2 = Ku((100 * t4[14]).toFixed(2)) + "") && H(qe2, Fi2), (!Ze2 || 524288 & e3[0]) && Ni2 !== (Ni2 = t4[19]("strategy") + "") && H(Qe2, Ni2);
+        },
+        i(t4) {
+            Ze2 || (le(re2.$$.fragment, t4), Ze2 = true);
+        },
+        o(t4) {
+            he(re2.$$.fragment, t4), Ze2 = false;
+        },
+        d(i3) {
+            i3 && E(e2), t3[33](null), t3[34](null), C(zi2, i3), C(ji2, i3), C(qi2, i3), Gi2 && Gi2.d(), ye(re2), t3[38](null), t3[39](null), ti2 = false, ei2();
+        }
+    };
+}
+
+function Ku(t3) {
+    return t3 > 0 ? "+" + String(t3) : t3;
+}
+
+function Gu(t3) {
+    return 0 === t3.length ? 0 : t3[0] + Gu(t3.slice(1));
+}
+
+function Yu(t3, e2, i2) {
+    let s2, n2, r2, o2, a2, l2, h2, c2, u2, d2, f2, p2, m2, g2, y2, v2;
+    Chart.register(LinearScale, BarController, CategoryScale, BarElement, Ga);
+    let b2, {
+            browser: _2
+        } = e2,
+        {
+            report: w2
+        } = e2,
+        {
+            theme: x2 = "light"
+        } = e2,
+        {
+            showAll: k2 = true
+        } = e2,
+        {
+            lang: T2 = "en"
+        } = e2;
+    void 0 !== window && (window.report = w2);
+    let S2 = null;
+    pt(() => {
+        B2("all"), ut2();
+    }), yt(() => {
+        ht2 && ht2.destroy(), ct2 && ct2.destroy();
+    });
+    let E2, C2 = null,
+        P2 = null,
+        R2 = null,
+        D2 = k2 ? null : r2;
+
+    function $2() {
+        if (R2 && D2 && w2 && S2 && b2) {
+            const t4 = `${D2}-${R2 < 10 ? `0${R2}` : String(R2)}-01`,
+                e3 = `${D2}-${R2 + 1 < 10 ? `0${R2 + 1}` : String(R2 + 1)}-01`,
+                s3 = w2.indexOfTimestamps(t4),
+                n3 = w2.indexOfTimestamps(e3);
+            if (!w2.timestamps[s3] | !w2.timestamps[n3])
+                return;
+            const r3 = S2.chart.timeScale().timeToCoordinate(w2.timestamps[s3]),
+                o3 = S2.chart.timeScale().timeToCoordinate(w2.timestamps[n3]);
+            r3 && o3 && (i2(11, E2.style.height = "80%", E2), i2(11, E2.style.width = o3 - r3 + "px", E2), i2(11, E2.style.left = r3 + "px", E2), i2(11, E2.style.top = "0", E2));
+        }
+    }
+    async function z2(t4, e3) {
+        if (!S2)
+            return;
+        const i3 = w2.indexOfTimestamps(t4),
+            s3 = w2.indexOfTimestamps(e3);
+        S2.setTimeScale(new Date(w2.timestamps[i3]), new Date(w2.timestamps[s3]));
+    }
+
+    function B2(t4) {
+        S2 || i2(30, S2 = new TwChart(b2, true)), S2.setTheme(x2);
+        const e3 = "all" === t4 ? w2.timestamps.length : 100,
+            s3 = w2.timestamps.length / (e3 / 100),
+            n3 = w2.createTradingviewSeries("strategy", 0, -1, s3),
+            r3 = w2.createTradingviewSeries("benchmark", 0, -1, s3);
+        S2.resetAreaSeries(0), S2.resetAreaSeries(1), S2.series[0].setData(n3), S2.series[1].setData(r3), S2.chart.subscribeCrosshairMove((t5) => {
+            const e4 = new Date(t5.time);
+            i2(9, C2 = e4.getMonth() + 1), i2(10, P2 = e4.getFullYear() || P2);
+        }), S2.chart.subscribeClick((t5) => {
+            const e4 = new Date(t5.time);
+            i2(4, R2 = e4.getMonth() + 1), i2(5, D2 = e4.getFullYear()), $2();
+        }), S2.chart.timeScale().subscribeVisibleTimeRangeChange((t5) => {
+            $2();
+        }), "all" === t4 && S2.setTimeScale(new Date(w2.timestamps[0]), new Date(w2.timestamps[w2.timestamps.length - 1]));
+    }
+    let U2 = null,
+        j2 = null;
+
+    function H2(t4) {
+        if (!t4 || 0 == t4)
+            return "rgba(0,0,0,0)";
+        const e3 = "dark" === x2 ? 20 : 255;
+        let i3 = t4 > 0 ? t4 / c2 : t4 / u2;
+        i3 = Math.min(0.6, i3);
+        const [s3, n3, r3] = t4 > 0 ? [255, 56, 156] : [99, 102, 241], [o3, a3, l3] = [s3 * i3 + e3 * (1 - i3), n3 * i3 + e3 * (1 - i3), r3 * i3 + e3 * (1 - i3)];
+        return `rgb(${o3},${a3},${l3})`;
+    }
+
+    function q2(t4) {
+        if (!t4 || 0 == t4)
+            return "rgba(0,0,0,0)";
+        const e3 = "dark" === x2 ? 20 : 255;
+        let i3 = t4 > 0 ? t4 / y2 : t4 / g2;
+        i3 = Math.min(0.6, i3);
+        const [s3, n3, r3] = t4 > 0 ? [255, 56, 156] : [99, 102, 241], [o3, a3, l3] = [s3 * i3 + e3 * (1 - i3), n3 * i3 + e3 * (1 - i3), r3 * i3 + e3 * (1 - i3)];
+        return `rgb(${o3},${a3},${l3})`;
+    }
+    let G2, Y2, it2 = null,
+        st2 = null,
+        rt2 = null,
+        ht2 = null,
+        ct2 = null;
+
+    function ut2() {
+        if (!_2)
+            return;
+        if (!p2)
+            return;
+        if (!v2)
+            return;
+        ht2 && ht2.destroy(), ct2 && ct2.destroy();
+        const t4 = function(t5, e4) {
+            const i3 = Object.keys(t5),
+                s3 = {},
+                n4 = i3.reduce((i4, n5) => {
+                    const r4 = t5[n5] - e4[n5];
+                    return s3[n5] = r4, i4 + r4;
+                }, 0) / i3.length;
+            return {
+                result: s3,
+                mean: n4
+            };
+        }(p2, v2);
+        i2(14, it2 = t4.mean), i2(15, st2 = Object.values(t4.result).filter((t5) => t5 > 0).length), i2(16, rt2 = Object.values(t4.result).length - st2);
+        const e3 = Object.keys(p2),
+            n3 = G2.getContext("2d");
+        ht2 = new Chart(n3, {
+            type: "bar",
+            data: {
+                labels: e3,
+                datasets: [{
+                    label: s2("profitability.yearlyReturn"),
+                    data: Object.values(p2),
+                    backgroundColor: "light" === x2 ? "#725bf5" : "#7a64f5",
+                    borderWidth: 0
+                }, {
+                    label: s2("profitability.benchmarkYearlyReturn"),
+                    data: Object.values(v2),
+                    backgroundColor: "#777777AA",
+                    borderWidth: 0
+                }]
+            },
+            options: {
+                responsive: true,
+                maintainAspectRatio: true,
+                scales: {
+                    y: {
+                        beginAtZero: true,
+                        ticks: {
+                            callback: (t5, e4, i3) => (100 * t5).toFixed() + "%",
+                            color: "light" === x2 ? "#000000aa" : "#FFFFFFaa"
+                        },
+                        grid: {
+                            color: "#77777755",
+                            tickBorderDash: [2, 2]
+                        }
+                    },
+                    x: {
+                        ticks: {
+                            color: "light" === x2 ? "#000000aa" : "#FFFFFFaa"
+                        },
+                        grid: {
+                            color: "#77777755",
+                            tickBorderDash: [2, 2]
+                        }
+                    }
+                }
+            }
+        });
+        const r3 = Y2.getContext("2d");
+        ct2 = new Chart(r3, {
+            type: "bar",
+            data: {
+                labels: e3,
+                datasets: [{
+                    label: s2("profitability.exceedReturn"),
+                    data: Object.values(t4.result),
+                    backgroundColor: "light" === x2 ? "#725bf5" : "#7a64f5",
+                    borderColor: "#725bf5",
+                    borderWidth: 1,
+                    barPercentage: 0.5
+                }]
+            },
+            options: {
+                responsive: true,
+                maintainAspectRatio: true,
+                scales: {
+                    y: {
+                        beginAtZero: true,
+                        ticks: {
+                            callback: (t5, e4, i3) => (100 * t5).toFixed() + "%",
+                            color: "light" === x2 ? "#000000aa" : "#FFFFFFaa"
+                        },
+                        grid: {
+                            color: "#77777755",
+                            tickBorderDash: [2, 2]
+                        }
+                    },
+                    x: {
+                        ticks: {
+                            color: "light" === x2 ? "#000000aa" : "#FFFFFFaa"
+                        },
+                        grid: {
+                            color: "#77777755",
+                            tickBorderDash: [2, 2]
+                        }
+                    }
+                }
+            }
+        });
+    }
+    return t3.$$set = (t4) => {
+        "browser" in t4 && i2(0, _2 = t4.browser), "report" in t4 && i2(1, w2 = t4.report), "theme" in t4 && i2(2, x2 = t4.theme), "showAll" in t4 && i2(29, k2 = t4.showAll), "lang" in t4 && i2(3, T2 = t4.lang);
+    }, t3.$$.update = () => {
+        8 & t3.$$.dirty[0] && i2(19, s2 = (t4) => "en" === T2 ? sl(t4) : nl(t4)), 4 & t3.$$.dirty[0] && x2 && ut2(), 2 & t3.$$.dirty[0] && i2(25, n2 = new Date(w2.timestamps[0]).getFullYear()), 2 & t3.$$.dirty[0] && i2(24, r2 = new Date(w2.timestamps[w2.timestamps.length - 1]).getFullYear()), 48 & t3.$$.dirty[0] && i2(23, o2 = D2 ? new Date(new Date(D2, (R2 || 1) - 1)) : null), 48 & t3.$$.dirty[0] && i2(22, a2 = D2 ? new Date(new Date(D2, R2 || 12) - 864e5) : null), 1073741828 & t3.$$.dirty[0] && S2 && S2.setTheme(x2), 2 & t3.$$.dirty[0] && i2(7, l2 = w2.calculateMonthlyReturn("strategy")), 128 & t3.$$.dirty[0] && i2(32, h2 = Object.values(l2).filter((t4) => t4 == t4)), 2 & t3.$$.dirty[1] && (c2 = Math.max(...h2)), 2 & t3.$$.dirty[1] && (u2 = Math.min(...h2)), 2 & t3.$$.dirty[1] && i2(21, d2 = Gu(h2) / h2.length), 2 & t3.$$.dirty[1] && i2(20, f2 = h2.filter((t4) => t4 > 0).length / h2.length * 100), 2 & t3.$$.dirty[0] && i2(6, p2 = w2.calculateAnnualReturn("strategy")), 64 & t3.$$.dirty[0] && i2(31, m2 = Object.values(p2).filter((t4) => t4 == t4)), 1 & t3.$$.dirty[1] && (g2 = Math.min(...m2)), 1 & t3.$$.dirty[1] && (y2 = Math.max(...m2)), 2 & t3.$$.dirty[0] && (v2 = w2.calculateAnnualReturn("benchmark")), 132 & t3.$$.dirty[0] && (l2 || x2) && i2(12, U2 = Object.fromEntries(Object.keys(l2).map((t4) => [t4, H2(l2[t4])]))), 68 & t3.$$.dirty[0] && (p2 || x2) && i2(13, j2 = Object.fromEntries(Object.keys(p2).map((t4) => [t4, q2(p2[t4])])));
+    }, [_2, w2, x2, T2, R2, D2, p2, l2, b2, C2, P2, E2, U2, j2, it2, st2, rt2, G2, Y2, s2, f2, d2, a2, o2, r2, n2, $2, z2, B2, k2, S2, m2, h2, function(t4) {
+        xt[t4 ? "unshift" : "push"](() => {
+            b2 = t4, i2(8, b2);
+        });
+    }, function(t4) {
+        xt[t4 ? "unshift" : "push"](() => {
+            E2 = t4, i2(11, E2);
+        });
+    }, (t4) => {
+        B2("year"), z2(t4 - 1 + "-12-31", `${t4}-12-31`), i2(10, P2 = t4);
+    }, () => {
+        B2("all"), z2(0, -1), i2(10, P2 = null);
+    }, (t4, e3) => {
+        B2("year"), z2(t4 - 1 + "-12-31", `${t4}-12-31`), i2(10, P2 = t4), i2(5, D2 = t4), i2(4, R2 = e3), $2();
+    }, function(t4) {
+        xt[t4 ? "unshift" : "push"](() => {
+            G2 = t4, i2(17, G2);
+        });
+    }, function(t4) {
+        xt[t4 ? "unshift" : "push"](() => {
+            Y2 = t4, i2(18, Y2);
+        });
+    }];
+}
+we(Du, {
+    prefix: {},
+    name: {},
+    color: {},
+    strokeColor: {},
+    className: {}
+}, [], [], true);
+class Profitability extends SvelteComponent {
+    constructor(t3) {
+        super(), ve(this, t3, Yu, qu, o, {
+            browser: 0,
+            report: 1,
+            theme: 2,
+            showAll: 29,
+            lang: 3
+        }, Fu, [-1, -1]);
+    }
+    get browser() {
+        return this.$$.ctx[0];
+    }
+    set browser(t3) {
+        this.$$set({
+            browser: t3
+        }), te();
+    }
+    get report() {
+        return this.$$.ctx[1];
+    }
+    set report(t3) {
+        this.$$set({
+            report: t3
+        }), te();
+    }
+    get theme() {
+        return this.$$.ctx[2];
+    }
+    set theme(t3) {
+        this.$$set({
+            theme: t3
+        }), te();
+    }
+    get showAll() {
+        return this.$$.ctx[29];
+    }
+    set showAll(t3) {
+        this.$$set({
+            showAll: t3
+        }), te();
+    }
+    get lang() {
+        return this.$$.ctx[3];
+    }
+    set lang(t3) {
+        this.$$set({
+            lang: t3
+        }), te();
+    }
+}
+
+function Qu(e2) {
+    let i2, s2, n2, r2, o2, a2, l2, h2, c2, u2, d2, f2, p2, m2, g2, y2, v2, b2, w2, x2, k2, T2, C2, R2, z2, B2, j2, q2, Y2, it2, st2, rt2, ht2, ct2, ut2, dt2, ft2, pt2, yt2, bt2, _t2, xt2, kt2, St2, It2, Mt2, At2, Lt2, Ot2, Ht2, Qt2, Jt2, te2, ee2, ie2, se2, ne2, re2, oe2, ae2, le2, he2, ce2, ue2, de2, fe2, pe2, me2, ge2, ye2, ve2, be2, _e2, we2, xe2, ke2, Te2, Se2, Ee2, Ce2, Ie2, Me2, Pe2, Re2, Ae2, De2, Le2, Oe2, Fe2, Ne2, $e2, Ve2 = e2[6]("metrics.ratio.sharpeRatio") + "",
+        ze2 = e2[6]("metrics.ratio.timeBetterThanBenchmark") + "",
+        Be2 = (100 * e2[7]).toFixed(2) + "",
+        Ue2 = e2[6]("metrics.ratio.yearlySharpeRatio") + "",
+        je2 = e2[6]("metrics.ratio.timeBetterThanBenchmark") + "",
+        He2 = e2[10].length + "",
+        We2 = e2[6]("metrics.ratio.year") + "",
+        qe2 = e2[6]("strategy") + "",
+        Ke2 = e2[6]("benchmark") + "",
+        Ge2 = e2[6]("metrics.ratio.worseThanBenchmark") + "",
+        Ye2 = e2[6]("metrics.ratio.rollingTailRatio") + "",
+        Qe2 = e2[6]("metrics.ratio.timeBetterThanBenchmark") + "",
+        Xe2 = (100 * e2[9]).toFixed(2) + "",
+        Je2 = e2[6]("metrics.ratio.yearlyTailRatio") + "",
+        Ze2 = e2[6]("metrics.ratio.timeBetterThanBenchmark") + "",
+        ti2 = e2[10].length + "",
+        ei2 = e2[6]("metrics.ratio.year") + "",
+        si2 = e2[6]("strategy") + "",
+        ni2 = e2[6]("benchmark") + "",
+        ri2 = e2[6]("metrics.ratio.worseThanBenchmark") + "",
+        ai2 = e2[6]("metrics.ratio.volatility") + "",
+        li2 = e2[6]("metrics.ratio.timeBetterThanBenchmark") + "",
+        hi2 = (100 * e2[8]).toFixed(2) + "";
+    return {
+        c() {
+            i2 = P("div"), s2 = P("div"), n2 = P("h3"), r2 = D(Ve2), o2 = $(), a2 = P("span"), l2 = D(ze2), h2 = $(), c2 = D(Be2), u2 = D("％"), d2 = $(), f2 = P("div"), p2 = $(), m2 = P("div"), g2 = P("h3"), y2 = D(Ue2), v2 = $(), b2 = P("span"), w2 = D(je2), x2 = $(), k2 = D(e2[11]), T2 = D(" / "), C2 = D(He2), R2 = $(), z2 = D(We2), B2 = $(), j2 = P("div"), q2 = P("div"), Y2 = P("div"), it2 = D(qe2), st2 = $(), rt2 = P("div"), ht2 = D(Ke2), ct2 = $(), ut2 = P("div"), dt2 = D(Ge2), ft2 = $(), pt2 = P("canvas"), yt2 = $(), bt2 = P("div"), _t2 = P("div"), xt2 = $(), kt2 = P("div"), St2 = P("h3"), It2 = D(Ye2), Mt2 = $(), At2 = P("span"), Lt2 = D(Qe2), Ot2 = $(), Ht2 = D(Xe2), Qt2 = D("％"), Jt2 = $(), te2 = P("div"), ee2 = $(), ie2 = P("div"), se2 = P("h3"), ne2 = D(Je2), re2 = $(), oe2 = P("span"), ae2 = D(Ze2), le2 = $(), he2 = D(e2[12]), ce2 = D(" / "), ue2 = D(ti2), de2 = $(), fe2 = D(ei2), pe2 = $(), me2 = P("div"), ge2 = P("div"), ye2 = P("div"), ve2 = D(si2), be2 = $(), _e2 = P("div"), we2 = D(ni2), xe2 = $(), ke2 = P("div"), Te2 = D(ri2), Se2 = $(), Ee2 = P("canvas"), Ce2 = $(), Ie2 = P("div"), Me2 = P("h3"), Pe2 = D(ai2), Re2 = $(), Ae2 = P("span"), De2 = D(li2), Le2 = $(), Oe2 = D(hi2), Fe2 = D("％"), Ne2 = $(), $e2 = P("div"), U(n2, "class", "text-2xl font-bold mb-1 text-base-content-200"), U(f2, "class", "h-48 mt-6"), U(s2, "class", "col-span-6 md:col-span-3 p-2 md:p-8 pt-8 md:border rounded-xl"), U(g2, "class", "text-2xl font-bold mb-1 text-base-content-200"), U(Y2, "class", "badge rounded bg-primary text-white"), U(rt2, "class", "badge rounded bg-gray-500 text-white"), U(ut2, "class", "badge rounded bg-[rgba(241,99,102,1)] text-white"), U(q2, "class", "text-sm mt-2 flex gap-2"), U(pt2, "class", "h-48 mt-4"), G(pt2, "width", "580px"), U(j2, "class", "w-full overflow-x-auto relative"), U(m2, "class", "col-span-6 md:col-span-3 p-2 md:p-8 pt-8 md:border rounded-xl"), U(_t2, "class", "h-48 hidden"), U(bt2, "class", "col-span-6 md:col-span-3 pt-8 md:p-8 hidden"), U(St2, "class", "text-2xl font-bold mb-1 text-base-content-200"), U(te2, "class", "h-48 mt-6"), U(kt2, "class", "col-span-6 md:col-span-3 p-2 md:p-8 pt-8 md:border rounded-xl"), U(se2, "class", "text-2xl font-bold mb-1 text-base-content-200"), U(ye2, "class", "badge rounded badge-primary text-white"), U(_e2, "class", "badge rounded bg-gray-500 text-white"), U(ke2, "class", "badge rounded bg-[rgba(241,99,102,1)] text-white"), U(ge2, "class", "text-sm mt-2 flex gap-2"), U(Ee2, "class", "h-48 mt-4"), G(Ee2, "width", "580px"), U(me2, "class", "w-full overflow-x-auto relative"), U(ie2, "class", "col-span-6 md:col-span-3 p-2 md:p-8 pt-8 md:border rounded-xl"), U(Me2, "class", "text-2xl font-bold mb-1 text-base-content-200"), U($e2, "class", "h-48 mt-6"), U(Ie2, "class", "col-span-6 p-2 md:p-8 pt-8 md:border rounded-xl"), U(i2, "class", "grid grid-cols-6 gap-4 text-base-content-200");
+        },
+        m(t3, E2) {
+            S(t3, i2, E2), _(i2, s2), _(s2, n2), _(n2, r2), _(s2, o2), _(s2, a2), _(a2, l2), _(a2, h2), _(a2, c2), _(a2, u2), _(s2, d2), _(s2, f2), e2[17](f2), _(i2, p2), _(i2, m2), _(m2, g2), _(g2, y2), _(m2, v2), _(m2, b2), _(b2, w2), _(b2, x2), _(b2, k2), _(b2, T2), _(b2, C2), _(b2, R2), _(b2, z2), _(m2, B2), _(m2, j2), _(j2, q2), _(q2, Y2), _(Y2, it2), _(q2, st2), _(q2, rt2), _(rt2, ht2), _(q2, ct2), _(q2, ut2), _(ut2, dt2), _(j2, ft2), _(j2, pt2), e2[18](pt2), _(i2, yt2), _(i2, bt2), _(bt2, _t2), e2[19](_t2), _(i2, xt2), _(i2, kt2), _(kt2, St2), _(St2, It2), _(kt2, Mt2), _(kt2, At2), _(At2, Lt2), _(At2, Ot2), _(At2, Ht2), _(At2, Qt2), _(kt2, Jt2), _(kt2, te2), e2[20](te2), _(i2, ee2), _(i2, ie2), _(ie2, se2), _(se2, ne2), _(ie2, re2), _(ie2, oe2), _(oe2, ae2), _(oe2, le2), _(oe2, he2), _(oe2, ce2), _(oe2, ue2), _(oe2, de2), _(oe2, fe2), _(ie2, pe2), _(ie2, me2), _(me2, ge2), _(ge2, ye2), _(ye2, ve2), _(ge2, be2), _(ge2, _e2), _(_e2, we2), _(ge2, xe2), _(ge2, ke2), _(ke2, Te2), _(me2, Se2), _(me2, Ee2), e2[21](Ee2), _(i2, Ce2), _(i2, Ie2), _(Ie2, Me2), _(Me2, Pe2), _(Ie2, Re2), _(Ie2, Ae2), _(Ae2, De2), _(Ae2, Le2), _(Ae2, Oe2), _(Ae2, Fe2), _(Ie2, Ne2), _(Ie2, $e2), e2[22]($e2);
+        },
+        p(t3, e3) {
+            64 & e3[0] && Ve2 !== (Ve2 = t3[6]("metrics.ratio.sharpeRatio") + "") && H(r2, Ve2), 64 & e3[0] && ze2 !== (ze2 = t3[6]("metrics.ratio.timeBetterThanBenchmark") + "") && H(l2, ze2), 64 & e3[0] && Ue2 !== (Ue2 = t3[6]("metrics.ratio.yearlySharpeRatio") + "") && H(y2, Ue2), 64 & e3[0] && je2 !== (je2 = t3[6]("metrics.ratio.timeBetterThanBenchmark") + "") && H(w2, je2), 64 & e3[0] && We2 !== (We2 = t3[6]("metrics.ratio.year") + "") && H(z2, We2), 64 & e3[0] && qe2 !== (qe2 = t3[6]("strategy") + "") && H(it2, qe2), 64 & e3[0] && Ke2 !== (Ke2 = t3[6]("benchmark") + "") && H(ht2, Ke2), 64 & e3[0] && Ge2 !== (Ge2 = t3[6]("metrics.ratio.worseThanBenchmark") + "") && H(dt2, Ge2), 64 & e3[0] && Ye2 !== (Ye2 = t3[6]("metrics.ratio.rollingTailRatio") + "") && H(It2, Ye2), 64 & e3[0] && Qe2 !== (Qe2 = t3[6]("metrics.ratio.timeBetterThanBenchmark") + "") && H(Lt2, Qe2), 64 & e3[0] && Je2 !== (Je2 = t3[6]("metrics.ratio.yearlyTailRatio") + "") && H(ne2, Je2), 64 & e3[0] && Ze2 !== (Ze2 = t3[6]("metrics.ratio.timeBetterThanBenchmark") + "") && H(ae2, Ze2), 64 & e3[0] && ei2 !== (ei2 = t3[6]("metrics.ratio.year") + "") && H(fe2, ei2), 64 & e3[0] && si2 !== (si2 = t3[6]("strategy") + "") && H(ve2, si2), 64 & e3[0] && ni2 !== (ni2 = t3[6]("benchmark") + "") && H(we2, ni2), 64 & e3[0] && ri2 !== (ri2 = t3[6]("metrics.ratio.worseThanBenchmark") + "") && H(Te2, ri2), 64 & e3[0] && ai2 !== (ai2 = t3[6]("metrics.ratio.volatility") + "") && H(Pe2, ai2), 64 & e3[0] && li2 !== (li2 = t3[6]("metrics.ratio.timeBetterThanBenchmark") + "") && H(De2, li2);
+        },
+        i: t,
+        o: t,
+        d(t3) {
+            t3 && E(i2), e2[17](null), e2[18](null), e2[19](null), e2[20](null), e2[21](null), e2[22](null);
+        }
+    };
+}
+
+function Xu(t3, e2) {
+    let i2 = 0;
+    for (let s2 = 0; s2 < t3.length; s2++)
+        t3[s2] > e2[s2] && i2++;
+    return i2 / t3.length;
+}
+
+function Ju(t3, e2, i2) {
+    let s2;
+    Chart.register(LinearScale, BarController, CategoryScale, BarElement, Ga);
+    let {
+        browser: n2
+    } = e2, {
+        report: r2
+    } = e2, {
+        theme: o2
+    } = e2, {
+        lang: a2 = "en"
+    } = e2;
+    const l2 = r2.calculateSharpe("strategy", 0, 250),
+        h2 = r2.calculateSharpe("benchmark", 0, 250),
+        c2 = Xu(l2.map((t4) => t4.value), h2.map((t4) => t4.value));
+    let u2, d2, f2 = null,
+        p2 = null;
+    const m2 = r2.calculateSortino("strategy", 0, 250),
+        g2 = r2.calculateSortino("benchmark", 0, 250);
+    let y2, v2 = null;
+    const b2 = r2.calculateVolitility("strategy", 0, 10).slice(-m2.length),
+        _2 = r2.calculateVolitility("benchmark", 0, 10).slice(-m2.length),
+        w2 = Xu(b2.map((t4) => t4.value), _2.map((t4) => t4.value));
+    let x2, k2 = null;
+    const T2 = r2.calculateTailRatio("strategy", 250),
+        S2 = r2.calculateTailRatio("benchmark", 250),
+        E2 = Xu(T2.map((t4) => t4.value), S2.map((t4) => t4.value));
+    let C2, P2, R2 = null,
+        D2 = null;
+    const $2 = parseInt(l2[0].time.slice(0, 4)),
+        z2 = parseInt(l2[l2.length - 1].time.slice(0, 4)),
+        B2 = Array.from(Array(z2 + 1).keys()).slice($2),
+        U2 = B2.map((t4) => Math.max(Math.min(r2.indexOfTimestamps(t4 + "-12-31") - 249, l2.length - 1), 0));
+
+    function j2(t4, e3) {
+        return U2.map((i3) => {
+            const s3 = t4[i3].value,
+                n3 = e3[i3].value;
+            return s3 > n3 ? 1 : s3 < n3 ? 0 : 0.5;
+        }).reduce((t5, e4) => t5 + e4, 0);
+    }
+    const H2 = j2(l2, h2),
+        q2 = j2(T2, S2);
+
+    function G2(t4, e3) {
+        return t4.map((t5, i3) => t5 < e3[i3] ? "rgba(241, 99, 102, 1)" : "light" === o2 ? "#725bf5" : "#7a64f5");
+    }
+
+    function Y2() {
+        if (void 0 !== d2) {
+            p2 && p2.destroy();
+            var t4 = d2.getContext("2d");
+            p2 = new Chart(t4, {
+                type: "bar",
+                data: {
+                    labels: B2,
+                    datasets: [{
+                        label: s2("metrics.ratio.sharpeRatio"),
+                        data: U2.map((t5) => l2[t5].value),
+                        backgroundColor: G2(U2.map((t5) => l2[t5].value), U2.map((t5) => h2[t5].value)),
+                        borderWidth: 0,
+                        barPercentage: 0.5
+                    }, {
+                        label: s2("benchmark"),
+                        data: U2.map((t5) => h2[t5].value),
+                        backgroundColor: "#77777777",
+                        borderWidth: 0,
+                        barPercentage: 0.5
+                    }]
+                },
+                options: {
+                    responsive: true,
+                    maintainAspectRatio: true,
+                    scales: {
+                        y: {
+                            beginAtZero: true,
+                            ticks: {
+                                color: "light" === o2 ? "#000000aa" : "#FFFFFFaa"
+                            },
+                            grid: {
+                                color: "#77777755",
+                                tickBorderDash: [2, 2]
+                            }
+                        },
+                        x: {
+                            ticks: {
+                                color: "light" === o2 ? "#000000aa" : "#FFFFFFaa"
+                            },
+                            grid: {
+                                color: "#77777755",
+                                tickBorderDash: [2, 2]
+                            }
+                        }
+                    }
+                }
+            }), D2 && D2.destroy();
+            var e3 = P2.getContext("2d");
+            D2 = new Chart(e3, {
+                type: "bar",
+                data: {
+                    labels: B2,
+                    datasets: [{
+                        label: s2("metrics.ratio.tailRatio"),
+                        data: U2.map((t5) => T2[t5].value),
+                        backgroundColor: G2(U2.map((t5) => T2[t5].value), U2.map((t5) => S2[t5].value)),
+                        borderWidth: 0,
+                        barPercentage: 0.5
+                    }, {
+                        label: s2("benchmark"),
+                        data: U2.map((t5) => S2[t5].value),
+                        backgroundColor: "#77777777",
+                        borderWidth: 0,
+                        barPercentage: 0.5
+                    }]
+                },
+                options: {
+                    responsive: true,
+                    maintainAspectRatio: true,
+                    scales: {
+                        y: {
+                            beginAtZero: true,
+                            ticks: {
+                                color: "light" === o2 ? "#000000aa" : "#FFFFFFaa"
+                            },
+                            grid: {
+                                color: "#77777755",
+                                tickBorderDash: [2, 2]
+                            }
+                        },
+                        x: {
+                            ticks: {
+                                color: "light" === o2 ? "#000000aa" : "#FFFFFFaa"
+                            },
+                            grid: {
+                                color: "#77777755",
+                                tickBorderDash: [2, 2]
+                            }
+                        }
+                    }
+                }
+            });
+        }
+    }
+    return pt(() => {
+        if (!n2)
+            return;
+        f2 = new TwChart(u2, false), f2.setTheme(o2), f2.resetAreaSeries(0), f2.resetAreaSeries(1);
+        let t4 = l2[0].time,
+            e3 = l2[l2.length - 1].time;
+        f2.series[0].setData(l2), f2.series[1].setData(h2), f2.setTimeScale(new Date(t4), new Date(e3)), v2 = new TwChart(y2, false), v2.setTheme(o2), v2.resetAreaSeries(0), v2.resetAreaSeries(1), t4 = m2[0].time, e3 = m2[l2.length - 1].time, v2.series[0].setData(m2), v2.series[1].setData(g2), v2.setTimeScale(new Date(t4), new Date(e3)), k2 = new TwChart(x2, false), k2.setTheme(o2), k2.resetAreaSeries(0), k2.resetAreaSeries(1), t4 = b2[0].time, e3 = b2[l2.length - 1].time, k2.series[0].setData(b2), k2.series[1].setData(_2), k2.setTimeScale(new Date(t4), new Date(e3)), R2 = new TwChart(C2, false), R2.setTheme(o2), R2.resetAreaSeries(0), R2.resetAreaSeries(1), t4 = T2[0].time, e3 = T2[l2.length - 1].time, R2.series[0].setData(T2), R2.series[1].setData(S2), R2.setTimeScale(new Date(t4), new Date(e3));
+        const i3 = [f2, v2, k2, R2];
+        for (let t5 in i3) {
+            const e4 = i3[t5].chart;
+            e4.timeScale().subscribeVisibleTimeRangeChange((s3) => {
+                const n3 = e4.timeScale().getVisibleLogicalRange();
+                for (let e5 in i3)
+                    e5 !== t5 && i3[e5].chart.timeScale().setVisibleLogicalRange(n3);
+            });
+        }
+        Y2();
+    }), yt(() => {
+        p2 && p2.destroy(), D2 && D2.destroy();
+    }), t3.$$set = (t4) => {
+        "browser" in t4 && i2(13, n2 = t4.browser), "report" in t4 && i2(14, r2 = t4.report), "theme" in t4 && i2(15, o2 = t4.theme), "lang" in t4 && i2(16, a2 = t4.lang);
+    }, t3.$$.update = () => {
+        65536 & t3.$$.dirty[0] && i2(6, s2 = (t4) => "en" === a2 ? sl(t4) : nl(t4)), 32768 & t3.$$.dirty[0] && o2 && Y2();
+    }, [u2, d2, y2, x2, C2, P2, s2, c2, w2, E2, U2, H2, q2, n2, r2, o2, a2, function(t4) {
+        xt[t4 ? "unshift" : "push"](() => {
+            u2 = t4, i2(0, u2);
+        });
+    }, function(t4) {
+        xt[t4 ? "unshift" : "push"](() => {
+            d2 = t4, i2(1, d2);
+        });
+    }, function(t4) {
+        xt[t4 ? "unshift" : "push"](() => {
+            y2 = t4, i2(2, y2);
+        });
+    }, function(t4) {
+        xt[t4 ? "unshift" : "push"](() => {
+            C2 = t4, i2(4, C2);
+        });
+    }, function(t4) {
+        xt[t4 ? "unshift" : "push"](() => {
+            P2 = t4, i2(5, P2);
+        });
+    }, function(t4) {
+        xt[t4 ? "unshift" : "push"](() => {
+            x2 = t4, i2(3, x2);
+        });
+    }];
+}
+we(Profitability, {
+    browser: {},
+    report: {},
+    theme: {},
+    showAll: {
+        type: "Boolean"
+    },
+    lang: {}
+}, [], [], true);
+class Ratio extends SvelteComponent {
+    constructor(t3) {
+        super(), ve(this, t3, Ju, Qu, o, {
+            browser: 13,
+            report: 14,
+            theme: 15,
+            lang: 16
+        }, null, [-1, -1]);
+    }
+    get browser() {
+        return this.$$.ctx[13];
+    }
+    set browser(t3) {
+        this.$$set({
+            browser: t3
+        }), te();
+    }
+    get report() {
+        return this.$$.ctx[14];
+    }
+    set report(t3) {
+        this.$$set({
+            report: t3
+        }), te();
+    }
+    get theme() {
+        return this.$$.ctx[15];
+    }
+    set theme(t3) {
+        this.$$set({
+            theme: t3
+        }), te();
+    }
+    get lang() {
+        return this.$$.ctx[16];
+    }
+    set lang(t3) {
+        this.$$set({
+            lang: t3
+        }), te();
+    }
+}
+
+function Zu(t3, e2, i2) {
+    const s2 = t3.slice();
+    return s2[35] = e2[i2], s2;
+}
+
+function td(t3, e2, i2) {
+    const s2 = t3.slice();
+    return s2[35] = e2[i2], s2;
+}
+
+function ed(t3, e2, i2) {
+    const s2 = t3.slice();
+    return s2[35] = e2[i2], s2;
+}
+
+function id(t3) {
+    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2, d2 = t3[2].timestamps[t3[35].start].slice(0, 4) + "",
+        f2 = (100 * t3[35].maxDrawdown).toFixed(1) + "";
+
+    function p2() {
+        return t3[22](t3[35]);
+    }
+    return {
+        c() {
+            e2 = P("div"), i2 = P("div"), s2 = D(d2), n2 = $(), r2 = P("div"), o2 = D(f2), a2 = D("%"), l2 = $(), U(i2, "class", "text-xs"), U(r2, "class", "font-bold"), U(e2, "class", h2 = "hover:badge-primary hover:text-white p-2 mt-1 mr-3 cursor-pointer rounded-md " + (t3[11] === t3[35] ? "outline outline-primary" : "bg-base-100"));
+        },
+        m(t4, h3) {
+            S(t4, e2, h3), _(e2, i2), _(i2, s2), _(e2, n2), _(e2, r2), _(r2, o2), _(r2, a2), _(e2, l2), c2 || (u2 = B(e2, "click", p2), c2 = true);
+        },
+        p(i3, n3) {
+            t3 = i3, 20 & n3[0] && d2 !== (d2 = t3[2].timestamps[t3[35].start].slice(0, 4) + "") && H(s2, d2), 16 & n3[0] && f2 !== (f2 = (100 * t3[35].maxDrawdown).toFixed(1) + "") && H(o2, f2), 2064 & n3[0] && h2 !== (h2 = "hover:badge-primary hover:text-white p-2 mt-1 mr-3 cursor-pointer rounded-md " + (t3[11] === t3[35] ? "outline outline-primary" : "bg-base-100")) && U(e2, "class", h2);
+        },
+        d(t4) {
+            t4 && E(e2), c2 = false, u2();
+        }
+    };
+}
+
+function sd(t3) {
+    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2, d2, f2, p2, m2, g2, y2, v2, b2, w2, x2, k2, T2, C2, R2, z2, j2, q2, G2 = t3[2].timestamps[t3[35].at].slice(0, 4) + "",
+        Y2 = t3[2].timestamps[t3[35].at].slice(5, 7) + "",
+        it2 = (100 * t3[35].maxDrawdown).toFixed(1) + "";
+
+    function st2() {
+        return t3[26](t3[35]);
+    }
+    return {
+        c() {
+            e2 = P("div"), i2 = P("div"), s2 = D(G2), n2 = $(), r2 = P("br"), o2 = $(), a2 = D(Y2), l2 = D(" 月"), h2 = $(), c2 = P("div"), u2 = P("div"), p2 = $(), m2 = P("div"), b2 = $(), w2 = P("div"), x2 = D(it2), k2 = P("br"), T2 = D("% "), C2 = P("br"), z2 = $(), U(i2, "class", "mt-2 border-b border-base-content/20 pb-4 px-2 text-center w-full"), U(u2, "style", d2 = `height:${(t3[35].maxDrawdown / t3[4][0].maxDrawdown * 160).toFixed(0)}px`), U(u2, "class", f2 = "w-3 rounded-b-full mx-1 " + ("strategy" === t3[10] ? "bg-primary" : "bg-gray-400")), U(m2, "style", g2 = `height:${(("strategy" === t3[10] ? t3[15] : t3[16])[t3[35].at].value / 100 / Math.max(t3[4][0].maxDrawdown, t3[13][0].maxDrawdown) * 160).toFixed(0)}px`), U(m2, "class", y2 = "w-3 rounded-b-full mx-1 " + ("strategy" === t3[10] ? "bg-gray-400" : "bg-primary")), U(c2, "class", v2 = "flex justify-center " + ("benchmark" === t3[10] ? "flex-row-reverse" : "")), U(w2, "class", R2 = `w-20 pt-2 text-center text-primary ${0 === t3[17] ? "text-2xl font-bold" : ""} ${"strategy" === t3[10] ? "text-primary" : "text-gray-400"}`), U(e2, "class", "flex flex-col justify-center items-center text-sm rounded-full pb-4 transition-all hover:cursor-pointer hover:text-base hover:-mt-4 hover:shadow-2xl hover:shadow-primary");
+        },
+        m(t4, d3) {
+            S(t4, e2, d3), _(e2, i2), _(i2, s2), _(i2, n2), _(i2, r2), _(i2, o2), _(i2, a2), _(i2, l2), _(e2, h2), _(e2, c2), _(c2, u2), _(c2, p2), _(c2, m2), _(e2, b2), _(e2, w2), _(w2, x2), _(w2, k2), _(w2, T2), _(w2, C2), _(e2, z2), j2 || (q2 = B(e2, "click", st2), j2 = true);
+        },
+        p(e3, i3) {
+            t3 = e3, 9236 & i3[0] && G2 !== (G2 = t3[2].timestamps[t3[35].at].slice(0, 4) + "") && H(s2, G2), 9236 & i3[0] && Y2 !== (Y2 = t3[2].timestamps[t3[35].at].slice(5, 7) + "") && H(a2, Y2), 9232 & i3[0] && d2 !== (d2 = `height:${(t3[35].maxDrawdown / t3[4][0].maxDrawdown * 160).toFixed(0)}px`) && U(u2, "style", d2), 1024 & i3[0] && f2 !== (f2 = "w-3 rounded-b-full mx-1 " + ("strategy" === t3[10] ? "bg-primary" : "bg-gray-400")) && U(u2, "class", f2), 107536 & i3[0] && g2 !== (g2 = `height:${(("strategy" === t3[10] ? t3[15] : t3[16])[t3[35].at].value / 100 / Math.max(t3[4][0].maxDrawdown, t3[13][0].maxDrawdown) * 160).toFixed(0)}px`) && U(m2, "style", g2), 1024 & i3[0] && y2 !== (y2 = "w-3 rounded-b-full mx-1 " + ("strategy" === t3[10] ? "bg-gray-400" : "bg-primary")) && U(m2, "class", y2), 1024 & i3[0] && v2 !== (v2 = "flex justify-center " + ("benchmark" === t3[10] ? "flex-row-reverse" : "")) && U(c2, "class", v2), 9232 & i3[0] && it2 !== (it2 = (100 * t3[35].maxDrawdown).toFixed(1) + "") && H(x2, it2), 132096 & i3[0] && R2 !== (R2 = `w-20 pt-2 text-center text-primary ${0 === t3[17] ? "text-2xl font-bold" : ""} ${"strategy" === t3[10] ? "text-primary" : "text-gray-400"}`) && U(w2, "class", R2);
+        },
+        d(t4) {
+            t4 && E(e2), j2 = false, q2();
+        }
+    };
+}
+
+function nd(t3) {
+    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2, d2, f2, p2, m2, g2, y2, v2, b2, w2, x2, k2, T2, C2, R2 = t3[2].timestamps[t3[35].at].slice(0, 4) + "",
+        z2 = t3[2].timestamps[t3[35].at].slice(5, 7) + "",
+        j2 = t3[20](t3[35]) + "",
+        q2 = t3[17]("metrics.risk.days") + "";
+
+    function G2() {
+        return t3[29](t3[35]);
+    }
+    return {
+        c() {
+            e2 = P("div"), i2 = P("div"), s2 = D(R2), n2 = $(), r2 = P("br"), o2 = $(), a2 = D(z2), l2 = D(" 月"), h2 = $(), c2 = P("div"), u2 = P("div"), p2 = $(), m2 = P("div"), g2 = D(j2), y2 = $(), v2 = P("br"), b2 = $(), w2 = D(q2), k2 = $(), U(i2, "class", "mt-2 border-b border-base-content/20 pb-4 px-2 text-center w-full"), U(u2, "style", d2 = `height:${(t3[20](t3[35]) / Math.min(t3[20](t3[14][0]), t3[20](t3[12][0])) * 160).toFixed(0)}px`), U(u2, "class", f2 = "w-3 rounded-b-full mx-1 " + ("strategy" === t3[10] ? "bg-primary" : "bg-gray-400")), U(m2, "class", x2 = `w-14 pt-2 text-center ${0 === t3[17] ? "text-2xl font-bold" : ""} ${"strategy" === t3[10] ? "text-primary" : "text-gray-400"}`), U(e2, "class", "flex flex-col justify-center items-center text-sm rounded-full pb-4 transition-all hover:cursor-pointer hover:text-base hover:-mt-4 hover:shadow-2xl hover:shadow-primary");
+        },
+        m(t4, d3) {
+            S(t4, e2, d3), _(e2, i2), _(i2, s2), _(i2, n2), _(i2, r2), _(i2, o2), _(i2, a2), _(i2, l2), _(e2, h2), _(e2, c2), _(c2, u2), _(e2, p2), _(e2, m2), _(m2, g2), _(m2, y2), _(m2, v2), _(m2, b2), _(m2, w2), _(e2, k2), T2 || (C2 = B(e2, "click", G2), T2 = true);
+        },
+        p(e3, i3) {
+            t3 = e3, 21508 & i3[0] && R2 !== (R2 = t3[2].timestamps[t3[35].at].slice(0, 4) + "") && H(s2, R2), 21508 & i3[0] && z2 !== (z2 = t3[2].timestamps[t3[35].at].slice(5, 7) + "") && H(a2, z2), 21504 & i3[0] && d2 !== (d2 = `height:${(t3[20](t3[35]) / Math.min(t3[20](t3[14][0]), t3[20](t3[12][0])) * 160).toFixed(0)}px`) && U(u2, "style", d2), 1024 & i3[0] && f2 !== (f2 = "w-3 rounded-b-full mx-1 " + ("strategy" === t3[10] ? "bg-primary" : "bg-gray-400")) && U(u2, "class", f2), 21504 & i3[0] && j2 !== (j2 = t3[20](t3[35]) + "") && H(g2, j2), 131072 & i3[0] && q2 !== (q2 = t3[17]("metrics.risk.days") + "") && H(w2, q2), 132096 & i3[0] && x2 !== (x2 = `w-14 pt-2 text-center ${0 === t3[17] ? "text-2xl font-bold" : ""} ${"strategy" === t3[10] ? "text-primary" : "text-gray-400"}`) && U(m2, "class", x2);
+        },
+        d(t4) {
+            t4 && E(e2), T2 = false, C2();
+        }
+    };
+}
+
+function rd(t3) {
+    var _a2, _b2;
+    let e2, i2, s2, r2, o2, a2, l2, h2, c2, u2, d2, f2, p2, m2, g2, y2, v2, b2, w2, x2, k2, T2, R2, z2, j2, q2, Y2, it2, st2, rt2, ht2, ct2, ut2, dt2, ft2, pt2, yt2, bt2, _t2, xt2, kt2, St2, It2, Mt2, At2, Lt2, Ot2, Ht2, Qt2, Jt2, te2, ee2, ie2, se2, ne2, re2, oe2, ae2, ce2, de2, fe2, pe2, ve2, be2, _e2, we2, xe2, ke2, Te2, Se2, Ee2, Ce2, Ie2, Me2, Pe2, Re2, Ae2, De2, Le2, Oe2, Fe2, Ne2, $e2 = t3[17]("risk.drawdowPeriods") + "",
+        Ve2 = t3[17]("profitability.stockList") + "",
+        ze2 = ((_a2 = t3[8]) == null ? void 0 : _a2.toLocaleDateString()) + "",
+        Be2 = ((_b2 = t3[9]) == null ? void 0 : _b2.toLocaleDateString()) + "",
+        Ue2 = t3[17]("metrics.risk.worstDrawdownPeriod") + "",
+        je2 = t3[17]("metrics.risk.worst10Strategy") + "",
+        He2 = t3[17]("metrics.risk.worst10Benchmark") + "",
+        We2 = t3[17]("benchmark") + "",
+        qe2 = t3[17]("strategy") + "",
+        Ke2 = t3[17]("metrics.risk.newHighTimeRank") + "",
+        Ge2 = t3[17]("metrics.risk.worst10Strategy") + "",
+        Ye2 = t3[17]("metrics.risk.worst10Benchmark") + "",
+        Qe2 = t3[17]("strategy") + "",
+        Xe2 = t3[17]("risk.drawdownPercentage") + "",
+        Je2 = ue(t3[4]),
+        Ze2 = [];
+    for (let e3 = 0; e3 < Je2.length; e3 += 1)
+        Ze2[e3] = id(ed(t3, Je2, e3));
+    rt2 = new Stocks({
+        props: {
+            lang: t3[0],
+            report: t3[2],
+            theme: t3[3],
+            browser: t3[1],
+            tstart: t3[8],
+            tend: t3[9]
+        }
+    });
+    let ti2 = ue("strategy" === t3[10] ? t3[4] : t3[13]),
+        ei2 = [];
+    for (let e3 = 0; e3 < ti2.length; e3 += 1)
+        ei2[e3] = sd(td(t3, ti2, e3));
+    let si2 = ue("strategy" === t3[10] ? t3[14] : t3[12]),
+        ni2 = [];
+    for (let e3 = 0; e3 < si2.length; e3 += 1)
+        ni2[e3] = nd(Zu(t3, si2, e3));
+    return {
+        c() {
+            e2 = P("div"), i2 = P("div"), s2 = P("div"), r2 = P("h3"), o2 = D($e2), a2 = $(), l2 = P("div"), h2 = P("div");
+            for (let t4 = 0; t4 < Ze2.length; t4 += 1)
+                Ze2[t4].c();
+            c2 = $(), u2 = P("div"), d2 = P("div"), f2 = $(), p2 = P("div"), m2 = P("span"), g2 = D(t3[7]), y2 = $(), v2 = D("天"), b2 = $(), w2 = P("div"), x2 = P("h3"), k2 = D(Ve2), T2 = $(), R2 = P("h4"), z2 = D(ze2), j2 = D("~"), q2 = D(Be2), Y2 = $(), it2 = P("div"), st2 = P("div"), me(rt2.$$.fragment), ht2 = $(), ct2 = P("div"), ut2 = P("h3"), dt2 = D(Ue2), ft2 = $(), pt2 = P("div"), yt2 = P("button"), bt2 = D(je2), xt2 = $(), kt2 = P("button"), St2 = D(He2), Mt2 = $(), At2 = P("div"), Lt2 = P("div");
+            for (let t4 = 0; t4 < ei2.length; t4 += 1)
+                ei2[t4].c();
+            Ot2 = $(), Ht2 = P("div"), Qt2 = P("div"), Jt2 = D(We2), te2 = $(), ee2 = P("div"), ie2 = D(qe2), se2 = $(), ne2 = P("div"), re2 = P("h3"), oe2 = D(Ke2), ae2 = $(), ce2 = P("div"), de2 = P("span"), fe2 = D(Ge2), ve2 = $(), be2 = P("span"), _e2 = D(Ye2), xe2 = $(), ke2 = P("div"), Te2 = P("div");
+            for (let t4 = 0; t4 < ni2.length; t4 += 1)
+                ni2[t4].c();
+            Se2 = $(), Ee2 = P("div"), Ce2 = P("div"), Ie2 = D(Qe2), Me2 = $(), Pe2 = P("div"), Re2 = P("h3"), Ae2 = D(Xe2), De2 = $(), Le2 = P("div"), U(r2, "class", "text-2xl font-bold text-base-content-200"), U(h2, "class", "flex mt-2 overflow-x-auto max-w-full pb-4 pl-1 no-scrollbar"), U(l2, "class", "flex"), U(d2, "class", "text-primary h-64 z-0"), U(m2, "class", "text-2xl font-bold text-primary"), U(p2, "class", "absolute bottom-8 left-2"), U(u2, "class", "relative overflow-hidden"), U(s2, "class", "h-full"), U(i2, "class", "col-span-6 md:p-8 pt-8 sm:rounded-xl md:border"), U(x2, "class", "text-base-content-200 text-2xl font-bold md:text-center"), U(R2, "class", "mt-2 text-base-content-100 md:text-center"), U(st2, "class", `overflow-auto max-h-72 text-base-content
+				${Lu() ? "no-scrollbar" : "show-scrollbar"}
+				`), U(it2, "class", "relative"), U(w2, "class", "col-span-6 md:col-span-6 md:p-8 pt-8 md:border sm:rounded-xl"), U(ut2, "class", "text-2xl font-bold text-base-content-200 text-center"), U(yt2, "class", _t2 = "border border-base-content/10 text-sm bg-base-100 hover:badge-primary hover:text-white px-2 py-1 rounded-xl " + ("strategy" === t3[10] ? "outline outline-primary" : "")), U(kt2, "class", It2 = "border border-base-content/10 text-sm bg-base-100 hover:badge-primary hover:text-white px-2 py-1 rounded-xl " + ("benchmark" === t3[10] ? "outline outline-primary" : "")), U(pt2, "class", "flex mt-4 justify-center gap-2"), U(Lt2, "class", "grid grid-cols-5 justify-start items-start mt-4"), U(Qt2, "class", "badge rounded bg-gray-500 text-white"), U(ee2, "class", "badge rounded bg-primary text-white"), U(Ht2, "class", "absolute inset-x-0 bottom-0 flex justify-center my-2 text-sm gap-2"), G(Ht2, "direction", "rtl"), U(ct2, "class", "relative col-span-6 md:col-span-3 md:p-8 pt-8 sm:rounded-xl md:border"), U(re2, "class", "text-2xl font-bold text-base-content-200 text-center"), U(de2, "class", pe2 = "border border-base-content/10 text-sm bg-base-100 hover:badge-primary hover:text-white px-2 py-1 cursor-pointer rounded-xl " + ("strategy" === t3[10] ? "outline outline-primary" : "")), U(be2, "class", we2 = "border border-base-content/10 text-sm bg-base-100 hover:badge-primary hover:text-white px-2 py-1 cursor-pointer rounded-xl " + ("benchmark" === t3[10] ? "outline outline-primary" : "")), U(ce2, "class", "flex mt-4 justify-center gap-2"), U(Te2, "class", "flex justify-between items-start mt-4 text-sm"), U(Ce2, "class", "badge rounded badge-primary text-white"), U(Ee2, "class", "absolute inset-x-0 bottom-0 flex justify-center my-2 text-sm"), G(Ee2, "direction", "rtl"), U(ne2, "class", "relative col-span-6 md:col-span-3 md:p-8 pt-8 sm:rounded-xl md:border"), U(Re2, "class", "text-2xl font-bold text-base-content-200"), U(Le2, "class", "text-primary h-48 z-0"), U(Pe2, "class", "col-span-6 md:p-8 pt-8 sm:rounded-xl md:border"), U(e2, "class", "grid grid-cols-6 gap-4 text-base-content-300");
+        },
+        m(n2, E2) {
+            S(n2, e2, E2), _(e2, i2), _(i2, s2), _(s2, r2), _(r2, o2), _(s2, a2), _(s2, l2), _(l2, h2);
+            for (let t4 = 0; t4 < Ze2.length; t4 += 1)
+                Ze2[t4] && Ze2[t4].m(h2, null);
+            _(s2, c2), _(s2, u2), _(u2, d2), t3[23](d2), _(u2, f2), _(u2, p2), _(p2, m2), _(m2, g2), _(m2, y2), _(p2, v2), _(e2, b2), _(e2, w2), _(w2, x2), _(x2, k2), _(w2, T2), _(w2, R2), _(R2, z2), _(R2, j2), _(R2, q2), _(w2, Y2), _(w2, it2), _(it2, st2), ge(rt2, st2, null), _(e2, ht2), _(e2, ct2), _(ct2, ut2), _(ut2, dt2), _(ct2, ft2), _(ct2, pt2), _(pt2, yt2), _(yt2, bt2), _(pt2, xt2), _(pt2, kt2), _(kt2, St2), _(ct2, Mt2), _(ct2, At2), _(At2, Lt2);
+            for (let t4 = 0; t4 < ei2.length; t4 += 1)
+                ei2[t4] && ei2[t4].m(Lt2, null);
+            _(ct2, Ot2), _(ct2, Ht2), _(Ht2, Qt2), _(Qt2, Jt2), _(Ht2, te2), _(Ht2, ee2), _(ee2, ie2), _(e2, se2), _(e2, ne2), _(ne2, re2), _(re2, oe2), _(ne2, ae2), _(ne2, ce2), _(ce2, de2), _(de2, fe2), _(ce2, ve2), _(ce2, be2), _(be2, _e2), _(ne2, xe2), _(ne2, ke2), _(ke2, Te2);
+            for (let t4 = 0; t4 < ni2.length; t4 += 1)
+                ni2[t4] && ni2[t4].m(Te2, null);
+            _(ne2, Se2), _(ne2, Ee2), _(Ee2, Ce2), _(Ce2, Ie2), _(e2, Me2), _(e2, Pe2), _(Pe2, Re2), _(Re2, Ae2), _(Pe2, De2), _(Pe2, Le2), t3[30](Le2), Oe2 = true, Fe2 || (Ne2 = [B(yt2, "click", t3[24]), B(kt2, "click", t3[25]), B(de2, "click", t3[27]), B(be2, "click", t3[28])], Fe2 = true);
+        },
+        p(t4, e3) {
+            var _a3, _b3;
+            if ((!Oe2 || 131072 & e3[0]) && $e2 !== ($e2 = t4[17]("risk.drawdowPeriods") + "") && H(o2, $e2), 788500 & e3[0]) {
+                let i4;
+                for (Je2 = ue(t4[4]), i4 = 0; i4 < Je2.length; i4 += 1) {
+                    const s3 = ed(t4, Je2, i4);
+                    Ze2[i4] ? Ze2[i4].p(s3, e3) : (Ze2[i4] = id(s3), Ze2[i4].c(), Ze2[i4].m(h2, null));
+                }
+                for (; i4 < Ze2.length; i4 += 1)
+                    Ze2[i4].d(1);
+                Ze2.length = Je2.length;
+            }
+            (!Oe2 || 128 & e3[0]) && H(g2, t4[7]), (!Oe2 || 131072 & e3[0]) && Ve2 !== (Ve2 = t4[17]("profitability.stockList") + "") && H(k2, Ve2), (!Oe2 || 256 & e3[0]) && ze2 !== (ze2 = ((_a3 = t4[8]) == null ? void 0 : _a3.toLocaleDateString()) + "") && H(z2, ze2), (!Oe2 || 512 & e3[0]) && Be2 !== (Be2 = ((_b3 = t4[9]) == null ? void 0 : _b3.toLocaleDateString()) + "") && H(q2, Be2);
+            const i3 = {};
+            if (1 & e3[0] && (i3.lang = t4[0]), 4 & e3[0] && (i3.report = t4[2]), 8 & e3[0] && (i3.theme = t4[3]), 2 & e3[0] && (i3.browser = t4[1]), 256 & e3[0] && (i3.tstart = t4[8]), 512 & e3[0] && (i3.tend = t4[9]), rt2.$set(i3), (!Oe2 || 131072 & e3[0]) && Ue2 !== (Ue2 = t4[17]("metrics.risk.worstDrawdownPeriod") + "") && H(dt2, Ue2), (!Oe2 || 131072 & e3[0]) && je2 !== (je2 = t4[17]("metrics.risk.worst10Strategy") + "") && H(bt2, je2), (!Oe2 || 1024 & e3[0] && _t2 !== (_t2 = "border border-base-content/10 text-sm bg-base-100 hover:badge-primary hover:text-white px-2 py-1 rounded-xl " + ("strategy" === t4[10] ? "outline outline-primary" : ""))) && U(yt2, "class", _t2), (!Oe2 || 131072 & e3[0]) && He2 !== (He2 = t4[17]("metrics.risk.worst10Benchmark") + "") && H(St2, He2), (!Oe2 || 1024 & e3[0] && It2 !== (It2 = "border border-base-content/10 text-sm bg-base-100 hover:badge-primary hover:text-white px-2 py-1 rounded-xl " + ("benchmark" === t4[10] ? "outline outline-primary" : ""))) && U(kt2, "class", It2), 1027092 & e3[0]) {
+                let i4;
+                for (ti2 = ue("strategy" === t4[10] ? t4[4] : t4[13]), i4 = 0; i4 < ti2.length; i4 += 1) {
+                    const s3 = td(t4, ti2, i4);
+                    ei2[i4] ? ei2[i4].p(s3, e3) : (ei2[i4] = sd(s3), ei2[i4].c(), ei2[i4].m(Lt2, null));
+                }
+                for (; i4 < ei2.length; i4 += 1)
+                    ei2[i4].d(1);
+                ei2.length = ti2.length;
+            }
+            if ((!Oe2 || 131072 & e3[0]) && We2 !== (We2 = t4[17]("benchmark") + "") && H(Jt2, We2), (!Oe2 || 131072 & e3[0]) && qe2 !== (qe2 = t4[17]("strategy") + "") && H(ie2, qe2), (!Oe2 || 131072 & e3[0]) && Ke2 !== (Ke2 = t4[17]("metrics.risk.newHighTimeRank") + "") && H(oe2, Ke2), (!Oe2 || 131072 & e3[0]) && Ge2 !== (Ge2 = t4[17]("metrics.risk.worst10Strategy") + "") && H(fe2, Ge2), (!Oe2 || 1024 & e3[0] && pe2 !== (pe2 = "border border-base-content/10 text-sm bg-base-100 hover:badge-primary hover:text-white px-2 py-1 cursor-pointer rounded-xl " + ("strategy" === t4[10] ? "outline outline-primary" : ""))) && U(de2, "class", pe2), (!Oe2 || 131072 & e3[0]) && Ye2 !== (Ye2 = t4[17]("metrics.risk.worst10Benchmark") + "") && H(_e2, Ye2), (!Oe2 || 1024 & e3[0] && we2 !== (we2 = "border border-base-content/10 text-sm bg-base-100 hover:badge-primary hover:text-white px-2 py-1 cursor-pointer rounded-xl " + ("benchmark" === t4[10] ? "outline outline-primary" : ""))) && U(be2, "class", we2), 1989636 & e3[0]) {
+                let i4;
+                for (si2 = ue("strategy" === t4[10] ? t4[14] : t4[12]), i4 = 0; i4 < si2.length; i4 += 1) {
+                    const s3 = Zu(t4, si2, i4);
+                    ni2[i4] ? ni2[i4].p(s3, e3) : (ni2[i4] = nd(s3), ni2[i4].c(), ni2[i4].m(Te2, null));
+                }
+                for (; i4 < ni2.length; i4 += 1)
+                    ni2[i4].d(1);
+                ni2.length = si2.length;
+            }
+            (!Oe2 || 131072 & e3[0]) && Qe2 !== (Qe2 = t4[17]("strategy") + "") && H(Ie2, Qe2), (!Oe2 || 131072 & e3[0]) && Xe2 !== (Xe2 = t4[17]("risk.drawdownPercentage") + "") && H(Ae2, Xe2);
+        },
+        i(t4) {
+            Oe2 || (le(rt2.$$.fragment, t4), Oe2 = true);
+        },
+        o(t4) {
+            he(rt2.$$.fragment, t4), Oe2 = false;
+        },
+        d(i3) {
+            i3 && E(e2), C(Ze2, i3), t3[23](null), ye(rt2), C(ei2, i3), C(ni2, i3), t3[30](null), Fe2 = false, n(Ne2);
+        }
+    };
+}
+
+function od(t3, e2, i2) {
+    let s2, n2, r2, o2, a2, l2, h2, c2, u2, d2, {
+            lang: f2 = "en"
+        } = e2,
+        {
+            browser: p2
+        } = e2,
+        {
+            report: m2
+        } = e2,
+        {
+            theme: g2 = "light"
+        } = e2,
+        y2 = null,
+        v2 = null,
+        b2 = null,
+        _2 = null,
+        w2 = null;
+
+    function x2(t4, e3) {
+        if (y2)
+            if ("string" == typeof t4 && "string" == typeof e3) {
+                const s3 = new Date(t4),
+                    n3 = new Date(e3);
+                y2.setTimeScale(s3, n3), i2(7, b2 = S2({
+                    start: t4,
+                    end: e3
+                })), i2(7, b2 = ((s3 - n3) / 864e5).toFixed(0)), i2(8, _2 = s3), i2(9, w2 = n3);
+            } else {
+                const s3 = m2.indexOfTimestamps(t4),
+                    n3 = m2.indexOfTimestamps(e3),
+                    r3 = new Date(m2.timestamps[s3]),
+                    o3 = new Date(m2.timestamps[n3]);
+                y2.setTimeScale(r3, o3), i2(8, _2 = r3), i2(9, w2 = o3);
+            }
+    }
+
+    function k2(t4) {
+        y2 || i2(21, y2 = new TwChart(u2, true)), y2.setTheme(g2);
+        const e3 = "all" === t4 ? m2.timestamps.length : 100,
+            s3 = m2.timestamps.length / (e3 / 100),
+            n3 = m2.createTradingviewSeries("strategy", 0, -1, s3),
+            r3 = m2.createTradingviewSeries("benchmark", 0, -1, s3);
+        y2.resetAreaSeries(0), y2.resetAreaSeries(1), y2.series[0].setData(n3), y2.series[1].setData(r3), y2.chart.subscribeCrosshairMove((t5) => {}), y2.chart.subscribeClick((t5) => {}), y2.chart.timeScale().subscribeVisibleTimeRangeChange((t5) => {}), "all" === t4 && y2.setTimeScale(new Date(m2.timestamps[0]), new Date(m2.timestamps[m2.timestamps.length - 1]));
+    }
+    let T2 = "strategy";
+    const S2 = (t4) => ((new Date(m2.timestamps[t4.end]) - new Date(m2.timestamps[t4.start])) / 864e5).toFixed(0);
+    pt(() => {
+        if (!p2)
+            return;
+        const t4 = o2[0];
+        k2("year"), x2(m2.timestamps[t4.start], m2.timestamps[t4.end]), v2 || (v2 = new TwChart(d2, false)), v2.setTheme(g2), m2.timestamps.length, v2.resetAreaSeries(0), v2.resetAreaSeries(1), v2.series[0].setData(n2), v2.series[1].setData(r2), v2.setTimeScale(new Date(m2.timestamps[0]), new Date(m2.timestamps[m2.timestamps.length - 1]));
+    });
+    return t3.$$set = (t4) => {
+        "lang" in t4 && i2(0, f2 = t4.lang), "browser" in t4 && i2(1, p2 = t4.browser), "report" in t4 && i2(2, m2 = t4.report), "theme" in t4 && i2(3, g2 = t4.theme);
+    }, t3.$$.update = () => {
+        1 & t3.$$.dirty[0] && i2(17, s2 = (t4) => "en" === f2 ? sl(t4) : nl(t4)), 4 & t3.$$.dirty[0] && i2(16, n2 = m2.createTradingViewDrawdown("strategy", m2.timestamps.length)), 4 & t3.$$.dirty[0] && i2(15, r2 = m2.createTradingViewDrawdown("benchmark", m2.timestamps.length)), 2097160 & t3.$$.dirty[0] && y2 && y2.setTheme(g2), 4 & t3.$$.dirty[0] && i2(4, [o2, a2] = m2.calculateDrawdown("strategy"), o2, (i2(14, a2), i2(2, m2))), 4 & t3.$$.dirty[0] && i2(13, [l2, h2] = m2.calculateDrawdown("benchmark"), l2, (i2(12, h2), i2(2, m2))), 16 & t3.$$.dirty[0] && i2(11, c2 = o2[0]);
+    }, [f2, p2, m2, g2, o2, u2, d2, b2, _2, w2, T2, c2, h2, l2, a2, r2, n2, s2, x2, k2, S2, y2, (t4) => {
+        k2("year"), x2(m2.timestamps[t4.start], m2.timestamps[t4.end]), i2(11, c2 = t4);
+    }, function(t4) {
+        xt[t4 ? "unshift" : "push"](() => {
+            u2 = t4, i2(5, u2);
+        });
+    }, () => {
+        i2(10, T2 = "strategy");
+    }, () => {
+        i2(10, T2 = "benchmark");
+    }, (t4) => {
+        k2("year"), x2(m2.timestamps[t4.start], m2.timestamps[t4.end]), i2(11, c2 = t4);
+    }, () => {
+        i2(10, T2 = "strategy");
+    }, () => {
+        i2(10, T2 = "benchmark");
+    }, (t4) => {
+        k2("year"), x2(m2.timestamps[t4.start], m2.timestamps[t4.end]), i2(11, c2 = t4);
+    }, function(t4) {
+        xt[t4 ? "unshift" : "push"](() => {
+            d2 = t4, i2(6, d2);
+        });
+    }];
+}
+we(Ratio, {
+    browser: {},
+    report: {},
+    theme: {},
+    lang: {}
+}, [], [], true);
+class Risk extends SvelteComponent {
+    constructor(t3) {
+        super(), ve(this, t3, od, rd, o, {
+            lang: 0,
+            browser: 1,
+            report: 2,
+            theme: 3
+        }, null, [-1, -1]);
+    }
+    get lang() {
+        return this.$$.ctx[0];
+    }
+    set lang(t3) {
+        this.$$set({
+            lang: t3
+        }), te();
+    }
+    get browser() {
+        return this.$$.ctx[1];
+    }
+    set browser(t3) {
+        this.$$set({
+            browser: t3
+        }), te();
+    }
+    get report() {
+        return this.$$.ctx[2];
+    }
+    set report(t3) {
+        this.$$set({
+            report: t3
+        }), te();
+    }
+    get theme() {
+        return this.$$.ctx[3];
+    }
+    set theme(t3) {
+        this.$$set({
+            theme: t3
+        }), te();
+    }
+}
+we(Risk, {
+    lang: {},
+    browser: {},
+    report: {},
+    theme: {}
+}, [], [], true);
+
+function ad(e2) {
+    let i2, s2, r2, o2, a2, l2, h2, c2, u2, d2, f2, p2, m2, g2, y2, v2, b2, w2, x2, k2, T2, C2, R2, z2, j2, G2, Y2, it2, st2, rt2, ht2, ct2, ut2, dt2, ft2, pt2, yt2, bt2, _t2, xt2, kt2, St2, It2, Mt2, At2, Lt2, Ot2, Ht2, Qt2, Jt2, te2, ee2, ie2, se2, ne2, re2, oe2, ae2, le2, he2, ce2, ue2, de2, fe2, pe2, me2, ge2, ye2, ve2, be2, _e2, we2, xe2, ke2, Te2, Se2, Ee2, Ce2, Ie2, Me2, Pe2, Re2, Ae2, De2, Le2, Oe2, Fe2, Ne2, $e2, Ve2, ze2, Be2, Ue2, je2, He2, We2, qe2, Ke2, Ge2, Ye2, Qe2, Xe2, Je2, Ze2, ti2, ei2, si2, ni2, ri2, ai2, li2, hi2, ci2, ui2, yi2, _i2, ki2 = e2[10]("metrics.winrate.returnDistribution") + "",
+        Ti2 = e2[10]("metrics.winrate.distributionInfo1") + "",
+        Si2 = (100 * e2[11]).toFixed(1) + "",
+        Ei2 = e2[10]("metrics.winrate.distributionInfo2") + "",
+        Ii2 = e2[10]("metrics.winrate.return") + "",
+        Li2 = e2[10]("metrics.winrate.simulatedStopLoss") + "",
+        Oi2 = e2[10]("metrics.winrate.stoploss") + "",
+        Fi2 = (0 !== e2[0] ? 100 * e2[0] + "%" : e2[10]("metrics.winrate.none")) + "",
+        Ni2 = e2[10]("metrics.winrate.extraProfitLoss") + "",
+        Vi2 = (e2[9] > 0 ? "+" : "") + (100 * e2[9]).toFixed(1),
+        zi2 = e2[10]("metrics.winrate.stoplossRatio") + "",
+        Ui2 = (100 * e2[8]).toFixed(1) + "",
+        ji2 = e2[10]("metrics.winrate.maeReturn") + "",
+        Wi2 = e2[10]("metrics.winrate.return") + "",
+        qi2 = e2[10]("metrics.winrate.mae") + "",
+        Gi2 = e2[10]("metrics.winrate.simulatedTakeProfit") + "",
+        Yi2 = e2[10]("metrics.winrate.takeProfit") + "",
+        Qi2 = (0 !== e2[1] ? 100 * e2[1] + "%" : e2[10]("metrics.winrate.none")) + "",
+        Xi2 = e2[10]("metrics.winrate.extraProfitLossTakingProfit") + "",
+        Ji2 = (e2[7] > 0 ? "+" : "") + (100 * e2[7]).toFixed(1),
+        ts2 = e2[10]("metrics.winrate.takeProfitRatio") + "",
+        es2 = (100 * e2[6]).toFixed(1) + "",
+        is2 = e2[10]("metrics.winrate.mfeReturn") + "",
+        ss2 = e2[10]("metrics.winrate.return") + "",
+        ns2 = e2[10]("metrics.winrate.mae") + "",
+        rs2 = e2[10]("metrics.winrate.maemfe") + "",
+        os2 = e2[10]("metrics.winrate.mfe") + "",
+        as2 = e2[10]("metrics.winrate.mae") + "";
+    return {
+        c() {
+            i2 = P("div"), s2 = P("div"), r2 = P("div"), o2 = P("h3"), a2 = D(ki2), l2 = $(), h2 = P("span"), c2 = D(Ti2), u2 = $(), d2 = D(Si2), f2 = $(), p2 = D(Ei2), m2 = $(), g2 = P("canvas"), y2 = $(), v2 = P("div"), b2 = D(Ii2), w2 = $(), x2 = P("div"), k2 = P("h3"), T2 = D(Li2), C2 = $(), R2 = P("span"), z2 = D(Oi2), j2 = $(), G2 = P("span"), Y2 = D(Fi2), it2 = $(), st2 = P("br"), rt2 = $(), ht2 = P("span"), ct2 = D(Ni2), ut2 = $(), dt2 = P("span"), ft2 = D(Vi2), pt2 = D("\n				%"), yt2 = $(), bt2 = P("br"), _t2 = $(), xt2 = P("span"), kt2 = D(zi2), St2 = $(), It2 = P("span"), Mt2 = D(Ui2), At2 = D("%"), Lt2 = $(), Ot2 = P("input"), Ht2 = $(), Qt2 = P("div"), Qt2.innerHTML = '<span class="font-bold text-sm">0％</span> <span class="font-bold text-sm">5％</span> <span class="font-bold text-sm">10％</span> <span class="font-bold text-sm">15％</span> <span class="font-bold text-sm">20％</span> <span class="font-bold text-sm">25％</span> <span class="font-bold text-sm">30％</span>', Jt2 = $(), te2 = P("h3"), ee2 = D(ji2), ie2 = $(), se2 = P("div"), ne2 = D(Wi2), re2 = $(), oe2 = P("canvas"), ae2 = $(), le2 = P("div"), he2 = D(qi2), ce2 = $(), ue2 = P("div"), de2 = P("h3"), fe2 = D(Gi2), pe2 = $(), me2 = P("span"), ge2 = D(Yi2), ye2 = P("span"), ve2 = D(Qi2), be2 = $(), _e2 = P("br"), we2 = $(), xe2 = P("span"), ke2 = D(Xi2), Te2 = $(), Se2 = P("span"), Ee2 = D(Ji2), Ce2 = $(), Ie2 = D("%"), Me2 = $(), Pe2 = P("br"), Re2 = $(), Ae2 = P("span"), De2 = D(ts2), Le2 = P("span"), Oe2 = D(es2), Fe2 = D("%"), Ne2 = $(), $e2 = P("input"), Ve2 = $(), ze2 = P("div"), ze2.innerHTML = '<span class="font-bold text-sm">0％</span> <span class="font-bold text-sm">5％</span> <span class="font-bold text-sm">10％</span> <span class="font-bold text-sm">15％</span> <span class="font-bold text-sm">20％</span> <span class="font-bold text-sm">25％</span> <span class="font-bold text-sm">30％</span>', Be2 = $(), Ue2 = P("h3"), je2 = D(is2), He2 = $(), We2 = P("div"), qe2 = D(ss2), Ke2 = $(), Ge2 = P("canvas"), Ye2 = $(), Qe2 = P("div"), Xe2 = D(ns2), Je2 = $(), Ze2 = P("div"), ti2 = P("h3"), ei2 = D(rs2), si2 = $(), ni2 = P("div"), ri2 = D(os2), ai2 = $(), li2 = P("canvas"), hi2 = $(), ci2 = P("div"), ui2 = D(as2), U(o2, "class", "text-2xl font-bold mb-4 text-base-content-200"), U(g2, "class", "mt-2 max-h-[400px]"), U(v2, "class", "text-sm text-center pb-4 mt-2"), U(r2, "class", "col-span-6 text-center p-2 md:p-8 pt-8 md:border rounded-xl"), U(k2, "class", "text-2xl font-bold mb-4 text-center text-base-content-200"), U(G2, "class", "font-bold"), U(dt2, "class", "font-bold"), U(It2, "class", "font-bold"), U(Ot2, "type", "range"), U(Ot2, "min", "0"), U(Ot2, "max", "0.3"), U(Ot2, "class", "range range-secondary mt-4"), U(Ot2, "step", "0.05"), U(Qt2, "class", "w-full flex justify-between text-xs px-2"), U(te2, "class", "text-2xl font-bold mt-6 mb-3 text-center text-base-content-200"), U(se2, "class", "text-base-content-100 text-sm font-bold mt-2"), U(oe2, "class", "mt-2"), U(le2, "class", "text-base-content-100 text-sm text-center font-bold"), U(x2, "class", "col-span-6 md:col-span-3 p-2 md:p-8 pt-8 md:border rounded-xl"), U(de2, "class", "text-2xl font-bold mb-4 text-center text-base-content-200"), U(ye2, "class", "font-bold"), U(Se2, "class", "font-bold"), U(Le2, "class", "font-bold"), U($e2, "type", "range"), U($e2, "min", "0"), U($e2, "max", "0.3"), U($e2, "class", "range range-primary mt-4"), U($e2, "step", "0.05"), U(ze2, "class", "w-full flex justify-between text-xs px-2"), U(Ue2, "class", "text-2xl font-bold mt-6 mb-3 text-center text-base-content-200"), U(We2, "class", "text-base-content-100 text-sm font-bold mt-2"), U(Ge2, "class", "mt-2"), U(Qe2, "class", "text-base-content-100 text-sm text-center font-bold"), U(ue2, "class", "col-span-6 md:col-span-3 p-2 md:p-8 pt-8 md:border rounded-xl"), U(ti2, "class", "text-2xl font-bold text-center text-base-content-200"), U(ni2, "class", "text-base-content-100 text-sm font-bold mt-4"), U(li2, "class", "mt-2"), U(ci2, "class", "text-base-content-100 text-sm text-center font-bold"), U(Ze2, "class", "col-span-6 p-2 md:p-8 pt-8 md:border rounded-xl"), U(s2, "class", "grid grid-cols-6 gap-4"), U(i2, "class", "text-base-content-200");
+        },
+        m(t3, n2) {
+            S(t3, i2, n2), _(i2, s2), _(s2, r2), _(r2, o2), _(o2, a2), _(r2, l2), _(r2, h2), _(h2, c2), _(h2, u2), _(h2, d2), _(h2, f2), _(h2, p2), _(r2, m2), _(r2, g2), e2[20](g2), _(r2, y2), _(r2, v2), _(v2, b2), _(s2, w2), _(s2, x2), _(x2, k2), _(k2, T2), _(x2, C2), _(x2, R2), _(R2, z2), _(R2, j2), _(R2, G2), _(G2, Y2), _(x2, it2), _(x2, st2), _(x2, rt2), _(x2, ht2), _(ht2, ct2), _(ht2, ut2), _(ht2, dt2), _(dt2, ft2), _(ht2, pt2), _(x2, yt2), _(x2, bt2), _(x2, _t2), _(x2, xt2), _(xt2, kt2), _(xt2, St2), _(xt2, It2), _(It2, Mt2), _(It2, At2), _(x2, Lt2), _(x2, Ot2), q(Ot2, e2[0]), _(x2, Ht2), _(x2, Qt2), _(x2, Jt2), _(x2, te2), _(te2, ee2), _(x2, ie2), _(x2, se2), _(se2, ne2), _(x2, re2), _(x2, oe2), e2[22](oe2), _(x2, ae2), _(x2, le2), _(le2, he2), _(s2, ce2), _(s2, ue2), _(ue2, de2), _(de2, fe2), _(ue2, pe2), _(ue2, me2), _(me2, ge2), _(me2, ye2), _(ye2, ve2), _(ue2, be2), _(ue2, _e2), _(ue2, we2), _(ue2, xe2), _(xe2, ke2), _(xe2, Te2), _(xe2, Se2), _(Se2, Ee2), _(Se2, Ce2), _(xe2, Ie2), _(ue2, Me2), _(ue2, Pe2), _(ue2, Re2), _(ue2, Ae2), _(Ae2, De2), _(Ae2, Le2), _(Le2, Oe2), _(Le2, Fe2), _(ue2, Ne2), _(ue2, $e2), q($e2, e2[1]), _(ue2, Ve2), _(ue2, ze2), _(ue2, Be2), _(ue2, Ue2), _(Ue2, je2), _(ue2, He2), _(ue2, We2), _(We2, qe2), _(ue2, Ke2), _(ue2, Ge2), e2[24](Ge2), _(ue2, Ye2), _(ue2, Qe2), _(Qe2, Xe2), _(s2, Je2), _(s2, Ze2), _(Ze2, ti2), _(ti2, ei2), _(Ze2, si2), _(Ze2, ni2), _(ni2, ri2), _(Ze2, ai2), _(Ze2, li2), e2[25](li2), _(Ze2, hi2), _(Ze2, ci2), _(ci2, ui2), yi2 || (_i2 = [B(Ot2, "change", e2[21]), B(Ot2, "input", e2[21]), B($e2, "change", e2[23]), B($e2, "input", e2[23])], yi2 = true);
+        },
+        p(t3, e3) {
+            1024 & e3[0] && ki2 !== (ki2 = t3[10]("metrics.winrate.returnDistribution") + "") && H(a2, ki2), 1024 & e3[0] && Ti2 !== (Ti2 = t3[10]("metrics.winrate.distributionInfo1") + "") && H(c2, Ti2), 1024 & e3[0] && Ei2 !== (Ei2 = t3[10]("metrics.winrate.distributionInfo2") + "") && H(p2, Ei2), 1024 & e3[0] && Ii2 !== (Ii2 = t3[10]("metrics.winrate.return") + "") && H(b2, Ii2), 1024 & e3[0] && Li2 !== (Li2 = t3[10]("metrics.winrate.simulatedStopLoss") + "") && H(T2, Li2), 1024 & e3[0] && Oi2 !== (Oi2 = t3[10]("metrics.winrate.stoploss") + "") && H(z2, Oi2), 1025 & e3[0] && Fi2 !== (Fi2 = (0 !== t3[0] ? 100 * t3[0] + "%" : t3[10]("metrics.winrate.none")) + "") && H(Y2, Fi2), 1024 & e3[0] && Ni2 !== (Ni2 = t3[10]("metrics.winrate.extraProfitLoss") + "") && H(ct2, Ni2), 512 & e3[0] && Vi2 !== (Vi2 = (t3[9] > 0 ? "+" : "") + (100 * t3[9]).toFixed(1)) && H(ft2, Vi2), 1024 & e3[0] && zi2 !== (zi2 = t3[10]("metrics.winrate.stoplossRatio") + "") && H(kt2, zi2), 256 & e3[0] && Ui2 !== (Ui2 = (100 * t3[8]).toFixed(1) + "") && H(Mt2, Ui2), 1 & e3[0] && q(Ot2, t3[0]), 1024 & e3[0] && ji2 !== (ji2 = t3[10]("metrics.winrate.maeReturn") + "") && H(ee2, ji2), 1024 & e3[0] && Wi2 !== (Wi2 = t3[10]("metrics.winrate.return") + "") && H(ne2, Wi2), 1024 & e3[0] && qi2 !== (qi2 = t3[10]("metrics.winrate.mae") + "") && H(he2, qi2), 1024 & e3[0] && Gi2 !== (Gi2 = t3[10]("metrics.winrate.simulatedTakeProfit") + "") && H(fe2, Gi2), 1024 & e3[0] && Yi2 !== (Yi2 = t3[10]("metrics.winrate.takeProfit") + "") && H(ge2, Yi2), 1026 & e3[0] && Qi2 !== (Qi2 = (0 !== t3[1] ? 100 * t3[1] + "%" : t3[10]("metrics.winrate.none")) + "") && H(ve2, Qi2), 1024 & e3[0] && Xi2 !== (Xi2 = t3[10]("metrics.winrate.extraProfitLossTakingProfit") + "") && H(ke2, Xi2), 128 & e3[0] && Ji2 !== (Ji2 = (t3[7] > 0 ? "+" : "") + (100 * t3[7]).toFixed(1)) && H(Ee2, Ji2), 1024 & e3[0] && ts2 !== (ts2 = t3[10]("metrics.winrate.takeProfitRatio") + "") && H(De2, ts2), 64 & e3[0] && es2 !== (es2 = (100 * t3[6]).toFixed(1) + "") && H(Oe2, es2), 2 & e3[0] && q($e2, t3[1]), 1024 & e3[0] && is2 !== (is2 = t3[10]("metrics.winrate.mfeReturn") + "") && H(je2, is2), 1024 & e3[0] && ss2 !== (ss2 = t3[10]("metrics.winrate.return") + "") && H(qe2, ss2), 1024 & e3[0] && ns2 !== (ns2 = t3[10]("metrics.winrate.mae") + "") && H(Xe2, ns2), 1024 & e3[0] && rs2 !== (rs2 = t3[10]("metrics.winrate.maemfe") + "") && H(ei2, rs2), 1024 & e3[0] && os2 !== (os2 = t3[10]("metrics.winrate.mfe") + "") && H(ri2, os2), 1024 & e3[0] && as2 !== (as2 = t3[10]("metrics.winrate.mae") + "") && H(ui2, as2);
+        },
+        i: t,
+        o: t,
+        d(t3) {
+            t3 && E(i2), e2[20](null), e2[22](null), e2[24](null), e2[25](null), yi2 = false, n(_i2);
+        }
+    };
+}
+
+function ld(t3, e2, i2) {
+    let s2, n2, r2, o2, a2, l2, h2, {
+        lang: c2 = "en"
+    } = e2;
+    Chart.register(BubbleController, LinearScale, PointElement, Ga, CategoryScale, BarController, BarElement, LineElement, LineController);
+    let {
+        browser: u2
+    } = e2, {
+        report: d2
+    } = e2, {
+        theme: f2 = "light"
+    } = e2, p2 = 0, m2 = 0;
+    const g2 = d2.trades.map((t4) => t4.return),
+        y2 = g2.reduce((t4, e3) => t4 + e3, 0) / g2.length,
+        v2 = g2.reduce((t4, e3) => t4 + Math.pow(e3 - y2, 2), 0) / g2.length,
+        b2 = Math.sqrt(v2);
+
+    function _2(t4, e3) {
+        const i3 = -3 * b2,
+            s3 = (3 * b2 - i3) / e3,
+            n3 = new Array(e3).fill(0),
+            r3 = [];
+        t4.forEach((t5) => {
+            const r4 = Math.min(Math.floor((t5 - i3) / s3), e3 - 1);
+            n3[r4]++;
+        });
+        for (let t5 = 0; t5 < e3; t5++)
+            r3.push([i3 + t5 * s3, i3 + (t5 + 1) * s3]);
+        return {
+            bins: n3,
+            ranges: r3
+        };
+    }
+    let w2;
+    [...g2].sort((t4, e3) => t4 - e3);
+    let x2, k2 = null;
+    const T2 = function(t4, e3 = 0.95) {
+        const i3 = t4;
+        return 0 === i3.length ? null : (i3.sort((t5, e4) => t5 - e4), i3[Math.floor((1 - e3) * i3.length)]);
+    }(d2.trades.map((t4) => t4.return));
+
+    function S2(t4) {
+        const e3 = w2,
+            i3 = t4.ranges.map((t5) => t5[0]),
+            s3 = i3.map((t5) => t5 >= 0 ? "light" === f2 ? "#725bf5" : "#7a64f5" : "rgba(241, 99, 102, 1)");
+        null !== k2 && k2.destroy(), k2 = new Chart(e3, {
+            type: "bar",
+            data: {
+                labels: i3,
+                datasets: [{
+                    data: t4.bins,
+                    backgroundColor: s3
+                }]
+            },
+            options: {
+                responsive: true,
+                maintainAspectRatio: true,
+                scales: {
+                    x: {
+                        type: "category",
+                        ticks: {
+                            callback: (t5, e4, s4) => (100 * i3[e4]).toFixed(1) + "%",
+                            color: "light" === f2 ? "#000000aa" : "#FFFFFFaa"
+                        },
+                        grid: {
+                            color: "#77777755",
+                            tickBorderDash: [2, 2]
+                        }
+                    },
+                    y: {
+                        type: "linear",
+                        ticks: {
+                            callback: (t5, e4, i4) => t5 + " trades",
+                            color: "light" === f2 ? "#000000aa" : "#FFFFFFaa"
+                        },
+                        grid: {
+                            color: "#77777755",
+                            tickBorderDash: [2, 2]
+                        }
+                    }
+                }
+            }
+        });
+    }
+    const E2 = d2.trades.filter((t4) => t4.return > 0),
+        C2 = d2.trades.filter((t4) => t4.return <= 0);
+
+    function P2(t4, e3, i3, s3) {
+        const n3 = Math.max(...d2.trades.map((t5) => Math.abs(t5[e3]))),
+            r3 = Math.max(...d2.trades.map((t5) => Math.abs(t5[i3]))),
+            o3 = d2.trades.map((t5) => Math.log(Math.abs(t5.return) + 1)),
+            a3 = Math.max(...o3),
+            l3 = Math.min(...o3);
+
+        function h3(t5, e4, i4, s4, n4) {
+            return (t5 - e4) / (i4 - e4) * (n4 - s4) + s4;
+        }
+
+        function c3(t5, i4) {
+            const s4 = 0 !== p2 ? p2 : 1;
+            return "mae" === e3 ? i4 < -s4 ? -s4 : t5 : "gmfe" === e3 && i4 > m2 && 0 !== m2 ? m2 : t5;
+        }
+        const u3 = {
+            type: "bubble",
+            data: {
+                datasets: [{
+                    label: "Winning",
+                    data: E2.map((t5) => ({
+                        x: Math.abs(t5[e3]),
+                        y: Math.abs(c3(t5[i3], t5[e3])),
+                        r: h3(Math.log(Math.abs(t5.return) + 1), l3, a3, 3, 20),
+                        t: t5
+                    })),
+                    backgroundColor: "rgba(99, 102, 241, 0.5)"
+                }, {
+                    label: "Losing",
+                    data: C2.map((t5) => ({
+                        x: Math.abs(t5[e3]),
+                        y: Math.abs(c3(t5[i3], t5[e3])),
+                        r: h3(Math.log(Math.abs(t5.return) + 1), l3, a3, 3, 20),
+                        t: t5
+                    })),
+                    backgroundColor: "rgba(241, 99, 102, 0.5)"
+                }, {
+                    label: "45-degree Line",
+                    data: [{
+                        x: 0,
+                        y: 0
+                    }, {
+                        x: 0.5,
+                        y: 0.5
+                    }],
+                    type: "line",
+                    fill: false,
+                    borderColor: "rgba(125, 125, 125, 0.8)",
+                    pointRadius: 0,
+                    borderWidth: 1,
+                    tension: 0
+                }]
+            },
+            options: {
+                responsive: true,
+                maintainAspectRatio: true,
+                animation: false,
+                scales: {
+                    x: {
+                        type: "linear",
+                        beginAtZero: true,
+                        max: Math.min(0.5, n3, r3),
+                        ticks: {
+                            color: "light" === f2 ? "#000000aa" : "#FFFFFFaa",
+                            callback: (t5, e4, i4) => (100 * t5).toFixed(1) + "%"
+                        },
+                        grid: {
+                            color: "#77777755",
+                            tickBorderDash: [2, 2]
+                        }
+                    },
+                    y: {
+                        type: "linear",
+                        beginAtZero: true,
+                        max: Math.min(0.5, r3, n3),
+                        ticks: {
+                            color: "light" === f2 ? "#000000aa" : "#FFFFFFaa",
+                            callback: (t5, e4, i4) => (100 * t5).toFixed(1) + "%"
+                        },
+                        grid: {
+                            color: "#77777755",
+                            tickBorderDash: [2, 2]
+                        }
+                    }
+                },
+                plugins: {
+                    zoom: {
+                        pan: {
+                            enabled: true,
+                            mode: "xy"
+                        },
+                        zoom: {
+                            wheel: {
+                                enabled: true
+                            },
+                            pinch: {
+                                enabled: true
+                            },
+                            mode: "xy"
+                        }
+                    },
+                    tooltip: {
+                        callbacks: {
+                            title: (t5) => t5[0].raw.t.stockId + " " + t5[0].dataset.label,
+                            label(t5) {
+                                const s4 = t5.raw.x.toFixed(2),
+                                    n4 = t5.raw.y.toFixed(2);
+                                return t5.raw.t.stock, `${e3}: ${s4}, ${i3}:${n4}`;
+                            }
+                        }
+                    }
+                }
+            }
+        };
+        return new Chart(t4, u3);
+    }
+    let R2, D2;
+    const $2 = {};
+    let z2 = false;
+    return pt(() => {
+        if (!u2)
+            return;
+        S2(_2(g2, 50)), i2(16, $2.maemfe = P2(x2, "mae", "gmfe"), $2), i2(16, $2.mae = P2(R2, "mae", "return"), $2), i2(16, $2.mfe = P2(D2, "gmfe", "return"), $2), i2(17, z2 = true);
+    }), yt(() => {
+        var _a2, _b2, _c2;
+        (_a2 = $2.maemfe) == null ? void 0 : _a2.destroy(), (_b2 = $2.mae) == null ? void 0 : _b2.destroy(), (_c2 = $2.mfe) == null ? void 0 : _c2.destroy(), k2 == null ? void 0 : k2.destroy();
+    }), t3.$$set = (t4) => {
+        "lang" in t4 && i2(12, c2 = t4.lang), "browser" in t4 && i2(13, u2 = t4.browser), "report" in t4 && i2(14, d2 = t4.report), "theme" in t4 && i2(15, f2 = t4.theme);
+    }, t3.$$.update = () => {
+        if (4096 & t3.$$.dirty[0] && i2(10, s2 = (t4) => "en" === c2 ? sl(t4) : nl(t4)), 16385 & t3.$$.dirty[0] && i2(19, n2 = d2.trades.filter((t4) => t4.mae < -p2).map((t4) => t4.return)), 524289 & t3.$$.dirty[0] && i2(9, r2 = 0 === p2 ? 0 : n2.reduce((t4, e3) => t4 + e3, 0) / n2.length + p2 || 0), 540673 & t3.$$.dirty[0] && i2(8, o2 = 0 === p2 ? 0 : n2.length / d2.trades.length), 16386 & t3.$$.dirty[0] && i2(18, a2 = d2.trades.filter((t4) => t4.gmfe > m2).map((t4) => t4.return)), 262146 & t3.$$.dirty[0] && i2(7, l2 = 0 === m2 ? 0 : a2.reduce((t4, e3) => t4 + e3, 0) / a2.length - m2 || 0), 278530 & t3.$$.dirty[0] && i2(6, h2 = 0 === m2 ? 0 : a2.length / d2.trades.length), 229380 & t3.$$.dirty[0] && f2 && z2) {
+            $2.maemfe && ($2.maemfe.destroy(), i2(16, $2.maemfe = P2(x2, "mae", "gmfe"), $2));
+            S2(_2(g2, 50));
+        }
+        98313 & t3.$$.dirty[0] && (0 === p2 || p2 || f2) && $2.mae && ($2.mae.destroy(), i2(16, $2.mae = P2(R2, "mae", "return"), $2)), 98322 & t3.$$.dirty[0] && (0 === m2 || m2 || f2) && $2.mfe && ($2.mfe.destroy(), i2(16, $2.mfe = P2(D2, "gmfe", "return"), $2));
+    }, [p2, m2, x2, R2, D2, w2, h2, l2, o2, r2, s2, T2, c2, u2, d2, f2, $2, z2, a2, n2, function(t4) {
+        xt[t4 ? "unshift" : "push"](() => {
+            w2 = t4, i2(5, w2);
+        });
+    }, function() {
+        p2 = j(this.value), i2(0, p2);
+    }, function(t4) {
+        xt[t4 ? "unshift" : "push"](() => {
+            R2 = t4, i2(3, R2);
+        });
+    }, function() {
+        m2 = j(this.value), i2(1, m2);
+    }, function(t4) {
+        xt[t4 ? "unshift" : "push"](() => {
+            D2 = t4, i2(4, D2);
+        });
+    }, function(t4) {
+        xt[t4 ? "unshift" : "push"](() => {
+            x2 = t4, i2(2, x2);
+        });
+    }];
+}
+class Winrate extends SvelteComponent {
+    constructor(t3) {
+        super(), ve(this, t3, ld, ad, o, {
+            lang: 12,
+            browser: 13,
+            report: 14,
+            theme: 15
+        }, null, [-1, -1]);
+    }
+    get lang() {
+        return this.$$.ctx[12];
+    }
+    set lang(t3) {
+        this.$$set({
+            lang: t3
+        }), te();
+    }
+    get browser() {
+        return this.$$.ctx[13];
+    }
+    set browser(t3) {
+        this.$$set({
+            browser: t3
+        }), te();
+    }
+    get report() {
+        return this.$$.ctx[14];
+    }
+    set report(t3) {
+        this.$$set({
+            report: t3
+        }), te();
+    }
+    get theme() {
+        return this.$$.ctx[15];
+    }
+    set theme(t3) {
+        this.$$set({
+            theme: t3
+        }), te();
+    }
+}
+we(Winrate, {
+    lang: {},
+    browser: {},
+    report: {},
+    theme: {}
+}, [], [], true);
+const hd = [];
+
+function cd(e2, i2 = t) {
+    let s2;
+    const n2 = /* @__PURE__ */ new Set();
+
+    function r2(t3) {
+        if (o(e2, t3) && (e2 = t3, s2)) {
+            const t4 = !hd.length;
+            for (const t5 of n2)
+                t5[1](), hd.push(t5, e2);
+            if (t4) {
+                for (let t5 = 0; t5 < hd.length; t5 += 2)
+                    hd[t5][0](hd[t5 + 1]);
+                hd.length = 0;
+            }
+        }
+    }
+
+    function a2(t3) {
+        r2(t3(e2));
+    }
+    return {
+        set: r2,
+        update: a2,
+        subscribe: function(o2, l2 = t) {
+            const h2 = [o2, l2];
+            return n2.add(h2), 1 === n2.size && (s2 = i2(r2, a2) || t), o2(e2), () => {
+                n2.delete(h2), 0 === n2.size && s2 && (s2(), s2 = null);
+            };
+        }
+    };
+}
+const ud = cd(null),
+    dd = function(t3) {
+        const e2 = [];
+        let i2 = 0;
+        for (let s2 = 0; s2 < t3.length; s2++) {
+            let n2 = t3.charCodeAt(s2);
+            n2 < 128 ? e2[i2++] = n2 : n2 < 2048 ? (e2[i2++] = n2 >> 6 | 192, e2[i2++] = 63 & n2 | 128) : 55296 == (64512 & n2) && s2 + 1 < t3.length && 56320 == (64512 & t3.charCodeAt(s2 + 1)) ? (n2 = 65536 + ((1023 & n2) << 10) + (1023 & t3.charCodeAt(++s2)), e2[i2++] = n2 >> 18 | 240, e2[i2++] = n2 >> 12 & 63 | 128, e2[i2++] = n2 >> 6 & 63 | 128, e2[i2++] = 63 & n2 | 128) : (e2[i2++] = n2 >> 12 | 224, e2[i2++] = n2 >> 6 & 63 | 128, e2[i2++] = 63 & n2 | 128);
+        }
+        return e2;
+    },
+    fd = {
+        byteToCharMap_: null,
+        charToByteMap_: null,
+        byteToCharMapWebSafe_: null,
+        charToByteMapWebSafe_: null,
+        ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
+        get ENCODED_VALS() {
+            return this.ENCODED_VALS_BASE + "+/=";
+        },
+        get ENCODED_VALS_WEBSAFE() {
+            return this.ENCODED_VALS_BASE + "-_.";
+        },
+        HAS_NATIVE_SUPPORT: "function" == typeof atob,
+        encodeByteArray(t3, e2) {
+            if (!Array.isArray(t3))
+                throw Error("encodeByteArray takes an array as a parameter");
+            this.init_();
+            const i2 = e2 ? this.byteToCharMapWebSafe_ : this.byteToCharMap_,
+                s2 = [];
+            for (let e3 = 0; e3 < t3.length; e3 += 3) {
+                const n2 = t3[e3],
+                    r2 = e3 + 1 < t3.length,
+                    o2 = r2 ? t3[e3 + 1] : 0,
+                    a2 = e3 + 2 < t3.length,
+                    l2 = a2 ? t3[e3 + 2] : 0,
+                    h2 = n2 >> 2,
+                    c2 = (3 & n2) << 4 | o2 >> 4;
+                let u2 = (15 & o2) << 2 | l2 >> 6,
+                    d2 = 63 & l2;
+                a2 || (d2 = 64, r2 || (u2 = 64)), s2.push(i2[h2], i2[c2], i2[u2], i2[d2]);
+            }
+            return s2.join("");
+        },
+        encodeString(t3, e2) {
+            return this.HAS_NATIVE_SUPPORT && !e2 ? btoa(t3) : this.encodeByteArray(dd(t3), e2);
+        },
+        decodeString(t3, e2) {
+            return this.HAS_NATIVE_SUPPORT && !e2 ? atob(t3) : function(t4) {
+                const e3 = [];
+                let i2 = 0,
+                    s2 = 0;
+                for (; i2 < t4.length;) {
+                    const n2 = t4[i2++];
+                    if (n2 < 128)
+                        e3[s2++] = String.fromCharCode(n2);
+                    else if (n2 > 191 && n2 < 224) {
+                        const r2 = t4[i2++];
+                        e3[s2++] = String.fromCharCode((31 & n2) << 6 | 63 & r2);
+                    } else if (n2 > 239 && n2 < 365) {
+                        const r2 = ((7 & n2) << 18 | (63 & t4[i2++]) << 12 | (63 & t4[i2++]) << 6 | 63 & t4[i2++]) - 65536;
+                        e3[s2++] = String.fromCharCode(55296 + (r2 >> 10)), e3[s2++] = String.fromCharCode(56320 + (1023 & r2));
+                    } else {
+                        const r2 = t4[i2++],
+                            o2 = t4[i2++];
+                        e3[s2++] = String.fromCharCode((15 & n2) << 12 | (63 & r2) << 6 | 63 & o2);
+                    }
+                }
+                return e3.join("");
+            }(this.decodeStringToByteArray(t3, e2));
+        },
+        decodeStringToByteArray(t3, e2) {
+            this.init_();
+            const i2 = e2 ? this.charToByteMapWebSafe_ : this.charToByteMap_,
+                s2 = [];
+            for (let e3 = 0; e3 < t3.length;) {
+                const n2 = i2[t3.charAt(e3++)],
+                    r2 = e3 < t3.length ? i2[t3.charAt(e3)] : 0;
+                ++e3;
+                const o2 = e3 < t3.length ? i2[t3.charAt(e3)] : 64;
+                ++e3;
+                const a2 = e3 < t3.length ? i2[t3.charAt(e3)] : 64;
+                if (++e3, null == n2 || null == r2 || null == o2 || null == a2)
+                    throw new DecodeBase64StringError();
+                const l2 = n2 << 2 | r2 >> 4;
+                if (s2.push(l2), 64 !== o2) {
+                    const t4 = r2 << 4 & 240 | o2 >> 2;
+                    if (s2.push(t4), 64 !== a2) {
+                        const t5 = o2 << 6 & 192 | a2;
+                        s2.push(t5);
+                    }
+                }
+            }
+            return s2;
+        },
+        init_() {
+            if (!this.byteToCharMap_) {
+                this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {};
+                for (let t3 = 0; t3 < this.ENCODED_VALS.length; t3++)
+                    this.byteToCharMap_[t3] = this.ENCODED_VALS.charAt(t3), this.charToByteMap_[this.byteToCharMap_[t3]] = t3, this.byteToCharMapWebSafe_[t3] = this.ENCODED_VALS_WEBSAFE.charAt(t3), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[t3]] = t3, t3 >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(t3)] = t3, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(t3)] = t3);
+            }
+        }
+    };
+class DecodeBase64StringError extends Error {
+    constructor() {
+        super(...arguments), this.name = "DecodeBase64StringError";
+    }
+}
+const pd = function(t3) {
+        return function(t4) {
+            const e2 = dd(t4);
+            return fd.encodeByteArray(e2, true);
+        }(t3).replace(/\./g, "");
+    },
+    md = function(t3) {
+        try {
+            return fd.decodeString(t3, true);
+        } catch (t4) {
+            console.error("base64Decode failed: ", t4);
+        }
+        return null;
+    };
+const gd = () => function() {
+        if ("undefined" != typeof self)
+            return self;
+        if ("undefined" != typeof window)
+            return window;
+        if ("undefined" != typeof global)
+            return global;
+        throw new Error("Unable to locate global object.");
+    }().__FIREBASE_DEFAULTS__,
+    yd = () => {
+        try {
+            return gd() || (() => {
+                if ("undefined" == typeof process || void 0 === process.env)
+                    return;
+                const t3 = process.env.__FIREBASE_DEFAULTS__;
+                return t3 ? JSON.parse(t3) : void 0;
+            })() || (() => {
+                if ("undefined" == typeof document)
+                    return;
+                let t3;
+                try {
+                    t3 = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
+                } catch (t4) {
+                    return;
+                }
+                const e2 = t3 && md(t3[1]);
+                return e2 && JSON.parse(e2);
+            })();
+        } catch (t3) {
+            return void console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${t3}`);
+        }
+    },
+    vd = (t3) => {
+        var e2, i2;
+        return null === (i2 = null === (e2 = yd()) || void 0 === e2 ? void 0 : e2.emulatorHosts) || void 0 === i2 ? void 0 : i2[t3];
+    },
+    bd = (t3) => {
+        const e2 = vd(t3);
+        if (!e2)
+            return;
+        const i2 = e2.lastIndexOf(":");
+        if (i2 <= 0 || i2 + 1 === e2.length)
+            throw new Error(`Invalid host ${e2} with no separate hostname and port!`);
+        const s2 = parseInt(e2.substring(i2 + 1), 10);
+        return "[" === e2[0] ? [e2.substring(1, i2 - 1), s2] : [e2.substring(0, i2), s2];
+    },
+    _d = () => {
+        var t3;
+        return null === (t3 = yd()) || void 0 === t3 ? void 0 : t3.config;
+    },
+    wd = (t3) => {
+        var e2;
+        return null === (e2 = yd()) || void 0 === e2 ? void 0 : e2[`_${t3}`];
+    };
+class Deferred {
+    constructor() {
+        this.reject = () => {}, this.resolve = () => {}, this.promise = new Promise((t3, e2) => {
+            this.resolve = t3, this.reject = e2;
+        });
+    }
+    wrapCallback(t3) {
+        return (e2, i2) => {
+            e2 ? this.reject(e2) : this.resolve(i2), "function" == typeof t3 && (this.promise.catch(() => {}), 1 === t3.length ? t3(e2) : t3(e2, i2));
+        };
+    }
+}
+
+function xd(t3, e2) {
+    if (t3.uid)
+        throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
+    const i2 = e2 || "demo-project",
+        s2 = t3.iat || 0,
+        n2 = t3.sub || t3.user_id;
+    if (!n2)
+        throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
+    const r2 = Object.assign({
+        iss: `https://securetoken.google.com/${i2}`,
+        aud: i2,
+        iat: s2,
+        exp: s2 + 3600,
+        auth_time: s2,
+        sub: n2,
+        user_id: n2,
+        firebase: {
+            sign_in_provider: "custom",
+            identities: {}
+        }
+    }, t3);
+    return [pd(JSON.stringify({
+        alg: "none",
+        type: "JWT"
+    })), pd(JSON.stringify(r2)), ""].join(".");
+}
+
+function kd() {
+    return "undefined" != typeof navigator && "string" == typeof navigator.userAgent ? navigator.userAgent : "";
+}
+class FirebaseError extends Error {
+    constructor(t3, e2, i2) {
+        super(e2), this.code = t3, this.customData = i2, this.name = "FirebaseError", Object.setPrototypeOf(this, FirebaseError.prototype), Error.captureStackTrace && Error.captureStackTrace(this, ErrorFactory.prototype.create);
+    }
+}
+class ErrorFactory {
+    constructor(t3, e2, i2) {
+        this.service = t3, this.serviceName = e2, this.errors = i2;
+    }
+    create(t3, ...e2) {
+        const i2 = e2[0] || {},
+            s2 = `${this.service}/${t3}`,
+            n2 = this.errors[t3],
+            r2 = n2 ? function(t4, e3) {
+                return t4.replace(Td, (t5, i3) => {
+                    const s3 = e3[i3];
+                    return null != s3 ? String(s3) : `<${i3}?>`;
+                });
+            }(n2, i2) : "Error",
+            o2 = `${this.serviceName}: ${r2} (${s2}).`;
+        return new FirebaseError(s2, o2, i2);
+    }
+}
+const Td = /\{\$([^}]+)}/g;
+
+function Sd(t3, e2) {
+    if (t3 === e2)
+        return true;
+    const i2 = Object.keys(t3),
+        s2 = Object.keys(e2);
+    for (const n2 of i2) {
+        if (!s2.includes(n2))
+            return false;
+        const i3 = t3[n2],
+            r2 = e2[n2];
+        if (Ed(i3) && Ed(r2)) {
+            if (!Sd(i3, r2))
+                return false;
+        } else if (i3 !== r2)
+            return false;
+    }
+    for (const t4 of s2)
+        if (!i2.includes(t4))
+            return false;
+    return true;
+}
+
+function Ed(t3) {
+    return null !== t3 && "object" == typeof t3;
+}
+
+function Cd(t3) {
+    const e2 = [];
+    for (const [i2, s2] of Object.entries(t3))
+        Array.isArray(s2) ? s2.forEach((t4) => {
+            e2.push(encodeURIComponent(i2) + "=" + encodeURIComponent(t4));
+        }) : e2.push(encodeURIComponent(i2) + "=" + encodeURIComponent(s2));
+    return e2.length ? "&" + e2.join("&") : "";
+}
+class ObserverProxy {
+    constructor(t3, e2) {
+        this.observers = [], this.unsubscribes = [], this.observerCount = 0, this.task = Promise.resolve(), this.finalized = false, this.onNoObservers = e2, this.task.then(() => {
+            t3(this);
+        }).catch((t4) => {
+            this.error(t4);
+        });
+    }
+    next(t3) {
+        this.forEachObserver((e2) => {
+            e2.next(t3);
+        });
+    }
+    error(t3) {
+        this.forEachObserver((e2) => {
+            e2.error(t3);
+        }), this.close(t3);
+    }
+    complete() {
+        this.forEachObserver((t3) => {
+            t3.complete();
+        }), this.close();
+    }
+    subscribe(t3, e2, i2) {
+        let s2;
+        if (void 0 === t3 && void 0 === e2 && void 0 === i2)
+            throw new Error("Missing Observer.");
+        s2 = function(t4, e3) {
+            if ("object" != typeof t4 || null === t4)
+                return false;
+            for (const i3 of e3)
+                if (i3 in t4 && "function" == typeof t4[i3])
+                    return true;
+            return false;
+        }(t3, ["next", "error", "complete"]) ? t3 : {
+            next: t3,
+            error: e2,
+            complete: i2
+        }, void 0 === s2.next && (s2.next = Id), void 0 === s2.error && (s2.error = Id), void 0 === s2.complete && (s2.complete = Id);
+        const n2 = this.unsubscribeOne.bind(this, this.observers.length);
+        return this.finalized && this.task.then(() => {
+            try {
+                this.finalError ? s2.error(this.finalError) : s2.complete();
+            } catch (t4) {}
+        }), this.observers.push(s2), n2;
+    }
+    unsubscribeOne(t3) {
+        void 0 !== this.observers && void 0 !== this.observers[t3] && (delete this.observers[t3], this.observerCount -= 1, 0 === this.observerCount && void 0 !== this.onNoObservers && this.onNoObservers(this));
+    }
+    forEachObserver(t3) {
+        if (!this.finalized)
+            for (let e2 = 0; e2 < this.observers.length; e2++)
+                this.sendOne(e2, t3);
+    }
+    sendOne(t3, e2) {
+        this.task.then(() => {
+            if (void 0 !== this.observers && void 0 !== this.observers[t3])
+                try {
+                    e2(this.observers[t3]);
+                } catch (t4) {
+                    "undefined" != typeof console && console.error && console.error(t4);
+                }
+        });
+    }
+    close(t3) {
+        this.finalized || (this.finalized = true, void 0 !== t3 && (this.finalError = t3), this.task.then(() => {
+            this.observers = void 0, this.onNoObservers = void 0;
+        }));
+    }
+}
+
+function Id() {}
+
+function Md(t3) {
+    return t3 && t3._delegate ? t3._delegate : t3;
+}
+class Component {
+    constructor(t3, e2, i2) {
+        this.name = t3, this.instanceFactory = e2, this.type = i2, this.multipleInstances = false, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null;
+    }
+    setInstantiationMode(t3) {
+        return this.instantiationMode = t3, this;
+    }
+    setMultipleInstances(t3) {
+        return this.multipleInstances = t3, this;
+    }
+    setServiceProps(t3) {
+        return this.serviceProps = t3, this;
+    }
+    setInstanceCreatedCallback(t3) {
+        return this.onInstanceCreated = t3, this;
+    }
+}
+const Pd = "[DEFAULT]";
+class Provider {
+    constructor(t3, e2) {
+        this.name = t3, this.container = e2, this.component = null, this.instances = /* @__PURE__ */ new Map(), this.instancesDeferred = /* @__PURE__ */ new Map(), this.instancesOptions = /* @__PURE__ */ new Map(), this.onInitCallbacks = /* @__PURE__ */ new Map();
+    }
+    get(t3) {
+        const e2 = this.normalizeInstanceIdentifier(t3);
+        if (!this.instancesDeferred.has(e2)) {
+            const t4 = new Deferred();
+            if (this.instancesDeferred.set(e2, t4), this.isInitialized(e2) || this.shouldAutoInitialize())
+                try {
+                    const i2 = this.getOrInitializeService({
+                        instanceIdentifier: e2
+                    });
+                    i2 && t4.resolve(i2);
+                } catch (t5) {}
+        }
+        return this.instancesDeferred.get(e2).promise;
+    }
+    getImmediate(t3) {
+        var e2;
+        const i2 = this.normalizeInstanceIdentifier(null == t3 ? void 0 : t3.identifier),
+            s2 = null !== (e2 = null == t3 ? void 0 : t3.optional) && void 0 !== e2 && e2;
+        if (!this.isInitialized(i2) && !this.shouldAutoInitialize()) {
+            if (s2)
+                return null;
+            throw Error(`Service ${this.name} is not available`);
+        }
+        try {
+            return this.getOrInitializeService({
+                instanceIdentifier: i2
+            });
+        } catch (t4) {
+            if (s2)
+                return null;
+            throw t4;
+        }
+    }
+    getComponent() {
+        return this.component;
+    }
+    setComponent(t3) {
+        if (t3.name !== this.name)
+            throw Error(`Mismatching Component ${t3.name} for Provider ${this.name}.`);
+        if (this.component)
+            throw Error(`Component for ${this.name} has already been provided`);
+        if (this.component = t3, this.shouldAutoInitialize()) {
+            if (function(t4) {
+                    return "EAGER" === t4.instantiationMode;
+                }(t3))
+                try {
+                    this.getOrInitializeService({
+                        instanceIdentifier: Pd
+                    });
+                } catch (t4) {}
+            for (const [t4, e2] of this.instancesDeferred.entries()) {
+                const i2 = this.normalizeInstanceIdentifier(t4);
+                try {
+                    const t5 = this.getOrInitializeService({
+                        instanceIdentifier: i2
+                    });
+                    e2.resolve(t5);
+                } catch (t5) {}
+            }
+        }
+    }
+    clearInstance(t3 = Pd) {
+        this.instancesDeferred.delete(t3), this.instancesOptions.delete(t3), this.instances.delete(t3);
+    }
+    async delete() {
+        const t3 = Array.from(this.instances.values());
+        await Promise.all([...t3.filter((t4) => "INTERNAL" in t4).map((t4) => t4.INTERNAL.delete()), ...t3.filter((t4) => "_delete" in t4).map((t4) => t4._delete())]);
+    }
+    isComponentSet() {
+        return null != this.component;
+    }
+    isInitialized(t3 = Pd) {
+        return this.instances.has(t3);
+    }
+    getOptions(t3 = Pd) {
+        return this.instancesOptions.get(t3) || {};
+    }
+    initialize(t3 = {}) {
+        const {
+            options: e2 = {}
+        } = t3, i2 = this.normalizeInstanceIdentifier(t3.instanceIdentifier);
+        if (this.isInitialized(i2))
+            throw Error(`${this.name}(${i2}) has already been initialized`);
+        if (!this.isComponentSet())
+            throw Error(`Component ${this.name} has not been registered yet`);
+        const s2 = this.getOrInitializeService({
+            instanceIdentifier: i2,
+            options: e2
+        });
+        for (const [t4, e3] of this.instancesDeferred.entries()) {
+            i2 === this.normalizeInstanceIdentifier(t4) && e3.resolve(s2);
+        }
+        return s2;
+    }
+    onInit(t3, e2) {
+        var i2;
+        const s2 = this.normalizeInstanceIdentifier(e2),
+            n2 = null !== (i2 = this.onInitCallbacks.get(s2)) && void 0 !== i2 ? i2 : /* @__PURE__ */ new Set();
+        n2.add(t3), this.onInitCallbacks.set(s2, n2);
+        const r2 = this.instances.get(s2);
+        return r2 && t3(r2, s2), () => {
+            n2.delete(t3);
+        };
+    }
+    invokeOnInitCallbacks(t3, e2) {
+        const i2 = this.onInitCallbacks.get(e2);
+        if (i2)
+            for (const s2 of i2)
+                try {
+                    s2(t3, e2);
+                } catch (t4) {}
+    }
+    getOrInitializeService({
+        instanceIdentifier: t3,
+        options: e2 = {}
+    }) {
+        let i2 = this.instances.get(t3);
+        if (!i2 && this.component && (i2 = this.component.instanceFactory(this.container, {
+                instanceIdentifier: (s2 = t3, s2 === Pd ? void 0 : s2),
+                options: e2
+            }), this.instances.set(t3, i2), this.instancesOptions.set(t3, e2), this.invokeOnInitCallbacks(i2, t3), this.component.onInstanceCreated))
+            try {
+                this.component.onInstanceCreated(this.container, t3, i2);
+            } catch (t4) {}
+        var s2;
+        return i2 || null;
+    }
+    normalizeInstanceIdentifier(t3 = Pd) {
+        return this.component ? this.component.multipleInstances ? t3 : Pd : t3;
+    }
+    shouldAutoInitialize() {
+        return !!this.component && "EXPLICIT" !== this.component.instantiationMode;
+    }
+}
+class ComponentContainer {
+    constructor(t3) {
+        this.name = t3, this.providers = /* @__PURE__ */ new Map();
+    }
+    addComponent(t3) {
+        const e2 = this.getProvider(t3.name);
+        if (e2.isComponentSet())
+            throw new Error(`Component ${t3.name} has already been registered with ${this.name}`);
+        e2.setComponent(t3);
+    }
+    addOrOverwriteComponent(t3) {
+        this.getProvider(t3.name).isComponentSet() && this.providers.delete(t3.name), this.addComponent(t3);
+    }
+    getProvider(t3) {
+        if (this.providers.has(t3))
+            return this.providers.get(t3);
+        const e2 = new Provider(t3, this);
+        return this.providers.set(t3, e2), e2;
+    }
+    getProviders() {
+        return Array.from(this.providers.values());
+    }
+}
+var Rd;
+! function(t3) {
+    t3[t3.DEBUG = 0] = "DEBUG", t3[t3.VERBOSE = 1] = "VERBOSE", t3[t3.INFO = 2] = "INFO", t3[t3.WARN = 3] = "WARN", t3[t3.ERROR = 4] = "ERROR", t3[t3.SILENT = 5] = "SILENT";
+}(Rd || (Rd = {}));
+const Ad = {
+        debug: Rd.DEBUG,
+        verbose: Rd.VERBOSE,
+        info: Rd.INFO,
+        warn: Rd.WARN,
+        error: Rd.ERROR,
+        silent: Rd.SILENT
+    },
+    Dd = Rd.INFO,
+    Ld = {
+        [Rd.DEBUG]: "log",
+        [Rd.VERBOSE]: "log",
+        [Rd.INFO]: "info",
+        [Rd.WARN]: "warn",
+        [Rd.ERROR]: "error"
+    },
+    Od = (t3, e2, ...i2) => {
+        if (e2 < t3.logLevel)
+            return;
+        const s2 = ( /* @__PURE__ */ new Date()).toISOString(),
+            n2 = Ld[e2];
+        if (!n2)
+            throw new Error(`Attempted to log a message with an invalid logType (value: ${e2})`);
+        console[n2](`[${s2}]  ${t3.name}:`, ...i2);
+    };
+class Logger {
+    constructor(t3) {
+        this.name = t3, this._logLevel = Dd, this._logHandler = Od, this._userLogHandler = null;
+    }
+    get logLevel() {
+        return this._logLevel;
+    }
+    set logLevel(t3) {
+        if (!(t3 in Rd))
+            throw new TypeError(`Invalid value "${t3}" assigned to \`logLevel\``);
+        this._logLevel = t3;
+    }
+    setLogLevel(t3) {
+        this._logLevel = "string" == typeof t3 ? Ad[t3] : t3;
+    }
+    get logHandler() {
+        return this._logHandler;
+    }
+    set logHandler(t3) {
+        if ("function" != typeof t3)
+            throw new TypeError("Value assigned to `logHandler` must be a function");
+        this._logHandler = t3;
+    }
+    get userLogHandler() {
+        return this._userLogHandler;
+    }
+    set userLogHandler(t3) {
+        this._userLogHandler = t3;
+    }
+    debug(...t3) {
+        this._userLogHandler && this._userLogHandler(this, Rd.DEBUG, ...t3), this._logHandler(this, Rd.DEBUG, ...t3);
+    }
+    log(...t3) {
+        this._userLogHandler && this._userLogHandler(this, Rd.VERBOSE, ...t3), this._logHandler(this, Rd.VERBOSE, ...t3);
+    }
+    info(...t3) {
+        this._userLogHandler && this._userLogHandler(this, Rd.INFO, ...t3), this._logHandler(this, Rd.INFO, ...t3);
+    }
+    warn(...t3) {
+        this._userLogHandler && this._userLogHandler(this, Rd.WARN, ...t3), this._logHandler(this, Rd.WARN, ...t3);
+    }
+    error(...t3) {
+        this._userLogHandler && this._userLogHandler(this, Rd.ERROR, ...t3), this._logHandler(this, Rd.ERROR, ...t3);
+    }
+}
+const Fd = (t3, e2) => e2.some((e3) => t3 instanceof e3);
+let Nd, $d;
+const Vd = /* @__PURE__ */ new WeakMap(),
+    zd = /* @__PURE__ */ new WeakMap(),
+    Bd = /* @__PURE__ */ new WeakMap(),
+    Ud = /* @__PURE__ */ new WeakMap(),
+    jd = /* @__PURE__ */ new WeakMap();
+let Hd = {
+    get(t3, e2, i2) {
+        if (t3 instanceof IDBTransaction) {
+            if ("done" === e2)
+                return zd.get(t3);
+            if ("objectStoreNames" === e2)
+                return t3.objectStoreNames || Bd.get(t3);
+            if ("store" === e2)
+                return i2.objectStoreNames[1] ? void 0 : i2.objectStore(i2.objectStoreNames[0]);
+        }
+        return Kd(t3[e2]);
+    },
+    set: (t3, e2, i2) => (t3[e2] = i2, true),
+    has: (t3, e2) => t3 instanceof IDBTransaction && ("done" === e2 || "store" === e2) || e2 in t3
+};
+
+function Wd(t3) {
+    return t3 !== IDBDatabase.prototype.transaction || "objectStoreNames" in IDBTransaction.prototype ? ($d || ($d = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey])).includes(t3) ? function(...e2) {
+        return t3.apply(Gd(this), e2), Kd(Vd.get(this));
+    } : function(...e2) {
+        return Kd(t3.apply(Gd(this), e2));
+    } : function(e2, ...i2) {
+        const s2 = t3.call(Gd(this), e2, ...i2);
+        return Bd.set(s2, e2.sort ? e2.sort() : [e2]), Kd(s2);
+    };
+}
+
+function qd(t3) {
+    return "function" == typeof t3 ? Wd(t3) : (t3 instanceof IDBTransaction && function(t4) {
+        if (zd.has(t4))
+            return;
+        const e2 = new Promise((e3, i2) => {
+            const s2 = () => {
+                    t4.removeEventListener("complete", n2), t4.removeEventListener("error", r2), t4.removeEventListener("abort", r2);
+                },
+                n2 = () => {
+                    e3(), s2();
+                },
+                r2 = () => {
+                    i2(t4.error || new DOMException("AbortError", "AbortError")), s2();
+                };
+            t4.addEventListener("complete", n2), t4.addEventListener("error", r2), t4.addEventListener("abort", r2);
+        });
+        zd.set(t4, e2);
+    }(t3), Fd(t3, Nd || (Nd = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction])) ? new Proxy(t3, Hd) : t3);
+}
+
+function Kd(t3) {
+    if (t3 instanceof IDBRequest)
+        return function(t4) {
+            const e3 = new Promise((e4, i2) => {
+                const s2 = () => {
+                        t4.removeEventListener("success", n2), t4.removeEventListener("error", r2);
+                    },
+                    n2 = () => {
+                        e4(Kd(t4.result)), s2();
+                    },
+                    r2 = () => {
+                        i2(t4.error), s2();
+                    };
+                t4.addEventListener("success", n2), t4.addEventListener("error", r2);
+            });
+            return e3.then((e4) => {
+                e4 instanceof IDBCursor && Vd.set(e4, t4);
+            }).catch(() => {}), jd.set(e3, t4), e3;
+        }(t3);
+    if (Ud.has(t3))
+        return Ud.get(t3);
+    const e2 = qd(t3);
+    return e2 !== t3 && (Ud.set(t3, e2), jd.set(e2, t3)), e2;
+}
+const Gd = (t3) => jd.get(t3);
+const Yd = ["get", "getKey", "getAll", "getAllKeys", "count"],
+    Qd = ["put", "add", "delete", "clear"],
+    Xd = /* @__PURE__ */ new Map();
+
+function Jd(t3, e2) {
+    if (!(t3 instanceof IDBDatabase) || e2 in t3 || "string" != typeof e2)
+        return;
+    if (Xd.get(e2))
+        return Xd.get(e2);
+    const i2 = e2.replace(/FromIndex$/, ""),
+        s2 = e2 !== i2,
+        n2 = Qd.includes(i2);
+    if (!(i2 in (s2 ? IDBIndex : IDBObjectStore).prototype) || !n2 && !Yd.includes(i2))
+        return;
+    const r2 = async function(t4, ...e3) {
+        const r3 = this.transaction(t4, n2 ? "readwrite" : "readonly");
+        let o2 = r3.store;
+        return s2 && (o2 = o2.index(e3.shift())), (await Promise.all([o2[i2](...e3), n2 && r3.done]))[0];
+    };
+    return Xd.set(e2, r2), r2;
+}! function(t3) {
+    Hd = t3(Hd);
+}((t3) => ({
+    ...t3,
+    get: (e2, i2, s2) => Jd(e2, i2) || t3.get(e2, i2, s2),
+    has: (e2, i2) => !!Jd(e2, i2) || t3.has(e2, i2)
+}));
+class PlatformLoggerServiceImpl {
+    constructor(t3) {
+        this.container = t3;
+    }
+    getPlatformInfoString() {
+        return this.container.getProviders().map((t3) => {
+            if (function(t4) {
+                    const e2 = t4.getComponent();
+                    return "VERSION" === (null == e2 ? void 0 : e2.type);
+                }(t3)) {
+                const e2 = t3.getImmediate();
+                return `${e2.library}/${e2.version}`;
+            }
+            return null;
+        }).filter((t3) => t3).join(" ");
+    }
+}
+const Zd = "@firebase/app",
+    tf = "0.9.14",
+    ef = new Logger("@firebase/app"),
+    sf = "[DEFAULT]",
+    nf = {
+        [Zd]: "fire-core",
+        "@firebase/app-compat": "fire-core-compat",
+        "@firebase/analytics": "fire-analytics",
+        "@firebase/analytics-compat": "fire-analytics-compat",
+        "@firebase/app-check": "fire-app-check",
+        "@firebase/app-check-compat": "fire-app-check-compat",
+        "@firebase/auth": "fire-auth",
+        "@firebase/auth-compat": "fire-auth-compat",
+        "@firebase/database": "fire-rtdb",
+        "@firebase/database-compat": "fire-rtdb-compat",
+        "@firebase/functions": "fire-fn",
+        "@firebase/functions-compat": "fire-fn-compat",
+        "@firebase/installations": "fire-iid",
+        "@firebase/installations-compat": "fire-iid-compat",
+        "@firebase/messaging": "fire-fcm",
+        "@firebase/messaging-compat": "fire-fcm-compat",
+        "@firebase/performance": "fire-perf",
+        "@firebase/performance-compat": "fire-perf-compat",
+        "@firebase/remote-config": "fire-rc",
+        "@firebase/remote-config-compat": "fire-rc-compat",
+        "@firebase/storage": "fire-gcs",
+        "@firebase/storage-compat": "fire-gcs-compat",
+        "@firebase/firestore": "fire-fst",
+        "@firebase/firestore-compat": "fire-fst-compat",
+        "fire-js": "fire-js",
+        firebase: "fire-js-all"
+    },
+    rf = /* @__PURE__ */ new Map(),
+    of = /* @__PURE__ */ new Map();
+
+function af(t3, e2) {
+    try {
+        t3.container.addComponent(e2);
+    } catch (i2) {
+        ef.debug(`Component ${e2.name} failed to register with FirebaseApp ${t3.name}`, i2);
+    }
+}
+
+function lf(t3) {
+    const e2 = t3.name;
+    if (of.has(e2))
+        return ef.debug(`There were multiple attempts to register component ${e2}.`), false;
+    of.set(e2, t3);
+    for (const e3 of rf.values())
+        af(e3, t3);
+    return true;
+}
+
+function hf(t3, e2) {
+    const i2 = t3.container.getProvider("heartbeat").getImmediate({
+        optional: true
+    });
+    return i2 && i2.triggerHeartbeat(), t3.container.getProvider(e2);
+}
+const cf = new ErrorFactory("app", "Firebase", {
+    "no-app": "No Firebase App '{$appName}' has been created - call initializeApp() first",
+    "bad-app-name": "Illegal App name: '{$appName}",
+    "duplicate-app": "Firebase App named '{$appName}' already exists with different options or config",
+    "app-deleted": "Firebase App named '{$appName}' already deleted",
+    "no-options": "Need to provide options, when not being deployed to hosting via source.",
+    "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance.",
+    "invalid-log-argument": "First argument to `onLog` must be null or a function.",
+    "idb-open": "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
+    "idb-get": "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
+    "idb-set": "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
+    "idb-delete": "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}."
+});
+class FirebaseAppImpl {
+    constructor(t3, e2, i2) {
+        this._isDeleted = false, this._options = Object.assign({}, t3), this._config = Object.assign({}, e2), this._name = e2.name, this._automaticDataCollectionEnabled = e2.automaticDataCollectionEnabled, this._container = i2, this.container.addComponent(new Component("app", () => this, "PUBLIC"));
+    }
+    get automaticDataCollectionEnabled() {
+        return this.checkDestroyed(), this._automaticDataCollectionEnabled;
+    }
+    set automaticDataCollectionEnabled(t3) {
+        this.checkDestroyed(), this._automaticDataCollectionEnabled = t3;
+    }
+    get name() {
+        return this.checkDestroyed(), this._name;
+    }
+    get options() {
+        return this.checkDestroyed(), this._options;
+    }
+    get config() {
+        return this.checkDestroyed(), this._config;
+    }
+    get container() {
+        return this._container;
+    }
+    get isDeleted() {
+        return this._isDeleted;
+    }
+    set isDeleted(t3) {
+        this._isDeleted = t3;
+    }
+    checkDestroyed() {
+        if (this.isDeleted)
+            throw cf.create("app-deleted", {
+                appName: this._name
+            });
+    }
+}
+const uf = "10.0.0";
+
+function df(t3, e2 = {}) {
+    let i2 = t3;
+    if ("object" != typeof e2) {
+        e2 = {
+            name: e2
+        };
+    }
+    const s2 = Object.assign({
+            name: sf,
+            automaticDataCollectionEnabled: false
+        }, e2),
+        n2 = s2.name;
+    if ("string" != typeof n2 || !n2)
+        throw cf.create("bad-app-name", {
+            appName: String(n2)
+        });
+    if (i2 || (i2 = _d()), !i2)
+        throw cf.create("no-options");
+    const r2 = rf.get(n2);
+    if (r2) {
+        if (Sd(i2, r2.options) && Sd(s2, r2.config))
+            return r2;
+        throw cf.create("duplicate-app", {
+            appName: n2
+        });
+    }
+    const o2 = new ComponentContainer(n2);
+    for (const t4 of of.values())
+        o2.addComponent(t4);
+    const a2 = new FirebaseAppImpl(i2, s2, o2);
+    return rf.set(n2, a2), a2;
+}
+
+function ff(t3 = sf) {
+    const e2 = rf.get(t3);
+    if (!e2 && t3 === sf && _d())
+        return df();
+    if (!e2)
+        throw cf.create("no-app", {
+            appName: t3
+        });
+    return e2;
+}
+
+function pf(t3, e2, i2) {
+    var s2;
+    let n2 = null !== (s2 = nf[t3]) && void 0 !== s2 ? s2 : t3;
+    i2 && (n2 += `-${i2}`);
+    const r2 = n2.match(/\s|\//),
+        o2 = e2.match(/\s|\//);
+    if (r2 || o2) {
+        const t4 = [`Unable to register library "${n2}" with version "${e2}":`];
+        return r2 && t4.push(`library name "${n2}" contains illegal characters (whitespace or "/")`), r2 && o2 && t4.push("and"), o2 && t4.push(`version name "${e2}" contains illegal characters (whitespace or "/")`), void ef.warn(t4.join(" "));
+    }
+    lf(new Component(`${n2}-version`, () => ({
+        library: n2,
+        version: e2
+    }), "VERSION"));
+}
+const mf = "firebase-heartbeat-database",
+    gf = 1,
+    yf = "firebase-heartbeat-store";
+let vf = null;
+
+function bf() {
+    return vf || (vf = function(t3, e2, {
+        blocked: i2,
+        upgrade: s2,
+        blocking: n2,
+        terminated: r2
+    } = {}) {
+        const o2 = indexedDB.open(t3, e2),
+            a2 = Kd(o2);
+        return s2 && o2.addEventListener("upgradeneeded", (t4) => {
+            s2(Kd(o2.result), t4.oldVersion, t4.newVersion, Kd(o2.transaction), t4);
+        }), i2 && o2.addEventListener("blocked", (t4) => i2(t4.oldVersion, t4.newVersion, t4)), a2.then((t4) => {
+            r2 && t4.addEventListener("close", () => r2()), n2 && t4.addEventListener("versionchange", (t5) => n2(t5.oldVersion, t5.newVersion, t5));
+        }).catch(() => {}), a2;
+    }(mf, gf, {
+        upgrade: (t3, e2) => {
+            if (0 === e2)
+                t3.createObjectStore(yf);
+        }
+    }).catch((t3) => {
+        throw cf.create("idb-open", {
+            originalErrorMessage: t3.message
+        });
+    })), vf;
+}
+async function _f(t3, e2) {
+    try {
+        const i2 = (await bf()).transaction(yf, "readwrite"),
+            s2 = i2.objectStore(yf);
+        await s2.put(e2, wf(t3)), await i2.done;
+    } catch (t4) {
+        if (t4 instanceof FirebaseError)
+            ef.warn(t4.message);
+        else {
+            const e3 = cf.create("idb-set", {
+                originalErrorMessage: null == t4 ? void 0 : t4.message
+            });
+            ef.warn(e3.message);
+        }
+    }
+}
+
+function wf(t3) {
+    return `${t3.name}!${t3.options.appId}`;
+}
+class HeartbeatServiceImpl {
+    constructor(t3) {
+        this.container = t3, this._heartbeatsCache = null;
+        const e2 = this.container.getProvider("app").getImmediate();
+        this._storage = new HeartbeatStorageImpl(e2), this._heartbeatsCachePromise = this._storage.read().then((t4) => (this._heartbeatsCache = t4, t4));
+    }
+    async triggerHeartbeat() {
+        const t3 = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(),
+            e2 = xf();
+        if (null === this._heartbeatsCache && (this._heartbeatsCache = await this._heartbeatsCachePromise), this._heartbeatsCache.lastSentHeartbeatDate !== e2 && !this._heartbeatsCache.heartbeats.some((t4) => t4.date === e2))
+            return this._heartbeatsCache.heartbeats.push({
+                date: e2,
+                agent: t3
+            }), this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((t4) => {
+                const e3 = new Date(t4.date).valueOf();
+                return Date.now() - e3 <= 2592e6;
+            }), this._storage.overwrite(this._heartbeatsCache);
+    }
+    async getHeartbeatsHeader() {
+        if (null === this._heartbeatsCache && await this._heartbeatsCachePromise, null === this._heartbeatsCache || 0 === this._heartbeatsCache.heartbeats.length)
+            return "";
+        const t3 = xf(),
+            {
+                heartbeatsToSend: e2,
+                unsentEntries: i2
+            } = function(t4, e3 = 1024) {
+                const i3 = [];
+                let s3 = t4.slice();
+                for (const n2 of t4) {
+                    const t5 = i3.find((t6) => t6.agent === n2.agent);
+                    if (t5) {
+                        if (t5.dates.push(n2.date), kf(i3) > e3) {
+                            t5.dates.pop();
+                            break;
+                        }
+                    } else if (i3.push({
+                            agent: n2.agent,
+                            dates: [n2.date]
+                        }), kf(i3) > e3) {
+                        i3.pop();
+                        break;
+                    }
+                    s3 = s3.slice(1);
+                }
+                return {
+                    heartbeatsToSend: i3,
+                    unsentEntries: s3
+                };
+            }(this._heartbeatsCache.heartbeats),
+            s2 = pd(JSON.stringify({
+                version: 2,
+                heartbeats: e2
+            }));
+        return this._heartbeatsCache.lastSentHeartbeatDate = t3, i2.length > 0 ? (this._heartbeatsCache.heartbeats = i2, await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [], this._storage.overwrite(this._heartbeatsCache)), s2;
+    }
+}
+
+function xf() {
+    return ( /* @__PURE__ */ new Date()).toISOString().substring(0, 10);
+}
+class HeartbeatStorageImpl {
+    constructor(t3) {
+        this.app = t3, this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();
+    }
+    async runIndexedDBEnvironmentCheck() {
+        return !! function() {
+            try {
+                return "object" == typeof indexedDB;
+            } catch (t3) {
+                return false;
+            }
+        }() && new Promise((t3, e2) => {
+            try {
+                let i2 = true;
+                const s2 = "validate-browser-context-for-indexeddb-analytics-module",
+                    n2 = self.indexedDB.open(s2);
+                n2.onsuccess = () => {
+                    n2.result.close(), i2 || self.indexedDB.deleteDatabase(s2), t3(true);
+                }, n2.onupgradeneeded = () => {
+                    i2 = false;
+                }, n2.onerror = () => {
+                    var t4;
+                    e2((null === (t4 = n2.error) || void 0 === t4 ? void 0 : t4.message) || "");
+                };
+            } catch (t4) {
+                e2(t4);
+            }
+        }).then(() => true).catch(() => false);
+    }
+    async read() {
+        if (await this._canUseIndexedDBPromise) {
+            const t3 = await async function(t4) {
+                try {
+                    const e2 = await bf();
+                    return await e2.transaction(yf).objectStore(yf).get(wf(t4));
+                } catch (t5) {
+                    if (t5 instanceof FirebaseError)
+                        ef.warn(t5.message);
+                    else {
+                        const e2 = cf.create("idb-get", {
+                            originalErrorMessage: null == t5 ? void 0 : t5.message
+                        });
+                        ef.warn(e2.message);
+                    }
+                }
+            }(this.app);
+            return t3 || {
+                heartbeats: []
+            };
+        }
+        return {
+            heartbeats: []
+        };
+    }
+    async overwrite(t3) {
+        var e2;
+        if (await this._canUseIndexedDBPromise) {
+            const i2 = await this.read();
+            return _f(this.app, {
+                lastSentHeartbeatDate: null !== (e2 = t3.lastSentHeartbeatDate) && void 0 !== e2 ? e2 : i2.lastSentHeartbeatDate,
+                heartbeats: t3.heartbeats
+            });
+        }
+    }
+    async add(t3) {
+        var e2;
+        if (await this._canUseIndexedDBPromise) {
+            const i2 = await this.read();
+            return _f(this.app, {
+                lastSentHeartbeatDate: null !== (e2 = t3.lastSentHeartbeatDate) && void 0 !== e2 ? e2 : i2.lastSentHeartbeatDate,
+                heartbeats: [...i2.heartbeats, ...t3.heartbeats]
+            });
+        }
+    }
+}
+
+function kf(t3) {
+    return pd(JSON.stringify({
+        version: 2,
+        heartbeats: t3
+    })).length;
+}
+var Tf;
+Tf = "", lf(new Component("platform-logger", (t3) => new PlatformLoggerServiceImpl(t3), "PRIVATE")), lf(new Component("heartbeat", (t3) => new HeartbeatServiceImpl(t3), "PRIVATE")), pf(Zd, tf, Tf), pf(Zd, tf, "esm2017"), pf("fire-js", "");
+var Sf, Ef = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {},
+    Cf = Cf || {},
+    If = Ef || self;
+
+function Mf(t3) {
+    var e2 = typeof t3;
+    return "array" == (e2 = "object" != e2 ? e2 : t3 ? Array.isArray(t3) ? "array" : e2 : "null") || "object" == e2 && "number" == typeof t3.length;
+}
+
+function Pf(t3) {
+    var e2 = typeof t3;
+    return "object" == e2 && null != t3 || "function" == e2;
+}
+var Rf = "closure_uid_" + (1e9 * Math.random() >>> 0),
+    Af = 0;
+
+function Df(t3, e2, i2) {
+    return t3.call.apply(t3.bind, arguments);
+}
+
+function Lf(t3, e2, i2) {
+    if (!t3)
+        throw Error();
+    if (2 < arguments.length) {
+        var s2 = Array.prototype.slice.call(arguments, 2);
+        return function() {
+            var i3 = Array.prototype.slice.call(arguments);
+            return Array.prototype.unshift.apply(i3, s2), t3.apply(e2, i3);
+        };
+    }
+    return function() {
+        return t3.apply(e2, arguments);
+    };
+}
+
+function Of(t3, e2, i2) {
+    return (Of = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? Df : Lf).apply(null, arguments);
+}
+
+function Ff(t3, e2) {
+    var i2 = Array.prototype.slice.call(arguments, 1);
+    return function() {
+        var e3 = i2.slice();
+        return e3.push.apply(e3, arguments), t3.apply(this, e3);
+    };
+}
+
+function Nf(t3, e2) {
+    function i2() {}
+    i2.prototype = e2.prototype, t3.$ = e2.prototype, t3.prototype = new i2(), t3.prototype.constructor = t3, t3.ac = function(t4, i3, s2) {
+        for (var n2 = Array(arguments.length - 2), r2 = 2; r2 < arguments.length; r2++)
+            n2[r2 - 2] = arguments[r2];
+        return e2.prototype[i3].apply(t4, n2);
+    };
+}
+
+function $f() {
+    this.s = this.s, this.o = this.o;
+}
+$f.prototype.s = false, $f.prototype.sa = function() {
+    !this.s && (this.s = true, this.N(), 0);
+}, $f.prototype.N = function() {
+    if (this.o)
+        for (; this.o.length;)
+            this.o.shift()();
+};
+const Vf = Array.prototype.indexOf ? function(t3, e2) {
+    return Array.prototype.indexOf.call(t3, e2, void 0);
+} : function(t3, e2) {
+    if ("string" == typeof t3)
+        return "string" != typeof e2 || 1 != e2.length ? -1 : t3.indexOf(e2, 0);
+    for (let i2 = 0; i2 < t3.length; i2++)
+        if (i2 in t3 && t3[i2] === e2)
+            return i2;
+    return -1;
+};
+
+function zf(t3) {
+    const e2 = t3.length;
+    if (0 < e2) {
+        const i2 = Array(e2);
+        for (let s2 = 0; s2 < e2; s2++)
+            i2[s2] = t3[s2];
+        return i2;
+    }
+    return [];
+}
+
+function Bf(t3, e2) {
+    for (let e3 = 1; e3 < arguments.length; e3++) {
+        const i2 = arguments[e3];
+        if (Mf(i2)) {
+            const e4 = t3.length || 0,
+                s2 = i2.length || 0;
+            t3.length = e4 + s2;
+            for (let n2 = 0; n2 < s2; n2++)
+                t3[e4 + n2] = i2[n2];
+        } else
+            t3.push(i2);
+    }
+}
+
+function Uf(t3, e2) {
+    this.type = t3, this.g = this.target = e2, this.defaultPrevented = false;
+}
+Uf.prototype.h = function() {
+    this.defaultPrevented = true;
+};
+var jf = function() {
+    if (!If.addEventListener || !Object.defineProperty)
+        return false;
+    var t3 = false,
+        e2 = Object.defineProperty({}, "passive", {
+            get: function() {
+                t3 = true;
+            }
+        });
+    try {
+        If.addEventListener("test", () => {}, e2), If.removeEventListener("test", () => {}, e2);
+    } catch (t4) {}
+    return t3;
+}();
+
+function Hf(t3) {
+    return /^[\s\xa0]*$/.test(t3);
+}
+
+function Wf() {
+    var t3 = If.navigator;
+    return t3 && (t3 = t3.userAgent) ? t3 : "";
+}
+
+function qf(t3) {
+    return -1 != Wf().indexOf(t3);
+}
+
+function Kf(t3) {
+    return Kf[" "](t3), t3;
+}
+Kf[" "] = function() {};
+var Gf, Yf, Qf = qf("Opera"),
+    Xf = qf("Trident") || qf("MSIE"),
+    Jf = qf("Edge"),
+    Zf = Jf || Xf,
+    tp = qf("Gecko") && !(-1 != Wf().toLowerCase().indexOf("webkit") && !qf("Edge")) && !(qf("Trident") || qf("MSIE")) && !qf("Edge"),
+    ep = -1 != Wf().toLowerCase().indexOf("webkit") && !qf("Edge");
+
+function ip() {
+    var t3 = If.document;
+    return t3 ? t3.documentMode : void 0;
+}
+t: {
+    var sp = "",
+        np = function() {
+            var t3 = Wf();
+            return tp ? /rv:([^\);]+)(\)|;)/.exec(t3) : Jf ? /Edge\/([\d\.]+)/.exec(t3) : Xf ? /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(t3) : ep ? /WebKit\/(\S+)/.exec(t3) : Qf ? /(?:Version)[ \/]?(\S+)/.exec(t3) : void 0;
+        }();
+    if (np && (sp = np ? np[1] : ""), Xf) {
+        var rp = ip();
+        if (null != rp && rp > parseFloat(sp)) {
+            Gf = String(rp);
+            break t;
+        }
+    }
+    Gf = sp;
+}
+if (If.document && Xf) {
+    var op = ip();
+    Yf = op || (parseInt(Gf, 10) || void 0);
+} else
+    Yf = void 0;
+var ap = Yf;
+
+function lp(t3, e2) {
+    if (Uf.call(this, t3 ? t3.type : ""), this.relatedTarget = this.g = this.target = null, this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0, this.key = "", this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = false, this.state = null, this.pointerId = 0, this.pointerType = "", this.i = null, t3) {
+        var i2 = this.type = t3.type,
+            s2 = t3.changedTouches && t3.changedTouches.length ? t3.changedTouches[0] : null;
+        if (this.target = t3.target || t3.srcElement, this.g = e2, e2 = t3.relatedTarget) {
+            if (tp) {
+                t: {
+                    try {
+                        Kf(e2.nodeName);
+                        var n2 = true;
+                        break t;
+                    } catch (t4) {}
+                    n2 = false;
+                }
+                n2 || (e2 = null);
+            }
+        } else
+            "mouseover" == i2 ? e2 = t3.fromElement : "mouseout" == i2 && (e2 = t3.toElement);
+        this.relatedTarget = e2, s2 ? (this.clientX = void 0 !== s2.clientX ? s2.clientX : s2.pageX, this.clientY = void 0 !== s2.clientY ? s2.clientY : s2.pageY, this.screenX = s2.screenX || 0, this.screenY = s2.screenY || 0) : (this.clientX = void 0 !== t3.clientX ? t3.clientX : t3.pageX, this.clientY = void 0 !== t3.clientY ? t3.clientY : t3.pageY, this.screenX = t3.screenX || 0, this.screenY = t3.screenY || 0), this.button = t3.button, this.key = t3.key || "", this.ctrlKey = t3.ctrlKey, this.altKey = t3.altKey, this.shiftKey = t3.shiftKey, this.metaKey = t3.metaKey, this.pointerId = t3.pointerId || 0, this.pointerType = "string" == typeof t3.pointerType ? t3.pointerType : hp[t3.pointerType] || "", this.state = t3.state, this.i = t3, t3.defaultPrevented && lp.$.h.call(this);
+    }
+}
+Nf(lp, Uf);
+var hp = {
+    2: "touch",
+    3: "pen",
+    4: "mouse"
+};
+lp.prototype.h = function() {
+    lp.$.h.call(this);
+    var t3 = this.i;
+    t3.preventDefault ? t3.preventDefault() : t3.returnValue = false;
+};
+var cp = "closure_listenable_" + (1e6 * Math.random() | 0),
+    up = 0;
+
+function dp(t3, e2, i2, s2, n2) {
+    this.listener = t3, this.proxy = null, this.src = e2, this.type = i2, this.capture = !!s2, this.la = n2, this.key = ++up, this.fa = this.ia = false;
+}
+
+function fp(t3) {
+    t3.fa = true, t3.listener = null, t3.proxy = null, t3.src = null, t3.la = null;
+}
+
+function pp(t3, e2, i2) {
+    for (const s2 in t3)
+        e2.call(i2, t3[s2], s2, t3);
+}
+
+function mp(t3) {
+    const e2 = {};
+    for (const i2 in t3)
+        e2[i2] = t3[i2];
+    return e2;
+}
+const gp = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
+
+function yp(t3, e2) {
+    let i2, s2;
+    for (let e3 = 1; e3 < arguments.length; e3++) {
+        for (i2 in s2 = arguments[e3], s2)
+            t3[i2] = s2[i2];
+        for (let e4 = 0; e4 < gp.length; e4++)
+            i2 = gp[e4], Object.prototype.hasOwnProperty.call(s2, i2) && (t3[i2] = s2[i2]);
+    }
+}
+
+function vp(t3) {
+    this.src = t3, this.g = {}, this.h = 0;
+}
+
+function bp(t3, e2) {
+    var i2 = e2.type;
+    if (i2 in t3.g) {
+        var s2, n2 = t3.g[i2],
+            r2 = Vf(n2, e2);
+        (s2 = 0 <= r2) && Array.prototype.splice.call(n2, r2, 1), s2 && (fp(e2), 0 == t3.g[i2].length && (delete t3.g[i2], t3.h--));
+    }
+}
+
+function _p(t3, e2, i2, s2) {
+    for (var n2 = 0; n2 < t3.length; ++n2) {
+        var r2 = t3[n2];
+        if (!r2.fa && r2.listener == e2 && r2.capture == !!i2 && r2.la == s2)
+            return n2;
+    }
+    return -1;
+}
+vp.prototype.add = function(t3, e2, i2, s2, n2) {
+    var r2 = t3.toString();
+    (t3 = this.g[r2]) || (t3 = this.g[r2] = [], this.h++);
+    var o2 = _p(t3, e2, s2, n2);
+    return -1 < o2 ? (e2 = t3[o2], i2 || (e2.ia = false)) : ((e2 = new dp(e2, this.src, r2, !!s2, n2)).ia = i2, t3.push(e2)), e2;
+};
+var wp = "closure_lm_" + (1e6 * Math.random() | 0),
+    xp = {};
+
+function kp(t3, e2, i2, s2, n2) {
+    if (s2 && s2.once)
+        return Sp(t3, e2, i2, s2, n2);
+    if (Array.isArray(e2)) {
+        for (var r2 = 0; r2 < e2.length; r2++)
+            kp(t3, e2[r2], i2, s2, n2);
+        return null;
+    }
+    return i2 = Ap(i2), t3 && t3[cp] ? t3.O(e2, i2, Pf(s2) ? !!s2.capture : !!s2, n2) : Tp(t3, e2, i2, false, s2, n2);
+}
+
+function Tp(t3, e2, i2, s2, n2, r2) {
+    if (!e2)
+        throw Error("Invalid event type");
+    var o2 = Pf(n2) ? !!n2.capture : !!n2,
+        a2 = Pp(t3);
+    if (a2 || (t3[wp] = a2 = new vp(t3)), (i2 = a2.add(e2, i2, s2, o2, r2)).proxy)
+        return i2;
+    if (s2 = function() {
+            function t4(i3) {
+                return e3.call(t4.src, t4.listener, i3);
+            }
+            const e3 = Mp;
+            return t4;
+        }(), i2.proxy = s2, s2.src = t3, s2.listener = i2, t3.addEventListener)
+        jf || (n2 = o2), void 0 === n2 && (n2 = false), t3.addEventListener(e2.toString(), s2, n2);
+    else if (t3.attachEvent)
+        t3.attachEvent(Ip(e2.toString()), s2);
+    else {
+        if (!t3.addListener || !t3.removeListener)
+            throw Error("addEventListener and attachEvent are unavailable.");
+        t3.addListener(s2);
+    }
+    return i2;
+}
+
+function Sp(t3, e2, i2, s2, n2) {
+    if (Array.isArray(e2)) {
+        for (var r2 = 0; r2 < e2.length; r2++)
+            Sp(t3, e2[r2], i2, s2, n2);
+        return null;
+    }
+    return i2 = Ap(i2), t3 && t3[cp] ? t3.P(e2, i2, Pf(s2) ? !!s2.capture : !!s2, n2) : Tp(t3, e2, i2, true, s2, n2);
+}
+
+function Ep(t3, e2, i2, s2, n2) {
+    if (Array.isArray(e2))
+        for (var r2 = 0; r2 < e2.length; r2++)
+            Ep(t3, e2[r2], i2, s2, n2);
+    else
+        s2 = Pf(s2) ? !!s2.capture : !!s2, i2 = Ap(i2), t3 && t3[cp] ? (t3 = t3.i, (e2 = String(e2).toString()) in t3.g && (-1 < (i2 = _p(r2 = t3.g[e2], i2, s2, n2)) && (fp(r2[i2]), Array.prototype.splice.call(r2, i2, 1), 0 == r2.length && (delete t3.g[e2], t3.h--)))) : t3 && (t3 = Pp(t3)) && (e2 = t3.g[e2.toString()], t3 = -1, e2 && (t3 = _p(e2, i2, s2, n2)), (i2 = -1 < t3 ? e2[t3] : null) && Cp(i2));
+}
+
+function Cp(t3) {
+    if ("number" != typeof t3 && t3 && !t3.fa) {
+        var e2 = t3.src;
+        if (e2 && e2[cp])
+            bp(e2.i, t3);
+        else {
+            var i2 = t3.type,
+                s2 = t3.proxy;
+            e2.removeEventListener ? e2.removeEventListener(i2, s2, t3.capture) : e2.detachEvent ? e2.detachEvent(Ip(i2), s2) : e2.addListener && e2.removeListener && e2.removeListener(s2), (i2 = Pp(e2)) ? (bp(i2, t3), 0 == i2.h && (i2.src = null, e2[wp] = null)) : fp(t3);
+        }
+    }
+}
+
+function Ip(t3) {
+    return t3 in xp ? xp[t3] : xp[t3] = "on" + t3;
+}
+
+function Mp(t3, e2) {
+    if (t3.fa)
+        t3 = true;
+    else {
+        e2 = new lp(e2, this);
+        var i2 = t3.listener,
+            s2 = t3.la || t3.src;
+        t3.ia && Cp(t3), t3 = i2.call(s2, e2);
+    }
+    return t3;
+}
+
+function Pp(t3) {
+    return (t3 = t3[wp]) instanceof vp ? t3 : null;
+}
+var Rp = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
+
+function Ap(t3) {
+    return "function" == typeof t3 ? t3 : (t3[Rp] || (t3[Rp] = function(e2) {
+        return t3.handleEvent(e2);
+    }), t3[Rp]);
+}
+
+function Dp() {
+    $f.call(this), this.i = new vp(this), this.S = this, this.J = null;
+}
+
+function Lp(t3, e2) {
+    var i2, s2 = t3.J;
+    if (s2)
+        for (i2 = []; s2; s2 = s2.J)
+            i2.push(s2);
+    if (t3 = t3.S, s2 = e2.type || e2, "string" == typeof e2)
+        e2 = new Uf(e2, t3);
+    else if (e2 instanceof Uf)
+        e2.target = e2.target || t3;
+    else {
+        var n2 = e2;
+        yp(e2 = new Uf(s2, t3), n2);
+    }
+    if (n2 = true, i2)
+        for (var r2 = i2.length - 1; 0 <= r2; r2--) {
+            var o2 = e2.g = i2[r2];
+            n2 = Op(o2, s2, true, e2) && n2;
+        }
+    if (n2 = Op(o2 = e2.g = t3, s2, true, e2) && n2, n2 = Op(o2, s2, false, e2) && n2, i2)
+        for (r2 = 0; r2 < i2.length; r2++)
+            n2 = Op(o2 = e2.g = i2[r2], s2, false, e2) && n2;
+}
+
+function Op(t3, e2, i2, s2) {
+    if (!(e2 = t3.i.g[String(e2)]))
+        return true;
+    e2 = e2.concat();
+    for (var n2 = true, r2 = 0; r2 < e2.length; ++r2) {
+        var o2 = e2[r2];
+        if (o2 && !o2.fa && o2.capture == i2) {
+            var a2 = o2.listener,
+                l2 = o2.la || o2.src;
+            o2.ia && bp(t3.i, o2), n2 = false !== a2.call(l2, s2) && n2;
+        }
+    }
+    return n2 && !s2.defaultPrevented;
+}
+Nf(Dp, $f), Dp.prototype[cp] = true, Dp.prototype.removeEventListener = function(t3, e2, i2, s2) {
+    Ep(this, t3, e2, i2, s2);
+}, Dp.prototype.N = function() {
+    if (Dp.$.N.call(this), this.i) {
+        var t3, e2 = this.i;
+        for (t3 in e2.g) {
+            for (var i2 = e2.g[t3], s2 = 0; s2 < i2.length; s2++)
+                fp(i2[s2]);
+            delete e2.g[t3], e2.h--;
+        }
+    }
+    this.J = null;
+}, Dp.prototype.O = function(t3, e2, i2, s2) {
+    return this.i.add(String(t3), e2, false, i2, s2);
+}, Dp.prototype.P = function(t3, e2, i2, s2) {
+    return this.i.add(String(t3), e2, true, i2, s2);
+};
+var Fp = If.JSON.stringify;
+
+function Np() {
+    var t3 = jp;
+    let e2 = null;
+    return t3.g && (e2 = t3.g, t3.g = t3.g.next, t3.g || (t3.h = null), e2.next = null), e2;
+}
+var $p = new class kb {
+    constructor(t3, e2) {
+        this.i = t3, this.j = e2, this.h = 0, this.g = null;
+    }
+    get() {
+        let t3;
+        return 0 < this.h ? (this.h--, t3 = this.g, this.g = t3.next, t3.next = null) : t3 = this.i(), t3;
+    }
+}(() => new pb(), (t3) => t3.reset());
+class pb {
+    constructor() {
+        this.next = this.g = this.h = null;
+    }
+    set(t3, e2) {
+        this.h = t3, this.g = e2, this.next = null;
+    }
+    reset() {
+        this.next = this.g = this.h = null;
+    }
+}
+
+function Vp(t3) {
+    var e2 = 1;
+    t3 = t3.split(":");
+    const i2 = [];
+    for (; 0 < e2 && t3.length;)
+        i2.push(t3.shift()), e2--;
+    return t3.length && i2.push(t3.join(":")), i2;
+}
+
+function zp(t3) {
+    If.setTimeout(() => {
+        throw t3;
+    }, 0);
+}
+let Bp, Up = false,
+    jp = new class nb {
+        constructor() {
+            this.h = this.g = null;
+        }
+        add(t3, e2) {
+            const i2 = $p.get();
+            i2.set(t3, e2), this.h ? this.h.next = i2 : this.g = i2, this.h = i2;
+        }
+    }(),
+    Hp = () => {
+        const t3 = If.Promise.resolve(void 0);
+        Bp = () => {
+            t3.then(Wp);
+        };
+    };
+var Wp = () => {
+    for (var t3; t3 = Np();) {
+        try {
+            t3.h.call(t3.g);
+        } catch (t4) {
+            zp(t4);
+        }
+        var e2 = $p;
+        e2.j(t3), 100 > e2.h && (e2.h++, t3.next = e2.g, e2.g = t3);
+    }
+    Up = false;
+};
+
+function qp(t3, e2) {
+    Dp.call(this), this.h = t3 || 1, this.g = e2 || If, this.j = Of(this.qb, this), this.l = Date.now();
+}
+
+function Kp(t3) {
+    t3.ga = false, t3.T && (t3.g.clearTimeout(t3.T), t3.T = null);
+}
+
+function Gp(t3, e2, i2) {
+    if ("function" == typeof t3)
+        i2 && (t3 = Of(t3, i2));
+    else {
+        if (!t3 || "function" != typeof t3.handleEvent)
+            throw Error("Invalid listener argument");
+        t3 = Of(t3.handleEvent, t3);
+    }
+    return 2147483647 < Number(e2) ? -1 : If.setTimeout(t3, e2 || 0);
+}
+
+function Yp(t3) {
+    t3.g = Gp(() => {
+        t3.g = null, t3.i && (t3.i = false, Yp(t3));
+    }, t3.j);
+    const e2 = t3.h;
+    t3.h = null, t3.m.apply(null, e2);
+}
+Nf(qp, Dp), (Sf = qp.prototype).ga = false, Sf.T = null, Sf.qb = function() {
+    if (this.ga) {
+        var t3 = Date.now() - this.l;
+        0 < t3 && t3 < 0.8 * this.h ? this.T = this.g.setTimeout(this.j, this.h - t3) : (this.T && (this.g.clearTimeout(this.T), this.T = null), Lp(this, "tick"), this.ga && (Kp(this), this.start()));
+    }
+}, Sf.start = function() {
+    this.ga = true, this.T || (this.T = this.g.setTimeout(this.j, this.h), this.l = Date.now());
+}, Sf.N = function() {
+    qp.$.N.call(this), Kp(this), delete this.g;
+};
+class Ab extends $f {
+    constructor(t3, e2) {
+        super(), this.m = t3, this.j = e2, this.h = null, this.i = false, this.g = null;
+    }
+    l(t3) {
+        this.h = arguments, this.g ? this.i = true : Yp(this);
+    }
+    N() {
+        super.N(), this.g && (If.clearTimeout(this.g), this.g = null, this.i = false, this.h = null);
+    }
+}
+
+function Qp(t3) {
+    $f.call(this), this.h = t3, this.g = {};
+}
+Nf(Qp, $f);
+var Xp = [];
+
+function Jp(t3, e2, i2, s2) {
+    Array.isArray(i2) || (i2 && (Xp[0] = i2.toString()), i2 = Xp);
+    for (var n2 = 0; n2 < i2.length; n2++) {
+        var r2 = kp(e2, i2[n2], s2 || t3.handleEvent, false, t3.h || t3);
+        if (!r2)
+            break;
+        t3.g[r2.key] = r2;
+    }
+}
+
+function Zp(t3) {
+    pp(t3.g, function(t4, e2) {
+        this.g.hasOwnProperty(e2) && Cp(t4);
+    }, t3), t3.g = {};
+}
+
+function tm() {
+    this.g = true;
+}
+
+function em(t3, e2, i2, s2) {
+    t3.info(function() {
+        return "XMLHTTP TEXT (" + e2 + "): " + function(t4, e3) {
+            if (!t4.g)
+                return e3;
+            if (!e3)
+                return null;
+            try {
+                var i3 = JSON.parse(e3);
+                if (i3) {
+                    for (t4 = 0; t4 < i3.length; t4++)
+                        if (Array.isArray(i3[t4])) {
+                            var s3 = i3[t4];
+                            if (!(2 > s3.length)) {
+                                var n2 = s3[1];
+                                if (Array.isArray(n2) && !(1 > n2.length)) {
+                                    var r2 = n2[0];
+                                    if ("noop" != r2 && "stop" != r2 && "close" != r2)
+                                        for (var o2 = 1; o2 < n2.length; o2++)
+                                            n2[o2] = "";
+                                }
+                            }
+                        }
+                }
+                return Fp(i3);
+            } catch (t5) {
+                return e3;
+            }
+        }(t3, i2) + (s2 ? " " + s2 : "");
+    });
+}
+Qp.prototype.N = function() {
+    Qp.$.N.call(this), Zp(this);
+}, Qp.prototype.handleEvent = function() {
+    throw Error("EventHandler.handleEvent not implemented");
+}, tm.prototype.Ea = function() {
+    this.g = false;
+}, tm.prototype.info = function() {};
+var im = {},
+    sm = null;
+
+function nm() {
+    return sm = sm || new Dp();
+}
+
+function rm(t3) {
+    Uf.call(this, im.Ta, t3);
+}
+
+function om(t3) {
+    const e2 = nm();
+    Lp(e2, new rm(e2));
+}
+
+function am(t3, e2) {
+    Uf.call(this, im.STAT_EVENT, t3), this.stat = e2;
+}
+
+function lm(t3) {
+    const e2 = nm();
+    Lp(e2, new am(e2, t3));
+}
+
+function hm(t3, e2) {
+    Uf.call(this, im.Ua, t3), this.size = e2;
+}
+
+function cm(t3, e2) {
+    if ("function" != typeof t3)
+        throw Error("Fn must not be null and must be a function");
+    return If.setTimeout(function() {
+        t3();
+    }, e2);
+}
+im.Ta = "serverreachability", Nf(rm, Uf), im.STAT_EVENT = "statevent", Nf(am, Uf), im.Ua = "timingevent", Nf(hm, Uf);
+var um = {
+        NO_ERROR: 0,
+        rb: 1,
+        Eb: 2,
+        Db: 3,
+        yb: 4,
+        Cb: 5,
+        Fb: 6,
+        Qa: 7,
+        TIMEOUT: 8,
+        Ib: 9
+    },
+    dm = {
+        wb: "complete",
+        Sb: "success",
+        Ra: "error",
+        Qa: "abort",
+        Kb: "ready",
+        Lb: "readystatechange",
+        TIMEOUT: "timeout",
+        Gb: "incrementaldata",
+        Jb: "progress",
+        zb: "downloadprogress",
+        $b: "uploadprogress"
+    };
+
+function fm() {}
+
+function pm(t3) {
+    return t3.h || (t3.h = t3.i());
+}
+
+function mm() {}
+fm.prototype.h = null;
+var gm, ym = {
+    OPEN: "a",
+    vb: "b",
+    Ra: "c",
+    Hb: "d"
+};
+
+function vm() {
+    Uf.call(this, "d");
+}
+
+function bm() {
+    Uf.call(this, "c");
+}
+
+function _m() {}
+
+function wm(t3, e2, i2, s2) {
+    this.l = t3, this.j = e2, this.m = i2, this.W = s2 || 1, this.U = new Qp(this), this.P = km, t3 = Zf ? 125 : void 0, this.V = new qp(t3), this.I = null, this.i = false, this.s = this.A = this.v = this.L = this.G = this.Y = this.B = null, this.F = [], this.g = null, this.C = 0, this.o = this.u = null, this.ca = -1, this.J = false, this.O = 0, this.M = null, this.ba = this.K = this.aa = this.S = false, this.h = new xm();
+}
+
+function xm() {
+    this.i = null, this.g = "", this.h = false;
+}
+Nf(vm, Uf), Nf(bm, Uf), Nf(_m, fm), _m.prototype.g = function() {
+    return new XMLHttpRequest();
+}, _m.prototype.i = function() {
+    return {};
+}, gm = new _m();
+var km = 45e3,
+    Tm = {},
+    Sm = {};
+
+function Em(t3, e2, i2) {
+    t3.L = 1, t3.v = Wm(zm(e2)), t3.s = i2, t3.S = true, Cm(t3, null);
+}
+
+function Cm(t3, e2) {
+    t3.G = Date.now(), Rm(t3), t3.A = zm(t3.v);
+    var i2 = t3.A,
+        s2 = t3.W;
+    Array.isArray(s2) || (s2 = [String(s2)]), ng(i2.i, "t", s2), t3.C = 0, i2 = t3.l.J, t3.h = new xm(), t3.g = sy(t3.l, i2 ? e2 : null, !t3.s), 0 < t3.O && (t3.M = new Ab(Of(t3.Pa, t3, t3.g), t3.O)), Jp(t3.U, t3.g, "readystatechange", t3.nb), e2 = t3.I ? mp(t3.I) : {}, t3.s ? (t3.u || (t3.u = "POST"), e2["Content-Type"] = "application/x-www-form-urlencoded", t3.g.ha(t3.A, t3.u, t3.s, e2)) : (t3.u = "GET", t3.g.ha(t3.A, t3.u, null, e2)), om(),
+        function(t4, e3, i3, s3, n2, r2) {
+            t4.info(function() {
+                if (t4.g)
+                    if (r2)
+                        for (var o2 = "", a2 = r2.split("&"), l2 = 0; l2 < a2.length; l2++) {
+                            var h2 = a2[l2].split("=");
+                            if (1 < h2.length) {
+                                var c2 = h2[0];
+                                h2 = h2[1];
+                                var u2 = c2.split("_");
+                                o2 = 2 <= u2.length && "type" == u2[1] ? o2 + (c2 + "=") + h2 + "&" : o2 + (c2 + "=redacted&");
+                            }
+                        }
+                else
+                    o2 = null;
+                else
+                    o2 = r2;
+                return "XMLHTTP REQ (" + s3 + ") [attempt " + n2 + "]: " + e3 + "\n" + i3 + "\n" + o2;
+            });
+        }(t3.j, t3.u, t3.A, t3.m, t3.W, t3.s);
+}
+
+function Im(t3) {
+    return !!t3.g && ("GET" == t3.u && 2 != t3.L && t3.l.Ha);
+}
+
+function Mm(t3, e2, i2) {
+    let s2, n2 = true;
+    for (; !t3.J && t3.C < i2.length;) {
+        if (s2 = Pm(t3, i2), s2 == Sm) {
+            4 == e2 && (t3.o = 4, lm(14), n2 = false), em(t3.j, t3.m, null, "[Incomplete Response]");
+            break;
+        }
+        if (s2 == Tm) {
+            t3.o = 4, lm(15), em(t3.j, t3.m, i2, "[Invalid Chunk]"), n2 = false;
+            break;
+        }
+        em(t3.j, t3.m, s2, null), Fm(t3, s2);
+    }
+    Im(t3) && s2 != Sm && s2 != Tm && (t3.h.g = "", t3.C = 0), 4 != e2 || 0 != i2.length || t3.h.h || (t3.o = 1, lm(16), n2 = false), t3.i = t3.i && n2, n2 ? 0 < i2.length && !t3.ba && (t3.ba = true, (e2 = t3.l).g == t3 && e2.ca && !e2.M && (e2.l.info("Great, no buffering proxy detected. Bytes received: " + i2.length), Yg(e2), e2.M = true, lm(11))) : (em(t3.j, t3.m, i2, "[Invalid Chunked Response]"), Om(t3), Lm(t3));
+}
+
+function Pm(t3, e2) {
+    var i2 = t3.C,
+        s2 = e2.indexOf("\n", i2);
+    return -1 == s2 ? Sm : (i2 = Number(e2.substring(i2, s2)), isNaN(i2) ? Tm : (s2 += 1) + i2 > e2.length ? Sm : (e2 = e2.slice(s2, s2 + i2), t3.C = s2 + i2, e2));
+}
+
+function Rm(t3) {
+    t3.Y = Date.now() + t3.P, Am(t3, t3.P);
+}
+
+function Am(t3, e2) {
+    if (null != t3.B)
+        throw Error("WatchDog timer not null");
+    t3.B = cm(Of(t3.lb, t3), e2);
+}
+
+function Dm(t3) {
+    t3.B && (If.clearTimeout(t3.B), t3.B = null);
+}
+
+function Lm(t3) {
+    0 == t3.l.H || t3.J || Jg(t3.l, t3);
+}
+
+function Om(t3) {
+    Dm(t3);
+    var e2 = t3.M;
+    e2 && "function" == typeof e2.sa && e2.sa(), t3.M = null, Kp(t3.V), Zp(t3.U), t3.g && (e2 = t3.g, t3.g = null, e2.abort(), e2.sa());
+}
+
+function Fm(t3, e2) {
+    try {
+        var i2 = t3.l;
+        if (0 != i2.H && (i2.g == t3 || cg(i2.i, t3))) {
+            if (!t3.K && cg(i2.i, t3) && 3 == i2.H) {
+                try {
+                    var s2 = i2.Ja.g.parse(e2);
+                } catch (t4) {
+                    s2 = null;
+                }
+                if (Array.isArray(s2) && 3 == s2.length) {
+                    var n2 = s2;
+                    if (0 == n2[0]) {
+                        t: if (!i2.u) {
+                            if (i2.g) {
+                                if (!(i2.g.G + 3e3 < t3.G))
+                                    break t;
+                                Xg(i2), Bg(i2);
+                            }
+                            Gg(i2), lm(18);
+                        }
+                    }
+                    else
+                        i2.Fa = n2[1], 0 < i2.Fa - i2.V && 37500 > n2[2] && i2.G && 0 == i2.A && !i2.v && (i2.v = cm(Of(i2.ib, i2), 6e3));
+                    if (1 >= hg(i2.i) && i2.oa) {
+                        try {
+                            i2.oa();
+                        } catch (t4) {}
+                        i2.oa = void 0;
+                    }
+                } else
+                    ty(i2, 11);
+            } else if ((t3.K || i2.g == t3) && Xg(i2), !Hf(e2))
+                for (n2 = i2.Ja.g.parse(e2), e2 = 0; e2 < n2.length; e2++) {
+                    let h2 = n2[e2];
+                    if (i2.V = h2[0], h2 = h2[1], 2 == i2.H)
+                        if ("c" == h2[0]) {
+                            i2.K = h2[1], i2.pa = h2[2];
+                            const e3 = h2[3];
+                            null != e3 && (i2.ra = e3, i2.l.info("VER=" + i2.ra));
+                            const n3 = h2[4];
+                            null != n3 && (i2.Ga = n3, i2.l.info("SVER=" + i2.Ga));
+                            const c2 = h2[5];
+                            null != c2 && "number" == typeof c2 && 0 < c2 && (s2 = 1.5 * c2, i2.L = s2, i2.l.info("backChannelRequestTimeoutMs_=" + s2)), s2 = i2;
+                            const u2 = t3.g;
+                            if (u2) {
+                                const t4 = u2.g ? u2.g.getResponseHeader("X-Client-Wire-Protocol") : null;
+                                if (t4) {
+                                    var r2 = s2.i;
+                                    r2.g || -1 == t4.indexOf("spdy") && -1 == t4.indexOf("quic") && -1 == t4.indexOf("h2") || (r2.j = r2.l, r2.g = /* @__PURE__ */ new Set(), r2.h && (ug(r2, r2.h), r2.h = null));
+                                }
+                                if (s2.F) {
+                                    const t5 = u2.g ? u2.g.getResponseHeader("X-HTTP-Session-Id") : null;
+                                    t5 && (s2.Da = t5, Hm(s2.I, s2.F, t5));
+                                }
+                            }
+                            i2.H = 3, i2.h && i2.h.Ba(), i2.ca && (i2.S = Date.now() - t3.G, i2.l.info("Handshake RTT: " + i2.S + "ms"));
+                            var o2 = t3;
+                            if ((s2 = i2).wa = iy(s2, s2.J ? s2.pa : null, s2.Y), o2.K) {
+                                dg(s2.i, o2);
+                                var a2 = o2,
+                                    l2 = s2.L;
+                                l2 && a2.setTimeout(l2), a2.B && (Dm(a2), Rm(a2)), s2.g = o2;
+                            } else
+                                Kg(s2);
+                            0 < i2.j.length && jg(i2);
+                        } else
+                            "stop" != h2[0] && "close" != h2[0] || ty(i2, 7);
+                    else
+                        3 == i2.H && ("stop" == h2[0] || "close" == h2[0] ? "stop" == h2[0] ? ty(i2, 7) : zg(i2) : "noop" != h2[0] && i2.h && i2.h.Aa(h2), i2.A = 0);
+                }
+        }
+        om();
+    } catch (t4) {}
+}
+
+function Nm(t3, e2) {
+    if (t3.forEach && "function" == typeof t3.forEach)
+        t3.forEach(e2, void 0);
+    else if (Mf(t3) || "string" == typeof t3)
+        Array.prototype.forEach.call(t3, e2, void 0);
+    else
+        for (var i2 = function(t4) {
+                if (t4.ta && "function" == typeof t4.ta)
+                    return t4.ta();
+                if (!t4.Z || "function" != typeof t4.Z) {
+                    if ("undefined" != typeof Map && t4 instanceof Map)
+                        return Array.from(t4.keys());
+                    if (!("undefined" != typeof Set && t4 instanceof Set)) {
+                        if (Mf(t4) || "string" == typeof t4) {
+                            var e3 = [];
+                            t4 = t4.length;
+                            for (var i3 = 0; i3 < t4; i3++)
+                                e3.push(i3);
+                            return e3;
+                        }
+                        e3 = [], i3 = 0;
+                        for (const s3 in t4)
+                            e3[i3++] = s3;
+                        return e3;
+                    }
+                }
+            }(t3), s2 = function(t4) {
+                if (t4.Z && "function" == typeof t4.Z)
+                    return t4.Z();
+                if ("undefined" != typeof Map && t4 instanceof Map || "undefined" != typeof Set && t4 instanceof Set)
+                    return Array.from(t4.values());
+                if ("string" == typeof t4)
+                    return t4.split("");
+                if (Mf(t4)) {
+                    for (var e3 = [], i3 = t4.length, s3 = 0; s3 < i3; s3++)
+                        e3.push(t4[s3]);
+                    return e3;
+                }
+                for (s3 in e3 = [], i3 = 0, t4)
+                    e3[i3++] = t4[s3];
+                return e3;
+            }(t3), n2 = s2.length, r2 = 0; r2 < n2; r2++)
+            e2.call(void 0, s2[r2], i2 && i2[r2], t3);
+}
+(Sf = wm.prototype).setTimeout = function(t3) {
+    this.P = t3;
+}, Sf.nb = function(t3) {
+    t3 = t3.target;
+    const e2 = this.M;
+    e2 && 3 == Lg(t3) ? e2.l() : this.Pa(t3);
+}, Sf.Pa = function(t3) {
+    try {
+        if (t3 == this.g)
+            t: {
+                const c2 = Lg(this.g);
+                var e2 = this.g.Ia();
+                this.g.da();
+                if (!(3 > c2) && (3 != c2 || Zf || this.g && (this.h.h || this.g.ja() || Og(this.g)))) {
+                    this.J || 4 != c2 || 7 == e2 || om(), Dm(this);
+                    var i2 = this.g.da();
+                    this.ca = i2;
+                    e:
+                        if (Im(this)) {
+                            var s2 = Og(this.g);
+                            t3 = "";
+                            var n2 = s2.length,
+                                r2 = 4 == Lg(this.g);
+                            if (!this.h.i) {
+                                if ("undefined" == typeof TextDecoder) {
+                                    Om(this), Lm(this);
+                                    var o2 = "";
+                                    break e;
+                                }
+                                this.h.i = new If.TextDecoder();
+                            }
+                            for (e2 = 0; e2 < n2; e2++)
+                                this.h.h = true, t3 += this.h.i.decode(s2[e2], {
+                                    stream: r2 && e2 == n2 - 1
+                                });
+                            s2.splice(0, n2), this.h.g += t3, this.C = 0, o2 = this.h.g;
+                        } else
+                            o2 = this.g.ja();
+                    if (this.i = 200 == i2, function(t4, e3, i3, s3, n3, r3, o3) {
+                            t4.info(function() {
+                                return "XMLHTTP RESP (" + s3 + ") [ attempt " + n3 + "]: " + e3 + "\n" + i3 + "\n" + r3 + " " + o3;
+                            });
+                        }(this.j, this.u, this.A, this.m, this.W, c2, i2), this.i) {
+                        if (this.aa && !this.K) {
+                            e: {
+                                if (this.g) {
+                                    var a2, l2 = this.g;
+                                    if ((a2 = l2.g ? l2.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !Hf(a2)) {
+                                        var h2 = a2;
+                                        break e;
+                                    }
+                                }
+                                h2 = null;
+                            }
+                            if (!(i2 = h2)) {
+                                this.i = false, this.o = 3, lm(12), Om(this), Lm(this);
+                                break t;
+                            }
+                            em(this.j, this.m, i2, "Initial handshake response via X-HTTP-Initial-Response"),
+                            this.K = true,
+                            Fm(this, i2);
+                        }
+                        this.S ? (Mm(this, c2, o2), Zf && this.i && 3 == c2 && (Jp(this.U, this.V, "tick", this.mb), this.V.start())) : (em(this.j, this.m, o2, null), Fm(this, o2)), 4 == c2 && Om(this), this.i && !this.J && (4 == c2 ? Jg(this.l, this) : (this.i = false, Rm(this)));
+                    } else
+                        (function(t4) {
+                            const e3 = {};
+                            t4 = (t4.g && 2 <= Lg(t4) && t4.g.getAllResponseHeaders() || "").split("\r\n");
+                            for (let s3 = 0; s3 < t4.length; s3++) {
+                                if (Hf(t4[s3]))
+                                    continue;
+                                var i3 = Vp(t4[s3]);
+                                const n3 = i3[0];
+                                if ("string" != typeof(i3 = i3[1]))
+                                    continue;
+                                i3 = i3.trim();
+                                const r3 = e3[n3] || [];
+                                e3[n3] = r3, r3.push(i3);
+                            }! function(t5, e4) {
+                                for (const i4 in t5)
+                                    e4.call(void 0, t5[i4], i4, t5);
+                            }(e3, function(t5) {
+                                return t5.join(", ");
+                            });
+                        })(this.g), 400 == i2 && 0 < o2.indexOf("Unknown SID") ? (this.o = 3, lm(12)) : (this.o = 0, lm(13)), Om(this), Lm(this);
+                }
+            }
+    } catch (t4) {}
+}, Sf.mb = function() {
+    if (this.g) {
+        var t3 = Lg(this.g),
+            e2 = this.g.ja();
+        this.C < e2.length && (Dm(this), Mm(this, t3, e2), this.i && 4 != t3 && Rm(this));
+    }
+}, Sf.cancel = function() {
+    this.J = true, Om(this);
+}, Sf.lb = function() {
+    this.B = null;
+    const t3 = Date.now();
+    0 <= t3 - this.Y ? (function(t4, e2) {
+        t4.info(function() {
+            return "TIMEOUT: " + e2;
+        });
+    }(this.j, this.A), 2 != this.L && (om(), lm(17)), Om(this), this.o = 2, Lm(this)) : Am(this, this.Y - t3);
+};
+var $m = RegExp("^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$");
+
+function Vm(t3) {
+    if (this.g = this.s = this.j = "", this.m = null, this.o = this.l = "", this.h = false, t3 instanceof Vm) {
+        this.h = t3.h, Bm(this, t3.j), this.s = t3.s, this.g = t3.g, Um(this, t3.m), this.l = t3.l;
+        var e2 = t3.i,
+            i2 = new tg();
+        i2.i = e2.i, e2.g && (i2.g = new Map(e2.g), i2.h = e2.h), jm(this, i2), this.o = t3.o;
+    } else
+        t3 && (e2 = String(t3).match($m)) ? (this.h = false, Bm(this, e2[1] || "", true), this.s = qm(e2[2] || ""), this.g = qm(e2[3] || "", true), Um(this, e2[4]), this.l = qm(e2[5] || "", true), jm(this, e2[6] || "", true), this.o = qm(e2[7] || "")) : (this.h = false, this.i = new tg(null, this.h));
+}
+
+function zm(t3) {
+    return new Vm(t3);
+}
+
+function Bm(t3, e2, i2) {
+    t3.j = i2 ? qm(e2, true) : e2, t3.j && (t3.j = t3.j.replace(/:$/, ""));
+}
+
+function Um(t3, e2) {
+    if (e2) {
+        if (e2 = Number(e2), isNaN(e2) || 0 > e2)
+            throw Error("Bad port number " + e2);
+        t3.m = e2;
+    } else
+        t3.m = null;
+}
+
+function jm(t3, e2, i2) {
+    e2 instanceof tg ? (t3.i = e2, function(t4, e3) {
+        e3 && !t4.j && (eg(t4), t4.i = null, t4.g.forEach(function(t5, e4) {
+            var i3 = e4.toLowerCase();
+            e4 != i3 && (ig(this, e4), ng(this, i3, t5));
+        }, t4)), t4.j = e3;
+    }(t3.i, t3.h)) : (i2 || (e2 = Km(e2, Jm)), t3.i = new tg(e2, t3.h));
+}
+
+function Hm(t3, e2, i2) {
+    t3.i.set(e2, i2);
+}
+
+function Wm(t3) {
+    return Hm(t3, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36)), t3;
+}
+
+function qm(t3, e2) {
+    return t3 ? e2 ? decodeURI(t3.replace(/%25/g, "%2525")) : decodeURIComponent(t3) : "";
+}
+
+function Km(t3, e2, i2) {
+    return "string" == typeof t3 ? (t3 = encodeURI(t3).replace(e2, Gm), i2 && (t3 = t3.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), t3) : null;
+}
+
+function Gm(t3) {
+    return "%" + ((t3 = t3.charCodeAt(0)) >> 4 & 15).toString(16) + (15 & t3).toString(16);
+}
+Vm.prototype.toString = function() {
+    var t3 = [],
+        e2 = this.j;
+    e2 && t3.push(Km(e2, Ym, true), ":");
+    var i2 = this.g;
+    return (i2 || "file" == e2) && (t3.push("//"), (e2 = this.s) && t3.push(Km(e2, Ym, true), "@"), t3.push(encodeURIComponent(String(i2)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), null != (i2 = this.m) && t3.push(":", String(i2))), (i2 = this.l) && (this.g && "/" != i2.charAt(0) && t3.push("/"), t3.push(Km(i2, "/" == i2.charAt(0) ? Xm : Qm, true))), (i2 = this.i.toString()) && t3.push("?", i2), (i2 = this.o) && t3.push("#", Km(i2, Zm)), t3.join("");
+};
+var Ym = /[#\/\?@]/g,
+    Qm = /[#\?:]/g,
+    Xm = /[#\?]/g,
+    Jm = /[#\?@]/g,
+    Zm = /#/g;
+
+function tg(t3, e2) {
+    this.h = this.g = null, this.i = t3 || null, this.j = !!e2;
+}
+
+function eg(t3) {
+    t3.g || (t3.g = /* @__PURE__ */ new Map(), t3.h = 0, t3.i && function(t4, e2) {
+        if (t4) {
+            t4 = t4.split("&");
+            for (var i2 = 0; i2 < t4.length; i2++) {
+                var s2 = t4[i2].indexOf("="),
+                    n2 = null;
+                if (0 <= s2) {
+                    var r2 = t4[i2].substring(0, s2);
+                    n2 = t4[i2].substring(s2 + 1);
+                } else
+                    r2 = t4[i2];
+                e2(r2, n2 ? decodeURIComponent(n2.replace(/\+/g, " ")) : "");
+            }
+        }
+    }(t3.i, function(e2, i2) {
+        t3.add(decodeURIComponent(e2.replace(/\+/g, " ")), i2);
+    }));
+}
+
+function ig(t3, e2) {
+    eg(t3), e2 = rg(t3, e2), t3.g.has(e2) && (t3.i = null, t3.h -= t3.g.get(e2).length, t3.g.delete(e2));
+}
+
+function sg(t3, e2) {
+    return eg(t3), e2 = rg(t3, e2), t3.g.has(e2);
+}
+
+function ng(t3, e2, i2) {
+    ig(t3, e2), 0 < i2.length && (t3.i = null, t3.g.set(rg(t3, e2), zf(i2)), t3.h += i2.length);
+}
+
+function rg(t3, e2) {
+    return e2 = String(e2), t3.j && (e2 = e2.toLowerCase()), e2;
+}
+(Sf = tg.prototype).add = function(t3, e2) {
+    eg(this), this.i = null, t3 = rg(this, t3);
+    var i2 = this.g.get(t3);
+    return i2 || this.g.set(t3, i2 = []), i2.push(e2), this.h += 1, this;
+}, Sf.forEach = function(t3, e2) {
+    eg(this), this.g.forEach(function(i2, s2) {
+        i2.forEach(function(i3) {
+            t3.call(e2, i3, s2, this);
+        }, this);
+    }, this);
+}, Sf.ta = function() {
+    eg(this);
+    const t3 = Array.from(this.g.values()),
+        e2 = Array.from(this.g.keys()),
+        i2 = [];
+    for (let s2 = 0; s2 < e2.length; s2++) {
+        const n2 = t3[s2];
+        for (let t4 = 0; t4 < n2.length; t4++)
+            i2.push(e2[s2]);
+    }
+    return i2;
+}, Sf.Z = function(t3) {
+    eg(this);
+    let e2 = [];
+    if ("string" == typeof t3)
+        sg(this, t3) && (e2 = e2.concat(this.g.get(rg(this, t3))));
+    else {
+        t3 = Array.from(this.g.values());
+        for (let i2 = 0; i2 < t3.length; i2++)
+            e2 = e2.concat(t3[i2]);
+    }
+    return e2;
+}, Sf.set = function(t3, e2) {
+    return eg(this), this.i = null, sg(this, t3 = rg(this, t3)) && (this.h -= this.g.get(t3).length), this.g.set(t3, [e2]), this.h += 1, this;
+}, Sf.get = function(t3, e2) {
+    return t3 && 0 < (t3 = this.Z(t3)).length ? String(t3[0]) : e2;
+}, Sf.toString = function() {
+    if (this.i)
+        return this.i;
+    if (!this.g)
+        return "";
+    const t3 = [],
+        e2 = Array.from(this.g.keys());
+    for (var i2 = 0; i2 < e2.length; i2++) {
+        var s2 = e2[i2];
+        const r2 = encodeURIComponent(String(s2)),
+            o2 = this.Z(s2);
+        for (s2 = 0; s2 < o2.length; s2++) {
+            var n2 = r2;
+            "" !== o2[s2] && (n2 += "=" + encodeURIComponent(String(o2[s2]))), t3.push(n2);
+        }
+    }
+    return this.i = t3.join("&");
+};
+
+function og(t3) {
+    this.l = t3 || ag, If.PerformanceNavigationTiming ? t3 = 0 < (t3 = If.performance.getEntriesByType("navigation")).length && ("hq" == t3[0].nextHopProtocol || "h2" == t3[0].nextHopProtocol) : t3 = !!(If.g && If.g.Ka && If.g.Ka() && If.g.Ka().ec), this.j = t3 ? this.l : 1, this.g = null, 1 < this.j && (this.g = /* @__PURE__ */ new Set()), this.h = null, this.i = [];
+}
+var ag = 10;
+
+function lg(t3) {
+    return !!t3.h || !!t3.g && t3.g.size >= t3.j;
+}
+
+function hg(t3) {
+    return t3.h ? 1 : t3.g ? t3.g.size : 0;
+}
+
+function cg(t3, e2) {
+    return t3.h ? t3.h == e2 : !!t3.g && t3.g.has(e2);
+}
+
+function ug(t3, e2) {
+    t3.g ? t3.g.add(e2) : t3.h = e2;
+}
+
+function dg(t3, e2) {
+    t3.h && t3.h == e2 ? t3.h = null : t3.g && t3.g.has(e2) && t3.g.delete(e2);
+}
+
+function fg(t3) {
+    if (null != t3.h)
+        return t3.i.concat(t3.h.F);
+    if (null != t3.g && 0 !== t3.g.size) {
+        let e2 = t3.i;
+        for (const i2 of t3.g.values())
+            e2 = e2.concat(i2.F);
+        return e2;
+    }
+    return zf(t3.i);
+}
+og.prototype.cancel = function() {
+    if (this.i = fg(this), this.h)
+        this.h.cancel(), this.h = null;
+    else if (this.g && 0 !== this.g.size) {
+        for (const t3 of this.g.values())
+            t3.cancel();
+        this.g.clear();
+    }
+};
+var pg = class {
+    stringify(t3) {
+        return If.JSON.stringify(t3, void 0);
+    }
+    parse(t3) {
+        return If.JSON.parse(t3, void 0);
+    }
+};
+
+function mg() {
+    this.g = new pg();
+}
+
+function gg(t3, e2, i2) {
+    const s2 = i2 || "";
+    try {
+        Nm(t3, function(t4, i3) {
+            let n2 = t4;
+            Pf(t4) && (n2 = Fp(t4)), e2.push(s2 + i3 + "=" + encodeURIComponent(n2));
+        });
+    } catch (t4) {
+        throw e2.push(s2 + "type=" + encodeURIComponent("_badmap")), t4;
+    }
+}
+
+function yg(t3, e2, i2, s2, n2) {
+    try {
+        e2.onload = null, e2.onerror = null, e2.onabort = null, e2.ontimeout = null, n2(s2);
+    } catch (t4) {}
+}
+
+function vg(t3) {
+    this.l = t3.fc || null, this.j = t3.ob || false;
+}
+
+function bg(t3, e2) {
+    Dp.call(this), this.F = t3, this.u = e2, this.m = void 0, this.readyState = _g, this.status = 0, this.responseType = this.responseText = this.response = this.statusText = "", this.onreadystatechange = null, this.v = new Headers(), this.h = null, this.C = "GET", this.B = "", this.g = false, this.A = this.j = this.l = null;
+}
+Nf(vg, fm), vg.prototype.g = function() {
+    return new bg(this.l, this.j);
+}, vg.prototype.i = function(t3) {
+    return function() {
+        return t3;
+    };
+}({}), Nf(bg, Dp);
+var _g = 0;
+
+function wg(t3) {
+    t3.j.read().then(t3.Xa.bind(t3)).catch(t3.ka.bind(t3));
+}
+
+function xg(t3) {
+    t3.readyState = 4, t3.l = null, t3.j = null, t3.A = null, kg(t3);
+}
+
+function kg(t3) {
+    t3.onreadystatechange && t3.onreadystatechange.call(t3);
+}
+(Sf = bg.prototype).open = function(t3, e2) {
+    if (this.readyState != _g)
+        throw this.abort(), Error("Error reopening a connection");
+    this.C = t3, this.B = e2, this.readyState = 1, kg(this);
+}, Sf.send = function(t3) {
+    if (1 != this.readyState)
+        throw this.abort(), Error("need to call open() first. ");
+    this.g = true;
+    const e2 = {
+        headers: this.v,
+        method: this.C,
+        credentials: this.m,
+        cache: void 0
+    };
+    t3 && (e2.body = t3), (this.F || If).fetch(new Request(this.B, e2)).then(this.$a.bind(this), this.ka.bind(this));
+}, Sf.abort = function() {
+    this.response = this.responseText = "", this.v = new Headers(), this.status = 0, this.j && this.j.cancel("Request was aborted.").catch(() => {}), 1 <= this.readyState && this.g && 4 != this.readyState && (this.g = false, xg(this)), this.readyState = _g;
+}, Sf.$a = function(t3) {
+    if (this.g && (this.l = t3, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = t3.headers, this.readyState = 2, kg(this)), this.g && (this.readyState = 3, kg(this), this.g)))
+        if ("arraybuffer" === this.responseType)
+            t3.arrayBuffer().then(this.Ya.bind(this), this.ka.bind(this));
+        else if (void 0 !== If.ReadableStream && "body" in t3) {
+        if (this.j = t3.body.getReader(), this.u) {
+            if (this.responseType)
+                throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');
+            this.response = [];
+        } else
+            this.response = this.responseText = "", this.A = new TextDecoder();
+        wg(this);
+    } else
+        t3.text().then(this.Za.bind(this), this.ka.bind(this));
+}, Sf.Xa = function(t3) {
+    if (this.g) {
+        if (this.u && t3.value)
+            this.response.push(t3.value);
+        else if (!this.u) {
+            var e2 = t3.value ? t3.value : new Uint8Array(0);
+            (e2 = this.A.decode(e2, {
+                stream: !t3.done
+            })) && (this.response = this.responseText += e2);
+        }
+        t3.done ? xg(this) : kg(this), 3 == this.readyState && wg(this);
+    }
+}, Sf.Za = function(t3) {
+    this.g && (this.response = this.responseText = t3, xg(this));
+}, Sf.Ya = function(t3) {
+    this.g && (this.response = t3, xg(this));
+}, Sf.ka = function() {
+    this.g && xg(this);
+}, Sf.setRequestHeader = function(t3, e2) {
+    this.v.append(t3, e2);
+}, Sf.getResponseHeader = function(t3) {
+    return this.h && this.h.get(t3.toLowerCase()) || "";
+}, Sf.getAllResponseHeaders = function() {
+    if (!this.h)
+        return "";
+    const t3 = [],
+        e2 = this.h.entries();
+    for (var i2 = e2.next(); !i2.done;)
+        i2 = i2.value, t3.push(i2[0] + ": " + i2[1]), i2 = e2.next();
+    return t3.join("\r\n");
+}, Object.defineProperty(bg.prototype, "withCredentials", {
+    get: function() {
+        return "include" === this.m;
+    },
+    set: function(t3) {
+        this.m = t3 ? "include" : "same-origin";
+    }
+});
+var Tg = If.JSON.parse;
+
+function Sg(t3) {
+    Dp.call(this), this.headers = /* @__PURE__ */ new Map(), this.u = t3 || null, this.h = false, this.C = this.g = null, this.I = "", this.m = 0, this.j = "", this.l = this.G = this.v = this.F = false, this.B = 0, this.A = null, this.K = Eg, this.L = this.M = false;
+}
+Nf(Sg, Dp);
+var Eg = "",
+    Cg = /^https?$/i,
+    Ig = ["POST", "PUT"];
+
+function Mg(t3, e2) {
+    t3.h = false, t3.g && (t3.l = true, t3.g.abort(), t3.l = false), t3.j = e2, t3.m = 5, Pg(t3), Ag(t3);
+}
+
+function Pg(t3) {
+    t3.F || (t3.F = true, Lp(t3, "complete"), Lp(t3, "error"));
+}
+
+function Rg(t3) {
+    if (t3.h && void 0 !== Cf && (!t3.C[1] || 4 != Lg(t3) || 2 != t3.da())) {
+        if (t3.v && 4 == Lg(t3))
+            Gp(t3.La, 0, t3);
+        else if (Lp(t3, "readystatechange"), 4 == Lg(t3)) {
+            t3.h = false;
+            try {
+                const o2 = t3.da();
+                t:
+                    switch (o2) {
+                        case 200:
+                        case 201:
+                        case 202:
+                        case 204:
+                        case 206:
+                        case 304:
+                        case 1223:
+                            var e2 = true;
+                            break t;
+                        default:
+                            e2 = false;
+                    }
+                var i2;
+                if (!(i2 = e2)) {
+                    var s2;
+                    if (s2 = 0 === o2) {
+                        var n2 = String(t3.I).match($m)[1] || null;
+                        !n2 && If.self && If.self.location && (n2 = If.self.location.protocol.slice(0, -1)), s2 = !Cg.test(n2 ? n2.toLowerCase() : "");
+                    }
+                    i2 = s2;
+                }
+                if (i2)
+                    Lp(t3, "complete"), Lp(t3, "success");
+                else {
+                    t3.m = 6;
+                    try {
+                        var r2 = 2 < Lg(t3) ? t3.g.statusText : "";
+                    } catch (t4) {
+                        r2 = "";
+                    }
+                    t3.j = r2 + " [" + t3.da() + "]", Pg(t3);
+                }
+            } finally {
+                Ag(t3);
+            }
+        }
+    }
+}
+
+function Ag(t3, e2) {
+    if (t3.g) {
+        Dg(t3);
+        const i2 = t3.g,
+            s2 = t3.C[0] ? () => {} : null;
+        t3.g = null, t3.C = null, e2 || Lp(t3, "ready");
+        try {
+            i2.onreadystatechange = s2;
+        } catch (t4) {}
+    }
+}
+
+function Dg(t3) {
+    t3.g && t3.L && (t3.g.ontimeout = null), t3.A && (If.clearTimeout(t3.A), t3.A = null);
+}
+
+function Lg(t3) {
+    return t3.g ? t3.g.readyState : 0;
+}
+
+function Og(t3) {
+    try {
+        if (!t3.g)
+            return null;
+        if ("response" in t3.g)
+            return t3.g.response;
+        switch (t3.K) {
+            case Eg:
+            case "text":
+                return t3.g.responseText;
+            case "arraybuffer":
+                if ("mozResponseArrayBuffer" in t3.g)
+                    return t3.g.mozResponseArrayBuffer;
+        }
+        return null;
+    } catch (t4) {
+        return null;
+    }
+}
+
+function Fg(t3) {
+    let e2 = "";
+    return pp(t3, function(t4, i2) {
+        e2 += i2, e2 += ":", e2 += t4, e2 += "\r\n";
+    }), e2;
+}
+
+function Ng(t3, e2, i2) {
+    t: {
+        for (s2 in i2) {
+            var s2 = false;
+            break t;
+        }
+        s2 = true;
+    }
+    s2 || (i2 = Fg(i2), "string" == typeof t3 ? null != i2 && encodeURIComponent(String(i2)) : Hm(t3, e2, i2));
+}
+
+function $g(t3, e2, i2) {
+    return i2 && i2.internalChannelParams && i2.internalChannelParams[t3] || e2;
+}
+
+function Vg(t3) {
+    this.Ga = 0, this.j = [], this.l = new tm(), this.pa = this.wa = this.I = this.Y = this.g = this.Da = this.F = this.na = this.o = this.U = this.s = null, this.fb = this.W = 0, this.cb = $g("failFast", false, t3), this.G = this.v = this.u = this.m = this.h = null, this.aa = true, this.Fa = this.V = -1, this.ba = this.A = this.C = 0, this.ab = $g("baseRetryDelayMs", 5e3, t3), this.hb = $g("retryDelaySeedMs", 1e4, t3), this.eb = $g("forwardChannelMaxRetries", 2, t3), this.xa = $g("forwardChannelRequestTimeoutMs", 2e4, t3), this.va = t3 && t3.xmlHttpFactory || void 0, this.Ha = t3 && t3.dc || false, this.L = void 0, this.J = t3 && t3.supportsCrossDomainXhr || false, this.K = "", this.i = new og(t3 && t3.concurrentRequestLimit), this.Ja = new mg(), this.P = t3 && t3.fastHandshake || false, this.O = t3 && t3.encodeInitMessageHeaders || false, this.P && this.O && (this.O = false), this.bb = t3 && t3.bc || false, t3 && t3.Ea && this.l.Ea(), t3 && t3.forceLongPolling && (this.aa = false), this.ca = !this.P && this.aa && t3 && t3.detectBufferingProxy || false, this.qa = void 0, t3 && t3.longPollingTimeout && 0 < t3.longPollingTimeout && (this.qa = t3.longPollingTimeout), this.oa = void 0, this.S = 0, this.M = false, this.ma = this.B = null;
+}
+
+function zg(t3) {
+    if (Ug(t3), 3 == t3.H) {
+        var e2 = t3.W++,
+            i2 = zm(t3.I);
+        if (Hm(i2, "SID", t3.K), Hm(i2, "RID", e2), Hm(i2, "TYPE", "terminate"), Wg(t3, i2), (e2 = new wm(t3, t3.l, e2)).L = 2, e2.v = Wm(zm(i2)), i2 = false, If.navigator && If.navigator.sendBeacon)
+            try {
+                i2 = If.navigator.sendBeacon(e2.v.toString(), "");
+            } catch (t4) {}!i2 && If.Image && (new Image().src = e2.v, i2 = true), i2 || (e2.g = sy(e2.l, null), e2.g.ha(e2.v)), e2.G = Date.now(), Rm(e2);
+    }
+    ey(t3);
+}
+
+function Bg(t3) {
+    t3.g && (Yg(t3), t3.g.cancel(), t3.g = null);
+}
+
+function Ug(t3) {
+    Bg(t3), t3.u && (If.clearTimeout(t3.u), t3.u = null), Xg(t3), t3.i.cancel(), t3.m && ("number" == typeof t3.m && If.clearTimeout(t3.m), t3.m = null);
+}
+
+function jg(t3) {
+    if (!lg(t3.i) && !t3.m) {
+        t3.m = true;
+        var e2 = t3.Na;
+        Bp || Hp(), Up || (Bp(), Up = true), jp.add(e2, t3), t3.C = 0;
+    }
+}
+
+function Hg(t3, e2) {
+    var i2;
+    i2 = e2 ? e2.m : t3.W++;
+    const s2 = zm(t3.I);
+    Hm(s2, "SID", t3.K), Hm(s2, "RID", i2), Hm(s2, "AID", t3.V), Wg(t3, s2), t3.o && t3.s && Ng(s2, t3.o, t3.s), i2 = new wm(t3, t3.l, i2, t3.C + 1), null === t3.o && (i2.I = t3.s), e2 && (t3.j = e2.F.concat(t3.j)), e2 = qg(t3, i2, 1e3), i2.setTimeout(Math.round(0.5 * t3.xa) + Math.round(0.5 * t3.xa * Math.random())), ug(t3.i, i2), Em(i2, s2, e2);
+}
+
+function Wg(t3, e2) {
+    t3.na && pp(t3.na, function(t4, i2) {
+        Hm(e2, i2, t4);
+    }), t3.h && Nm({}, function(t4, i2) {
+        Hm(e2, i2, t4);
+    });
+}
+
+function qg(t3, e2, i2) {
+    i2 = Math.min(t3.j.length, i2);
+    var s2 = t3.h ? Of(t3.h.Va, t3.h, t3) : null;
+    t: {
+        var n2 = t3.j;
+        let e3 = -1;
+        for (;;) {
+            const t4 = ["count=" + i2]; -
+            1 == e3 ? 0 < i2 ? (e3 = n2[0].g, t4.push("ofs=" + e3)) : e3 = 0 : t4.push("ofs=" + e3);
+            let r2 = true;
+            for (let o2 = 0; o2 < i2; o2++) {
+                let i3 = n2[o2].g;
+                const a2 = n2[o2].map;
+                if (i3 -= e3, 0 > i3)
+                    e3 = Math.max(0, n2[o2].g - 100), r2 = false;
+                else
+                    try {
+                        gg(a2, t4, "req" + i3 + "_");
+                    } catch (t5) {
+                        s2 && s2(a2);
+                    }
+            }
+            if (r2) {
+                s2 = t4.join("&");
+                break t;
+            }
+        }
+    }
+    return t3 = t3.j.splice(0, i2), e2.F = t3, s2;
+}
+
+function Kg(t3) {
+    if (!t3.g && !t3.u) {
+        t3.ba = 1;
+        var e2 = t3.Ma;
+        Bp || Hp(), Up || (Bp(), Up = true), jp.add(e2, t3), t3.A = 0;
+    }
+}
+
+function Gg(t3) {
+    return !(t3.g || t3.u || 3 <= t3.A) && (t3.ba++, t3.u = cm(Of(t3.Ma, t3), Zg(t3, t3.A)), t3.A++, true);
+}
+
+function Yg(t3) {
+    null != t3.B && (If.clearTimeout(t3.B), t3.B = null);
+}
+
+function Qg(t3) {
+    t3.g = new wm(t3, t3.l, "rpc", t3.ba), null === t3.o && (t3.g.I = t3.s), t3.g.O = 0;
+    var e2 = zm(t3.wa);
+    Hm(e2, "RID", "rpc"), Hm(e2, "SID", t3.K), Hm(e2, "AID", t3.V), Hm(e2, "CI", t3.G ? "0" : "1"), !t3.G && t3.qa && Hm(e2, "TO", t3.qa), Hm(e2, "TYPE", "xmlhttp"), Wg(t3, e2), t3.o && t3.s && Ng(e2, t3.o, t3.s), t3.L && t3.g.setTimeout(t3.L);
+    var i2 = t3.g;
+    t3 = t3.pa, i2.L = 1, i2.v = Wm(zm(e2)), i2.s = null, i2.S = true, Cm(i2, t3);
+}
+
+function Xg(t3) {
+    null != t3.v && (If.clearTimeout(t3.v), t3.v = null);
+}
+
+function Jg(t3, e2) {
+    var i2 = null;
+    if (t3.g == e2) {
+        Xg(t3), Yg(t3), t3.g = null;
+        var s2 = 2;
+    } else {
+        if (!cg(t3.i, e2))
+            return;
+        i2 = e2.F, dg(t3.i, e2), s2 = 1;
+    }
+    if (0 != t3.H) {
+        if (e2.i)
+            if (1 == s2) {
+                i2 = e2.s ? e2.s.length : 0, e2 = Date.now() - e2.G;
+                var n2 = t3.C;
+                Lp(s2 = nm(), new hm(s2, i2)), jg(t3);
+            } else
+                Kg(t3);
+        else if (3 == (n2 = e2.o) || 0 == n2 && 0 < e2.ca || !(1 == s2 && function(t4, e3) {
+                return !(hg(t4.i) >= t4.i.j - (t4.m ? 1 : 0) || (t4.m ? (t4.j = e3.F.concat(t4.j), 0) : 1 == t4.H || 2 == t4.H || t4.C >= (t4.cb ? 0 : t4.eb) || (t4.m = cm(Of(t4.Na, t4, e3), Zg(t4, t4.C)), t4.C++, 0)));
+            }(t3, e2) || 2 == s2 && Gg(t3)))
+            switch (i2 && 0 < i2.length && (e2 = t3.i, e2.i = e2.i.concat(i2)), n2) {
+                case 1:
+                    ty(t3, 5);
+                    break;
+                case 4:
+                    ty(t3, 10);
+                    break;
+                case 3:
+                    ty(t3, 6);
+                    break;
+                default:
+                    ty(t3, 2);
+            }
+    }
+}
+
+function Zg(t3, e2) {
+    let i2 = t3.ab + Math.floor(Math.random() * t3.hb);
+    return t3.isActive() || (i2 *= 2), i2 * e2;
+}
+
+function ty(t3, e2) {
+    if (t3.l.info("Error code " + e2), 2 == e2) {
+        var i2 = null;
+        t3.h && (i2 = null);
+        var s2 = Of(t3.pb, t3);
+        i2 || (i2 = new Vm("//www.google.com/images/cleardot.gif"), If.location && "http" == If.location.protocol || Bm(i2, "https"), Wm(i2)),
+            function(t4, e3) {
+                const i3 = new tm();
+                if (If.Image) {
+                    const s3 = new Image();
+                    s3.onload = Ff(yg, i3, s3, "TestLoadImage: loaded", true, e3), s3.onerror = Ff(yg, i3, s3, "TestLoadImage: error", false, e3), s3.onabort = Ff(yg, i3, s3, "TestLoadImage: abort", false, e3), s3.ontimeout = Ff(yg, i3, s3, "TestLoadImage: timeout", false, e3), If.setTimeout(function() {
+                        s3.ontimeout && s3.ontimeout();
+                    }, 1e4), s3.src = t4;
+                } else
+                    e3(false);
+            }(i2.toString(), s2);
+    } else
+        lm(2);
+    t3.H = 0, t3.h && t3.h.za(e2), ey(t3), Ug(t3);
+}
+
+function ey(t3) {
+    if (t3.H = 0, t3.ma = [], t3.h) {
+        const e2 = fg(t3.i);
+        0 == e2.length && 0 == t3.j.length || (Bf(t3.ma, e2), Bf(t3.ma, t3.j), t3.i.i.length = 0, zf(t3.j), t3.j.length = 0), t3.h.ya();
+    }
+}
+
+function iy(t3, e2, i2) {
+    var s2 = i2 instanceof Vm ? zm(i2) : new Vm(i2);
+    if ("" != s2.g)
+        e2 && (s2.g = e2 + "." + s2.g), Um(s2, s2.m);
+    else {
+        var n2 = If.location;
+        s2 = n2.protocol, e2 = e2 ? e2 + "." + n2.hostname : n2.hostname, n2 = +n2.port;
+        var r2 = new Vm(null);
+        s2 && Bm(r2, s2), e2 && (r2.g = e2), n2 && Um(r2, n2), i2 && (r2.l = i2), s2 = r2;
+    }
+    return i2 = t3.F, e2 = t3.Da, i2 && e2 && Hm(s2, i2, e2), Hm(s2, "VER", t3.ra), Wg(t3, s2), s2;
+}
+
+function sy(t3, e2, i2) {
+    if (e2 && !t3.J)
+        throw Error("Can't create secondary domain capable XhrIo object.");
+    return (e2 = i2 && t3.Ha && !t3.va ? new Sg(new vg({
+        ob: true
+    })) : new Sg(t3.va)).Oa(t3.J), e2;
+}
+
+function ny() {}
+
+function ry() {
+    if (Xf && !(10 <= Number(ap)))
+        throw Error("Environmental error: no available transport.");
+}
+
+function oy(t3, e2) {
+    Dp.call(this), this.g = new Vg(e2), this.l = t3, this.h = e2 && e2.messageUrlParams || null, t3 = e2 && e2.messageHeaders || null, e2 && e2.clientProtocolHeaderRequired && (t3 ? t3["X-Client-Protocol"] = "webchannel" : t3 = {
+        "X-Client-Protocol": "webchannel"
+    }), this.g.s = t3, t3 = e2 && e2.initMessageHeaders || null, e2 && e2.messageContentType && (t3 ? t3["X-WebChannel-Content-Type"] = e2.messageContentType : t3 = {
+        "X-WebChannel-Content-Type": e2.messageContentType
+    }), e2 && e2.Ca && (t3 ? t3["X-WebChannel-Client-Profile"] = e2.Ca : t3 = {
+        "X-WebChannel-Client-Profile": e2.Ca
+    }), this.g.U = t3, (t3 = e2 && e2.cc) && !Hf(t3) && (this.g.o = t3), this.A = e2 && e2.supportsCrossDomainXhr || false, this.v = e2 && e2.sendRawJson || false, (e2 = e2 && e2.httpSessionIdParam) && !Hf(e2) && (this.g.F = e2, null !== (t3 = this.h) && e2 in t3 && (e2 in (t3 = this.h) && delete t3[e2])), this.j = new hy(this);
+}
+
+function ay(t3) {
+    vm.call(this), t3.__headers__ && (this.headers = t3.__headers__, this.statusCode = t3.__status__, delete t3.__headers__, delete t3.__status__);
+    var e2 = t3.__sm__;
+    if (e2) {
+        t: {
+            for (const i2 in e2) {
+                t3 = i2;
+                break t;
+            }
+            t3 = void 0;
+        }
+        (this.i = t3) && (t3 = this.i, e2 = null !== e2 && t3 in e2 ? e2[t3] : void 0),
+        this.data = e2;
+    }
+    else
+        this.data = t3;
+}
+
+function ly() {
+    bm.call(this), this.status = 1;
+}
+
+function hy(t3) {
+    this.g = t3;
+}
+
+function cy() {
+    this.blockSize = -1, this.blockSize = 64, this.g = Array(4), this.m = Array(this.blockSize), this.i = this.h = 0, this.reset();
+}
+
+function uy(t3, e2, i2) {
+    i2 || (i2 = 0);
+    var s2 = Array(16);
+    if ("string" == typeof e2)
+        for (var n2 = 0; 16 > n2; ++n2)
+            s2[n2] = e2.charCodeAt(i2++) | e2.charCodeAt(i2++) << 8 | e2.charCodeAt(i2++) << 16 | e2.charCodeAt(i2++) << 24;
+    else
+        for (n2 = 0; 16 > n2; ++n2)
+            s2[n2] = e2[i2++] | e2[i2++] << 8 | e2[i2++] << 16 | e2[i2++] << 24;
+    e2 = t3.g[0], i2 = t3.g[1], n2 = t3.g[2];
+    var r2 = t3.g[3],
+        o2 = e2 + (r2 ^ i2 & (n2 ^ r2)) + s2[0] + 3614090360 & 4294967295;
+    o2 = (i2 = (n2 = (r2 = (e2 = (i2 = (n2 = (r2 = (e2 = (i2 = (n2 = (r2 = (e2 = (i2 = (n2 = (r2 = (e2 = (i2 = (n2 = (r2 = (e2 = (i2 = (n2 = (r2 = (e2 = (i2 = (n2 = (r2 = (e2 = (i2 = (n2 = (r2 = (e2 = (i2 = (n2 = (r2 = (e2 = (i2 = (n2 = (r2 = (e2 = (i2 = (n2 = (r2 = (e2 = (i2 = (n2 = (r2 = (e2 = (i2 = (n2 = (r2 = (e2 = (i2 = (n2 = (r2 = (e2 = (i2 = (n2 = (r2 = (e2 = i2 + (o2 << 7 & 4294967295 | o2 >>> 25)) + ((o2 = r2 + (n2 ^ e2 & (i2 ^ n2)) + s2[1] + 3905402710 & 4294967295) << 12 & 4294967295 | o2 >>> 20)) + ((o2 = n2 + (i2 ^ r2 & (e2 ^ i2)) + s2[2] + 606105819 & 4294967295) << 17 & 4294967295 | o2 >>> 15)) + ((o2 = i2 + (e2 ^ n2 & (r2 ^ e2)) + s2[3] + 3250441966 & 4294967295) << 22 & 4294967295 | o2 >>> 10)) + ((o2 = e2 + (r2 ^ i2 & (n2 ^ r2)) + s2[4] + 4118548399 & 4294967295) << 7 & 4294967295 | o2 >>> 25)) + ((o2 = r2 + (n2 ^ e2 & (i2 ^ n2)) + s2[5] + 1200080426 & 4294967295) << 12 & 4294967295 | o2 >>> 20)) + ((o2 = n2 + (i2 ^ r2 & (e2 ^ i2)) + s2[6] + 2821735955 & 4294967295) << 17 & 4294967295 | o2 >>> 15)) + ((o2 = i2 + (e2 ^ n2 & (r2 ^ e2)) + s2[7] + 4249261313 & 4294967295) << 22 & 4294967295 | o2 >>> 10)) + ((o2 = e2 + (r2 ^ i2 & (n2 ^ r2)) + s2[8] + 1770035416 & 4294967295) << 7 & 4294967295 | o2 >>> 25)) + ((o2 = r2 + (n2 ^ e2 & (i2 ^ n2)) + s2[9] + 2336552879 & 4294967295) << 12 & 4294967295 | o2 >>> 20)) + ((o2 = n2 + (i2 ^ r2 & (e2 ^ i2)) + s2[10] + 4294925233 & 4294967295) << 17 & 4294967295 | o2 >>> 15)) + ((o2 = i2 + (e2 ^ n2 & (r2 ^ e2)) + s2[11] + 2304563134 & 4294967295) << 22 & 4294967295 | o2 >>> 10)) + ((o2 = e2 + (r2 ^ i2 & (n2 ^ r2)) + s2[12] + 1804603682 & 4294967295) << 7 & 4294967295 | o2 >>> 25)) + ((o2 = r2 + (n2 ^ e2 & (i2 ^ n2)) + s2[13] + 4254626195 & 4294967295) << 12 & 4294967295 | o2 >>> 20)) + ((o2 = n2 + (i2 ^ r2 & (e2 ^ i2)) + s2[14] + 2792965006 & 4294967295) << 17 & 4294967295 | o2 >>> 15)) + ((o2 = i2 + (e2 ^ n2 & (r2 ^ e2)) + s2[15] + 1236535329 & 4294967295) << 22 & 4294967295 | o2 >>> 10)) + ((o2 = e2 + (n2 ^ r2 & (i2 ^ n2)) + s2[1] + 4129170786 & 4294967295) << 5 & 4294967295 | o2 >>> 27)) + ((o2 = r2 + (i2 ^ n2 & (e2 ^ i2)) + s2[6] + 3225465664 & 4294967295) << 9 & 4294967295 | o2 >>> 23)) + ((o2 = n2 + (e2 ^ i2 & (r2 ^ e2)) + s2[11] + 643717713 & 4294967295) << 14 & 4294967295 | o2 >>> 18)) + ((o2 = i2 + (r2 ^ e2 & (n2 ^ r2)) + s2[0] + 3921069994 & 4294967295) << 20 & 4294967295 | o2 >>> 12)) + ((o2 = e2 + (n2 ^ r2 & (i2 ^ n2)) + s2[5] + 3593408605 & 4294967295) << 5 & 4294967295 | o2 >>> 27)) + ((o2 = r2 + (i2 ^ n2 & (e2 ^ i2)) + s2[10] + 38016083 & 4294967295) << 9 & 4294967295 | o2 >>> 23)) + ((o2 = n2 + (e2 ^ i2 & (r2 ^ e2)) + s2[15] + 3634488961 & 4294967295) << 14 & 4294967295 | o2 >>> 18)) + ((o2 = i2 + (r2 ^ e2 & (n2 ^ r2)) + s2[4] + 3889429448 & 4294967295) << 20 & 4294967295 | o2 >>> 12)) + ((o2 = e2 + (n2 ^ r2 & (i2 ^ n2)) + s2[9] + 568446438 & 4294967295) << 5 & 4294967295 | o2 >>> 27)) + ((o2 = r2 + (i2 ^ n2 & (e2 ^ i2)) + s2[14] + 3275163606 & 4294967295) << 9 & 4294967295 | o2 >>> 23)) + ((o2 = n2 + (e2 ^ i2 & (r2 ^ e2)) + s2[3] + 4107603335 & 4294967295) << 14 & 4294967295 | o2 >>> 18)) + ((o2 = i2 + (r2 ^ e2 & (n2 ^ r2)) + s2[8] + 1163531501 & 4294967295) << 20 & 4294967295 | o2 >>> 12)) + ((o2 = e2 + (n2 ^ r2 & (i2 ^ n2)) + s2[13] + 2850285829 & 4294967295) << 5 & 4294967295 | o2 >>> 27)) + ((o2 = r2 + (i2 ^ n2 & (e2 ^ i2)) + s2[2] + 4243563512 & 4294967295) << 9 & 4294967295 | o2 >>> 23)) + ((o2 = n2 + (e2 ^ i2 & (r2 ^ e2)) + s2[7] + 1735328473 & 4294967295) << 14 & 4294967295 | o2 >>> 18)) + ((o2 = i2 + (r2 ^ e2 & (n2 ^ r2)) + s2[12] + 2368359562 & 4294967295) << 20 & 4294967295 | o2 >>> 12)) + ((o2 = e2 + (i2 ^ n2 ^ r2) + s2[5] + 4294588738 & 4294967295) << 4 & 4294967295 | o2 >>> 28)) + ((o2 = r2 + (e2 ^ i2 ^ n2) + s2[8] + 2272392833 & 4294967295) << 11 & 4294967295 | o2 >>> 21)) + ((o2 = n2 + (r2 ^ e2 ^ i2) + s2[11] + 1839030562 & 4294967295) << 16 & 4294967295 | o2 >>> 16)) + ((o2 = i2 + (n2 ^ r2 ^ e2) + s2[14] + 4259657740 & 4294967295) << 23 & 4294967295 | o2 >>> 9)) + ((o2 = e2 + (i2 ^ n2 ^ r2) + s2[1] + 2763975236 & 4294967295) << 4 & 4294967295 | o2 >>> 28)) + ((o2 = r2 + (e2 ^ i2 ^ n2) + s2[4] + 1272893353 & 4294967295) << 11 & 4294967295 | o2 >>> 21)) + ((o2 = n2 + (r2 ^ e2 ^ i2) + s2[7] + 4139469664 & 4294967295) << 16 & 4294967295 | o2 >>> 16)) + ((o2 = i2 + (n2 ^ r2 ^ e2) + s2[10] + 3200236656 & 4294967295) << 23 & 4294967295 | o2 >>> 9)) + ((o2 = e2 + (i2 ^ n2 ^ r2) + s2[13] + 681279174 & 4294967295) << 4 & 4294967295 | o2 >>> 28)) + ((o2 = r2 + (e2 ^ i2 ^ n2) + s2[0] + 3936430074 & 4294967295) << 11 & 4294967295 | o2 >>> 21)) + ((o2 = n2 + (r2 ^ e2 ^ i2) + s2[3] + 3572445317 & 4294967295) << 16 & 4294967295 | o2 >>> 16)) + ((o2 = i2 + (n2 ^ r2 ^ e2) + s2[6] + 76029189 & 4294967295) << 23 & 4294967295 | o2 >>> 9)) + ((o2 = e2 + (i2 ^ n2 ^ r2) + s2[9] + 3654602809 & 4294967295) << 4 & 4294967295 | o2 >>> 28)) + ((o2 = r2 + (e2 ^ i2 ^ n2) + s2[12] + 3873151461 & 4294967295) << 11 & 4294967295 | o2 >>> 21)) + ((o2 = n2 + (r2 ^ e2 ^ i2) + s2[15] + 530742520 & 4294967295) << 16 & 4294967295 | o2 >>> 16)) + ((o2 = i2 + (n2 ^ r2 ^ e2) + s2[2] + 3299628645 & 4294967295) << 23 & 4294967295 | o2 >>> 9)) + ((o2 = e2 + (n2 ^ (i2 | ~r2)) + s2[0] + 4096336452 & 4294967295) << 6 & 4294967295 | o2 >>> 26)) + ((o2 = r2 + (i2 ^ (e2 | ~n2)) + s2[7] + 1126891415 & 4294967295) << 10 & 4294967295 | o2 >>> 22)) + ((o2 = n2 + (e2 ^ (r2 | ~i2)) + s2[14] + 2878612391 & 4294967295) << 15 & 4294967295 | o2 >>> 17)) + ((o2 = i2 + (r2 ^ (n2 | ~e2)) + s2[5] + 4237533241 & 4294967295) << 21 & 4294967295 | o2 >>> 11)) + ((o2 = e2 + (n2 ^ (i2 | ~r2)) + s2[12] + 1700485571 & 4294967295) << 6 & 4294967295 | o2 >>> 26)) + ((o2 = r2 + (i2 ^ (e2 | ~n2)) + s2[3] + 2399980690 & 4294967295) << 10 & 4294967295 | o2 >>> 22)) + ((o2 = n2 + (e2 ^ (r2 | ~i2)) + s2[10] + 4293915773 & 4294967295) << 15 & 4294967295 | o2 >>> 17)) + ((o2 = i2 + (r2 ^ (n2 | ~e2)) + s2[1] + 2240044497 & 4294967295) << 21 & 4294967295 | o2 >>> 11)) + ((o2 = e2 + (n2 ^ (i2 | ~r2)) + s2[8] + 1873313359 & 4294967295) << 6 & 4294967295 | o2 >>> 26)) + ((o2 = r2 + (i2 ^ (e2 | ~n2)) + s2[15] + 4264355552 & 4294967295) << 10 & 4294967295 | o2 >>> 22)) + ((o2 = n2 + (e2 ^ (r2 | ~i2)) + s2[6] + 2734768916 & 4294967295) << 15 & 4294967295 | o2 >>> 17)) + ((o2 = i2 + (r2 ^ (n2 | ~e2)) + s2[13] + 1309151649 & 4294967295) << 21 & 4294967295 | o2 >>> 11)) + ((r2 = (e2 = i2 + ((o2 = e2 + (n2 ^ (i2 | ~r2)) + s2[4] + 4149444226 & 4294967295) << 6 & 4294967295 | o2 >>> 26)) + ((o2 = r2 + (i2 ^ (e2 | ~n2)) + s2[11] + 3174756917 & 4294967295) << 10 & 4294967295 | o2 >>> 22)) ^ ((n2 = r2 + ((o2 = n2 + (e2 ^ (r2 | ~i2)) + s2[2] + 718787259 & 4294967295) << 15 & 4294967295 | o2 >>> 17)) | ~e2)) + s2[9] + 3951481745 & 4294967295, t3.g[0] = t3.g[0] + e2 & 4294967295, t3.g[1] = t3.g[1] + (n2 + (o2 << 21 & 4294967295 | o2 >>> 11)) & 4294967295, t3.g[2] = t3.g[2] + n2 & 4294967295, t3.g[3] = t3.g[3] + r2 & 4294967295;
+}
+
+function dy(t3, e2) {
+    this.h = e2;
+    for (var i2 = [], s2 = true, n2 = t3.length - 1; 0 <= n2; n2--) {
+        var r2 = 0 | t3[n2];
+        s2 && r2 == e2 || (i2[n2] = r2, s2 = false);
+    }
+    this.g = i2;
+}
+(Sf = Sg.prototype).Oa = function(t3) {
+    this.M = t3;
+}, Sf.ha = function(t3, e2, i2, s2) {
+    if (this.g)
+        throw Error("[goog.net.XhrIo] Object is active with another request=" + this.I + "; newUri=" + t3);
+    e2 = e2 ? e2.toUpperCase() : "GET", this.I = t3, this.j = "", this.m = 0, this.F = false, this.h = true, this.g = this.u ? this.u.g() : gm.g(), this.C = this.u ? pm(this.u) : pm(gm), this.g.onreadystatechange = Of(this.La, this);
+    try {
+        this.G = true, this.g.open(e2, String(t3), true), this.G = false;
+    } catch (t4) {
+        return void Mg(this, t4);
+    }
+    if (t3 = i2 || "", i2 = new Map(this.headers), s2)
+        if (Object.getPrototypeOf(s2) === Object.prototype)
+            for (var n2 in s2)
+                i2.set(n2, s2[n2]);
+        else {
+            if ("function" != typeof s2.keys || "function" != typeof s2.get)
+                throw Error("Unknown input type for opt_headers: " + String(s2));
+            for (const t4 of s2.keys())
+                i2.set(t4, s2.get(t4));
+        }
+    s2 = Array.from(i2.keys()).find((t4) => "content-type" == t4.toLowerCase()), n2 = If.FormData && t3 instanceof If.FormData, !(0 <= Vf(Ig, e2)) || s2 || n2 || i2.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
+    for (const [t4, e3] of i2)
+        this.g.setRequestHeader(t4, e3);
+    this.K && (this.g.responseType = this.K), "withCredentials" in this.g && this.g.withCredentials !== this.M && (this.g.withCredentials = this.M);
+    try {
+        Dg(this), 0 < this.B && ((this.L = function(t4) {
+            return Xf && "number" == typeof t4.timeout && void 0 !== t4.ontimeout;
+        }(this.g)) ? (this.g.timeout = this.B, this.g.ontimeout = Of(this.ua, this)) : this.A = Gp(this.ua, this.B, this)), this.v = true, this.g.send(t3), this.v = false;
+    } catch (t4) {
+        Mg(this, t4);
+    }
+}, Sf.ua = function() {
+    void 0 !== Cf && this.g && (this.j = "Timed out after " + this.B + "ms, aborting", this.m = 8, Lp(this, "timeout"), this.abort(8));
+}, Sf.abort = function(t3) {
+    this.g && this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false, this.m = t3 || 7, Lp(this, "complete"), Lp(this, "abort"), Ag(this));
+}, Sf.N = function() {
+    this.g && (this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false), Ag(this, true)), Sg.$.N.call(this);
+}, Sf.La = function() {
+    this.s || (this.G || this.v || this.l ? Rg(this) : this.kb());
+}, Sf.kb = function() {
+    Rg(this);
+}, Sf.isActive = function() {
+    return !!this.g;
+}, Sf.da = function() {
+    try {
+        return 2 < Lg(this) ? this.g.status : -1;
+    } catch (t3) {
+        return -1;
+    }
+}, Sf.ja = function() {
+    try {
+        return this.g ? this.g.responseText : "";
+    } catch (t3) {
+        return "";
+    }
+}, Sf.Wa = function(t3) {
+    if (this.g) {
+        var e2 = this.g.responseText;
+        return t3 && 0 == e2.indexOf(t3) && (e2 = e2.substring(t3.length)), Tg(e2);
+    }
+}, Sf.Ia = function() {
+    return this.m;
+}, Sf.Sa = function() {
+    return "string" == typeof this.j ? this.j : String(this.j);
+}, (Sf = Vg.prototype).ra = 8, Sf.H = 1, Sf.Na = function(t3) {
+    if (this.m)
+        if (this.m = null, 1 == this.H) {
+            if (!t3) {
+                this.W = Math.floor(1e5 * Math.random()), t3 = this.W++;
+                const n2 = new wm(this, this.l, t3);
+                let r2 = this.s;
+                if (this.U && (r2 ? (r2 = mp(r2), yp(r2, this.U)) : r2 = this.U), null !== this.o || this.O || (n2.I = r2, r2 = null), this.P)
+                    t: {
+                        for (var e2 = 0, i2 = 0; i2 < this.j.length; i2++) {
+                            var s2 = this.j[i2];
+                            if (void 0 === (s2 = "__data__" in s2.map && "string" == typeof(s2 = s2.map.__data__) ? s2.length : void 0))
+                                break;
+                            if (4096 < (e2 += s2)) {
+                                e2 = i2;
+                                break t;
+                            }
+                            if (4096 === e2 || i2 === this.j.length - 1) {
+                                e2 = i2 + 1;
+                                break t;
+                            }
+                        }
+                        e2 = 1e3;
+                    }
+                else
+                    e2 = 1e3;
+                e2 = qg(this, n2, e2), Hm(i2 = zm(this.I), "RID", t3), Hm(i2, "CVER", 22), this.F && Hm(i2, "X-HTTP-Session-Id", this.F), Wg(this, i2), r2 && (this.O ? e2 = "headers=" + encodeURIComponent(String(Fg(r2))) + "&" + e2 : this.o && Ng(i2, this.o, r2)), ug(this.i, n2), this.bb && Hm(i2, "TYPE", "init"), this.P ? (Hm(i2, "$req", e2), Hm(i2, "SID", "null"), n2.aa = true, Em(n2, i2, null)) : Em(n2, i2, e2), this.H = 2;
+            }
+        } else
+            3 == this.H && (t3 ? Hg(this, t3) : 0 == this.j.length || lg(this.i) || Hg(this));
+}, Sf.Ma = function() {
+    if (this.u = null, Qg(this), this.ca && !(this.M || null == this.g || 0 >= this.S)) {
+        var t3 = 2 * this.S;
+        this.l.info("BP detection timer enabled: " + t3), this.B = cm(Of(this.jb, this), t3);
+    }
+}, Sf.jb = function() {
+    this.B && (this.B = null, this.l.info("BP detection timeout reached."), this.l.info("Buffering proxy detected and switch to long-polling!"), this.G = false, this.M = true, lm(10), Bg(this), Qg(this));
+}, Sf.ib = function() {
+    null != this.v && (this.v = null, Bg(this), Gg(this), lm(19));
+}, Sf.pb = function(t3) {
+    t3 ? (this.l.info("Successfully pinged google.com"), lm(2)) : (this.l.info("Failed to ping google.com"), lm(1));
+}, Sf.isActive = function() {
+    return !!this.h && this.h.isActive(this);
+}, (Sf = ny.prototype).Ba = function() {}, Sf.Aa = function() {}, Sf.za = function() {}, Sf.ya = function() {}, Sf.isActive = function() {
+    return true;
+}, Sf.Va = function() {}, ry.prototype.g = function(t3, e2) {
+    return new oy(t3, e2);
+}, Nf(oy, Dp), oy.prototype.m = function() {
+    this.g.h = this.j, this.A && (this.g.J = true);
+    var t3 = this.g,
+        e2 = this.l,
+        i2 = this.h || void 0;
+    lm(0), t3.Y = e2, t3.na = i2 || {}, t3.G = t3.aa, t3.I = iy(t3, null, t3.Y), jg(t3);
+}, oy.prototype.close = function() {
+    zg(this.g);
+}, oy.prototype.u = function(t3) {
+    var e2 = this.g;
+    if ("string" == typeof t3) {
+        var i2 = {};
+        i2.__data__ = t3, t3 = i2;
+    } else
+        this.v && ((i2 = {}).__data__ = Fp(t3), t3 = i2);
+    e2.j.push(new class {
+        constructor(t4, e3) {
+            this.g = t4, this.map = e3;
+        }
+    }(e2.fb++, t3)), 3 == e2.H && jg(e2);
+}, oy.prototype.N = function() {
+    this.g.h = null, delete this.j, zg(this.g), delete this.g, oy.$.N.call(this);
+}, Nf(ay, vm), Nf(ly, bm), Nf(hy, ny), hy.prototype.Ba = function() {
+    Lp(this.g, "a");
+}, hy.prototype.Aa = function(t3) {
+    Lp(this.g, new ay(t3));
+}, hy.prototype.za = function(t3) {
+    Lp(this.g, new ly());
+}, hy.prototype.ya = function() {
+    Lp(this.g, "b");
+}, Nf(cy, function() {
+    this.blockSize = -1;
+}), cy.prototype.reset = function() {
+    this.g[0] = 1732584193, this.g[1] = 4023233417, this.g[2] = 2562383102, this.g[3] = 271733878, this.i = this.h = 0;
+}, cy.prototype.j = function(t3, e2) {
+    void 0 === e2 && (e2 = t3.length);
+    for (var i2 = e2 - this.blockSize, s2 = this.m, n2 = this.h, r2 = 0; r2 < e2;) {
+        if (0 == n2)
+            for (; r2 <= i2;)
+                uy(this, t3, r2), r2 += this.blockSize;
+        if ("string" == typeof t3) {
+            for (; r2 < e2;)
+                if (s2[n2++] = t3.charCodeAt(r2++), n2 == this.blockSize) {
+                    uy(this, s2), n2 = 0;
+                    break;
+                }
+        } else
+            for (; r2 < e2;)
+                if (s2[n2++] = t3[r2++], n2 == this.blockSize) {
+                    uy(this, s2), n2 = 0;
+                    break;
+                }
+    }
+    this.h = n2, this.i += e2;
+}, cy.prototype.l = function() {
+    var t3 = Array((56 > this.h ? this.blockSize : 2 * this.blockSize) - this.h);
+    t3[0] = 128;
+    for (var e2 = 1; e2 < t3.length - 8; ++e2)
+        t3[e2] = 0;
+    var i2 = 8 * this.i;
+    for (e2 = t3.length - 8; e2 < t3.length; ++e2)
+        t3[e2] = 255 & i2, i2 /= 256;
+    for (this.j(t3), t3 = Array(16), e2 = i2 = 0; 4 > e2; ++e2)
+        for (var s2 = 0; 32 > s2; s2 += 8)
+            t3[i2++] = this.g[e2] >>> s2 & 255;
+    return t3;
+};
+var fy = {};
+
+function py(t3) {
+    return -128 <= t3 && 128 > t3 ? function(t4, e2) {
+        var i2 = fy;
+        return Object.prototype.hasOwnProperty.call(i2, t4) ? i2[t4] : i2[t4] = e2(t4);
+    }(t3, function(t4) {
+        return new dy([0 | t4], 0 > t4 ? -1 : 0);
+    }) : new dy([0 | t3], 0 > t3 ? -1 : 0);
+}
+
+function my(t3) {
+    if (isNaN(t3) || !isFinite(t3))
+        return yy;
+    if (0 > t3)
+        return xy(my(-t3));
+    for (var e2 = [], i2 = 1, s2 = 0; t3 >= i2; s2++)
+        e2[s2] = t3 / i2 | 0, i2 *= gy;
+    return new dy(e2, 0);
+}
+var gy = 4294967296,
+    yy = py(0),
+    vy = py(1),
+    by = py(16777216);
+
+function _y(t3) {
+    if (0 != t3.h)
+        return false;
+    for (var e2 = 0; e2 < t3.g.length; e2++)
+        if (0 != t3.g[e2])
+            return false;
+    return true;
+}
+
+function wy(t3) {
+    return -1 == t3.h;
+}
+
+function xy(t3) {
+    for (var e2 = t3.g.length, i2 = [], s2 = 0; s2 < e2; s2++)
+        i2[s2] = ~t3.g[s2];
+    return new dy(i2, ~t3.h).add(vy);
+}
+
+function ky(t3, e2) {
+    return t3.add(xy(e2));
+}
+
+function Ty(t3, e2) {
+    for (;
+        (65535 & t3[e2]) != t3[e2];)
+        t3[e2 + 1] += t3[e2] >>> 16, t3[e2] &= 65535, e2++;
+}
+
+function Sy(t3, e2) {
+    this.g = t3, this.h = e2;
+}
+
+function Ey(t3, e2) {
+    if (_y(e2))
+        throw Error("division by zero");
+    if (_y(t3))
+        return new Sy(yy, yy);
+    if (wy(t3))
+        return e2 = Ey(xy(t3), e2), new Sy(xy(e2.g), xy(e2.h));
+    if (wy(e2))
+        return e2 = Ey(t3, xy(e2)), new Sy(xy(e2.g), e2.h);
+    if (30 < t3.g.length) {
+        if (wy(t3) || wy(e2))
+            throw Error("slowDivide_ only works with positive integers.");
+        for (var i2 = vy, s2 = e2; 0 >= s2.X(t3);)
+            i2 = Cy(i2), s2 = Cy(s2);
+        var n2 = Iy(i2, 1),
+            r2 = Iy(s2, 1);
+        for (s2 = Iy(s2, 2), i2 = Iy(i2, 2); !_y(s2);) {
+            var o2 = r2.add(s2);
+            0 >= o2.X(t3) && (n2 = n2.add(i2), r2 = o2), s2 = Iy(s2, 1), i2 = Iy(i2, 1);
+        }
+        return e2 = ky(t3, n2.R(e2)), new Sy(n2, e2);
+    }
+    for (n2 = yy; 0 <= t3.X(e2);) {
+        for (i2 = Math.max(1, Math.floor(t3.ea() / e2.ea())), s2 = 48 >= (s2 = Math.ceil(Math.log(i2) / Math.LN2)) ? 1 : Math.pow(2, s2 - 48), o2 = (r2 = my(i2)).R(e2); wy(o2) || 0 < o2.X(t3);)
+            o2 = (r2 = my(i2 -= s2)).R(e2);
+        _y(r2) && (r2 = vy), n2 = n2.add(r2), t3 = ky(t3, o2);
+    }
+    return new Sy(n2, t3);
+}
+
+function Cy(t3) {
+    for (var e2 = t3.g.length + 1, i2 = [], s2 = 0; s2 < e2; s2++)
+        i2[s2] = t3.D(s2) << 1 | t3.D(s2 - 1) >>> 31;
+    return new dy(i2, t3.h);
+}
+
+function Iy(t3, e2) {
+    var i2 = e2 >> 5;
+    e2 %= 32;
+    for (var s2 = t3.g.length - i2, n2 = [], r2 = 0; r2 < s2; r2++)
+        n2[r2] = 0 < e2 ? t3.D(r2 + i2) >>> e2 | t3.D(r2 + i2 + 1) << 32 - e2 : t3.D(r2 + i2);
+    return new dy(n2, t3.h);
+}
+(Sf = dy.prototype).ea = function() {
+    if (wy(this))
+        return -xy(this).ea();
+    for (var t3 = 0, e2 = 1, i2 = 0; i2 < this.g.length; i2++) {
+        var s2 = this.D(i2);
+        t3 += (0 <= s2 ? s2 : gy + s2) * e2, e2 *= gy;
+    }
+    return t3;
+}, Sf.toString = function(t3) {
+    if (2 > (t3 = t3 || 10) || 36 < t3)
+        throw Error("radix out of range: " + t3);
+    if (_y(this))
+        return "0";
+    if (wy(this))
+        return "-" + xy(this).toString(t3);
+    for (var e2 = my(Math.pow(t3, 6)), i2 = this, s2 = "";;) {
+        var n2 = Ey(i2, e2).g,
+            r2 = ((0 < (i2 = ky(i2, n2.R(e2))).g.length ? i2.g[0] : i2.h) >>> 0).toString(t3);
+        if (_y(i2 = n2))
+            return r2 + s2;
+        for (; 6 > r2.length;)
+            r2 = "0" + r2;
+        s2 = r2 + s2;
+    }
+}, Sf.D = function(t3) {
+    return 0 > t3 ? 0 : t3 < this.g.length ? this.g[t3] : this.h;
+}, Sf.X = function(t3) {
+    return wy(t3 = ky(this, t3)) ? -1 : _y(t3) ? 0 : 1;
+}, Sf.abs = function() {
+    return wy(this) ? xy(this) : this;
+}, Sf.add = function(t3) {
+    for (var e2 = Math.max(this.g.length, t3.g.length), i2 = [], s2 = 0, n2 = 0; n2 <= e2; n2++) {
+        var r2 = s2 + (65535 & this.D(n2)) + (65535 & t3.D(n2)),
+            o2 = (r2 >>> 16) + (this.D(n2) >>> 16) + (t3.D(n2) >>> 16);
+        s2 = o2 >>> 16, r2 &= 65535, o2 &= 65535, i2[n2] = o2 << 16 | r2;
+    }
+    return new dy(i2, -2147483648 & i2[i2.length - 1] ? -1 : 0);
+}, Sf.R = function(t3) {
+    if (_y(this) || _y(t3))
+        return yy;
+    if (wy(this))
+        return wy(t3) ? xy(this).R(xy(t3)) : xy(xy(this).R(t3));
+    if (wy(t3))
+        return xy(this.R(xy(t3)));
+    if (0 > this.X(by) && 0 > t3.X(by))
+        return my(this.ea() * t3.ea());
+    for (var e2 = this.g.length + t3.g.length, i2 = [], s2 = 0; s2 < 2 * e2; s2++)
+        i2[s2] = 0;
+    for (s2 = 0; s2 < this.g.length; s2++)
+        for (var n2 = 0; n2 < t3.g.length; n2++) {
+            var r2 = this.D(s2) >>> 16,
+                o2 = 65535 & this.D(s2),
+                a2 = t3.D(n2) >>> 16,
+                l2 = 65535 & t3.D(n2);
+            i2[2 * s2 + 2 * n2] += o2 * l2, Ty(i2, 2 * s2 + 2 * n2), i2[2 * s2 + 2 * n2 + 1] += r2 * l2, Ty(i2, 2 * s2 + 2 * n2 + 1), i2[2 * s2 + 2 * n2 + 1] += o2 * a2, Ty(i2, 2 * s2 + 2 * n2 + 1), i2[2 * s2 + 2 * n2 + 2] += r2 * a2, Ty(i2, 2 * s2 + 2 * n2 + 2);
+        }
+    for (s2 = 0; s2 < e2; s2++)
+        i2[s2] = i2[2 * s2 + 1] << 16 | i2[2 * s2];
+    for (s2 = e2; s2 < 2 * e2; s2++)
+        i2[s2] = 0;
+    return new dy(i2, 0);
+}, Sf.gb = function(t3) {
+    return Ey(this, t3).h;
+}, Sf.and = function(t3) {
+    for (var e2 = Math.max(this.g.length, t3.g.length), i2 = [], s2 = 0; s2 < e2; s2++)
+        i2[s2] = this.D(s2) & t3.D(s2);
+    return new dy(i2, this.h & t3.h);
+}, Sf.or = function(t3) {
+    for (var e2 = Math.max(this.g.length, t3.g.length), i2 = [], s2 = 0; s2 < e2; s2++)
+        i2[s2] = this.D(s2) | t3.D(s2);
+    return new dy(i2, this.h | t3.h);
+}, Sf.xor = function(t3) {
+    for (var e2 = Math.max(this.g.length, t3.g.length), i2 = [], s2 = 0; s2 < e2; s2++)
+        i2[s2] = this.D(s2) ^ t3.D(s2);
+    return new dy(i2, this.h ^ t3.h);
+}, ry.prototype.createWebChannel = ry.prototype.g, oy.prototype.send = oy.prototype.u, oy.prototype.open = oy.prototype.m, oy.prototype.close = oy.prototype.close, um.NO_ERROR = 0, um.TIMEOUT = 8, um.HTTP_ERROR = 6, dm.COMPLETE = "complete", mm.EventType = ym, ym.OPEN = "a", ym.CLOSE = "b", ym.ERROR = "c", ym.MESSAGE = "d", Dp.prototype.listen = Dp.prototype.O, Sg.prototype.listenOnce = Sg.prototype.P, Sg.prototype.getLastError = Sg.prototype.Sa, Sg.prototype.getLastErrorCode = Sg.prototype.Ia, Sg.prototype.getStatus = Sg.prototype.da, Sg.prototype.getResponseJson = Sg.prototype.Wa, Sg.prototype.getResponseText = Sg.prototype.ja, Sg.prototype.send = Sg.prototype.ha, Sg.prototype.setWithCredentials = Sg.prototype.Oa, cy.prototype.digest = cy.prototype.l, cy.prototype.reset = cy.prototype.reset, cy.prototype.update = cy.prototype.j, dy.prototype.add = dy.prototype.add, dy.prototype.multiply = dy.prototype.R, dy.prototype.modulo = dy.prototype.gb, dy.prototype.compare = dy.prototype.X, dy.prototype.toNumber = dy.prototype.ea, dy.prototype.toString = dy.prototype.toString, dy.prototype.getBits = dy.prototype.D, dy.fromNumber = my, dy.fromString = function t2(e2, i2) {
+    if (0 == e2.length)
+        throw Error("number format error: empty string");
+    if (2 > (i2 = i2 || 10) || 36 < i2)
+        throw Error("radix out of range: " + i2);
+    if ("-" == e2.charAt(0))
+        return xy(t2(e2.substring(1), i2));
+    if (0 <= e2.indexOf("-"))
+        throw Error('number format error: interior "-" character');
+    for (var s2 = my(Math.pow(i2, 8)), n2 = yy, r2 = 0; r2 < e2.length; r2 += 8) {
+        var o2 = Math.min(8, e2.length - r2),
+            a2 = parseInt(e2.substring(r2, r2 + o2), i2);
+        8 > o2 ? (o2 = my(Math.pow(i2, o2)), n2 = n2.R(o2).add(my(a2))) : n2 = (n2 = n2.R(s2)).add(my(a2));
+    }
+    return n2;
+};
+var My = um,
+    Py = dm,
+    Ry = im,
+    Ay = 10,
+    Dy = 11,
+    Ly = vg,
+    Oy = mm,
+    Fy = Sg,
+    Ny = cy,
+    $y = dy;
+const Vy = "@firebase/firestore";
+class User {
+    constructor(t3) {
+        this.uid = t3;
+    }
+    isAuthenticated() {
+        return null != this.uid;
+    }
+    toKey() {
+        return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
+    }
+    isEqual(t3) {
+        return t3.uid === this.uid;
+    }
+}
+User.UNAUTHENTICATED = new User(null), User.GOOGLE_CREDENTIALS = new User("google-credentials-uid"), User.FIRST_PARTY = new User("first-party-uid"), User.MOCK_USER = new User("mock-user");
+let zy = "10.0.0";
+const By = new Logger("@firebase/firestore");
+
+function Uy() {
+    return By.logLevel;
+}
+
+function jy(t3, ...e2) {
+    if (By.logLevel <= Rd.DEBUG) {
+        const i2 = e2.map(qy);
+        By.debug(`Firestore (${zy}): ${t3}`, ...i2);
+    }
+}
+
+function Hy(t3, ...e2) {
+    if (By.logLevel <= Rd.ERROR) {
+        const i2 = e2.map(qy);
+        By.error(`Firestore (${zy}): ${t3}`, ...i2);
+    }
+}
+
+function Wy(t3, ...e2) {
+    if (By.logLevel <= Rd.WARN) {
+        const i2 = e2.map(qy);
+        By.warn(`Firestore (${zy}): ${t3}`, ...i2);
+    }
+}
+
+function qy(t3) {
+    if ("string" == typeof t3)
+        return t3;
+    try {
+        return function(t4) {
+            return JSON.stringify(t4);
+        }(t3);
+    } catch (e2) {
+        return t3;
+    }
+}
+
+function Ky(t3 = "Unexpected state") {
+    const e2 = `FIRESTORE (${zy}) INTERNAL ASSERTION FAILED: ` + t3;
+    throw Hy(e2), new Error(e2);
+}
+
+function Gy(t3, e2) {
+    t3 || Ky();
+}
+
+function Yy(t3, e2) {
+    return t3;
+}
+const Qy = {
+    OK: "ok",
+    CANCELLED: "cancelled",
+    UNKNOWN: "unknown",
+    INVALID_ARGUMENT: "invalid-argument",
+    DEADLINE_EXCEEDED: "deadline-exceeded",
+    NOT_FOUND: "not-found",
+    ALREADY_EXISTS: "already-exists",
+    PERMISSION_DENIED: "permission-denied",
+    UNAUTHENTICATED: "unauthenticated",
+    RESOURCE_EXHAUSTED: "resource-exhausted",
+    FAILED_PRECONDITION: "failed-precondition",
+    ABORTED: "aborted",
+    OUT_OF_RANGE: "out-of-range",
+    UNIMPLEMENTED: "unimplemented",
+    INTERNAL: "internal",
+    UNAVAILABLE: "unavailable",
+    DATA_LOSS: "data-loss"
+};
+class FirestoreError extends FirebaseError {
+    constructor(t3, e2) {
+        super(t3, e2), this.code = t3, this.message = e2, this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
+    }
+}
+class __PRIVATE_Deferred {
+    constructor() {
+        this.promise = new Promise((t3, e2) => {
+            this.resolve = t3, this.reject = e2;
+        });
+    }
+}
+class __PRIVATE_OAuthToken {
+    constructor(t3, e2) {
+        this.user = e2, this.type = "OAuth", this.headers = /* @__PURE__ */ new Map(), this.headers.set("Authorization", `Bearer ${t3}`);
+    }
+}
+class __PRIVATE_EmptyAuthCredentialsProvider {
+    getToken() {
+        return Promise.resolve(null);
+    }
+    invalidateToken() {}
+    start(t3, e2) {
+        t3.enqueueRetryable(() => e2(User.UNAUTHENTICATED));
+    }
+    shutdown() {}
+}
+class __PRIVATE_EmulatorAuthCredentialsProvider {
+    constructor(t3) {
+        this.token = t3, this.changeListener = null;
+    }
+    getToken() {
+        return Promise.resolve(this.token);
+    }
+    invalidateToken() {}
+    start(t3, e2) {
+        this.changeListener = e2, t3.enqueueRetryable(() => e2(this.token.user));
+    }
+    shutdown() {
+        this.changeListener = null;
+    }
+}
+class __PRIVATE_FirebaseAuthCredentialsProvider {
+    constructor(t3) {
+        this.t = t3, this.currentUser = User.UNAUTHENTICATED, this.i = 0, this.forceRefresh = false, this.auth = null;
+    }
+    start(t3, e2) {
+        let i2 = this.i;
+        const s2 = (t4) => this.i !== i2 ? (i2 = this.i, e2(t4)) : Promise.resolve();
+        let n2 = new __PRIVATE_Deferred();
+        this.o = () => {
+            this.i++, this.currentUser = this.u(), n2.resolve(), n2 = new __PRIVATE_Deferred(), t3.enqueueRetryable(() => s2(this.currentUser));
+        };
+        const r2 = () => {
+                const e3 = n2;
+                t3.enqueueRetryable(async () => {
+                    await e3.promise, await s2(this.currentUser);
+                });
+            },
+            o2 = (t4) => {
+                jy("FirebaseAuthCredentialsProvider", "Auth detected"), this.auth = t4, this.auth.addAuthTokenListener(this.o), r2();
+            };
+        this.t.onInit((t4) => o2(t4)), setTimeout(() => {
+            if (!this.auth) {
+                const t4 = this.t.getImmediate({
+                    optional: true
+                });
+                t4 ? o2(t4) : (jy("FirebaseAuthCredentialsProvider", "Auth not yet detected"), n2.resolve(), n2 = new __PRIVATE_Deferred());
+            }
+        }, 0), r2();
+    }
+    getToken() {
+        const t3 = this.i,
+            e2 = this.forceRefresh;
+        return this.forceRefresh = false, this.auth ? this.auth.getToken(e2).then((e3) => this.i !== t3 ? (jy("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : e3 ? (Gy("string" == typeof e3.accessToken), new __PRIVATE_OAuthToken(e3.accessToken, this.currentUser)) : null) : Promise.resolve(null);
+    }
+    invalidateToken() {
+        this.forceRefresh = true;
+    }
+    shutdown() {
+        this.auth && this.auth.removeAuthTokenListener(this.o);
+    }
+    u() {
+        const t3 = this.auth && this.auth.getUid();
+        return Gy(null === t3 || "string" == typeof t3), new User(t3);
+    }
+}
+class __PRIVATE_FirstPartyToken {
+    constructor(t3, e2, i2) {
+        this.l = t3, this.h = e2, this.P = i2, this.type = "FirstParty", this.user = User.FIRST_PARTY, this.I = /* @__PURE__ */ new Map();
+    }
+    T() {
+        return this.P ? this.P() : null;
+    }
+    get headers() {
+        this.I.set("X-Goog-AuthUser", this.l);
+        const t3 = this.T();
+        return t3 && this.I.set("Authorization", t3), this.h && this.I.set("X-Goog-Iam-Authorization-Token", this.h), this.I;
+    }
+}
+class __PRIVATE_FirstPartyAuthCredentialsProvider {
+    constructor(t3, e2, i2) {
+        this.l = t3, this.h = e2, this.P = i2;
+    }
+    getToken() {
+        return Promise.resolve(new __PRIVATE_FirstPartyToken(this.l, this.h, this.P));
+    }
+    start(t3, e2) {
+        t3.enqueueRetryable(() => e2(User.FIRST_PARTY));
+    }
+    shutdown() {}
+    invalidateToken() {}
+}
+class AppCheckToken {
+    constructor(t3) {
+        this.value = t3, this.type = "AppCheck", this.headers = /* @__PURE__ */ new Map(), t3 && t3.length > 0 && this.headers.set("x-firebase-appcheck", this.value);
+    }
+}
+class __PRIVATE_FirebaseAppCheckTokenProvider {
+    constructor(t3) {
+        this.A = t3, this.forceRefresh = false, this.appCheck = null, this.R = null;
+    }
+    start(t3, e2) {
+        const i2 = (t4) => {
+            null != t4.error && jy("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${t4.error.message}`);
+            const i3 = t4.token !== this.R;
+            return this.R = t4.token, jy("FirebaseAppCheckTokenProvider", `Received ${i3 ? "new" : "existing"} token.`), i3 ? e2(t4.token) : Promise.resolve();
+        };
+        this.o = (e3) => {
+            t3.enqueueRetryable(() => i2(e3));
+        };
+        const s2 = (t4) => {
+            jy("FirebaseAppCheckTokenProvider", "AppCheck detected"), this.appCheck = t4, this.appCheck.addTokenListener(this.o);
+        };
+        this.A.onInit((t4) => s2(t4)), setTimeout(() => {
+            if (!this.appCheck) {
+                const t4 = this.A.getImmediate({
+                    optional: true
+                });
+                t4 ? s2(t4) : jy("FirebaseAppCheckTokenProvider", "AppCheck not yet detected");
+            }
+        }, 0);
+    }
+    getToken() {
+        const t3 = this.forceRefresh;
+        return this.forceRefresh = false, this.appCheck ? this.appCheck.getToken(t3).then((t4) => t4 ? (Gy("string" == typeof t4.token), this.R = t4.token, new AppCheckToken(t4.token)) : null) : Promise.resolve(null);
+    }
+    invalidateToken() {
+        this.forceRefresh = true;
+    }
+    shutdown() {
+        this.appCheck && this.appCheck.removeTokenListener(this.o);
+    }
+}
+
+function Xy(t3) {
+    const e2 = "undefined" != typeof self && (self.crypto || self.msCrypto),
+        i2 = new Uint8Array(t3);
+    if (e2 && "function" == typeof e2.getRandomValues)
+        e2.getRandomValues(i2);
+    else
+        for (let e3 = 0; e3 < t3; e3++)
+            i2[e3] = Math.floor(256 * Math.random());
+    return i2;
+}
+class __PRIVATE_AutoId {
+    static V() {
+        const t3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
+            e2 = 62 * Math.floor(256 / 62);
+        let i2 = "";
+        for (; i2.length < 20;) {
+            const s2 = Xy(40);
+            for (let n2 = 0; n2 < s2.length; ++n2)
+                i2.length < 20 && s2[n2] < e2 && (i2 += t3.charAt(s2[n2] % 62));
+        }
+        return i2;
+    }
+}
+
+function Jy(t3, e2) {
+    return t3 < e2 ? -1 : t3 > e2 ? 1 : 0;
+}
+
+function Zy(t3, e2, i2) {
+    return t3.length === e2.length && t3.every((t4, s2) => i2(t4, e2[s2]));
+}
+class Timestamp {
+    constructor(t3, e2) {
+        if (this.seconds = t3, this.nanoseconds = e2, e2 < 0)
+            throw new FirestoreError(Qy.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e2);
+        if (e2 >= 1e9)
+            throw new FirestoreError(Qy.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e2);
+        if (t3 < -62135596800)
+            throw new FirestoreError(Qy.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t3);
+        if (t3 >= 253402300800)
+            throw new FirestoreError(Qy.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t3);
+    }
+    static now() {
+        return Timestamp.fromMillis(Date.now());
+    }
+    static fromDate(t3) {
+        return Timestamp.fromMillis(t3.getTime());
+    }
+    static fromMillis(t3) {
+        const e2 = Math.floor(t3 / 1e3),
+            i2 = Math.floor(1e6 * (t3 - 1e3 * e2));
+        return new Timestamp(e2, i2);
+    }
+    toDate() {
+        return new Date(this.toMillis());
+    }
+    toMillis() {
+        return 1e3 * this.seconds + this.nanoseconds / 1e6;
+    }
+    _compareTo(t3) {
+        return this.seconds === t3.seconds ? Jy(this.nanoseconds, t3.nanoseconds) : Jy(this.seconds, t3.seconds);
+    }
+    isEqual(t3) {
+        return t3.seconds === this.seconds && t3.nanoseconds === this.nanoseconds;
+    }
+    toString() {
+        return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
+    }
+    toJSON() {
+        return {
+            seconds: this.seconds,
+            nanoseconds: this.nanoseconds
+        };
+    }
+    valueOf() {
+        const t3 = this.seconds - -62135596800;
+        return String(t3).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
+    }
+}
+class SnapshotVersion {
+    constructor(t3) {
+        this.timestamp = t3;
+    }
+    static fromTimestamp(t3) {
+        return new SnapshotVersion(t3);
+    }
+    static min() {
+        return new SnapshotVersion(new Timestamp(0, 0));
+    }
+    static max() {
+        return new SnapshotVersion(new Timestamp(253402300799, 999999999));
+    }
+    compareTo(t3) {
+        return this.timestamp._compareTo(t3.timestamp);
+    }
+    isEqual(t3) {
+        return this.timestamp.isEqual(t3.timestamp);
+    }
+    toMicroseconds() {
+        return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
+    }
+    toString() {
+        return "SnapshotVersion(" + this.timestamp.toString() + ")";
+    }
+    toTimestamp() {
+        return this.timestamp;
+    }
+}
+class BasePath {
+    constructor(t3, e2, i2) {
+        void 0 === e2 ? e2 = 0 : e2 > t3.length && Ky(), void 0 === i2 ? i2 = t3.length - e2 : i2 > t3.length - e2 && Ky(), this.segments = t3, this.offset = e2, this.len = i2;
+    }
+    get length() {
+        return this.len;
+    }
+    isEqual(t3) {
+        return 0 === BasePath.comparator(this, t3);
+    }
+    child(t3) {
+        const e2 = this.segments.slice(this.offset, this.limit());
+        return t3 instanceof BasePath ? t3.forEach((t4) => {
+            e2.push(t4);
+        }) : e2.push(t3), this.construct(e2);
+    }
+    limit() {
+        return this.offset + this.length;
+    }
+    popFirst(t3) {
+        return t3 = void 0 === t3 ? 1 : t3, this.construct(this.segments, this.offset + t3, this.length - t3);
+    }
+    popLast() {
+        return this.construct(this.segments, this.offset, this.length - 1);
+    }
+    firstSegment() {
+        return this.segments[this.offset];
+    }
+    lastSegment() {
+        return this.get(this.length - 1);
+    }
+    get(t3) {
+        return this.segments[this.offset + t3];
+    }
+    isEmpty() {
+        return 0 === this.length;
+    }
+    isPrefixOf(t3) {
+        if (t3.length < this.length)
+            return false;
+        for (let e2 = 0; e2 < this.length; e2++)
+            if (this.get(e2) !== t3.get(e2))
+                return false;
+        return true;
+    }
+    isImmediateParentOf(t3) {
+        if (this.length + 1 !== t3.length)
+            return false;
+        for (let e2 = 0; e2 < this.length; e2++)
+            if (this.get(e2) !== t3.get(e2))
+                return false;
+        return true;
+    }
+    forEach(t3) {
+        for (let e2 = this.offset, i2 = this.limit(); e2 < i2; e2++)
+            t3(this.segments[e2]);
+    }
+    toArray() {
+        return this.segments.slice(this.offset, this.limit());
+    }
+    static comparator(t3, e2) {
+        const i2 = Math.min(t3.length, e2.length);
+        for (let s2 = 0; s2 < i2; s2++) {
+            const i3 = t3.get(s2),
+                n2 = e2.get(s2);
+            if (i3 < n2)
+                return -1;
+            if (i3 > n2)
+                return 1;
+        }
+        return t3.length < e2.length ? -1 : t3.length > e2.length ? 1 : 0;
+    }
+}
+class ResourcePath extends BasePath {
+    construct(t3, e2, i2) {
+        return new ResourcePath(t3, e2, i2);
+    }
+    canonicalString() {
+        return this.toArray().join("/");
+    }
+    toString() {
+        return this.canonicalString();
+    }
+    static fromString(...t3) {
+        const e2 = [];
+        for (const i2 of t3) {
+            if (i2.indexOf("//") >= 0)
+                throw new FirestoreError(Qy.INVALID_ARGUMENT, `Invalid segment (${i2}). Paths must not contain // in them.`);
+            e2.push(...i2.split("/").filter((t4) => t4.length > 0));
+        }
+        return new ResourcePath(e2);
+    }
+    static emptyPath() {
+        return new ResourcePath([]);
+    }
+}
+const tv = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
+class FieldPath$1 extends BasePath {
+    construct(t3, e2, i2) {
+        return new FieldPath$1(t3, e2, i2);
+    }
+    static isValidIdentifier(t3) {
+        return tv.test(t3);
+    }
+    canonicalString() {
+        return this.toArray().map((t3) => (t3 = t3.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), FieldPath$1.isValidIdentifier(t3) || (t3 = "`" + t3 + "`"), t3)).join(".");
+    }
+    toString() {
+        return this.canonicalString();
+    }
+    isKeyField() {
+        return 1 === this.length && "__name__" === this.get(0);
+    }
+    static keyField() {
+        return new FieldPath$1(["__name__"]);
+    }
+    static fromServerFormat(t3) {
+        const e2 = [];
+        let i2 = "",
+            s2 = 0;
+        const n2 = () => {
+            if (0 === i2.length)
+                throw new FirestoreError(Qy.INVALID_ARGUMENT, `Invalid field path (${t3}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
+            e2.push(i2), i2 = "";
+        };
+        let r2 = false;
+        for (; s2 < t3.length;) {
+            const e3 = t3[s2];
+            if ("\\" === e3) {
+                if (s2 + 1 === t3.length)
+                    throw new FirestoreError(Qy.INVALID_ARGUMENT, "Path has trailing escape character: " + t3);
+                const e4 = t3[s2 + 1];
+                if ("\\" !== e4 && "." !== e4 && "`" !== e4)
+                    throw new FirestoreError(Qy.INVALID_ARGUMENT, "Path has invalid escape sequence: " + t3);
+                i2 += e4, s2 += 2;
+            } else
+                "`" === e3 ? (r2 = !r2, s2++) : "." !== e3 || r2 ? (i2 += e3, s2++) : (n2(), s2++);
+        }
+        if (n2(), r2)
+            throw new FirestoreError(Qy.INVALID_ARGUMENT, "Unterminated ` in path: " + t3);
+        return new FieldPath$1(e2);
+    }
+    static emptyPath() {
+        return new FieldPath$1([]);
+    }
+}
+class DocumentKey {
+    constructor(t3) {
+        this.path = t3;
+    }
+    static fromPath(t3) {
+        return new DocumentKey(ResourcePath.fromString(t3));
+    }
+    static fromName(t3) {
+        return new DocumentKey(ResourcePath.fromString(t3).popFirst(5));
+    }
+    static empty() {
+        return new DocumentKey(ResourcePath.emptyPath());
+    }
+    get collectionGroup() {
+        return this.path.popLast().lastSegment();
+    }
+    hasCollectionId(t3) {
+        return this.path.length >= 2 && this.path.get(this.path.length - 2) === t3;
+    }
+    getCollectionGroup() {
+        return this.path.get(this.path.length - 2);
+    }
+    getCollectionPath() {
+        return this.path.popLast();
+    }
+    isEqual(t3) {
+        return null !== t3 && 0 === ResourcePath.comparator(this.path, t3.path);
+    }
+    toString() {
+        return this.path.toString();
+    }
+    static comparator(t3, e2) {
+        return ResourcePath.comparator(t3.path, e2.path);
+    }
+    static isDocumentKey(t3) {
+        return t3.length % 2 == 0;
+    }
+    static fromSegments(t3) {
+        return new DocumentKey(new ResourcePath(t3.slice()));
+    }
+}
+
+function ev(t3) {
+    return new IndexOffset(t3.readTime, t3.key, -1);
+}
+class IndexOffset {
+    constructor(t3, e2, i2) {
+        this.readTime = t3, this.documentKey = e2, this.largestBatchId = i2;
+    }
+    static min() {
+        return new IndexOffset(SnapshotVersion.min(), DocumentKey.empty(), -1);
+    }
+    static max() {
+        return new IndexOffset(SnapshotVersion.max(), DocumentKey.empty(), -1);
+    }
+}
+
+function iv(t3, e2) {
+    let i2 = t3.readTime.compareTo(e2.readTime);
+    return 0 !== i2 ? i2 : (i2 = DocumentKey.comparator(t3.documentKey, e2.documentKey), 0 !== i2 ? i2 : Jy(t3.largestBatchId, e2.largestBatchId));
+}
+const sv = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
+class PersistenceTransaction {
+    constructor() {
+        this.onCommittedListeners = [];
+    }
+    addOnCommittedListener(t3) {
+        this.onCommittedListeners.push(t3);
+    }
+    raiseOnCommittedEvent() {
+        this.onCommittedListeners.forEach((t3) => t3());
+    }
+}
+async function nv(t3) {
+    if (t3.code !== Qy.FAILED_PRECONDITION || t3.message !== sv)
+        throw t3;
+    jy("LocalStore", "Unexpectedly lost primary lease");
+}
+class PersistencePromise {
+    constructor(t3) {
+        this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = false, this.callbackAttached = false, t3((t4) => {
+            this.isDone = true, this.result = t4, this.nextCallback && this.nextCallback(t4);
+        }, (t4) => {
+            this.isDone = true, this.error = t4, this.catchCallback && this.catchCallback(t4);
+        });
+    }
+    catch (t3) {
+        return this.next(void 0, t3);
+    }
+    next(t3, e2) {
+        return this.callbackAttached && Ky(), this.callbackAttached = true, this.isDone ? this.error ? this.wrapFailure(e2, this.error) : this.wrapSuccess(t3, this.result) : new PersistencePromise((i2, s2) => {
+            this.nextCallback = (e3) => {
+                this.wrapSuccess(t3, e3).next(i2, s2);
+            }, this.catchCallback = (t4) => {
+                this.wrapFailure(e2, t4).next(i2, s2);
+            };
+        });
+    }
+    toPromise() {
+        return new Promise((t3, e2) => {
+            this.next(t3, e2);
+        });
+    }
+    wrapUserFunction(t3) {
+        try {
+            const e2 = t3();
+            return e2 instanceof PersistencePromise ? e2 : PersistencePromise.resolve(e2);
+        } catch (t4) {
+            return PersistencePromise.reject(t4);
+        }
+    }
+    wrapSuccess(t3, e2) {
+        return t3 ? this.wrapUserFunction(() => t3(e2)) : PersistencePromise.resolve(e2);
+    }
+    wrapFailure(t3, e2) {
+        return t3 ? this.wrapUserFunction(() => t3(e2)) : PersistencePromise.reject(e2);
+    }
+    static resolve(t3) {
+        return new PersistencePromise((e2, i2) => {
+            e2(t3);
+        });
+    }
+    static reject(t3) {
+        return new PersistencePromise((e2, i2) => {
+            i2(t3);
+        });
+    }
+    static waitFor(t3) {
+        return new PersistencePromise((e2, i2) => {
+            let s2 = 0,
+                n2 = 0,
+                r2 = false;
+            t3.forEach((t4) => {
+                ++s2, t4.next(() => {
+                    ++n2, r2 && n2 === s2 && e2();
+                }, (t5) => i2(t5));
+            }), r2 = true, n2 === s2 && e2();
+        });
+    }
+    static or(t3) {
+        let e2 = PersistencePromise.resolve(false);
+        for (const i2 of t3)
+            e2 = e2.next((t4) => t4 ? PersistencePromise.resolve(t4) : i2());
+        return e2;
+    }
+    static forEach(t3, e2) {
+        const i2 = [];
+        return t3.forEach((t4, s2) => {
+            i2.push(e2.call(this, t4, s2));
+        }), this.waitFor(i2);
+    }
+    static mapArray(t3, e2) {
+        return new PersistencePromise((i2, s2) => {
+            const n2 = t3.length,
+                r2 = new Array(n2);
+            let o2 = 0;
+            for (let a2 = 0; a2 < n2; a2++) {
+                const l2 = a2;
+                e2(t3[l2]).next((t4) => {
+                    r2[l2] = t4, ++o2, o2 === n2 && i2(r2);
+                }, (t4) => s2(t4));
+            }
+        });
+    }
+    static doWhile(t3, e2) {
+        return new PersistencePromise((i2, s2) => {
+            const n2 = () => {
+                true === t3() ? e2().next(() => {
+                    n2();
+                }, s2) : i2();
+            };
+            n2();
+        });
+    }
+}
+
+function rv(t3) {
+    return "IndexedDbTransactionError" === t3.name;
+}
+class __PRIVATE_ListenSequence {
+    constructor(t3, e2) {
+        this.previousValue = t3, e2 && (e2.sequenceNumberHandler = (t4) => this.oe(t4), this._e = (t4) => e2.writeSequenceNumber(t4));
+    }
+    oe(t3) {
+        return this.previousValue = Math.max(t3, this.previousValue), this.previousValue;
+    }
+    next() {
+        const t3 = ++this.previousValue;
+        return this._e && this._e(t3), t3;
+    }
+}
+
+function ov(t3) {
+    return null == t3;
+}
+
+function av(t3) {
+    return 0 === t3 && 1 / t3 == -1 / 0;
+}
+
+function lv(t3) {
+    let e2 = 0;
+    for (const i2 in t3)
+        Object.prototype.hasOwnProperty.call(t3, i2) && e2++;
+    return e2;
+}
+
+function hv(t3, e2) {
+    for (const i2 in t3)
+        Object.prototype.hasOwnProperty.call(t3, i2) && e2(i2, t3[i2]);
+}
+__PRIVATE_ListenSequence.ae = -1;
+class SortedMap {
+    constructor(t3, e2) {
+        this.comparator = t3, this.root = e2 || LLRBNode.EMPTY;
+    }
+    insert(t3, e2) {
+        return new SortedMap(this.comparator, this.root.insert(t3, e2, this.comparator).copy(null, null, LLRBNode.BLACK, null, null));
+    }
+    remove(t3) {
+        return new SortedMap(this.comparator, this.root.remove(t3, this.comparator).copy(null, null, LLRBNode.BLACK, null, null));
+    }
+    get(t3) {
+        let e2 = this.root;
+        for (; !e2.isEmpty();) {
+            const i2 = this.comparator(t3, e2.key);
+            if (0 === i2)
+                return e2.value;
+            i2 < 0 ? e2 = e2.left : i2 > 0 && (e2 = e2.right);
+        }
+        return null;
+    }
+    indexOf(t3) {
+        let e2 = 0,
+            i2 = this.root;
+        for (; !i2.isEmpty();) {
+            const s2 = this.comparator(t3, i2.key);
+            if (0 === s2)
+                return e2 + i2.left.size;
+            s2 < 0 ? i2 = i2.left : (e2 += i2.left.size + 1, i2 = i2.right);
+        }
+        return -1;
+    }
+    isEmpty() {
+        return this.root.isEmpty();
+    }
+    get size() {
+        return this.root.size;
+    }
+    minKey() {
+        return this.root.minKey();
+    }
+    maxKey() {
+        return this.root.maxKey();
+    }
+    inorderTraversal(t3) {
+        return this.root.inorderTraversal(t3);
+    }
+    forEach(t3) {
+        this.inorderTraversal((e2, i2) => (t3(e2, i2), false));
+    }
+    toString() {
+        const t3 = [];
+        return this.inorderTraversal((e2, i2) => (t3.push(`${e2}:${i2}`), false)), `{${t3.join(", ")}}`;
+    }
+    reverseTraversal(t3) {
+        return this.root.reverseTraversal(t3);
+    }
+    getIterator() {
+        return new SortedMapIterator(this.root, null, this.comparator, false);
+    }
+    getIteratorFrom(t3) {
+        return new SortedMapIterator(this.root, t3, this.comparator, false);
+    }
+    getReverseIterator() {
+        return new SortedMapIterator(this.root, null, this.comparator, true);
+    }
+    getReverseIteratorFrom(t3) {
+        return new SortedMapIterator(this.root, t3, this.comparator, true);
+    }
+}
+class SortedMapIterator {
+    constructor(t3, e2, i2, s2) {
+        this.isReverse = s2, this.nodeStack = [];
+        let n2 = 1;
+        for (; !t3.isEmpty();)
+            if (n2 = e2 ? i2(t3.key, e2) : 1, e2 && s2 && (n2 *= -1), n2 < 0)
+                t3 = this.isReverse ? t3.left : t3.right;
+            else {
+                if (0 === n2) {
+                    this.nodeStack.push(t3);
+                    break;
+                }
+                this.nodeStack.push(t3), t3 = this.isReverse ? t3.right : t3.left;
+            }
+    }
+    getNext() {
+        let t3 = this.nodeStack.pop();
+        const e2 = {
+            key: t3.key,
+            value: t3.value
+        };
+        if (this.isReverse)
+            for (t3 = t3.left; !t3.isEmpty();)
+                this.nodeStack.push(t3), t3 = t3.right;
+        else
+            for (t3 = t3.right; !t3.isEmpty();)
+                this.nodeStack.push(t3), t3 = t3.left;
+        return e2;
+    }
+    hasNext() {
+        return this.nodeStack.length > 0;
+    }
+    peek() {
+        if (0 === this.nodeStack.length)
+            return null;
+        const t3 = this.nodeStack[this.nodeStack.length - 1];
+        return {
+            key: t3.key,
+            value: t3.value
+        };
+    }
+}
+class LLRBNode {
+    constructor(t3, e2, i2, s2, n2) {
+        this.key = t3, this.value = e2, this.color = null != i2 ? i2 : LLRBNode.RED, this.left = null != s2 ? s2 : LLRBNode.EMPTY, this.right = null != n2 ? n2 : LLRBNode.EMPTY, this.size = this.left.size + 1 + this.right.size;
+    }
+    copy(t3, e2, i2, s2, n2) {
+        return new LLRBNode(null != t3 ? t3 : this.key, null != e2 ? e2 : this.value, null != i2 ? i2 : this.color, null != s2 ? s2 : this.left, null != n2 ? n2 : this.right);
+    }
+    isEmpty() {
+        return false;
+    }
+    inorderTraversal(t3) {
+        return this.left.inorderTraversal(t3) || t3(this.key, this.value) || this.right.inorderTraversal(t3);
+    }
+    reverseTraversal(t3) {
+        return this.right.reverseTraversal(t3) || t3(this.key, this.value) || this.left.reverseTraversal(t3);
+    }
+    min() {
+        return this.left.isEmpty() ? this : this.left.min();
+    }
+    minKey() {
+        return this.min().key;
+    }
+    maxKey() {
+        return this.right.isEmpty() ? this.key : this.right.maxKey();
+    }
+    insert(t3, e2, i2) {
+        let s2 = this;
+        const n2 = i2(t3, s2.key);
+        return s2 = n2 < 0 ? s2.copy(null, null, null, s2.left.insert(t3, e2, i2), null) : 0 === n2 ? s2.copy(null, e2, null, null, null) : s2.copy(null, null, null, null, s2.right.insert(t3, e2, i2)), s2.fixUp();
+    }
+    removeMin() {
+        if (this.left.isEmpty())
+            return LLRBNode.EMPTY;
+        let t3 = this;
+        return t3.left.isRed() || t3.left.left.isRed() || (t3 = t3.moveRedLeft()), t3 = t3.copy(null, null, null, t3.left.removeMin(), null), t3.fixUp();
+    }
+    remove(t3, e2) {
+        let i2, s2 = this;
+        if (e2(t3, s2.key) < 0)
+            s2.left.isEmpty() || s2.left.isRed() || s2.left.left.isRed() || (s2 = s2.moveRedLeft()), s2 = s2.copy(null, null, null, s2.left.remove(t3, e2), null);
+        else {
+            if (s2.left.isRed() && (s2 = s2.rotateRight()), s2.right.isEmpty() || s2.right.isRed() || s2.right.left.isRed() || (s2 = s2.moveRedRight()), 0 === e2(t3, s2.key)) {
+                if (s2.right.isEmpty())
+                    return LLRBNode.EMPTY;
+                i2 = s2.right.min(), s2 = s2.copy(i2.key, i2.value, null, null, s2.right.removeMin());
+            }
+            s2 = s2.copy(null, null, null, null, s2.right.remove(t3, e2));
+        }
+        return s2.fixUp();
+    }
+    isRed() {
+        return this.color;
+    }
+    fixUp() {
+        let t3 = this;
+        return t3.right.isRed() && !t3.left.isRed() && (t3 = t3.rotateLeft()), t3.left.isRed() && t3.left.left.isRed() && (t3 = t3.rotateRight()), t3.left.isRed() && t3.right.isRed() && (t3 = t3.colorFlip()), t3;
+    }
+    moveRedLeft() {
+        let t3 = this.colorFlip();
+        return t3.right.left.isRed() && (t3 = t3.copy(null, null, null, null, t3.right.rotateRight()), t3 = t3.rotateLeft(), t3 = t3.colorFlip()), t3;
+    }
+    moveRedRight() {
+        let t3 = this.colorFlip();
+        return t3.left.left.isRed() && (t3 = t3.rotateRight(), t3 = t3.colorFlip()), t3;
+    }
+    rotateLeft() {
+        const t3 = this.copy(null, null, LLRBNode.RED, null, this.right.left);
+        return this.right.copy(null, null, this.color, t3, null);
+    }
+    rotateRight() {
+        const t3 = this.copy(null, null, LLRBNode.RED, this.left.right, null);
+        return this.left.copy(null, null, this.color, null, t3);
+    }
+    colorFlip() {
+        const t3 = this.left.copy(null, null, !this.left.color, null, null),
+            e2 = this.right.copy(null, null, !this.right.color, null, null);
+        return this.copy(null, null, !this.color, t3, e2);
+    }
+    checkMaxDepth() {
+        const t3 = this.check();
+        return Math.pow(2, t3) <= this.size + 1;
+    }
+    check() {
+        if (this.isRed() && this.left.isRed())
+            throw Ky();
+        if (this.right.isRed())
+            throw Ky();
+        const t3 = this.left.check();
+        if (t3 !== this.right.check())
+            throw Ky();
+        return t3 + (this.isRed() ? 0 : 1);
+    }
+}
+LLRBNode.EMPTY = null, LLRBNode.RED = true, LLRBNode.BLACK = false, LLRBNode.EMPTY = new class LLRBEmptyNode {
+    constructor() {
+        this.size = 0;
+    }
+    get key() {
+        throw Ky();
+    }
+    get value() {
+        throw Ky();
+    }
+    get color() {
+        throw Ky();
+    }
+    get left() {
+        throw Ky();
+    }
+    get right() {
+        throw Ky();
+    }
+    copy(t3, e2, i2, s2, n2) {
+        return this;
+    }
+    insert(t3, e2, i2) {
+        return new LLRBNode(t3, e2);
+    }
+    remove(t3, e2) {
+        return this;
+    }
+    isEmpty() {
+        return true;
+    }
+    inorderTraversal(t3) {
+        return false;
+    }
+    reverseTraversal(t3) {
+        return false;
+    }
+    minKey() {
+        return null;
+    }
+    maxKey() {
+        return null;
+    }
+    isRed() {
+        return false;
+    }
+    checkMaxDepth() {
+        return true;
+    }
+    check() {
+        return 0;
+    }
+}();
+class SortedSet {
+    constructor(t3) {
+        this.comparator = t3, this.data = new SortedMap(this.comparator);
+    }
+    has(t3) {
+        return null !== this.data.get(t3);
+    }
+    first() {
+        return this.data.minKey();
+    }
+    last() {
+        return this.data.maxKey();
+    }
+    get size() {
+        return this.data.size;
+    }
+    indexOf(t3) {
+        return this.data.indexOf(t3);
+    }
+    forEach(t3) {
+        this.data.inorderTraversal((e2, i2) => (t3(e2), false));
+    }
+    forEachInRange(t3, e2) {
+        const i2 = this.data.getIteratorFrom(t3[0]);
+        for (; i2.hasNext();) {
+            const s2 = i2.getNext();
+            if (this.comparator(s2.key, t3[1]) >= 0)
+                return;
+            e2(s2.key);
+        }
+    }
+    forEachWhile(t3, e2) {
+        let i2;
+        for (i2 = void 0 !== e2 ? this.data.getIteratorFrom(e2) : this.data.getIterator(); i2.hasNext();)
+            if (!t3(i2.getNext().key))
+                return;
+    }
+    firstAfterOrEqual(t3) {
+        const e2 = this.data.getIteratorFrom(t3);
+        return e2.hasNext() ? e2.getNext().key : null;
+    }
+    getIterator() {
+        return new SortedSetIterator(this.data.getIterator());
+    }
+    getIteratorFrom(t3) {
+        return new SortedSetIterator(this.data.getIteratorFrom(t3));
+    }
+    add(t3) {
+        return this.copy(this.data.remove(t3).insert(t3, true));
+    }
+    delete(t3) {
+        return this.has(t3) ? this.copy(this.data.remove(t3)) : this;
+    }
+    isEmpty() {
+        return this.data.isEmpty();
+    }
+    unionWith(t3) {
+        let e2 = this;
+        return e2.size < t3.size && (e2 = t3, t3 = this), t3.forEach((t4) => {
+            e2 = e2.add(t4);
+        }), e2;
+    }
+    isEqual(t3) {
+        if (!(t3 instanceof SortedSet))
+            return false;
+        if (this.size !== t3.size)
+            return false;
+        const e2 = this.data.getIterator(),
+            i2 = t3.data.getIterator();
+        for (; e2.hasNext();) {
+            const t4 = e2.getNext().key,
+                s2 = i2.getNext().key;
+            if (0 !== this.comparator(t4, s2))
+                return false;
+        }
+        return true;
+    }
+    toArray() {
+        const t3 = [];
+        return this.forEach((e2) => {
+            t3.push(e2);
+        }), t3;
+    }
+    toString() {
+        const t3 = [];
+        return this.forEach((e2) => t3.push(e2)), "SortedSet(" + t3.toString() + ")";
+    }
+    copy(t3) {
+        const e2 = new SortedSet(this.comparator);
+        return e2.data = t3, e2;
+    }
+}
+class SortedSetIterator {
+    constructor(t3) {
+        this.iter = t3;
+    }
+    getNext() {
+        return this.iter.getNext().key;
+    }
+    hasNext() {
+        return this.iter.hasNext();
+    }
+}
+class FieldMask {
+    constructor(t3) {
+        this.fields = t3, t3.sort(FieldPath$1.comparator);
+    }
+    static empty() {
+        return new FieldMask([]);
+    }
+    unionWith(t3) {
+        let e2 = new SortedSet(FieldPath$1.comparator);
+        for (const t4 of this.fields)
+            e2 = e2.add(t4);
+        for (const i2 of t3)
+            e2 = e2.add(i2);
+        return new FieldMask(e2.toArray());
+    }
+    covers(t3) {
+        for (const e2 of this.fields)
+            if (e2.isPrefixOf(t3))
+                return true;
+        return false;
+    }
+    isEqual(t3) {
+        return Zy(this.fields, t3.fields, (t4, e2) => t4.isEqual(e2));
+    }
+}
+class __PRIVATE_Base64DecodeError extends Error {
+    constructor() {
+        super(...arguments), this.name = "Base64DecodeError";
+    }
+}
+class ByteString {
+    constructor(t3) {
+        this.binaryString = t3;
+    }
+    static fromBase64String(t3) {
+        const e2 = function(t4) {
+            try {
+                return atob(t4);
+            } catch (t5) {
+                throw "undefined" != typeof DOMException && t5 instanceof DOMException ? new __PRIVATE_Base64DecodeError("Invalid base64 string: " + t5) : t5;
+            }
+        }(t3);
+        return new ByteString(e2);
+    }
+    static fromUint8Array(t3) {
+            const e2 = function(t4) {
+                let e3 = "";
+                for (let i2 = 0; i2 < t4.length; ++i2)
+                    e3 += String.fromCharCode(t4[i2]);
+                return e3;
+            }(t3);
+            return new ByteString(e2);
+        }
+        [Symbol.iterator]() {
+            let t3 = 0;
+            return {
+                next: () => t3 < this.binaryString.length ? {
+                    value: this.binaryString.charCodeAt(t3++),
+                    done: false
+                } : {
+                    value: void 0,
+                    done: true
+                }
+            };
+        }
+    toBase64() {
+        return function(t3) {
+            return btoa(t3);
+        }(this.binaryString);
+    }
+    toUint8Array() {
+        return function(t3) {
+            const e2 = new Uint8Array(t3.length);
+            for (let i2 = 0; i2 < t3.length; i2++)
+                e2[i2] = t3.charCodeAt(i2);
+            return e2;
+        }(this.binaryString);
+    }
+    approximateByteSize() {
+        return 2 * this.binaryString.length;
+    }
+    compareTo(t3) {
+        return Jy(this.binaryString, t3.binaryString);
+    }
+    isEqual(t3) {
+        return this.binaryString === t3.binaryString;
+    }
+}
+ByteString.EMPTY_BYTE_STRING = new ByteString("");
+const cv = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
+
+function uv(t3) {
+    if (Gy(!!t3), "string" == typeof t3) {
+        let e2 = 0;
+        const i2 = cv.exec(t3);
+        if (Gy(!!i2), i2[1]) {
+            let t4 = i2[1];
+            t4 = (t4 + "000000000").substr(0, 9), e2 = Number(t4);
+        }
+        const s2 = new Date(t3);
+        return {
+            seconds: Math.floor(s2.getTime() / 1e3),
+            nanos: e2
+        };
+    }
+    return {
+        seconds: dv(t3.seconds),
+        nanos: dv(t3.nanos)
+    };
+}
+
+function dv(t3) {
+    return "number" == typeof t3 ? t3 : "string" == typeof t3 ? Number(t3) : 0;
+}
+
+function fv(t3) {
+    return "string" == typeof t3 ? ByteString.fromBase64String(t3) : ByteString.fromUint8Array(t3);
+}
+
+function pv(t3) {
+    var e2, i2;
+    return "server_timestamp" === (null === (i2 = ((null === (e2 = null == t3 ? void 0 : t3.mapValue) || void 0 === e2 ? void 0 : e2.fields) || {}).__type__) || void 0 === i2 ? void 0 : i2.stringValue);
+}
+
+function mv(t3) {
+    const e2 = t3.mapValue.fields.__previous_value__;
+    return pv(e2) ? mv(e2) : e2;
+}
+
+function gv(t3) {
+    const e2 = uv(t3.mapValue.fields.__local_write_time__.timestampValue);
+    return new Timestamp(e2.seconds, e2.nanos);
+}
+class DatabaseInfo {
+    constructor(t3, e2, i2, s2, n2, r2, o2, a2, l2) {
+        this.databaseId = t3, this.appId = e2, this.persistenceKey = i2, this.host = s2, this.ssl = n2, this.forceLongPolling = r2, this.autoDetectLongPolling = o2, this.longPollingOptions = a2, this.useFetchStreams = l2;
+    }
+}
+class DatabaseId {
+    constructor(t3, e2) {
+        this.projectId = t3, this.database = e2 || "(default)";
+    }
+    static empty() {
+        return new DatabaseId("", "");
+    }
+    get isDefaultDatabase() {
+        return "(default)" === this.database;
+    }
+    isEqual(t3) {
+        return t3 instanceof DatabaseId && t3.projectId === this.projectId && t3.database === this.database;
+    }
+}
+const yv = {
+    mapValue: {
+        fields: {
+            __type__: {
+                stringValue: "__max__"
+            }
+        }
+    }
+};
+
+function vv(t3) {
+    return "nullValue" in t3 ? 0 : "booleanValue" in t3 ? 1 : "integerValue" in t3 || "doubleValue" in t3 ? 2 : "timestampValue" in t3 ? 3 : "stringValue" in t3 ? 5 : "bytesValue" in t3 ? 6 : "referenceValue" in t3 ? 7 : "geoPointValue" in t3 ? 8 : "arrayValue" in t3 ? 9 : "mapValue" in t3 ? pv(t3) ? 4 : function(t4) {
+        return "__max__" === (((t4.mapValue || {}).fields || {}).__type__ || {}).stringValue;
+    }(t3) ? 9007199254740991 : 10 : Ky();
+}
+
+function bv(t3, e2) {
+    if (t3 === e2)
+        return true;
+    const i2 = vv(t3);
+    if (i2 !== vv(e2))
+        return false;
+    switch (i2) {
+        case 0:
+        case 9007199254740991:
+            return true;
+        case 1:
+            return t3.booleanValue === e2.booleanValue;
+        case 4:
+            return gv(t3).isEqual(gv(e2));
+        case 3:
+            return function(t4, e3) {
+                if ("string" == typeof t4.timestampValue && "string" == typeof e3.timestampValue && t4.timestampValue.length === e3.timestampValue.length)
+                    return t4.timestampValue === e3.timestampValue;
+                const i3 = uv(t4.timestampValue),
+                    s2 = uv(e3.timestampValue);
+                return i3.seconds === s2.seconds && i3.nanos === s2.nanos;
+            }(t3, e2);
+        case 5:
+            return t3.stringValue === e2.stringValue;
+        case 6:
+            return function(t4, e3) {
+                return fv(t4.bytesValue).isEqual(fv(e3.bytesValue));
+            }(t3, e2);
+        case 7:
+            return t3.referenceValue === e2.referenceValue;
+        case 8:
+            return function(t4, e3) {
+                return dv(t4.geoPointValue.latitude) === dv(e3.geoPointValue.latitude) && dv(t4.geoPointValue.longitude) === dv(e3.geoPointValue.longitude);
+            }(t3, e2);
+        case 2:
+            return function(t4, e3) {
+                if ("integerValue" in t4 && "integerValue" in e3)
+                    return dv(t4.integerValue) === dv(e3.integerValue);
+                if ("doubleValue" in t4 && "doubleValue" in e3) {
+                    const i3 = dv(t4.doubleValue),
+                        s2 = dv(e3.doubleValue);
+                    return i3 === s2 ? av(i3) === av(s2) : isNaN(i3) && isNaN(s2);
+                }
+                return false;
+            }(t3, e2);
+        case 9:
+            return Zy(t3.arrayValue.values || [], e2.arrayValue.values || [], bv);
+        case 10:
+            return function(t4, e3) {
+                const i3 = t4.mapValue.fields || {},
+                    s2 = e3.mapValue.fields || {};
+                if (lv(i3) !== lv(s2))
+                    return false;
+                for (const t5 in i3)
+                    if (i3.hasOwnProperty(t5) && (void 0 === s2[t5] || !bv(i3[t5], s2[t5])))
+                        return false;
+                return true;
+            }(t3, e2);
+        default:
+            return Ky();
+    }
+}
+
+function _v(t3, e2) {
+    return void 0 !== (t3.values || []).find((t4) => bv(t4, e2));
+}
+
+function wv(t3, e2) {
+    if (t3 === e2)
+        return 0;
+    const i2 = vv(t3),
+        s2 = vv(e2);
+    if (i2 !== s2)
+        return Jy(i2, s2);
+    switch (i2) {
+        case 0:
+        case 9007199254740991:
+            return 0;
+        case 1:
+            return Jy(t3.booleanValue, e2.booleanValue);
+        case 2:
+            return function(t4, e3) {
+                const i3 = dv(t4.integerValue || t4.doubleValue),
+                    s3 = dv(e3.integerValue || e3.doubleValue);
+                return i3 < s3 ? -1 : i3 > s3 ? 1 : i3 === s3 ? 0 : isNaN(i3) ? isNaN(s3) ? 0 : -1 : 1;
+            }(t3, e2);
+        case 3:
+            return xv(t3.timestampValue, e2.timestampValue);
+        case 4:
+            return xv(gv(t3), gv(e2));
+        case 5:
+            return Jy(t3.stringValue, e2.stringValue);
+        case 6:
+            return function(t4, e3) {
+                const i3 = fv(t4),
+                    s3 = fv(e3);
+                return i3.compareTo(s3);
+            }(t3.bytesValue, e2.bytesValue);
+        case 7:
+            return function(t4, e3) {
+                const i3 = t4.split("/"),
+                    s3 = e3.split("/");
+                for (let t5 = 0; t5 < i3.length && t5 < s3.length; t5++) {
+                    const e4 = Jy(i3[t5], s3[t5]);
+                    if (0 !== e4)
+                        return e4;
+                }
+                return Jy(i3.length, s3.length);
+            }(t3.referenceValue, e2.referenceValue);
+        case 8:
+            return function(t4, e3) {
+                const i3 = Jy(dv(t4.latitude), dv(e3.latitude));
+                return 0 !== i3 ? i3 : Jy(dv(t4.longitude), dv(e3.longitude));
+            }(t3.geoPointValue, e2.geoPointValue);
+        case 9:
+            return function(t4, e3) {
+                const i3 = t4.values || [],
+                    s3 = e3.values || [];
+                for (let t5 = 0; t5 < i3.length && t5 < s3.length; ++t5) {
+                    const e4 = wv(i3[t5], s3[t5]);
+                    if (e4)
+                        return e4;
+                }
+                return Jy(i3.length, s3.length);
+            }(t3.arrayValue, e2.arrayValue);
+        case 10:
+            return function(t4, e3) {
+                if (t4 === yv.mapValue && e3 === yv.mapValue)
+                    return 0;
+                if (t4 === yv.mapValue)
+                    return 1;
+                if (e3 === yv.mapValue)
+                    return -1;
+                const i3 = t4.fields || {},
+                    s3 = Object.keys(i3),
+                    n2 = e3.fields || {},
+                    r2 = Object.keys(n2);
+                s3.sort(), r2.sort();
+                for (let t5 = 0; t5 < s3.length && t5 < r2.length; ++t5) {
+                    const e4 = Jy(s3[t5], r2[t5]);
+                    if (0 !== e4)
+                        return e4;
+                    const o2 = wv(i3[s3[t5]], n2[r2[t5]]);
+                    if (0 !== o2)
+                        return o2;
+                }
+                return Jy(s3.length, r2.length);
+            }(t3.mapValue, e2.mapValue);
+        default:
+            throw Ky();
+    }
+}
+
+function xv(t3, e2) {
+    if ("string" == typeof t3 && "string" == typeof e2 && t3.length === e2.length)
+        return Jy(t3, e2);
+    const i2 = uv(t3),
+        s2 = uv(e2),
+        n2 = Jy(i2.seconds, s2.seconds);
+    return 0 !== n2 ? n2 : Jy(i2.nanos, s2.nanos);
+}
+
+function kv(t3) {
+    return Tv(t3);
+}
+
+function Tv(t3) {
+    return "nullValue" in t3 ? "null" : "booleanValue" in t3 ? "" + t3.booleanValue : "integerValue" in t3 ? "" + t3.integerValue : "doubleValue" in t3 ? "" + t3.doubleValue : "timestampValue" in t3 ? function(t4) {
+        const e2 = uv(t4);
+        return `time(${e2.seconds},${e2.nanos})`;
+    }(t3.timestampValue) : "stringValue" in t3 ? t3.stringValue : "bytesValue" in t3 ? function(t4) {
+        return fv(t4).toBase64();
+    }(t3.bytesValue) : "referenceValue" in t3 ? function(t4) {
+        return DocumentKey.fromName(t4).toString();
+    }(t3.referenceValue) : "geoPointValue" in t3 ? function(t4) {
+        return `geo(${t4.latitude},${t4.longitude})`;
+    }(t3.geoPointValue) : "arrayValue" in t3 ? function(t4) {
+        let e2 = "[",
+            i2 = true;
+        for (const s2 of t4.values || [])
+            i2 ? i2 = false : e2 += ",", e2 += Tv(s2);
+        return e2 + "]";
+    }(t3.arrayValue) : "mapValue" in t3 ? function(t4) {
+        const e2 = Object.keys(t4.fields || {}).sort();
+        let i2 = "{",
+            s2 = true;
+        for (const n2 of e2)
+            s2 ? s2 = false : i2 += ",", i2 += `${n2}:${Tv(t4.fields[n2])}`;
+        return i2 + "}";
+    }(t3.mapValue) : Ky();
+}
+
+function Sv(t3) {
+    return !!t3 && "integerValue" in t3;
+}
+
+function Ev(t3) {
+    return !!t3 && "arrayValue" in t3;
+}
+
+function Cv(t3) {
+    return !!t3 && "nullValue" in t3;
+}
+
+function Iv(t3) {
+    return !!t3 && "doubleValue" in t3 && isNaN(Number(t3.doubleValue));
+}
+
+function Mv(t3) {
+    return !!t3 && "mapValue" in t3;
+}
+
+function Pv(t3) {
+    if (t3.geoPointValue)
+        return {
+            geoPointValue: Object.assign({}, t3.geoPointValue)
+        };
+    if (t3.timestampValue && "object" == typeof t3.timestampValue)
+        return {
+            timestampValue: Object.assign({}, t3.timestampValue)
+        };
+    if (t3.mapValue) {
+        const e2 = {
+            mapValue: {
+                fields: {}
+            }
+        };
+        return hv(t3.mapValue.fields, (t4, i2) => e2.mapValue.fields[t4] = Pv(i2)), e2;
+    }
+    if (t3.arrayValue) {
+        const e2 = {
+            arrayValue: {
+                values: []
+            }
+        };
+        for (let i2 = 0; i2 < (t3.arrayValue.values || []).length; ++i2)
+            e2.arrayValue.values[i2] = Pv(t3.arrayValue.values[i2]);
+        return e2;
+    }
+    return Object.assign({}, t3);
+}
+class ObjectValue {
+    constructor(t3) {
+        this.value = t3;
+    }
+    static empty() {
+        return new ObjectValue({
+            mapValue: {}
+        });
+    }
+    field(t3) {
+        if (t3.isEmpty())
+            return this.value;
+        {
+            let e2 = this.value;
+            for (let i2 = 0; i2 < t3.length - 1; ++i2)
+                if (e2 = (e2.mapValue.fields || {})[t3.get(i2)], !Mv(e2))
+                    return null;
+            return e2 = (e2.mapValue.fields || {})[t3.lastSegment()], e2 || null;
+        }
+    }
+    set(t3, e2) {
+        this.getFieldsMap(t3.popLast())[t3.lastSegment()] = Pv(e2);
+    }
+    setAll(t3) {
+        let e2 = FieldPath$1.emptyPath(),
+            i2 = {},
+            s2 = [];
+        t3.forEach((t4, n3) => {
+            if (!e2.isImmediateParentOf(n3)) {
+                const t5 = this.getFieldsMap(e2);
+                this.applyChanges(t5, i2, s2), i2 = {}, s2 = [], e2 = n3.popLast();
+            }
+            t4 ? i2[n3.lastSegment()] = Pv(t4) : s2.push(n3.lastSegment());
+        });
+        const n2 = this.getFieldsMap(e2);
+        this.applyChanges(n2, i2, s2);
+    }
+    delete(t3) {
+        const e2 = this.field(t3.popLast());
+        Mv(e2) && e2.mapValue.fields && delete e2.mapValue.fields[t3.lastSegment()];
+    }
+    isEqual(t3) {
+        return bv(this.value, t3.value);
+    }
+    getFieldsMap(t3) {
+        let e2 = this.value;
+        e2.mapValue.fields || (e2.mapValue = {
+            fields: {}
+        });
+        for (let i2 = 0; i2 < t3.length; ++i2) {
+            let s2 = e2.mapValue.fields[t3.get(i2)];
+            Mv(s2) && s2.mapValue.fields || (s2 = {
+                mapValue: {
+                    fields: {}
+                }
+            }, e2.mapValue.fields[t3.get(i2)] = s2), e2 = s2;
+        }
+        return e2.mapValue.fields;
+    }
+    applyChanges(t3, e2, i2) {
+        hv(e2, (e3, i3) => t3[e3] = i3);
+        for (const e3 of i2)
+            delete t3[e3];
+    }
+    clone() {
+        return new ObjectValue(Pv(this.value));
+    }
+}
+class MutableDocument {
+    constructor(t3, e2, i2, s2, n2, r2, o2) {
+        this.key = t3, this.documentType = e2, this.version = i2, this.readTime = s2, this.createTime = n2, this.data = r2, this.documentState = o2;
+    }
+    static newInvalidDocument(t3) {
+        return new MutableDocument(t3, 0, SnapshotVersion.min(), SnapshotVersion.min(), SnapshotVersion.min(), ObjectValue.empty(), 0);
+    }
+    static newFoundDocument(t3, e2, i2, s2) {
+        return new MutableDocument(t3, 1, e2, SnapshotVersion.min(), i2, s2, 0);
+    }
+    static newNoDocument(t3, e2) {
+        return new MutableDocument(t3, 2, e2, SnapshotVersion.min(), SnapshotVersion.min(), ObjectValue.empty(), 0);
+    }
+    static newUnknownDocument(t3, e2) {
+        return new MutableDocument(t3, 3, e2, SnapshotVersion.min(), SnapshotVersion.min(), ObjectValue.empty(), 2);
+    }
+    convertToFoundDocument(t3, e2) {
+        return !this.createTime.isEqual(SnapshotVersion.min()) || 2 !== this.documentType && 0 !== this.documentType || (this.createTime = t3), this.version = t3, this.documentType = 1, this.data = e2, this.documentState = 0, this;
+    }
+    convertToNoDocument(t3) {
+        return this.version = t3, this.documentType = 2, this.data = ObjectValue.empty(), this.documentState = 0, this;
+    }
+    convertToUnknownDocument(t3) {
+        return this.version = t3, this.documentType = 3, this.data = ObjectValue.empty(), this.documentState = 2, this;
+    }
+    setHasCommittedMutations() {
+        return this.documentState = 2, this;
+    }
+    setHasLocalMutations() {
+        return this.documentState = 1, this.version = SnapshotVersion.min(), this;
+    }
+    setReadTime(t3) {
+        return this.readTime = t3, this;
+    }
+    get hasLocalMutations() {
+        return 1 === this.documentState;
+    }
+    get hasCommittedMutations() {
+        return 2 === this.documentState;
+    }
+    get hasPendingWrites() {
+        return this.hasLocalMutations || this.hasCommittedMutations;
+    }
+    isValidDocument() {
+        return 0 !== this.documentType;
+    }
+    isFoundDocument() {
+        return 1 === this.documentType;
+    }
+    isNoDocument() {
+        return 2 === this.documentType;
+    }
+    isUnknownDocument() {
+        return 3 === this.documentType;
+    }
+    isEqual(t3) {
+        return t3 instanceof MutableDocument && this.key.isEqual(t3.key) && this.version.isEqual(t3.version) && this.documentType === t3.documentType && this.documentState === t3.documentState && this.data.isEqual(t3.data);
+    }
+    mutableCopy() {
+        return new MutableDocument(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState);
+    }
+    toString() {
+        return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
+    }
+}
+class Bound {
+    constructor(t3, e2) {
+        this.position = t3, this.inclusive = e2;
+    }
+}
+
+function Rv(t3, e2, i2) {
+    let s2 = 0;
+    for (let n2 = 0; n2 < t3.position.length; n2++) {
+        const r2 = e2[n2],
+            o2 = t3.position[n2];
+        if (s2 = r2.field.isKeyField() ? DocumentKey.comparator(DocumentKey.fromName(o2.referenceValue), i2.key) : wv(o2, i2.data.field(r2.field)), "desc" === r2.dir && (s2 *= -1), 0 !== s2)
+            break;
+    }
+    return s2;
+}
+
+function Av(t3, e2) {
+    if (null === t3)
+        return null === e2;
+    if (null === e2)
+        return false;
+    if (t3.inclusive !== e2.inclusive || t3.position.length !== e2.position.length)
+        return false;
+    for (let i2 = 0; i2 < t3.position.length; i2++)
+        if (!bv(t3.position[i2], e2.position[i2]))
+            return false;
+    return true;
+}
+class OrderBy {
+    constructor(t3, e2 = "asc") {
+        this.field = t3, this.dir = e2;
+    }
+}
+
+function Dv(t3, e2) {
+    return t3.dir === e2.dir && t3.field.isEqual(e2.field);
+}
+class Filter {}
+class FieldFilter extends Filter {
+    constructor(t3, e2, i2) {
+        super(), this.field = t3, this.op = e2, this.value = i2;
+    }
+    static create(t3, e2, i2) {
+        return t3.isKeyField() ? "in" === e2 || "not-in" === e2 ? this.createKeyFieldInFilter(t3, e2, i2) : new __PRIVATE_KeyFieldFilter(t3, e2, i2) : "array-contains" === e2 ? new __PRIVATE_ArrayContainsFilter(t3, i2) : "in" === e2 ? new __PRIVATE_InFilter(t3, i2) : "not-in" === e2 ? new __PRIVATE_NotInFilter(t3, i2) : "array-contains-any" === e2 ? new __PRIVATE_ArrayContainsAnyFilter(t3, i2) : new FieldFilter(t3, e2, i2);
+    }
+    static createKeyFieldInFilter(t3, e2, i2) {
+        return "in" === e2 ? new __PRIVATE_KeyFieldInFilter(t3, i2) : new __PRIVATE_KeyFieldNotInFilter(t3, i2);
+    }
+    matches(t3) {
+        const e2 = t3.data.field(this.field);
+        return "!=" === this.op ? null !== e2 && this.matchesComparison(wv(e2, this.value)) : null !== e2 && vv(this.value) === vv(e2) && this.matchesComparison(wv(e2, this.value));
+    }
+    matchesComparison(t3) {
+        switch (this.op) {
+            case "<":
+                return t3 < 0;
+            case "<=":
+                return t3 <= 0;
+            case "==":
+                return 0 === t3;
+            case "!=":
+                return 0 !== t3;
+            case ">":
+                return t3 > 0;
+            case ">=":
+                return t3 >= 0;
+            default:
+                return Ky();
+        }
+    }
+    isInequality() {
+        return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0;
+    }
+    getFlattenedFilters() {
+        return [this];
+    }
+    getFilters() {
+        return [this];
+    }
+    getFirstInequalityField() {
+        return this.isInequality() ? this.field : null;
+    }
+}
+class CompositeFilter extends Filter {
+    constructor(t3, e2) {
+        super(), this.filters = t3, this.op = e2, this.ce = null;
+    }
+    static create(t3, e2) {
+        return new CompositeFilter(t3, e2);
+    }
+    matches(t3) {
+        return Lv(this) ? void 0 === this.filters.find((e2) => !e2.matches(t3)) : void 0 !== this.filters.find((e2) => e2.matches(t3));
+    }
+    getFlattenedFilters() {
+        return null !== this.ce || (this.ce = this.filters.reduce((t3, e2) => t3.concat(e2.getFlattenedFilters()), [])), this.ce;
+    }
+    getFilters() {
+        return Object.assign([], this.filters);
+    }
+    getFirstInequalityField() {
+        const t3 = this.le((t4) => t4.isInequality());
+        return null !== t3 ? t3.field : null;
+    }
+    le(t3) {
+        for (const e2 of this.getFlattenedFilters())
+            if (t3(e2))
+                return e2;
+        return null;
+    }
+}
+
+function Lv(t3) {
+    return "and" === t3.op;
+}
+
+function Ov(t3) {
+    return function(t4) {
+        for (const e2 of t4.filters)
+            if (e2 instanceof CompositeFilter)
+                return false;
+        return true;
+    }(t3) && Lv(t3);
+}
+
+function Fv(t3) {
+    if (t3 instanceof FieldFilter)
+        return t3.field.canonicalString() + t3.op.toString() + kv(t3.value);
+    if (Ov(t3))
+        return t3.filters.map((t4) => Fv(t4)).join(",");
+    {
+        const e2 = t3.filters.map((t4) => Fv(t4)).join(",");
+        return `${t3.op}(${e2})`;
+    }
+}
+
+function Nv(t3, e2) {
+    return t3 instanceof FieldFilter ? function(t4, e3) {
+        return e3 instanceof FieldFilter && t4.op === e3.op && t4.field.isEqual(e3.field) && bv(t4.value, e3.value);
+    }(t3, e2) : t3 instanceof CompositeFilter ? function(t4, e3) {
+        return e3 instanceof CompositeFilter && t4.op === e3.op && t4.filters.length === e3.filters.length && t4.filters.reduce((t5, i2, s2) => t5 && Nv(i2, e3.filters[s2]), true);
+    }(t3, e2) : void Ky();
+}
+
+function $v(t3) {
+    return t3 instanceof FieldFilter ? function(t4) {
+        return `${t4.field.canonicalString()} ${t4.op} ${kv(t4.value)}`;
+    }(t3) : t3 instanceof CompositeFilter ? function(t4) {
+        return t4.op.toString() + " {" + t4.getFilters().map($v).join(" ,") + "}";
+    }(t3) : "Filter";
+}
+class __PRIVATE_KeyFieldFilter extends FieldFilter {
+    constructor(t3, e2, i2) {
+        super(t3, e2, i2), this.key = DocumentKey.fromName(i2.referenceValue);
+    }
+    matches(t3) {
+        const e2 = DocumentKey.comparator(t3.key, this.key);
+        return this.matchesComparison(e2);
+    }
+}
+class __PRIVATE_KeyFieldInFilter extends FieldFilter {
+    constructor(t3, e2) {
+        super(t3, "in", e2), this.keys = Vv("in", e2);
+    }
+    matches(t3) {
+        return this.keys.some((e2) => e2.isEqual(t3.key));
+    }
+}
+class __PRIVATE_KeyFieldNotInFilter extends FieldFilter {
+    constructor(t3, e2) {
+        super(t3, "not-in", e2), this.keys = Vv("not-in", e2);
+    }
+    matches(t3) {
+        return !this.keys.some((e2) => e2.isEqual(t3.key));
+    }
+}
+
+function Vv(t3, e2) {
+    var i2;
+    return ((null === (i2 = e2.arrayValue) || void 0 === i2 ? void 0 : i2.values) || []).map((t4) => DocumentKey.fromName(t4.referenceValue));
+}
+class __PRIVATE_ArrayContainsFilter extends FieldFilter {
+    constructor(t3, e2) {
+        super(t3, "array-contains", e2);
+    }
+    matches(t3) {
+        const e2 = t3.data.field(this.field);
+        return Ev(e2) && _v(e2.arrayValue, this.value);
+    }
+}
+class __PRIVATE_InFilter extends FieldFilter {
+    constructor(t3, e2) {
+        super(t3, "in", e2);
+    }
+    matches(t3) {
+        const e2 = t3.data.field(this.field);
+        return null !== e2 && _v(this.value.arrayValue, e2);
+    }
+}
+class __PRIVATE_NotInFilter extends FieldFilter {
+    constructor(t3, e2) {
+        super(t3, "not-in", e2);
+    }
+    matches(t3) {
+        if (_v(this.value.arrayValue, {
+                nullValue: "NULL_VALUE"
+            }))
+            return false;
+        const e2 = t3.data.field(this.field);
+        return null !== e2 && !_v(this.value.arrayValue, e2);
+    }
+}
+class __PRIVATE_ArrayContainsAnyFilter extends FieldFilter {
+    constructor(t3, e2) {
+        super(t3, "array-contains-any", e2);
+    }
+    matches(t3) {
+        const e2 = t3.data.field(this.field);
+        return !(!Ev(e2) || !e2.arrayValue.values) && e2.arrayValue.values.some((t4) => _v(this.value.arrayValue, t4));
+    }
+}
+class __PRIVATE_TargetImpl {
+    constructor(t3, e2 = null, i2 = [], s2 = [], n2 = null, r2 = null, o2 = null) {
+        this.path = t3, this.collectionGroup = e2, this.orderBy = i2, this.filters = s2, this.limit = n2, this.startAt = r2, this.endAt = o2, this.he = null;
+    }
+}
+
+function zv(t3, e2 = null, i2 = [], s2 = [], n2 = null, r2 = null, o2 = null) {
+    return new __PRIVATE_TargetImpl(t3, e2, i2, s2, n2, r2, o2);
+}
+
+function Bv(t3) {
+    const e2 = Yy(t3);
+    if (null === e2.he) {
+        let t4 = e2.path.canonicalString();
+        null !== e2.collectionGroup && (t4 += "|cg:" + e2.collectionGroup), t4 += "|f:", t4 += e2.filters.map((t5) => Fv(t5)).join(","), t4 += "|ob:", t4 += e2.orderBy.map((t5) => function(t6) {
+            return t6.field.canonicalString() + t6.dir;
+        }(t5)).join(","), ov(e2.limit) || (t4 += "|l:", t4 += e2.limit), e2.startAt && (t4 += "|lb:", t4 += e2.startAt.inclusive ? "b:" : "a:", t4 += e2.startAt.position.map((t5) => kv(t5)).join(",")), e2.endAt && (t4 += "|ub:", t4 += e2.endAt.inclusive ? "a:" : "b:", t4 += e2.endAt.position.map((t5) => kv(t5)).join(",")), e2.he = t4;
+    }
+    return e2.he;
+}
+
+function Uv(t3, e2) {
+    if (t3.limit !== e2.limit)
+        return false;
+    if (t3.orderBy.length !== e2.orderBy.length)
+        return false;
+    for (let i2 = 0; i2 < t3.orderBy.length; i2++)
+        if (!Dv(t3.orderBy[i2], e2.orderBy[i2]))
+            return false;
+    if (t3.filters.length !== e2.filters.length)
+        return false;
+    for (let i2 = 0; i2 < t3.filters.length; i2++)
+        if (!Nv(t3.filters[i2], e2.filters[i2]))
+            return false;
+    return t3.collectionGroup === e2.collectionGroup && !!t3.path.isEqual(e2.path) && !!Av(t3.startAt, e2.startAt) && Av(t3.endAt, e2.endAt);
+}
+
+function jv(t3) {
+    return DocumentKey.isDocumentKey(t3.path) && null === t3.collectionGroup && 0 === t3.filters.length;
+}
+class __PRIVATE_QueryImpl {
+    constructor(t3, e2 = null, i2 = [], s2 = [], n2 = null, r2 = "F", o2 = null, a2 = null) {
+        this.path = t3, this.collectionGroup = e2, this.explicitOrderBy = i2, this.filters = s2, this.limit = n2, this.limitType = r2, this.startAt = o2, this.endAt = a2, this.Pe = null, this.Ie = null, this.startAt, this.endAt;
+    }
+}
+
+function Hv(t3) {
+    return new __PRIVATE_QueryImpl(t3);
+}
+
+function Wv(t3) {
+    return 0 === t3.filters.length && null === t3.limit && null == t3.startAt && null == t3.endAt && (0 === t3.explicitOrderBy.length || 1 === t3.explicitOrderBy.length && t3.explicitOrderBy[0].field.isKeyField());
+}
+
+function qv(t3) {
+    const e2 = Yy(t3);
+    if (null === e2.Pe) {
+        e2.Pe = [];
+        const t4 = function(t5) {
+                for (const e3 of t5.filters) {
+                    const t6 = e3.getFirstInequalityField();
+                    if (null !== t6)
+                        return t6;
+                }
+                return null;
+            }(e2),
+            i2 = function(t5) {
+                return t5.explicitOrderBy.length > 0 ? t5.explicitOrderBy[0].field : null;
+            }(e2);
+        if (null !== t4 && null === i2)
+            t4.isKeyField() || e2.Pe.push(new OrderBy(t4)), e2.Pe.push(new OrderBy(FieldPath$1.keyField(), "asc"));
+        else {
+            let t5 = false;
+            for (const i3 of e2.explicitOrderBy)
+                e2.Pe.push(i3), i3.field.isKeyField() && (t5 = true);
+            if (!t5) {
+                const t6 = e2.explicitOrderBy.length > 0 ? e2.explicitOrderBy[e2.explicitOrderBy.length - 1].dir : "asc";
+                e2.Pe.push(new OrderBy(FieldPath$1.keyField(), t6));
+            }
+        }
+    }
+    return e2.Pe;
+}
+
+function Kv(t3) {
+    const e2 = Yy(t3);
+    if (!e2.Ie)
+        if ("F" === e2.limitType)
+            e2.Ie = zv(e2.path, e2.collectionGroup, qv(e2), e2.filters, e2.limit, e2.startAt, e2.endAt);
+        else {
+            const t4 = [];
+            for (const i3 of qv(e2)) {
+                const e3 = "desc" === i3.dir ? "asc" : "desc";
+                t4.push(new OrderBy(i3.field, e3));
+            }
+            const i2 = e2.endAt ? new Bound(e2.endAt.position, e2.endAt.inclusive) : null,
+                s2 = e2.startAt ? new Bound(e2.startAt.position, e2.startAt.inclusive) : null;
+            e2.Ie = zv(e2.path, e2.collectionGroup, t4, e2.filters, e2.limit, i2, s2);
+        }
+    return e2.Ie;
+}
+
+function Gv(t3, e2, i2) {
+    return new __PRIVATE_QueryImpl(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), e2, i2, t3.startAt, t3.endAt);
+}
+
+function Yv(t3, e2) {
+    return Uv(Kv(t3), Kv(e2)) && t3.limitType === e2.limitType;
+}
+
+function Qv(t3) {
+    return `${Bv(Kv(t3))}|lt:${t3.limitType}`;
+}
+
+function Xv(t3) {
+    return `Query(target=${function(t4) {
+    let e2 = t4.path.canonicalString();
+    return null !== t4.collectionGroup && (e2 += " collectionGroup=" + t4.collectionGroup), t4.filters.length > 0 && (e2 += `, filters: [${t4.filters.map((t5) => $v(t5)).join(", ")}]`), ov(t4.limit) || (e2 += ", limit: " + t4.limit), t4.orderBy.length > 0 && (e2 += `, orderBy: [${t4.orderBy.map((t5) => function(t6) {
+      return `${t6.field.canonicalString()} (${t6.dir})`;
+    }(t5)).join(", ")}]`), t4.startAt && (e2 += ", startAt: ", e2 += t4.startAt.inclusive ? "b:" : "a:", e2 += t4.startAt.position.map((t5) => kv(t5)).join(",")), t4.endAt && (e2 += ", endAt: ", e2 += t4.endAt.inclusive ? "a:" : "b:", e2 += t4.endAt.position.map((t5) => kv(t5)).join(",")), `Target(${e2})`;
+  }(Kv(t3))}; limitType=${t3.limitType})`;
+}
+
+function Jv(t3, e2) {
+    return e2.isFoundDocument() && function(t4, e3) {
+        const i2 = e3.key.path;
+        return null !== t4.collectionGroup ? e3.key.hasCollectionId(t4.collectionGroup) && t4.path.isPrefixOf(i2) : DocumentKey.isDocumentKey(t4.path) ? t4.path.isEqual(i2) : t4.path.isImmediateParentOf(i2);
+    }(t3, e2) && function(t4, e3) {
+        for (const i2 of qv(t4))
+            if (!i2.field.isKeyField() && null === e3.data.field(i2.field))
+                return false;
+        return true;
+    }(t3, e2) && function(t4, e3) {
+        for (const i2 of t4.filters)
+            if (!i2.matches(e3))
+                return false;
+        return true;
+    }(t3, e2) && function(t4, e3) {
+        return !(t4.startAt && ! function(t5, e4, i2) {
+            const s2 = Rv(t5, e4, i2);
+            return t5.inclusive ? s2 <= 0 : s2 < 0;
+        }(t4.startAt, qv(t4), e3)) && !(t4.endAt && ! function(t5, e4, i2) {
+            const s2 = Rv(t5, e4, i2);
+            return t5.inclusive ? s2 >= 0 : s2 > 0;
+        }(t4.endAt, qv(t4), e3));
+    }(t3, e2);
+}
+
+function Zv(t3) {
+    return (e2, i2) => {
+        let s2 = false;
+        for (const n2 of qv(t3)) {
+            const t4 = tb(n2, e2, i2);
+            if (0 !== t4)
+                return t4;
+            s2 = s2 || n2.field.isKeyField();
+        }
+        return 0;
+    };
+}
+
+function tb(t3, e2, i2) {
+    const s2 = t3.field.isKeyField() ? DocumentKey.comparator(e2.key, i2.key) : function(t4, e3, i3) {
+        const s3 = e3.data.field(t4),
+            n2 = i3.data.field(t4);
+        return null !== s3 && null !== n2 ? wv(s3, n2) : Ky();
+    }(t3.field, e2, i2);
+    switch (t3.dir) {
+        case "asc":
+            return s2;
+        case "desc":
+            return -1 * s2;
+        default:
+            return Ky();
+    }
+}
+class ObjectMap {
+    constructor(t3, e2) {
+        this.mapKeyFn = t3, this.equalsFn = e2, this.inner = {}, this.innerSize = 0;
+    }
+    get(t3) {
+        const e2 = this.mapKeyFn(t3),
+            i2 = this.inner[e2];
+        if (void 0 !== i2) {
+            for (const [e3, s2] of i2)
+                if (this.equalsFn(e3, t3))
+                    return s2;
+        }
+    }
+    has(t3) {
+        return void 0 !== this.get(t3);
+    }
+    set(t3, e2) {
+        const i2 = this.mapKeyFn(t3),
+            s2 = this.inner[i2];
+        if (void 0 === s2)
+            return this.inner[i2] = [
+                [t3, e2]
+            ], void this.innerSize++;
+        for (let i3 = 0; i3 < s2.length; i3++)
+            if (this.equalsFn(s2[i3][0], t3))
+                return void(s2[i3] = [t3, e2]);
+        s2.push([t3, e2]), this.innerSize++;
+    }
+    delete(t3) {
+        const e2 = this.mapKeyFn(t3),
+            i2 = this.inner[e2];
+        if (void 0 === i2)
+            return false;
+        for (let s2 = 0; s2 < i2.length; s2++)
+            if (this.equalsFn(i2[s2][0], t3))
+                return 1 === i2.length ? delete this.inner[e2] : i2.splice(s2, 1), this.innerSize--, true;
+        return false;
+    }
+    forEach(t3) {
+        hv(this.inner, (e2, i2) => {
+            for (const [e3, s2] of i2)
+                t3(e3, s2);
+        });
+    }
+    isEmpty() {
+        return function(t3) {
+            for (const e2 in t3)
+                if (Object.prototype.hasOwnProperty.call(t3, e2))
+                    return false;
+            return true;
+        }(this.inner);
+    }
+    size() {
+        return this.innerSize;
+    }
+}
+const eb = new SortedMap(DocumentKey.comparator);
+
+function ib() {
+    return eb;
+}
+const sb = new SortedMap(DocumentKey.comparator);
+
+function rb(...t3) {
+    let e2 = sb;
+    for (const i2 of t3)
+        e2 = e2.insert(i2.key, i2);
+    return e2;
+}
+
+function ob(t3) {
+    let e2 = sb;
+    return t3.forEach((t4, i2) => e2 = e2.insert(t4, i2.overlayedDocument)), e2;
+}
+
+function ab() {
+    return hb();
+}
+
+function lb() {
+    return hb();
+}
+
+function hb() {
+    return new ObjectMap((t3) => t3.toString(), (t3, e2) => t3.isEqual(e2));
+}
+const cb = new SortedSet(DocumentKey.comparator);
+
+function ub(...t3) {
+    let e2 = cb;
+    for (const i2 of t3)
+        e2 = e2.add(i2);
+    return e2;
+}
+const db = new SortedSet(Jy);
+class TransformOperation {
+    constructor() {
+        this._ = void 0;
+    }
+}
+
+function fb(t3, e2, i2) {
+    return t3 instanceof __PRIVATE_ServerTimestampTransform ? function(t4, e3) {
+        const i3 = {
+            fields: {
+                __type__: {
+                    stringValue: "server_timestamp"
+                },
+                __local_write_time__: {
+                    timestampValue: {
+                        seconds: t4.seconds,
+                        nanos: t4.nanoseconds
+                    }
+                }
+            }
+        };
+        return e3 && pv(e3) && (e3 = mv(e3)), e3 && (i3.fields.__previous_value__ = e3), {
+            mapValue: i3
+        };
+    }(i2, e2) : t3 instanceof __PRIVATE_ArrayUnionTransformOperation ? gb(t3, e2) : t3 instanceof __PRIVATE_ArrayRemoveTransformOperation ? yb(t3, e2) : function(t4, e3) {
+        const i3 = function(t5, e4) {
+                return t5 instanceof __PRIVATE_NumericIncrementTransformOperation ? function(t6) {
+                    return Sv(t6) || function(t7) {
+                        return !!t7 && "doubleValue" in t7;
+                    }(t6);
+                }(e4) ? e4 : {
+                    integerValue: 0
+                } : null;
+            }(t4, e3),
+            s2 = vb(i3) + vb(t4.Te);
+        return Sv(i3) && Sv(t4.Te) ? function(t5) {
+            return {
+                integerValue: "" + t5
+            };
+        }(s2) : function(t5, e4) {
+            if (t5.useProto3Json) {
+                if (isNaN(e4))
+                    return {
+                        doubleValue: "NaN"
+                    };
+                if (e4 === 1 / 0)
+                    return {
+                        doubleValue: "Infinity"
+                    };
+                if (e4 === -1 / 0)
+                    return {
+                        doubleValue: "-Infinity"
+                    };
+            }
+            return {
+                doubleValue: av(e4) ? "-0" : e4
+            };
+        }(t4.serializer, s2);
+    }(t3, e2);
+}
+
+function mb(t3, e2, i2) {
+    return t3 instanceof __PRIVATE_ArrayUnionTransformOperation ? gb(t3, e2) : t3 instanceof __PRIVATE_ArrayRemoveTransformOperation ? yb(t3, e2) : i2;
+}
+class __PRIVATE_ServerTimestampTransform extends TransformOperation {}
+class __PRIVATE_ArrayUnionTransformOperation extends TransformOperation {
+    constructor(t3) {
+        super(), this.elements = t3;
+    }
+}
+
+function gb(t3, e2) {
+    const i2 = bb(e2);
+    for (const e3 of t3.elements)
+        i2.some((t4) => bv(t4, e3)) || i2.push(e3);
+    return {
+        arrayValue: {
+            values: i2
+        }
+    };
+}
+class __PRIVATE_ArrayRemoveTransformOperation extends TransformOperation {
+    constructor(t3) {
+        super(), this.elements = t3;
+    }
+}
+
+function yb(t3, e2) {
+    let i2 = bb(e2);
+    for (const e3 of t3.elements)
+        i2 = i2.filter((t4) => !bv(t4, e3));
+    return {
+        arrayValue: {
+            values: i2
+        }
+    };
+}
+class __PRIVATE_NumericIncrementTransformOperation extends TransformOperation {
+    constructor(t3, e2) {
+        super(), this.serializer = t3, this.Te = e2;
+    }
+}
+
+function vb(t3) {
+    return dv(t3.integerValue || t3.doubleValue);
+}
+
+function bb(t3) {
+    return Ev(t3) && t3.arrayValue.values ? t3.arrayValue.values.slice() : [];
+}
+class Precondition {
+    constructor(t3, e2) {
+        this.updateTime = t3, this.exists = e2;
+    }
+    static none() {
+        return new Precondition();
+    }
+    static exists(t3) {
+        return new Precondition(void 0, t3);
+    }
+    static updateTime(t3) {
+        return new Precondition(t3);
+    }
+    get isNone() {
+        return void 0 === this.updateTime && void 0 === this.exists;
+    }
+    isEqual(t3) {
+        return this.exists === t3.exists && (this.updateTime ? !!t3.updateTime && this.updateTime.isEqual(t3.updateTime) : !t3.updateTime);
+    }
+}
+
+function _b(t3, e2) {
+    return void 0 !== t3.updateTime ? e2.isFoundDocument() && e2.version.isEqual(t3.updateTime) : void 0 === t3.exists || t3.exists === e2.isFoundDocument();
+}
+class Mutation {}
+
+function wb(t3, e2) {
+    if (!t3.hasLocalMutations || e2 && 0 === e2.fields.length)
+        return null;
+    if (null === e2)
+        return t3.isNoDocument() ? new __PRIVATE_DeleteMutation(t3.key, Precondition.none()) : new __PRIVATE_SetMutation(t3.key, t3.data, Precondition.none());
+    {
+        const i2 = t3.data,
+            s2 = ObjectValue.empty();
+        let n2 = new SortedSet(FieldPath$1.comparator);
+        for (let t4 of e2.fields)
+            if (!n2.has(t4)) {
+                let e3 = i2.field(t4);
+                null === e3 && t4.length > 1 && (t4 = t4.popLast(), e3 = i2.field(t4)), null === e3 ? s2.delete(t4) : s2.set(t4, e3), n2 = n2.add(t4);
+            }
+        return new __PRIVATE_PatchMutation(t3.key, s2, new FieldMask(n2.toArray()), Precondition.none());
+    }
+}
+
+function xb(t3, e2, i2) {
+    t3 instanceof __PRIVATE_SetMutation ? function(t4, e3, i3) {
+        const s2 = t4.value.clone(),
+            n2 = Cb(t4.fieldTransforms, e3, i3.transformResults);
+        s2.setAll(n2), e3.convertToFoundDocument(i3.version, s2).setHasCommittedMutations();
+    }(t3, e2, i2) : t3 instanceof __PRIVATE_PatchMutation ? function(t4, e3, i3) {
+        if (!_b(t4.precondition, e3))
+            return void e3.convertToUnknownDocument(i3.version);
+        const s2 = Cb(t4.fieldTransforms, e3, i3.transformResults),
+            n2 = e3.data;
+        n2.setAll(Eb(t4)), n2.setAll(s2), e3.convertToFoundDocument(i3.version, n2).setHasCommittedMutations();
+    }(t3, e2, i2) : function(t4, e3, i3) {
+        e3.convertToNoDocument(i3.version).setHasCommittedMutations();
+    }(0, e2, i2);
+}
+
+function Tb(t3, e2, i2, s2) {
+    return t3 instanceof __PRIVATE_SetMutation ? function(t4, e3, i3, s3) {
+        if (!_b(t4.precondition, e3))
+            return i3;
+        const n2 = t4.value.clone(),
+            r2 = Ib(t4.fieldTransforms, s3, e3);
+        return n2.setAll(r2), e3.convertToFoundDocument(e3.version, n2).setHasLocalMutations(), null;
+    }(t3, e2, i2, s2) : t3 instanceof __PRIVATE_PatchMutation ? function(t4, e3, i3, s3) {
+        if (!_b(t4.precondition, e3))
+            return i3;
+        const n2 = Ib(t4.fieldTransforms, s3, e3),
+            r2 = e3.data;
+        return r2.setAll(Eb(t4)), r2.setAll(n2), e3.convertToFoundDocument(e3.version, r2).setHasLocalMutations(), null === i3 ? null : i3.unionWith(t4.fieldMask.fields).unionWith(t4.fieldTransforms.map((t5) => t5.field));
+    }(t3, e2, i2, s2) : function(t4, e3, i3) {
+        return _b(t4.precondition, e3) ? (e3.convertToNoDocument(e3.version).setHasLocalMutations(), null) : i3;
+    }(t3, e2, i2);
+}
+
+function Sb(t3, e2) {
+    return t3.type === e2.type && !!t3.key.isEqual(e2.key) && !!t3.precondition.isEqual(e2.precondition) && !! function(t4, e3) {
+        return void 0 === t4 && void 0 === e3 || !(!t4 || !e3) && Zy(t4, e3, (t5, e4) => function(t6, e5) {
+            return t6.field.isEqual(e5.field) && function(t7, e6) {
+                return t7 instanceof __PRIVATE_ArrayUnionTransformOperation && e6 instanceof __PRIVATE_ArrayUnionTransformOperation || t7 instanceof __PRIVATE_ArrayRemoveTransformOperation && e6 instanceof __PRIVATE_ArrayRemoveTransformOperation ? Zy(t7.elements, e6.elements, bv) : t7 instanceof __PRIVATE_NumericIncrementTransformOperation && e6 instanceof __PRIVATE_NumericIncrementTransformOperation ? bv(t7.Te, e6.Te) : t7 instanceof __PRIVATE_ServerTimestampTransform && e6 instanceof __PRIVATE_ServerTimestampTransform;
+            }(t6.transform, e5.transform);
+        }(t5, e4));
+    }(t3.fieldTransforms, e2.fieldTransforms) && (0 === t3.type ? t3.value.isEqual(e2.value) : 1 !== t3.type || t3.data.isEqual(e2.data) && t3.fieldMask.isEqual(e2.fieldMask));
+}
+class __PRIVATE_SetMutation extends Mutation {
+    constructor(t3, e2, i2, s2 = []) {
+        super(), this.key = t3, this.value = e2, this.precondition = i2, this.fieldTransforms = s2, this.type = 0;
+    }
+    getFieldMask() {
+        return null;
+    }
+}
+class __PRIVATE_PatchMutation extends Mutation {
+    constructor(t3, e2, i2, s2, n2 = []) {
+        super(), this.key = t3, this.data = e2, this.fieldMask = i2, this.precondition = s2, this.fieldTransforms = n2, this.type = 1;
+    }
+    getFieldMask() {
+        return this.fieldMask;
+    }
+}
+
+function Eb(t3) {
+    const e2 = /* @__PURE__ */ new Map();
+    return t3.fieldMask.fields.forEach((i2) => {
+        if (!i2.isEmpty()) {
+            const s2 = t3.data.field(i2);
+            e2.set(i2, s2);
+        }
+    }), e2;
+}
+
+function Cb(t3, e2, i2) {
+    const s2 = /* @__PURE__ */ new Map();
+    Gy(t3.length === i2.length);
+    for (let n2 = 0; n2 < i2.length; n2++) {
+        const r2 = t3[n2],
+            o2 = r2.transform,
+            a2 = e2.data.field(r2.field);
+        s2.set(r2.field, mb(o2, a2, i2[n2]));
+    }
+    return s2;
+}
+
+function Ib(t3, e2, i2) {
+    const s2 = /* @__PURE__ */ new Map();
+    for (const n2 of t3) {
+        const t4 = n2.transform,
+            r2 = i2.data.field(n2.field);
+        s2.set(n2.field, fb(t4, r2, e2));
+    }
+    return s2;
+}
+class __PRIVATE_DeleteMutation extends Mutation {
+    constructor(t3, e2) {
+        super(), this.key = t3, this.precondition = e2, this.type = 2, this.fieldTransforms = [];
+    }
+    getFieldMask() {
+        return null;
+    }
+}
+class MutationBatch {
+    constructor(t3, e2, i2, s2) {
+        this.batchId = t3, this.localWriteTime = e2, this.baseMutations = i2, this.mutations = s2;
+    }
+    applyToRemoteDocument(t3, e2) {
+        const i2 = e2.mutationResults;
+        for (let e3 = 0; e3 < this.mutations.length; e3++) {
+            const s2 = this.mutations[e3];
+            s2.key.isEqual(t3.key) && xb(s2, t3, i2[e3]);
+        }
+    }
+    applyToLocalView(t3, e2) {
+        for (const i2 of this.baseMutations)
+            i2.key.isEqual(t3.key) && (e2 = Tb(i2, t3, e2, this.localWriteTime));
+        for (const i2 of this.mutations)
+            i2.key.isEqual(t3.key) && (e2 = Tb(i2, t3, e2, this.localWriteTime));
+        return e2;
+    }
+    applyToLocalDocumentSet(t3, e2) {
+        const i2 = lb();
+        return this.mutations.forEach((s2) => {
+            const n2 = t3.get(s2.key),
+                r2 = n2.overlayedDocument;
+            let o2 = this.applyToLocalView(r2, n2.mutatedFields);
+            o2 = e2.has(s2.key) ? null : o2;
+            const a2 = wb(r2, o2);
+            null !== a2 && i2.set(s2.key, a2), r2.isValidDocument() || r2.convertToNoDocument(SnapshotVersion.min());
+        }), i2;
+    }
+    keys() {
+        return this.mutations.reduce((t3, e2) => t3.add(e2.key), ub());
+    }
+    isEqual(t3) {
+        return this.batchId === t3.batchId && Zy(this.mutations, t3.mutations, (t4, e2) => Sb(t4, e2)) && Zy(this.baseMutations, t3.baseMutations, (t4, e2) => Sb(t4, e2));
+    }
+}
+class Overlay {
+    constructor(t3, e2) {
+        this.largestBatchId = t3, this.mutation = e2;
+    }
+    getKey() {
+        return this.mutation.key;
+    }
+    isEqual(t3) {
+        return null !== t3 && this.mutation === t3.mutation;
+    }
+    toString() {
+        return `Overlay{
+      largestBatchId: ${this.largestBatchId},
+      mutation: ${this.mutation.toString()}
+    }`;
+    }
+}
+class ExistenceFilter {
+    constructor(t3, e2) {
+        this.count = t3, this.unchangedNames = e2;
+    }
+}
+var Mb, Pb;
+
+function Rb(t3) {
+    if (void 0 === t3)
+        return Hy("GRPC error has no .code"), Qy.UNKNOWN;
+    switch (t3) {
+        case Mb.OK:
+            return Qy.OK;
+        case Mb.CANCELLED:
+            return Qy.CANCELLED;
+        case Mb.UNKNOWN:
+            return Qy.UNKNOWN;
+        case Mb.DEADLINE_EXCEEDED:
+            return Qy.DEADLINE_EXCEEDED;
+        case Mb.RESOURCE_EXHAUSTED:
+            return Qy.RESOURCE_EXHAUSTED;
+        case Mb.INTERNAL:
+            return Qy.INTERNAL;
+        case Mb.UNAVAILABLE:
+            return Qy.UNAVAILABLE;
+        case Mb.UNAUTHENTICATED:
+            return Qy.UNAUTHENTICATED;
+        case Mb.INVALID_ARGUMENT:
+            return Qy.INVALID_ARGUMENT;
+        case Mb.NOT_FOUND:
+            return Qy.NOT_FOUND;
+        case Mb.ALREADY_EXISTS:
+            return Qy.ALREADY_EXISTS;
+        case Mb.PERMISSION_DENIED:
+            return Qy.PERMISSION_DENIED;
+        case Mb.FAILED_PRECONDITION:
+            return Qy.FAILED_PRECONDITION;
+        case Mb.ABORTED:
+            return Qy.ABORTED;
+        case Mb.OUT_OF_RANGE:
+            return Qy.OUT_OF_RANGE;
+        case Mb.UNIMPLEMENTED:
+            return Qy.UNIMPLEMENTED;
+        case Mb.DATA_LOSS:
+            return Qy.DATA_LOSS;
+        default:
+            return Ky();
+    }
+}
+(Pb = Mb || (Mb = {}))[Pb.OK = 0] = "OK", Pb[Pb.CANCELLED = 1] = "CANCELLED", Pb[Pb.UNKNOWN = 2] = "UNKNOWN", Pb[Pb.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", Pb[Pb.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", Pb[Pb.NOT_FOUND = 5] = "NOT_FOUND", Pb[Pb.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", Pb[Pb.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", Pb[Pb.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", Pb[Pb.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", Pb[Pb.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", Pb[Pb.ABORTED = 10] = "ABORTED", Pb[Pb.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", Pb[Pb.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", Pb[Pb.INTERNAL = 13] = "INTERNAL", Pb[Pb.UNAVAILABLE = 14] = "UNAVAILABLE", Pb[Pb.DATA_LOSS = 15] = "DATA_LOSS";
+class __PRIVATE_TestingHooks {
+    constructor() {
+        this.onExistenceFilterMismatchCallbacks = /* @__PURE__ */ new Map();
+    }
+    static get instance() {
+        return Db;
+    }
+    static getOrCreateInstance() {
+        return null === Db && (Db = new __PRIVATE_TestingHooks()), Db;
+    }
+    onExistenceFilterMismatch(t3) {
+        const e2 = Symbol();
+        return this.onExistenceFilterMismatchCallbacks.set(e2, t3), () => this.onExistenceFilterMismatchCallbacks.delete(e2);
+    }
+    notifyOnExistenceFilterMismatch(t3) {
+        this.onExistenceFilterMismatchCallbacks.forEach((e2) => e2(t3));
+    }
+}
+let Db = null;
+const Lb = new $y([4294967295, 4294967295], 0);
+
+function Ob(t3) {
+    const e2 = new TextEncoder().encode(t3),
+        i2 = new Ny();
+    return i2.update(e2), new Uint8Array(i2.digest());
+}
+
+function Fb(t3) {
+    const e2 = new DataView(t3.buffer),
+        i2 = e2.getUint32(0, true),
+        s2 = e2.getUint32(4, true),
+        n2 = e2.getUint32(8, true),
+        r2 = e2.getUint32(12, true);
+    return [new $y([i2, s2], 0), new $y([n2, r2], 0)];
+}
+class BloomFilter {
+    constructor(t3, e2, i2) {
+        if (this.bitmap = t3, this.padding = e2, this.hashCount = i2, e2 < 0 || e2 >= 8)
+            throw new __PRIVATE_BloomFilterError(`Invalid padding: ${e2}`);
+        if (i2 < 0)
+            throw new __PRIVATE_BloomFilterError(`Invalid hash count: ${i2}`);
+        if (t3.length > 0 && 0 === this.hashCount)
+            throw new __PRIVATE_BloomFilterError(`Invalid hash count: ${i2}`);
+        if (0 === t3.length && 0 !== e2)
+            throw new __PRIVATE_BloomFilterError(`Invalid padding when bitmap length is 0: ${e2}`);
+        this.de = 8 * t3.length - e2, this.Ae = $y.fromNumber(this.de);
+    }
+    Re(t3, e2, i2) {
+        let s2 = t3.add(e2.multiply($y.fromNumber(i2)));
+        return 1 === s2.compare(Lb) && (s2 = new $y([s2.getBits(0), s2.getBits(1)], 0)), s2.modulo(this.Ae).toNumber();
+    }
+    Ve(t3) {
+        return 0 != (this.bitmap[Math.floor(t3 / 8)] & 1 << t3 % 8);
+    }
+    mightContain(t3) {
+        if (0 === this.de)
+            return false;
+        const e2 = Ob(t3),
+            [i2, s2] = Fb(e2);
+        for (let t4 = 0; t4 < this.hashCount; t4++) {
+            const e3 = this.Re(i2, s2, t4);
+            if (!this.Ve(e3))
+                return false;
+        }
+        return true;
+    }
+    static create(t3, e2, i2) {
+        const s2 = t3 % 8 == 0 ? 0 : 8 - t3 % 8,
+            n2 = new Uint8Array(Math.ceil(t3 / 8)),
+            r2 = new BloomFilter(n2, s2, e2);
+        return i2.forEach((t4) => r2.insert(t4)), r2;
+    }
+    insert(t3) {
+        if (0 === this.de)
+            return;
+        const e2 = Ob(t3),
+            [i2, s2] = Fb(e2);
+        for (let t4 = 0; t4 < this.hashCount; t4++) {
+            const e3 = this.Re(i2, s2, t4);
+            this.me(e3);
+        }
+    }
+    me(t3) {
+        const e2 = Math.floor(t3 / 8),
+            i2 = t3 % 8;
+        this.bitmap[e2] |= 1 << i2;
+    }
+}
+class __PRIVATE_BloomFilterError extends Error {
+    constructor() {
+        super(...arguments), this.name = "BloomFilterError";
+    }
+}
+class RemoteEvent {
+    constructor(t3, e2, i2, s2, n2) {
+        this.snapshotVersion = t3, this.targetChanges = e2, this.targetMismatches = i2, this.documentUpdates = s2, this.resolvedLimboDocuments = n2;
+    }
+    static createSynthesizedRemoteEventForCurrentChange(t3, e2, i2) {
+        const s2 = /* @__PURE__ */ new Map();
+        return s2.set(t3, TargetChange.createSynthesizedTargetChangeForCurrentChange(t3, e2, i2)), new RemoteEvent(SnapshotVersion.min(), s2, new SortedMap(Jy), ib(), ub());
+    }
+}
+class TargetChange {
+    constructor(t3, e2, i2, s2, n2) {
+        this.resumeToken = t3, this.current = e2, this.addedDocuments = i2, this.modifiedDocuments = s2, this.removedDocuments = n2;
+    }
+    static createSynthesizedTargetChangeForCurrentChange(t3, e2, i2) {
+        return new TargetChange(i2, e2, ub(), ub(), ub());
+    }
+}
+class __PRIVATE_DocumentWatchChange {
+    constructor(t3, e2, i2, s2) {
+        this.fe = t3, this.removedTargetIds = e2, this.key = i2, this.ge = s2;
+    }
+}
+class __PRIVATE_ExistenceFilterChange {
+    constructor(t3, e2) {
+        this.targetId = t3, this.pe = e2;
+    }
+}
+class __PRIVATE_WatchTargetChange {
+    constructor(t3, e2, i2 = ByteString.EMPTY_BYTE_STRING, s2 = null) {
+        this.state = t3, this.targetIds = e2, this.resumeToken = i2, this.cause = s2;
+    }
+}
+class __PRIVATE_TargetState {
+    constructor() {
+        this.ye = 0, this.we = $b(), this.Se = ByteString.EMPTY_BYTE_STRING, this.be = false, this.De = true;
+    }
+    get current() {
+        return this.be;
+    }
+    get resumeToken() {
+        return this.Se;
+    }
+    get ve() {
+        return 0 !== this.ye;
+    }
+    get Ce() {
+        return this.De;
+    }
+    Fe(t3) {
+        t3.approximateByteSize() > 0 && (this.De = true, this.Se = t3);
+    }
+    Me() {
+        let t3 = ub(),
+            e2 = ub(),
+            i2 = ub();
+        return this.we.forEach((s2, n2) => {
+            switch (n2) {
+                case 0:
+                    t3 = t3.add(s2);
+                    break;
+                case 2:
+                    e2 = e2.add(s2);
+                    break;
+                case 1:
+                    i2 = i2.add(s2);
+                    break;
+                default:
+                    Ky();
+            }
+        }), new TargetChange(this.Se, this.be, t3, e2, i2);
+    }
+    xe() {
+        this.De = false, this.we = $b();
+    }
+    Oe(t3, e2) {
+        this.De = true, this.we = this.we.insert(t3, e2);
+    }
+    Ne(t3) {
+        this.De = true, this.we = this.we.remove(t3);
+    }
+    Be() {
+        this.ye += 1;
+    }
+    Le() {
+        this.ye -= 1;
+    }
+    ke() {
+        this.De = true, this.be = true;
+    }
+}
+class __PRIVATE_WatchChangeAggregator {
+    constructor(t3) {
+        this.qe = t3, this.Qe = /* @__PURE__ */ new Map(), this.Ke = ib(), this.$e = Nb(), this.Ue = new SortedMap(Jy);
+    }
+    We(t3) {
+        for (const e2 of t3.fe)
+            t3.ge && t3.ge.isFoundDocument() ? this.Ge(e2, t3.ge) : this.ze(e2, t3.key, t3.ge);
+        for (const e2 of t3.removedTargetIds)
+            this.ze(e2, t3.key, t3.ge);
+    }
+    je(t3) {
+        this.forEachTarget(t3, (e2) => {
+            const i2 = this.He(e2);
+            switch (t3.state) {
+                case 0:
+                    this.Je(e2) && i2.Fe(t3.resumeToken);
+                    break;
+                case 1:
+                    i2.Le(), i2.ve || i2.xe(), i2.Fe(t3.resumeToken);
+                    break;
+                case 2:
+                    i2.Le(), i2.ve || this.removeTarget(e2);
+                    break;
+                case 3:
+                    this.Je(e2) && (i2.ke(), i2.Fe(t3.resumeToken));
+                    break;
+                case 4:
+                    this.Je(e2) && (this.Ye(e2), i2.Fe(t3.resumeToken));
+                    break;
+                default:
+                    Ky();
+            }
+        });
+    }
+    forEachTarget(t3, e2) {
+        t3.targetIds.length > 0 ? t3.targetIds.forEach(e2) : this.Qe.forEach((t4, i2) => {
+            this.Je(i2) && e2(i2);
+        });
+    }
+    Ze(t3) {
+        var e2, i2;
+        const s2 = t3.targetId,
+            n2 = t3.pe.count,
+            r2 = this.Xe(s2);
+        if (r2) {
+            const o2 = r2.target;
+            if (jv(o2))
+                if (0 === n2) {
+                    const t4 = new DocumentKey(o2.path);
+                    this.ze(s2, t4, MutableDocument.newNoDocument(t4, SnapshotVersion.min()));
+                } else
+                    Gy(1 === n2);
+            else {
+                const r3 = this.et(s2);
+                if (r3 !== n2) {
+                    const n3 = this.tt(t3, r3);
+                    if (0 !== n3.status) {
+                        this.Ye(s2);
+                        const t4 = 2 === n3.status ? "TargetPurposeExistenceFilterMismatchBloom" : "TargetPurposeExistenceFilterMismatch";
+                        this.Ue = this.Ue.insert(s2, t4);
+                    }
+                    null === (e2 = __PRIVATE_TestingHooks.instance) || void 0 === e2 || e2.notifyOnExistenceFilterMismatch(function(t4, e3, i3, s3) {
+                        var n4, r4, o3, a2, l2, h2;
+                        const c2 = {
+                                localCacheCount: i3,
+                                existenceFilterCount: s3.count
+                            },
+                            u2 = s3.unchangedNames;
+                        return u2 && (c2.bloomFilter = {
+                            applied: 0 === t4,
+                            hashCount: null !== (n4 = null == u2 ? void 0 : u2.hashCount) && void 0 !== n4 ? n4 : 0,
+                            bitmapLength: null !== (a2 = null === (o3 = null === (r4 = null == u2 ? void 0 : u2.bits) || void 0 === r4 ? void 0 : r4.bitmap) || void 0 === o3 ? void 0 : o3.length) && void 0 !== a2 ? a2 : 0,
+                            padding: null !== (h2 = null === (l2 = null == u2 ? void 0 : u2.bits) || void 0 === l2 ? void 0 : l2.padding) && void 0 !== h2 ? h2 : 0
+                        }, e3 && (c2.bloomFilter.mightContain = e3)), c2;
+                    }(n3.status, null !== (i2 = n3.nt) && void 0 !== i2 ? i2 : null, r3, t3.pe));
+                }
+            }
+        }
+    }
+    tt(t3, e2) {
+        const {
+            unchangedNames: i2,
+            count: s2
+        } = t3.pe;
+        if (!i2 || !i2.bits)
+            return {
+                status: 1
+            };
+        const {
+            bits: {
+                bitmap: n2 = "",
+                padding: r2 = 0
+            },
+            hashCount: o2 = 0
+        } = i2;
+        let a2, l2;
+        try {
+            a2 = fv(n2).toUint8Array();
+        } catch (t4) {
+            if (t4 instanceof __PRIVATE_Base64DecodeError)
+                return Wy("Decoding the base64 bloom filter in existence filter failed (" + t4.message + "); ignoring the bloom filter and falling back to full re-query."), {
+                    status: 1
+                };
+            throw t4;
+        }
+        try {
+            l2 = new BloomFilter(a2, r2, o2);
+        } catch (t4) {
+            return Wy(t4 instanceof __PRIVATE_BloomFilterError ? "BloomFilter error: " : "Applying bloom filter failed: ", t4), {
+                status: 1
+            };
+        }
+        const h2 = (t4) => {
+            const e3 = this.qe.rt();
+            return l2.mightContain(`projects/${e3.projectId}/databases/${e3.database}/documents/${t4}`);
+        };
+        return 0 === l2.de ? {
+            status: 1
+        } : {
+            status: s2 === e2 - this.it(t3.targetId, h2) ? 0 : 2,
+            nt: h2
+        };
+    }
+    it(t3, e2) {
+        const i2 = this.qe.getRemoteKeysForTarget(t3);
+        let s2 = 0;
+        return i2.forEach((i3) => {
+            e2(i3.path.canonicalString()) || (this.ze(t3, i3, null), s2++);
+        }), s2;
+    }
+    st(t3) {
+        const e2 = /* @__PURE__ */ new Map();
+        this.Qe.forEach((i3, s3) => {
+            const n2 = this.Xe(s3);
+            if (n2) {
+                if (i3.current && jv(n2.target)) {
+                    const e3 = new DocumentKey(n2.target.path);
+                    null !== this.Ke.get(e3) || this.ot(s3, e3) || this.ze(s3, e3, MutableDocument.newNoDocument(e3, t3));
+                }
+                i3.Ce && (e2.set(s3, i3.Me()), i3.xe());
+            }
+        });
+        let i2 = ub();
+        this.$e.forEach((t4, e3) => {
+            let s3 = true;
+            e3.forEachWhile((t5) => {
+                const e4 = this.Xe(t5);
+                return !e4 || "TargetPurposeLimboResolution" === e4.purpose || (s3 = false, false);
+            }), s3 && (i2 = i2.add(t4));
+        }), this.Ke.forEach((e3, i3) => i3.setReadTime(t3));
+        const s2 = new RemoteEvent(t3, e2, this.Ue, this.Ke, i2);
+        return this.Ke = ib(), this.$e = Nb(), this.Ue = new SortedMap(Jy), s2;
+    }
+    Ge(t3, e2) {
+        if (!this.Je(t3))
+            return;
+        const i2 = this.ot(t3, e2.key) ? 2 : 0;
+        this.He(t3).Oe(e2.key, i2), this.Ke = this.Ke.insert(e2.key, e2), this.$e = this.$e.insert(e2.key, this._t(e2.key).add(t3));
+    }
+    ze(t3, e2, i2) {
+        if (!this.Je(t3))
+            return;
+        const s2 = this.He(t3);
+        this.ot(t3, e2) ? s2.Oe(e2, 1) : s2.Ne(e2), this.$e = this.$e.insert(e2, this._t(e2).delete(t3)), i2 && (this.Ke = this.Ke.insert(e2, i2));
+    }
+    removeTarget(t3) {
+        this.Qe.delete(t3);
+    }
+    et(t3) {
+        const e2 = this.He(t3).Me();
+        return this.qe.getRemoteKeysForTarget(t3).size + e2.addedDocuments.size - e2.removedDocuments.size;
+    }
+    Be(t3) {
+        this.He(t3).Be();
+    }
+    He(t3) {
+        let e2 = this.Qe.get(t3);
+        return e2 || (e2 = new __PRIVATE_TargetState(), this.Qe.set(t3, e2)), e2;
+    }
+    _t(t3) {
+        let e2 = this.$e.get(t3);
+        return e2 || (e2 = new SortedSet(Jy), this.$e = this.$e.insert(t3, e2)), e2;
+    }
+    Je(t3) {
+        const e2 = null !== this.Xe(t3);
+        return e2 || jy("WatchChangeAggregator", "Detected inactive target", t3), e2;
+    }
+    Xe(t3) {
+        const e2 = this.Qe.get(t3);
+        return e2 && e2.ve ? null : this.qe.ut(t3);
+    }
+    Ye(t3) {
+        this.Qe.set(t3, new __PRIVATE_TargetState()), this.qe.getRemoteKeysForTarget(t3).forEach((e2) => {
+            this.ze(t3, e2, null);
+        });
+    }
+    ot(t3, e2) {
+        return this.qe.getRemoteKeysForTarget(t3).has(e2);
+    }
+}
+
+function Nb() {
+    return new SortedMap(DocumentKey.comparator);
+}
+
+function $b() {
+    return new SortedMap(DocumentKey.comparator);
+}
+const Vb = {
+        asc: "ASCENDING",
+        desc: "DESCENDING"
+    },
+    zb = {
+        "<": "LESS_THAN",
+        "<=": "LESS_THAN_OR_EQUAL",
+        ">": "GREATER_THAN",
+        ">=": "GREATER_THAN_OR_EQUAL",
+        "==": "EQUAL",
+        "!=": "NOT_EQUAL",
+        "array-contains": "ARRAY_CONTAINS",
+        in: "IN",
+        "not-in": "NOT_IN",
+        "array-contains-any": "ARRAY_CONTAINS_ANY"
+    },
+    Bb = {
+        and: "AND",
+        or: "OR"
+    };
+class JsonProtoSerializer {
+    constructor(t3, e2) {
+        this.databaseId = t3, this.useProto3Json = e2;
+    }
+}
+
+function Ub(t3, e2) {
+    return t3.useProto3Json || ov(e2) ? e2 : {
+        value: e2
+    };
+}
+
+function jb(t3) {
+    return Gy(!!t3), SnapshotVersion.fromTimestamp(function(t4) {
+        const e2 = uv(t4);
+        return new Timestamp(e2.seconds, e2.nanos);
+    }(t3));
+}
+
+function Hb(t3) {
+    const e2 = ResourcePath.fromString(t3);
+    return Gy(r_(e2)), e2;
+}
+
+function Wb(t3, e2) {
+    const i2 = Hb(e2);
+    if (i2.get(1) !== t3.databaseId.projectId)
+        throw new FirestoreError(Qy.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + i2.get(1) + " vs " + t3.databaseId.projectId);
+    if (i2.get(3) !== t3.databaseId.database)
+        throw new FirestoreError(Qy.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + i2.get(3) + " vs " + t3.databaseId.database);
+    return new DocumentKey(Gb(i2));
+}
+
+function qb(t3, e2) {
+    return function(t4, e3) {
+        return function(t5) {
+            return new ResourcePath(["projects", t5.projectId, "databases", t5.database]);
+        }(t4).child("documents").child(e3).canonicalString();
+    }(t3.databaseId, e2);
+}
+
+function Kb(t3) {
+    return new ResourcePath(["projects", t3.databaseId.projectId, "databases", t3.databaseId.database]).canonicalString();
+}
+
+function Gb(t3) {
+    return Gy(t3.length > 4 && "documents" === t3.get(4)), t3.popFirst(5);
+}
+
+function Yb(t3, e2) {
+    return {
+        documents: [qb(t3, e2.path)]
+    };
+}
+
+function Qb(t3, e2) {
+    const i2 = {
+            structuredQuery: {}
+        },
+        s2 = e2.path;
+    null !== e2.collectionGroup ? (i2.parent = qb(t3, s2), i2.structuredQuery.from = [{
+        collectionId: e2.collectionGroup,
+        allDescendants: true
+    }]) : (i2.parent = qb(t3, s2.popLast()), i2.structuredQuery.from = [{
+        collectionId: s2.lastSegment()
+    }]);
+    const n2 = function(t4) {
+        if (0 !== t4.length)
+            return n_(CompositeFilter.create(t4, "and"));
+    }(e2.filters);
+    n2 && (i2.structuredQuery.where = n2);
+    const r2 = function(t4) {
+        if (0 !== t4.length)
+            return t4.map((t5) => function(t6) {
+                return {
+                    field: i_(t6.field),
+                    direction: Zb(t6.dir)
+                };
+            }(t5));
+    }(e2.orderBy);
+    r2 && (i2.structuredQuery.orderBy = r2);
+    const o2 = Ub(t3, e2.limit);
+    return null !== o2 && (i2.structuredQuery.limit = o2), e2.startAt && (i2.structuredQuery.startAt = function(t4) {
+        return {
+            before: t4.inclusive,
+            values: t4.position
+        };
+    }(e2.startAt)), e2.endAt && (i2.structuredQuery.endAt = function(t4) {
+        return {
+            before: !t4.inclusive,
+            values: t4.position
+        };
+    }(e2.endAt)), i2;
+}
+
+function Xb(t3) {
+    let e2 = function(t4) {
+        const e3 = Hb(t4);
+        return 4 === e3.length ? ResourcePath.emptyPath() : Gb(e3);
+    }(t3.parent);
+    const i2 = t3.structuredQuery,
+        s2 = i2.from ? i2.from.length : 0;
+    let n2 = null;
+    if (s2 > 0) {
+        Gy(1 === s2);
+        const t4 = i2.from[0];
+        t4.allDescendants ? n2 = t4.collectionId : e2 = e2.child(t4.collectionId);
+    }
+    let r2 = [];
+    i2.where && (r2 = function(t4) {
+        const e3 = Jb(t4);
+        return e3 instanceof CompositeFilter && Ov(e3) ? e3.getFilters() : [e3];
+    }(i2.where));
+    let o2 = [];
+    i2.orderBy && (o2 = function(t4) {
+        return t4.map((t5) => function(t6) {
+            return new OrderBy(s_(t6.field), function(t7) {
+                switch (t7) {
+                    case "ASCENDING":
+                        return "asc";
+                    case "DESCENDING":
+                        return "desc";
+                    default:
+                        return;
+                }
+            }(t6.direction));
+        }(t5));
+    }(i2.orderBy));
+    let a2 = null;
+    i2.limit && (a2 = function(t4) {
+        let e3;
+        return e3 = "object" == typeof t4 ? t4.value : t4, ov(e3) ? null : e3;
+    }(i2.limit));
+    let l2 = null;
+    i2.startAt && (l2 = function(t4) {
+        const e3 = !!t4.before,
+            i3 = t4.values || [];
+        return new Bound(i3, e3);
+    }(i2.startAt));
+    let h2 = null;
+    return i2.endAt && (h2 = function(t4) {
+            const e3 = !t4.before,
+                i3 = t4.values || [];
+            return new Bound(i3, e3);
+        }(i2.endAt)),
+        function(t4, e3, i3, s3, n3, r3, o3, a3) {
+            return new __PRIVATE_QueryImpl(t4, e3, i3, s3, n3, r3, o3, a3);
+        }(e2, n2, o2, r2, a2, "F", l2, h2);
+}
+
+function Jb(t3) {
+    return void 0 !== t3.unaryFilter ? function(t4) {
+        switch (t4.unaryFilter.op) {
+            case "IS_NAN":
+                const e2 = s_(t4.unaryFilter.field);
+                return FieldFilter.create(e2, "==", {
+                    doubleValue: NaN
+                });
+            case "IS_NULL":
+                const i2 = s_(t4.unaryFilter.field);
+                return FieldFilter.create(i2, "==", {
+                    nullValue: "NULL_VALUE"
+                });
+            case "IS_NOT_NAN":
+                const s2 = s_(t4.unaryFilter.field);
+                return FieldFilter.create(s2, "!=", {
+                    doubleValue: NaN
+                });
+            case "IS_NOT_NULL":
+                const n2 = s_(t4.unaryFilter.field);
+                return FieldFilter.create(n2, "!=", {
+                    nullValue: "NULL_VALUE"
+                });
+            default:
+                return Ky();
+        }
+    }(t3) : void 0 !== t3.fieldFilter ? function(t4) {
+        return FieldFilter.create(s_(t4.fieldFilter.field), function(t5) {
+            switch (t5) {
+                case "EQUAL":
+                    return "==";
+                case "NOT_EQUAL":
+                    return "!=";
+                case "GREATER_THAN":
+                    return ">";
+                case "GREATER_THAN_OR_EQUAL":
+                    return ">=";
+                case "LESS_THAN":
+                    return "<";
+                case "LESS_THAN_OR_EQUAL":
+                    return "<=";
+                case "ARRAY_CONTAINS":
+                    return "array-contains";
+                case "IN":
+                    return "in";
+                case "NOT_IN":
+                    return "not-in";
+                case "ARRAY_CONTAINS_ANY":
+                    return "array-contains-any";
+                default:
+                    return Ky();
+            }
+        }(t4.fieldFilter.op), t4.fieldFilter.value);
+    }(t3) : void 0 !== t3.compositeFilter ? function(t4) {
+        return CompositeFilter.create(t4.compositeFilter.filters.map((t5) => Jb(t5)), function(t5) {
+            switch (t5) {
+                case "AND":
+                    return "and";
+                case "OR":
+                    return "or";
+                default:
+                    return Ky();
+            }
+        }(t4.compositeFilter.op));
+    }(t3) : Ky();
+}
+
+function Zb(t3) {
+    return Vb[t3];
+}
+
+function t_(t3) {
+    return zb[t3];
+}
+
+function e_(t3) {
+    return Bb[t3];
+}
+
+function i_(t3) {
+    return {
+        fieldPath: t3.canonicalString()
+    };
+}
+
+function s_(t3) {
+    return FieldPath$1.fromServerFormat(t3.fieldPath);
+}
+
+function n_(t3) {
+    return t3 instanceof FieldFilter ? function(t4) {
+        if ("==" === t4.op) {
+            if (Iv(t4.value))
+                return {
+                    unaryFilter: {
+                        field: i_(t4.field),
+                        op: "IS_NAN"
+                    }
+                };
+            if (Cv(t4.value))
+                return {
+                    unaryFilter: {
+                        field: i_(t4.field),
+                        op: "IS_NULL"
+                    }
+                };
+        } else if ("!=" === t4.op) {
+            if (Iv(t4.value))
+                return {
+                    unaryFilter: {
+                        field: i_(t4.field),
+                        op: "IS_NOT_NAN"
+                    }
+                };
+            if (Cv(t4.value))
+                return {
+                    unaryFilter: {
+                        field: i_(t4.field),
+                        op: "IS_NOT_NULL"
+                    }
+                };
+        }
+        return {
+            fieldFilter: {
+                field: i_(t4.field),
+                op: t_(t4.op),
+                value: t4.value
+            }
+        };
+    }(t3) : t3 instanceof CompositeFilter ? function(t4) {
+        const e2 = t4.getFilters().map((t5) => n_(t5));
+        return 1 === e2.length ? e2[0] : {
+            compositeFilter: {
+                op: e_(t4.op),
+                filters: e2
+            }
+        };
+    }(t3) : Ky();
+}
+
+function r_(t3) {
+    return t3.length >= 4 && "projects" === t3.get(0) && "databases" === t3.get(2);
+}
+class TargetData {
+    constructor(t3, e2, i2, s2, n2 = SnapshotVersion.min(), r2 = SnapshotVersion.min(), o2 = ByteString.EMPTY_BYTE_STRING, a2 = null) {
+        this.target = t3, this.targetId = e2, this.purpose = i2, this.sequenceNumber = s2, this.snapshotVersion = n2, this.lastLimboFreeSnapshotVersion = r2, this.resumeToken = o2, this.expectedCount = a2;
+    }
+    withSequenceNumber(t3) {
+        return new TargetData(this.target, this.targetId, this.purpose, t3, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, this.expectedCount);
+    }
+    withResumeToken(t3, e2) {
+        return new TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, e2, this.lastLimboFreeSnapshotVersion, t3, null);
+    }
+    withExpectedCount(t3) {
+        return new TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, t3);
+    }
+    withLastLimboFreeSnapshotVersion(t3) {
+        return new TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, t3, this.resumeToken, this.expectedCount);
+    }
+}
+class __PRIVATE_LocalSerializer {
+    constructor(t3) {
+        this.ct = t3;
+    }
+}
+
+function o_(t3) {
+    const e2 = Xb({
+        parent: t3.parent,
+        structuredQuery: t3.structuredQuery
+    });
+    return "LAST" === t3.limitType ? Gv(e2, e2.limit, "L") : e2;
+}
+class __PRIVATE_MemoryIndexManager {
+    constructor() {
+        this.sn = new __PRIVATE_MemoryCollectionParentIndex();
+    }
+    addToCollectionParentIndex(t3, e2) {
+        return this.sn.add(e2), PersistencePromise.resolve();
+    }
+    getCollectionParents(t3, e2) {
+        return PersistencePromise.resolve(this.sn.getEntries(e2));
+    }
+    addFieldIndex(t3, e2) {
+        return PersistencePromise.resolve();
+    }
+    deleteFieldIndex(t3, e2) {
+        return PersistencePromise.resolve();
+    }
+    getDocumentsMatchingTarget(t3, e2) {
+        return PersistencePromise.resolve(null);
+    }
+    getIndexType(t3, e2) {
+        return PersistencePromise.resolve(0);
+    }
+    getFieldIndexes(t3, e2) {
+        return PersistencePromise.resolve([]);
+    }
+    getNextCollectionGroupToUpdate(t3) {
+        return PersistencePromise.resolve(null);
+    }
+    getMinOffset(t3, e2) {
+        return PersistencePromise.resolve(IndexOffset.min());
+    }
+    getMinOffsetFromCollectionGroup(t3, e2) {
+        return PersistencePromise.resolve(IndexOffset.min());
+    }
+    updateCollectionGroup(t3, e2, i2) {
+        return PersistencePromise.resolve();
+    }
+    updateIndexEntries(t3, e2) {
+        return PersistencePromise.resolve();
+    }
+}
+class __PRIVATE_MemoryCollectionParentIndex {
+    constructor() {
+        this.index = {};
+    }
+    add(t3) {
+        const e2 = t3.lastSegment(),
+            i2 = t3.popLast(),
+            s2 = this.index[e2] || new SortedSet(ResourcePath.comparator),
+            n2 = !s2.has(i2);
+        return this.index[e2] = s2.add(i2), n2;
+    }
+    has(t3) {
+        const e2 = t3.lastSegment(),
+            i2 = t3.popLast(),
+            s2 = this.index[e2];
+        return s2 && s2.has(i2);
+    }
+    getEntries(t3) {
+        return (this.index[t3] || new SortedSet(ResourcePath.comparator)).toArray();
+    }
+}
+class __PRIVATE_TargetIdGenerator {
+    constructor(t3) {
+        this.Mn = t3;
+    }
+    next() {
+        return this.Mn += 2, this.Mn;
+    }
+    static xn() {
+        return new __PRIVATE_TargetIdGenerator(0);
+    }
+    static On() {
+        return new __PRIVATE_TargetIdGenerator(-1);
+    }
+}
+class RemoteDocumentChangeBuffer {
+    constructor() {
+        this.changes = new ObjectMap((t3) => t3.toString(), (t3, e2) => t3.isEqual(e2)), this.changesApplied = false;
+    }
+    addEntry(t3) {
+        this.assertNotApplied(), this.changes.set(t3.key, t3);
+    }
+    removeEntry(t3, e2) {
+        this.assertNotApplied(), this.changes.set(t3, MutableDocument.newInvalidDocument(t3).setReadTime(e2));
+    }
+    getEntry(t3, e2) {
+        this.assertNotApplied();
+        const i2 = this.changes.get(e2);
+        return void 0 !== i2 ? PersistencePromise.resolve(i2) : this.getFromCache(t3, e2);
+    }
+    getEntries(t3, e2) {
+        return this.getAllFromCache(t3, e2);
+    }
+    apply(t3) {
+        return this.assertNotApplied(), this.changesApplied = true, this.applyChanges(t3);
+    }
+    assertNotApplied() {}
+}
+class OverlayedDocument {
+    constructor(t3, e2) {
+        this.overlayedDocument = t3, this.mutatedFields = e2;
+    }
+}
+class LocalDocumentsView {
+    constructor(t3, e2, i2, s2) {
+        this.remoteDocumentCache = t3, this.mutationQueue = e2, this.documentOverlayCache = i2, this.indexManager = s2;
+    }
+    getDocument(t3, e2) {
+        let i2 = null;
+        return this.documentOverlayCache.getOverlay(t3, e2).next((s2) => (i2 = s2, this.remoteDocumentCache.getEntry(t3, e2))).next((t4) => (null !== i2 && Tb(i2.mutation, t4, FieldMask.empty(), Timestamp.now()), t4));
+    }
+    getDocuments(t3, e2) {
+        return this.remoteDocumentCache.getEntries(t3, e2).next((e3) => this.getLocalViewOfDocuments(t3, e3, ub()).next(() => e3));
+    }
+    getLocalViewOfDocuments(t3, e2, i2 = ub()) {
+        const s2 = ab();
+        return this.populateOverlays(t3, s2, e2).next(() => this.computeViews(t3, e2, s2, i2).next((t4) => {
+            let e3 = rb();
+            return t4.forEach((t5, i3) => {
+                e3 = e3.insert(t5, i3.overlayedDocument);
+            }), e3;
+        }));
+    }
+    getOverlayedDocuments(t3, e2) {
+        const i2 = ab();
+        return this.populateOverlays(t3, i2, e2).next(() => this.computeViews(t3, e2, i2, ub()));
+    }
+    populateOverlays(t3, e2, i2) {
+        const s2 = [];
+        return i2.forEach((t4) => {
+            e2.has(t4) || s2.push(t4);
+        }), this.documentOverlayCache.getOverlays(t3, s2).next((t4) => {
+            t4.forEach((t5, i3) => {
+                e2.set(t5, i3);
+            });
+        });
+    }
+    computeViews(t3, e2, i2, s2) {
+        let n2 = ib();
+        const r2 = hb(),
+            o2 = hb();
+        return e2.forEach((t4, e3) => {
+            const o3 = i2.get(e3.key);
+            s2.has(e3.key) && (void 0 === o3 || o3.mutation instanceof __PRIVATE_PatchMutation) ? n2 = n2.insert(e3.key, e3) : void 0 !== o3 ? (r2.set(e3.key, o3.mutation.getFieldMask()), Tb(o3.mutation, e3, o3.mutation.getFieldMask(), Timestamp.now())) : r2.set(e3.key, FieldMask.empty());
+        }), this.recalculateAndSaveOverlays(t3, n2).next((t4) => (t4.forEach((t5, e3) => r2.set(t5, e3)), e2.forEach((t5, e3) => {
+            var i3;
+            return o2.set(t5, new OverlayedDocument(e3, null !== (i3 = r2.get(t5)) && void 0 !== i3 ? i3 : null));
+        }), o2));
+    }
+    recalculateAndSaveOverlays(t3, e2) {
+        const i2 = hb();
+        let s2 = new SortedMap((t4, e3) => t4 - e3),
+            n2 = ub();
+        return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(t3, e2).next((t4) => {
+            for (const n3 of t4)
+                n3.keys().forEach((t5) => {
+                    const r2 = e2.get(t5);
+                    if (null === r2)
+                        return;
+                    let o2 = i2.get(t5) || FieldMask.empty();
+                    o2 = n3.applyToLocalView(r2, o2), i2.set(t5, o2);
+                    const a2 = (s2.get(n3.batchId) || ub()).add(t5);
+                    s2 = s2.insert(n3.batchId, a2);
+                });
+        }).next(() => {
+            const r2 = [],
+                o2 = s2.getReverseIterator();
+            for (; o2.hasNext();) {
+                const s3 = o2.getNext(),
+                    a2 = s3.key,
+                    l2 = s3.value,
+                    h2 = lb();
+                l2.forEach((t4) => {
+                    if (!n2.has(t4)) {
+                        const s4 = wb(e2.get(t4), i2.get(t4));
+                        null !== s4 && h2.set(t4, s4), n2 = n2.add(t4);
+                    }
+                }), r2.push(this.documentOverlayCache.saveOverlays(t3, a2, h2));
+            }
+            return PersistencePromise.waitFor(r2);
+        }).next(() => i2);
+    }
+    recalculateAndSaveOverlaysForDocumentKeys(t3, e2) {
+        return this.remoteDocumentCache.getEntries(t3, e2).next((e3) => this.recalculateAndSaveOverlays(t3, e3));
+    }
+    getDocumentsMatchingQuery(t3, e2, i2) {
+        return function(t4) {
+            return DocumentKey.isDocumentKey(t4.path) && null === t4.collectionGroup && 0 === t4.filters.length;
+        }(e2) ? this.getDocumentsMatchingDocumentQuery(t3, e2.path) : function(t4) {
+            return null !== t4.collectionGroup;
+        }(e2) ? this.getDocumentsMatchingCollectionGroupQuery(t3, e2, i2) : this.getDocumentsMatchingCollectionQuery(t3, e2, i2);
+    }
+    getNextDocuments(t3, e2, i2, s2) {
+        return this.remoteDocumentCache.getAllFromCollectionGroup(t3, e2, i2, s2).next((n2) => {
+            const r2 = s2 - n2.size > 0 ? this.documentOverlayCache.getOverlaysForCollectionGroup(t3, e2, i2.largestBatchId, s2 - n2.size) : PersistencePromise.resolve(ab());
+            let o2 = -1,
+                a2 = n2;
+            return r2.next((e3) => PersistencePromise.forEach(e3, (e4, i3) => (o2 < i3.largestBatchId && (o2 = i3.largestBatchId), n2.get(e4) ? PersistencePromise.resolve() : this.remoteDocumentCache.getEntry(t3, e4).next((t4) => {
+                a2 = a2.insert(e4, t4);
+            }))).next(() => this.populateOverlays(t3, e3, n2)).next(() => this.computeViews(t3, a2, e3, ub())).next((t4) => ({
+                batchId: o2,
+                changes: ob(t4)
+            })));
+        });
+    }
+    getDocumentsMatchingDocumentQuery(t3, e2) {
+        return this.getDocument(t3, new DocumentKey(e2)).next((t4) => {
+            let e3 = rb();
+            return t4.isFoundDocument() && (e3 = e3.insert(t4.key, t4)), e3;
+        });
+    }
+    getDocumentsMatchingCollectionGroupQuery(t3, e2, i2) {
+        const s2 = e2.collectionGroup;
+        let n2 = rb();
+        return this.indexManager.getCollectionParents(t3, s2).next((r2) => PersistencePromise.forEach(r2, (r3) => {
+            const o2 = function(t4, e3) {
+                return new __PRIVATE_QueryImpl(e3, null, t4.explicitOrderBy.slice(), t4.filters.slice(), t4.limit, t4.limitType, t4.startAt, t4.endAt);
+            }(e2, r3.child(s2));
+            return this.getDocumentsMatchingCollectionQuery(t3, o2, i2).next((t4) => {
+                t4.forEach((t5, e3) => {
+                    n2 = n2.insert(t5, e3);
+                });
+            });
+        }).next(() => n2));
+    }
+    getDocumentsMatchingCollectionQuery(t3, e2, i2) {
+        let s2;
+        return this.documentOverlayCache.getOverlaysForCollection(t3, e2.path, i2.largestBatchId).next((n2) => (s2 = n2, this.remoteDocumentCache.getDocumentsMatchingQuery(t3, e2, i2, s2))).next((t4) => {
+            s2.forEach((e3, i4) => {
+                const s3 = i4.getKey();
+                null === t4.get(s3) && (t4 = t4.insert(s3, MutableDocument.newInvalidDocument(s3)));
+            });
+            let i3 = rb();
+            return t4.forEach((t5, n2) => {
+                const r2 = s2.get(t5);
+                void 0 !== r2 && Tb(r2.mutation, n2, FieldMask.empty(), Timestamp.now()), Jv(e2, n2) && (i3 = i3.insert(t5, n2));
+            }), i3;
+        });
+    }
+}
+class __PRIVATE_MemoryBundleCache {
+    constructor(t3) {
+        this.serializer = t3, this.ar = /* @__PURE__ */ new Map(), this.ur = /* @__PURE__ */ new Map();
+    }
+    getBundleMetadata(t3, e2) {
+        return PersistencePromise.resolve(this.ar.get(e2));
+    }
+    saveBundleMetadata(t3, e2) {
+        return this.ar.set(e2.id, function(t4) {
+            return {
+                id: t4.id,
+                version: t4.version,
+                createTime: jb(t4.createTime)
+            };
+        }(e2)), PersistencePromise.resolve();
+    }
+    getNamedQuery(t3, e2) {
+        return PersistencePromise.resolve(this.ur.get(e2));
+    }
+    saveNamedQuery(t3, e2) {
+        return this.ur.set(e2.name, function(t4) {
+            return {
+                name: t4.name,
+                query: o_(t4.bundledQuery),
+                readTime: jb(t4.readTime)
+            };
+        }(e2)), PersistencePromise.resolve();
+    }
+}
+class __PRIVATE_MemoryDocumentOverlayCache {
+    constructor() {
+        this.overlays = new SortedMap(DocumentKey.comparator), this.cr = /* @__PURE__ */ new Map();
+    }
+    getOverlay(t3, e2) {
+        return PersistencePromise.resolve(this.overlays.get(e2));
+    }
+    getOverlays(t3, e2) {
+        const i2 = ab();
+        return PersistencePromise.forEach(e2, (e3) => this.getOverlay(t3, e3).next((t4) => {
+            null !== t4 && i2.set(e3, t4);
+        })).next(() => i2);
+    }
+    saveOverlays(t3, e2, i2) {
+        return i2.forEach((i3, s2) => {
+            this.ht(t3, e2, s2);
+        }), PersistencePromise.resolve();
+    }
+    removeOverlaysForBatchId(t3, e2, i2) {
+        const s2 = this.cr.get(i2);
+        return void 0 !== s2 && (s2.forEach((t4) => this.overlays = this.overlays.remove(t4)), this.cr.delete(i2)), PersistencePromise.resolve();
+    }
+    getOverlaysForCollection(t3, e2, i2) {
+        const s2 = ab(),
+            n2 = e2.length + 1,
+            r2 = new DocumentKey(e2.child("")),
+            o2 = this.overlays.getIteratorFrom(r2);
+        for (; o2.hasNext();) {
+            const t4 = o2.getNext().value,
+                r3 = t4.getKey();
+            if (!e2.isPrefixOf(r3.path))
+                break;
+            r3.path.length === n2 && t4.largestBatchId > i2 && s2.set(t4.getKey(), t4);
+        }
+        return PersistencePromise.resolve(s2);
+    }
+    getOverlaysForCollectionGroup(t3, e2, i2, s2) {
+        let n2 = new SortedMap((t4, e3) => t4 - e3);
+        const r2 = this.overlays.getIterator();
+        for (; r2.hasNext();) {
+            const t4 = r2.getNext().value;
+            if (t4.getKey().getCollectionGroup() === e2 && t4.largestBatchId > i2) {
+                let e3 = n2.get(t4.largestBatchId);
+                null === e3 && (e3 = ab(), n2 = n2.insert(t4.largestBatchId, e3)), e3.set(t4.getKey(), t4);
+            }
+        }
+        const o2 = ab(),
+            a2 = n2.getIterator();
+        for (; a2.hasNext() && (a2.getNext().value.forEach((t4, e3) => o2.set(t4, e3)), !(o2.size() >= s2));)
+        ;
+        return PersistencePromise.resolve(o2);
+    }
+    ht(t3, e2, i2) {
+        const s2 = this.overlays.get(i2.key);
+        if (null !== s2) {
+            const t4 = this.cr.get(s2.largestBatchId).delete(i2.key);
+            this.cr.set(s2.largestBatchId, t4);
+        }
+        this.overlays = this.overlays.insert(i2.key, new Overlay(e2, i2));
+        let n2 = this.cr.get(e2);
+        void 0 === n2 && (n2 = ub(), this.cr.set(e2, n2)), this.cr.set(e2, n2.add(i2.key));
+    }
+}
+class __PRIVATE_ReferenceSet {
+    constructor() {
+        this.lr = new SortedSet(__PRIVATE_DocReference.hr), this.Pr = new SortedSet(__PRIVATE_DocReference.Ir);
+    }
+    isEmpty() {
+        return this.lr.isEmpty();
+    }
+    addReference(t3, e2) {
+        const i2 = new __PRIVATE_DocReference(t3, e2);
+        this.lr = this.lr.add(i2), this.Pr = this.Pr.add(i2);
+    }
+    Tr(t3, e2) {
+        t3.forEach((t4) => this.addReference(t4, e2));
+    }
+    removeReference(t3, e2) {
+        this.Er(new __PRIVATE_DocReference(t3, e2));
+    }
+    dr(t3, e2) {
+        t3.forEach((t4) => this.removeReference(t4, e2));
+    }
+    Ar(t3) {
+        const e2 = new DocumentKey(new ResourcePath([])),
+            i2 = new __PRIVATE_DocReference(e2, t3),
+            s2 = new __PRIVATE_DocReference(e2, t3 + 1),
+            n2 = [];
+        return this.Pr.forEachInRange([i2, s2], (t4) => {
+            this.Er(t4), n2.push(t4.key);
+        }), n2;
+    }
+    Rr() {
+        this.lr.forEach((t3) => this.Er(t3));
+    }
+    Er(t3) {
+        this.lr = this.lr.delete(t3), this.Pr = this.Pr.delete(t3);
+    }
+    Vr(t3) {
+        const e2 = new DocumentKey(new ResourcePath([])),
+            i2 = new __PRIVATE_DocReference(e2, t3),
+            s2 = new __PRIVATE_DocReference(e2, t3 + 1);
+        let n2 = ub();
+        return this.Pr.forEachInRange([i2, s2], (t4) => {
+            n2 = n2.add(t4.key);
+        }), n2;
+    }
+    containsKey(t3) {
+        const e2 = new __PRIVATE_DocReference(t3, 0),
+            i2 = this.lr.firstAfterOrEqual(e2);
+        return null !== i2 && t3.isEqual(i2.key);
+    }
+}
+class __PRIVATE_DocReference {
+    constructor(t3, e2) {
+        this.key = t3, this.mr = e2;
+    }
+    static hr(t3, e2) {
+        return DocumentKey.comparator(t3.key, e2.key) || Jy(t3.mr, e2.mr);
+    }
+    static Ir(t3, e2) {
+        return Jy(t3.mr, e2.mr) || DocumentKey.comparator(t3.key, e2.key);
+    }
+}
+class __PRIVATE_MemoryMutationQueue {
+    constructor(t3, e2) {
+        this.indexManager = t3, this.referenceDelegate = e2, this.mutationQueue = [], this.gr = 1, this.pr = new SortedSet(__PRIVATE_DocReference.hr);
+    }
+    checkEmpty(t3) {
+        return PersistencePromise.resolve(0 === this.mutationQueue.length);
+    }
+    addMutationBatch(t3, e2, i2, s2) {
+        const n2 = this.gr;
+        this.gr++, this.mutationQueue.length > 0 && this.mutationQueue[this.mutationQueue.length - 1];
+        const r2 = new MutationBatch(n2, e2, i2, s2);
+        this.mutationQueue.push(r2);
+        for (const e3 of s2)
+            this.pr = this.pr.add(new __PRIVATE_DocReference(e3.key, n2)), this.indexManager.addToCollectionParentIndex(t3, e3.key.path.popLast());
+        return PersistencePromise.resolve(r2);
+    }
+    lookupMutationBatch(t3, e2) {
+        return PersistencePromise.resolve(this.yr(e2));
+    }
+    getNextMutationBatchAfterBatchId(t3, e2) {
+        const i2 = e2 + 1,
+            s2 = this.wr(i2),
+            n2 = s2 < 0 ? 0 : s2;
+        return PersistencePromise.resolve(this.mutationQueue.length > n2 ? this.mutationQueue[n2] : null);
+    }
+    getHighestUnacknowledgedBatchId() {
+        return PersistencePromise.resolve(0 === this.mutationQueue.length ? -1 : this.gr - 1);
+    }
+    getAllMutationBatches(t3) {
+        return PersistencePromise.resolve(this.mutationQueue.slice());
+    }
+    getAllMutationBatchesAffectingDocumentKey(t3, e2) {
+        const i2 = new __PRIVATE_DocReference(e2, 0),
+            s2 = new __PRIVATE_DocReference(e2, Number.POSITIVE_INFINITY),
+            n2 = [];
+        return this.pr.forEachInRange([i2, s2], (t4) => {
+            const e3 = this.yr(t4.mr);
+            n2.push(e3);
+        }), PersistencePromise.resolve(n2);
+    }
+    getAllMutationBatchesAffectingDocumentKeys(t3, e2) {
+        let i2 = new SortedSet(Jy);
+        return e2.forEach((t4) => {
+            const e3 = new __PRIVATE_DocReference(t4, 0),
+                s2 = new __PRIVATE_DocReference(t4, Number.POSITIVE_INFINITY);
+            this.pr.forEachInRange([e3, s2], (t5) => {
+                i2 = i2.add(t5.mr);
+            });
+        }), PersistencePromise.resolve(this.Sr(i2));
+    }
+    getAllMutationBatchesAffectingQuery(t3, e2) {
+        const i2 = e2.path,
+            s2 = i2.length + 1;
+        let n2 = i2;
+        DocumentKey.isDocumentKey(n2) || (n2 = n2.child(""));
+        const r2 = new __PRIVATE_DocReference(new DocumentKey(n2), 0);
+        let o2 = new SortedSet(Jy);
+        return this.pr.forEachWhile((t4) => {
+            const e3 = t4.key.path;
+            return !!i2.isPrefixOf(e3) && (e3.length === s2 && (o2 = o2.add(t4.mr)), true);
+        }, r2), PersistencePromise.resolve(this.Sr(o2));
+    }
+    Sr(t3) {
+        const e2 = [];
+        return t3.forEach((t4) => {
+            const i2 = this.yr(t4);
+            null !== i2 && e2.push(i2);
+        }), e2;
+    }
+    removeMutationBatch(t3, e2) {
+        Gy(0 === this.br(e2.batchId, "removed")), this.mutationQueue.shift();
+        let i2 = this.pr;
+        return PersistencePromise.forEach(e2.mutations, (s2) => {
+            const n2 = new __PRIVATE_DocReference(s2.key, e2.batchId);
+            return i2 = i2.delete(n2), this.referenceDelegate.markPotentiallyOrphaned(t3, s2.key);
+        }).next(() => {
+            this.pr = i2;
+        });
+    }
+    Cn(t3) {}
+    containsKey(t3, e2) {
+        const i2 = new __PRIVATE_DocReference(e2, 0),
+            s2 = this.pr.firstAfterOrEqual(i2);
+        return PersistencePromise.resolve(e2.isEqual(s2 && s2.key));
+    }
+    performConsistencyCheck(t3) {
+        return this.mutationQueue.length, PersistencePromise.resolve();
+    }
+    br(t3, e2) {
+        return this.wr(t3);
+    }
+    wr(t3) {
+        return 0 === this.mutationQueue.length ? 0 : t3 - this.mutationQueue[0].batchId;
+    }
+    yr(t3) {
+        const e2 = this.wr(t3);
+        return e2 < 0 || e2 >= this.mutationQueue.length ? null : this.mutationQueue[e2];
+    }
+}
+class __PRIVATE_MemoryRemoteDocumentCacheImpl {
+    constructor(t3) {
+        this.Dr = t3, this.docs = new SortedMap(DocumentKey.comparator), this.size = 0;
+    }
+    setIndexManager(t3) {
+        this.indexManager = t3;
+    }
+    addEntry(t3, e2) {
+        const i2 = e2.key,
+            s2 = this.docs.get(i2),
+            n2 = s2 ? s2.size : 0,
+            r2 = this.Dr(e2);
+        return this.docs = this.docs.insert(i2, {
+            document: e2.mutableCopy(),
+            size: r2
+        }), this.size += r2 - n2, this.indexManager.addToCollectionParentIndex(t3, i2.path.popLast());
+    }
+    removeEntry(t3) {
+        const e2 = this.docs.get(t3);
+        e2 && (this.docs = this.docs.remove(t3), this.size -= e2.size);
+    }
+    getEntry(t3, e2) {
+        const i2 = this.docs.get(e2);
+        return PersistencePromise.resolve(i2 ? i2.document.mutableCopy() : MutableDocument.newInvalidDocument(e2));
+    }
+    getEntries(t3, e2) {
+        let i2 = ib();
+        return e2.forEach((t4) => {
+            const e3 = this.docs.get(t4);
+            i2 = i2.insert(t4, e3 ? e3.document.mutableCopy() : MutableDocument.newInvalidDocument(t4));
+        }), PersistencePromise.resolve(i2);
+    }
+    getDocumentsMatchingQuery(t3, e2, i2, s2) {
+        let n2 = ib();
+        const r2 = e2.path,
+            o2 = new DocumentKey(r2.child("")),
+            a2 = this.docs.getIteratorFrom(o2);
+        for (; a2.hasNext();) {
+            const {
+                key: t4,
+                value: {
+                    document: o3
+                }
+            } = a2.getNext();
+            if (!r2.isPrefixOf(t4.path))
+                break;
+            t4.path.length > r2.length + 1 || iv(ev(o3), i2) <= 0 || (s2.has(o3.key) || Jv(e2, o3)) && (n2 = n2.insert(o3.key, o3.mutableCopy()));
+        }
+        return PersistencePromise.resolve(n2);
+    }
+    getAllFromCollectionGroup(t3, e2, i2, s2) {
+        Ky();
+    }
+    vr(t3, e2) {
+        return PersistencePromise.forEach(this.docs, (t4) => e2(t4));
+    }
+    newChangeBuffer(t3) {
+        return new __PRIVATE_MemoryRemoteDocumentChangeBuffer(this);
+    }
+    getSize(t3) {
+        return PersistencePromise.resolve(this.size);
+    }
+}
+class __PRIVATE_MemoryRemoteDocumentChangeBuffer extends RemoteDocumentChangeBuffer {
+    constructor(t3) {
+        super(), this.sr = t3;
+    }
+    applyChanges(t3) {
+        const e2 = [];
+        return this.changes.forEach((i2, s2) => {
+            s2.isValidDocument() ? e2.push(this.sr.addEntry(t3, s2)) : this.sr.removeEntry(i2);
+        }), PersistencePromise.waitFor(e2);
+    }
+    getFromCache(t3, e2) {
+        return this.sr.getEntry(t3, e2);
+    }
+    getAllFromCache(t3, e2) {
+        return this.sr.getEntries(t3, e2);
+    }
+}
+class __PRIVATE_MemoryTargetCache {
+    constructor(t3) {
+        this.persistence = t3, this.Cr = new ObjectMap((t4) => Bv(t4), Uv), this.lastRemoteSnapshotVersion = SnapshotVersion.min(), this.highestTargetId = 0, this.Fr = 0, this.Mr = new __PRIVATE_ReferenceSet(), this.targetCount = 0, this.Or = __PRIVATE_TargetIdGenerator.xn();
+    }
+    forEachTarget(t3, e2) {
+        return this.Cr.forEach((t4, i2) => e2(i2)), PersistencePromise.resolve();
+    }
+    getLastRemoteSnapshotVersion(t3) {
+        return PersistencePromise.resolve(this.lastRemoteSnapshotVersion);
+    }
+    getHighestSequenceNumber(t3) {
+        return PersistencePromise.resolve(this.Fr);
+    }
+    allocateTargetId(t3) {
+        return this.highestTargetId = this.Or.next(), PersistencePromise.resolve(this.highestTargetId);
+    }
+    setTargetsMetadata(t3, e2, i2) {
+        return i2 && (this.lastRemoteSnapshotVersion = i2), e2 > this.Fr && (this.Fr = e2), PersistencePromise.resolve();
+    }
+    Ln(t3) {
+        this.Cr.set(t3.target, t3);
+        const e2 = t3.targetId;
+        e2 > this.highestTargetId && (this.Or = new __PRIVATE_TargetIdGenerator(e2), this.highestTargetId = e2), t3.sequenceNumber > this.Fr && (this.Fr = t3.sequenceNumber);
+    }
+    addTargetData(t3, e2) {
+        return this.Ln(e2), this.targetCount += 1, PersistencePromise.resolve();
+    }
+    updateTargetData(t3, e2) {
+        return this.Ln(e2), PersistencePromise.resolve();
+    }
+    removeTargetData(t3, e2) {
+        return this.Cr.delete(e2.target), this.Mr.Ar(e2.targetId), this.targetCount -= 1, PersistencePromise.resolve();
+    }
+    removeTargets(t3, e2, i2) {
+        let s2 = 0;
+        const n2 = [];
+        return this.Cr.forEach((r2, o2) => {
+            o2.sequenceNumber <= e2 && null === i2.get(o2.targetId) && (this.Cr.delete(r2), n2.push(this.removeMatchingKeysForTargetId(t3, o2.targetId)), s2++);
+        }), PersistencePromise.waitFor(n2).next(() => s2);
+    }
+    getTargetCount(t3) {
+        return PersistencePromise.resolve(this.targetCount);
+    }
+    getTargetData(t3, e2) {
+        const i2 = this.Cr.get(e2) || null;
+        return PersistencePromise.resolve(i2);
+    }
+    addMatchingKeys(t3, e2, i2) {
+        return this.Mr.Tr(e2, i2), PersistencePromise.resolve();
+    }
+    removeMatchingKeys(t3, e2, i2) {
+        this.Mr.dr(e2, i2);
+        const s2 = this.persistence.referenceDelegate,
+            n2 = [];
+        return s2 && e2.forEach((e3) => {
+            n2.push(s2.markPotentiallyOrphaned(t3, e3));
+        }), PersistencePromise.waitFor(n2);
+    }
+    removeMatchingKeysForTargetId(t3, e2) {
+        return this.Mr.Ar(e2), PersistencePromise.resolve();
+    }
+    getMatchingKeysForTargetId(t3, e2) {
+        const i2 = this.Mr.Vr(e2);
+        return PersistencePromise.resolve(i2);
+    }
+    containsKey(t3, e2) {
+        return PersistencePromise.resolve(this.Mr.containsKey(e2));
+    }
+}
+class __PRIVATE_MemoryPersistence {
+    constructor(t3, e2) {
+        this.Nr = {}, this.overlays = {}, this.Br = new __PRIVATE_ListenSequence(0), this.Lr = false, this.Lr = true, this.referenceDelegate = t3(this), this.kr = new __PRIVATE_MemoryTargetCache(this), this.indexManager = new __PRIVATE_MemoryIndexManager(), this.remoteDocumentCache = function(t4) {
+            return new __PRIVATE_MemoryRemoteDocumentCacheImpl(t4);
+        }((t4) => this.referenceDelegate.qr(t4)), this.serializer = new __PRIVATE_LocalSerializer(e2), this.Qr = new __PRIVATE_MemoryBundleCache(this.serializer);
+    }
+    start() {
+        return Promise.resolve();
+    }
+    shutdown() {
+        return this.Lr = false, Promise.resolve();
+    }
+    get started() {
+        return this.Lr;
+    }
+    setDatabaseDeletedListener() {}
+    setNetworkEnabled() {}
+    getIndexManager(t3) {
+        return this.indexManager;
+    }
+    getDocumentOverlayCache(t3) {
+        let e2 = this.overlays[t3.toKey()];
+        return e2 || (e2 = new __PRIVATE_MemoryDocumentOverlayCache(), this.overlays[t3.toKey()] = e2), e2;
+    }
+    getMutationQueue(t3, e2) {
+        let i2 = this.Nr[t3.toKey()];
+        return i2 || (i2 = new __PRIVATE_MemoryMutationQueue(e2, this.referenceDelegate), this.Nr[t3.toKey()] = i2), i2;
+    }
+    getTargetCache() {
+        return this.kr;
+    }
+    getRemoteDocumentCache() {
+        return this.remoteDocumentCache;
+    }
+    getBundleCache() {
+        return this.Qr;
+    }
+    runTransaction(t3, e2, i2) {
+        jy("MemoryPersistence", "Starting transaction:", t3);
+        const s2 = new __PRIVATE_MemoryTransaction(this.Br.next());
+        return this.referenceDelegate.Kr(), i2(s2).next((t4) => this.referenceDelegate.$r(s2).next(() => t4)).toPromise().then((t4) => (s2.raiseOnCommittedEvent(), t4));
+    }
+    Ur(t3, e2) {
+        return PersistencePromise.or(Object.values(this.Nr).map((i2) => () => i2.containsKey(t3, e2)));
+    }
+}
+class __PRIVATE_MemoryTransaction extends PersistenceTransaction {
+    constructor(t3) {
+        super(), this.currentSequenceNumber = t3;
+    }
+}
+class __PRIVATE_MemoryEagerDelegate {
+    constructor(t3) {
+        this.persistence = t3, this.Wr = new __PRIVATE_ReferenceSet(), this.Gr = null;
+    }
+    static zr(t3) {
+        return new __PRIVATE_MemoryEagerDelegate(t3);
+    }
+    get jr() {
+        if (this.Gr)
+            return this.Gr;
+        throw Ky();
+    }
+    addReference(t3, e2, i2) {
+        return this.Wr.addReference(i2, e2), this.jr.delete(i2.toString()), PersistencePromise.resolve();
+    }
+    removeReference(t3, e2, i2) {
+        return this.Wr.removeReference(i2, e2), this.jr.add(i2.toString()), PersistencePromise.resolve();
+    }
+    markPotentiallyOrphaned(t3, e2) {
+        return this.jr.add(e2.toString()), PersistencePromise.resolve();
+    }
+    removeTarget(t3, e2) {
+        this.Wr.Ar(e2.targetId).forEach((t4) => this.jr.add(t4.toString()));
+        const i2 = this.persistence.getTargetCache();
+        return i2.getMatchingKeysForTargetId(t3, e2.targetId).next((t4) => {
+            t4.forEach((t5) => this.jr.add(t5.toString()));
+        }).next(() => i2.removeTargetData(t3, e2));
+    }
+    Kr() {
+        this.Gr = /* @__PURE__ */ new Set();
+    }
+    $r(t3) {
+        const e2 = this.persistence.getRemoteDocumentCache().newChangeBuffer();
+        return PersistencePromise.forEach(this.jr, (i2) => {
+            const s2 = DocumentKey.fromPath(i2);
+            return this.Hr(t3, s2).next((t4) => {
+                t4 || e2.removeEntry(s2, SnapshotVersion.min());
+            });
+        }).next(() => (this.Gr = null, e2.apply(t3)));
+    }
+    updateLimboDocument(t3, e2) {
+        return this.Hr(t3, e2).next((t4) => {
+            t4 ? this.jr.delete(e2.toString()) : this.jr.add(e2.toString());
+        });
+    }
+    qr(t3) {
+        return 0;
+    }
+    Hr(t3, e2) {
+        return PersistencePromise.or([() => PersistencePromise.resolve(this.Wr.containsKey(e2)), () => this.persistence.getTargetCache().containsKey(t3, e2), () => this.persistence.Ur(t3, e2)]);
+    }
+}
+class __PRIVATE_LocalViewChanges {
+    constructor(t3, e2, i2, s2) {
+        this.targetId = t3, this.fromCache = e2, this.Li = i2, this.ki = s2;
+    }
+    static qi(t3, e2) {
+        let i2 = ub(),
+            s2 = ub();
+        for (const t4 of e2.docChanges)
+            switch (t4.type) {
+                case 0:
+                    i2 = i2.add(t4.doc.key);
+                    break;
+                case 1:
+                    s2 = s2.add(t4.doc.key);
+            }
+        return new __PRIVATE_LocalViewChanges(t3, e2.fromCache, i2, s2);
+    }
+}
+class __PRIVATE_QueryEngine {
+    constructor() {
+        this.Qi = false;
+    }
+    initialize(t3, e2) {
+        this.Ki = t3, this.indexManager = e2, this.Qi = true;
+    }
+    getDocumentsMatchingQuery(t3, e2, i2, s2) {
+        return this.$i(t3, e2).next((n2) => n2 || this.Ui(t3, e2, s2, i2)).next((i3) => i3 || this.Wi(t3, e2));
+    }
+    $i(t3, e2) {
+        if (Wv(e2))
+            return PersistencePromise.resolve(null);
+        let i2 = Kv(e2);
+        return this.indexManager.getIndexType(t3, i2).next((s2) => 0 === s2 ? null : (null !== e2.limit && 1 === s2 && (e2 = Gv(e2, null, "F"), i2 = Kv(e2)), this.indexManager.getDocumentsMatchingTarget(t3, i2).next((s3) => {
+            const n2 = ub(...s3);
+            return this.Ki.getDocuments(t3, n2).next((s4) => this.indexManager.getMinOffset(t3, i2).next((i3) => {
+                const r2 = this.Gi(e2, s4);
+                return this.zi(e2, r2, n2, i3.readTime) ? this.$i(t3, Gv(e2, null, "F")) : this.ji(t3, r2, e2, i3);
+            }));
+        })));
+    }
+    Ui(t3, e2, i2, s2) {
+        return Wv(e2) || s2.isEqual(SnapshotVersion.min()) ? this.Wi(t3, e2) : this.Ki.getDocuments(t3, i2).next((n2) => {
+            const r2 = this.Gi(e2, n2);
+            return this.zi(e2, r2, i2, s2) ? this.Wi(t3, e2) : (Uy() <= Rd.DEBUG && jy("QueryEngine", "Re-using previous result from %s to execute query: %s", s2.toString(), Xv(e2)), this.ji(t3, r2, e2, function(t4, e3) {
+                const i3 = t4.toTimestamp().seconds,
+                    s3 = t4.toTimestamp().nanoseconds + 1,
+                    n3 = SnapshotVersion.fromTimestamp(1e9 === s3 ? new Timestamp(i3 + 1, 0) : new Timestamp(i3, s3));
+                return new IndexOffset(n3, DocumentKey.empty(), e3);
+            }(s2, -1)));
+        });
+    }
+    Gi(t3, e2) {
+        let i2 = new SortedSet(Zv(t3));
+        return e2.forEach((e3, s2) => {
+            Jv(t3, s2) && (i2 = i2.add(s2));
+        }), i2;
+    }
+    zi(t3, e2, i2, s2) {
+        if (null === t3.limit)
+            return false;
+        if (i2.size !== e2.size)
+            return true;
+        const n2 = "F" === t3.limitType ? e2.last() : e2.first();
+        return !!n2 && (n2.hasPendingWrites || n2.version.compareTo(s2) > 0);
+    }
+    Wi(t3, e2) {
+        return Uy() <= Rd.DEBUG && jy("QueryEngine", "Using full collection scan to execute query:", Xv(e2)), this.Ki.getDocumentsMatchingQuery(t3, e2, IndexOffset.min());
+    }
+    ji(t3, e2, i2, s2) {
+        return this.Ki.getDocumentsMatchingQuery(t3, i2, s2).next((t4) => (e2.forEach((e3) => {
+            t4 = t4.insert(e3.key, e3);
+        }), t4));
+    }
+}
+class __PRIVATE_LocalStoreImpl {
+    constructor(t3, e2, i2, s2) {
+        this.persistence = t3, this.Hi = e2, this.serializer = s2, this.Ji = new SortedMap(Jy), this.Yi = new ObjectMap((t4) => Bv(t4), Uv), this.Zi = /* @__PURE__ */ new Map(), this.Xi = t3.getRemoteDocumentCache(), this.kr = t3.getTargetCache(), this.Qr = t3.getBundleCache(), this.es(i2);
+    }
+    es(t3) {
+        this.documentOverlayCache = this.persistence.getDocumentOverlayCache(t3), this.indexManager = this.persistence.getIndexManager(t3), this.mutationQueue = this.persistence.getMutationQueue(t3, this.indexManager), this.localDocuments = new LocalDocumentsView(this.Xi, this.mutationQueue, this.documentOverlayCache, this.indexManager), this.Xi.setIndexManager(this.indexManager), this.Hi.initialize(this.localDocuments, this.indexManager);
+    }
+    collectGarbage(t3) {
+        return this.persistence.runTransaction("Collect garbage", "readwrite-primary", (e2) => t3.collect(e2, this.Ji));
+    }
+}
+async function a_(t3, e2) {
+    const i2 = Yy(t3);
+    return await i2.persistence.runTransaction("Handle user change", "readonly", (t4) => {
+        let s2;
+        return i2.mutationQueue.getAllMutationBatches(t4).next((n2) => (s2 = n2, i2.es(e2), i2.mutationQueue.getAllMutationBatches(t4))).next((e3) => {
+            const n2 = [],
+                r2 = [];
+            let o2 = ub();
+            for (const t5 of s2) {
+                n2.push(t5.batchId);
+                for (const e4 of t5.mutations)
+                    o2 = o2.add(e4.key);
+            }
+            for (const t5 of e3) {
+                r2.push(t5.batchId);
+                for (const e4 of t5.mutations)
+                    o2 = o2.add(e4.key);
+            }
+            return i2.localDocuments.getDocuments(t4, o2).next((t5) => ({
+                ts: t5,
+                removedBatchIds: n2,
+                addedBatchIds: r2
+            }));
+        });
+    });
+}
+
+function l_(t3) {
+    const e2 = Yy(t3);
+    return e2.persistence.runTransaction("Get last remote snapshot version", "readonly", (t4) => e2.kr.getLastRemoteSnapshotVersion(t4));
+}
+
+function h_(t3, e2) {
+    const i2 = Yy(t3),
+        s2 = e2.snapshotVersion;
+    let n2 = i2.Ji;
+    return i2.persistence.runTransaction("Apply remote event", "readwrite-primary", (t4) => {
+        const r2 = i2.Xi.newChangeBuffer({
+            trackRemovals: true
+        });
+        n2 = i2.Ji;
+        const o2 = [];
+        e2.targetChanges.forEach((r3, a3) => {
+            const l3 = n2.get(a3);
+            if (!l3)
+                return;
+            o2.push(i2.kr.removeMatchingKeys(t4, r3.removedDocuments, a3).next(() => i2.kr.addMatchingKeys(t4, r3.addedDocuments, a3)));
+            let h2 = l3.withSequenceNumber(t4.currentSequenceNumber);
+            null !== e2.targetMismatches.get(a3) ? h2 = h2.withResumeToken(ByteString.EMPTY_BYTE_STRING, SnapshotVersion.min()).withLastLimboFreeSnapshotVersion(SnapshotVersion.min()) : r3.resumeToken.approximateByteSize() > 0 && (h2 = h2.withResumeToken(r3.resumeToken, s2)), n2 = n2.insert(a3, h2),
+                function(t5, e3, i3) {
+                    return 0 === t5.resumeToken.approximateByteSize() || (e3.snapshotVersion.toMicroseconds() - t5.snapshotVersion.toMicroseconds() >= 3e8 || i3.addedDocuments.size + i3.modifiedDocuments.size + i3.removedDocuments.size > 0);
+                }(l3, h2, r3) && o2.push(i2.kr.updateTargetData(t4, h2));
+        });
+        let a2 = ib(),
+            l2 = ub();
+        if (e2.documentUpdates.forEach((s3) => {
+                e2.resolvedLimboDocuments.has(s3) && o2.push(i2.persistence.referenceDelegate.updateLimboDocument(t4, s3));
+            }), o2.push(function(t5, e3, i3) {
+                let s3 = ub(),
+                    n3 = ub();
+                return i3.forEach((t6) => s3 = s3.add(t6)), e3.getEntries(t5, s3).next((t6) => {
+                    let s4 = ib();
+                    return i3.forEach((i4, r3) => {
+                        const o3 = t6.get(i4);
+                        r3.isFoundDocument() !== o3.isFoundDocument() && (n3 = n3.add(i4)), r3.isNoDocument() && r3.version.isEqual(SnapshotVersion.min()) ? (e3.removeEntry(i4, r3.readTime), s4 = s4.insert(i4, r3)) : !o3.isValidDocument() || r3.version.compareTo(o3.version) > 0 || 0 === r3.version.compareTo(o3.version) && o3.hasPendingWrites ? (e3.addEntry(r3), s4 = s4.insert(i4, r3)) : jy("LocalStore", "Ignoring outdated watch update for ", i4, ". Current version:", o3.version, " Watch version:", r3.version);
+                    }), {
+                        ns: s4,
+                        rs: n3
+                    };
+                });
+            }(t4, r2, e2.documentUpdates).next((t5) => {
+                a2 = t5.ns, l2 = t5.rs;
+            })), !s2.isEqual(SnapshotVersion.min())) {
+            const e3 = i2.kr.getLastRemoteSnapshotVersion(t4).next((e4) => i2.kr.setTargetsMetadata(t4, t4.currentSequenceNumber, s2));
+            o2.push(e3);
+        }
+        return PersistencePromise.waitFor(o2).next(() => r2.apply(t4)).next(() => i2.localDocuments.getLocalViewOfDocuments(t4, a2, l2)).next(() => a2);
+    }).then((t4) => (i2.Ji = n2, t4));
+}
+async function c_(t3, e2, i2) {
+    const s2 = Yy(t3),
+        n2 = s2.Ji.get(e2),
+        r2 = i2 ? "readwrite" : "readwrite-primary";
+    try {
+        i2 || await s2.persistence.runTransaction("Release target", r2, (t4) => s2.persistence.referenceDelegate.removeTarget(t4, n2));
+    } catch (t4) {
+        if (!rv(t4))
+            throw t4;
+        jy("LocalStore", `Failed to update sequence numbers for target ${e2}: ${t4}`);
+    }
+    s2.Ji = s2.Ji.remove(e2), s2.Yi.delete(n2.target);
+}
+
+function u_(t3, e2, i2) {
+    const s2 = Yy(t3);
+    let n2 = SnapshotVersion.min(),
+        r2 = ub();
+    return s2.persistence.runTransaction("Execute query", "readonly", (t4) => function(t5, e3, i3) {
+        const s3 = Yy(t5),
+            n3 = s3.Yi.get(i3);
+        return void 0 !== n3 ? PersistencePromise.resolve(s3.Ji.get(n3)) : s3.kr.getTargetData(e3, i3);
+    }(s2, t4, Kv(e2)).next((e3) => {
+        if (e3)
+            return n2 = e3.lastLimboFreeSnapshotVersion, s2.kr.getMatchingKeysForTargetId(t4, e3.targetId).next((t5) => {
+                r2 = t5;
+            });
+    }).next(() => s2.Hi.getDocumentsMatchingQuery(t4, e2, i2 ? n2 : SnapshotVersion.min(), i2 ? r2 : ub())).next((t5) => (function(t6, e3, i3) {
+        let s3 = t6.Zi.get(e3) || SnapshotVersion.min();
+        i3.forEach((t7, e4) => {
+            e4.readTime.compareTo(s3) > 0 && (s3 = e4.readTime);
+        }), t6.Zi.set(e3, s3);
+    }(s2, function(t6) {
+        return t6.collectionGroup || (t6.path.length % 2 == 1 ? t6.path.lastSegment() : t6.path.get(t6.path.length - 2));
+    }(e2), t5), {
+        documents: t5,
+        ss: r2
+    })));
+}
+class __PRIVATE_LocalClientState {
+    constructor() {
+        this.activeTargetIds = db;
+    }
+    hs(t3) {
+        this.activeTargetIds = this.activeTargetIds.add(t3);
+    }
+    Ps(t3) {
+        this.activeTargetIds = this.activeTargetIds.delete(t3);
+    }
+    ls() {
+        const t3 = {
+            activeTargetIds: this.activeTargetIds.toArray(),
+            updateTimeMs: Date.now()
+        };
+        return JSON.stringify(t3);
+    }
+}
+class __PRIVATE_MemorySharedClientState {
+    constructor() {
+        this.Hs = new __PRIVATE_LocalClientState(), this.Js = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null;
+    }
+    addPendingMutation(t3) {}
+    updateMutationState(t3, e2, i2) {}
+    addLocalQueryTarget(t3) {
+        return this.Hs.hs(t3), this.Js[t3] || "not-current";
+    }
+    updateQueryState(t3, e2, i2) {
+        this.Js[t3] = e2;
+    }
+    removeLocalQueryTarget(t3) {
+        this.Hs.Ps(t3);
+    }
+    isLocalQueryTarget(t3) {
+        return this.Hs.activeTargetIds.has(t3);
+    }
+    clearQueryState(t3) {
+        delete this.Js[t3];
+    }
+    getAllActiveQueryTargets() {
+        return this.Hs.activeTargetIds;
+    }
+    isActiveQueryTarget(t3) {
+        return this.Hs.activeTargetIds.has(t3);
+    }
+    start() {
+        return this.Hs = new __PRIVATE_LocalClientState(), Promise.resolve();
+    }
+    handleUserChange(t3, e2, i2) {}
+    setOnlineState(t3) {}
+    shutdown() {}
+    writeSequenceNumber(t3) {}
+    notifyBundleLoaded(t3) {}
+}
+class __PRIVATE_NoopConnectivityMonitor {
+    Ys(t3) {}
+    shutdown() {}
+}
+class __PRIVATE_BrowserConnectivityMonitor {
+    constructor() {
+        this.Zs = () => this.Xs(), this.eo = () => this.no(), this.ro = [], this.io();
+    }
+    Ys(t3) {
+        this.ro.push(t3);
+    }
+    shutdown() {
+        window.removeEventListener("online", this.Zs), window.removeEventListener("offline", this.eo);
+    }
+    io() {
+        window.addEventListener("online", this.Zs), window.addEventListener("offline", this.eo);
+    }
+    Xs() {
+        jy("ConnectivityMonitor", "Network connectivity changed: AVAILABLE");
+        for (const t3 of this.ro)
+            t3(0);
+    }
+    no() {
+        jy("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE");
+        for (const t3 of this.ro)
+            t3(1);
+    }
+    static v() {
+        return "undefined" != typeof window && void 0 !== window.addEventListener && void 0 !== window.removeEventListener;
+    }
+}
+let d_ = null;
+
+function f_() {
+    return null === d_ ? d_ = 268435456 + Math.round(2147483648 * Math.random()) : d_++, "0x" + d_.toString(16);
+}
+const p_ = {
+    BatchGetDocuments: "batchGet",
+    Commit: "commit",
+    RunQuery: "runQuery",
+    RunAggregationQuery: "runAggregationQuery"
+};
+class __PRIVATE_StreamBridge {
+    constructor(t3) {
+        this.so = t3.so, this.oo = t3.oo;
+    }
+    _o(t3) {
+        this.ao = t3;
+    }
+    uo(t3) {
+        this.co = t3;
+    }
+    onMessage(t3) {
+        this.lo = t3;
+    }
+    close() {
+        this.oo();
+    }
+    send(t3) {
+        this.so(t3);
+    }
+    ho() {
+        this.ao();
+    }
+    Po(t3) {
+        this.co(t3);
+    }
+    Io(t3) {
+        this.lo(t3);
+    }
+}
+const m_ = "WebChannelConnection";
+class __PRIVATE_WebChannelConnection extends class __PRIVATE_RestConnection {
+    constructor(t3) {
+        this.databaseInfo = t3, this.databaseId = t3.databaseId;
+        const e2 = t3.ssl ? "https" : "http";
+        this.To = e2 + "://" + t3.host, this.Eo = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents";
+    }
+    get Ao() {
+        return false;
+    }
+    Ro(t3, e2, i2, s2, n2) {
+        const r2 = f_(),
+            o2 = this.Vo(t3, e2);
+        jy("RestConnection", `Sending RPC '${t3}' ${r2}:`, o2, i2);
+        const a2 = {};
+        return this.mo(a2, s2, n2), this.fo(t3, o2, a2, i2).then((e3) => (jy("RestConnection", `Received RPC '${t3}' ${r2}: `, e3), e3), (e3) => {
+            throw Wy("RestConnection", `RPC '${t3}' ${r2} failed with error: `, e3, "url: ", o2, "request:", i2), e3;
+        });
+    }
+    po(t3, e2, i2, s2, n2, r2) {
+        return this.Ro(t3, e2, i2, s2, n2);
+    }
+    mo(t3, e2, i2) {
+        t3["X-Goog-Api-Client"] = "gl-js/ fire/" + zy, t3["Content-Type"] = "text/plain", this.databaseInfo.appId && (t3["X-Firebase-GMPID"] = this.databaseInfo.appId), e2 && e2.headers.forEach((e3, i3) => t3[i3] = e3), i2 && i2.headers.forEach((e3, i3) => t3[i3] = e3);
+    }
+    Vo(t3, e2) {
+        const i2 = p_[t3];
+        return `${this.To}/v1/${e2}:${i2}`;
+    }
+} {
+    constructor(t3) {
+        super(t3), this.forceLongPolling = t3.forceLongPolling, this.autoDetectLongPolling = t3.autoDetectLongPolling, this.useFetchStreams = t3.useFetchStreams, this.longPollingOptions = t3.longPollingOptions;
+    }
+    fo(t3, e2, i2, s2) {
+        const n2 = f_();
+        return new Promise((r2, o2) => {
+            const a2 = new Fy();
+            a2.setWithCredentials(true), a2.listenOnce(Py.COMPLETE, () => {
+                try {
+                    switch (a2.getLastErrorCode()) {
+                        case My.NO_ERROR:
+                            const e3 = a2.getResponseJson();
+                            jy(m_, `XHR for RPC '${t3}' ${n2} received:`, JSON.stringify(e3)), r2(e3);
+                            break;
+                        case My.TIMEOUT:
+                            jy(m_, `RPC '${t3}' ${n2} timed out`), o2(new FirestoreError(Qy.DEADLINE_EXCEEDED, "Request time out"));
+                            break;
+                        case My.HTTP_ERROR:
+                            const i3 = a2.getStatus();
+                            if (jy(m_, `RPC '${t3}' ${n2} failed with status:`, i3, "response text:", a2.getResponseText()), i3 > 0) {
+                                let t4 = a2.getResponseJson();
+                                Array.isArray(t4) && (t4 = t4[0]);
+                                const e4 = null == t4 ? void 0 : t4.error;
+                                if (e4 && e4.status && e4.message) {
+                                    const t5 = function(t6) {
+                                        const e5 = t6.toLowerCase().replace(/_/g, "-");
+                                        return Object.values(Qy).indexOf(e5) >= 0 ? e5 : Qy.UNKNOWN;
+                                    }(e4.status);
+                                    o2(new FirestoreError(t5, e4.message));
+                                } else
+                                    o2(new FirestoreError(Qy.UNKNOWN, "Server responded with status " + a2.getStatus()));
+                            } else
+                                o2(new FirestoreError(Qy.UNAVAILABLE, "Connection failed."));
+                            break;
+                        default:
+                            Ky();
+                    }
+                } finally {
+                    jy(m_, `RPC '${t3}' ${n2} completed.`);
+                }
+            });
+            const l2 = JSON.stringify(s2);
+            jy(m_, `RPC '${t3}' ${n2} sending request:`, s2), a2.send(e2, "POST", l2, i2, 15);
+        });
+    }
+    yo(t3, e2, i2) {
+        const s2 = f_(),
+            n2 = [this.To, "/", "google.firestore.v1.Firestore", "/", t3, "/channel"],
+            r2 = new ry(),
+            o2 = nm(),
+            a2 = {
+                httpSessionIdParam: "gsessionid",
+                initMessageHeaders: {},
+                messageUrlParams: {
+                    database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
+                },
+                sendRawJson: true,
+                supportsCrossDomainXhr: true,
+                internalChannelParams: {
+                    forwardChannelRequestTimeoutMs: 6e5
+                },
+                forceLongPolling: this.forceLongPolling,
+                detectBufferingProxy: this.autoDetectLongPolling
+            },
+            l2 = this.longPollingOptions.timeoutSeconds;
+        void 0 !== l2 && (a2.longPollingTimeout = Math.round(1e3 * l2)), this.useFetchStreams && (a2.xmlHttpFactory = new Ly({})), this.mo(a2.initMessageHeaders, e2, i2), a2.encodeInitMessageHeaders = true;
+        const h2 = n2.join("");
+        jy(m_, `Creating RPC '${t3}' stream ${s2}: ${h2}`, a2);
+        const c2 = r2.createWebChannel(h2, a2);
+        let u2 = false,
+            d2 = false;
+        const f2 = new __PRIVATE_StreamBridge({
+                so: (e3) => {
+                    d2 ? jy(m_, `Not sending because RPC '${t3}' stream ${s2} is closed:`, e3) : (u2 || (jy(m_, `Opening RPC '${t3}' stream ${s2} transport.`), c2.open(), u2 = true), jy(m_, `RPC '${t3}' stream ${s2} sending:`, e3), c2.send(e3));
+                },
+                oo: () => c2.close()
+            }),
+            p2 = (t4, e3, i3) => {
+                t4.listen(e3, (t5) => {
+                    try {
+                        i3(t5);
+                    } catch (t6) {
+                        setTimeout(() => {
+                            throw t6;
+                        }, 0);
+                    }
+                });
+            };
+        return p2(c2, Oy.EventType.OPEN, () => {
+            d2 || jy(m_, `RPC '${t3}' stream ${s2} transport opened.`);
+        }), p2(c2, Oy.EventType.CLOSE, () => {
+            d2 || (d2 = true, jy(m_, `RPC '${t3}' stream ${s2} transport closed`), f2.Po());
+        }), p2(c2, Oy.EventType.ERROR, (e3) => {
+            d2 || (d2 = true, Wy(m_, `RPC '${t3}' stream ${s2} transport errored:`, e3), f2.Po(new FirestoreError(Qy.UNAVAILABLE, "The operation could not be completed")));
+        }), p2(c2, Oy.EventType.MESSAGE, (e3) => {
+            var i3;
+            if (!d2) {
+                const n3 = e3.data[0];
+                Gy(!!n3);
+                const r3 = n3,
+                    o3 = r3.error || (null === (i3 = r3[0]) || void 0 === i3 ? void 0 : i3.error);
+                if (o3) {
+                    jy(m_, `RPC '${t3}' stream ${s2} received error:`, o3);
+                    const e4 = o3.status;
+                    let i4 = function(t4) {
+                            const e5 = Mb[t4];
+                            if (void 0 !== e5)
+                                return Rb(e5);
+                        }(e4),
+                        n4 = o3.message;
+                    void 0 === i4 && (i4 = Qy.INTERNAL, n4 = "Unknown error status: " + e4 + " with message " + o3.message), d2 = true, f2.Po(new FirestoreError(i4, n4)), c2.close();
+                } else
+                    jy(m_, `RPC '${t3}' stream ${s2} received:`, n3), f2.Io(n3);
+            }
+        }), p2(o2, Ry.STAT_EVENT, (e3) => {
+            e3.stat === Ay ? jy(m_, `RPC '${t3}' stream ${s2} detected buffering proxy`) : e3.stat === Dy && jy(m_, `RPC '${t3}' stream ${s2} detected no buffering proxy`);
+        }), setTimeout(() => {
+            f2.ho();
+        }, 0), f2;
+    }
+}
+
+function g_() {
+    return "undefined" != typeof document ? document : null;
+}
+
+function y_(t3) {
+    return new JsonProtoSerializer(t3, true);
+}
+class __PRIVATE_ExponentialBackoff {
+    constructor(t3, e2, i2 = 1e3, s2 = 1.5, n2 = 6e4) {
+        this.ii = t3, this.timerId = e2, this.wo = i2, this.So = s2, this.bo = n2, this.Do = 0, this.vo = null, this.Co = Date.now(), this.reset();
+    }
+    reset() {
+        this.Do = 0;
+    }
+    Fo() {
+        this.Do = this.bo;
+    }
+    Mo(t3) {
+        this.cancel();
+        const e2 = Math.floor(this.Do + this.xo()),
+            i2 = Math.max(0, Date.now() - this.Co),
+            s2 = Math.max(0, e2 - i2);
+        s2 > 0 && jy("ExponentialBackoff", `Backing off for ${s2} ms (base delay: ${this.Do} ms, delay with jitter: ${e2} ms, last attempt: ${i2} ms ago)`), this.vo = this.ii.enqueueAfterDelay(this.timerId, s2, () => (this.Co = Date.now(), t3())), this.Do *= this.So, this.Do < this.wo && (this.Do = this.wo), this.Do > this.bo && (this.Do = this.bo);
+    }
+    Oo() {
+        null !== this.vo && (this.vo.skipDelay(), this.vo = null);
+    }
+    cancel() {
+        null !== this.vo && (this.vo.cancel(), this.vo = null);
+    }
+    xo() {
+        return (Math.random() - 0.5) * this.Do;
+    }
+}
+class __PRIVATE_PersistentStream {
+    constructor(t3, e2, i2, s2, n2, r2, o2, a2) {
+        this.ii = t3, this.No = i2, this.Bo = s2, this.connection = n2, this.authCredentialsProvider = r2, this.appCheckCredentialsProvider = o2, this.listener = a2, this.state = 0, this.Lo = 0, this.ko = null, this.qo = null, this.stream = null, this.Qo = new __PRIVATE_ExponentialBackoff(t3, e2);
+    }
+    Ko() {
+        return 1 === this.state || 5 === this.state || this.$o();
+    }
+    $o() {
+        return 2 === this.state || 3 === this.state;
+    }
+    start() {
+        4 !== this.state ? this.auth() : this.Uo();
+    }
+    async stop() {
+        this.Ko() && await this.close(0);
+    }
+    Wo() {
+        this.state = 0, this.Qo.reset();
+    }
+    Go() {
+        this.$o() && null === this.ko && (this.ko = this.ii.enqueueAfterDelay(this.No, 6e4, () => this.zo()));
+    }
+    jo(t3) {
+        this.Ho(), this.stream.send(t3);
+    }
+    async zo() {
+        if (this.$o())
+            return this.close(0);
+    }
+    Ho() {
+        this.ko && (this.ko.cancel(), this.ko = null);
+    }
+    Jo() {
+        this.qo && (this.qo.cancel(), this.qo = null);
+    }
+    async close(t3, e2) {
+        this.Ho(), this.Jo(), this.Qo.cancel(), this.Lo++, 4 !== t3 ? this.Qo.reset() : e2 && e2.code === Qy.RESOURCE_EXHAUSTED ? (Hy(e2.toString()), Hy("Using maximum backoff delay to prevent overloading the backend."), this.Qo.Fo()) : e2 && e2.code === Qy.UNAUTHENTICATED && 3 !== this.state && (this.authCredentialsProvider.invalidateToken(), this.appCheckCredentialsProvider.invalidateToken()), null !== this.stream && (this.Yo(), this.stream.close(), this.stream = null), this.state = t3, await this.listener.uo(e2);
+    }
+    Yo() {}
+    auth() {
+        this.state = 1;
+        const t3 = this.Zo(this.Lo),
+            e2 = this.Lo;
+        Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then(([t4, i2]) => {
+            this.Lo === e2 && this.Xo(t4, i2);
+        }, (e3) => {
+            t3(() => {
+                const t4 = new FirestoreError(Qy.UNKNOWN, "Fetching auth token failed: " + e3.message);
+                return this.e_(t4);
+            });
+        });
+    }
+    Xo(t3, e2) {
+        const i2 = this.Zo(this.Lo);
+        this.stream = this.t_(t3, e2), this.stream._o(() => {
+            i2(() => (this.state = 2, this.qo = this.ii.enqueueAfterDelay(this.Bo, 1e4, () => (this.$o() && (this.state = 3), Promise.resolve())), this.listener._o()));
+        }), this.stream.uo((t4) => {
+            i2(() => this.e_(t4));
+        }), this.stream.onMessage((t4) => {
+            i2(() => this.onMessage(t4));
+        });
+    }
+    Uo() {
+        this.state = 5, this.Qo.Mo(async () => {
+            this.state = 0, this.start();
+        });
+    }
+    e_(t3) {
+        return jy("PersistentStream", `close with error: ${t3}`), this.stream = null, this.close(4, t3);
+    }
+    Zo(t3) {
+        return (e2) => {
+            this.ii.enqueueAndForget(() => this.Lo === t3 ? e2() : (jy("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()));
+        };
+    }
+}
+class __PRIVATE_PersistentListenStream extends __PRIVATE_PersistentStream {
+    constructor(t3, e2, i2, s2, n2, r2) {
+        super(t3, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", e2, i2, s2, r2), this.serializer = n2;
+    }
+    t_(t3, e2) {
+        return this.connection.yo("Listen", t3, e2);
+    }
+    onMessage(t3) {
+        this.Qo.reset();
+        const e2 = function(t4, e3) {
+                let i3;
+                if ("targetChange" in e3) {
+                    e3.targetChange;
+                    const s2 = function(t5) {
+                            return "NO_CHANGE" === t5 ? 0 : "ADD" === t5 ? 1 : "REMOVE" === t5 ? 2 : "CURRENT" === t5 ? 3 : "RESET" === t5 ? 4 : Ky();
+                        }(e3.targetChange.targetChangeType || "NO_CHANGE"),
+                        n2 = e3.targetChange.targetIds || [],
+                        r2 = function(t5, e4) {
+                            return t5.useProto3Json ? (Gy(void 0 === e4 || "string" == typeof e4), ByteString.fromBase64String(e4 || "")) : (Gy(void 0 === e4 || e4 instanceof Uint8Array), ByteString.fromUint8Array(e4 || new Uint8Array()));
+                        }(t4, e3.targetChange.resumeToken),
+                        o2 = e3.targetChange.cause,
+                        a2 = o2 && function(t5) {
+                            const e4 = void 0 === t5.code ? Qy.UNKNOWN : Rb(t5.code);
+                            return new FirestoreError(e4, t5.message || "");
+                        }(o2);
+                    i3 = new __PRIVATE_WatchTargetChange(s2, n2, r2, a2 || null);
+                } else if ("documentChange" in e3) {
+                    e3.documentChange;
+                    const s2 = e3.documentChange;
+                    s2.document, s2.document.name, s2.document.updateTime;
+                    const n2 = Wb(t4, s2.document.name),
+                        r2 = jb(s2.document.updateTime),
+                        o2 = s2.document.createTime ? jb(s2.document.createTime) : SnapshotVersion.min(),
+                        a2 = new ObjectValue({
+                            mapValue: {
+                                fields: s2.document.fields
+                            }
+                        }),
+                        l2 = MutableDocument.newFoundDocument(n2, r2, o2, a2),
+                        h2 = s2.targetIds || [],
+                        c2 = s2.removedTargetIds || [];
+                    i3 = new __PRIVATE_DocumentWatchChange(h2, c2, l2.key, l2);
+                } else if ("documentDelete" in e3) {
+                    e3.documentDelete;
+                    const s2 = e3.documentDelete;
+                    s2.document;
+                    const n2 = Wb(t4, s2.document),
+                        r2 = s2.readTime ? jb(s2.readTime) : SnapshotVersion.min(),
+                        o2 = MutableDocument.newNoDocument(n2, r2),
+                        a2 = s2.removedTargetIds || [];
+                    i3 = new __PRIVATE_DocumentWatchChange([], a2, o2.key, o2);
+                } else if ("documentRemove" in e3) {
+                    e3.documentRemove;
+                    const s2 = e3.documentRemove;
+                    s2.document;
+                    const n2 = Wb(t4, s2.document),
+                        r2 = s2.removedTargetIds || [];
+                    i3 = new __PRIVATE_DocumentWatchChange([], r2, n2, null);
+                } else {
+                    if (!("filter" in e3))
+                        return Ky();
+                    {
+                        e3.filter;
+                        const t5 = e3.filter;
+                        t5.targetId;
+                        const {
+                            count: s2 = 0,
+                            unchangedNames: n2
+                        } = t5, r2 = new ExistenceFilter(s2, n2), o2 = t5.targetId;
+                        i3 = new __PRIVATE_ExistenceFilterChange(o2, r2);
+                    }
+                }
+                return i3;
+            }(this.serializer, t3),
+            i2 = function(t4) {
+                if (!("targetChange" in t4))
+                    return SnapshotVersion.min();
+                const e3 = t4.targetChange;
+                return e3.targetIds && e3.targetIds.length ? SnapshotVersion.min() : e3.readTime ? jb(e3.readTime) : SnapshotVersion.min();
+            }(t3);
+        return this.listener.n_(e2, i2);
+    }
+    r_(t3) {
+        const e2 = {};
+        e2.database = Kb(this.serializer), e2.addTarget = function(t4, e3) {
+            let i3;
+            const s2 = e3.target;
+            if (i3 = jv(s2) ? {
+                    documents: Yb(t4, s2)
+                } : {
+                    query: Qb(t4, s2)
+                }, i3.targetId = e3.targetId, e3.resumeToken.approximateByteSize() > 0) {
+                i3.resumeToken = function(t5, e4) {
+                    return t5.useProto3Json ? e4.toBase64() : e4.toUint8Array();
+                }(t4, e3.resumeToken);
+                const s3 = Ub(t4, e3.expectedCount);
+                null !== s3 && (i3.expectedCount = s3);
+            } else if (e3.snapshotVersion.compareTo(SnapshotVersion.min()) > 0) {
+                i3.readTime = function(t5, e4) {
+                    return t5.useProto3Json ? `${new Date(1e3 * e4.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + e4.nanoseconds).slice(-9)}Z` : {
+                        seconds: "" + e4.seconds,
+                        nanos: e4.nanoseconds
+                    };
+                }(t4, e3.snapshotVersion.toTimestamp());
+                const s3 = Ub(t4, e3.expectedCount);
+                null !== s3 && (i3.expectedCount = s3);
+            }
+            return i3;
+        }(this.serializer, t3);
+        const i2 = function(t4, e3) {
+            const i3 = function(t5) {
+                switch (t5) {
+                    case "TargetPurposeListen":
+                        return null;
+                    case "TargetPurposeExistenceFilterMismatch":
+                        return "existence-filter-mismatch";
+                    case "TargetPurposeExistenceFilterMismatchBloom":
+                        return "existence-filter-mismatch-bloom";
+                    case "TargetPurposeLimboResolution":
+                        return "limbo-document";
+                    default:
+                        return Ky();
+                }
+            }(e3.purpose);
+            return null == i3 ? null : {
+                "goog-listen-tags": i3
+            };
+        }(this.serializer, t3);
+        i2 && (e2.labels = i2), this.jo(e2);
+    }
+    i_(t3) {
+        const e2 = {};
+        e2.database = Kb(this.serializer), e2.removeTarget = t3, this.jo(e2);
+    }
+}
+class __PRIVATE_DatastoreImpl extends class Datastore {} {
+    constructor(t3, e2, i2, s2) {
+        super(), this.authCredentials = t3, this.appCheckCredentials = e2, this.connection = i2, this.serializer = s2, this.l_ = false;
+    }
+    h_() {
+        if (this.l_)
+            throw new FirestoreError(Qy.FAILED_PRECONDITION, "The client has already been terminated.");
+    }
+    Ro(t3, e2, i2) {
+        return this.h_(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s2, n2]) => this.connection.Ro(t3, e2, i2, s2, n2)).catch((t4) => {
+            throw "FirebaseError" === t4.name ? (t4.code === Qy.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), t4) : new FirestoreError(Qy.UNKNOWN, t4.toString());
+        });
+    }
+    po(t3, e2, i2, s2) {
+        return this.h_(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([n2, r2]) => this.connection.po(t3, e2, i2, n2, r2, s2)).catch((t4) => {
+            throw "FirebaseError" === t4.name ? (t4.code === Qy.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), t4) : new FirestoreError(Qy.UNKNOWN, t4.toString());
+        });
+    }
+    terminate() {
+        this.l_ = true;
+    }
+}
+class __PRIVATE_OnlineStateTracker {
+    constructor(t3, e2) {
+        this.asyncQueue = t3, this.onlineStateHandler = e2, this.state = "Unknown", this.I_ = 0, this.T_ = null, this.E_ = true;
+    }
+    d_() {
+        0 === this.I_ && (this.A_("Unknown"), this.T_ = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.T_ = null, this.R_("Backend didn't respond within 10 seconds."), this.A_("Offline"), Promise.resolve())));
+    }
+    V_(t3) {
+        "Online" === this.state ? this.A_("Unknown") : (this.I_++, this.I_ >= 1 && (this.m_(), this.R_(`Connection failed 1 times. Most recent error: ${t3.toString()}`), this.A_("Offline")));
+    }
+    set(t3) {
+        this.m_(), this.I_ = 0, "Online" === t3 && (this.E_ = false), this.A_(t3);
+    }
+    A_(t3) {
+        t3 !== this.state && (this.state = t3, this.onlineStateHandler(t3));
+    }
+    R_(t3) {
+        const e2 = `Could not reach Cloud Firestore backend. ${t3}
+This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
+        this.E_ ? (Hy(e2), this.E_ = false) : jy("OnlineStateTracker", e2);
+    }
+    m_() {
+        null !== this.T_ && (this.T_.cancel(), this.T_ = null);
+    }
+}
+class __PRIVATE_RemoteStoreImpl {
+    constructor(t3, e2, i2, s2, n2) {
+        this.localStore = t3, this.datastore = e2, this.asyncQueue = i2, this.remoteSyncer = {}, this.f_ = [], this.g_ = /* @__PURE__ */ new Map(), this.p_ = /* @__PURE__ */ new Set(), this.y_ = [], this.w_ = n2, this.w_.Ys((t4) => {
+            i2.enqueueAndForget(async () => {
+                E_(this) && (jy("RemoteStore", "Restarting streams for network reachability change."), await async function(t5) {
+                    const e3 = Yy(t5);
+                    e3.p_.add(4), await b_(e3), e3.S_.set("Unknown"), e3.p_.delete(4), await v_(e3);
+                }(this));
+            });
+        }), this.S_ = new __PRIVATE_OnlineStateTracker(i2, s2);
+    }
+}
+async function v_(t3) {
+    if (E_(t3))
+        for (const e2 of t3.y_)
+            await e2(true);
+}
+async function b_(t3) {
+    for (const e2 of t3.y_)
+        await e2(false);
+}
+
+function __(t3, e2) {
+    const i2 = Yy(t3);
+    i2.g_.has(e2.targetId) || (i2.g_.set(e2.targetId, e2), S_(i2) ? T_(i2) : D_(i2).$o() && x_(i2, e2));
+}
+
+function w_(t3, e2) {
+    const i2 = Yy(t3),
+        s2 = D_(i2);
+    i2.g_.delete(e2), s2.$o() && k_(i2, e2), 0 === i2.g_.size && (s2.$o() ? s2.Go() : E_(i2) && i2.S_.set("Unknown"));
+}
+
+function x_(t3, e2) {
+    if (t3.b_.Be(e2.targetId), e2.resumeToken.approximateByteSize() > 0 || e2.snapshotVersion.compareTo(SnapshotVersion.min()) > 0) {
+        const i2 = t3.remoteSyncer.getRemoteKeysForTarget(e2.targetId).size;
+        e2 = e2.withExpectedCount(i2);
+    }
+    D_(t3).r_(e2);
+}
+
+function k_(t3, e2) {
+    t3.b_.Be(e2), D_(t3).i_(e2);
+}
+
+function T_(t3) {
+    t3.b_ = new __PRIVATE_WatchChangeAggregator({
+        getRemoteKeysForTarget: (e2) => t3.remoteSyncer.getRemoteKeysForTarget(e2),
+        ut: (e2) => t3.g_.get(e2) || null,
+        rt: () => t3.datastore.serializer.databaseId
+    }), D_(t3).start(), t3.S_.d_();
+}
+
+function S_(t3) {
+    return E_(t3) && !D_(t3).Ko() && t3.g_.size > 0;
+}
+
+function E_(t3) {
+    return 0 === Yy(t3).p_.size;
+}
+
+function C_(t3) {
+    t3.b_ = void 0;
+}
+async function I_(t3) {
+    t3.g_.forEach((e2, i2) => {
+        x_(t3, e2);
+    });
+}
+async function M_(t3, e2) {
+    C_(t3), S_(t3) ? (t3.S_.V_(e2), T_(t3)) : t3.S_.set("Unknown");
+}
+async function P_(t3, e2, i2) {
+    if (t3.S_.set("Online"), e2 instanceof __PRIVATE_WatchTargetChange && 2 === e2.state && e2.cause)
+        try {
+            await async function(t4, e3) {
+                const i3 = e3.cause;
+                for (const s2 of e3.targetIds)
+                    t4.g_.has(s2) && (await t4.remoteSyncer.rejectListen(s2, i3), t4.g_.delete(s2), t4.b_.removeTarget(s2));
+            }(t3, e2);
+        } catch (i3) {
+            jy("RemoteStore", "Failed to remove targets %s: %s ", e2.targetIds.join(","), i3), await R_(t3, i3);
+        }
+    else if (e2 instanceof __PRIVATE_DocumentWatchChange ? t3.b_.We(e2) : e2 instanceof __PRIVATE_ExistenceFilterChange ? t3.b_.Ze(e2) : t3.b_.je(e2), !i2.isEqual(SnapshotVersion.min()))
+        try {
+            const e3 = await l_(t3.localStore);
+            i2.compareTo(e3) >= 0 && await
+            function(t4, e4) {
+                const i3 = t4.b_.st(e4);
+                return i3.targetChanges.forEach((i4, s2) => {
+                    if (i4.resumeToken.approximateByteSize() > 0) {
+                        const n2 = t4.g_.get(s2);
+                        n2 && t4.g_.set(s2, n2.withResumeToken(i4.resumeToken, e4));
+                    }
+                }), i3.targetMismatches.forEach((e5, i4) => {
+                    const s2 = t4.g_.get(e5);
+                    if (!s2)
+                        return;
+                    t4.g_.set(e5, s2.withResumeToken(ByteString.EMPTY_BYTE_STRING, s2.snapshotVersion)), k_(t4, e5);
+                    const n2 = new TargetData(s2.target, e5, i4, s2.sequenceNumber);
+                    x_(t4, n2);
+                }), t4.remoteSyncer.applyRemoteEvent(i3);
+            }(t3, i2);
+        } catch (e3) {
+            jy("RemoteStore", "Failed to raise snapshot:", e3), await R_(t3, e3);
+        }
+}
+async function R_(t3, e2, i2) {
+    if (!rv(e2))
+        throw e2;
+    t3.p_.add(1), await b_(t3), t3.S_.set("Offline"), i2 || (i2 = () => l_(t3.localStore)), t3.asyncQueue.enqueueRetryable(async () => {
+        jy("RemoteStore", "Retrying IndexedDB access"), await i2(), t3.p_.delete(1), await v_(t3);
+    });
+}
+async function A_(t3, e2) {
+    const i2 = Yy(t3);
+    i2.asyncQueue.verifyOperationInProgress(), jy("RemoteStore", "RemoteStore received new credentials");
+    const s2 = E_(i2);
+    i2.p_.add(3), await b_(i2), s2 && i2.S_.set("Unknown"), await i2.remoteSyncer.handleCredentialChange(e2), i2.p_.delete(3), await v_(i2);
+}
+
+function D_(t3) {
+    return t3.D_ || (t3.D_ = function(t4, e2, i2) {
+        const s2 = Yy(t4);
+        return s2.h_(), new __PRIVATE_PersistentListenStream(e2, s2.connection, s2.authCredentials, s2.appCheckCredentials, s2.serializer, i2);
+    }(t3.datastore, t3.asyncQueue, {
+        _o: I_.bind(null, t3),
+        uo: M_.bind(null, t3),
+        n_: P_.bind(null, t3)
+    }), t3.y_.push(async (e2) => {
+        e2 ? (t3.D_.Wo(), S_(t3) ? T_(t3) : t3.S_.set("Unknown")) : (await t3.D_.stop(), C_(t3));
+    })), t3.D_;
+}
+class DelayedOperation {
+    constructor(t3, e2, i2, s2, n2) {
+        this.asyncQueue = t3, this.timerId = e2, this.targetTimeMs = i2, this.op = s2, this.removalCallback = n2, this.deferred = new __PRIVATE_Deferred(), this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch((t4) => {});
+    }
+    static createAndSchedule(t3, e2, i2, s2, n2) {
+        const r2 = Date.now() + i2,
+            o2 = new DelayedOperation(t3, e2, r2, s2, n2);
+        return o2.start(i2), o2;
+    }
+    start(t3) {
+        this.timerHandle = setTimeout(() => this.handleDelayElapsed(), t3);
+    }
+    skipDelay() {
+        return this.handleDelayElapsed();
+    }
+    cancel(t3) {
+        null !== this.timerHandle && (this.clearTimeout(), this.deferred.reject(new FirestoreError(Qy.CANCELLED, "Operation cancelled" + (t3 ? ": " + t3 : ""))));
+    }
+    handleDelayElapsed() {
+        this.asyncQueue.enqueueAndForget(() => null !== this.timerHandle ? (this.clearTimeout(), this.op().then((t3) => this.deferred.resolve(t3))) : Promise.resolve());
+    }
+    clearTimeout() {
+        null !== this.timerHandle && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
+    }
+}
+
+function L_(t3, e2) {
+    if (Hy("AsyncQueue", `${e2}: ${t3}`), rv(t3))
+        return new FirestoreError(Qy.UNAVAILABLE, `${e2}: ${t3}`);
+    throw t3;
+}
+class DocumentSet {
+    constructor(t3) {
+        this.comparator = t3 ? (e2, i2) => t3(e2, i2) || DocumentKey.comparator(e2.key, i2.key) : (t4, e2) => DocumentKey.comparator(t4.key, e2.key), this.keyedMap = rb(), this.sortedSet = new SortedMap(this.comparator);
+    }
+    static emptySet(t3) {
+        return new DocumentSet(t3.comparator);
+    }
+    has(t3) {
+        return null != this.keyedMap.get(t3);
+    }
+    get(t3) {
+        return this.keyedMap.get(t3);
+    }
+    first() {
+        return this.sortedSet.minKey();
+    }
+    last() {
+        return this.sortedSet.maxKey();
+    }
+    isEmpty() {
+        return this.sortedSet.isEmpty();
+    }
+    indexOf(t3) {
+        const e2 = this.keyedMap.get(t3);
+        return e2 ? this.sortedSet.indexOf(e2) : -1;
+    }
+    get size() {
+        return this.sortedSet.size;
+    }
+    forEach(t3) {
+        this.sortedSet.inorderTraversal((e2, i2) => (t3(e2), false));
+    }
+    add(t3) {
+        const e2 = this.delete(t3.key);
+        return e2.copy(e2.keyedMap.insert(t3.key, t3), e2.sortedSet.insert(t3, null));
+    }
+    delete(t3) {
+        const e2 = this.get(t3);
+        return e2 ? this.copy(this.keyedMap.remove(t3), this.sortedSet.remove(e2)) : this;
+    }
+    isEqual(t3) {
+        if (!(t3 instanceof DocumentSet))
+            return false;
+        if (this.size !== t3.size)
+            return false;
+        const e2 = this.sortedSet.getIterator(),
+            i2 = t3.sortedSet.getIterator();
+        for (; e2.hasNext();) {
+            const t4 = e2.getNext().key,
+                s2 = i2.getNext().key;
+            if (!t4.isEqual(s2))
+                return false;
+        }
+        return true;
+    }
+    toString() {
+        const t3 = [];
+        return this.forEach((e2) => {
+            t3.push(e2.toString());
+        }), 0 === t3.length ? "DocumentSet ()" : "DocumentSet (\n  " + t3.join("  \n") + "\n)";
+    }
+    copy(t3, e2) {
+        const i2 = new DocumentSet();
+        return i2.comparator = this.comparator, i2.keyedMap = t3, i2.sortedSet = e2, i2;
+    }
+}
+class __PRIVATE_DocumentChangeSet {
+    constructor() {
+        this.C_ = new SortedMap(DocumentKey.comparator);
+    }
+    track(t3) {
+        const e2 = t3.doc.key,
+            i2 = this.C_.get(e2);
+        i2 ? 0 !== t3.type && 3 === i2.type ? this.C_ = this.C_.insert(e2, t3) : 3 === t3.type && 1 !== i2.type ? this.C_ = this.C_.insert(e2, {
+            type: i2.type,
+            doc: t3.doc
+        }) : 2 === t3.type && 2 === i2.type ? this.C_ = this.C_.insert(e2, {
+            type: 2,
+            doc: t3.doc
+        }) : 2 === t3.type && 0 === i2.type ? this.C_ = this.C_.insert(e2, {
+            type: 0,
+            doc: t3.doc
+        }) : 1 === t3.type && 0 === i2.type ? this.C_ = this.C_.remove(e2) : 1 === t3.type && 2 === i2.type ? this.C_ = this.C_.insert(e2, {
+            type: 1,
+            doc: i2.doc
+        }) : 0 === t3.type && 1 === i2.type ? this.C_ = this.C_.insert(e2, {
+            type: 2,
+            doc: t3.doc
+        }) : Ky() : this.C_ = this.C_.insert(e2, t3);
+    }
+    F_() {
+        const t3 = [];
+        return this.C_.inorderTraversal((e2, i2) => {
+            t3.push(i2);
+        }), t3;
+    }
+}
+class ViewSnapshot {
+    constructor(t3, e2, i2, s2, n2, r2, o2, a2, l2) {
+        this.query = t3, this.docs = e2, this.oldDocs = i2, this.docChanges = s2, this.mutatedKeys = n2, this.fromCache = r2, this.syncStateChanged = o2, this.excludesMetadataChanges = a2, this.hasCachedResults = l2;
+    }
+    static fromInitialDocuments(t3, e2, i2, s2, n2) {
+        const r2 = [];
+        return e2.forEach((t4) => {
+            r2.push({
+                type: 0,
+                doc: t4
+            });
+        }), new ViewSnapshot(t3, e2, DocumentSet.emptySet(e2), r2, i2, s2, true, false, n2);
+    }
+    get hasPendingWrites() {
+        return !this.mutatedKeys.isEmpty();
+    }
+    isEqual(t3) {
+        if (!(this.fromCache === t3.fromCache && this.hasCachedResults === t3.hasCachedResults && this.syncStateChanged === t3.syncStateChanged && this.mutatedKeys.isEqual(t3.mutatedKeys) && Yv(this.query, t3.query) && this.docs.isEqual(t3.docs) && this.oldDocs.isEqual(t3.oldDocs)))
+            return false;
+        const e2 = this.docChanges,
+            i2 = t3.docChanges;
+        if (e2.length !== i2.length)
+            return false;
+        for (let t4 = 0; t4 < e2.length; t4++)
+            if (e2[t4].type !== i2[t4].type || !e2[t4].doc.isEqual(i2[t4].doc))
+                return false;
+        return true;
+    }
+}
+class __PRIVATE_QueryListenersInfo {
+    constructor() {
+        this.M_ = void 0, this.listeners = [];
+    }
+}
+class __PRIVATE_EventManagerImpl {
+    constructor() {
+        this.queries = new ObjectMap((t3) => Qv(t3), Yv), this.onlineState = "Unknown", this.x_ = /* @__PURE__ */ new Set();
+    }
+}
+
+function O_(t3, e2) {
+    const i2 = Yy(t3);
+    let s2 = false;
+    for (const t4 of e2) {
+        const e3 = t4.query,
+            n2 = i2.queries.get(e3);
+        if (n2) {
+            for (const e4 of n2.listeners)
+                e4.N_(t4) && (s2 = true);
+            n2.M_ = t4;
+        }
+    }
+    s2 && N_(i2);
+}
+
+function F_(t3, e2, i2) {
+    const s2 = Yy(t3),
+        n2 = s2.queries.get(e2);
+    if (n2)
+        for (const t4 of n2.listeners)
+            t4.onError(i2);
+    s2.queries.delete(e2);
+}
+
+function N_(t3) {
+    t3.x_.forEach((t4) => {
+        t4.next();
+    });
+}
+class __PRIVATE_QueryListener {
+    constructor(t3, e2, i2) {
+        this.query = t3, this.B_ = e2, this.L_ = false, this.k_ = null, this.onlineState = "Unknown", this.options = i2 || {};
+    }
+    N_(t3) {
+        if (!this.options.includeMetadataChanges) {
+            const e3 = [];
+            for (const i2 of t3.docChanges)
+                3 !== i2.type && e3.push(i2);
+            t3 = new ViewSnapshot(t3.query, t3.docs, t3.oldDocs, e3, t3.mutatedKeys, t3.fromCache, t3.syncStateChanged, true, t3.hasCachedResults);
+        }
+        let e2 = false;
+        return this.L_ ? this.q_(t3) && (this.B_.next(t3), e2 = true) : this.Q_(t3, this.onlineState) && (this.K_(t3), e2 = true), this.k_ = t3, e2;
+    }
+    onError(t3) {
+        this.B_.error(t3);
+    }
+    O_(t3) {
+        this.onlineState = t3;
+        let e2 = false;
+        return this.k_ && !this.L_ && this.Q_(this.k_, t3) && (this.K_(this.k_), e2 = true), e2;
+    }
+    Q_(t3, e2) {
+        if (!t3.fromCache)
+            return true;
+        const i2 = "Offline" !== e2;
+        return (!this.options.U_ || !i2) && (!t3.docs.isEmpty() || t3.hasCachedResults || "Offline" === e2);
+    }
+    q_(t3) {
+        if (t3.docChanges.length > 0)
+            return true;
+        const e2 = this.k_ && this.k_.hasPendingWrites !== t3.hasPendingWrites;
+        return !(!t3.syncStateChanged && !e2) && true === this.options.includeMetadataChanges;
+    }
+    K_(t3) {
+        t3 = ViewSnapshot.fromInitialDocuments(t3.query, t3.docs, t3.mutatedKeys, t3.fromCache, t3.hasCachedResults), this.L_ = true, this.B_.next(t3);
+    }
+}
+class __PRIVATE_AddedLimboDocument {
+    constructor(t3) {
+        this.key = t3;
+    }
+}
+class __PRIVATE_RemovedLimboDocument {
+    constructor(t3) {
+        this.key = t3;
+    }
+}
+class __PRIVATE_View {
+    constructor(t3, e2) {
+        this.query = t3, this.Z_ = e2, this.X_ = null, this.hasCachedResults = false, this.current = false, this.ea = ub(), this.mutatedKeys = ub(), this.ta = Zv(t3), this.na = new DocumentSet(this.ta);
+    }
+    get ra() {
+        return this.Z_;
+    }
+    ia(t3, e2) {
+        const i2 = e2 ? e2.sa : new __PRIVATE_DocumentChangeSet(),
+            s2 = e2 ? e2.na : this.na;
+        let n2 = e2 ? e2.mutatedKeys : this.mutatedKeys,
+            r2 = s2,
+            o2 = false;
+        const a2 = "F" === this.query.limitType && s2.size === this.query.limit ? s2.last() : null,
+            l2 = "L" === this.query.limitType && s2.size === this.query.limit ? s2.first() : null;
+        if (t3.inorderTraversal((t4, e3) => {
+                const h2 = s2.get(t4),
+                    c2 = Jv(this.query, e3) ? e3 : null,
+                    u2 = !!h2 && this.mutatedKeys.has(h2.key),
+                    d2 = !!c2 && (c2.hasLocalMutations || this.mutatedKeys.has(c2.key) && c2.hasCommittedMutations);
+                let f2 = false;
+                h2 && c2 ? h2.data.isEqual(c2.data) ? u2 !== d2 && (i2.track({
+                    type: 3,
+                    doc: c2
+                }), f2 = true) : this.oa(h2, c2) || (i2.track({
+                    type: 2,
+                    doc: c2
+                }), f2 = true, (a2 && this.ta(c2, a2) > 0 || l2 && this.ta(c2, l2) < 0) && (o2 = true)) : !h2 && c2 ? (i2.track({
+                    type: 0,
+                    doc: c2
+                }), f2 = true) : h2 && !c2 && (i2.track({
+                    type: 1,
+                    doc: h2
+                }), f2 = true, (a2 || l2) && (o2 = true)), f2 && (c2 ? (r2 = r2.add(c2), n2 = d2 ? n2.add(t4) : n2.delete(t4)) : (r2 = r2.delete(t4), n2 = n2.delete(t4)));
+            }), null !== this.query.limit)
+            for (; r2.size > this.query.limit;) {
+                const t4 = "F" === this.query.limitType ? r2.last() : r2.first();
+                r2 = r2.delete(t4.key), n2 = n2.delete(t4.key), i2.track({
+                    type: 1,
+                    doc: t4
+                });
+            }
+        return {
+            na: r2,
+            sa: i2,
+            zi: o2,
+            mutatedKeys: n2
+        };
+    }
+    oa(t3, e2) {
+        return t3.hasLocalMutations && e2.hasCommittedMutations && !e2.hasLocalMutations;
+    }
+    applyChanges(t3, e2, i2) {
+        const s2 = this.na;
+        this.na = t3.na, this.mutatedKeys = t3.mutatedKeys;
+        const n2 = t3.sa.F_();
+        n2.sort((t4, e3) => function(t5, e4) {
+            const i3 = (t6) => {
+                switch (t6) {
+                    case 0:
+                        return 1;
+                    case 2:
+                    case 3:
+                        return 2;
+                    case 1:
+                        return 0;
+                    default:
+                        return Ky();
+                }
+            };
+            return i3(t5) - i3(e4);
+        }(t4.type, e3.type) || this.ta(t4.doc, e3.doc)), this._a(i2);
+        const r2 = e2 ? this.aa() : [],
+            o2 = 0 === this.ea.size && this.current ? 1 : 0,
+            a2 = o2 !== this.X_;
+        return this.X_ = o2, 0 !== n2.length || a2 ? {
+            snapshot: new ViewSnapshot(this.query, t3.na, s2, n2, t3.mutatedKeys, 0 === o2, a2, false, !!i2 && i2.resumeToken.approximateByteSize() > 0),
+            ua: r2
+        } : {
+            ua: r2
+        };
+    }
+    O_(t3) {
+        return this.current && "Offline" === t3 ? (this.current = false, this.applyChanges({
+            na: this.na,
+            sa: new __PRIVATE_DocumentChangeSet(),
+            mutatedKeys: this.mutatedKeys,
+            zi: false
+        }, false)) : {
+            ua: []
+        };
+    }
+    ca(t3) {
+        return !this.Z_.has(t3) && !!this.na.has(t3) && !this.na.get(t3).hasLocalMutations;
+    }
+    _a(t3) {
+        t3 && (t3.addedDocuments.forEach((t4) => this.Z_ = this.Z_.add(t4)), t3.modifiedDocuments.forEach((t4) => {}), t3.removedDocuments.forEach((t4) => this.Z_ = this.Z_.delete(t4)), this.current = t3.current);
+    }
+    aa() {
+        if (!this.current)
+            return [];
+        const t3 = this.ea;
+        this.ea = ub(), this.na.forEach((t4) => {
+            this.ca(t4.key) && (this.ea = this.ea.add(t4.key));
+        });
+        const e2 = [];
+        return t3.forEach((t4) => {
+            this.ea.has(t4) || e2.push(new __PRIVATE_RemovedLimboDocument(t4));
+        }), this.ea.forEach((i2) => {
+            t3.has(i2) || e2.push(new __PRIVATE_AddedLimboDocument(i2));
+        }), e2;
+    }
+    la(t3) {
+        this.Z_ = t3.ss, this.ea = ub();
+        const e2 = this.ia(t3.documents);
+        return this.applyChanges(e2, true);
+    }
+    ha() {
+        return ViewSnapshot.fromInitialDocuments(this.query, this.na, this.mutatedKeys, 0 === this.X_, this.hasCachedResults);
+    }
+}
+class __PRIVATE_QueryView {
+    constructor(t3, e2, i2) {
+        this.query = t3, this.targetId = e2, this.view = i2;
+    }
+}
+class LimboResolution {
+    constructor(t3) {
+        this.key = t3, this.Pa = false;
+    }
+}
+class __PRIVATE_SyncEngineImpl {
+    constructor(t3, e2, i2, s2, n2, r2) {
+        this.localStore = t3, this.remoteStore = e2, this.eventManager = i2, this.sharedClientState = s2, this.currentUser = n2, this.maxConcurrentLimboResolutions = r2, this.Ia = {}, this.Ta = new ObjectMap((t4) => Qv(t4), Yv), this.Ea = /* @__PURE__ */ new Map(), this.da = /* @__PURE__ */ new Set(), this.Aa = new SortedMap(DocumentKey.comparator), this.Ra = /* @__PURE__ */ new Map(), this.Va = new __PRIVATE_ReferenceSet(), this.ma = {}, this.fa = /* @__PURE__ */ new Map(), this.ga = __PRIVATE_TargetIdGenerator.On(), this.onlineState = "Unknown", this.pa = void 0;
+    }
+    get isPrimaryClient() {
+        return true === this.pa;
+    }
+}
+async function $_(t3, e2) {
+    const i2 = function(t4) {
+        const e3 = Yy(t4);
+        return e3.remoteStore.remoteSyncer.applyRemoteEvent = z_.bind(null, e3), e3.remoteStore.remoteSyncer.getRemoteKeysForTarget = Q_.bind(null, e3), e3.remoteStore.remoteSyncer.rejectListen = U_.bind(null, e3), e3.Ia.n_ = O_.bind(null, e3.eventManager), e3.Ia.wa = F_.bind(null, e3.eventManager), e3;
+    }(t3);
+    let s2, n2;
+    const r2 = i2.Ta.get(e2);
+    if (r2)
+        s2 = r2.targetId, i2.sharedClientState.addLocalQueryTarget(s2), n2 = r2.view.ha();
+    else {
+        const t4 = await
+        function(t5, e3) {
+            const i3 = Yy(t5);
+            return i3.persistence.runTransaction("Allocate target", "readwrite", (t6) => {
+                let s3;
+                return i3.kr.getTargetData(t6, e3).next((n3) => n3 ? (s3 = n3, PersistencePromise.resolve(s3)) : i3.kr.allocateTargetId(t6).next((n4) => (s3 = new TargetData(e3, n4, "TargetPurposeListen", t6.currentSequenceNumber), i3.kr.addTargetData(t6, s3).next(() => s3))));
+            }).then((t6) => {
+                const s3 = i3.Ji.get(t6.targetId);
+                return (null === s3 || t6.snapshotVersion.compareTo(s3.snapshotVersion) > 0) && (i3.Ji = i3.Ji.insert(t6.targetId, t6), i3.Yi.set(e3, t6.targetId)), t6;
+            });
+        }(i2.localStore, Kv(e2)), r3 = i2.sharedClientState.addLocalQueryTarget(t4.targetId);
+        s2 = t4.targetId, n2 = await async function(t5, e3, i3, s3, n3) {
+            t5.ya = (e4, i4, s4) => async function(t6, e5, i5, s5) {
+                let n4 = e5.view.ia(i5);
+                n4.zi && (n4 = await u_(t6.localStore, e5.query, false).then(({
+                    documents: t7
+                }) => e5.view.ia(t7, n4)));
+                const r5 = s5 && s5.targetChanges.get(e5.targetId),
+                    o3 = e5.view.applyChanges(n4, t6.isPrimaryClient, r5);
+                return W_(t6, e5.targetId, o3.ua), o3.snapshot;
+            }(t5, e4, i4, s4);
+            const r4 = await u_(t5.localStore, e3, true),
+                o2 = new __PRIVATE_View(e3, r4.ss),
+                a2 = o2.ia(r4.documents),
+                l2 = TargetChange.createSynthesizedTargetChangeForCurrentChange(i3, s3 && "Offline" !== t5.onlineState, n3),
+                h2 = o2.applyChanges(a2, t5.isPrimaryClient, l2);
+            W_(t5, i3, h2.ua);
+            const c2 = new __PRIVATE_QueryView(e3, i3, o2);
+            return t5.Ta.set(e3, c2), t5.Ea.has(i3) ? t5.Ea.get(i3).push(e3) : t5.Ea.set(i3, [e3]), h2.snapshot;
+        }(i2, e2, s2, "current" === r3, t4.resumeToken), i2.isPrimaryClient && __(i2.remoteStore, t4);
+    }
+    return n2;
+}
+async function V_(t3, e2) {
+    const i2 = Yy(t3),
+        s2 = i2.Ta.get(e2),
+        n2 = i2.Ea.get(s2.targetId);
+    if (n2.length > 1)
+        return i2.Ea.set(s2.targetId, n2.filter((t4) => !Yv(t4, e2))), void i2.Ta.delete(e2);
+    i2.isPrimaryClient ? (i2.sharedClientState.removeLocalQueryTarget(s2.targetId), i2.sharedClientState.isActiveQueryTarget(s2.targetId) || await c_(i2.localStore, s2.targetId, false).then(() => {
+        i2.sharedClientState.clearQueryState(s2.targetId), w_(i2.remoteStore, s2.targetId), j_(i2, s2.targetId);
+    }).catch(nv)) : (j_(i2, s2.targetId), await c_(i2.localStore, s2.targetId, true));
+}
+async function z_(t3, e2) {
+    const i2 = Yy(t3);
+    try {
+        const t4 = await h_(i2.localStore, e2);
+        e2.targetChanges.forEach((t5, e3) => {
+            const s2 = i2.Ra.get(e3);
+            s2 && (Gy(t5.addedDocuments.size + t5.modifiedDocuments.size + t5.removedDocuments.size <= 1), t5.addedDocuments.size > 0 ? s2.Pa = true : t5.modifiedDocuments.size > 0 ? Gy(s2.Pa) : t5.removedDocuments.size > 0 && (Gy(s2.Pa), s2.Pa = false));
+        }), await G_(i2, t4, e2);
+    } catch (t4) {
+        await nv(t4);
+    }
+}
+
+function B_(t3, e2, i2) {
+    const s2 = Yy(t3);
+    if (s2.isPrimaryClient && 0 === i2 || !s2.isPrimaryClient && 1 === i2) {
+        const t4 = [];
+        s2.Ta.forEach((i3, s3) => {
+                const n2 = s3.view.O_(e2);
+                n2.snapshot && t4.push(n2.snapshot);
+            }),
+            function(t5, e3) {
+                const i3 = Yy(t5);
+                i3.onlineState = e3;
+                let s3 = false;
+                i3.queries.forEach((t6, i4) => {
+                    for (const t7 of i4.listeners)
+                        t7.O_(e3) && (s3 = true);
+                }), s3 && N_(i3);
+            }(s2.eventManager, e2), t4.length && s2.Ia.n_(t4), s2.onlineState = e2, s2.isPrimaryClient && s2.sharedClientState.setOnlineState(e2);
+    }
+}
+async function U_(t3, e2, i2) {
+    const s2 = Yy(t3);
+    s2.sharedClientState.updateQueryState(e2, "rejected", i2);
+    const n2 = s2.Ra.get(e2),
+        r2 = n2 && n2.key;
+    if (r2) {
+        let t4 = new SortedMap(DocumentKey.comparator);
+        t4 = t4.insert(r2, MutableDocument.newNoDocument(r2, SnapshotVersion.min()));
+        const i3 = ub().add(r2),
+            n3 = new RemoteEvent(SnapshotVersion.min(), /* @__PURE__ */ new Map(), new SortedMap(Jy), t4, i3);
+        await z_(s2, n3), s2.Aa = s2.Aa.remove(r2), s2.Ra.delete(e2), K_(s2);
+    } else
+        await c_(s2.localStore, e2, false).then(() => j_(s2, e2, i2)).catch(nv);
+}
+
+function j_(t3, e2, i2 = null) {
+    t3.sharedClientState.removeLocalQueryTarget(e2);
+    for (const s2 of t3.Ea.get(e2))
+        t3.Ta.delete(s2), i2 && t3.Ia.wa(s2, i2);
+    t3.Ea.delete(e2), t3.isPrimaryClient && t3.Va.Ar(e2).forEach((e3) => {
+        t3.Va.containsKey(e3) || H_(t3, e3);
+    });
+}
+
+function H_(t3, e2) {
+    t3.da.delete(e2.path.canonicalString());
+    const i2 = t3.Aa.get(e2);
+    null !== i2 && (w_(t3.remoteStore, i2), t3.Aa = t3.Aa.remove(e2), t3.Ra.delete(i2), K_(t3));
+}
+
+function W_(t3, e2, i2) {
+    for (const s2 of i2)
+        s2 instanceof __PRIVATE_AddedLimboDocument ? (t3.Va.addReference(s2.key, e2), q_(t3, s2)) : s2 instanceof __PRIVATE_RemovedLimboDocument ? (jy("SyncEngine", "Document no longer in limbo: " + s2.key), t3.Va.removeReference(s2.key, e2), t3.Va.containsKey(s2.key) || H_(t3, s2.key)) : Ky();
+}
+
+function q_(t3, e2) {
+    const i2 = e2.key,
+        s2 = i2.path.canonicalString();
+    t3.Aa.get(i2) || t3.da.has(s2) || (jy("SyncEngine", "New document in limbo: " + i2), t3.da.add(s2), K_(t3));
+}
+
+function K_(t3) {
+    for (; t3.da.size > 0 && t3.Aa.size < t3.maxConcurrentLimboResolutions;) {
+        const e2 = t3.da.values().next().value;
+        t3.da.delete(e2);
+        const i2 = new DocumentKey(ResourcePath.fromString(e2)),
+            s2 = t3.ga.next();
+        t3.Ra.set(s2, new LimboResolution(i2)), t3.Aa = t3.Aa.insert(i2, s2), __(t3.remoteStore, new TargetData(Kv(Hv(i2.path)), s2, "TargetPurposeLimboResolution", __PRIVATE_ListenSequence.ae));
+    }
+}
+async function G_(t3, e2, i2) {
+    const s2 = Yy(t3),
+        n2 = [],
+        r2 = [],
+        o2 = [];
+    s2.Ta.isEmpty() || (s2.Ta.forEach((t4, a2) => {
+        o2.push(s2.ya(a2, e2, i2).then((t5) => {
+            if ((t5 || i2) && s2.isPrimaryClient && s2.sharedClientState.updateQueryState(a2.targetId, (null == t5 ? void 0 : t5.fromCache) ? "not-current" : "current"), t5) {
+                n2.push(t5);
+                const e3 = __PRIVATE_LocalViewChanges.qi(a2.targetId, t5);
+                r2.push(e3);
+            }
+        }));
+    }), await Promise.all(o2), s2.Ia.n_(n2), await async function(t4, e3) {
+        const i3 = Yy(t4);
+        try {
+            await i3.persistence.runTransaction("notifyLocalViewChanges", "readwrite", (t5) => PersistencePromise.forEach(e3, (e4) => PersistencePromise.forEach(e4.Li, (s3) => i3.persistence.referenceDelegate.addReference(t5, e4.targetId, s3)).next(() => PersistencePromise.forEach(e4.ki, (s3) => i3.persistence.referenceDelegate.removeReference(t5, e4.targetId, s3)))));
+        } catch (t5) {
+            if (!rv(t5))
+                throw t5;
+            jy("LocalStore", "Failed to update sequence numbers: " + t5);
+        }
+        for (const t5 of e3) {
+            const e4 = t5.targetId;
+            if (!t5.fromCache) {
+                const t6 = i3.Ji.get(e4),
+                    s3 = t6.snapshotVersion,
+                    n3 = t6.withLastLimboFreeSnapshotVersion(s3);
+                i3.Ji = i3.Ji.insert(e4, n3);
+            }
+        }
+    }(s2.localStore, r2));
+}
+async function Y_(t3, e2) {
+    const i2 = Yy(t3);
+    if (!i2.currentUser.isEqual(e2)) {
+        jy("SyncEngine", "User change. New user:", e2.toKey());
+        const t4 = await a_(i2.localStore, e2);
+        i2.currentUser = e2,
+            function(t5, e3) {
+                t5.fa.forEach((t6) => {
+                    t6.forEach((t7) => {
+                        t7.reject(new FirestoreError(Qy.CANCELLED, e3));
+                    });
+                }), t5.fa.clear();
+            }(i2, "'waitForPendingWrites' promise is rejected due to a user change."), i2.sharedClientState.handleUserChange(e2, t4.removedBatchIds, t4.addedBatchIds), await G_(i2, t4.ts);
+    }
+}
+
+function Q_(t3, e2) {
+    const i2 = Yy(t3),
+        s2 = i2.Ra.get(e2);
+    if (s2 && s2.Pa)
+        return ub().add(s2.key);
+    {
+        let t4 = ub();
+        const s3 = i2.Ea.get(e2);
+        if (!s3)
+            return t4;
+        for (const e3 of s3) {
+            const s4 = i2.Ta.get(e3);
+            t4 = t4.unionWith(s4.view.ra);
+        }
+        return t4;
+    }
+}
+class MemoryOfflineComponentProvider {
+    constructor() {
+        this.synchronizeTabs = false;
+    }
+    async initialize(t3) {
+        this.serializer = y_(t3.databaseInfo.databaseId), this.sharedClientState = this.createSharedClientState(t3), this.persistence = this.createPersistence(t3), await this.persistence.start(), this.localStore = this.createLocalStore(t3), this.gcScheduler = this.createGarbageCollectionScheduler(t3, this.localStore), this.indexBackfillerScheduler = this.createIndexBackfillerScheduler(t3, this.localStore);
+    }
+    createGarbageCollectionScheduler(t3, e2) {
+        return null;
+    }
+    createIndexBackfillerScheduler(t3, e2) {
+        return null;
+    }
+    createLocalStore(t3) {
+        return function(t4, e2, i2, s2) {
+            return new __PRIVATE_LocalStoreImpl(t4, e2, i2, s2);
+        }(this.persistence, new __PRIVATE_QueryEngine(), t3.initialUser, this.serializer);
+    }
+    createPersistence(t3) {
+        return new __PRIVATE_MemoryPersistence(__PRIVATE_MemoryEagerDelegate.zr, this.serializer);
+    }
+    createSharedClientState(t3) {
+        return new __PRIVATE_MemorySharedClientState();
+    }
+    async terminate() {
+        this.gcScheduler && this.gcScheduler.stop(), await this.sharedClientState.shutdown(), await this.persistence.shutdown();
+    }
+}
+class OnlineComponentProvider {
+    async initialize(t3, e2) {
+        this.localStore || (this.localStore = t3.localStore, this.sharedClientState = t3.sharedClientState, this.datastore = this.createDatastore(e2), this.remoteStore = this.createRemoteStore(e2), this.eventManager = this.createEventManager(e2), this.syncEngine = this.createSyncEngine(e2, !t3.synchronizeTabs), this.sharedClientState.onlineStateHandler = (t4) => B_(this.syncEngine, t4, 1), this.remoteStore.remoteSyncer.handleCredentialChange = Y_.bind(null, this.syncEngine), await async function(t4, e3) {
+            const i2 = Yy(t4);
+            e3 ? (i2.p_.delete(2), await v_(i2)) : e3 || (i2.p_.add(2), await b_(i2), i2.S_.set("Unknown"));
+        }(this.remoteStore, this.syncEngine.isPrimaryClient));
+    }
+    createEventManager(t3) {
+        return new __PRIVATE_EventManagerImpl();
+    }
+    createDatastore(t3) {
+        const e2 = y_(t3.databaseInfo.databaseId),
+            i2 = function(t4) {
+                return new __PRIVATE_WebChannelConnection(t4);
+            }(t3.databaseInfo);
+        return function(t4, e3, i3, s2) {
+            return new __PRIVATE_DatastoreImpl(t4, e3, i3, s2);
+        }(t3.authCredentials, t3.appCheckCredentials, i2, e2);
+    }
+    createRemoteStore(t3) {
+        return function(t4, e2, i2, s2, n2) {
+            return new __PRIVATE_RemoteStoreImpl(t4, e2, i2, s2, n2);
+        }(this.localStore, this.datastore, t3.asyncQueue, (t4) => B_(this.syncEngine, t4, 0), __PRIVATE_BrowserConnectivityMonitor.v() ? new __PRIVATE_BrowserConnectivityMonitor() : new __PRIVATE_NoopConnectivityMonitor());
+    }
+    createSyncEngine(t3, e2) {
+        return function(t4, e3, i2, s2, n2, r2, o2) {
+            const a2 = new __PRIVATE_SyncEngineImpl(t4, e3, i2, s2, n2, r2);
+            return o2 && (a2.pa = true), a2;
+        }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, t3.initialUser, t3.maxConcurrentLimboResolutions, e2);
+    }
+    terminate() {
+        return async function(t3) {
+            const e2 = Yy(t3);
+            jy("RemoteStore", "RemoteStore shutting down."), e2.p_.add(5), await b_(e2), e2.w_.shutdown(), e2.S_.set("Unknown");
+        }(this.remoteStore);
+    }
+}
+class __PRIVATE_AsyncObserver {
+    constructor(t3) {
+        this.observer = t3, this.muted = false;
+    }
+    next(t3) {
+        this.observer.next && this.Da(this.observer.next, t3);
+    }
+    error(t3) {
+        this.observer.error ? this.Da(this.observer.error, t3) : Hy("Uncaught Error in snapshot listener:", t3.toString());
+    }
+    va() {
+        this.muted = true;
+    }
+    Da(t3, e2) {
+        this.muted || setTimeout(() => {
+            this.muted || t3(e2);
+        }, 0);
+    }
+}
+class FirestoreClient {
+    constructor(t3, e2, i2, s2) {
+        this.authCredentials = t3, this.appCheckCredentials = e2, this.asyncQueue = i2, this.databaseInfo = s2, this.user = User.UNAUTHENTICATED, this.clientId = __PRIVATE_AutoId.V(), this.authCredentialListener = () => Promise.resolve(), this.appCheckCredentialListener = () => Promise.resolve(), this.authCredentials.start(i2, async (t4) => {
+            jy("FirestoreClient", "Received user=", t4.uid), await this.authCredentialListener(t4), this.user = t4;
+        }), this.appCheckCredentials.start(i2, (t4) => (jy("FirestoreClient", "Received new app check token=", t4), this.appCheckCredentialListener(t4, this.user)));
+    }
+    async getConfiguration() {
+        return {
+            asyncQueue: this.asyncQueue,
+            databaseInfo: this.databaseInfo,
+            clientId: this.clientId,
+            authCredentials: this.authCredentials,
+            appCheckCredentials: this.appCheckCredentials,
+            initialUser: this.user,
+            maxConcurrentLimboResolutions: 100
+        };
+    }
+    setCredentialChangeListener(t3) {
+        this.authCredentialListener = t3;
+    }
+    setAppCheckTokenChangeListener(t3) {
+        this.appCheckCredentialListener = t3;
+    }
+    verifyNotTerminated() {
+        if (this.asyncQueue.isShuttingDown)
+            throw new FirestoreError(Qy.FAILED_PRECONDITION, "The client has already been terminated.");
+    }
+    terminate() {
+        this.asyncQueue.enterRestrictedMode();
+        const t3 = new __PRIVATE_Deferred();
+        return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
+            try {
+                this._onlineComponents && await this._onlineComponents.terminate(), this._offlineComponents && await this._offlineComponents.terminate(), this.authCredentials.shutdown(), this.appCheckCredentials.shutdown(), t3.resolve();
+            } catch (e2) {
+                const i2 = L_(e2, "Failed to shutdown persistence");
+                t3.reject(i2);
+            }
+        }), t3.promise;
+    }
+}
+async function X_(t3, e2) {
+    t3.asyncQueue.verifyOperationInProgress(), jy("FirestoreClient", "Initializing OfflineComponentProvider");
+    const i2 = await t3.getConfiguration();
+    await e2.initialize(i2);
+    let s2 = i2.initialUser;
+    t3.setCredentialChangeListener(async (t4) => {
+        s2.isEqual(t4) || (await a_(e2.localStore, t4), s2 = t4);
+    }), e2.persistence.setDatabaseDeletedListener(() => t3.terminate()), t3._offlineComponents = e2;
+}
+async function J_(t3, e2) {
+    t3.asyncQueue.verifyOperationInProgress();
+    const i2 = await async function(t4) {
+        if (!t4._offlineComponents)
+            if (t4._uninitializedComponentsProvider) {
+                jy("FirestoreClient", "Using user provided OfflineComponentProvider");
+                try {
+                    await X_(t4, t4._uninitializedComponentsProvider._offline);
+                } catch (e3) {
+                    const i3 = e3;
+                    if (! function(t5) {
+                            return "FirebaseError" === t5.name ? t5.code === Qy.FAILED_PRECONDITION || t5.code === Qy.UNIMPLEMENTED : !("undefined" != typeof DOMException && t5 instanceof DOMException) || 22 === t5.code || 20 === t5.code || 11 === t5.code;
+                        }(i3))
+                        throw i3;
+                    Wy("Error using user provided cache. Falling back to memory cache: " + i3), await X_(t4, new MemoryOfflineComponentProvider());
+                }
+            } else
+                jy("FirestoreClient", "Using default OfflineComponentProvider"), await X_(t4, new MemoryOfflineComponentProvider());
+        return t4._offlineComponents;
+    }(t3);
+    jy("FirestoreClient", "Initializing OnlineComponentProvider");
+    const s2 = await t3.getConfiguration();
+    await e2.initialize(i2, s2), t3.setCredentialChangeListener((t4) => A_(e2.remoteStore, t4)), t3.setAppCheckTokenChangeListener((t4, i3) => A_(e2.remoteStore, i3)), t3._onlineComponents = e2;
+}
+async function Z_(t3) {
+    const e2 = await async function(t4) {
+        return t4._onlineComponents || (t4._uninitializedComponentsProvider ? (jy("FirestoreClient", "Using user provided OnlineComponentProvider"), await J_(t4, t4._uninitializedComponentsProvider._online)) : (jy("FirestoreClient", "Using default OnlineComponentProvider"), await J_(t4, new OnlineComponentProvider()))), t4._onlineComponents;
+    }(t3), i2 = e2.eventManager;
+    return i2.onListen = $_.bind(null, e2.syncEngine), i2.onUnlisten = V_.bind(null, e2.syncEngine), i2;
+}
+
+function tw(t3, e2, i2 = {}) {
+    const s2 = new __PRIVATE_Deferred();
+    return t3.asyncQueue.enqueueAndForget(async () => function(t4, e3, i3, s3, n2) {
+        const r2 = new __PRIVATE_AsyncObserver({
+                next: (r3) => {
+                    e3.enqueueAndForget(() => async function(t5, e4) {
+                        const i4 = Yy(t5),
+                            s4 = e4.query;
+                        let n3 = false;
+                        const r4 = i4.queries.get(s4);
+                        if (r4) {
+                            const t6 = r4.listeners.indexOf(e4);
+                            t6 >= 0 && (r4.listeners.splice(t6, 1), n3 = 0 === r4.listeners.length);
+                        }
+                        if (n3)
+                            return i4.queries.delete(s4), i4.onUnlisten(s4);
+                    }(t4, o2));
+                    const a2 = r3.docs.has(i3);
+                    !a2 && r3.fromCache ? n2.reject(new FirestoreError(Qy.UNAVAILABLE, "Failed to get document because the client is offline.")) : a2 && r3.fromCache && s3 && "server" === s3.source ? n2.reject(new FirestoreError(Qy.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : n2.resolve(r3);
+                },
+                error: (t5) => n2.reject(t5)
+            }),
+            o2 = new __PRIVATE_QueryListener(Hv(i3.path), r2, {
+                includeMetadataChanges: true,
+                U_: true
+            });
+        return async function(t5, e4) {
+            const i4 = Yy(t5),
+                s4 = e4.query;
+            let n3 = false,
+                r3 = i4.queries.get(s4);
+            if (r3 || (n3 = true, r3 = new __PRIVATE_QueryListenersInfo()), n3)
+                try {
+                    r3.M_ = await i4.onListen(s4);
+                } catch (t6) {
+                    const i5 = L_(t6, `Initialization of query '${Xv(e4.query)}' failed`);
+                    return void e4.onError(i5);
+                }
+            i4.queries.set(s4, r3), r3.listeners.push(e4), e4.O_(i4.onlineState), r3.M_ && e4.N_(r3.M_) && N_(i4);
+        }(t4, o2);
+    }(await Z_(t3), t3.asyncQueue, e2, i2, s2)), s2.promise;
+}
+
+function ew(t3) {
+    const e2 = {};
+    return void 0 !== t3.timeoutSeconds && (e2.timeoutSeconds = t3.timeoutSeconds), e2;
+}
+const iw = /* @__PURE__ */ new Map();
+
+function sw(t3) {
+    if (!DocumentKey.isDocumentKey(t3))
+        throw new FirestoreError(Qy.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${t3} has ${t3.length}.`);
+}
+
+function nw(t3, e2) {
+    if ("_delegate" in t3 && (t3 = t3._delegate), !(t3 instanceof e2)) {
+        if (e2.name === t3.constructor.name)
+            throw new FirestoreError(Qy.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
+        {
+            const i2 = function(t4) {
+                if (void 0 === t4)
+                    return "undefined";
+                if (null === t4)
+                    return "null";
+                if ("string" == typeof t4)
+                    return t4.length > 20 && (t4 = `${t4.substring(0, 20)}...`), JSON.stringify(t4);
+                if ("number" == typeof t4 || "boolean" == typeof t4)
+                    return "" + t4;
+                if ("object" == typeof t4) {
+                    if (t4 instanceof Array)
+                        return "an array";
+                    {
+                        const e3 = function(t5) {
+                            return t5.constructor ? t5.constructor.name : null;
+                        }(t4);
+                        return e3 ? `a custom ${e3} object` : "an object";
+                    }
+                }
+                return "function" == typeof t4 ? "a function" : Ky();
+            }(t3);
+            throw new FirestoreError(Qy.INVALID_ARGUMENT, `Expected type '${e2.name}', but it was: ${i2}`);
+        }
+    }
+    return t3;
+}
+class FirestoreSettingsImpl {
+    constructor(t3) {
+        var e2, i2;
+        if (void 0 === t3.host) {
+            if (void 0 !== t3.ssl)
+                throw new FirestoreError(Qy.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
+            this.host = "firestore.googleapis.com", this.ssl = true;
+        } else
+            this.host = t3.host, this.ssl = null === (e2 = t3.ssl) || void 0 === e2 || e2;
+        if (this.credentials = t3.credentials, this.ignoreUndefinedProperties = !!t3.ignoreUndefinedProperties, this.localCache = t3.localCache, void 0 === t3.cacheSizeBytes)
+            this.cacheSizeBytes = 41943040;
+        else {
+            if (-1 !== t3.cacheSizeBytes && t3.cacheSizeBytes < 1048576)
+                throw new FirestoreError(Qy.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
+            this.cacheSizeBytes = t3.cacheSizeBytes;
+        }
+        (function(t4, e3, i3, s2) {
+            if (true === e3 && true === s2)
+                throw new FirestoreError(Qy.INVALID_ARGUMENT, `${t4} and ${i3} cannot be used together.`);
+        })("experimentalForceLongPolling", t3.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", t3.experimentalAutoDetectLongPolling), this.experimentalForceLongPolling = !!t3.experimentalForceLongPolling, this.experimentalForceLongPolling ? this.experimentalAutoDetectLongPolling = false : void 0 === t3.experimentalAutoDetectLongPolling ? this.experimentalAutoDetectLongPolling = true : this.experimentalAutoDetectLongPolling = !!t3.experimentalAutoDetectLongPolling, this.experimentalLongPollingOptions = ew(null !== (i2 = t3.experimentalLongPollingOptions) && void 0 !== i2 ? i2 : {}),
+            function(t4) {
+                if (void 0 !== t4.timeoutSeconds) {
+                    if (isNaN(t4.timeoutSeconds))
+                        throw new FirestoreError(Qy.INVALID_ARGUMENT, `invalid long polling timeout: ${t4.timeoutSeconds} (must not be NaN)`);
+                    if (t4.timeoutSeconds < 5)
+                        throw new FirestoreError(Qy.INVALID_ARGUMENT, `invalid long polling timeout: ${t4.timeoutSeconds} (minimum allowed value is 5)`);
+                    if (t4.timeoutSeconds > 30)
+                        throw new FirestoreError(Qy.INVALID_ARGUMENT, `invalid long polling timeout: ${t4.timeoutSeconds} (maximum allowed value is 30)`);
+                }
+            }(this.experimentalLongPollingOptions), this.useFetchStreams = !!t3.useFetchStreams;
+    }
+    isEqual(t3) {
+        return this.host === t3.host && this.ssl === t3.ssl && this.credentials === t3.credentials && this.cacheSizeBytes === t3.cacheSizeBytes && this.experimentalForceLongPolling === t3.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === t3.experimentalAutoDetectLongPolling && function(t4, e2) {
+            return t4.timeoutSeconds === e2.timeoutSeconds;
+        }(this.experimentalLongPollingOptions, t3.experimentalLongPollingOptions) && this.ignoreUndefinedProperties === t3.ignoreUndefinedProperties && this.useFetchStreams === t3.useFetchStreams;
+    }
+}
+class Firestore$1 {
+    constructor(t3, e2, i2, s2) {
+        this._authCredentials = t3, this._appCheckCredentials = e2, this._databaseId = i2, this._app = s2, this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new FirestoreSettingsImpl({}), this._settingsFrozen = false;
+    }
+    get app() {
+        if (!this._app)
+            throw new FirestoreError(Qy.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
+        return this._app;
+    }
+    get _initialized() {
+        return this._settingsFrozen;
+    }
+    get _terminated() {
+        return void 0 !== this._terminateTask;
+    }
+    _setSettings(t3) {
+        if (this._settingsFrozen)
+            throw new FirestoreError(Qy.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
+        this._settings = new FirestoreSettingsImpl(t3), void 0 !== t3.credentials && (this._authCredentials = function(t4) {
+            if (!t4)
+                return new __PRIVATE_EmptyAuthCredentialsProvider();
+            switch (t4.type) {
+                case "firstParty":
+                    return new __PRIVATE_FirstPartyAuthCredentialsProvider(t4.sessionIndex || "0", t4.iamToken || null, t4.authTokenFactory || null);
+                case "provider":
+                    return t4.client;
+                default:
+                    throw new FirestoreError(Qy.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type");
+            }
+        }(t3.credentials));
+    }
+    _getSettings() {
+        return this._settings;
+    }
+    _freezeSettings() {
+        return this._settingsFrozen = true, this._settings;
+    }
+    _delete() {
+        return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
+    }
+    toJSON() {
+        return {
+            app: this._app,
+            databaseId: this._databaseId,
+            settings: this._settings
+        };
+    }
+    _terminate() {
+        return function(t3) {
+            const e2 = iw.get(t3);
+            e2 && (jy("ComponentProvider", "Removing Datastore"), iw.delete(t3), e2.terminate());
+        }(this), Promise.resolve();
+    }
+}
+class Query {
+    constructor(t3, e2, i2) {
+        this.converter = e2, this._query = i2, this.type = "query", this.firestore = t3;
+    }
+    withConverter(t3) {
+        return new Query(this.firestore, t3, this._query);
+    }
+}
+class DocumentReference {
+    constructor(t3, e2, i2) {
+        this.converter = e2, this._key = i2, this.type = "document", this.firestore = t3;
+    }
+    get _path() {
+        return this._key.path;
+    }
+    get id() {
+        return this._key.path.lastSegment();
+    }
+    get path() {
+        return this._key.path.canonicalString();
+    }
+    get parent() {
+        return new CollectionReference(this.firestore, this.converter, this._key.path.popLast());
+    }
+    withConverter(t3) {
+        return new DocumentReference(this.firestore, t3, this._key);
+    }
+}
+class CollectionReference extends Query {
+    constructor(t3, e2, i2) {
+        super(t3, e2, Hv(i2)), this._path = i2, this.type = "collection";
+    }
+    get id() {
+        return this._query.path.lastSegment();
+    }
+    get path() {
+        return this._query.path.canonicalString();
+    }
+    get parent() {
+        const t3 = this._path.popLast();
+        return t3.isEmpty() ? null : new DocumentReference(this.firestore, null, new DocumentKey(t3));
+    }
+    withConverter(t3) {
+        return new CollectionReference(this.firestore, t3, this._path);
+    }
+}
+
+function rw(t3, e2, ...i2) {
+    if (t3 = Md(t3), 1 === arguments.length && (e2 = __PRIVATE_AutoId.V()), function(t4, e3, i3) {
+            if (!i3)
+                throw new FirestoreError(Qy.INVALID_ARGUMENT, `Function ${t4}() cannot be called with an empty ${e3}.`);
+        }("doc", "path", e2), t3 instanceof Firestore$1) {
+        const s2 = ResourcePath.fromString(e2, ...i2);
+        return sw(s2), new DocumentReference(t3, null, new DocumentKey(s2));
+    } {
+        if (!(t3 instanceof DocumentReference || t3 instanceof CollectionReference))
+            throw new FirestoreError(Qy.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
+        const s2 = t3._path.child(ResourcePath.fromString(e2, ...i2));
+        return sw(s2), new DocumentReference(t3.firestore, t3 instanceof CollectionReference ? t3.converter : null, new DocumentKey(s2));
+    }
+}
+class __PRIVATE_AsyncQueueImpl {
+    constructor() {
+        this.Ua = Promise.resolve(), this.Wa = [], this.Ga = false, this.za = [], this.ja = null, this.Ha = false, this.Ja = false, this.Ya = [], this.Qo = new __PRIVATE_ExponentialBackoff(this, "async_queue_retry"), this.Za = () => {
+            const t4 = g_();
+            t4 && jy("AsyncQueue", "Visibility state changed to " + t4.visibilityState), this.Qo.Oo();
+        };
+        const t3 = g_();
+        t3 && "function" == typeof t3.addEventListener && t3.addEventListener("visibilitychange", this.Za);
+    }
+    get isShuttingDown() {
+        return this.Ga;
+    }
+    enqueueAndForget(t3) {
+        this.enqueue(t3);
+    }
+    enqueueAndForgetEvenWhileRestricted(t3) {
+        this.Xa(), this.eu(t3);
+    }
+    enterRestrictedMode(t3) {
+        if (!this.Ga) {
+            this.Ga = true, this.Ja = t3 || false;
+            const e2 = g_();
+            e2 && "function" == typeof e2.removeEventListener && e2.removeEventListener("visibilitychange", this.Za);
+        }
+    }
+    enqueue(t3) {
+        if (this.Xa(), this.Ga)
+            return new Promise(() => {});
+        const e2 = new __PRIVATE_Deferred();
+        return this.eu(() => this.Ga && this.Ja ? Promise.resolve() : (t3().then(e2.resolve, e2.reject), e2.promise)).then(() => e2.promise);
+    }
+    enqueueRetryable(t3) {
+        this.enqueueAndForget(() => (this.Wa.push(t3), this.tu()));
+    }
+    async tu() {
+        if (0 !== this.Wa.length) {
+            try {
+                await this.Wa[0](), this.Wa.shift(), this.Qo.reset();
+            } catch (t3) {
+                if (!rv(t3))
+                    throw t3;
+                jy("AsyncQueue", "Operation failed with retryable error: " + t3);
+            }
+            this.Wa.length > 0 && this.Qo.Mo(() => this.tu());
+        }
+    }
+    eu(t3) {
+        const e2 = this.Ua.then(() => (this.Ha = true, t3().catch((t4) => {
+            this.ja = t4, this.Ha = false;
+            const e3 = function(t5) {
+                let e4 = t5.message || "";
+                return t5.stack && (e4 = t5.stack.includes(t5.message) ? t5.stack : t5.message + "\n" + t5.stack), e4;
+            }(t4);
+            throw Hy("INTERNAL UNHANDLED ERROR: ", e3), t4;
+        }).then((t4) => (this.Ha = false, t4))));
+        return this.Ua = e2, e2;
+    }
+    enqueueAfterDelay(t3, e2, i2) {
+        this.Xa(), this.Ya.indexOf(t3) > -1 && (e2 = 0);
+        const s2 = DelayedOperation.createAndSchedule(this, t3, e2, i2, (t4) => this.nu(t4));
+        return this.za.push(s2), s2;
+    }
+    Xa() {
+        this.ja && Ky();
+    }
+    verifyOperationInProgress() {}
+    async ru() {
+        let t3;
+        do {
+            t3 = this.Ua, await t3;
+        } while (t3 !== this.Ua);
+    }
+    iu(t3) {
+        for (const e2 of this.za)
+            if (e2.timerId === t3)
+                return true;
+        return false;
+    }
+    su(t3) {
+        return this.ru().then(() => {
+            this.za.sort((t4, e2) => t4.targetTimeMs - e2.targetTimeMs);
+            for (const e2 of this.za)
+                if (e2.skipDelay(), "all" !== t3 && e2.timerId === t3)
+                    break;
+            return this.ru();
+        });
+    }
+    ou(t3) {
+        this.Ya.push(t3);
+    }
+    nu(t3) {
+        const e2 = this.za.indexOf(t3);
+        this.za.splice(e2, 1);
+    }
+}
+class Firestore extends Firestore$1 {
+    constructor(t3, e2, i2, s2) {
+        super(t3, e2, i2, s2), this.type = "firestore", this._queue = new __PRIVATE_AsyncQueueImpl(), this._persistenceKey = (null == s2 ? void 0 : s2.name) || "[DEFAULT]";
+    }
+    _terminate() {
+        return this._firestoreClient || ow(this), this._firestoreClient.terminate();
+    }
+}
+
+function ow(t3) {
+    var e2, i2, s2;
+    const n2 = t3._freezeSettings(),
+        r2 = function(t4, e3, i3, s3) {
+            return new DatabaseInfo(t4, e3, i3, s3.host, s3.ssl, s3.experimentalForceLongPolling, s3.experimentalAutoDetectLongPolling, ew(s3.experimentalLongPollingOptions), s3.useFetchStreams);
+        }(t3._databaseId, (null === (e2 = t3._app) || void 0 === e2 ? void 0 : e2.options.appId) || "", t3._persistenceKey, n2);
+    t3._firestoreClient = new FirestoreClient(t3._authCredentials, t3._appCheckCredentials, t3._queue, r2), (null === (i2 = n2.localCache) || void 0 === i2 ? void 0 : i2._offlineComponentProvider) && (null === (s2 = n2.localCache) || void 0 === s2 ? void 0 : s2._onlineComponentProvider) && (t3._firestoreClient._uninitializedComponentsProvider = {
+        _offlineKind: n2.localCache.kind,
+        _offline: n2.localCache._offlineComponentProvider,
+        _online: n2.localCache._onlineComponentProvider
+    });
+}
+class Bytes {
+    constructor(t3) {
+        this._byteString = t3;
+    }
+    static fromBase64String(t3) {
+        try {
+            return new Bytes(ByteString.fromBase64String(t3));
+        } catch (t4) {
+            throw new FirestoreError(Qy.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + t4);
+        }
+    }
+    static fromUint8Array(t3) {
+        return new Bytes(ByteString.fromUint8Array(t3));
+    }
+    toBase64() {
+        return this._byteString.toBase64();
+    }
+    toUint8Array() {
+        return this._byteString.toUint8Array();
+    }
+    toString() {
+        return "Bytes(base64: " + this.toBase64() + ")";
+    }
+    isEqual(t3) {
+        return this._byteString.isEqual(t3._byteString);
+    }
+}
+class FieldPath {
+    constructor(...t3) {
+        for (let e2 = 0; e2 < t3.length; ++e2)
+            if (0 === t3[e2].length)
+                throw new FirestoreError(Qy.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
+        this._internalPath = new FieldPath$1(t3);
+    }
+    isEqual(t3) {
+        return this._internalPath.isEqual(t3._internalPath);
+    }
+}
+class GeoPoint {
+    constructor(t3, e2) {
+        if (!isFinite(t3) || t3 < -90 || t3 > 90)
+            throw new FirestoreError(Qy.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + t3);
+        if (!isFinite(e2) || e2 < -180 || e2 > 180)
+            throw new FirestoreError(Qy.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + e2);
+        this._lat = t3, this._long = e2;
+    }
+    get latitude() {
+        return this._lat;
+    }
+    get longitude() {
+        return this._long;
+    }
+    isEqual(t3) {
+        return this._lat === t3._lat && this._long === t3._long;
+    }
+    toJSON() {
+        return {
+            latitude: this._lat,
+            longitude: this._long
+        };
+    }
+    _compareTo(t3) {
+        return Jy(this._lat, t3._lat) || Jy(this._long, t3._long);
+    }
+}
+const aw = new RegExp("[~\\*/\\[\\]]");
+
+function lw(t3, e2, i2, s2, n2) {
+    const r2 = s2 && !s2.isEmpty(),
+        o2 = void 0 !== n2;
+    let a2 = `Function ${e2}() called with invalid data`;
+    i2 && (a2 += " (via `toFirestore()`)"), a2 += ". ";
+    let l2 = "";
+    return (r2 || o2) && (l2 += " (found", r2 && (l2 += ` in field ${s2}`), o2 && (l2 += ` in document ${n2}`), l2 += ")"), new FirestoreError(Qy.INVALID_ARGUMENT, a2 + t3 + l2);
+}
+class DocumentSnapshot$1 {
+    constructor(t3, e2, i2, s2, n2) {
+        this._firestore = t3, this._userDataWriter = e2, this._key = i2, this._document = s2, this._converter = n2;
+    }
+    get id() {
+        return this._key.path.lastSegment();
+    }
+    get ref() {
+        return new DocumentReference(this._firestore, this._converter, this._key);
+    }
+    exists() {
+        return null !== this._document;
+    }
+    data() {
+        if (this._document) {
+            if (this._converter) {
+                const t3 = new QueryDocumentSnapshot$1(this._firestore, this._userDataWriter, this._key, this._document, null);
+                return this._converter.fromFirestore(t3);
+            }
+            return this._userDataWriter.convertValue(this._document.data.value);
+        }
+    }
+    get(t3) {
+        if (this._document) {
+            const e2 = this._document.data.field(hw("DocumentSnapshot.get", t3));
+            if (null !== e2)
+                return this._userDataWriter.convertValue(e2);
+        }
+    }
+}
+class QueryDocumentSnapshot$1 extends DocumentSnapshot$1 {
+    data() {
+        return super.data();
+    }
+}
+
+function hw(t3, e2) {
+    return "string" == typeof e2 ? function(t4, e3, i2) {
+        if (e3.search(aw) >= 0)
+            throw lw(`Invalid field path (${e3}). Paths must not contain '~', '*', '/', '[', or ']'`, t4, false, void 0, i2);
+        try {
+            return new FieldPath(...e3.split("."))._internalPath;
+        } catch (s2) {
+            throw lw(`Invalid field path (${e3}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, t4, false, void 0, i2);
+        }
+    }(t3, e2) : e2 instanceof FieldPath ? e2._internalPath : e2._delegate._internalPath;
+}
+class AbstractUserDataWriter {
+    convertValue(t3, e2 = "none") {
+        switch (vv(t3)) {
+            case 0:
+                return null;
+            case 1:
+                return t3.booleanValue;
+            case 2:
+                return dv(t3.integerValue || t3.doubleValue);
+            case 3:
+                return this.convertTimestamp(t3.timestampValue);
+            case 4:
+                return this.convertServerTimestamp(t3, e2);
+            case 5:
+                return t3.stringValue;
+            case 6:
+                return this.convertBytes(fv(t3.bytesValue));
+            case 7:
+                return this.convertReference(t3.referenceValue);
+            case 8:
+                return this.convertGeoPoint(t3.geoPointValue);
+            case 9:
+                return this.convertArray(t3.arrayValue, e2);
+            case 10:
+                return this.convertObject(t3.mapValue, e2);
+            default:
+                throw Ky();
+        }
+    }
+    convertObject(t3, e2) {
+        return this.convertObjectMap(t3.fields, e2);
+    }
+    convertObjectMap(t3, e2 = "none") {
+        const i2 = {};
+        return hv(t3, (t4, s2) => {
+            i2[t4] = this.convertValue(s2, e2);
+        }), i2;
+    }
+    convertGeoPoint(t3) {
+        return new GeoPoint(dv(t3.latitude), dv(t3.longitude));
+    }
+    convertArray(t3, e2) {
+        return (t3.values || []).map((t4) => this.convertValue(t4, e2));
+    }
+    convertServerTimestamp(t3, e2) {
+        switch (e2) {
+            case "previous":
+                const i2 = mv(t3);
+                return null == i2 ? null : this.convertValue(i2, e2);
+            case "estimate":
+                return this.convertTimestamp(gv(t3));
+            default:
+                return null;
+        }
+    }
+    convertTimestamp(t3) {
+        const e2 = uv(t3);
+        return new Timestamp(e2.seconds, e2.nanos);
+    }
+    convertDocumentKey(t3, e2) {
+        const i2 = ResourcePath.fromString(t3);
+        Gy(r_(i2));
+        const s2 = new DatabaseId(i2.get(1), i2.get(3)),
+            n2 = new DocumentKey(i2.popFirst(5));
+        return s2.isEqual(e2) || Hy(`Document ${n2} contains a document reference within a different database (${s2.projectId}/${s2.database}) which is not supported. It will be treated as a reference in the current database (${e2.projectId}/${e2.database}) instead.`), n2;
+    }
+}
+class SnapshotMetadata {
+    constructor(t3, e2) {
+        this.hasPendingWrites = t3, this.fromCache = e2;
+    }
+    isEqual(t3) {
+        return this.hasPendingWrites === t3.hasPendingWrites && this.fromCache === t3.fromCache;
+    }
+}
+class DocumentSnapshot extends DocumentSnapshot$1 {
+    constructor(t3, e2, i2, s2, n2, r2) {
+        super(t3, e2, i2, s2, r2), this._firestore = t3, this._firestoreImpl = t3, this.metadata = n2;
+    }
+    exists() {
+        return super.exists();
+    }
+    data(t3 = {}) {
+        if (this._document) {
+            if (this._converter) {
+                const e2 = new QueryDocumentSnapshot(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null);
+                return this._converter.fromFirestore(e2, t3);
+            }
+            return this._userDataWriter.convertValue(this._document.data.value, t3.serverTimestamps);
+        }
+    }
+    get(t3, e2 = {}) {
+        if (this._document) {
+            const i2 = this._document.data.field(hw("DocumentSnapshot.get", t3));
+            if (null !== i2)
+                return this._userDataWriter.convertValue(i2, e2.serverTimestamps);
+        }
+    }
+}
+class QueryDocumentSnapshot extends DocumentSnapshot {
+    data(t3 = {}) {
+        return super.data(t3);
+    }
+}
+
+function cw(t3) {
+    t3 = nw(t3, DocumentReference);
+    const e2 = nw(t3.firestore, Firestore);
+    return tw(function(t4) {
+        return t4._firestoreClient || ow(t4), t4._firestoreClient.verifyNotTerminated(), t4._firestoreClient;
+    }(e2), t3._key).then((i2) => function(t4, e3, i3) {
+        const s2 = i3.docs.get(e3._key),
+            n2 = new __PRIVATE_ExpUserDataWriter(t4);
+        return new DocumentSnapshot(t4, n2, e3._key, s2, new SnapshotMetadata(i3.hasPendingWrites, i3.fromCache), e3.converter);
+    }(e2, t3, i2));
+}
+class __PRIVATE_ExpUserDataWriter extends AbstractUserDataWriter {
+    constructor(t3) {
+        super(), this.firestore = t3;
+    }
+    convertBytes(t3) {
+        return new Bytes(t3);
+    }
+    convertReference(t3) {
+        const e2 = this.convertDocumentKey(t3, this.firestore._databaseId);
+        return new DocumentReference(this.firestore, null, e2);
+    }
+}! function(t3, e2 = true) {
+    ! function(t4) {
+        zy = t4;
+    }(uf), lf(new Component("firestore", (t4, {
+        instanceIdentifier: i2,
+        options: s2
+    }) => {
+        const n2 = t4.getProvider("app").getImmediate(),
+            r2 = new Firestore(new __PRIVATE_FirebaseAuthCredentialsProvider(t4.getProvider("auth-internal")), new __PRIVATE_FirebaseAppCheckTokenProvider(t4.getProvider("app-check-internal")), function(t5, e3) {
+                if (!Object.prototype.hasOwnProperty.apply(t5.options, ["projectId"]))
+                    throw new FirestoreError(Qy.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
+                return new DatabaseId(t5.options.projectId, e3);
+            }(n2, i2), n2);
+        return s2 = Object.assign({
+            useFetchStreams: e2
+        }, s2), r2._setSettings(s2), r2;
+    }, "PUBLIC").setMultipleInstances(true)), pf(Vy, "4.0.0", t3), pf(Vy, "4.0.0", "esm2017");
+}();
+
+function uw(t3, e2) {
+    var i2 = {};
+    for (var s2 in t3)
+        Object.prototype.hasOwnProperty.call(t3, s2) && e2.indexOf(s2) < 0 && (i2[s2] = t3[s2]);
+    if (null != t3 && "function" == typeof Object.getOwnPropertySymbols) {
+        var n2 = 0;
+        for (s2 = Object.getOwnPropertySymbols(t3); n2 < s2.length; n2++)
+            e2.indexOf(s2[n2]) < 0 && Object.prototype.propertyIsEnumerable.call(t3, s2[n2]) && (i2[s2[n2]] = t3[s2[n2]]);
+    }
+    return i2;
+}
+
+function dw() {
+    return {
+        "dependent-sdk-initialized-before-auth": "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK."
+    };
+}
+pf("firebase", "10.0.0", "app"), "function" == typeof SuppressedError && SuppressedError;
+const fw = dw,
+    pw = new ErrorFactory("auth", "Firebase", {
+        "dependent-sdk-initialized-before-auth": "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK."
+    }),
+    mw = new Logger("@firebase/auth");
+
+function gw(t3, ...e2) {
+    mw.logLevel <= Rd.ERROR && mw.error(`Auth (${uf}): ${t3}`, ...e2);
+}
+
+function yw(t3, ...e2) {
+    throw bw(t3, ...e2);
+}
+
+function vw(t3, ...e2) {
+    return bw(t3, ...e2);
+}
+
+function bw(t3, ...e2) {
+    if ("string" != typeof t3) {
+        const i2 = e2[0],
+            s2 = [...e2.slice(1)];
+        return s2[0] && (s2[0].appName = t3.name), t3._errorFactory.create(i2, ...s2);
+    }
+    return pw.create(t3, ...e2);
+}
+
+function _w(t3, e2, ...i2) {
+    if (!t3)
+        throw bw(e2, ...i2);
+}
+
+function ww(t3) {
+    const e2 = "INTERNAL ASSERTION FAILED: " + t3;
+    throw gw(e2), new Error(e2);
+}
+
+function xw(t3, e2) {
+    t3 || ww(e2);
+}
+
+function kw() {
+    var t3;
+    return "undefined" != typeof self && (null === (t3 = self.location) || void 0 === t3 ? void 0 : t3.href) || "";
+}
+
+function Tw() {
+    var t3;
+    return "undefined" != typeof self && (null === (t3 = self.location) || void 0 === t3 ? void 0 : t3.protocol) || null;
+}
+
+function Sw() {
+    return "undefined" == typeof navigator || !navigator || !("onLine" in navigator) || "boolean" != typeof navigator.onLine || "http:" !== Tw() && "https:" !== Tw() && ! function() {
+        const t3 = "object" == typeof chrome ? chrome.runtime : "object" == typeof browser ? browser.runtime : void 0;
+        return "object" == typeof t3 && void 0 !== t3.id;
+    }() && !("connection" in navigator) || navigator.onLine;
+}
+class Delay {
+    constructor(t3, e2) {
+        this.shortDelay = t3, this.longDelay = e2, xw(e2 > t3, "Short delay should be less than long delay!"), this.isMobile = "undefined" != typeof window && !!(window.cordova || window.phonegap || window.PhoneGap) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(kd()) || "object" == typeof navigator && "ReactNative" === navigator.product;
+    }
+    get() {
+        return Sw() ? this.isMobile ? this.longDelay : this.shortDelay : Math.min(5e3, this.shortDelay);
+    }
+}
+
+function Ew(t3, e2) {
+    xw(t3.emulator, "Emulator should always be set here");
+    const {
+        url: i2
+    } = t3.emulator;
+    return e2 ? `${i2}${e2.startsWith("/") ? e2.slice(1) : e2}` : i2;
+}
+class FetchProvider {
+    static initialize(t3, e2, i2) {
+        this.fetchImpl = t3, e2 && (this.headersImpl = e2), i2 && (this.responseImpl = i2);
+    }
+    static fetch() {
+        return this.fetchImpl ? this.fetchImpl : "undefined" != typeof self && "fetch" in self ? self.fetch : void ww("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
+    }
+    static headers() {
+        return this.headersImpl ? this.headersImpl : "undefined" != typeof self && "Headers" in self ? self.Headers : void ww("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
+    }
+    static response() {
+        return this.responseImpl ? this.responseImpl : "undefined" != typeof self && "Response" in self ? self.Response : void ww("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
+    }
+}
+const Cw = {
+        CREDENTIAL_MISMATCH: "custom-token-mismatch",
+        MISSING_CUSTOM_TOKEN: "internal-error",
+        INVALID_IDENTIFIER: "invalid-email",
+        MISSING_CONTINUE_URI: "internal-error",
+        INVALID_PASSWORD: "wrong-password",
+        MISSING_PASSWORD: "missing-password",
+        EMAIL_EXISTS: "email-already-in-use",
+        PASSWORD_LOGIN_DISABLED: "operation-not-allowed",
+        INVALID_IDP_RESPONSE: "invalid-credential",
+        INVALID_PENDING_TOKEN: "invalid-credential",
+        FEDERATED_USER_ID_ALREADY_LINKED: "credential-already-in-use",
+        MISSING_REQ_TYPE: "internal-error",
+        EMAIL_NOT_FOUND: "user-not-found",
+        RESET_PASSWORD_EXCEED_LIMIT: "too-many-requests",
+        EXPIRED_OOB_CODE: "expired-action-code",
+        INVALID_OOB_CODE: "invalid-action-code",
+        MISSING_OOB_CODE: "internal-error",
+        CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "requires-recent-login",
+        INVALID_ID_TOKEN: "invalid-user-token",
+        TOKEN_EXPIRED: "user-token-expired",
+        USER_NOT_FOUND: "user-token-expired",
+        TOO_MANY_ATTEMPTS_TRY_LATER: "too-many-requests",
+        INVALID_CODE: "invalid-verification-code",
+        INVALID_SESSION_INFO: "invalid-verification-id",
+        INVALID_TEMPORARY_PROOF: "invalid-credential",
+        MISSING_SESSION_INFO: "missing-verification-id",
+        SESSION_EXPIRED: "code-expired",
+        MISSING_ANDROID_PACKAGE_NAME: "missing-android-pkg-name",
+        UNAUTHORIZED_DOMAIN: "unauthorized-continue-uri",
+        INVALID_OAUTH_CLIENT_ID: "invalid-oauth-client-id",
+        ADMIN_ONLY_OPERATION: "admin-restricted-operation",
+        INVALID_MFA_PENDING_CREDENTIAL: "invalid-multi-factor-session",
+        MFA_ENROLLMENT_NOT_FOUND: "multi-factor-info-not-found",
+        MISSING_MFA_ENROLLMENT_ID: "missing-multi-factor-info",
+        MISSING_MFA_PENDING_CREDENTIAL: "missing-multi-factor-session",
+        SECOND_FACTOR_EXISTS: "second-factor-already-in-use",
+        SECOND_FACTOR_LIMIT_EXCEEDED: "maximum-second-factor-count-exceeded",
+        BLOCKING_FUNCTION_ERROR_RESPONSE: "internal-error",
+        RECAPTCHA_NOT_ENABLED: "recaptcha-not-enabled",
+        MISSING_RECAPTCHA_TOKEN: "missing-recaptcha-token",
+        INVALID_RECAPTCHA_TOKEN: "invalid-recaptcha-token",
+        INVALID_RECAPTCHA_ACTION: "invalid-recaptcha-action",
+        MISSING_CLIENT_TYPE: "missing-client-type",
+        MISSING_RECAPTCHA_VERSION: "missing-recaptcha-version",
+        INVALID_RECAPTCHA_VERSION: "invalid-recaptcha-version",
+        INVALID_REQ_TYPE: "invalid-req-type"
+    },
+    Iw = new Delay(3e4, 6e4);
+
+function Mw(t3, e2) {
+    return t3.tenantId && !e2.tenantId ? Object.assign(Object.assign({}, e2), {
+        tenantId: t3.tenantId
+    }) : e2;
+}
+async function Pw(t3, e2, i2, s2, n2 = {}) {
+    return Rw(t3, n2, async () => {
+        let n3 = {},
+            r2 = {};
+        s2 && ("GET" === e2 ? r2 = s2 : n3 = {
+            body: JSON.stringify(s2)
+        });
+        const o2 = Cd(Object.assign({
+                key: t3.config.apiKey
+            }, r2)).slice(1),
+            a2 = await t3._getAdditionalHeaders();
+        return a2["Content-Type"] = "application/json", t3.languageCode && (a2["X-Firebase-Locale"] = t3.languageCode), FetchProvider.fetch()(Aw(t3, t3.config.apiHost, i2, o2), Object.assign({
+            method: e2,
+            headers: a2,
+            referrerPolicy: "no-referrer"
+        }, n3));
+    });
+}
+async function Rw(t3, e2, i2) {
+    t3._canInitEmulator = false;
+    const s2 = Object.assign(Object.assign({}, Cw), e2);
+    try {
+        const e3 = new NetworkTimeout(t3),
+            n2 = await Promise.race([i2(), e3.promise]);
+        e3.clearNetworkTimeout();
+        const r2 = await n2.json();
+        if ("needConfirmation" in r2)
+            throw Dw(t3, "account-exists-with-different-credential", r2);
+        if (n2.ok && !("errorMessage" in r2))
+            return r2;
+        {
+            const e4 = n2.ok ? r2.errorMessage : r2.error.message,
+                [i3, o2] = e4.split(" : ");
+            if ("FEDERATED_USER_ID_ALREADY_LINKED" === i3)
+                throw Dw(t3, "credential-already-in-use", r2);
+            if ("EMAIL_EXISTS" === i3)
+                throw Dw(t3, "email-already-in-use", r2);
+            if ("USER_DISABLED" === i3)
+                throw Dw(t3, "user-disabled", r2);
+            const a2 = s2[i3] || i3.toLowerCase().replace(/[_\s]+/g, "-");
+            if (o2)
+                throw function(t4, e5, i4) {
+                    const s3 = Object.assign(Object.assign({}, fw()), {
+                        [e5]: i4
+                    });
+                    return new ErrorFactory("auth", "Firebase", s3).create(e5, {
+                        appName: t4.name
+                    });
+                }(t3, a2, o2);
+            yw(t3, a2);
+        }
+    } catch (e3) {
+        if (e3 instanceof FirebaseError)
+            throw e3;
+        yw(t3, "network-request-failed", {
+            message: String(e3)
+        });
+    }
+}
+
+function Aw(t3, e2, i2, s2) {
+    const n2 = `${e2}${i2}?${s2}`;
+    return t3.config.emulator ? Ew(t3.config, n2) : `${t3.config.apiScheme}://${n2}`;
+}
+class NetworkTimeout {
+    constructor(t3) {
+        this.auth = t3, this.timer = null, this.promise = new Promise((t4, e2) => {
+            this.timer = setTimeout(() => e2(vw(this.auth, "network-request-failed")), Iw.get());
+        });
+    }
+    clearNetworkTimeout() {
+        clearTimeout(this.timer);
+    }
+}
+
+function Dw(t3, e2, i2) {
+    const s2 = {
+        appName: t3.name
+    };
+    i2.email && (s2.email = i2.email), i2.phoneNumber && (s2.phoneNumber = i2.phoneNumber);
+    const n2 = vw(t3, e2, s2);
+    return n2.customData._tokenResponse = i2, n2;
+}
+
+function Lw(t3) {
+    if (t3)
+        try {
+            const e2 = new Date(Number(t3));
+            if (!isNaN(e2.getTime()))
+                return e2.toUTCString();
+        } catch (t4) {}
+}
+
+function Ow(t3) {
+    return 1e3 * Number(t3);
+}
+
+function Fw(t3) {
+    const [e2, i2, s2] = t3.split(".");
+    if (void 0 === e2 || void 0 === i2 || void 0 === s2)
+        return gw("JWT malformed, contained fewer than 3 sections"), null;
+    try {
+        const t4 = md(i2);
+        return t4 ? JSON.parse(t4) : (gw("Failed to decode base64 JWT payload"), null);
+    } catch (t4) {
+        return gw("Caught error parsing JWT payload as JSON", null == t4 ? void 0 : t4.toString()), null;
+    }
+}
+async function Nw(t3, e2, i2 = false) {
+    if (i2)
+        return e2;
+    try {
+        return await e2;
+    } catch (e3) {
+        throw e3 instanceof FirebaseError && function({
+            code: t4
+        }) {
+            return "auth/user-disabled" === t4 || "auth/user-token-expired" === t4;
+        }(e3) && t3.auth.currentUser === t3 && await t3.auth.signOut(), e3;
+    }
+}
+class ProactiveRefresh {
+    constructor(t3) {
+        this.user = t3, this.isRunning = false, this.timerId = null, this.errorBackoff = 3e4;
+    }
+    _start() {
+        this.isRunning || (this.isRunning = true, this.schedule());
+    }
+    _stop() {
+        this.isRunning && (this.isRunning = false, null !== this.timerId && clearTimeout(this.timerId));
+    }
+    getInterval(t3) {
+        var e2;
+        if (t3) {
+            const t4 = this.errorBackoff;
+            return this.errorBackoff = Math.min(2 * this.errorBackoff, 96e4), t4;
+        } {
+            this.errorBackoff = 3e4;
+            const t4 = (null !== (e2 = this.user.stsTokenManager.expirationTime) && void 0 !== e2 ? e2 : 0) - Date.now() - 3e5;
+            return Math.max(0, t4);
+        }
+    }
+    schedule(t3 = false) {
+        if (!this.isRunning)
+            return;
+        const e2 = this.getInterval(t3);
+        this.timerId = setTimeout(async () => {
+            await this.iteration();
+        }, e2);
+    }
+    async iteration() {
+        try {
+            await this.user.getIdToken(true);
+        } catch (t3) {
+            return void("auth/network-request-failed" === (null == t3 ? void 0 : t3.code) && this.schedule(true));
+        }
+        this.schedule();
+    }
+}
+class UserMetadata {
+    constructor(t3, e2) {
+        this.createdAt = t3, this.lastLoginAt = e2, this._initializeTime();
+    }
+    _initializeTime() {
+        this.lastSignInTime = Lw(this.lastLoginAt), this.creationTime = Lw(this.createdAt);
+    }
+    _copy(t3) {
+        this.createdAt = t3.createdAt, this.lastLoginAt = t3.lastLoginAt, this._initializeTime();
+    }
+    toJSON() {
+        return {
+            createdAt: this.createdAt,
+            lastLoginAt: this.lastLoginAt
+        };
+    }
+}
+async function $w(t3) {
+    var e2;
+    const i2 = t3.auth,
+        s2 = await t3.getIdToken(),
+        n2 = await Nw(t3, async function(t4, e3) {
+            return Pw(t4, "POST", "/v1/accounts:lookup", e3);
+        }(i2, {
+            idToken: s2
+        }));
+    _w(null == n2 ? void 0 : n2.users.length, i2, "internal-error");
+    const r2 = n2.users[0];
+    t3._notifyReloadListener(r2);
+    const o2 = (null === (e2 = r2.providerUserInfo) || void 0 === e2 ? void 0 : e2.length) ? r2.providerUserInfo.map((t4) => {
+        var {
+            providerId: e3
+        } = t4, i3 = uw(t4, ["providerId"]);
+        return {
+            providerId: e3,
+            uid: i3.rawId || "",
+            displayName: i3.displayName || null,
+            email: i3.email || null,
+            phoneNumber: i3.phoneNumber || null,
+            photoURL: i3.photoUrl || null
+        };
+    }) : [];
+    const a2 = function(t4, e3) {
+            const i3 = t4.filter((t5) => !e3.some((e4) => e4.providerId === t5.providerId));
+            return [...i3, ...e3];
+        }(t3.providerData, o2),
+        l2 = t3.isAnonymous,
+        h2 = !(t3.email && r2.passwordHash || (null == a2 ? void 0 : a2.length)),
+        c2 = !!l2 && h2,
+        u2 = {
+            uid: r2.localId,
+            displayName: r2.displayName || null,
+            photoURL: r2.photoUrl || null,
+            email: r2.email || null,
+            emailVerified: r2.emailVerified || false,
+            phoneNumber: r2.phoneNumber || null,
+            tenantId: r2.tenantId || null,
+            providerData: a2,
+            metadata: new UserMetadata(r2.createdAt, r2.lastLoginAt),
+            isAnonymous: c2
+        };
+    Object.assign(t3, u2);
+}
+class StsTokenManager {
+    constructor() {
+        this.refreshToken = null, this.accessToken = null, this.expirationTime = null;
+    }
+    get isExpired() {
+        return !this.expirationTime || Date.now() > this.expirationTime - 3e4;
+    }
+    updateFromServerResponse(t3) {
+        _w(t3.idToken, "internal-error"), _w(void 0 !== t3.idToken, "internal-error"), _w(void 0 !== t3.refreshToken, "internal-error");
+        const e2 = "expiresIn" in t3 && void 0 !== t3.expiresIn ? Number(t3.expiresIn) : function(t4) {
+            const e3 = Fw(t4);
+            return _w(e3, "internal-error"), _w(void 0 !== e3.exp, "internal-error"), _w(void 0 !== e3.iat, "internal-error"), Number(e3.exp) - Number(e3.iat);
+        }(t3.idToken);
+        this.updateTokensAndExpiration(t3.idToken, t3.refreshToken, e2);
+    }
+    async getToken(t3, e2 = false) {
+        return _w(!this.accessToken || this.refreshToken, t3, "user-token-expired"), e2 || !this.accessToken || this.isExpired ? this.refreshToken ? (await this.refresh(t3, this.refreshToken), this.accessToken) : null : this.accessToken;
+    }
+    clearRefreshToken() {
+        this.refreshToken = null;
+    }
+    async refresh(t3, e2) {
+        const {
+            accessToken: i2,
+            refreshToken: s2,
+            expiresIn: n2
+        } = await async function(t4, e3) {
+            const i3 = await Rw(t4, {}, async () => {
+                const i4 = Cd({
+                        grant_type: "refresh_token",
+                        refresh_token: e3
+                    }).slice(1),
+                    {
+                        tokenApiHost: s3,
+                        apiKey: n3
+                    } = t4.config,
+                    r2 = Aw(t4, s3, "/v1/token", `key=${n3}`),
+                    o2 = await t4._getAdditionalHeaders();
+                return o2["Content-Type"] = "application/x-www-form-urlencoded", FetchProvider.fetch()(r2, {
+                    method: "POST",
+                    headers: o2,
+                    body: i4
+                });
+            });
+            return {
+                accessToken: i3.access_token,
+                expiresIn: i3.expires_in,
+                refreshToken: i3.refresh_token
+            };
+        }(t3, e2);
+        this.updateTokensAndExpiration(i2, s2, Number(n2));
+    }
+    updateTokensAndExpiration(t3, e2, i2) {
+        this.refreshToken = e2 || null, this.accessToken = t3 || null, this.expirationTime = Date.now() + 1e3 * i2;
+    }
+    static fromJSON(t3, e2) {
+        const {
+            refreshToken: i2,
+            accessToken: s2,
+            expirationTime: n2
+        } = e2, r2 = new StsTokenManager();
+        return i2 && (_w("string" == typeof i2, "internal-error", {
+            appName: t3
+        }), r2.refreshToken = i2), s2 && (_w("string" == typeof s2, "internal-error", {
+            appName: t3
+        }), r2.accessToken = s2), n2 && (_w("number" == typeof n2, "internal-error", {
+            appName: t3
+        }), r2.expirationTime = n2), r2;
+    }
+    toJSON() {
+        return {
+            refreshToken: this.refreshToken,
+            accessToken: this.accessToken,
+            expirationTime: this.expirationTime
+        };
+    }
+    _assign(t3) {
+        this.accessToken = t3.accessToken, this.refreshToken = t3.refreshToken, this.expirationTime = t3.expirationTime;
+    }
+    _clone() {
+        return Object.assign(new StsTokenManager(), this.toJSON());
+    }
+    _performRefresh() {
+        return ww("not implemented");
+    }
+}
+
+function Vw(t3, e2) {
+    _w("string" == typeof t3 || void 0 === t3, "internal-error", {
+        appName: e2
+    });
+}
+class UserImpl {
+    constructor(t3) {
+        var {
+            uid: e2,
+            auth: i2,
+            stsTokenManager: s2
+        } = t3, n2 = uw(t3, ["uid", "auth", "stsTokenManager"]);
+        this.providerId = "firebase", this.proactiveRefresh = new ProactiveRefresh(this), this.reloadUserInfo = null, this.reloadListener = null, this.uid = e2, this.auth = i2, this.stsTokenManager = s2, this.accessToken = s2.accessToken, this.displayName = n2.displayName || null, this.email = n2.email || null, this.emailVerified = n2.emailVerified || false, this.phoneNumber = n2.phoneNumber || null, this.photoURL = n2.photoURL || null, this.isAnonymous = n2.isAnonymous || false, this.tenantId = n2.tenantId || null, this.providerData = n2.providerData ? [...n2.providerData] : [], this.metadata = new UserMetadata(n2.createdAt || void 0, n2.lastLoginAt || void 0);
+    }
+    async getIdToken(t3) {
+        const e2 = await Nw(this, this.stsTokenManager.getToken(this.auth, t3));
+        return _w(e2, this.auth, "internal-error"), this.accessToken !== e2 && (this.accessToken = e2, await this.auth._persistUserIfCurrent(this), this.auth._notifyListenersIfCurrent(this)), e2;
+    }
+    getIdTokenResult(t3) {
+        return async function(t4, e2 = false) {
+            const i2 = Md(t4),
+                s2 = await i2.getIdToken(e2),
+                n2 = Fw(s2);
+            _w(n2 && n2.exp && n2.auth_time && n2.iat, i2.auth, "internal-error");
+            const r2 = "object" == typeof n2.firebase ? n2.firebase : void 0,
+                o2 = null == r2 ? void 0 : r2.sign_in_provider;
+            return {
+                claims: n2,
+                token: s2,
+                authTime: Lw(Ow(n2.auth_time)),
+                issuedAtTime: Lw(Ow(n2.iat)),
+                expirationTime: Lw(Ow(n2.exp)),
+                signInProvider: o2 || null,
+                signInSecondFactor: (null == r2 ? void 0 : r2.sign_in_second_factor) || null
+            };
+        }(this, t3);
+    }
+    reload() {
+        return async function(t3) {
+            const e2 = Md(t3);
+            await $w(e2), await e2.auth._persistUserIfCurrent(e2), e2.auth._notifyListenersIfCurrent(e2);
+        }(this);
+    }
+    _assign(t3) {
+        this !== t3 && (_w(this.uid === t3.uid, this.auth, "internal-error"), this.displayName = t3.displayName, this.photoURL = t3.photoURL, this.email = t3.email, this.emailVerified = t3.emailVerified, this.phoneNumber = t3.phoneNumber, this.isAnonymous = t3.isAnonymous, this.tenantId = t3.tenantId, this.providerData = t3.providerData.map((t4) => Object.assign({}, t4)), this.metadata._copy(t3.metadata), this.stsTokenManager._assign(t3.stsTokenManager));
+    }
+    _clone(t3) {
+        const e2 = new UserImpl(Object.assign(Object.assign({}, this), {
+            auth: t3,
+            stsTokenManager: this.stsTokenManager._clone()
+        }));
+        return e2.metadata._copy(this.metadata), e2;
+    }
+    _onReload(t3) {
+        _w(!this.reloadListener, this.auth, "internal-error"), this.reloadListener = t3, this.reloadUserInfo && (this._notifyReloadListener(this.reloadUserInfo), this.reloadUserInfo = null);
+    }
+    _notifyReloadListener(t3) {
+        this.reloadListener ? this.reloadListener(t3) : this.reloadUserInfo = t3;
+    }
+    _startProactiveRefresh() {
+        this.proactiveRefresh._start();
+    }
+    _stopProactiveRefresh() {
+        this.proactiveRefresh._stop();
+    }
+    async _updateTokensIfNecessary(t3, e2 = false) {
+        let i2 = false;
+        t3.idToken && t3.idToken !== this.stsTokenManager.accessToken && (this.stsTokenManager.updateFromServerResponse(t3), i2 = true), e2 && await $w(this), await this.auth._persistUserIfCurrent(this), i2 && this.auth._notifyListenersIfCurrent(this);
+    }
+    async delete() {
+        const t3 = await this.getIdToken();
+        return await Nw(this, async function(t4, e2) {
+            return Pw(t4, "POST", "/v1/accounts:delete", e2);
+        }(this.auth, {
+            idToken: t3
+        })), this.stsTokenManager.clearRefreshToken(), this.auth.signOut();
+    }
+    toJSON() {
+        return Object.assign(Object.assign({
+            uid: this.uid,
+            email: this.email || void 0,
+            emailVerified: this.emailVerified,
+            displayName: this.displayName || void 0,
+            isAnonymous: this.isAnonymous,
+            photoURL: this.photoURL || void 0,
+            phoneNumber: this.phoneNumber || void 0,
+            tenantId: this.tenantId || void 0,
+            providerData: this.providerData.map((t3) => Object.assign({}, t3)),
+            stsTokenManager: this.stsTokenManager.toJSON(),
+            _redirectEventId: this._redirectEventId
+        }, this.metadata.toJSON()), {
+            apiKey: this.auth.config.apiKey,
+            appName: this.auth.name
+        });
+    }
+    get refreshToken() {
+        return this.stsTokenManager.refreshToken || "";
+    }
+    static _fromJSON(t3, e2) {
+        var i2, s2, n2, r2, o2, a2, l2, h2;
+        const c2 = null !== (i2 = e2.displayName) && void 0 !== i2 ? i2 : void 0,
+            u2 = null !== (s2 = e2.email) && void 0 !== s2 ? s2 : void 0,
+            d2 = null !== (n2 = e2.phoneNumber) && void 0 !== n2 ? n2 : void 0,
+            f2 = null !== (r2 = e2.photoURL) && void 0 !== r2 ? r2 : void 0,
+            p2 = null !== (o2 = e2.tenantId) && void 0 !== o2 ? o2 : void 0,
+            m2 = null !== (a2 = e2._redirectEventId) && void 0 !== a2 ? a2 : void 0,
+            g2 = null !== (l2 = e2.createdAt) && void 0 !== l2 ? l2 : void 0,
+            y2 = null !== (h2 = e2.lastLoginAt) && void 0 !== h2 ? h2 : void 0,
+            {
+                uid: v2,
+                emailVerified: b2,
+                isAnonymous: _2,
+                providerData: w2,
+                stsTokenManager: x2
+            } = e2;
+        _w(v2 && x2, t3, "internal-error");
+        const k2 = StsTokenManager.fromJSON(this.name, x2);
+        _w("string" == typeof v2, t3, "internal-error"), Vw(c2, t3.name), Vw(u2, t3.name), _w("boolean" == typeof b2, t3, "internal-error"), _w("boolean" == typeof _2, t3, "internal-error"), Vw(d2, t3.name), Vw(f2, t3.name), Vw(p2, t3.name), Vw(m2, t3.name), Vw(g2, t3.name), Vw(y2, t3.name);
+        const T2 = new UserImpl({
+            uid: v2,
+            auth: t3,
+            email: u2,
+            emailVerified: b2,
+            displayName: c2,
+            isAnonymous: _2,
+            photoURL: f2,
+            phoneNumber: d2,
+            tenantId: p2,
+            stsTokenManager: k2,
+            createdAt: g2,
+            lastLoginAt: y2
+        });
+        return w2 && Array.isArray(w2) && (T2.providerData = w2.map((t4) => Object.assign({}, t4))), m2 && (T2._redirectEventId = m2), T2;
+    }
+    static async _fromIdTokenResponse(t3, e2, i2 = false) {
+        const s2 = new StsTokenManager();
+        s2.updateFromServerResponse(e2);
+        const n2 = new UserImpl({
+            uid: e2.localId,
+            auth: t3,
+            stsTokenManager: s2,
+            isAnonymous: i2
+        });
+        return await $w(n2), n2;
+    }
+}
+const zw = /* @__PURE__ */ new Map();
+
+function Bw(t3) {
+    xw(t3 instanceof Function, "Expected a class definition");
+    let e2 = zw.get(t3);
+    return e2 ? (xw(e2 instanceof t3, "Instance stored in cache mismatched with class"), e2) : (e2 = new t3(), zw.set(t3, e2), e2);
+}
+class InMemoryPersistence {
+    constructor() {
+        this.type = "NONE", this.storage = {};
+    }
+    async _isAvailable() {
+        return true;
+    }
+    async _set(t3, e2) {
+        this.storage[t3] = e2;
+    }
+    async _get(t3) {
+        const e2 = this.storage[t3];
+        return void 0 === e2 ? null : e2;
+    }
+    async _remove(t3) {
+        delete this.storage[t3];
+    }
+    _addListener(t3, e2) {}
+    _removeListener(t3, e2) {}
+}
+InMemoryPersistence.type = "NONE";
+const Uw = InMemoryPersistence;
+
+function jw(t3, e2, i2) {
+    return `firebase:${t3}:${e2}:${i2}`;
+}
+class PersistenceUserManager {
+    constructor(t3, e2, i2) {
+        this.persistence = t3, this.auth = e2, this.userKey = i2;
+        const {
+            config: s2,
+            name: n2
+        } = this.auth;
+        this.fullUserKey = jw(this.userKey, s2.apiKey, n2), this.fullPersistenceKey = jw("persistence", s2.apiKey, n2), this.boundEventHandler = e2._onStorageEvent.bind(e2), this.persistence._addListener(this.fullUserKey, this.boundEventHandler);
+    }
+    setCurrentUser(t3) {
+        return this.persistence._set(this.fullUserKey, t3.toJSON());
+    }
+    async getCurrentUser() {
+        const t3 = await this.persistence._get(this.fullUserKey);
+        return t3 ? UserImpl._fromJSON(this.auth, t3) : null;
+    }
+    removeCurrentUser() {
+        return this.persistence._remove(this.fullUserKey);
+    }
+    savePersistenceForRedirect() {
+        return this.persistence._set(this.fullPersistenceKey, this.persistence.type);
+    }
+    async setPersistence(t3) {
+        if (this.persistence === t3)
+            return;
+        const e2 = await this.getCurrentUser();
+        return await this.removeCurrentUser(), this.persistence = t3, e2 ? this.setCurrentUser(e2) : void 0;
+    }
+    delete() {
+        this.persistence._removeListener(this.fullUserKey, this.boundEventHandler);
+    }
+    static async create(t3, e2, i2 = "authUser") {
+        if (!e2.length)
+            return new PersistenceUserManager(Bw(Uw), t3, i2);
+        const s2 = (await Promise.all(e2.map(async (t4) => {
+            if (await t4._isAvailable())
+                return t4;
+        }))).filter((t4) => t4);
+        let n2 = s2[0] || Bw(Uw);
+        const r2 = jw(i2, t3.config.apiKey, t3.name);
+        let o2 = null;
+        for (const i3 of e2)
+            try {
+                const e3 = await i3._get(r2);
+                if (e3) {
+                    const s3 = UserImpl._fromJSON(t3, e3);
+                    i3 !== n2 && (o2 = s3), n2 = i3;
+                    break;
+                }
+            } catch (t4) {}
+        const a2 = s2.filter((t4) => t4._shouldAllowMigration);
+        return n2._shouldAllowMigration && a2.length ? (n2 = a2[0], o2 && await n2._set(r2, o2.toJSON()), await Promise.all(e2.map(async (t4) => {
+            if (t4 !== n2)
+                try {
+                    await t4._remove(r2);
+                } catch (t5) {}
+        })), new PersistenceUserManager(n2, t3, i2)) : new PersistenceUserManager(n2, t3, i2);
+    }
+}
+
+function Hw(t3) {
+    const e2 = t3.toLowerCase();
+    if (e2.includes("opera/") || e2.includes("opr/") || e2.includes("opios/"))
+        return "Opera";
+    if (Gw(e2))
+        return "IEMobile";
+    if (e2.includes("msie") || e2.includes("trident/"))
+        return "IE";
+    if (e2.includes("edge/"))
+        return "Edge";
+    if (Ww(e2))
+        return "Firefox";
+    if (e2.includes("silk/"))
+        return "Silk";
+    if (Qw(e2))
+        return "Blackberry";
+    if (Xw(e2))
+        return "Webos";
+    if (qw(e2))
+        return "Safari";
+    if ((e2.includes("chrome/") || Kw(e2)) && !e2.includes("edge/"))
+        return "Chrome";
+    if (Yw(e2))
+        return "Android";
+    {
+        const e3 = /([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/,
+            i2 = t3.match(e3);
+        if (2 === (null == i2 ? void 0 : i2.length))
+            return i2[1];
+    }
+    return "Other";
+}
+
+function Ww(t3 = kd()) {
+    return /firefox\//i.test(t3);
+}
+
+function qw(t3 = kd()) {
+    const e2 = t3.toLowerCase();
+    return e2.includes("safari/") && !e2.includes("chrome/") && !e2.includes("crios/") && !e2.includes("android");
+}
+
+function Kw(t3 = kd()) {
+    return /crios\//i.test(t3);
+}
+
+function Gw(t3 = kd()) {
+    return /iemobile/i.test(t3);
+}
+
+function Yw(t3 = kd()) {
+    return /android/i.test(t3);
+}
+
+function Qw(t3 = kd()) {
+    return /blackberry/i.test(t3);
+}
+
+function Xw(t3 = kd()) {
+    return /webos/i.test(t3);
+}
+
+function Jw(t3 = kd()) {
+    return /iphone|ipad|ipod/i.test(t3) || /macintosh/i.test(t3) && /mobile/i.test(t3);
+}
+
+function Zw() {
+    return function() {
+        const t3 = kd();
+        return t3.indexOf("MSIE ") >= 0 || t3.indexOf("Trident/") >= 0;
+    }() && 10 === document.documentMode;
+}
+
+function tx(t3 = kd()) {
+    return Jw(t3) || Yw(t3) || Xw(t3) || Qw(t3) || /windows phone/i.test(t3) || Gw(t3);
+}
+
+function ex(t3, e2 = []) {
+    let i2;
+    switch (t3) {
+        case "Browser":
+            i2 = Hw(kd());
+            break;
+        case "Worker":
+            i2 = `${Hw(kd())}-${t3}`;
+            break;
+        default:
+            i2 = t3;
+    }
+    const s2 = e2.length ? e2.join(",") : "FirebaseCore-web";
+    return `${i2}/JsCore/${uf}/${s2}`;
+}
+async function ix(t3, e2) {
+    return Pw(t3, "GET", "/v2/recaptchaConfig", Mw(t3, e2));
+}
+
+function sx(t3) {
+    return void 0 !== t3 && void 0 !== t3.enterprise;
+}
+class RecaptchaConfig {
+    constructor(t3) {
+        if (this.siteKey = "", this.emailPasswordEnabled = false, void 0 === t3.recaptchaKey)
+            throw new Error("recaptchaKey undefined");
+        this.siteKey = t3.recaptchaKey.split("/")[3], this.emailPasswordEnabled = t3.recaptchaEnforcementState.some((t4) => "EMAIL_PASSWORD_PROVIDER" === t4.provider && "OFF" !== t4.enforcementState);
+    }
+}
+
+function nx(t3) {
+    return new Promise((e2, i2) => {
+        const s2 = document.createElement("script");
+        var n2, r2;
+        s2.setAttribute("src", t3), s2.onload = e2, s2.onerror = (t4) => {
+            const e3 = vw("internal-error");
+            e3.customData = t4, i2(e3);
+        }, s2.type = "text/javascript", s2.charset = "UTF-8", (null !== (r2 = null === (n2 = document.getElementsByTagName("head")) || void 0 === n2 ? void 0 : n2[0]) && void 0 !== r2 ? r2 : document).appendChild(s2);
+    });
+}
+class RecaptchaEnterpriseVerifier {
+    constructor(t3) {
+        this.type = "recaptcha-enterprise", this.auth = rx(t3);
+    }
+    async verify(t3 = "verify", e2 = false) {
+        function i2(e3, i3, s2) {
+            const n2 = window.grecaptcha;
+            sx(n2) ? n2.enterprise.ready(() => {
+                n2.enterprise.execute(e3, {
+                    action: t3
+                }).then((t4) => {
+                    i3(t4);
+                }).catch(() => {
+                    i3("NO_RECAPTCHA");
+                });
+            }) : s2(Error("No reCAPTCHA enterprise script loaded."));
+        }
+        return new Promise((t4, s2) => {
+            (async function(t5) {
+                if (!e2) {
+                    if (null == t5.tenantId && null != t5._agentRecaptchaConfig)
+                        return t5._agentRecaptchaConfig.siteKey;
+                    if (null != t5.tenantId && void 0 !== t5._tenantRecaptchaConfigs[t5.tenantId])
+                        return t5._tenantRecaptchaConfigs[t5.tenantId].siteKey;
+                }
+                return new Promise(async (e3, i3) => {
+                    ix(t5, {
+                        clientType: "CLIENT_TYPE_WEB",
+                        version: "RECAPTCHA_ENTERPRISE"
+                    }).then((s3) => {
+                        if (void 0 !== s3.recaptchaKey) {
+                            const i4 = new RecaptchaConfig(s3);
+                            return null == t5.tenantId ? t5._agentRecaptchaConfig = i4 : t5._tenantRecaptchaConfigs[t5.tenantId] = i4, e3(i4.siteKey);
+                        }
+                        i3(new Error("recaptcha Enterprise site key undefined"));
+                    }).catch((t6) => {
+                        i3(t6);
+                    });
+                });
+            })(this.auth).then((n2) => {
+                if (!e2 && sx(window.grecaptcha))
+                    i2(n2, t4, s2);
+                else {
+                    if ("undefined" == typeof window)
+                        return void s2(new Error("RecaptchaVerifier is only supported in browser"));
+                    nx("https://www.google.com/recaptcha/enterprise.js?render=" + n2).then(() => {
+                        i2(n2, t4, s2);
+                    }).catch((t5) => {
+                        s2(t5);
+                    });
+                }
+            }).catch((t5) => {
+                s2(t5);
+            });
+        });
+    }
+}
+class AuthMiddlewareQueue {
+    constructor(t3) {
+        this.auth = t3, this.queue = [];
+    }
+    pushCallback(t3, e2) {
+        const i2 = (e3) => new Promise((i3, s3) => {
+            try {
+                i3(t3(e3));
+            } catch (t4) {
+                s3(t4);
+            }
+        });
+        i2.onAbort = e2, this.queue.push(i2);
+        const s2 = this.queue.length - 1;
+        return () => {
+            this.queue[s2] = () => Promise.resolve();
+        };
+    }
+    async runMiddleware(t3) {
+        if (this.auth.currentUser === t3)
+            return;
+        const e2 = [];
+        try {
+            for (const i2 of this.queue)
+                await i2(t3), i2.onAbort && e2.push(i2.onAbort);
+        } catch (t4) {
+            e2.reverse();
+            for (const t5 of e2)
+                try {
+                    t5();
+                } catch (t6) {}
+            throw this.auth._errorFactory.create("login-blocked", {
+                originalMessage: null == t4 ? void 0 : t4.message
+            });
+        }
+    }
+}
+class AuthImpl {
+    constructor(t3, e2, i2, s2) {
+        this.app = t3, this.heartbeatServiceProvider = e2, this.appCheckServiceProvider = i2, this.config = s2, this.currentUser = null, this.emulatorConfig = null, this.operations = Promise.resolve(), this.authStateSubscription = new Subscription(this), this.idTokenSubscription = new Subscription(this), this.beforeStateQueue = new AuthMiddlewareQueue(this), this.redirectUser = null, this.isProactiveRefreshEnabled = false, this._canInitEmulator = true, this._isInitialized = false, this._deleted = false, this._initializationPromise = null, this._popupRedirectResolver = null, this._errorFactory = pw, this._agentRecaptchaConfig = null, this._tenantRecaptchaConfigs = {}, this.lastNotifiedUid = void 0, this.languageCode = null, this.tenantId = null, this.settings = {
+            appVerificationDisabledForTesting: false
+        }, this.frameworks = [], this.name = t3.name, this.clientVersion = s2.sdkClientVersion;
+    }
+    _initializeWithPersistence(t3, e2) {
+        return e2 && (this._popupRedirectResolver = Bw(e2)), this._initializationPromise = this.queue(async () => {
+            var i2, s2;
+            if (!this._deleted && (this.persistenceManager = await PersistenceUserManager.create(this, t3), !this._deleted)) {
+                if (null === (i2 = this._popupRedirectResolver) || void 0 === i2 ? void 0 : i2._shouldInitProactively)
+                    try {
+                        await this._popupRedirectResolver._initialize(this);
+                    } catch (t4) {}
+                await this.initializeCurrentUser(e2), this.lastNotifiedUid = (null === (s2 = this.currentUser) || void 0 === s2 ? void 0 : s2.uid) || null, this._deleted || (this._isInitialized = true);
+            }
+        }), this._initializationPromise;
+    }
+    async _onStorageEvent() {
+        if (this._deleted)
+            return;
+        const t3 = await this.assertedPersistence.getCurrentUser();
+        return this.currentUser || t3 ? this.currentUser && t3 && this.currentUser.uid === t3.uid ? (this._currentUser._assign(t3), void await this.currentUser.getIdToken()) : void await this._updateCurrentUser(t3, true) : void 0;
+    }
+    async initializeCurrentUser(t3) {
+        var e2;
+        const i2 = await this.assertedPersistence.getCurrentUser();
+        let s2 = i2,
+            n2 = false;
+        if (t3 && this.config.authDomain) {
+            await this.getOrInitRedirectPersistenceManager();
+            const i3 = null === (e2 = this.redirectUser) || void 0 === e2 ? void 0 : e2._redirectEventId,
+                r2 = null == s2 ? void 0 : s2._redirectEventId,
+                o2 = await this.tryRedirectSignIn(t3);
+            i3 && i3 !== r2 || !(null == o2 ? void 0 : o2.user) || (s2 = o2.user, n2 = true);
+        }
+        if (!s2)
+            return this.directlySetCurrentUser(null);
+        if (!s2._redirectEventId) {
+            if (n2)
+                try {
+                    await this.beforeStateQueue.runMiddleware(s2);
+                } catch (t4) {
+                    s2 = i2, this._popupRedirectResolver._overrideRedirectResult(this, () => Promise.reject(t4));
+                }
+            return s2 ? this.reloadAndSetCurrentUserOrClear(s2) : this.directlySetCurrentUser(null);
+        }
+        return _w(this._popupRedirectResolver, this, "argument-error"), await this.getOrInitRedirectPersistenceManager(), this.redirectUser && this.redirectUser._redirectEventId === s2._redirectEventId ? this.directlySetCurrentUser(s2) : this.reloadAndSetCurrentUserOrClear(s2);
+    }
+    async tryRedirectSignIn(t3) {
+        let e2 = null;
+        try {
+            e2 = await this._popupRedirectResolver._completeRedirectFn(this, t3, true);
+        } catch (t4) {
+            await this._setRedirectUser(null);
+        }
+        return e2;
+    }
+    async reloadAndSetCurrentUserOrClear(t3) {
+        try {
+            await $w(t3);
+        } catch (t4) {
+            if ("auth/network-request-failed" !== (null == t4 ? void 0 : t4.code))
+                return this.directlySetCurrentUser(null);
+        }
+        return this.directlySetCurrentUser(t3);
+    }
+    useDeviceLanguage() {
+        this.languageCode = function() {
+            if ("undefined" == typeof navigator)
+                return null;
+            const t3 = navigator;
+            return t3.languages && t3.languages[0] || t3.language || null;
+        }();
+    }
+    async _delete() {
+        this._deleted = true;
+    }
+    async updateCurrentUser(t3) {
+        const e2 = t3 ? Md(t3) : null;
+        return e2 && _w(e2.auth.config.apiKey === this.config.apiKey, this, "invalid-user-token"), this._updateCurrentUser(e2 && e2._clone(this));
+    }
+    async _updateCurrentUser(t3, e2 = false) {
+        if (!this._deleted)
+            return t3 && _w(this.tenantId === t3.tenantId, this, "tenant-id-mismatch"), e2 || await this.beforeStateQueue.runMiddleware(t3), this.queue(async () => {
+                await this.directlySetCurrentUser(t3), this.notifyAuthListeners();
+            });
+    }
+    async signOut() {
+        return await this.beforeStateQueue.runMiddleware(null), (this.redirectPersistenceManager || this._popupRedirectResolver) && await this._setRedirectUser(null), this._updateCurrentUser(null, true);
+    }
+    setPersistence(t3) {
+        return this.queue(async () => {
+            await this.assertedPersistence.setPersistence(Bw(t3));
+        });
+    }
+    async initializeRecaptchaConfig() {
+        const t3 = await ix(this, {
+                clientType: "CLIENT_TYPE_WEB",
+                version: "RECAPTCHA_ENTERPRISE"
+            }),
+            e2 = new RecaptchaConfig(t3);
+        if (null == this.tenantId ? this._agentRecaptchaConfig = e2 : this._tenantRecaptchaConfigs[this.tenantId] = e2, e2.emailPasswordEnabled) {
+            new RecaptchaEnterpriseVerifier(this).verify();
+        }
+    }
+    _getRecaptchaConfig() {
+        return null == this.tenantId ? this._agentRecaptchaConfig : this._tenantRecaptchaConfigs[this.tenantId];
+    }
+    _getPersistence() {
+        return this.assertedPersistence.persistence.type;
+    }
+    _updateErrorMap(t3) {
+        this._errorFactory = new ErrorFactory("auth", "Firebase", t3());
+    }
+    onAuthStateChanged(t3, e2, i2) {
+        return this.registerStateListener(this.authStateSubscription, t3, e2, i2);
+    }
+    beforeAuthStateChanged(t3, e2) {
+        return this.beforeStateQueue.pushCallback(t3, e2);
+    }
+    onIdTokenChanged(t3, e2, i2) {
+        return this.registerStateListener(this.idTokenSubscription, t3, e2, i2);
+    }
+    toJSON() {
+        var t3;
+        return {
+            apiKey: this.config.apiKey,
+            authDomain: this.config.authDomain,
+            appName: this.name,
+            currentUser: null === (t3 = this._currentUser) || void 0 === t3 ? void 0 : t3.toJSON()
+        };
+    }
+    async _setRedirectUser(t3, e2) {
+        const i2 = await this.getOrInitRedirectPersistenceManager(e2);
+        return null === t3 ? i2.removeCurrentUser() : i2.setCurrentUser(t3);
+    }
+    async getOrInitRedirectPersistenceManager(t3) {
+        if (!this.redirectPersistenceManager) {
+            const e2 = t3 && Bw(t3) || this._popupRedirectResolver;
+            _w(e2, this, "argument-error"), this.redirectPersistenceManager = await PersistenceUserManager.create(this, [Bw(e2._redirectPersistence)], "redirectUser"), this.redirectUser = await this.redirectPersistenceManager.getCurrentUser();
+        }
+        return this.redirectPersistenceManager;
+    }
+    async _redirectUserForId(t3) {
+        var e2, i2;
+        return this._isInitialized && await this.queue(async () => {}), (null === (e2 = this._currentUser) || void 0 === e2 ? void 0 : e2._redirectEventId) === t3 ? this._currentUser : (null === (i2 = this.redirectUser) || void 0 === i2 ? void 0 : i2._redirectEventId) === t3 ? this.redirectUser : null;
+    }
+    async _persistUserIfCurrent(t3) {
+        if (t3 === this.currentUser)
+            return this.queue(async () => this.directlySetCurrentUser(t3));
+    }
+    _notifyListenersIfCurrent(t3) {
+        t3 === this.currentUser && this.notifyAuthListeners();
+    }
+    _key() {
+        return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`;
+    }
+    _startProactiveRefresh() {
+        this.isProactiveRefreshEnabled = true, this.currentUser && this._currentUser._startProactiveRefresh();
+    }
+    _stopProactiveRefresh() {
+        this.isProactiveRefreshEnabled = false, this.currentUser && this._currentUser._stopProactiveRefresh();
+    }
+    get _currentUser() {
+        return this.currentUser;
+    }
+    notifyAuthListeners() {
+        var t3, e2;
+        if (!this._isInitialized)
+            return;
+        this.idTokenSubscription.next(this.currentUser);
+        const i2 = null !== (e2 = null === (t3 = this.currentUser) || void 0 === t3 ? void 0 : t3.uid) && void 0 !== e2 ? e2 : null;
+        this.lastNotifiedUid !== i2 && (this.lastNotifiedUid = i2, this.authStateSubscription.next(this.currentUser));
+    }
+    registerStateListener(t3, e2, i2, s2) {
+        if (this._deleted)
+            return () => {};
+        const n2 = "function" == typeof e2 ? e2 : e2.next.bind(e2),
+            r2 = this._isInitialized ? Promise.resolve() : this._initializationPromise;
+        return _w(r2, this, "internal-error"), r2.then(() => n2(this.currentUser)), "function" == typeof e2 ? t3.addObserver(e2, i2, s2) : t3.addObserver(e2);
+    }
+    async directlySetCurrentUser(t3) {
+        this.currentUser && this.currentUser !== t3 && this._currentUser._stopProactiveRefresh(), t3 && this.isProactiveRefreshEnabled && t3._startProactiveRefresh(), this.currentUser = t3, t3 ? await this.assertedPersistence.setCurrentUser(t3) : await this.assertedPersistence.removeCurrentUser();
+    }
+    queue(t3) {
+        return this.operations = this.operations.then(t3, t3), this.operations;
+    }
+    get assertedPersistence() {
+        return _w(this.persistenceManager, this, "internal-error"), this.persistenceManager;
+    }
+    _logFramework(t3) {
+        t3 && !this.frameworks.includes(t3) && (this.frameworks.push(t3), this.frameworks.sort(), this.clientVersion = ex(this.config.clientPlatform, this._getFrameworks()));
+    }
+    _getFrameworks() {
+        return this.frameworks;
+    }
+    async _getAdditionalHeaders() {
+        var t3;
+        const e2 = {
+            "X-Client-Version": this.clientVersion
+        };
+        this.app.options.appId && (e2["X-Firebase-gmpid"] = this.app.options.appId);
+        const i2 = await (null === (t3 = this.heartbeatServiceProvider.getImmediate({
+            optional: true
+        })) || void 0 === t3 ? void 0 : t3.getHeartbeatsHeader());
+        i2 && (e2["X-Firebase-Client"] = i2);
+        const s2 = await this._getAppCheckToken();
+        return s2 && (e2["X-Firebase-AppCheck"] = s2), e2;
+    }
+    async _getAppCheckToken() {
+        var t3;
+        const e2 = await (null === (t3 = this.appCheckServiceProvider.getImmediate({
+            optional: true
+        })) || void 0 === t3 ? void 0 : t3.getToken());
+        return (null == e2 ? void 0 : e2.error) && function(t4, ...e3) {
+            mw.logLevel <= Rd.WARN && mw.warn(`Auth (${uf}): ${t4}`, ...e3);
+        }(`Error while retrieving App Check token: ${e2.error}`), null == e2 ? void 0 : e2.token;
+    }
+}
+
+function rx(t3) {
+    return Md(t3);
+}
+class Subscription {
+    constructor(t3) {
+        this.auth = t3, this.observer = null, this.addObserver = function(t4, e2) {
+            const i2 = new ObserverProxy(t4, e2);
+            return i2.subscribe.bind(i2);
+        }((t4) => this.observer = t4);
+    }
+    get next() {
+        return _w(this.observer, this.auth, "internal-error"), this.observer.next.bind(this.observer);
+    }
+}
+
+function ox(t3, e2, i2) {
+    const s2 = rx(t3);
+    _w(s2._canInitEmulator, s2, "emulator-config-failed"), _w(/^https?:\/\//.test(e2), s2, "invalid-emulator-scheme");
+    const n2 = !!(null == i2 ? void 0 : i2.disableWarnings),
+        r2 = ax(e2),
+        {
+            host: o2,
+            port: a2
+        } = function(t4) {
+            const e3 = ax(t4),
+                i3 = /(\/\/)?([^?#/]+)/.exec(t4.substr(e3.length));
+            if (!i3)
+                return {
+                    host: "",
+                    port: null
+                };
+            const s3 = i3[2].split("@").pop() || "",
+                n3 = /^(\[[^\]]+\])(:|$)/.exec(s3);
+            if (n3) {
+                const t5 = n3[1];
+                return {
+                    host: t5,
+                    port: lx(s3.substr(t5.length + 1))
+                };
+            } {
+                const [t5, e4] = s3.split(":");
+                return {
+                    host: t5,
+                    port: lx(e4)
+                };
+            }
+        }(e2),
+        l2 = null === a2 ? "" : `:${a2}`;
+    s2.config.emulator = {
+        url: `${r2}//${o2}${l2}/`
+    }, s2.settings.appVerificationDisabledForTesting = true, s2.emulatorConfig = Object.freeze({
+        host: o2,
+        port: a2,
+        protocol: r2.replace(":", ""),
+        options: Object.freeze({
+            disableWarnings: n2
+        })
+    }), n2 || function() {
+        function t4() {
+            const t5 = document.createElement("p"),
+                e3 = t5.style;
+            t5.innerText = "Running in emulator mode. Do not use with production credentials.", e3.position = "fixed", e3.width = "100%", e3.backgroundColor = "#ffffff", e3.border = ".1em solid #000000", e3.color = "#b50000", e3.bottom = "0px", e3.left = "0px", e3.margin = "0px", e3.zIndex = "10000", e3.textAlign = "center", t5.classList.add("firebase-emulator-warning"), document.body.appendChild(t5);
+        }
+        "undefined" != typeof console && "function" == typeof console.info && console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials.");
+        "undefined" != typeof window && "undefined" != typeof document && ("loading" === document.readyState ? window.addEventListener("DOMContentLoaded", t4) : t4());
+    }();
+}
+
+function ax(t3) {
+    const e2 = t3.indexOf(":");
+    return e2 < 0 ? "" : t3.substr(0, e2 + 1);
+}
+
+function lx(t3) {
+    if (!t3)
+        return null;
+    const e2 = Number(t3);
+    return isNaN(e2) ? null : e2;
+}
+class AuthCredential {
+    constructor(t3, e2) {
+        this.providerId = t3, this.signInMethod = e2;
+    }
+    toJSON() {
+        return ww("not implemented");
+    }
+    _getIdTokenResponse(t3) {
+        return ww("not implemented");
+    }
+    _linkToIdToken(t3, e2) {
+        return ww("not implemented");
+    }
+    _getReauthenticationResolver(t3) {
+        return ww("not implemented");
+    }
+}
+async function hx(t3, e2) {
+    return async function(t4, e3, i2, s2, n2 = {}) {
+        const r2 = await Pw(t4, e3, i2, s2, n2);
+        return "mfaPendingCredential" in r2 && yw(t4, "multi-factor-auth-required", {
+            _serverResponse: r2
+        }), r2;
+    }(t3, "POST", "/v1/accounts:signInWithIdp", Mw(t3, e2));
+}
+class OAuthCredential extends AuthCredential {
+    constructor() {
+        super(...arguments), this.pendingToken = null;
+    }
+    static _fromParams(t3) {
+        const e2 = new OAuthCredential(t3.providerId, t3.signInMethod);
+        return t3.idToken || t3.accessToken ? (t3.idToken && (e2.idToken = t3.idToken), t3.accessToken && (e2.accessToken = t3.accessToken), t3.nonce && !t3.pendingToken && (e2.nonce = t3.nonce), t3.pendingToken && (e2.pendingToken = t3.pendingToken)) : t3.oauthToken && t3.oauthTokenSecret ? (e2.accessToken = t3.oauthToken, e2.secret = t3.oauthTokenSecret) : yw("argument-error"), e2;
+    }
+    toJSON() {
+        return {
+            idToken: this.idToken,
+            accessToken: this.accessToken,
+            secret: this.secret,
+            nonce: this.nonce,
+            pendingToken: this.pendingToken,
+            providerId: this.providerId,
+            signInMethod: this.signInMethod
+        };
+    }
+    static fromJSON(t3) {
+        const e2 = "string" == typeof t3 ? JSON.parse(t3) : t3,
+            {
+                providerId: i2,
+                signInMethod: s2
+            } = e2,
+            n2 = uw(e2, ["providerId", "signInMethod"]);
+        if (!i2 || !s2)
+            return null;
+        const r2 = new OAuthCredential(i2, s2);
+        return r2.idToken = n2.idToken || void 0, r2.accessToken = n2.accessToken || void 0, r2.secret = n2.secret, r2.nonce = n2.nonce, r2.pendingToken = n2.pendingToken || null, r2;
+    }
+    _getIdTokenResponse(t3) {
+        return hx(t3, this.buildRequest());
+    }
+    _linkToIdToken(t3, e2) {
+        const i2 = this.buildRequest();
+        return i2.idToken = e2, hx(t3, i2);
+    }
+    _getReauthenticationResolver(t3) {
+        const e2 = this.buildRequest();
+        return e2.autoCreate = false, hx(t3, e2);
+    }
+    buildRequest() {
+        const t3 = {
+            requestUri: "http://localhost",
+            returnSecureToken: true
+        };
+        if (this.pendingToken)
+            t3.pendingToken = this.pendingToken;
+        else {
+            const e2 = {};
+            this.idToken && (e2.id_token = this.idToken), this.accessToken && (e2.access_token = this.accessToken), this.secret && (e2.oauth_token_secret = this.secret), e2.providerId = this.providerId, this.nonce && !this.pendingToken && (e2.nonce = this.nonce), t3.postBody = Cd(e2);
+        }
+        return t3;
+    }
+}
+class FederatedAuthProvider {
+    constructor(t3) {
+        this.providerId = t3, this.defaultLanguageCode = null, this.customParameters = {};
+    }
+    setDefaultLanguage(t3) {
+        this.defaultLanguageCode = t3;
+    }
+    setCustomParameters(t3) {
+        return this.customParameters = t3, this;
+    }
+    getCustomParameters() {
+        return this.customParameters;
+    }
+}
+class BaseOAuthProvider extends FederatedAuthProvider {
+    constructor() {
+        super(...arguments), this.scopes = [];
+    }
+    addScope(t3) {
+        return this.scopes.includes(t3) || this.scopes.push(t3), this;
+    }
+    getScopes() {
+        return [...this.scopes];
+    }
+}
+class FacebookAuthProvider extends BaseOAuthProvider {
+    constructor() {
+        super("facebook.com");
+    }
+    static credential(t3) {
+        return OAuthCredential._fromParams({
+            providerId: FacebookAuthProvider.PROVIDER_ID,
+            signInMethod: FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD,
+            accessToken: t3
+        });
+    }
+    static credentialFromResult(t3) {
+        return FacebookAuthProvider.credentialFromTaggedObject(t3);
+    }
+    static credentialFromError(t3) {
+        return FacebookAuthProvider.credentialFromTaggedObject(t3.customData || {});
+    }
+    static credentialFromTaggedObject({
+        _tokenResponse: t3
+    }) {
+        if (!t3 || !("oauthAccessToken" in t3))
+            return null;
+        if (!t3.oauthAccessToken)
+            return null;
+        try {
+            return FacebookAuthProvider.credential(t3.oauthAccessToken);
+        } catch (t4) {
+            return null;
+        }
+    }
+}
+FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD = "facebook.com", FacebookAuthProvider.PROVIDER_ID = "facebook.com";
+class GoogleAuthProvider extends BaseOAuthProvider {
+    constructor() {
+        super("google.com"), this.addScope("profile");
+    }
+    static credential(t3, e2) {
+        return OAuthCredential._fromParams({
+            providerId: GoogleAuthProvider.PROVIDER_ID,
+            signInMethod: GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD,
+            idToken: t3,
+            accessToken: e2
+        });
+    }
+    static credentialFromResult(t3) {
+        return GoogleAuthProvider.credentialFromTaggedObject(t3);
+    }
+    static credentialFromError(t3) {
+        return GoogleAuthProvider.credentialFromTaggedObject(t3.customData || {});
+    }
+    static credentialFromTaggedObject({
+        _tokenResponse: t3
+    }) {
+        if (!t3)
+            return null;
+        const {
+            oauthIdToken: e2,
+            oauthAccessToken: i2
+        } = t3;
+        if (!e2 && !i2)
+            return null;
+        try {
+            return GoogleAuthProvider.credential(e2, i2);
+        } catch (t4) {
+            return null;
+        }
+    }
+}
+GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD = "google.com", GoogleAuthProvider.PROVIDER_ID = "google.com";
+class GithubAuthProvider extends BaseOAuthProvider {
+    constructor() {
+        super("github.com");
+    }
+    static credential(t3) {
+        return OAuthCredential._fromParams({
+            providerId: GithubAuthProvider.PROVIDER_ID,
+            signInMethod: GithubAuthProvider.GITHUB_SIGN_IN_METHOD,
+            accessToken: t3
+        });
+    }
+    static credentialFromResult(t3) {
+        return GithubAuthProvider.credentialFromTaggedObject(t3);
+    }
+    static credentialFromError(t3) {
+        return GithubAuthProvider.credentialFromTaggedObject(t3.customData || {});
+    }
+    static credentialFromTaggedObject({
+        _tokenResponse: t3
+    }) {
+        if (!t3 || !("oauthAccessToken" in t3))
+            return null;
+        if (!t3.oauthAccessToken)
+            return null;
+        try {
+            return GithubAuthProvider.credential(t3.oauthAccessToken);
+        } catch (t4) {
+            return null;
+        }
+    }
+}
+GithubAuthProvider.GITHUB_SIGN_IN_METHOD = "github.com", GithubAuthProvider.PROVIDER_ID = "github.com";
+class TwitterAuthProvider extends BaseOAuthProvider {
+    constructor() {
+        super("twitter.com");
+    }
+    static credential(t3, e2) {
+        return OAuthCredential._fromParams({
+            providerId: TwitterAuthProvider.PROVIDER_ID,
+            signInMethod: TwitterAuthProvider.TWITTER_SIGN_IN_METHOD,
+            oauthToken: t3,
+            oauthTokenSecret: e2
+        });
+    }
+    static credentialFromResult(t3) {
+        return TwitterAuthProvider.credentialFromTaggedObject(t3);
+    }
+    static credentialFromError(t3) {
+        return TwitterAuthProvider.credentialFromTaggedObject(t3.customData || {});
+    }
+    static credentialFromTaggedObject({
+        _tokenResponse: t3
+    }) {
+        if (!t3)
+            return null;
+        const {
+            oauthAccessToken: e2,
+            oauthTokenSecret: i2
+        } = t3;
+        if (!e2 || !i2)
+            return null;
+        try {
+            return TwitterAuthProvider.credential(e2, i2);
+        } catch (t4) {
+            return null;
+        }
+    }
+}
+TwitterAuthProvider.TWITTER_SIGN_IN_METHOD = "twitter.com", TwitterAuthProvider.PROVIDER_ID = "twitter.com";
+class UserCredentialImpl {
+    constructor(t3) {
+        this.user = t3.user, this.providerId = t3.providerId, this._tokenResponse = t3._tokenResponse, this.operationType = t3.operationType;
+    }
+    static async _fromIdTokenResponse(t3, e2, i2, s2 = false) {
+        const n2 = await UserImpl._fromIdTokenResponse(t3, i2, s2),
+            r2 = cx(i2);
+        return new UserCredentialImpl({
+            user: n2,
+            providerId: r2,
+            _tokenResponse: i2,
+            operationType: e2
+        });
+    }
+    static async _forOperation(t3, e2, i2) {
+        await t3._updateTokensIfNecessary(i2, true);
+        const s2 = cx(i2);
+        return new UserCredentialImpl({
+            user: t3,
+            providerId: s2,
+            _tokenResponse: i2,
+            operationType: e2
+        });
+    }
+}
+
+function cx(t3) {
+    return t3.providerId ? t3.providerId : "phoneNumber" in t3 ? "phone" : null;
+}
+class MultiFactorError extends FirebaseError {
+    constructor(t3, e2, i2, s2) {
+        var n2;
+        super(e2.code, e2.message), this.operationType = i2, this.user = s2, Object.setPrototypeOf(this, MultiFactorError.prototype), this.customData = {
+            appName: t3.name,
+            tenantId: null !== (n2 = t3.tenantId) && void 0 !== n2 ? n2 : void 0,
+            _serverResponse: e2.customData._serverResponse,
+            operationType: i2
+        };
+    }
+    static _fromErrorAndOperation(t3, e2, i2, s2) {
+        return new MultiFactorError(t3, e2, i2, s2);
+    }
+}
+
+function ux(t3, e2, i2, s2) {
+    return ("reauthenticate" === e2 ? i2._getReauthenticationResolver(t3) : i2._getIdTokenResponse(t3)).catch((i3) => {
+        if ("auth/multi-factor-auth-required" === i3.code)
+            throw MultiFactorError._fromErrorAndOperation(t3, i3, e2, s2);
+        throw i3;
+    });
+}
+const dx = "__sak";
+class BrowserPersistenceClass {
+    constructor(t3, e2) {
+        this.storageRetriever = t3, this.type = e2;
+    }
+    _isAvailable() {
+        try {
+            return this.storage ? (this.storage.setItem(dx, "1"), this.storage.removeItem(dx), Promise.resolve(true)) : Promise.resolve(false);
+        } catch (t3) {
+            return Promise.resolve(false);
+        }
+    }
+    _set(t3, e2) {
+        return this.storage.setItem(t3, JSON.stringify(e2)), Promise.resolve();
+    }
+    _get(t3) {
+        const e2 = this.storage.getItem(t3);
+        return Promise.resolve(e2 ? JSON.parse(e2) : null);
+    }
+    _remove(t3) {
+        return this.storage.removeItem(t3), Promise.resolve();
+    }
+    get storage() {
+        return this.storageRetriever();
+    }
+}
+class BrowserLocalPersistence extends BrowserPersistenceClass {
+    constructor() {
+        super(() => window.localStorage, "LOCAL"), this.boundEventHandler = (t3, e2) => this.onStorageEvent(t3, e2), this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.safariLocalStorageNotSynced = function() {
+            const t3 = kd();
+            return qw(t3) || Jw(t3);
+        }() && function() {
+            try {
+                return !(!window || window === window.top);
+            } catch (t3) {
+                return false;
+            }
+        }(), this.fallbackToPolling = tx(), this._shouldAllowMigration = true;
+    }
+    forAllChangedKeys(t3) {
+        for (const e2 of Object.keys(this.listeners)) {
+            const i2 = this.storage.getItem(e2),
+                s2 = this.localCache[e2];
+            i2 !== s2 && t3(e2, s2, i2);
+        }
+    }
+    onStorageEvent(t3, e2 = false) {
+        if (!t3.key)
+            return void this.forAllChangedKeys((t4, e3, i3) => {
+                this.notifyListeners(t4, i3);
+            });
+        const i2 = t3.key;
+        if (e2 ? this.detachListener() : this.stopPolling(), this.safariLocalStorageNotSynced) {
+            const s3 = this.storage.getItem(i2);
+            if (t3.newValue !== s3)
+                null !== t3.newValue ? this.storage.setItem(i2, t3.newValue) : this.storage.removeItem(i2);
+            else if (this.localCache[i2] === t3.newValue && !e2)
+                return;
+        }
+        const s2 = () => {
+                const t4 = this.storage.getItem(i2);
+                (e2 || this.localCache[i2] !== t4) && this.notifyListeners(i2, t4);
+            },
+            n2 = this.storage.getItem(i2);
+        Zw() && n2 !== t3.newValue && t3.newValue !== t3.oldValue ? setTimeout(s2, 10) : s2();
+    }
+    notifyListeners(t3, e2) {
+        this.localCache[t3] = e2;
+        const i2 = this.listeners[t3];
+        if (i2)
+            for (const t4 of Array.from(i2))
+                t4(e2 ? JSON.parse(e2) : e2);
+    }
+    startPolling() {
+        this.stopPolling(), this.pollTimer = setInterval(() => {
+            this.forAllChangedKeys((t3, e2, i2) => {
+                this.onStorageEvent(new StorageEvent("storage", {
+                    key: t3,
+                    oldValue: e2,
+                    newValue: i2
+                }), true);
+            });
+        }, 1e3);
+    }
+    stopPolling() {
+        this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null);
+    }
+    attachListener() {
+        window.addEventListener("storage", this.boundEventHandler);
+    }
+    detachListener() {
+        window.removeEventListener("storage", this.boundEventHandler);
+    }
+    _addListener(t3, e2) {
+        0 === Object.keys(this.listeners).length && (this.fallbackToPolling ? this.startPolling() : this.attachListener()), this.listeners[t3] || (this.listeners[t3] = /* @__PURE__ */ new Set(), this.localCache[t3] = this.storage.getItem(t3)), this.listeners[t3].add(e2);
+    }
+    _removeListener(t3, e2) {
+        this.listeners[t3] && (this.listeners[t3].delete(e2), 0 === this.listeners[t3].size && delete this.listeners[t3]), 0 === Object.keys(this.listeners).length && (this.detachListener(), this.stopPolling());
+    }
+    async _set(t3, e2) {
+        await super._set(t3, e2), this.localCache[t3] = JSON.stringify(e2);
+    }
+    async _get(t3) {
+        const e2 = await super._get(t3);
+        return this.localCache[t3] = JSON.stringify(e2), e2;
+    }
+    async _remove(t3) {
+        await super._remove(t3), delete this.localCache[t3];
+    }
+}
+BrowserLocalPersistence.type = "LOCAL";
+const fx = BrowserLocalPersistence;
+class BrowserSessionPersistence extends BrowserPersistenceClass {
+    constructor() {
+        super(() => window.sessionStorage, "SESSION");
+    }
+    _addListener(t3, e2) {}
+    _removeListener(t3, e2) {}
+}
+BrowserSessionPersistence.type = "SESSION";
+const px = BrowserSessionPersistence;
+class Receiver {
+    constructor(t3) {
+        this.eventTarget = t3, this.handlersMap = {}, this.boundEventHandler = this.handleEvent.bind(this);
+    }
+    static _getInstance(t3) {
+        const e2 = this.receivers.find((e3) => e3.isListeningto(t3));
+        if (e2)
+            return e2;
+        const i2 = new Receiver(t3);
+        return this.receivers.push(i2), i2;
+    }
+    isListeningto(t3) {
+        return this.eventTarget === t3;
+    }
+    async handleEvent(t3) {
+        const e2 = t3,
+            {
+                eventId: i2,
+                eventType: s2,
+                data: n2
+            } = e2.data,
+            r2 = this.handlersMap[s2];
+        if (!(null == r2 ? void 0 : r2.size))
+            return;
+        e2.ports[0].postMessage({
+            status: "ack",
+            eventId: i2,
+            eventType: s2
+        });
+        const o2 = Array.from(r2).map(async (t4) => t4(e2.origin, n2)),
+            a2 = await
+        function(t4) {
+            return Promise.all(t4.map(async (t5) => {
+                try {
+                    return {
+                        fulfilled: true,
+                        value: await t5
+                    };
+                } catch (t6) {
+                    return {
+                        fulfilled: false,
+                        reason: t6
+                    };
+                }
+            }));
+        }(o2);
+        e2.ports[0].postMessage({
+            status: "done",
+            eventId: i2,
+            eventType: s2,
+            response: a2
+        });
+    }
+    _subscribe(t3, e2) {
+        0 === Object.keys(this.handlersMap).length && this.eventTarget.addEventListener("message", this.boundEventHandler), this.handlersMap[t3] || (this.handlersMap[t3] = /* @__PURE__ */ new Set()), this.handlersMap[t3].add(e2);
+    }
+    _unsubscribe(t3, e2) {
+        this.handlersMap[t3] && e2 && this.handlersMap[t3].delete(e2), e2 && 0 !== this.handlersMap[t3].size || delete this.handlersMap[t3], 0 === Object.keys(this.handlersMap).length && this.eventTarget.removeEventListener("message", this.boundEventHandler);
+    }
+}
+
+function mx(t3 = "", e2 = 10) {
+    let i2 = "";
+    for (let t4 = 0; t4 < e2; t4++)
+        i2 += Math.floor(10 * Math.random());
+    return t3 + i2;
+}
+Receiver.receivers = [];
+class Sender {
+    constructor(t3) {
+        this.target = t3, this.handlers = /* @__PURE__ */ new Set();
+    }
+    removeMessageHandler(t3) {
+        t3.messageChannel && (t3.messageChannel.port1.removeEventListener("message", t3.onMessage), t3.messageChannel.port1.close()), this.handlers.delete(t3);
+    }
+    async _send(t3, e2, i2 = 50) {
+        const s2 = "undefined" != typeof MessageChannel ? new MessageChannel() : null;
+        if (!s2)
+            throw new Error("connection_unavailable");
+        let n2, r2;
+        return new Promise((o2, a2) => {
+            const l2 = mx("", 20);
+            s2.port1.start();
+            const h2 = setTimeout(() => {
+                a2(new Error("unsupported_event"));
+            }, i2);
+            r2 = {
+                messageChannel: s2,
+                onMessage(t4) {
+                    const e3 = t4;
+                    if (e3.data.eventId === l2)
+                        switch (e3.data.status) {
+                            case "ack":
+                                clearTimeout(h2), n2 = setTimeout(() => {
+                                    a2(new Error("timeout"));
+                                }, 3e3);
+                                break;
+                            case "done":
+                                clearTimeout(n2), o2(e3.data.response);
+                                break;
+                            default:
+                                clearTimeout(h2), clearTimeout(n2), a2(new Error("invalid_response"));
+                        }
+                }
+            }, this.handlers.add(r2), s2.port1.addEventListener("message", r2.onMessage), this.target.postMessage({
+                eventType: t3,
+                eventId: l2,
+                data: e2
+            }, [s2.port2]);
+        }).finally(() => {
+            r2 && this.removeMessageHandler(r2);
+        });
+    }
+}
+
+function gx() {
+    return window;
+}
+
+function yx() {
+    return void 0 !== gx().WorkerGlobalScope && "function" == typeof gx().importScripts;
+}
+const vx = "firebaseLocalStorageDb",
+    bx = "firebaseLocalStorage",
+    _x = "fbase_key";
+class DBPromise {
+    constructor(t3) {
+        this.request = t3;
+    }
+    toPromise() {
+        return new Promise((t3, e2) => {
+            this.request.addEventListener("success", () => {
+                t3(this.request.result);
+            }), this.request.addEventListener("error", () => {
+                e2(this.request.error);
+            });
+        });
+    }
+}
+
+function wx(t3, e2) {
+    return t3.transaction([bx], e2 ? "readwrite" : "readonly").objectStore(bx);
+}
+
+function xx() {
+    const t3 = indexedDB.open(vx, 1);
+    return new Promise((e2, i2) => {
+        t3.addEventListener("error", () => {
+            i2(t3.error);
+        }), t3.addEventListener("upgradeneeded", () => {
+            const e3 = t3.result;
+            try {
+                e3.createObjectStore(bx, {
+                    keyPath: _x
+                });
+            } catch (t4) {
+                i2(t4);
+            }
+        }), t3.addEventListener("success", async () => {
+            const i3 = t3.result;
+            i3.objectStoreNames.contains(bx) ? e2(i3) : (i3.close(), await
+                function() {
+                    const t4 = indexedDB.deleteDatabase(vx);
+                    return new DBPromise(t4).toPromise();
+                }(), e2(await xx()));
+        });
+    });
+}
+async function kx(t3, e2, i2) {
+    const s2 = wx(t3, true).put({
+        [_x]: e2,
+        value: i2
+    });
+    return new DBPromise(s2).toPromise();
+}
+
+function Tx(t3, e2) {
+    const i2 = wx(t3, true).delete(e2);
+    return new DBPromise(i2).toPromise();
+}
+class IndexedDBLocalPersistence {
+    constructor() {
+        this.type = "LOCAL", this._shouldAllowMigration = true, this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.pendingWrites = 0, this.receiver = null, this.sender = null, this.serviceWorkerReceiverAvailable = false, this.activeServiceWorker = null, this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then(() => {}, () => {});
+    }
+    async _openDb() {
+        return this.db || (this.db = await xx()), this.db;
+    }
+    async _withRetries(t3) {
+        let e2 = 0;
+        for (;;)
+            try {
+                const e3 = await this._openDb();
+                return await t3(e3);
+            } catch (t4) {
+                if (e2++ > 3)
+                    throw t4;
+                this.db && (this.db.close(), this.db = void 0);
+            }
+    }
+    async initializeServiceWorkerMessaging() {
+        return yx() ? this.initializeReceiver() : this.initializeSender();
+    }
+    async initializeReceiver() {
+        this.receiver = Receiver._getInstance(yx() ? self : null), this.receiver._subscribe("keyChanged", async (t3, e2) => ({
+            keyProcessed: (await this._poll()).includes(e2.key)
+        })), this.receiver._subscribe("ping", async (t3, e2) => ["keyChanged"]);
+    }
+    async initializeSender() {
+        var t3, e2;
+        if (this.activeServiceWorker = await async function() {
+                if (!(null === navigator || void 0 === navigator ? void 0 : navigator.serviceWorker))
+                    return null;
+                try {
+                    return (await navigator.serviceWorker.ready).active;
+                } catch (t4) {
+                    return null;
+                }
+            }(), !this.activeServiceWorker)
+            return;
+        this.sender = new Sender(this.activeServiceWorker);
+        const i2 = await this.sender._send("ping", {}, 800);
+        i2 && (null === (t3 = i2[0]) || void 0 === t3 ? void 0 : t3.fulfilled) && (null === (e2 = i2[0]) || void 0 === e2 ? void 0 : e2.value.includes("keyChanged")) && (this.serviceWorkerReceiverAvailable = true);
+    }
+    async notifyServiceWorker(t3) {
+        var e2;
+        if (this.sender && this.activeServiceWorker && ((null === (e2 = null === navigator || void 0 === navigator ? void 0 : navigator.serviceWorker) || void 0 === e2 ? void 0 : e2.controller) || null) === this.activeServiceWorker)
+            try {
+                await this.sender._send("keyChanged", {
+                    key: t3
+                }, this.serviceWorkerReceiverAvailable ? 800 : 50);
+            } catch (e3) {}
+    }
+    async _isAvailable() {
+        try {
+            if (!indexedDB)
+                return false;
+            const t3 = await xx();
+            return await kx(t3, dx, "1"), await Tx(t3, dx), true;
+        } catch (t3) {}
+        return false;
+    }
+    async _withPendingWrite(t3) {
+        this.pendingWrites++;
+        try {
+            await t3();
+        } finally {
+            this.pendingWrites--;
+        }
+    }
+    async _set(t3, e2) {
+        return this._withPendingWrite(async () => (await this._withRetries((i2) => kx(i2, t3, e2)), this.localCache[t3] = e2, this.notifyServiceWorker(t3)));
+    }
+    async _get(t3) {
+        const e2 = await this._withRetries((e3) => async function(t4, e4) {
+            const i2 = wx(t4, false).get(e4),
+                s2 = await new DBPromise(i2).toPromise();
+            return void 0 === s2 ? null : s2.value;
+        }(e3, t3));
+        return this.localCache[t3] = e2, e2;
+    }
+    async _remove(t3) {
+        return this._withPendingWrite(async () => (await this._withRetries((e2) => Tx(e2, t3)), delete this.localCache[t3], this.notifyServiceWorker(t3)));
+    }
+    async _poll() {
+        const t3 = await this._withRetries((t4) => {
+            const e3 = wx(t4, false).getAll();
+            return new DBPromise(e3).toPromise();
+        });
+        if (!t3)
+            return [];
+        if (0 !== this.pendingWrites)
+            return [];
+        const e2 = [],
+            i2 = /* @__PURE__ */ new Set();
+        for (const {
+                fbase_key: s2,
+                value: n2
+            }
+            of t3)
+            i2.add(s2), JSON.stringify(this.localCache[s2]) !== JSON.stringify(n2) && (this.notifyListeners(s2, n2), e2.push(s2));
+        for (const t4 of Object.keys(this.localCache))
+            this.localCache[t4] && !i2.has(t4) && (this.notifyListeners(t4, null), e2.push(t4));
+        return e2;
+    }
+    notifyListeners(t3, e2) {
+        this.localCache[t3] = e2;
+        const i2 = this.listeners[t3];
+        if (i2)
+            for (const t4 of Array.from(i2))
+                t4(e2);
+    }
+    startPolling() {
+        this.stopPolling(), this.pollTimer = setInterval(async () => this._poll(), 800);
+    }
+    stopPolling() {
+        this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null);
+    }
+    _addListener(t3, e2) {
+        0 === Object.keys(this.listeners).length && this.startPolling(), this.listeners[t3] || (this.listeners[t3] = /* @__PURE__ */ new Set(), this._get(t3)), this.listeners[t3].add(e2);
+    }
+    _removeListener(t3, e2) {
+        this.listeners[t3] && (this.listeners[t3].delete(e2), 0 === this.listeners[t3].size && delete this.listeners[t3]), 0 === Object.keys(this.listeners).length && this.stopPolling();
+    }
+}
+IndexedDBLocalPersistence.type = "LOCAL";
+const Sx = IndexedDBLocalPersistence;
+new Delay(3e4, 6e4);
+class IdpCredential extends AuthCredential {
+    constructor(t3) {
+        super("custom", "custom"), this.params = t3;
+    }
+    _getIdTokenResponse(t3) {
+        return hx(t3, this._buildIdpRequest());
+    }
+    _linkToIdToken(t3, e2) {
+        return hx(t3, this._buildIdpRequest(e2));
+    }
+    _getReauthenticationResolver(t3) {
+        return hx(t3, this._buildIdpRequest());
+    }
+    _buildIdpRequest(t3) {
+        const e2 = {
+            requestUri: this.params.requestUri,
+            sessionId: this.params.sessionId,
+            postBody: this.params.postBody,
+            tenantId: this.params.tenantId,
+            pendingToken: this.params.pendingToken,
+            returnSecureToken: true,
+            returnIdpCredential: true
+        };
+        return t3 && (e2.idToken = t3), e2;
+    }
+}
+
+function Ex(t3) {
+    return async function(t4, e2, i2 = false) {
+        const s2 = "signIn",
+            n2 = await ux(t4, s2, e2),
+            r2 = await UserCredentialImpl._fromIdTokenResponse(t4, s2, n2);
+        return i2 || await t4._updateCurrentUser(r2.user), r2;
+    }(t3.auth, new IdpCredential(t3), t3.bypassAuthState);
+}
+
+function Cx(t3) {
+    const {
+        auth: e2,
+        user: i2
+    } = t3;
+    return _w(i2, e2, "internal-error"), async function(t4, e3, i3 = false) {
+        const {
+            auth: s2
+        } = t4, n2 = "reauthenticate";
+        try {
+            const r2 = await Nw(t4, ux(s2, n2, e3, t4), i3);
+            _w(r2.idToken, s2, "internal-error");
+            const o2 = Fw(r2.idToken);
+            _w(o2, s2, "internal-error");
+            const {
+                sub: a2
+            } = o2;
+            return _w(t4.uid === a2, s2, "user-mismatch"), UserCredentialImpl._forOperation(t4, n2, r2);
+        } catch (t5) {
+            throw "auth/user-not-found" === (null == t5 ? void 0 : t5.code) && yw(s2, "user-mismatch"), t5;
+        }
+    }(i2, new IdpCredential(t3), t3.bypassAuthState);
+}
+async function Ix(t3) {
+    const {
+        auth: e2,
+        user: i2
+    } = t3;
+    return _w(i2, e2, "internal-error"), async function(t4, e3, i3 = false) {
+        const s2 = await Nw(t4, e3._linkToIdToken(t4.auth, await t4.getIdToken()), i3);
+        return UserCredentialImpl._forOperation(t4, "link", s2);
+    }(i2, new IdpCredential(t3), t3.bypassAuthState);
+}
+class AbstractPopupRedirectOperation {
+    constructor(t3, e2, i2, s2, n2 = false) {
+        this.auth = t3, this.resolver = i2, this.user = s2, this.bypassAuthState = n2, this.pendingPromise = null, this.eventManager = null, this.filter = Array.isArray(e2) ? e2 : [e2];
+    }
+    execute() {
+        return new Promise(async (t3, e2) => {
+            this.pendingPromise = {
+                resolve: t3,
+                reject: e2
+            };
+            try {
+                this.eventManager = await this.resolver._initialize(this.auth), await this.onExecution(), this.eventManager.registerConsumer(this);
+            } catch (t4) {
+                this.reject(t4);
+            }
+        });
+    }
+    async onAuthEvent(t3) {
+        const {
+            urlResponse: e2,
+            sessionId: i2,
+            postBody: s2,
+            tenantId: n2,
+            error: r2,
+            type: o2
+        } = t3;
+        if (r2)
+            return void this.reject(r2);
+        const a2 = {
+            auth: this.auth,
+            requestUri: e2,
+            sessionId: i2,
+            tenantId: n2 || void 0,
+            postBody: s2 || void 0,
+            user: this.user,
+            bypassAuthState: this.bypassAuthState
+        };
+        try {
+            this.resolve(await this.getIdpTask(o2)(a2));
+        } catch (t4) {
+            this.reject(t4);
+        }
+    }
+    onError(t3) {
+        this.reject(t3);
+    }
+    getIdpTask(t3) {
+        switch (t3) {
+            case "signInViaPopup":
+            case "signInViaRedirect":
+                return Ex;
+            case "linkViaPopup":
+            case "linkViaRedirect":
+                return Ix;
+            case "reauthViaPopup":
+            case "reauthViaRedirect":
+                return Cx;
+            default:
+                yw(this.auth, "internal-error");
+        }
+    }
+    resolve(t3) {
+        xw(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.resolve(t3), this.unregisterAndCleanUp();
+    }
+    reject(t3) {
+        xw(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.reject(t3), this.unregisterAndCleanUp();
+    }
+    unregisterAndCleanUp() {
+        this.eventManager && this.eventManager.unregisterConsumer(this), this.pendingPromise = null, this.cleanUp();
+    }
+}
+const Mx = new Delay(2e3, 1e4);
+class PopupOperation extends AbstractPopupRedirectOperation {
+    constructor(t3, e2, i2, s2, n2) {
+        super(t3, e2, s2, n2), this.provider = i2, this.authWindow = null, this.pollId = null, PopupOperation.currentPopupAction && PopupOperation.currentPopupAction.cancel(), PopupOperation.currentPopupAction = this;
+    }
+    async executeNotNull() {
+        const t3 = await this.execute();
+        return _w(t3, this.auth, "internal-error"), t3;
+    }
+    async onExecution() {
+        xw(1 === this.filter.length, "Popup operations only handle one event");
+        const t3 = mx();
+        this.authWindow = await this.resolver._openPopup(this.auth, this.provider, this.filter[0], t3), this.authWindow.associatedEvent = t3, this.resolver._originValidation(this.auth).catch((t4) => {
+            this.reject(t4);
+        }), this.resolver._isIframeWebStorageSupported(this.auth, (t4) => {
+            t4 || this.reject(vw(this.auth, "web-storage-unsupported"));
+        }), this.pollUserCancellation();
+    }
+    get eventId() {
+        var t3;
+        return (null === (t3 = this.authWindow) || void 0 === t3 ? void 0 : t3.associatedEvent) || null;
+    }
+    cancel() {
+        this.reject(vw(this.auth, "cancelled-popup-request"));
+    }
+    cleanUp() {
+        this.authWindow && this.authWindow.close(), this.pollId && window.clearTimeout(this.pollId), this.authWindow = null, this.pollId = null, PopupOperation.currentPopupAction = null;
+    }
+    pollUserCancellation() {
+        const t3 = () => {
+            var e2, i2;
+            (null === (i2 = null === (e2 = this.authWindow) || void 0 === e2 ? void 0 : e2.window) || void 0 === i2 ? void 0 : i2.closed) ? this.pollId = window.setTimeout(() => {
+                this.pollId = null, this.reject(vw(this.auth, "popup-closed-by-user"));
+            }, 8e3): this.pollId = window.setTimeout(t3, Mx.get());
+        };
+        t3();
+    }
+}
+PopupOperation.currentPopupAction = null;
+const Px = "pendingRedirect",
+    Rx = /* @__PURE__ */ new Map();
+class RedirectAction extends AbstractPopupRedirectOperation {
+    constructor(t3, e2, i2 = false) {
+        super(t3, ["signInViaRedirect", "linkViaRedirect", "reauthViaRedirect", "unknown"], e2, void 0, i2), this.eventId = null;
+    }
+    async execute() {
+        let t3 = Rx.get(this.auth._key());
+        if (!t3) {
+            try {
+                const e2 = await async function(t4, e3) {
+                    const i3 = function(t5) {
+                            return jw(Px, t5.config.apiKey, t5.name);
+                        }(e3),
+                        s2 = function(t5) {
+                            return Bw(t5._redirectPersistence);
+                        }(t4);
+                    if (!await s2._isAvailable())
+                        return false;
+                    const n2 = "true" === await s2._get(i3);
+                    return await s2._remove(i3), n2;
+                }(this.resolver, this.auth), i2 = e2 ? await super.execute() : null;
+                t3 = () => Promise.resolve(i2);
+            } catch (e2) {
+                t3 = () => Promise.reject(e2);
+            }
+            Rx.set(this.auth._key(), t3);
+        }
+        return this.bypassAuthState || Rx.set(this.auth._key(), () => Promise.resolve(null)), t3();
+    }
+    async onAuthEvent(t3) {
+        if ("signInViaRedirect" === t3.type)
+            return super.onAuthEvent(t3);
+        if ("unknown" !== t3.type) {
+            if (t3.eventId) {
+                const e2 = await this.auth._redirectUserForId(t3.eventId);
+                if (e2)
+                    return this.user = e2, super.onAuthEvent(t3);
+                this.resolve(null);
+            }
+        } else
+            this.resolve(null);
+    }
+    async onExecution() {}
+    cleanUp() {}
+}
+
+function Ax(t3, e2) {
+    Rx.set(t3._key(), e2);
+}
+async function Dx(t3, e2, i2 = false) {
+    const s2 = rx(t3),
+        n2 = function(t4, e3) {
+            return e3 ? Bw(e3) : (_w(t4._popupRedirectResolver, t4, "argument-error"), t4._popupRedirectResolver);
+        }(s2, e2),
+        r2 = new RedirectAction(s2, n2, i2),
+        o2 = await r2.execute();
+    return o2 && !i2 && (delete o2.user._redirectEventId, await s2._persistUserIfCurrent(o2.user), await s2._setRedirectUser(null, e2)), o2;
+}
+class AuthEventManager {
+    constructor(t3) {
+        this.auth = t3, this.cachedEventUids = /* @__PURE__ */ new Set(), this.consumers = /* @__PURE__ */ new Set(), this.queuedRedirectEvent = null, this.hasHandledPotentialRedirect = false, this.lastProcessedEventTime = Date.now();
+    }
+    registerConsumer(t3) {
+        this.consumers.add(t3), this.queuedRedirectEvent && this.isEventForConsumer(this.queuedRedirectEvent, t3) && (this.sendToConsumer(this.queuedRedirectEvent, t3), this.saveEventToCache(this.queuedRedirectEvent), this.queuedRedirectEvent = null);
+    }
+    unregisterConsumer(t3) {
+        this.consumers.delete(t3);
+    }
+    onEvent(t3) {
+        if (this.hasEventBeenHandled(t3))
+            return false;
+        let e2 = false;
+        return this.consumers.forEach((i2) => {
+            this.isEventForConsumer(t3, i2) && (e2 = true, this.sendToConsumer(t3, i2), this.saveEventToCache(t3));
+        }), this.hasHandledPotentialRedirect || ! function(t4) {
+            switch (t4.type) {
+                case "signInViaRedirect":
+                case "linkViaRedirect":
+                case "reauthViaRedirect":
+                    return true;
+                case "unknown":
+                    return Ox(t4);
+                default:
+                    return false;
+            }
+        }(t3) || (this.hasHandledPotentialRedirect = true, e2 || (this.queuedRedirectEvent = t3, e2 = true)), e2;
+    }
+    sendToConsumer(t3, e2) {
+        var i2;
+        if (t3.error && !Ox(t3)) {
+            const s2 = (null === (i2 = t3.error.code) || void 0 === i2 ? void 0 : i2.split("auth/")[1]) || "internal-error";
+            e2.onError(vw(this.auth, s2));
+        } else
+            e2.onAuthEvent(t3);
+    }
+    isEventForConsumer(t3, e2) {
+        const i2 = null === e2.eventId || !!t3.eventId && t3.eventId === e2.eventId;
+        return e2.filter.includes(t3.type) && i2;
+    }
+    hasEventBeenHandled(t3) {
+        return Date.now() - this.lastProcessedEventTime >= 6e5 && this.cachedEventUids.clear(), this.cachedEventUids.has(Lx(t3));
+    }
+    saveEventToCache(t3) {
+        this.cachedEventUids.add(Lx(t3)), this.lastProcessedEventTime = Date.now();
+    }
+}
+
+function Lx(t3) {
+    return [t3.type, t3.eventId, t3.sessionId, t3.tenantId].filter((t4) => t4).join("-");
+}
+
+function Ox({
+    type: t3,
+    error: e2
+}) {
+    return "unknown" === t3 && "auth/no-auth-event" === (null == e2 ? void 0 : e2.code);
+}
+const Fx = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/,
+    Nx = /^https?/;
+async function $x(t3) {
+    if (t3.config.emulator)
+        return;
+    const {
+        authorizedDomains: e2
+    } = await async function(t4, e3 = {}) {
+        return Pw(t4, "GET", "/v1/projects", e3);
+    }(t3);
+    for (const t4 of e2)
+        try {
+            if (Vx(t4))
+                return;
+        } catch (t5) {}
+    yw(t3, "unauthorized-domain");
+}
+
+function Vx(t3) {
+    const e2 = kw(),
+        {
+            protocol: i2,
+            hostname: s2
+        } = new URL(e2);
+    if (t3.startsWith("chrome-extension://")) {
+        const n3 = new URL(t3);
+        return "" === n3.hostname && "" === s2 ? "chrome-extension:" === i2 && t3.replace("chrome-extension://", "") === e2.replace("chrome-extension://", "") : "chrome-extension:" === i2 && n3.hostname === s2;
+    }
+    if (!Nx.test(i2))
+        return false;
+    if (Fx.test(t3))
+        return s2 === t3;
+    const n2 = t3.replace(/\./g, "\\.");
+    return new RegExp("^(.+\\." + n2 + "|" + n2 + ")$", "i").test(s2);
+}
+const zx = new Delay(3e4, 6e4);
+
+function Bx() {
+    const t3 = gx().___jsl;
+    if (null == t3 ? void 0 : t3.H) {
+        for (const e2 of Object.keys(t3.H))
+            if (t3.H[e2].r = t3.H[e2].r || [], t3.H[e2].L = t3.H[e2].L || [], t3.H[e2].r = [...t3.H[e2].L], t3.CP)
+                for (let e3 = 0; e3 < t3.CP.length; e3++)
+                    t3.CP[e3] = null;
+    }
+}
+
+function Ux(t3) {
+    return new Promise((e2, i2) => {
+        var s2, n2, r2;
+
+        function o2() {
+            Bx(), gapi.load("gapi.iframes", {
+                callback: () => {
+                    e2(gapi.iframes.getContext());
+                },
+                ontimeout: () => {
+                    Bx(), i2(vw(t3, "network-request-failed"));
+                },
+                timeout: zx.get()
+            });
+        }
+        if (null === (n2 = null === (s2 = gx().gapi) || void 0 === s2 ? void 0 : s2.iframes) || void 0 === n2 ? void 0 : n2.Iframe)
+            e2(gapi.iframes.getContext());
+        else {
+            if (!(null === (r2 = gx().gapi) || void 0 === r2 ? void 0 : r2.load)) {
+                const e3 = `__${"iframefcb"}${Math.floor(1e6 * Math.random())}`;
+                return gx()[e3] = () => {
+                    gapi.load ? o2() : i2(vw(t3, "network-request-failed"));
+                }, nx(`https://apis.google.com/js/api.js?onload=${e3}`).catch((t4) => i2(t4));
+            }
+            o2();
+        }
+    }).catch((t4) => {
+        throw jx = null, t4;
+    });
+}
+let jx = null;
+const Hx = new Delay(5e3, 15e3),
+    Wx = "__/auth/iframe",
+    qx = "emulator/auth/iframe",
+    Kx = {
+        style: {
+            position: "absolute",
+            top: "-100px",
+            width: "1px",
+            height: "1px"
+        },
+        "aria-hidden": "true",
+        tabindex: "-1"
+    },
+    Gx = /* @__PURE__ */ new Map([
+        ["identitytoolkit.googleapis.com", "p"],
+        ["staging-identitytoolkit.sandbox.googleapis.com", "s"],
+        ["test-identitytoolkit.sandbox.googleapis.com", "t"]
+    ]);
+
+function Yx(t3) {
+    const e2 = t3.config;
+    _w(e2.authDomain, t3, "auth-domain-config-required");
+    const i2 = e2.emulator ? Ew(e2, qx) : `https://${t3.config.authDomain}/${Wx}`,
+        s2 = {
+            apiKey: e2.apiKey,
+            appName: t3.name,
+            v: uf
+        },
+        n2 = Gx.get(t3.config.apiHost);
+    n2 && (s2.eid = n2);
+    const r2 = t3._getFrameworks();
+    return r2.length && (s2.fw = r2.join(",")), `${i2}?${Cd(s2).slice(1)}`;
+}
+async function Qx(t3) {
+    const e2 = await
+    function(t4) {
+        return jx = jx || Ux(t4), jx;
+    }(t3), i2 = gx().gapi;
+    return _w(i2, t3, "internal-error"), e2.open({
+        where: document.body,
+        url: Yx(t3),
+        messageHandlersFilter: i2.iframes.CROSS_ORIGIN_IFRAMES_FILTER,
+        attributes: Kx,
+        dontclear: true
+    }, (e3) => new Promise(async (i3, s2) => {
+        await e3.restyle({
+            setHideOnLeave: false
+        });
+        const n2 = vw(t3, "network-request-failed"),
+            r2 = gx().setTimeout(() => {
+                s2(n2);
+            }, Hx.get());
+
+        function o2() {
+            gx().clearTimeout(r2), i3(e3);
+        }
+        e3.ping(o2).then(o2, () => {
+            s2(n2);
+        });
+    }));
+}
+const Xx = {
+    location: "yes",
+    resizable: "yes",
+    statusbar: "yes",
+    toolbar: "no"
+};
+class AuthPopup {
+    constructor(t3) {
+        this.window = t3, this.associatedEvent = null;
+    }
+    close() {
+        if (this.window)
+            try {
+                this.window.close();
+            } catch (t3) {}
+    }
+}
+
+function Jx(t3, e2, i2, s2 = 500, n2 = 600) {
+    const r2 = Math.max((window.screen.availHeight - n2) / 2, 0).toString(),
+        o2 = Math.max((window.screen.availWidth - s2) / 2, 0).toString();
+    let a2 = "";
+    const l2 = Object.assign(Object.assign({}, Xx), {
+            width: s2.toString(),
+            height: n2.toString(),
+            top: r2,
+            left: o2
+        }),
+        h2 = kd().toLowerCase();
+    i2 && (a2 = Kw(h2) ? "_blank" : i2), Ww(h2) && (e2 = e2 || "http://localhost", l2.scrollbars = "yes");
+    const c2 = Object.entries(l2).reduce((t4, [e3, i3]) => `${t4}${e3}=${i3},`, "");
+    if (function(t4 = kd()) {
+            var e3;
+            return Jw(t4) && !!(null === (e3 = window.navigator) || void 0 === e3 ? void 0 : e3.standalone);
+        }(h2) && "_self" !== a2)
+        return function(t4, e3) {
+            const i3 = document.createElement("a");
+            i3.href = t4, i3.target = e3;
+            const s3 = document.createEvent("MouseEvent");
+            s3.initMouseEvent("click", true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 1, null), i3.dispatchEvent(s3);
+        }(e2 || "", a2), new AuthPopup(null);
+    const u2 = window.open(e2 || "", a2, c2);
+    _w(u2, t3, "popup-blocked");
+    try {
+        u2.focus();
+    } catch (t4) {}
+    return new AuthPopup(u2);
+}
+const Zx = "__/auth/handler",
+    tk = "emulator/auth/handler",
+    ek = encodeURIComponent("fac");
+async function ik(t3, e2, i2, s2, n2, r2) {
+    _w(t3.config.authDomain, t3, "auth-domain-config-required"), _w(t3.config.apiKey, t3, "invalid-api-key");
+    const o2 = {
+        apiKey: t3.config.apiKey,
+        appName: t3.name,
+        authType: i2,
+        redirectUrl: s2,
+        v: uf,
+        eventId: n2
+    };
+    if (e2 instanceof FederatedAuthProvider) {
+        e2.setDefaultLanguage(t3.languageCode), o2.providerId = e2.providerId || "",
+            function(t4) {
+                for (const e3 in t4)
+                    if (Object.prototype.hasOwnProperty.call(t4, e3))
+                        return false;
+                return true;
+            }(e2.getCustomParameters()) || (o2.customParameters = JSON.stringify(e2.getCustomParameters()));
+        for (const [t4, e3] of Object.entries(r2 || {}))
+            o2[t4] = e3;
+    }
+    if (e2 instanceof BaseOAuthProvider) {
+        const t4 = e2.getScopes().filter((t5) => "" !== t5);
+        t4.length > 0 && (o2.scopes = t4.join(","));
+    }
+    t3.tenantId && (o2.tid = t3.tenantId);
+    const a2 = o2;
+    for (const t4 of Object.keys(a2))
+        void 0 === a2[t4] && delete a2[t4];
+    const l2 = await t3._getAppCheckToken(),
+        h2 = l2 ? `#${ek}=${encodeURIComponent(l2)}` : "";
+    return `${function({ config: t4 }) {
+    if (!t4.emulator)
+      return `
+    https: //${t4.authDomain}/${Zx}`;
+        return Ew(t4, tk);
+}(t3)
+} ? $ {
+    Cd(a2).slice(1)
+}
+$ {
+    h2
+}
+`;
+}
+const sk = "webStorageSupport";
+const nk = class BrowserPopupRedirectResolver {
+  constructor() {
+    this.eventManagers = {}, this.iframes = {}, this.originValidationPromises = {}, this._redirectPersistence = px, this._completeRedirectFn = Dx, this._overrideRedirectResult = Ax;
+  }
+  async _openPopup(t3, e2, i2, s2) {
+    var n2;
+    xw(null === (n2 = this.eventManagers[t3._key()]) || void 0 === n2 ? void 0 : n2.manager, "_initialize() not called before _openPopup()");
+    return Jx(t3, await ik(t3, e2, i2, kw(), s2), mx());
+  }
+  async _openRedirect(t3, e2, i2, s2) {
+    await this._originValidation(t3);
+    return function(t4) {
+      gx().location.href = t4;
+    }(await ik(t3, e2, i2, kw(), s2)), new Promise(() => {
+    });
+  }
+  _initialize(t3) {
+    const e2 = t3._key();
+    if (this.eventManagers[e2]) {
+      const { manager: t4, promise: i3 } = this.eventManagers[e2];
+      return t4 ? Promise.resolve(t4) : (xw(i3, "If manager is not set, promise should be"), i3);
+    }
+    const i2 = this.initAndGetManager(t3);
+    return this.eventManagers[e2] = { promise: i2 }, i2.catch(() => {
+      delete this.eventManagers[e2];
+    }), i2;
+  }
+  async initAndGetManager(t3) {
+    const e2 = await Qx(t3), i2 = new AuthEventManager(t3);
+    return e2.register("authEvent", (e3) => {
+      _w(null == e3 ? void 0 : e3.authEvent, t3, "invalid-auth-event");
+      return { status: i2.onEvent(e3.authEvent) ? "ACK" : "ERROR" };
+    }, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER), this.eventManagers[t3._key()] = { manager: i2 }, this.iframes[t3._key()] = e2, i2;
+  }
+  _isIframeWebStorageSupported(t3, e2) {
+    this.iframes[t3._key()].send(sk, { type: sk }, (i2) => {
+      var s2;
+      const n2 = null === (s2 = null == i2 ? void 0 : i2[0]) || void 0 === s2 ? void 0 : s2[sk];
+      void 0 !== n2 && e2(!!n2), yw(t3, "internal-error");
+    }, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER);
+  }
+  _originValidation(t3) {
+    const e2 = t3._key();
+    return this.originValidationPromises[e2] || (this.originValidationPromises[e2] = $x(t3)), this.originValidationPromises[e2];
+  }
+  get _shouldInitProactively() {
+    return tx() || qw() || Jw();
+  }
+};
+var rk = "@firebase/auth", ok = "1.0.0";
+class AuthInterop {
+  constructor(t3) {
+    this.auth = t3, this.internalListeners = /* @__PURE__ */ new Map();
+  }
+  getUid() {
+    var t3;
+    return this.assertAuthConfigured(), (null === (t3 = this.auth.currentUser) || void 0 === t3 ? void 0 : t3.uid) || null;
+  }
+  async getToken(t3) {
+    if (this.assertAuthConfigured(), await this.auth._initializationPromise, !this.auth.currentUser)
+      return null;
+    return { accessToken: await this.auth.currentUser.getIdToken(t3) };
+  }
+  addAuthTokenListener(t3) {
+    if (this.assertAuthConfigured(), this.internalListeners.has(t3))
+      return;
+    const e2 = this.auth.onIdTokenChanged((e3) => {
+      t3((null == e3 ? void 0 : e3.stsTokenManager.accessToken) || null);
+    });
+    this.internalListeners.set(t3, e2), this.updateProactiveRefresh();
+  }
+  removeAuthTokenListener(t3) {
+    this.assertAuthConfigured();
+    const e2 = this.internalListeners.get(t3);
+    e2 && (this.internalListeners.delete(t3), e2(), this.updateProactiveRefresh());
+  }
+  assertAuthConfigured() {
+    _w(this.auth._initializationPromise, "dependent-sdk-initialized-before-auth");
+  }
+  updateProactiveRefresh() {
+    this.internalListeners.size > 0 ? this.auth._startProactiveRefresh() : this.auth._stopProactiveRefresh();
+  }
+}
+const ak = wd("authIdTokenMaxAge") || 300;
+let lk = null;
+var hk;
+hk = "Browser", lf(new Component("auth", (t3, { options: e2 }) => {
+  const i2 = t3.getProvider("app").getImmediate(), s2 = t3.getProvider("heartbeat"), n2 = t3.getProvider("app-check-internal"), { apiKey: r2, authDomain: o2 } = i2.options;
+  _w(r2 && !r2.includes(":"), "invalid-api-key", { appName: i2.name });
+  const a2 = { apiKey: r2, authDomain: o2, clientPlatform: hk, apiHost: "identitytoolkit.googleapis.com", tokenApiHost: "securetoken.googleapis.com", apiScheme: "https", sdkClientVersion: ex(hk) }, l2 = new AuthImpl(i2, s2, n2, a2);
+  return function(t4, e3) {
+    const i3 = (null == e3 ? void 0 : e3.persistence) || [], s3 = (Array.isArray(i3) ? i3 : [i3]).map(Bw);
+    (null == e3 ? void 0 : e3.errorMap) && t4._updateErrorMap(e3.errorMap), t4._initializeWithPersistence(s3, null == e3 ? void 0 : e3.popupRedirectResolver);
+  }(l2, e2), l2;
+}, "PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback((t3, e2, i2) => {
+  t3.getProvider("auth-internal").initialize();
+})), lf(new Component("auth-internal", (t3) => ((t4) => new AuthInterop(t4))(rx(t3.getProvider("auth").getImmediate())), "PRIVATE").setInstantiationMode("EXPLICIT")), pf(rk, ok, function(t3) {
+  switch (t3) {
+    case "Node":
+      return "node";
+    case "ReactNative":
+      return "rn";
+    case "Worker":
+      return "webworker";
+    case "Cordova":
+      return "cordova";
+    default:
+      return;
+  }
+}(hk)), pf(rk, ok, "esm2017");
+const ck = "firebasestorage.googleapis.com";
+class StorageError extends FirebaseError {
+  constructor(t3, e2, i2 = 0) {
+    super(fk(t3), `
+Firebase Storage: $ {
+    e2
+}($ {
+    fk(t3)
+})`), this.status_ = i2, this.customData = { serverResponse: null }, this._baseMessage = this.message, Object.setPrototypeOf(this, StorageError.prototype);
+  }
+  get status() {
+    return this.status_;
+  }
+  set status(t3) {
+    this.status_ = t3;
+  }
+  _codeEquals(t3) {
+    return fk(t3) === this.code;
+  }
+  get serverResponse() {
+    return this.customData.serverResponse;
+  }
+  set serverResponse(t3) {
+    this.customData.serverResponse = t3, this.customData.serverResponse ? this.message = `
+$ {
+    this._baseMessage
+}
+$ {
+    this.customData.serverResponse
+}
+` : this.message = this._baseMessage;
+  }
+}
+var uk, dk;
+function fk(t3) {
+  return "storage/" + t3;
+}
+function pk(t3) {
+  return new StorageError(uk.INVALID_ARGUMENT, t3);
+}
+function mk() {
+  return new StorageError(uk.APP_DELETED, "The Firebase app was deleted.");
+}
+!function(t3) {
+  t3.UNKNOWN = "unknown", t3.OBJECT_NOT_FOUND = "object-not-found", t3.BUCKET_NOT_FOUND = "bucket-not-found", t3.PROJECT_NOT_FOUND = "project-not-found", t3.QUOTA_EXCEEDED = "quota-exceeded", t3.UNAUTHENTICATED = "unauthenticated", t3.UNAUTHORIZED = "unauthorized", t3.UNAUTHORIZED_APP = "unauthorized-app", t3.RETRY_LIMIT_EXCEEDED = "retry-limit-exceeded", t3.INVALID_CHECKSUM = "invalid-checksum", t3.CANCELED = "canceled", t3.INVALID_EVENT_NAME = "invalid-event-name", t3.INVALID_URL = "invalid-url", t3.INVALID_DEFAULT_BUCKET = "invalid-default-bucket", t3.NO_DEFAULT_BUCKET = "no-default-bucket", t3.CANNOT_SLICE_BLOB = "cannot-slice-blob", t3.SERVER_FILE_WRONG_SIZE = "server-file-wrong-size", t3.NO_DOWNLOAD_URL = "no-download-url", t3.INVALID_ARGUMENT = "invalid-argument", t3.INVALID_ARGUMENT_COUNT = "invalid-argument-count", t3.APP_DELETED = "app-deleted", t3.INVALID_ROOT_OPERATION = "invalid-root-operation", t3.INVALID_FORMAT = "invalid-format", t3.INTERNAL_ERROR = "internal-error", t3.UNSUPPORTED_ENVIRONMENT = "unsupported-environment";
+}(uk || (uk = {}));
+class Location {
+  constructor(t3, e2) {
+    this.bucket = t3, this.path_ = e2;
+  }
+  get path() {
+    return this.path_;
+  }
+  get isRoot() {
+    return 0 === this.path.length;
+  }
+  fullServerUrl() {
+    const t3 = encodeURIComponent;
+    return "/b/" + t3(this.bucket) + "/o/" + t3(this.path);
+  }
+  bucketOnlyServerUrl() {
+    return "/b/" + encodeURIComponent(this.bucket) + "/o";
+  }
+  static makeFromBucketSpec(t3, e2) {
+    let i2;
+    try {
+      i2 = Location.makeFromUrl(t3, e2);
+    } catch (e3) {
+      return new Location(t3, "");
+    }
+    if ("" === i2.path)
+      return i2;
+    throw s2 = t3, new StorageError(uk.INVALID_DEFAULT_BUCKET, "Invalid default bucket '" + s2 + "'.");
+    var s2;
+  }
+  static makeFromUrl(t3, e2) {
+    let i2 = null;
+    const s2 = "([A-Za-z0-9.\\-_]+)";
+    const n2 = new RegExp("^gs://" + s2 + "(/(.*))?$", "i");
+    function r2(t4) {
+      t4.path_ = decodeURIComponent(t4.path);
+    }
+    const o2 = e2.replace(/[.]/g, "\\."), a2 = [{ regex: n2, indices: { bucket: 1, path: 3 }, postModify: function(t4) {
+      "/" === t4.path.charAt(t4.path.length - 1) && (t4.path_ = t4.path_.slice(0, -1));
+    } }, { regex: new RegExp(` ^ https ? : //${o2}/v[A-Za-z0-9_]+/b/${s2}/o(/([^?#]*).*)?$`, "i"), indices: { bucket: 1, path: 3 }, postModify: r2 }, { regex: new RegExp(`^https?://${e2 === ck ? "(?:storage.googleapis.com|storage.cloud.google.com)" : e2}/${s2}/([^?#]*)`, "i"), indices: { bucket: 1, path: 2 }, postModify: r2 }];
+    for (let e3 = 0; e3 < a2.length; e3++) {
+        const s3 = a2[e3],
+            n3 = s3.regex.exec(t3);
+        if (n3) {
+            const t4 = n3[s3.indices.bucket];
+            let e4 = n3[s3.indices.path];
+            e4 || (e4 = ""), i2 = new Location(t4, e4), s3.postModify(i2);
+            break;
+        }
+    }
+if (null == i2)
+    throw function(t4) {
+        return new StorageError(uk.INVALID_URL, "Invalid URL '" + t4 + "'.");
+    }(t3);
+return i2;
+}
+}
+class FailRequest {
+    constructor(t3) {
+        this.promise_ = Promise.reject(t3);
+    }
+    getPromise() {
+        return this.promise_;
+    }
+    cancel(t3 = false) {}
+}
+
+function gk(t3, e2, i2, s2) {
+    if (s2 < e2)
+        throw pk(`Invalid value for '${t3}'. Expected ${e2} or greater.`);
+    if (s2 > i2)
+        throw pk(`Invalid value for '${t3}'. Expected ${i2} or less.`);
+}! function(t3) {
+    t3[t3.NO_ERROR = 0] = "NO_ERROR", t3[t3.NETWORK_ERROR = 1] = "NETWORK_ERROR", t3[t3.ABORT = 2] = "ABORT";
+}(dk || (dk = {}));
+class NetworkRequest {
+    constructor(t3, e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2 = true) {
+        this.url_ = t3, this.method_ = e2, this.headers_ = i2, this.body_ = s2, this.successCodes_ = n2, this.additionalRetryCodes_ = r2, this.callback_ = o2, this.errorCallback_ = a2, this.timeout_ = l2, this.progressCallback_ = h2, this.connectionFactory_ = c2, this.retry = u2, this.pendingConnection_ = null, this.backoffId_ = null, this.canceled_ = false, this.appDelete_ = false, this.promise_ = new Promise((t4, e3) => {
+            this.resolve_ = t4, this.reject_ = e3, this.start_();
+        });
+    }
+    start_() {
+        const t3 = (t4, e3) => {
+                if (e3)
+                    return void t4(false, new RequestEndStatus(false, null, true));
+                const i2 = this.connectionFactory_();
+                this.pendingConnection_ = i2;
+                const s2 = (t5) => {
+                    const e4 = t5.loaded,
+                        i3 = t5.lengthComputable ? t5.total : -1;
+                    null !== this.progressCallback_ && this.progressCallback_(e4, i3);
+                };
+                null !== this.progressCallback_ && i2.addUploadProgressListener(s2), i2.send(this.url_, this.method_, this.body_, this.headers_).then(() => {
+                    null !== this.progressCallback_ && i2.removeUploadProgressListener(s2), this.pendingConnection_ = null;
+                    const e4 = i2.getErrorCode() === dk.NO_ERROR,
+                        n2 = i2.getStatus();
+                    if (!e4 || function(t5, e5) {
+                            const i3 = t5 >= 500 && t5 < 600,
+                                s3 = -1 !== [408, 429].indexOf(t5),
+                                n3 = -1 !== e5.indexOf(t5);
+                            return i3 || s3 || n3;
+                        }(n2, this.additionalRetryCodes_) && this.retry) {
+                        const e5 = i2.getErrorCode() === dk.ABORT;
+                        return void t4(false, new RequestEndStatus(false, null, e5));
+                    }
+                    const r2 = -1 !== this.successCodes_.indexOf(n2);
+                    t4(true, new RequestEndStatus(r2, i2));
+                });
+            },
+            e2 = (t4, e3) => {
+                const i2 = this.resolve_,
+                    s2 = this.reject_,
+                    n2 = e3.connection;
+                if (e3.wasSuccessCode)
+                    try {
+                        const t5 = this.callback_(n2, n2.getResponse());
+                        ! function(t6) {
+                            return void 0 !== t6;
+                        }(t5) ? i2(): i2(t5);
+                    } catch (t5) {
+                        s2(t5);
+                    }
+                else if (null !== n2) {
+                    const t5 = new StorageError(uk.UNKNOWN, "An unknown error occurred, please check the error payload for server response.");
+                    t5.serverResponse = n2.getErrorText(), this.errorCallback_ ? s2(this.errorCallback_(n2, t5)) : s2(t5);
+                } else if (e3.canceled) {
+                    s2(this.appDelete_ ? mk() : new StorageError(uk.CANCELED, "User canceled the upload/download."));
+                } else {
+                    s2(new StorageError(uk.RETRY_LIMIT_EXCEEDED, "Max retry time for operation exceeded, please try again."));
+                }
+            };
+        this.canceled_ ? e2(0, new RequestEndStatus(false, null, true)) : this.backoffId_ = function(t4, e3, i2) {
+            let s2 = 1,
+                n2 = null,
+                r2 = null,
+                o2 = false,
+                a2 = 0;
+
+            function l2() {
+                return 2 === a2;
+            }
+            let h2 = false;
+
+            function c2(...t5) {
+                h2 || (h2 = true, e3.apply(null, t5));
+            }
+
+            function u2(e4) {
+                n2 = setTimeout(() => {
+                    n2 = null, t4(f2, l2());
+                }, e4);
+            }
+
+            function d2() {
+                r2 && clearTimeout(r2);
+            }
+
+            function f2(t5, ...e4) {
+                if (h2)
+                    return void d2();
+                if (t5)
+                    return d2(), void c2.call(null, t5, ...e4);
+                if (l2() || o2)
+                    return d2(), void c2.call(null, t5, ...e4);
+                let i3;
+                s2 < 64 && (s2 *= 2), 1 === a2 ? (a2 = 2, i3 = 0) : i3 = 1e3 * (s2 + Math.random()), u2(i3);
+            }
+            let p2 = false;
+
+            function m2(t5) {
+                p2 || (p2 = true, d2(), h2 || (null !== n2 ? (t5 || (a2 = 2), clearTimeout(n2), u2(0)) : t5 || (a2 = 1)));
+            }
+            return u2(0), r2 = setTimeout(() => {
+                o2 = true, m2(true);
+            }, i2), m2;
+        }(t3, e2, this.timeout_);
+    }
+    getPromise() {
+        return this.promise_;
+    }
+    cancel(t3) {
+        this.canceled_ = true, this.appDelete_ = t3 || false, null !== this.backoffId_ && function(t4) {
+            t4(false);
+        }(this.backoffId_), null !== this.pendingConnection_ && this.pendingConnection_.abort();
+    }
+}
+class RequestEndStatus {
+    constructor(t3, e2, i2) {
+        this.wasSuccessCode = t3, this.connection = e2, this.canceled = !!i2;
+    }
+}
+
+function yk(t3, e2, i2, s2, n2, r2, o2 = true) {
+    const a2 = function(t4) {
+            const e3 = encodeURIComponent;
+            let i3 = "?";
+            for (const s3 in t4)
+                t4.hasOwnProperty(s3) && (i3 = i3 + (e3(s3) + "=") + e3(t4[s3]) + "&");
+            return i3 = i3.slice(0, -1), i3;
+        }(t3.urlParams),
+        l2 = t3.url + a2,
+        h2 = Object.assign({}, t3.headers);
+    return function(t4, e3) {
+            e3 && (t4["X-Firebase-GMPID"] = e3);
+        }(h2, e2),
+        function(t4, e3) {
+            null !== e3 && e3.length > 0 && (t4.Authorization = "Firebase " + e3);
+        }(h2, i2),
+        function(t4, e3) {
+            t4["X-Firebase-Storage-Version"] = "webjs/" + (null != e3 ? e3 : "AppManager");
+        }(h2, r2),
+        function(t4, e3) {
+            null !== e3 && (t4["X-Firebase-AppCheck"] = e3);
+        }(h2, s2), new NetworkRequest(l2, t3.method, h2, t3.body, t3.successCodes, t3.additionalRetryCodes, t3.handler, t3.errorHandler, t3.timeout, t3.progressCallback, n2, o2);
+}
+class Reference {
+    constructor(t3, e2) {
+        this._service = t3, this._location = e2 instanceof Location ? e2 : Location.makeFromUrl(e2, t3.host);
+    }
+    toString() {
+        return "gs://" + this._location.bucket + "/" + this._location.path;
+    }
+    _newRef(t3, e2) {
+        return new Reference(t3, e2);
+    }
+    get root() {
+        const t3 = new Location(this._location.bucket, "");
+        return this._newRef(this._service, t3);
+    }
+    get bucket() {
+        return this._location.bucket;
+    }
+    get fullPath() {
+        return this._location.path;
+    }
+    get name() {
+        return function(t3) {
+            const e2 = t3.lastIndexOf("/", t3.length - 2);
+            return -1 === e2 ? t3 : t3.slice(e2 + 1);
+        }(this._location.path);
+    }
+    get storage() {
+        return this._service;
+    }
+    get parent() {
+        const t3 = function(t4) {
+            if (0 === t4.length)
+                return null;
+            const e3 = t4.lastIndexOf("/");
+            return -1 === e3 ? "" : t4.slice(0, e3);
+        }(this._location.path);
+        if (null === t3)
+            return null;
+        const e2 = new Location(this._location.bucket, t3);
+        return new Reference(this._service, e2);
+    }
+    _throwIfRoot(t3) {
+        if ("" === this._location.path)
+            throw function(t4) {
+                return new StorageError(uk.INVALID_ROOT_OPERATION, "The operation '" + t4 + "' cannot be performed on a root reference, create a non-root reference using child, such as .child('file.png').");
+            }(t3);
+    }
+}
+
+function vk(t3, e2) {
+    const i2 = null == e2 ? void 0 : e2.storageBucket;
+    return null == i2 ? null : Location.makeFromBucketSpec(i2, t3);
+}
+class FirebaseStorageImpl {
+    constructor(t3, e2, i2, s2, n2) {
+        this.app = t3, this._authProvider = e2, this._appCheckProvider = i2, this._url = s2, this._firebaseVersion = n2, this._bucket = null, this._host = ck, this._protocol = "https", this._appId = null, this._deleted = false, this._maxOperationRetryTime = 12e4, this._maxUploadRetryTime = 6e5, this._requests = /* @__PURE__ */ new Set(), this._bucket = null != s2 ? Location.makeFromBucketSpec(s2, this._host) : vk(this._host, this.app.options);
+    }
+    get host() {
+        return this._host;
+    }
+    set host(t3) {
+        this._host = t3, null != this._url ? this._bucket = Location.makeFromBucketSpec(this._url, t3) : this._bucket = vk(t3, this.app.options);
+    }
+    get maxUploadRetryTime() {
+        return this._maxUploadRetryTime;
+    }
+    set maxUploadRetryTime(t3) {
+        gk("time", 0, Number.POSITIVE_INFINITY, t3), this._maxUploadRetryTime = t3;
+    }
+    get maxOperationRetryTime() {
+        return this._maxOperationRetryTime;
+    }
+    set maxOperationRetryTime(t3) {
+        gk("time", 0, Number.POSITIVE_INFINITY, t3), this._maxOperationRetryTime = t3;
+    }
+    async _getAuthToken() {
+        if (this._overrideAuthToken)
+            return this._overrideAuthToken;
+        const t3 = this._authProvider.getImmediate({
+            optional: true
+        });
+        if (t3) {
+            const e2 = await t3.getToken();
+            if (null !== e2)
+                return e2.accessToken;
+        }
+        return null;
+    }
+    async _getAppCheckToken() {
+        const t3 = this._appCheckProvider.getImmediate({
+            optional: true
+        });
+        if (t3) {
+            return (await t3.getToken()).token;
+        }
+        return null;
+    }
+    _delete() {
+        return this._deleted || (this._deleted = true, this._requests.forEach((t3) => t3.cancel()), this._requests.clear()), Promise.resolve();
+    }
+    _makeStorageReference(t3) {
+        return new Reference(this, t3);
+    }
+    _makeRequest(t3, e2, i2, s2, n2 = true) {
+        if (this._deleted)
+            return new FailRequest(mk());
+        {
+            const r2 = yk(t3, this._appId, i2, s2, e2, this._firebaseVersion, n2);
+            return this._requests.add(r2), r2.getPromise().then(() => this._requests.delete(r2), () => this._requests.delete(r2)), r2;
+        }
+    }
+    async makeRequestWithTokens(t3, e2) {
+        const [i2, s2] = await Promise.all([this._getAuthToken(), this._getAppCheckToken()]);
+        return this._makeRequest(t3, e2, i2, s2).getPromise();
+    }
+}
+const bk = "@firebase/storage",
+    _k = "0.11.2",
+    wk = "storage";
+
+function xk(t3, {
+    instanceIdentifier: e2
+}) {
+    const i2 = t3.getProvider("app").getImmediate(),
+        s2 = t3.getProvider("auth-internal"),
+        n2 = t3.getProvider("app-check-internal");
+    return new FirebaseStorageImpl(i2, s2, n2, e2, uf);
+}
+lf(new Component(wk, xk, "PUBLIC").setMultipleInstances(true)), pf(bk, _k, ""), pf(bk, _k, "esm2017");
+const kk = df({
+        apiKey: "AIzaSyB9Ogv6Vbwfy6_I0aLEfcpsPhqhlc4FSTw",
+        authDomain: "auth.finlab.tw",
+        projectId: "fdata-299302",
+        storageBucket: "fdata-299302.appspot.com",
+        messagingSenderId: "748308483506",
+        appId: "1:748308483506:web:7c78dd82b422cd4ea5a8ab"
+    }),
+    Tk = function(t3, e2) {
+        const i2 = "string" == typeof t3 ? t3 : e2 || "(default)",
+            s2 = hf("object" == typeof t3 ? t3 : ff(), "firestore").getImmediate({
+                identifier: i2
+            });
+        if (!s2._initialized) {
+            const t4 = bd("firestore");
+            t4 && function(t5, e3, i3, s3 = {}) {
+                var n2;
+                const r2 = (t5 = nw(t5, Firestore$1))._getSettings(),
+                    o2 = `${e3}:${i3}`;
+                if ("firestore.googleapis.com" !== r2.host && r2.host !== o2 && Wy("Host has been set in both settings() and connectFirestoreEmulator(), emulator host will be used."), t5._setSettings(Object.assign(Object.assign({}, r2), {
+                        host: o2,
+                        ssl: false
+                    })), s3.mockUserToken) {
+                    let e4, i4;
+                    if ("string" == typeof s3.mockUserToken)
+                        e4 = s3.mockUserToken, i4 = User.MOCK_USER;
+                    else {
+                        e4 = xd(s3.mockUserToken, null === (n2 = t5._app) || void 0 === n2 ? void 0 : n2.options.projectId);
+                        const r3 = s3.mockUserToken.sub || s3.mockUserToken.user_id;
+                        if (!r3)
+                            throw new FirestoreError(Qy.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
+                        i4 = new User(r3);
+                    }
+                    t5._authCredentials = new __PRIVATE_EmulatorAuthCredentialsProvider(new __PRIVATE_OAuthToken(e4, i4));
+                }
+            }(s2, ...t4);
+        }
+        return s2;
+    }(kk);
+! function(t3 = ff(), e2) {
+    const i2 = hf(t3 = Md(t3), wk).getImmediate({
+            identifier: e2
+        }),
+        s2 = bd("storage");
+    s2 && function(t4, e3, i3, s3 = {}) {
+        ! function(t5, e4, i4, s4 = {}) {
+            t5.host = `${e4}:${i4}`, t5._protocol = "http";
+            const {
+                mockUserToken: n2
+            } = s4;
+            n2 && (t5._overrideAuthToken = "string" == typeof n2 ? n2 : xd(n2, t5.app.options.projectId));
+        }(t4, e3, i3, s3);
+    }(i2, ...s2);
+}(kk);
+const Sk = function(t3 = ff()) {
+    const e2 = hf(t3, "auth");
+    if (e2.isInitialized())
+        return e2.getImmediate();
+    const i2 = function(t4, e3) {
+            const i3 = hf(t4, "auth");
+            if (i3.isInitialized()) {
+                const t5 = i3.getImmediate();
+                if (Sd(i3.getOptions(), null != e3 ? e3 : {}))
+                    return t5;
+                yw(t5, "already-initialized");
+            }
+            return i3.initialize({
+                options: e3
+            });
+        }(t3, {
+            popupRedirectResolver: nk,
+            persistence: [Sx, fx, px]
+        }),
+        s2 = wd("authTokenSyncURL");
+    if (s2) {
+        const t4 = (n2 = s2, async (t5) => {
+            const e3 = t5 && await t5.getIdTokenResult(),
+                i3 = e3 && (( /* @__PURE__ */ new Date()).getTime() - Date.parse(e3.issuedAtTime)) / 1e3;
+            if (i3 && i3 > ak)
+                return;
+            const s3 = null == e3 ? void 0 : e3.token;
+            lk !== s3 && (lk = s3, await fetch(n2, {
+                method: s3 ? "POST" : "DELETE",
+                headers: s3 ? {
+                    Authorization: `Bearer ${s3}`
+                } : {}
+            }));
+        });
+        ! function(t5, e3, i3) {
+            Md(t5).beforeAuthStateChanged(e3, i3);
+        }(i2, t4, () => t4(i2.currentUser)),
+        function(t5, e3, i3, s3) {
+            Md(t5).onIdTokenChanged(e3, i3, s3);
+        }(i2, (e3) => t4(e3));
+    }
+    var n2;
+    const r2 = vd("auth");
+    return r2 && ox(i2, `http://${r2}`), i2;
+}(kk);
+Sk.useDeviceLanguage(),
+    function(t3, e2) {
+        Md(t3).setPersistence(e2);
+    }(Sk, fx);
+class Stock {
+    constructor(t3) {
+        this.timestamps = t3.date, this.open = t3.open, this.high = t3.high, this.close = t3.close, this.low = t3.low, this.volume = t3.volume;
+    }
+    createTradingviewSeries(t3, e2 = 0, i2 = -1, s2 = 500) {
+        const n2 = this[t3],
+            r2 = this.timestamps.map((t4, e3) => ({
+                time: t4,
+                value: n2[e3]
+            })).slice(this.indexOfTimestamps(e2), this.indexOfTimestamps(i2) + 1),
+            o2 = Math.round(r2.length / s2);
+        return r2.filter((t4, e3) => e3 % o2 == 0 || e3 === r2.length - 1);
+    }
+    indexOfTimestamps(t3) {
+        return "string" == typeof t3 ? this.timestamps.findIndex((e2) => e2 === t3) : t3 < 0 ? Math.max(this.timestamps.length + t3, 0) : Math.min(t3, this.timestamps.length - 1);
+    }
+    createCandlestickSeries(t3 = 0, e2 = -1) {
+        const i2 = this.indexOfTimestamps(t3),
+            s2 = this.indexOfTimestamps(e2) + 1;
+        return this.timestamps.slice(i2, s2).map((t4, e3) => ({
+            time: t4,
+            open: this.open[i2 + e3],
+            high: this.high[i2 + e3],
+            low: this.low[i2 + e3],
+            close: this.close[i2 + e3]
+        }));
+    }
+}
+const Ek = cd(null);
+
+function Ck(t3) {
+    let e2, i2, s2, r2, o2, a2, l2, h2, c2, u2, d2, f2, p2, m2, g2, y2, v2, b2, w2, x2, k2, T2, C2 = t3[0].assetId + "",
+        R2 = t3[0].assetName + "";
+    return {
+        c() {
+            e2 = P("h3"), i2 = D(C2), s2 = $(), r2 = D(R2), o2 = $(), a2 = P("button"), a2.textContent = "✕", l2 = $(), h2 = P("div"), u2 = $(), d2 = P("div"), p2 = $(), m2 = P("div"), g2 = P("span"), g2.textContent = "報酬曲線圖", y2 = $(), v2 = P("label"), b2 = P("input"), w2 = $(), x2 = P("span"), x2.textContent = "蠟燭圖", U(e2, "class", "font-bold text-lg"), U(a2, "class", "btn btn-sm btn-circle btn-ghost absolute right-2 top-2"), U(h2, "class", c2 = "text-primary h-64 w-full z-0 " + (t3[3] ? "hidden" : "block")), U(d2, "class", f2 = "text-primary h-64 w-full z-0 " + (t3[3] ? "block" : "hidden")), U(g2, "class", "text-gray-500"), U(b2, "type", "checkbox"), U(b2, "class", "toggle toggle-primary toggle-md mx-2"), U(x2, "class", "text-gray-500"), U(m2, "class", "mt-4 flex item-center justify-center");
+        },
+        m(n2, c3) {
+            S(n2, e2, c3), _(e2, i2), _(e2, s2), _(e2, r2), S(n2, o2, c3), S(n2, a2, c3), S(n2, l2, c3), S(n2, h2, c3), t3[6](h2), S(n2, u2, c3), S(n2, d2, c3), t3[7](d2), S(n2, p2, c3), S(n2, m2, c3), _(m2, g2), _(m2, y2), _(m2, v2), _(v2, b2), b2.checked = t3[3], _(m2, w2), _(m2, x2), k2 || (T2 = [B(a2, "click", t3[4]), B(b2, "change", t3[8])], k2 = true);
+        },
+        p(t4, e3) {
+            1 & e3 && C2 !== (C2 = t4[0].assetId + "") && H(i2, C2), 1 & e3 && R2 !== (R2 = t4[0].assetName + "") && H(r2, R2), 8 & e3 && c2 !== (c2 = "text-primary h-64 w-full z-0 " + (t4[3] ? "hidden" : "block")) && U(h2, "class", c2), 8 & e3 && f2 !== (f2 = "text-primary h-64 w-full z-0 " + (t4[3] ? "block" : "hidden")) && U(d2, "class", f2), 8 & e3 && (b2.checked = t4[3]);
+        },
+        d(i3) {
+            i3 && (E(e2), E(o2), E(a2), E(l2), E(h2), E(u2), E(d2), E(p2), E(m2)), t3[6](null), t3[7](null), k2 = false, n(T2);
+        }
+    };
+}
+
+function Ik(e2) {
+    let i2, s2 = e2[0] && Ck(e2);
+    return {
+        c() {
+            i2 = P("div"), s2 && s2.c(), U(i2, "class", "card bg-base-100 shadow-xl text-base-content-300 p-4");
+        },
+        m(t3, e3) {
+            S(t3, i2, e3), s2 && s2.m(i2, null);
+        },
+        p(t3, [e3]) {
+            t3[0] ? s2 ? s2.p(t3, e3) : (s2 = Ck(t3), s2.c(), s2.m(i2, null)) : s2 && (s2.d(1), s2 = null);
+        },
+        i: t,
+        o: t,
+        d(t3) {
+            t3 && E(i2), s2 && s2.d();
+        }
+    };
+}
+
+function Mk(t3, e2, i2) {
+    let s2, n2, r2, o2;
+    async function l2(t4) {
+        await async function(t5) {
+            const e3 = await f2(t5),
+                i3 = e3.timestamps.length,
+                s3 = e3.timestamps.length / (i3 / 100);
+            c2 = e3.createTradingviewSeries("close", 0, -1, s3), c2.forEach((t6) => {
+                try {
+                    if (!t6.time || "number" != typeof t6.time.seconds)
+                        throw new Error("Invalid or missing time.seconds property");
+                    {
+                        const e4 = 1e3 * t6.time.seconds,
+                            i4 = new Date(e4);
+                        if (isNaN(i4.getTime()))
+                            throw new Error("Invalid date");
+                        t6.time = {
+                            day: i4.getDate(),
+                            month: i4.getMonth() + 1,
+                            year: i4.getFullYear()
+                        };
+                    }
+                } catch (e4) {
+                    t6.time = {
+                        day: null,
+                        month: null,
+                        year: null
+                    };
+                }
+            });
+        }(t4.assetId), await async function(t5) {
+                const e3 = await f2(t5),
+                    i3 = e3.createCandlestickSeries(0, -1);
+                i3.forEach((t6) => {
+                    try {
+                        if (!t6.time || "object" != typeof t6.time || !("seconds" in t6.time))
+                            throw new Error("Invalid or missing time property");
+                        {
+                            const e4 = new Date(1e3 * t6.time.seconds);
+                            if (isNaN(e4.getTime()))
+                                throw new Error("Invalid date");
+                            t6.time = e4.toISOString().split("T")[0];
+                        }
+                    } catch (e4) {
+                        console.error("Error processing time:", t6.time, e4), t6.time = null;
+                    }
+                }), h2 = i3;
+            }(t4.assetId),
+            function() {
+                d2 || (d2 = new TwChart(o2, false));
+                d2.setTheme("dark" === Ek ? "dark" : "light"), d2.addCandlestickSeries(), d2.updateCandlestickSeriesData(h2);
+            }(),
+            function() {
+                u2 || (u2 = new TwChart(r2, true));
+                u2.setTheme("dark" === Ek ? "dark" : "light"), u2.resetAreaSeries(0), u2.resetAreaSeries(1), u2.series[0].setData(c2);
+            }();
+    }
+    a(t3, ud, (t4) => i2(5, s2 = t4));
+    let h2, c2, u2 = null,
+        d2 = null;
+    async function f2(t4) {
+        const e3 = rw(Tk, "twStock", t4);
+        if (e3) {
+            const t5 = (await cw(e3)).data();
+            return new Stock(t5.price);
+        }
+    }
+    const p2 = bt();
+
+    function m2() {
+        p2("close"), ud.set(null);
+    }
+
+    function g2(t4) {
+        "Escape" === t4.key && m2();
+    }
+    pt(() => {
+        window.addEventListener("keydown", g2);
+    }), yt(() => {
+        window.removeEventListener("keydown", g2);
+    });
+    let y2 = true;
+    return t3.$$.update = () => {
+        32 & t3.$$.dirty && i2(0, n2 = s2), 1 & t3.$$.dirty && n2 && l2(n2);
+    }, [n2, r2, o2, y2, m2, s2, function(t4) {
+        xt[t4 ? "unshift" : "push"](() => {
+            r2 = t4, i2(1, r2);
+        });
+    }, function(t4) {
+        xt[t4 ? "unshift" : "push"](() => {
+            o2 = t4, i2(2, o2);
+        });
+    }, function() {
+        y2 = this.checked, i2(3, y2);
+    }];
+}
+class StockBlock extends SvelteComponent {
+    constructor(t3) {
+        super(), ve(this, t3, Mk, Ik, o, {});
+    }
+}
+
+function Pk(t3, e2, i2) {
+    const s2 = t3.slice();
+    return s2[18] = e2[i2], s2;
+}
+
+function Rk(t3, e2, i2) {
+    const s2 = t3.slice();
+    return s2[21] = e2[i2], s2;
+}
+we(StockBlock, {}, [], [], true);
+const Ak = (t3) => ({
+        row: 2 & t3
+    }),
+    Dk = (t3) => ({
+        row: t3[18]
+    }),
+    Lk = (t3) => ({
+        row: 2 & t3
+    }),
+    Ok = (t3) => ({
+        row: t3[18]
+    }),
+    Fk = (t3) => ({
+        row: 2 & t3
+    }),
+    Nk = (t3) => ({
+        row: t3[18]
+    }),
+    $k = (t3) => ({
+        row: 2 & t3
+    }),
+    Vk = (t3) => ({
+        row: t3[18]
+    }),
+    zk = (t3) => ({
+        row: 2 & t3
+    }),
+    Bk = (t3) => ({
+        row: t3[18]
+    }),
+    Uk = (t3) => ({
+        row: 2 & t3
+    }),
+    jk = (t3) => ({
+        row: t3[18]
+    });
+
+function Hk(t3, e2, i2) {
+    const s2 = t3.slice();
+    return s2[21] = e2[i2], s2;
+}
+
+function Wk(t3) {
+    let e2, i2, s2 = t3[3] ? "▲" : "▼";
+    return {
+        c() {
+            e2 = P("span"), i2 = D(s2), U(e2, "class", "pl-2");
+        },
+        m(t4, s3) {
+            S(t4, e2, s3), _(e2, i2);
+        },
+        p(t4, e3) {
+            8 & e3 && s2 !== (s2 = t4[3] ? "▲" : "▼") && H(i2, s2);
+        },
+        d(t4) {
+            t4 && E(e2);
+        }
+    };
+}
+
+function qk(t3, e2) {
+    let i2, s2, n2, r2, o2, a2, l2, h2 = e2[21].name + "",
+        c2 = e2[2] === e2[21].key && Wk(e2);
+
+    function u2() {
+        return e2[13](e2[21]);
+    }
+    return {
+        key: t3,
+        first: null,
+        c() {
+            i2 = P("th"), s2 = D(h2), n2 = $(), c2 && c2.c(), r2 = $(), G(i2, "width", e2[21].width), U(i2, "class", o2 = "tracking-wider cursor-pointer font-bold whitespace-nowrap " + ("name" === e2[21].key ? "pl-0 text-left sticky left-0 bg-base-200" : "text-right") + " " + (e2[21].sort, " ") + (e2[2] === e2[21].key ? "text-primary" : "")), this.first = i2;
+        },
+        m(t4, e3) {
+            S(t4, i2, e3), _(i2, s2), _(i2, n2), c2 && c2.m(i2, null), _(i2, r2), a2 || (l2 = B(i2, "click", u2), a2 = true);
+        },
+        p(t4, n3) {
+            e2 = t4, 1 & n3 && h2 !== (h2 = e2[21].name + "") && H(s2, h2), e2[2] === e2[21].key ? c2 ? c2.p(e2, n3) : (c2 = Wk(e2), c2.c(), c2.m(i2, r2)) : c2 && (c2.d(1), c2 = null), 1 & n3 && G(i2, "width", e2[21].width), 5 & n3 && o2 !== (o2 = "tracking-wider cursor-pointer font-bold whitespace-nowrap " + ("name" === e2[21].key ? "pl-0 text-left sticky left-0 bg-base-200" : "text-right") + " " + (e2[21].sort, " ") + (e2[2] === e2[21].key ? "text-primary" : "")) && U(i2, "class", o2);
+        },
+        d(t4) {
+            t4 && E(i2), c2 && c2.d(), a2 = false, l2();
+        }
+    };
+}
+
+function Kk(e2) {
+    let i2, s2 = (e2[18][e2[21].key] ? e2[18][e2[21].key] : "-") + "";
+    return {
+        c() {
+            i2 = D(s2);
+        },
+        m(t3, e3) {
+            S(t3, i2, e3);
+        },
+        p(t3, e3) {
+            3 & e3 && s2 !== (s2 = (t3[18][t3[21].key] ? t3[18][t3[21].key] : "-") + "") && H(i2, s2);
+        },
+        i: t,
+        o: t,
+        d(t3) {
+            t3 && E(i2);
+        }
+    };
+}
+
+function Gk(t3) {
+    let e2;
+    const i2 = t3[12].RSV,
+        s2 = l(i2, t3, t3[11], Dk),
+        n2 = s2 || function(t4) {
+            let e3, i3 = t4[18].RSV + "";
+            return {
+                c() {
+                    e3 = D(i3);
+                },
+                m(t5, i4) {
+                    S(t5, e3, i4);
+                },
+                p(t5, s3) {
+                    2 & s3 && i3 !== (i3 = t5[18].RSV + "") && H(e3, i3);
+                },
+                d(t5) {
+                    t5 && E(e3);
+                }
+            };
+        }(t3);
+    return {
+        c() {
+            n2 && n2.c();
+        },
+        m(t4, i3) {
+            n2 && n2.m(t4, i3), e2 = true;
+        },
+        p(t4, r2) {
+            s2 ? s2.p && (!e2 || 2050 & r2) && u(s2, i2, t4, t4[11], e2 ? c(i2, t4[11], r2, Ak) : d(t4[11]), Dk) : n2 && n2.p && (!e2 || 2 & r2) && n2.p(t4, e2 ? r2 : -1);
+        },
+        i(t4) {
+            e2 || (le(n2, t4), e2 = true);
+        },
+        o(t4) {
+            he(n2, t4), e2 = false;
+        },
+        d(t4) {
+            n2 && n2.d(t4);
+        }
+    };
+}
+
+function Yk(t3) {
+    let e2;
+    const i2 = t3[12].currentWeight,
+        s2 = l(i2, t3, t3[11], Ok),
+        n2 = s2 || function(t4) {
+            let e3, i3 = t4[18].currentWeight + "";
+            return {
+                c() {
+                    e3 = D(i3);
+                },
+                m(t5, i4) {
+                    S(t5, e3, i4);
+                },
+                p(t5, s3) {
+                    2 & s3 && i3 !== (i3 = t5[18].currentWeight + "") && H(e3, i3);
+                },
+                d(t5) {
+                    t5 && E(e3);
+                }
+            };
+        }(t3);
+    return {
+        c() {
+            n2 && n2.c();
+        },
+        m(t4, i3) {
+            n2 && n2.m(t4, i3), e2 = true;
+        },
+        p(t4, r2) {
+            s2 ? s2.p && (!e2 || 2050 & r2) && u(s2, i2, t4, t4[11], e2 ? c(i2, t4[11], r2, Lk) : d(t4[11]), Ok) : n2 && n2.p && (!e2 || 2 & r2) && n2.p(t4, e2 ? r2 : -1);
+        },
+        i(t4) {
+            e2 || (le(n2, t4), e2 = true);
+        },
+        o(t4) {
+            he(n2, t4), e2 = false;
+        },
+        d(t4) {
+            n2 && n2.d(t4);
+        }
+    };
+}
+
+function Qk(t3) {
+    let e2;
+    const i2 = t3[12].profit,
+        s2 = l(i2, t3, t3[11], Nk),
+        n2 = s2 || function(t4) {
+            let e3, i3 = t4[18].profit + "";
+            return {
+                c() {
+                    e3 = D(i3);
+                },
+                m(t5, i4) {
+                    S(t5, e3, i4);
+                },
+                p(t5, s3) {
+                    2 & s3 && i3 !== (i3 = t5[18].profit + "") && H(e3, i3);
+                },
+                d(t5) {
+                    t5 && E(e3);
+                }
+            };
+        }(t3);
+    return {
+        c() {
+            n2 && n2.c();
+        },
+        m(t4, i3) {
+            n2 && n2.m(t4, i3), e2 = true;
+        },
+        p(t4, r2) {
+            s2 ? s2.p && (!e2 || 2050 & r2) && u(s2, i2, t4, t4[11], e2 ? c(i2, t4[11], r2, Fk) : d(t4[11]), Nk) : n2 && n2.p && (!e2 || 2 & r2) && n2.p(t4, e2 ? r2 : -1);
+        },
+        i(t4) {
+            e2 || (le(n2, t4), e2 = true);
+        },
+        o(t4) {
+            he(n2, t4), e2 = false;
+        },
+        d(t4) {
+            n2 && n2.d(t4);
+        }
+    };
+}
+
+function Xk(t3) {
+    let e2;
+    const i2 = t3[12].entryDate,
+        s2 = l(i2, t3, t3[11], Vk),
+        n2 = s2 || function(t4) {
+            let e3, i3 = t4[18].entryDate + "";
+            return {
+                c() {
+                    e3 = D(i3);
+                },
+                m(t5, i4) {
+                    S(t5, e3, i4);
+                },
+                p(t5, s3) {
+                    2 & s3 && i3 !== (i3 = t5[18].entryDate + "") && H(e3, i3);
+                },
+                d(t5) {
+                    t5 && E(e3);
+                }
+            };
+        }(t3);
+    return {
+        c() {
+            n2 && n2.c();
+        },
+        m(t4, i3) {
+            n2 && n2.m(t4, i3), e2 = true;
+        },
+        p(t4, r2) {
+            s2 ? s2.p && (!e2 || 2050 & r2) && u(s2, i2, t4, t4[11], e2 ? c(i2, t4[11], r2, $k) : d(t4[11]), Vk) : n2 && n2.p && (!e2 || 2 & r2) && n2.p(t4, e2 ? r2 : -1);
+        },
+        i(t4) {
+            e2 || (le(n2, t4), e2 = true);
+        },
+        o(t4) {
+            he(n2, t4), e2 = false;
+        },
+        d(t4) {
+            n2 && n2.d(t4);
+        }
+    };
+}
+
+function Jk(t3) {
+    let e2;
+    const i2 = t3[12].action,
+        s2 = l(i2, t3, t3[11], Bk),
+        n2 = s2 || function(t4) {
+            let e3, i3 = t4[18].action + "";
+            return {
+                c() {
+                    e3 = D(i3);
+                },
+                m(t5, i4) {
+                    S(t5, e3, i4);
+                },
+                p(t5, s3) {
+                    2 & s3 && i3 !== (i3 = t5[18].action + "") && H(e3, i3);
+                },
+                d(t5) {
+                    t5 && E(e3);
+                }
+            };
+        }(t3);
+    return {
+        c() {
+            n2 && n2.c();
+        },
+        m(t4, i3) {
+            n2 && n2.m(t4, i3), e2 = true;
+        },
+        p(t4, r2) {
+            s2 ? s2.p && (!e2 || 2050 & r2) && u(s2, i2, t4, t4[11], e2 ? c(i2, t4[11], r2, zk) : d(t4[11]), Bk) : n2 && n2.p && (!e2 || 2 & r2) && n2.p(t4, e2 ? r2 : -1);
+        },
+        i(t4) {
+            e2 || (le(n2, t4), e2 = true);
+        },
+        o(t4) {
+            he(n2, t4), e2 = false;
+        },
+        d(t4) {
+            n2 && n2.d(t4);
+        }
+    };
+}
+
+function Zk(t3) {
+    let e2;
+    const i2 = t3[12].name,
+        s2 = l(i2, t3, t3[11], jk),
+        n2 = s2 || function(t4) {
+            let e3, i3 = t4[18].name + "";
+            return {
+                c() {
+                    e3 = D(i3);
+                },
+                m(t5, i4) {
+                    S(t5, e3, i4);
+                },
+                p(t5, s3) {
+                    2 & s3 && i3 !== (i3 = t5[18].name + "") && H(e3, i3);
+                },
+                d(t5) {
+                    t5 && E(e3);
+                }
+            };
+        }(t3);
+    return {
+        c() {
+            n2 && n2.c();
+        },
+        m(t4, i3) {
+            n2 && n2.m(t4, i3), e2 = true;
+        },
+        p(t4, r2) {
+            s2 ? s2.p && (!e2 || 2050 & r2) && u(s2, i2, t4, t4[11], e2 ? c(i2, t4[11], r2, Uk) : d(t4[11]), jk) : n2 && n2.p && (!e2 || 2 & r2) && n2.p(t4, e2 ? r2 : -1);
+        },
+        i(t4) {
+            e2 || (le(n2, t4), e2 = true);
+        },
+        o(t4) {
+            he(n2, t4), e2 = false;
+        },
+        d(t4) {
+            n2 && n2.d(t4);
+        }
+    };
+}
+
+function tT(t3, e2) {
+    let i2, s2, n2, r2, o2, a2;
+    const l2 = [Zk, Jk, Xk, Qk, Yk, Gk, Kk],
+        h2 = [];
+
+    function c2(t4, e3) {
+        return "name" === t4[21].key ? 0 : "action" === t4[21].key ? 1 : "entryDate" === t4[21].key ? 2 : "profit" === t4[21].key ? 3 : "currentWeight" === t4[21].key ? 4 : "RSV" === t4[21].key ? 5 : 6;
+    }
+    return s2 = c2(e2), n2 = h2[s2] = l2[s2](e2), {
+        key: t3,
+        first: null,
+        c() {
+            i2 = P("td"), n2.c(), r2 = $(), G(i2, "width", e2[21].width), U(i2, "class", o2 = "whitespace-nowrap " + ("name" === e2[21].key ? "pl-0 text-left sticky left-0 z-10 bg-base-200" : "text-right")), this.first = i2;
+        },
+        m(t4, e3) {
+            S(t4, i2, e3), h2[s2].m(i2, null), _(i2, r2), a2 = true;
+        },
+        p(t4, u2) {
+            let d2 = s2;
+            s2 = c2(e2 = t4), s2 === d2 ? h2[s2].p(e2, u2) : (oe(), he(h2[d2], 1, 1, () => {
+                h2[d2] = null;
+            }), ae(), n2 = h2[s2], n2 ? n2.p(e2, u2) : (n2 = h2[s2] = l2[s2](e2), n2.c()), le(n2, 1), n2.m(i2, r2)), (!a2 || 1 & u2) && G(i2, "width", e2[21].width), (!a2 || 1 & u2 && o2 !== (o2 = "whitespace-nowrap " + ("name" === e2[21].key ? "pl-0 text-left sticky left-0 z-10 bg-base-200" : "text-right"))) && U(i2, "class", o2);
+        },
+        i(t4) {
+            a2 || (le(n2), a2 = true);
+        },
+        o(t4) {
+            he(n2), a2 = false;
+        },
+        d(t4) {
+            t4 && E(i2), h2[s2].d();
+        }
+    };
+}
+
+function eT(t3) {
+    let e2, i2, s2, n2, r2, o2;
+    return s2 = new StockBlock({}), s2.$on("close", t3[8]), {
+        c() {
+            e2 = P("tr"), i2 = P("td"), me(s2.$$.fragment), r2 = $(), U(i2, "colspan", n2 = t3[0].length - 1);
+        },
+        m(t4, n3) {
+            S(t4, e2, n3), _(e2, i2), ge(s2, i2, null), _(e2, r2), o2 = true;
+        },
+        p(t4, e3) {
+            (!o2 || 1 & e3 && n2 !== (n2 = t4[0].length - 1)) && U(i2, "colspan", n2);
+        },
+        i(t4) {
+            o2 || (le(s2.$$.fragment, t4), o2 = true);
+        },
+        o(t4) {
+            he(s2.$$.fragment, t4), o2 = false;
+        },
+        d(t4) {
+            t4 && E(e2), ye(s2);
+        }
+    };
+}
+
+function iT(t3, e2) {
+    let i2, s2, n2, r2, o2 = [],
+        a2 = /* @__PURE__ */ new Map(),
+        l2 = Ou(),
+        h2 = ue(e2[0]);
+    const c2 = (t4) => t4[21].name;
+    for (let t4 = 0; t4 < h2.length; t4 += 1) {
+        let i3 = Rk(e2, h2, t4),
+            s3 = c2(i3);
+        a2.set(s3, o2[t4] = tT(s3, i3));
+    }
+    let u2 = l2 && function(t4) {
+        let e3, i3, s3 = t4[6] && t4[18].assetId === t4[6].assetId && eT(t4);
+        return {
+            c() {
+                s3 && s3.c(), e3 = z();
+            },
+            m(t5, n3) {
+                s3 && s3.m(t5, n3), S(t5, e3, n3), i3 = true;
+            },
+            p(t5, i4) {
+                t5[6] && t5[18].assetId === t5[6].assetId ? s3 ? (s3.p(t5, i4), 66 & i4 && le(s3, 1)) : (s3 = eT(t5), s3.c(), le(s3, 1), s3.m(e3.parentNode, e3)) : s3 && (oe(), he(s3, 1, 1, () => {
+                    s3 = null;
+                }), ae());
+            },
+            i(t5) {
+                i3 || (le(s3), i3 = true);
+            },
+            o(t5) {
+                he(s3), i3 = false;
+            },
+            d(t5) {
+                t5 && E(e3), s3 && s3.d(t5);
+            }
+        };
+    }(e2);
+    return {
+        key: t3,
+        first: null,
+        c() {
+            i2 = P("tr");
+            for (let t4 = 0; t4 < o2.length; t4 += 1)
+                o2[t4].c();
+            s2 = $(), u2 && u2.c(), n2 = z(), this.first = i2;
+        },
+        m(t4, e3) {
+            S(t4, i2, e3);
+            for (let t5 = 0; t5 < o2.length; t5 += 1)
+                o2[t5] && o2[t5].m(i2, null);
+            S(t4, s2, e3), u2 && u2.m(t4, e3), S(t4, n2, e3), r2 = true;
+        },
+        p(t4, s3) {
+            e2 = t4, 2051 & s3 && (h2 = ue(e2[0]), oe(), o2 = pe(o2, s3, c2, 1, e2, h2, a2, i2, fe, tT, null, Rk), ae()), l2 && u2.p(e2, s3);
+        },
+        i(t4) {
+            if (!r2) {
+                for (let t5 = 0; t5 < h2.length; t5 += 1)
+                    le(o2[t5]);
+                le(u2), r2 = true;
+            }
+        },
+        o(t4) {
+            for (let t5 = 0; t5 < o2.length; t5 += 1)
+                he(o2[t5]);
+            he(u2), r2 = false;
+        },
+        d(t4) {
+            t4 && (E(i2), E(s2), E(n2));
+            for (let t5 = 0; t5 < o2.length; t5 += 1)
+                o2[t5].d();
+            u2 && u2.d(t4);
+        }
+    };
+}
+
+function sT(t3) {
+    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2, d2, f2, p2 = [],
+        m2 = /* @__PURE__ */ new Map(),
+        g2 = [],
+        y2 = /* @__PURE__ */ new Map(),
+        v2 = ue(t3[0]);
+    const b2 = (t4) => t4[21].name;
+    for (let e3 = 0; e3 < v2.length; e3 += 1) {
+        let i3 = Hk(t3, v2, e3),
+            s3 = b2(i3);
+        m2.set(s3, p2[e3] = qk(s3, i3));
+    }
+    let w2 = ue(t3[1]);
+    const x2 = (t4) => t4[18].assetId;
+    for (let e3 = 0; e3 < w2.length; e3 += 1) {
+        let i3 = Pk(t3, w2, e3),
+            s3 = x2(i3);
+        y2.set(s3, g2[e3] = iT(s3, i3));
+    }
+    return {
+        c() {
+            e2 = P("div"), i2 = P("div"), s2 = P("div"), n2 = P("table"), r2 = P("thead"), o2 = P("tr");
+            for (let t4 = 0; t4 < p2.length; t4 += 1)
+                p2[t4].c();
+            a2 = $(), l2 = P("div"), h2 = P("table"), c2 = P("tbody");
+            for (let t4 = 0; t4 < g2.length; t4 += 1)
+                g2[t4].c();
+            U(r2, "class", "sticky top-12 z-20 bg-base-200 h-8 pb-4"), U(n2, "class", "table min-w-full table-fixed"), U(s2, "class", "overflow-hidden"), U(i2, "class", "sticky top-12 z-20"), U(h2, "class", "table table-fixed m-0"), U(l2, "class", "overflow-x-auto overflow-y-hidden pb-8"), U(e2, "class", "relative w-full -mt-2");
+        },
+        m(m3, y3) {
+            S(m3, e2, y3), _(e2, i2), _(i2, s2), _(s2, n2), _(n2, r2), _(r2, o2);
+            for (let t4 = 0; t4 < p2.length; t4 += 1)
+                p2[t4] && p2[t4].m(o2, null);
+            t3[14](s2), _(e2, a2), _(e2, l2), _(l2, h2), _(h2, c2);
+            for (let t4 = 0; t4 < g2.length; t4 += 1)
+                g2[t4] && g2[t4].m(c2, null);
+            t3[15](l2), u2 = true, d2 || (f2 = B(l2, "scroll", t3[16]), d2 = true);
+        },
+        p(t4, [e3]) {
+            141 & e3 && (v2 = ue(t4[0]), p2 = pe(p2, e3, b2, 1, t4, v2, m2, o2, de, qk, null, Hk)), 2371 & e3 && (w2 = ue(t4[1]), oe(), g2 = pe(g2, e3, x2, 1, t4, w2, y2, c2, fe, iT, null, Pk), ae());
+        },
+        i(t4) {
+            if (!u2) {
+                for (let t5 = 0; t5 < w2.length; t5 += 1)
+                    le(g2[t5]);
+                u2 = true;
+            }
+        },
+        o(t4) {
+            for (let t5 = 0; t5 < g2.length; t5 += 1)
+                he(g2[t5]);
+            u2 = false;
+        },
+        d(i3) {
+            i3 && E(e2);
+            for (let t4 = 0; t4 < p2.length; t4 += 1)
+                p2[t4].d();
+            t3[14](null);
+            for (let t4 = 0; t4 < g2.length; t4 += 1)
+                g2[t4].d();
+            t3[15](null), d2 = false, f2();
+        }
+    };
+}
+
+function nT(t3, e2, i2) {
+    let s2;
+    a(t3, ud, (t4) => i2(10, s2 = t4));
+    let n2, r2, o2, l2, h2, {
+            $$slots: c2 = {},
+            $$scope: u2
+        } = e2,
+        {
+            rows: d2 = []
+        } = e2,
+        {
+            columns: f2 = []
+        } = e2,
+        p2 = [];
+
+    function m2(t4) {
+        if (!t4.sort)
+            return;
+        const e3 = t4.key;
+        n2 === e3 ? i2(3, r2 = !r2) : (i2(2, n2 = e3), i2(3, r2 = true)), i2(1, p2 = [...d2].sort((t5, i3) => {
+            const s3 = t5[e3],
+                n3 = i3[e3];
+            if (s3 === n3)
+                return 0;
+            const o3 = s3 < n3 ? -1 : 1;
+            return r2 ? o3 : -o3;
+        }));
+    }
+    const g2 = bt();
+    return t3.$$set = (t4) => {
+        "rows" in t4 && i2(9, d2 = t4.rows), "columns" in t4 && i2(0, f2 = t4.columns), "$$scope" in t4 && i2(11, u2 = t4.$$scope);
+    }, t3.$$.update = () => {
+        512 & t3.$$.dirty && (i2(1, p2 = d2), i2(2, n2 = null), i2(3, r2 = true)), 1024 & t3.$$.dirty && i2(6, h2 = s2);
+    }, [f2, p2, n2, r2, o2, l2, h2, m2, function() {
+        g2("close");
+    }, d2, s2, u2, c2, (t4) => m2(t4), function(t4) {
+        xt[t4 ? "unshift" : "push"](() => {
+            o2 = t4, i2(4, o2);
+        });
+    }, function(t4) {
+        xt[t4 ? "unshift" : "push"](() => {
+            l2 = t4, i2(5, l2);
+        });
+    }, () => {
+        return t4 = l2, void(o2.scrollLeft = t4.scrollLeft);
+        var t4;
+    }];
+}
+class PositionDataTable extends SvelteComponent {
+    constructor(t3) {
+        super(), ve(this, t3, nT, sT, o, {
+            rows: 9,
+            columns: 0
+        });
+    }
+    get rows() {
+        return this.$$.ctx[9];
+    }
+    set rows(t3) {
+        this.$$set({
+            rows: t3
+        }), te();
+    }
+    get columns() {
+        return this.$$.ctx[0];
+    }
+    set columns(t3) {
+        this.$$set({
+            columns: t3
+        }), te();
+    }
+}
+
+function rT(t3) {
+    const e2 = function(t4) {
+            if (!t4)
+                return 0;
+            const e3 = t4.codePointAt(0);
+            if (void 0 === e3)
+                throw new Error("Invalid character");
+            return e3 % 360;
+        }(t3),
+        i2 = function(t4, e3, i3) {
+            let s3, n2, r2;
+            if (0 === e3)
+                s3 = n2 = r2 = i3;
+            else {
+                const o2 = (t5, e4, i4) => (i4 < 0 && (i4 += 1), i4 > 1 && (i4 -= 1), i4 < 1 / 6 ? t5 + 6 * (e4 - t5) * i4 : i4 < 0.5 ? e4 : i4 < 2 / 3 ? t5 + (e4 - t5) * (2 / 3 - i4) * 6 : t5);
+                let a2 = i3 < 0.5 ? i3 * (1 + e3) : i3 + e3 - i3 * e3,
+                    l2 = 2 * i3 - a2;
+                s3 = o2(l2, a2, t4 + 1 / 3), n2 = o2(l2, a2, t4), r2 = o2(l2, a2, t4 - 1 / 3);
+            }
+            return [Math.round(255 * s3), Math.round(255 * n2), Math.round(255 * r2)];
+        }(e2 / 360, 0.5, 0.5),
+        s2 = function(t4, e3, i3) {
+            const s3 = (t5) => {
+                const e4 = t5.toString(16);
+                return 1 === e4.length ? "0" + e4 : e4;
+            };
+            return `#${s3(t4)}${s3(e3)}${s3(i3)}`;
+        }(...i2);
+    return s2 + "77";
+}
+
+function oT(t3) {
+    const e2 = {};
+    for (let [i2, s2] of t3.entries())
+        s2 instanceof Map ? e2[i2] = oT(s2) : e2[i2] = s2;
+    return e2;
+}
+
+function aT(t3) {
+    if ("object" != typeof t3 || null === t3)
+        return console.log("Invalid: obj is not an object or is null"), false;
+    t3 instanceof Map && (t3 = oT(t3));
+    const e2 = ["assetName", "assetId"],
+        i2 = ["entryDate", "exitDate"],
+        s2 = ["entryPrice", "exitPrice", "currentPrice", "profit", "currentWeight", "nextWeight", "rsv20"];
+    for (const i3 of e2)
+        if ("string" != typeof t3[i3])
+            return console.log(`Invalid: ${i3} is not a string`), false;
+    for (const e3 of i2)
+        if (!(t3[e3] instanceof Date) && void 0 !== t3[e3])
+            return console.log(`Invalid: ${e3} is not a Date`), false;
+    for (const e3 of s2)
+        if ("number" != typeof t3[e3])
+            return console.log(`Invalid: ${e3} is not a number`), false;
+    if (null !== t3.action) {
+        if ("object" != typeof t3.action || null === t3.action)
+            return console.log("Invalid: action is not an object or is null"), false;
+        const e3 = ["type", "reason", "date", "profit"];
+        for (const i4 of e3)
+            if (!(i4 in t3.action))
+                return console.log(`Invalid: ${i4} is missing in action`), false;
+        if (!["entry", "exit", "hold", "entry_f", "exit_p"].includes(t3.action.type))
+            return console.log("Invalid: action.type is not one of 'entry', 'exit', 'hold'"), false;
+        const i3 = ["sl", "tp", "sl_", "tp_", "_", "entry", "exit", "sl_enter", "tp_enter"];
+        if (!i3.includes(t3.action.reason))
+            return console.log(`Invalid: action.reason is not one of ${i3}`), false;
+        if (!(t3.action.date instanceof Date) && void 0 !== t3.action.date)
+            return console.log("Invalid: action.date is not a Date"), false;
+        if ("number" != typeof t3.action.profit)
+            return console.log("Invalid: action.profit is not a number"), false;
+    }
+    return true;
+}
+
+function lT(t3) {
+    let e2, i2, s2, r2, o2, a2, l2, h2, c2, u2, d2, f2, p2, m2, g2, y2, v2, b2, w2, x2, k2, T2, C2, R2, z2 = t3[0].assetId + "",
+        j2 = t3[0].assetName + "";
+    return {
+        c() {
+            e2 = P("div"), i2 = P("form"), s2 = P("button"), s2.textContent = "✕", r2 = $(), o2 = P("h3"), a2 = D(z2), l2 = $(), h2 = D(j2), c2 = $(), u2 = P("div"), f2 = $(), p2 = P("div"), g2 = $(), y2 = P("div"), v2 = P("span"), v2.textContent = "報酬曲線圖", b2 = $(), w2 = P("label"), x2 = P("input"), k2 = $(), T2 = P("span"), T2.textContent = "蠟燭圖", U(s2, "class", "btn btn-sm btn-circle btn-ghost absolute right-2 top-2"), U(i2, "method", "dialog"), U(o2, "class", "font-bold text-lg"), U(u2, "class", d2 = "text-primary h-64 z-0 " + (t3[3] ? "hidden" : "block")), U(p2, "class", m2 = "text-primary h-64 z-0 " + (t3[3] ? "block" : "hidden")), U(v2, "class", "text-gray-500"), U(x2, "type", "checkbox"), U(x2, "class", "toggle toggle-primary toggle-md mx-2"), U(T2, "class", "text-gray-500"), U(y2, "class", "mt-4 flex item-center justify-center");
+        },
+        m(n2, d3) {
+            S(n2, e2, d3), _(e2, i2), _(i2, s2), _(e2, r2), _(e2, o2), _(o2, a2), _(o2, l2), _(o2, h2), _(e2, c2), _(e2, u2), t3[7](u2), _(e2, f2), _(e2, p2), t3[8](p2), _(e2, g2), _(e2, y2), _(y2, v2), _(y2, b2), _(y2, w2), _(w2, x2), x2.checked = t3[3], _(y2, k2), _(y2, T2), C2 || (R2 = [B(s2, "click", t3[4]), B(x2, "change", t3[9])], C2 = true);
+        },
+        p(t4, e3) {
+            1 & e3 && z2 !== (z2 = t4[0].assetId + "") && H(a2, z2), 1 & e3 && j2 !== (j2 = t4[0].assetName + "") && H(h2, j2), 8 & e3 && d2 !== (d2 = "text-primary h-64 z-0 " + (t4[3] ? "hidden" : "block")) && U(u2, "class", d2), 8 & e3 && m2 !== (m2 = "text-primary h-64 z-0 " + (t4[3] ? "block" : "hidden")) && U(p2, "class", m2), 8 & e3 && (x2.checked = t4[3]);
+        },
+        d(i3) {
+            i3 && E(e2), t3[7](null), t3[8](null), C2 = false, n(R2);
+        }
+    };
+}
+
+function hT(e2) {
+    let i2, s2, n2, r2 = e2[0] && lT(e2);
+    return {
+        c() {
+            i2 = P("dialog"), r2 && r2.c(), U(i2, "id", "stockModal"), U(i2, "class", "sticky bottom-0 overflow-hidden pb-4 w-auto max-w-screen-md rounded-xl md:border p-4 md:p-8 pt-8 shadow-2xl");
+        },
+        m(t3, o2) {
+            S(t3, i2, o2), r2 && r2.m(i2, null), s2 || (n2 = B(i2, "keydown", e2[5]), s2 = true);
+        },
+        p(t3, [e3]) {
+            t3[0] ? r2 ? r2.p(t3, e3) : (r2 = lT(t3), r2.c(), r2.m(i2, null)) : r2 && (r2.d(1), r2 = null);
+        },
+        i: t,
+        o: t,
+        d(t3) {
+            t3 && E(i2), r2 && r2.d(), s2 = false, n2();
+        }
+    };
+}
+
+function cT(t3, e2, i2) {
+    let s2, n2, r2, o2;
+    async function l2(t4) {
+        await async function(t5) {
+            const e3 = await f2(t5),
+                i3 = e3.timestamps.length,
+                s3 = e3.timestamps.length / (i3 / 100);
+            c2 = e3.createTradingviewSeries("close", 0, -1, s3), c2.forEach((t6) => {
+                try {
+                    if (!t6.time || "number" != typeof t6.time.seconds)
+                        throw new Error("Invalid or missing time.seconds property");
+                    {
+                        const e4 = 1e3 * t6.time.seconds,
+                            i4 = new Date(e4);
+                        if (isNaN(i4.getTime()))
+                            throw new Error("Invalid date");
+                        t6.time = {
+                            day: i4.getDate(),
+                            month: i4.getMonth() + 1,
+                            year: i4.getFullYear()
+                        };
+                    }
+                } catch (e4) {
+                    t6.time = {
+                        day: null,
+                        month: null,
+                        year: null
+                    };
+                }
+            });
+        }(t4.assetId), await async function(t5) {
+                const e3 = await f2(t5),
+                    i3 = e3.createCandlestickSeries(0, -1);
+                i3.forEach((t6) => {
+                    try {
+                        if (!t6.time || "object" != typeof t6.time || !("seconds" in t6.time))
+                            throw new Error("Invalid or missing time property");
+                        {
+                            const e4 = new Date(1e3 * t6.time.seconds);
+                            if (isNaN(e4.getTime()))
+                                throw new Error("Invalid date");
+                            t6.time = e4.toISOString().split("T")[0];
+                        }
+                    } catch (e4) {
+                        console.error("Error processing time:", t6.time, e4), t6.time = null;
+                    }
+                }), h2 = i3;
+            }(t4.assetId),
+            function() {
+                d2 || (d2 = new TwChart(o2, false));
+                d2.setTheme("dark" === Ek ? "dark" : "light"), d2.addCandlestickSeries(), d2.updateCandlestickSeriesData(h2);
+            }(),
+            function() {
+                u2 || (u2 = new TwChart(r2, true));
+                u2.setTheme("dark" === Ek ? "dark" : "light"), u2.resetAreaSeries(0), u2.resetAreaSeries(1), u2.series[0].setData(c2);
+            }(), stockModal.showModal();
+    }
+    a(t3, ud, (t4) => i2(6, s2 = t4));
+    let h2, c2, u2 = null,
+        d2 = null;
+    async function f2(t4) {
+        const e3 = rw(Tk, "twStock", t4);
+        if (e3) {
+            const t5 = (await cw(e3)).data();
+            return new Stock(t5.price);
+        }
+    }
+    const p2 = bt();
+
+    function m2() {
+        p2("close"), document.body.classList.remove("overflow-hidden");
+    }
+
+    function g2(t4) {
+        "Escape" === t4.key && m2();
+    }
+    pt(() => {
+        window.addEventListener("keydown", g2), document.body.classList.add("overflow-hidden");
+    }), yt(() => {
+        window.removeEventListener("keydown", g2), document.body.classList.remove("overflow-hidden");
+    });
+    let y2 = true;
+    return t3.$$.update = () => {
+        64 & t3.$$.dirty && i2(0, n2 = s2), 1 & t3.$$.dirty && n2 && l2(n2);
+    }, [n2, r2, o2, y2, m2, g2, s2, function(t4) {
+        xt[t4 ? "unshift" : "push"](() => {
+            r2 = t4, i2(1, r2);
+        });
+    }, function(t4) {
+        xt[t4 ? "unshift" : "push"](() => {
+            o2 = t4, i2(2, o2);
+        });
+    }, function() {
+        y2 = this.checked, i2(3, y2);
+    }];
+}
+we(PositionDataTable, {
+    rows: {},
+    columns: {}
+}, ["name", "action", "entryDate", "profit", "currentWeight", "RSV"], [], true);
+class StockModal extends SvelteComponent {
+    constructor(t3) {
+        super(), ve(this, t3, cT, hT, o, {});
+    }
+}
+
+function uT(t3) {
+    w(t3, "svelte-1nx0ef2", ".lining-nums.svelte-1nx0ef2{font-weight:600;font-size:18px;line-height:32px}");
+}
+
+function dT(t3, e2, i2) {
+    const s2 = t3.slice();
+    return s2[26] = e2[i2], s2;
+}
+
+function fT(t3, e2, i2) {
+    const s2 = t3.slice();
+    return s2[26] = e2[i2], s2;
+}
+
+function pT(t3, e2, i2) {
+    const s2 = t3.slice();
+    return s2[31] = e2[i2][0], s2[32] = e2[i2][1], s2;
+}
+
+function mT(t3) {
+    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2 = ue(Object.entries(t3[10])),
+        u2 = [];
+    for (let e3 = 0; e3 < c2.length; e3 += 1)
+        u2[e3] = yT(pT(t3, c2, e3));
+    let d2 = (0 !== t3[7].length || 0 !== t3[6].length) && vT(t3),
+        f2 = (0 !== t3[7].length || 0 !== t3[6].length) && MT();
+    o2 = new PositionDataTable({
+        props: {
+            rows: t3[2],
+            columns: t3[8],
+            $$slots: {
+                RSV: [$T, ({
+                    row: t4
+                }) => ({
+                    25: t4
+                }), ({
+                    row: t4
+                }) => [t4 ? 33554432 : 0]],
+                currentWeight: [OT, ({
+                    row: t4
+                }) => ({
+                    25: t4
+                }), ({
+                    row: t4
+                }) => [t4 ? 33554432 : 0]],
+                entryDate: [LT, ({
+                    row: t4
+                }) => ({
+                    25: t4
+                }), ({
+                    row: t4
+                }) => [t4 ? 33554432 : 0]],
+                profit: [AT, ({
+                    row: t4
+                }) => ({
+                    25: t4
+                }), ({
+                    row: t4
+                }) => [t4 ? 33554432 : 0]],
+                name: [RT, ({
+                    row: t4
+                }) => ({
+                    25: t4
+                }), ({
+                    row: t4
+                }) => [t4 ? 33554432 : 0]]
+            },
+            $$scope: {
+                ctx: t3
+            }
+        }
+    }), o2.$on("close", t3[12]);
+    let p2 = t3[4] && VT(t3);
+    return {
+        c() {
+            e2 = P("div");
+            for (let t4 = 0; t4 < u2.length; t4 += 1)
+                u2[t4].c();
+            i2 = $(), d2 && d2.c(), s2 = $(), n2 = P("div"), f2 && f2.c(), r2 = $(), me(o2.$$.fragment), a2 = $(), p2 && p2.c(), l2 = z(), U(e2, "class", "hidden sm:flex gap-2 md:gap-4 stats bg-transparent sm:text-center min-w-full mb-4"), U(n2, "class", "md:rounded-2xl h-full bg-base-200 my-4 p-4 sm:p-8 sm:border relative");
+        },
+        m(t4, c3) {
+            S(t4, e2, c3);
+            for (let t5 = 0; t5 < u2.length; t5 += 1)
+                u2[t5] && u2[t5].m(e2, null);
+            S(t4, i2, c3), d2 && d2.m(t4, c3), S(t4, s2, c3), S(t4, n2, c3), f2 && f2.m(n2, null), _(n2, r2), ge(o2, n2, null), S(t4, a2, c3), p2 && p2.m(t4, c3), S(t4, l2, c3), h2 = true;
+        },
+        p(t4, i3) {
+            if (1027 & i3[0]) {
+                let s3;
+                for (c2 = ue(Object.entries(t4[10])), s3 = 0; s3 < c2.length; s3 += 1) {
+                    const n3 = pT(t4, c2, s3);
+                    u2[s3] ? u2[s3].p(n3, i3) : (u2[s3] = yT(n3), u2[s3].c(), u2[s3].m(e2, null));
+                }
+                for (; s3 < u2.length; s3 += 1)
+                    u2[s3].d(1);
+                u2.length = c2.length;
+            }
+            0 !== t4[7].length || 0 !== t4[6].length ? d2 ? d2.p(t4, i3) : (d2 = vT(t4), d2.c(), d2.m(s2.parentNode, s2)) : d2 && (d2.d(1), d2 = null), 0 !== t4[7].length || 0 !== t4[6].length ? f2 || (f2 = MT(), f2.c(), f2.m(n2, r2)) : f2 && (f2.d(1), f2 = null);
+            const a3 = {};
+            4 & i3[0] && (a3.rows = t4[2]), 256 & i3[0] && (a3.columns = t4[8]), 33554449 & i3[0] | 16 & i3[1] && (a3.$$scope = {
+                dirty: i3,
+                ctx: t4
+            }), o2.$set(a3), t4[4] ? p2 ? (p2.p(t4, i3), 16 & i3[0] && le(p2, 1)) : (p2 = VT(t4), p2.c(), le(p2, 1), p2.m(l2.parentNode, l2)) : p2 && (oe(), he(p2, 1, 1, () => {
+                p2 = null;
+            }), ae());
+        },
+        i(t4) {
+            h2 || (le(o2.$$.fragment, t4), le(p2), h2 = true);
+        },
+        o(t4) {
+            he(o2.$$.fragment, t4), he(p2), h2 = false;
+        },
+        d(t4) {
+            t4 && (E(e2), E(i2), E(s2), E(n2), E(a2), E(l2)), C(u2, t4), d2 && d2.d(t4), f2 && f2.d(), ye(o2), p2 && p2.d(t4);
+        }
+    };
+}
+
+function gT(t3) {
+    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2 = t3[1]("position." + t3[31]) + "",
+        d2 = t3[32].formatter(t3[0][t3[31]]) + "";
+    return {
+        c() {
+            e2 = P("div"), i2 = P("span"), s2 = D(u2), n2 = P("br"), r2 = $(), o2 = P("span"), a2 = D(d2), l2 = $(), h2 = P("span"), h2.textContent = `${t3[32].unit}`, c2 = $(), U(i2, "class", "text-base-content-100"), U(o2, "class", "text-base-content-200 text-2xl font-bold"), U(h2, "class", "text-base-content-200"), U(e2, "class", "flex-1");
+        },
+        m(t4, u3) {
+            S(t4, e2, u3), _(e2, i2), _(i2, s2), _(e2, n2), _(e2, r2), _(e2, o2), _(o2, a2), _(e2, l2), _(e2, h2), _(e2, c2);
+        },
+        p(t4, e3) {
+            2 & e3[0] && u2 !== (u2 = t4[1]("position." + t4[31]) + "") && H(s2, u2), 1 & e3[0] && d2 !== (d2 = t4[32].formatter(t4[0][t4[31]]) + "") && H(a2, d2);
+        },
+        d(t4) {
+            t4 && E(e2);
+        }
+    };
+}
+
+function yT(t3) {
+    let e2, i2 = !("shown" in t3[32]) || t3[32].shown(t3[0][t3[31]]),
+        s2 = i2 && gT(t3);
+    return {
+        c() {
+            s2 && s2.c(), e2 = z();
+        },
+        m(t4, i3) {
+            s2 && s2.m(t4, i3), S(t4, e2, i3);
+        },
+        p(t4, n2) {
+            1 & n2[0] && (i2 = !("shown" in t4[32]) || t4[32].shown(t4[0][t4[31]])), i2 ? s2 ? s2.p(t4, n2) : (s2 = gT(t4), s2.c(), s2.m(e2.parentNode, e2)) : s2 && (s2.d(1), s2 = null);
+        },
+        d(t4) {
+            t4 && E(e2), s2 && s2.d(t4);
+        }
+    };
+}
+
+function vT(t3) {
+    let e2, i2, s2, n2 = 0 !== t3[6].length && bT(t3),
+        r2 = 0 !== t3[6].length && 0 !== t3[7].length && TT(),
+        o2 = t3[7] && ST(t3);
+    return {
+        c() {
+            e2 = P("div"), n2 && n2.c(), i2 = $(), r2 && r2.c(), s2 = $(), o2 && o2.c(), U(e2, "class", "md:rounded-2xl h-full border bg-base-200 p-4 sm:p-8");
+        },
+        m(t4, a2) {
+            S(t4, e2, a2), n2 && n2.m(e2, null), _(e2, i2), r2 && r2.m(e2, null), _(e2, s2), o2 && o2.m(e2, null);
+        },
+        p(t4, a2) {
+            0 !== t4[6].length ? n2 ? n2.p(t4, a2) : (n2 = bT(t4), n2.c(), n2.m(e2, i2)) : n2 && (n2.d(1), n2 = null), 0 !== t4[6].length && 0 !== t4[7].length ? r2 || (r2 = TT(), r2.c(), r2.m(e2, s2)) : r2 && (r2.d(1), r2 = null), t4[7] ? o2 ? o2.p(t4, a2) : (o2 = ST(t4), o2.c(), o2.m(e2, null)) : o2 && (o2.d(1), o2 = null);
+        },
+        d(t4) {
+            t4 && E(e2), n2 && n2.d(), r2 && r2.d(), o2 && o2.d();
+        }
+    };
+}
+
+function bT(t3) {
+    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2, d2, f2 = {
+            close: "收盤",
+            open: "開盤"
+        } [t3[0].entryTradePrice] + "",
+        p2 = ue(t3[6]),
+        m2 = [];
+    for (let e3 = 0; e3 < p2.length; e3 += 1)
+        m2[e3] = kT(fT(t3, p2, e3));
+    return {
+        c() {
+            e2 = P("div"), i2 = P("h2"), s2 = D(f2), n2 = D("買入"), r2 = $(), o2 = P("input"), a2 = $(), l2 = P("span"), l2.textContent = "顯示買入部位", h2 = $(), c2 = P("div");
+            for (let t4 = 0; t4 < m2.length; t4 += 1)
+                m2[t4].c();
+            U(o2, "type", "checkbox"), U(o2, "class", "ml-4 toggle toggle-sm"), U(l2, "class", "ml-2 text-sm font-normal"), U(e2, "class", "text-2xl text-base-content-200 font-bold items-center flex"), U(c2, "class", "grid grid-cols-2 md:grid-cols-3 gap-4 pt-1 mt-4");
+        },
+        m(f3, p3) {
+            S(f3, e2, p3), _(e2, i2), _(i2, s2), _(i2, n2), _(e2, r2), _(e2, o2), o2.checked = t3[3], _(e2, a2), _(e2, l2), S(f3, h2, p3), S(f3, c2, p3);
+            for (let t4 = 0; t4 < m2.length; t4 += 1)
+                m2[t4] && m2[t4].m(c2, null);
+            u2 || (d2 = B(o2, "change", t3[18]), u2 = true);
+        },
+        p(t4, e3) {
+            if (1 & e3[0] && f2 !== (f2 = {
+                    close: "收盤",
+                    open: "開盤"
+                } [t4[0].entryTradePrice] + "") && H(s2, f2), 8 & e3[0] && (o2.checked = t4[3]), 72 & e3[0]) {
+                let i3;
+                for (p2 = ue(t4[6]), i3 = 0; i3 < p2.length; i3 += 1) {
+                    const s3 = fT(t4, p2, i3);
+                    m2[i3] ? m2[i3].p(s3, e3) : (m2[i3] = kT(s3), m2[i3].c(), m2[i3].m(c2, null));
+                }
+                for (; i3 < m2.length; i3 += 1)
+                    m2[i3].d(1);
+                m2.length = p2.length;
+            }
+        },
+        d(t4) {
+            t4 && (E(e2), E(h2), E(c2)), C(m2, t4), u2 = false, d2();
+        }
+    };
+}
+
+function _T(t3) {
+    let e2, i2 = t3[26].assetName[0] + "";
+    return {
+        c() {
+            e2 = D(i2);
+        },
+        m(t4, i3) {
+            S(t4, e2, i3);
+        },
+        p(t4, s2) {
+            64 & s2[0] && i2 !== (i2 = t4[26].assetName[0] + "") && H(e2, i2);
+        },
+        d(t4) {
+            t4 && E(e2);
+        }
+    };
+}
+
+function wT(t3) {
+    let e2, i2, s2, n2, r2 = t3[26].assetName + "";
+    return {
+        c() {
+            e2 = P("span"), i2 = D(r2), s2 = $(), n2 = P("br"), U(e2, "class", "whitespace-nowrap font-bold text-base-content-200");
+        },
+        m(t4, r3) {
+            S(t4, e2, r3), _(e2, i2), S(t4, s2, r3), S(t4, n2, r3);
+        },
+        p(t4, e3) {
+            64 & e3[0] && r2 !== (r2 = t4[26].assetName + "") && H(i2, r2);
+        },
+        d(t4) {
+            t4 && (E(e2), E(s2), E(n2));
+        }
+    };
+}
+
+function xT(t3) {
+    let e2, i2, s2, n2, r2 = Math.abs(100 * t3[26].nextWeight).toFixed(1) + "";
+    return {
+        c() {
+            e2 = P("div"), i2 = P("span"), s2 = D(r2), n2 = D("%"), G(i2, "color", t3[26].nextWeight > 0 ? vu("red") : bu("red")), U(i2, "class", "font-light lining-nums ml-4 svelte-1nx0ef2"), U(e2, "class", "flex-grow text-left");
+        },
+        m(t4, r3) {
+            S(t4, e2, r3), _(e2, i2), _(i2, s2), _(i2, n2);
+        },
+        p(t4, e3) {
+            64 & e3[0] && r2 !== (r2 = Math.abs(100 * t4[26].nextWeight).toFixed(1) + "") && H(s2, r2), 64 & e3[0] && G(i2, "color", t4[26].nextWeight > 0 ? vu("red") : bu("red"));
+        },
+        d(t4) {
+            t4 && E(e2);
+        }
+    };
+}
+
+function kT(t3) {
+    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2 = t3[26].assetId + "",
+        d2 = t3[26].assetName && _T(t3),
+        f2 = t3[26].assetName && wT(t3),
+        p2 = t3[3] && xT(t3);
+    return {
+        c() {
+            e2 = P("div"), i2 = P("div"), s2 = P("div"), d2 && d2.c(), n2 = $(), r2 = P("div"), f2 && f2.c(), o2 = $(), a2 = P("span"), l2 = D(u2), h2 = $(), p2 && p2.c(), c2 = $(), U(s2, "class", "mr-3 w-8 h-8 rounded-full text-white font-bold justify-center items-center flex"), G(s2, "background", rT(t3[26].assetName[0])), U(a2, "class", "font-light text-base-content-300"), U(i2, "class", "flex flex-nowrap items-center"), U(e2, "class", "text-base font-bold relative text-ellipsis overflow-hidden text-left");
+        },
+        m(t4, u3) {
+            S(t4, e2, u3), _(e2, i2), _(i2, s2), d2 && d2.m(s2, null), _(i2, n2), _(i2, r2), f2 && f2.m(r2, null), _(r2, o2), _(r2, a2), _(a2, l2), _(i2, h2), p2 && p2.m(i2, null), _(e2, c2);
+        },
+        p(t4, e3) {
+            t4[26].assetName ? d2 ? d2.p(t4, e3) : (d2 = _T(t4), d2.c(), d2.m(s2, null)) : d2 && (d2.d(1), d2 = null), 64 & e3[0] && G(s2, "background", rT(t4[26].assetName[0])), t4[26].assetName ? f2 ? f2.p(t4, e3) : (f2 = wT(t4), f2.c(), f2.m(r2, o2)) : f2 && (f2.d(1), f2 = null), 64 & e3[0] && u2 !== (u2 = t4[26].assetId + "") && H(l2, u2), t4[3] ? p2 ? p2.p(t4, e3) : (p2 = xT(t4), p2.c(), p2.m(i2, null)) : p2 && (p2.d(1), p2 = null);
+        },
+        d(t4) {
+            t4 && E(e2), d2 && d2.d(), f2 && f2.d(), p2 && p2.d();
+        }
+    };
+}
+
+function TT(t3) {
+    let e2;
+    return {
+        c() {
+            e2 = P("hr"), U(e2, "class", "my-6");
+        },
+        m(t4, i2) {
+            S(t4, e2, i2);
+        },
+        d(t4) {
+            t4 && E(e2);
+        }
+    };
+}
+
+function ST(t3) {
+    let e2, i2, s2, n2, r2, o2 = {
+            close: "收盤",
+            open: "開盤"
+        } [t3[0].entryTradePrice] + "",
+        a2 = ue(t3[7]),
+        l2 = [];
+    for (let e3 = 0; e3 < a2.length; e3 += 1)
+        l2[e3] = IT(dT(t3, a2, e3));
+    return {
+        c() {
+            e2 = P("h2"), i2 = D(o2), s2 = D("賣出"), n2 = $(), r2 = P("div");
+            for (let t4 = 0; t4 < l2.length; t4 += 1)
+                l2[t4].c();
+            U(e2, "class", "text-2xl text-base-content-200 font-bold flex items-center"), U(r2, "class", "grid grid-cols-2 md:grid-cols-3 gap-4 pt-1 mt-4");
+        },
+        m(t4, o3) {
+            S(t4, e2, o3), _(e2, i2), _(e2, s2), S(t4, n2, o3), S(t4, r2, o3);
+            for (let t5 = 0; t5 < l2.length; t5 += 1)
+                l2[t5] && l2[t5].m(r2, null);
+        },
+        p(t4, e3) {
+            if (1 & e3[0] && o2 !== (o2 = {
+                    close: "收盤",
+                    open: "開盤"
+                } [t4[0].entryTradePrice] + "") && H(i2, o2), 128 & e3[0]) {
+                let i3;
+                for (a2 = ue(t4[7]), i3 = 0; i3 < a2.length; i3 += 1) {
+                    const s3 = dT(t4, a2, i3);
+                    l2[i3] ? l2[i3].p(s3, e3) : (l2[i3] = IT(s3), l2[i3].c(), l2[i3].m(r2, null));
+                }
+                for (; i3 < l2.length; i3 += 1)
+                    l2[i3].d(1);
+                l2.length = a2.length;
+            }
+        },
+        d(t4) {
+            t4 && (E(e2), E(n2), E(r2)), C(l2, t4);
+        }
+    };
+}
+
+function ET(t3) {
+    let e2, i2 = t3[26].assetName[0] + "";
+    return {
+        c() {
+            e2 = D(i2);
+        },
+        m(t4, i3) {
+            S(t4, e2, i3);
+        },
+        p(t4, s2) {
+            128 & s2[0] && i2 !== (i2 = t4[26].assetName[0] + "") && H(e2, i2);
+        },
+        d(t4) {
+            t4 && E(e2);
+        }
+    };
+}
+
+function CT(t3) {
+    let e2, i2, s2, n2, r2 = t3[26].assetName + "";
+    return {
+        c() {
+            e2 = P("span"), i2 = D(r2), s2 = $(), n2 = P("br"), U(e2, "class", "whitespace-nowrap font-bold text-base-content-300");
+        },
+        m(t4, r3) {
+            S(t4, e2, r3), _(e2, i2), S(t4, s2, r3), S(t4, n2, r3);
+        },
+        p(t4, e3) {
+            128 & e3[0] && r2 !== (r2 = t4[26].assetName + "") && H(i2, r2);
+        },
+        d(t4) {
+            t4 && (E(e2), E(s2), E(n2));
+        }
+    };
+}
+
+function IT(t3) {
+    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2 = t3[26].assetId + "",
+        u2 = t3[26].assetName && ET(t3),
+        d2 = t3[26].assetName && CT(t3);
+    return {
+        c() {
+            e2 = P("div"), i2 = P("div"), s2 = P("div"), u2 && u2.c(), n2 = $(), r2 = P("div"), d2 && d2.c(), o2 = $(), a2 = P("span"), l2 = D(c2), h2 = $(), U(s2, "class", "mr-3 w-8 h-8 rounded-full text-white font-bold justify-center items-center flex"), G(s2, "background", rT(t3[26].assetName[0])), U(a2, "class", "font-light text-base-content-200"), U(i2, "class", "flex flex-nowrap items-center"), U(e2, "class", "text-base font-bold relative text-ellipsis overflow-hidden text-left");
+        },
+        m(t4, c3) {
+            S(t4, e2, c3), _(e2, i2), _(i2, s2), u2 && u2.m(s2, null), _(i2, n2), _(i2, r2), d2 && d2.m(r2, null), _(r2, o2), _(r2, a2), _(a2, l2), _(e2, h2);
+        },
+        p(t4, e3) {
+            t4[26].assetName ? u2 ? u2.p(t4, e3) : (u2 = ET(t4), u2.c(), u2.m(s2, null)) : u2 && (u2.d(1), u2 = null), 128 & e3[0] && G(s2, "background", rT(t4[26].assetName[0])), t4[26].assetName ? d2 ? d2.p(t4, e3) : (d2 = CT(t4), d2.c(), d2.m(r2, o2)) : d2 && (d2.d(1), d2 = null), 128 & e3[0] && c2 !== (c2 = t4[26].assetId + "") && H(l2, c2);
+        },
+        d(t4) {
+            t4 && E(e2), u2 && u2.d(), d2 && d2.d();
+        }
+    };
+}
+
+function MT(t3) {
+    let e2;
+    return {
+        c() {
+            e2 = P("h2"), e2.textContent = "當前部位", U(e2, "class", "text-2xl text-base-content-200 font-bold mb-2");
+        },
+        m(t4, i2) {
+            S(t4, e2, i2);
+        },
+        d(t4) {
+            t4 && E(e2);
+        }
+    };
+}
+
+function PT(t3) {
+    let e2, i2, s2, n2, r2 = (t3[25].assetName ? t3[25].assetName : "") + "";
+    return {
+        c() {
+            e2 = P("span"), i2 = D(r2), s2 = $(), n2 = P("br"), U(e2, "class", "whitespace-nowrap font-bold text-base-content-300");
+        },
+        m(t4, r3) {
+            S(t4, e2, r3), _(e2, i2), S(t4, s2, r3), S(t4, n2, r3);
+        },
+        p(t4, e3) {
+            33554432 & e3[0] && r2 !== (r2 = (t4[25].assetName ? t4[25].assetName : "") + "") && H(i2, r2);
+        },
+        d(t4) {
+            t4 && (E(e2), E(s2), E(n2));
+        }
+    };
+}
+
+function RT(t3) {
+    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2, d2 = (t3[25].assetName ? t3[25].assetName[0] : "") + "",
+        f2 = t3[25].assetId + "",
+        p2 = t3[25].assetName && PT(t3);
+
+    function m2() {
+        return t3[19](t3[25]);
+    }
+    return {
+        c() {
+            e2 = P("div"), i2 = P("div"), s2 = P("div"), n2 = D(d2), r2 = $(), o2 = P("div"), p2 && p2.c(), a2 = $(), l2 = P("span"), h2 = D(f2), U(s2, "class", "mr-3 w-8 h-8 rounded-full text-white font-bold justify-center items-center flex"), G(s2, "background", rT(t3[25].assetName[0])), U(l2, "class", "font-light text-base-content-200"), U(i2, "class", "flex flex-nowrap items-center"), U(e2, "slot", "name"), U(e2, "class", "text-base font-bold relative text-ellipsis overflow-hidden text-left cursor-pointer");
+        },
+        m(t4, d3) {
+            S(t4, e2, d3), _(e2, i2), _(i2, s2), _(s2, n2), _(i2, r2), _(i2, o2), p2 && p2.m(o2, null), _(o2, a2), _(o2, l2), _(l2, h2), c2 || (u2 = B(e2, "click", m2), c2 = true);
+        },
+        p(e3, i3) {
+            t3 = e3, 33554432 & i3[0] && d2 !== (d2 = (t3[25].assetName ? t3[25].assetName[0] : "") + "") && H(n2, d2), 33554432 & i3[0] && G(s2, "background", rT(t3[25].assetName[0])), t3[25].assetName ? p2 ? p2.p(t3, i3) : (p2 = PT(t3), p2.c(), p2.m(o2, a2)) : p2 && (p2.d(1), p2 = null), 33554432 & i3[0] && f2 !== (f2 = t3[25].assetId + "") && H(h2, f2);
+        },
+        d(t4) {
+            t4 && E(e2), p2 && p2.d(), c2 = false, u2();
+        }
+    };
+}
+
+function AT(t3) {
+    let e2, i2, s2, n2, r2, o2 = t3[9](t3[25].profit) + "",
+        a2 = (100 * t3[25].profit).toFixed(2) + "";
+    return {
+        c() {
+            e2 = P("div"), i2 = P("span"), s2 = D(o2), n2 = D(a2), r2 = D("%"), G(i2, "color", t3[25].profit > 0 ? vu("red") : bu("red")), U(e2, "slot", "profit"), U(e2, "class", "lining-nums svelte-1nx0ef2");
+        },
+        m(t4, o3) {
+            S(t4, e2, o3), _(e2, i2), _(i2, s2), _(i2, n2), _(i2, r2);
+        },
+        p(t4, e3) {
+            33554432 & e3[0] && o2 !== (o2 = t4[9](t4[25].profit) + "") && H(s2, o2), 33554432 & e3[0] && a2 !== (a2 = (100 * t4[25].profit).toFixed(2) + "") && H(n2, a2), 33554432 & e3[0] && G(i2, "color", t4[25].profit > 0 ? vu("red") : bu("red"));
+        },
+        d(t4) {
+            t4 && E(e2);
+        }
+    };
+}
+
+function DT(t3) {
+    let e2, i2, s2 = t3[25].entryDate.toLocaleTimeString() + "";
+    return {
+        c() {
+            e2 = P("br"), i2 = D(s2);
+        },
+        m(t4, s3) {
+            S(t4, e2, s3), S(t4, i2, s3);
+        },
+        p(t4, e3) {
+            33554432 & e3[0] && s2 !== (s2 = t4[25].entryDate.toLocaleTimeString() + "") && H(i2, s2);
+        },
+        d(t4) {
+            t4 && (E(e2), E(i2));
+        }
+    };
+}
+
+function LT(t3) {
+    let e2, i2, s2, n2, r2, o2, a2, l2, h2 = t3[25].currentPrice.toFixed(2) + "",
+        c2 = t3[25].entryDate.toLocaleDateString() + "",
+        u2 = !t3[0].isDailyStrategy && DT(t3);
+    return {
+        c() {
+            e2 = P("div"), i2 = P("span"), s2 = D(h2), n2 = P("br"), r2 = $(), o2 = P("span"), a2 = D(c2), l2 = $(), u2 && u2.c(), U(i2, "class", "lining-nums svelte-1nx0ef2"), U(o2, "class", "text-sm"), U(e2, "slot", "entryDate");
+        },
+        m(t4, h3) {
+            S(t4, e2, h3), _(e2, i2), _(i2, s2), _(e2, n2), _(e2, r2), _(e2, o2), _(o2, a2), _(e2, l2), u2 && u2.m(e2, null);
+        },
+        p(t4, i3) {
+            33554432 & i3[0] && h2 !== (h2 = t4[25].currentPrice.toFixed(2) + "") && H(s2, h2), 33554432 & i3[0] && c2 !== (c2 = t4[25].entryDate.toLocaleDateString() + "") && H(a2, c2), t4[0].isDailyStrategy ? u2 && (u2.d(1), u2 = null) : u2 ? u2.p(t4, i3) : (u2 = DT(t4), u2.c(), u2.m(e2, null));
+        },
+        d(t4) {
+            t4 && E(e2), u2 && u2.d();
+        }
+    };
+}
+
+function OT(t3) {
+    let e2, i2, s2, n2, r2 = (100 * t3[25].currentWeight).toFixed(1) + "";
+    return {
+        c() {
+            e2 = P("div"), i2 = P("span"), s2 = D(r2), n2 = D("%"), G(i2, "color", t3[25].currentWeight > 0 ? vu("red") : bu("red")), U(e2, "slot", "currentWeight"), U(e2, "class", "lining-nums svelte-1nx0ef2");
+        },
+        m(t4, r3) {
+            S(t4, e2, r3), _(e2, i2), _(i2, s2), _(i2, n2);
+        },
+        p(t4, e3) {
+            33554432 & e3[0] && r2 !== (r2 = (100 * t4[25].currentWeight).toFixed(1) + "") && H(s2, r2), 33554432 & e3[0] && G(i2, "color", t4[25].currentWeight > 0 ? vu("red") : bu("red"));
+        },
+        d(t4) {
+            t4 && E(e2);
+        }
+    };
+}
+
+function FT(e2) {
+    let i2;
+    return {
+        c() {
+            i2 = D("-");
+        },
+        m(t3, e3) {
+            S(t3, i2, e3);
+        },
+        p: t,
+        d(t3) {
+            t3 && E(i2);
+        }
+    };
+}
+
+function NT(t3) {
+    let e2, i2, s2, n2, r2, o2, a2 = (100 * t3[25].rsv20).toFixed(2) + "";
+    return {
+        c() {
+            e2 = D(a2), i2 = D("%"), s2 = P("br"), n2 = $(), r2 = P("progress"), U(r2, "class", "progress progress-primary w-32"), r2.value = o2 = t3[25].rsv20, U(r2, "max", "1");
+        },
+        m(t4, o3) {
+            S(t4, e2, o3), S(t4, i2, o3), S(t4, s2, o3), S(t4, n2, o3), S(t4, r2, o3);
+        },
+        p(t4, i3) {
+            33554432 & i3[0] && a2 !== (a2 = (100 * t4[25].rsv20).toFixed(2) + "") && H(e2, a2), 33554432 & i3[0] && o2 !== (o2 = t4[25].rsv20) && (r2.value = o2);
+        },
+        d(t4) {
+            t4 && (E(e2), E(i2), E(s2), E(n2), E(r2));
+        }
+    };
+}
+
+function $T(t3) {
+    let e2, i2;
+
+    function s2(t4, e3) {
+        return 33554432 & e3[0] && (i2 = null), null == i2 && (i2 = !!isFinite(t4[25].rsv20)), i2 ? NT : FT;
+    }
+    let n2 = s2(t3, [-1, -1]),
+        r2 = n2(t3);
+    return {
+        c() {
+            e2 = P("div"), r2.c(), U(e2, "slot", "RSV"), U(e2, "class", "text-base-content-100");
+        },
+        m(t4, i3) {
+            S(t4, e2, i3), r2.m(e2, null);
+        },
+        p(t4, i3) {
+            n2 === (n2 = s2(t4, i3)) && r2 ? r2.p(t4, i3) : (r2.d(1), r2 = n2(t4), r2 && (r2.c(), r2.m(e2, null)));
+        },
+        d(t4) {
+            t4 && E(e2), r2.d();
+        }
+    };
+}
+
+function VT(e2) {
+    let i2, s2;
+    return i2 = new StockModal({}), i2.$on("close", e2[11]), {
+        c() {
+            me(i2.$$.fragment);
+        },
+        m(t3, e3) {
+            ge(i2, t3, e3), s2 = true;
+        },
+        p: t,
+        i(t3) {
+            s2 || (le(i2.$$.fragment, t3), s2 = true);
+        },
+        o(t3) {
+            he(i2.$$.fragment, t3), s2 = false;
+        },
+        d(t3) {
+            ye(i2, t3);
+        }
+    };
+}
+
+function zT(t3) {
+    let e2, i2, s2 = t3[0] && mT(t3);
+    return {
+        c() {
+            e2 = P("div"), s2 && s2.c(), U(e2, "class", "text-base-content w-full relative");
+        },
+        m(n2, r2) {
+            S(n2, e2, r2), s2 && s2.m(e2, null), t3[20](e2), i2 = true;
+        },
+        p(t4, i3) {
+            t4[0] ? s2 ? (s2.p(t4, i3), 1 & i3[0] && le(s2, 1)) : (s2 = mT(t4), s2.c(), le(s2, 1), s2.m(e2, null)) : s2 && (oe(), he(s2, 1, 1, () => {
+                s2 = null;
+            }), ae());
+        },
+        i(t4) {
+            i2 || (le(s2), i2 = true);
+        },
+        o(t4) {
+            he(s2), i2 = false;
+        },
+        d(i3) {
+            i3 && E(e2), s2 && s2.d(), t3[20](null);
+        }
+    };
+}
+we(StockModal, {}, [], [], true);
+
+function BT(t3) {
+    const e2 = {};
+    for (const [i2, s2] of t3.entries())
+        e2[i2] = s2;
+    return e2.action && (e2.action = BT(e2.action)), e2;
+}
+
+function UT(t3 = null) {
+    !t3 || t3 instanceof Date || (t3 = new Date(t3)), t3 || (t3 = /* @__PURE__ */ new Date());
+    const e2 = t3.getTime() + 6e4 * t3.getTimezoneOffset(),
+        i2 = new Date(e2 + 288e5);
+    return i2.setHours(15, 0, 0, 0), i2;
+}
+
+function jT(t3, e2, i2) {
+    let s2, n2, r2, o2, a2, {
+            reportPosition: l2 = null
+        } = e2,
+        {
+            lang: h2 = "en"
+        } = e2;
+    let c2 = null,
+        u2 = [];
+    pt(async () => {
+        let t4 = null;
+        t4 = l2, i2(16, u2 = []), t4 ? (i2(0, c2 = t4.positionConfig), null !== c2 && (i2(0, c2.created = new Date(c2.created), c2), i2(0, c2.scheduled = new Date(c2.scheduled), c2)), t4.positions.forEach((t5) => {
+            t5 instanceof Map && (t5 = BT(t5)), t5.entryDate = new Date(t5.entryDate), t5.exitDate = new Date(t5.exitDate), t5.entrySigDate = new Date(t5.entrySigDate), t5.exitSigDate = new Date(t5.exitSigDate), t5.action && (t5.action.date = new Date(t5.action.date)), aT(t5) ? u2.push(t5) : console.log("Invalid position:", t5);
+        })) : console.log("No such document!"), window.positions = u2;
+    });
+    const d2 = {
+        resample: {
+            formatter: (t4) => s2("position.resampleValue." + t4) || t4,
+            unit: ""
+        },
+        created: {
+            formatter: (t4) => c2.isDailyStrategy ? t4.toLocaleDateString() : t4.toLocaleString(),
+            unit: ""
+        },
+        sl: {
+            shown: (t4) => 1 != t4,
+            formatter: (t4) => 100 !== t4 ? -(100 * t4).toFixed() : "無",
+            unit: "%"
+        },
+        tp: {
+            shown: (t4) => t4 < 1e5,
+            formatter: (t4) => "+" + (100 * t4).toFixed(),
+            unit: "%"
+        },
+        ts: {
+            shown: (t4) => t4 < 1e5,
+            formatter: (t4) => "+" + (100 * t4).toFixed(),
+            unit: "%"
+        }
+    };
+    let f2;
+    const p2 = /* @__PURE__ */ new Date();
+    let m2, g2 = false,
+        y2 = false;
+    async function v2(t4) {
+        await Lt(), await new Promise((t5) => setTimeout(t5, 500));
+        let e3 = m2.scrollHeight + 120,
+            i3 = t4 ? t4.assetId : "";
+        window.parent.postMessage({
+            frameHeight: e3,
+            tab: "選股 " + i3
+        }, "*");
+    }
+    return t3.$$set = (t4) => {
+        "reportPosition" in t4 && i2(14, l2 = t4.reportPosition), "lang" in t4 && i2(15, h2 = t4.lang);
+    }, t3.$$.update = () => {
+        32768 & t3.$$.dirty[0] && i2(1, s2 = (t4) => "en" === h2 ? sl(t4) : nl(t4)), 65536 & t3.$$.dirty[0] && i2(17, n2 = u2.sort((t4, e3) => {
+            var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
+            return "entry" === ((_a2 = t4.action) == null ? void 0 : _a2.type) && "entry" !== ((_b2 = e3.action) == null ? void 0 : _b2.type) ? -1 : "entry" !== ((_c2 = t4.action) == null ? void 0 : _c2.type) && "entry" === ((_d2 = e3.action) == null ? void 0 : _d2.type) ? 1 : "exit" === ((_e2 = t4.action) == null ? void 0 : _e2.type) && "exit" !== ((_f2 = e3.action) == null ? void 0 : _f2.type) ? -1 : "exit" !== ((_g2 = t4.action) == null ? void 0 : _g2.type) && "exit" === ((_h2 = e3.action) == null ? void 0 : _h2.type) ? 1 : e3.entryDate.getTime() - t4.entryDate.getTime();
+        })), 131072 & t3.$$.dirty[0] && i2(2, f2 = n2.filter((t4) => "hold" == t4.action.type || "exit" == t4.action.type)), 2 & t3.$$.dirty[0] && i2(8, r2 = [{
+            key: "name",
+            name: s2("position.assetName"),
+            sort: false,
+            width: "160px"
+        }, {
+            key: "profit",
+            name: s2("position.profit"),
+            sort: true,
+            width: "160px"
+        }, {
+            key: "entryDate",
+            name: s2("position.entryDate"),
+            sort: true,
+            width: "180px"
+        }, {
+            key: "currentWeight",
+            name: s2("position.currentWeight"),
+            sort: true,
+            width: "160px"
+        }, {
+            key: "RSV",
+            name: s2("position.RSV"),
+            sort: false,
+            width: "240px"
+        }]), 131073 & t3.$$.dirty[0] && i2(7, o2 = n2.filter((t4) => {
+            var _a2, _b2, _c2;
+            return t4.exitSigDate >= new Date(c2.lastTimestamp) && p2 > UT(t4.exitSigDate) && (0 === t4.nextWeight || "exit" === ((_a2 = t4.action) == null ? void 0 : _a2.type) && ("tp" === ((_b2 = t4.action) == null ? void 0 : _b2.reason) || "sl" === ((_c2 = t4.action) == null ? void 0 : _c2.reason))) || function(t5) {
+                var _a3, _b3;
+                return ("tp_enter" === ((_a3 = t5.action) == null ? void 0 : _a3.reason) || "sl_enter" === ((_b3 = t5.action) == null ? void 0 : _b3.reason)) && 0 !== t5.currentWeight && c2.scheduled && p2 < UT(c2.scheduled);
+            }(t4);
+        })), 131073 & t3.$$.dirty[0] && i2(6, a2 = n2.filter((t4) => t4.entrySigDate >= new Date(c2.lastTimestamp) && p2 > UT(t4.entrySigDate) && 0 !== t4.nextWeight || function(t5) {
+            var _a2, _b2;
+            return ("tp_enter" === ((_a2 = t5.action) == null ? void 0 : _a2.reason) || "sl_enter" === ((_b2 = t5.action) == null ? void 0 : _b2.reason)) && 0 === t5.currentWeight && c2.scheduled && p2 >= UT(c2.scheduled);
+        }(t4)));
+    }, [c2, s2, f2, g2, y2, m2, a2, o2, r2, (t4) => t4 > 0 ? "▴ " : "▾ ", d2, function() {
+        i2(4, y2 = false);
+    }, function() {
+        localStorage.setItem("strategyAnalyticTab", "position"), v2();
+    }, v2, l2, h2, u2, n2, function() {
+        g2 = this.checked, i2(3, g2);
+    }, (t4) => {
+        Ou() ? (localStorage.setItem("strategyAnalyticTab", "position"), v2(t4)) : i2(4, y2 = true), ud.set(t4);
+    }, function(t4) {
+        xt[t4 ? "unshift" : "push"](() => {
+            m2 = t4, i2(5, m2);
+        });
+    }];
+}
+class Position extends SvelteComponent {
+    constructor(t3) {
+        super(), ve(this, t3, jT, zT, o, {
+            reportPosition: 14,
+            lang: 15
+        }, uT, [-1, -1]);
+    }
+    get reportPosition() {
+        return this.$$.ctx[14];
+    }
+    set reportPosition(t3) {
+        this.$$set({
+            reportPosition: t3
+        }), te();
+    }
+    get lang() {
+        return this.$$.ctx[15];
+    }
+    set lang(t3) {
+        this.$$set({
+            lang: t3
+        }), te();
+    }
+}
+if (we(Position, {
+        reportPosition: {},
+        lang: {}
+    }, [], [], true), "undefined" != typeof window) {
+    let HT = function() {
+        var t3 = document.body,
+            e2 = document.getElementById("__svg__icons__dom__");
+        e2 || ((e2 = document.createElementNS("http://www.w3.org/2000/svg", "svg")).style.position = "absolute", e2.style.width = "0", e2.style.height = "0", e2.id = "__svg__icons__dom__", e2.setAttribute("xmlns", "http://www.w3.org/2000/svg"), e2.setAttribute("xmlns:link", "http://www.w3.org/1999/xlink")), e2.innerHTML = '<symbol viewBox="0 0 24 24" fill="none"  id="icon-barChart"><path d="M9 11v9m0-9H4.6c-.56 0-.84 0-1.054.109a1 1 0 0 0-.437.437C3 11.76 3 12.04 3 12.6V20h6m0-9V5.6c0-.56 0-.84.109-1.054a1 1 0 0 1 .437-.437C9.76 4 10.04 4 10.6 4h2.8c.56 0 .84 0 1.054.109.188.096.34.249.437.437C15 4.76 15 5.04 15 5.6V8M9 20h6m0 0h6V9.6c0-.56 0-.84-.11-1.054a.997.997 0 0 0-.435-.437C20.24 8 19.96 8 19.4 8H15m0 12V8" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" /></symbol><symbol fill="currentColor"  viewBox="0 0 24 24" id="icon-checked"><g data-name="Layer 2"><path d="M9.86 18a1 1 0 0 1-.73-.32l-4.86-5.17a1 1 0 1 1 1.46-1.37l4.12 4.39 8.41-9.2a1 1 0 1 1 1.48 1.34l-9.14 10a1 1 0 0 1-.73.33z" data-name="checkmark" /></g></symbol><symbol  viewBox="0 0 48 48" id="icon-chinese"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="4"><rect width="36" height="36" x="6" y="6" stroke-linejoin="round" rx="3" /><path stroke-linejoin="round" d="M14 18h20v10H14z" /><path d="M24 14v21" /></g></symbol><symbol  viewBox="0 0 24 24" id="icon-close"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" /></symbol><symbol  viewBox="0 0 24 24" id="icon-code"><path d="M9.4 16.6 4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0 4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z" /></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-copy"><path d="M9 9V6.2c0-1.12 0-1.68.218-2.108.192-.377.497-.682.874-.874C10.52 3 11.08 3 12.2 3h5.6c1.12 0 1.68 0 2.108.218a2 2 0 0 1 .874.874C21 4.52 21 5.08 21 6.2v5.6c0 1.12 0 1.68-.218 2.108a2.002 2.002 0 0 1-.874.874C19.48 15 18.92 15 17.803 15H15M9 9H6.2c-1.12 0-1.68 0-2.108.218a1.999 1.999 0 0 0-.874.874C3 10.52 3 11.08 3 12.2v5.6c0 1.12 0 1.68.218 2.108a2 2 0 0 0 .874.874c.427.218.987.218 2.105.218h5.607c1.117 0 1.676 0 2.104-.218.376-.192.683-.498.874-.874.218-.428.218-.987.218-2.105V15M9 9h2.8c1.12 0 1.68 0 2.108.218a2 2 0 0 1 .874.874c.218.427.218.987.218 2.105V15" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" /></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-dark-mode"><path opacity=".1" d="M20.867 15.316c.052-.118-.066-.238-.188-.194-3.362 1.215-7.23.498-9.767-2.038-2.525-2.525-3.243-6.367-2.05-9.718.049-.139-.088-.273-.222-.213l-.027.012c-1.855.838-3.506 2.252-4.476 4.032a9.335 9.335 0 0 0 2.255 11.664A9.344 9.344 0 0 0 12.332 21a9.344 9.344 0 0 0 5.23-1.601c1.427-.964 2.557-2.423 3.27-4.003l.035-.08Z" /><path d="M20.867 15.316c.052-.118-.066-.238-.188-.194-3.362 1.215-7.23.498-9.767-2.038-2.525-2.525-3.243-6.367-2.05-9.718.049-.139-.088-.273-.222-.213l-.027.012c-1.855.838-3.506 2.252-4.476 4.032a9.335 9.335 0 0 0 2.255 11.664A9.344 9.344 0 0 0 12.332 21a9.344 9.344 0 0 0 5.23-1.601c1.427-.964 2.557-2.423 3.27-4.003l.035-.08Z" /></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-diamond"><path d="M12 21v-9m0 9 3-3m-3 3-3-3m3-6V3m0 9H3m9 0h9m-9-9L9 6m3-3 3 3M3 12l3 3m-3-3 3-3m15 3-3-3m3 3-3 3" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" /></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-drag"><g stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 18a1 1 0 1 0 2 0 1 1 0 0 0-2 0ZM8 18a1 1 0 1 0 2 0 1 1 0 0 0-2 0ZM14 12a1 1 0 1 0 2 0 1 1 0 0 0-2 0ZM8 12a1 1 0 1 0 2 0 1 1 0 0 0-2 0ZM14 6a1 1 0 1 0 2 0 1 1 0 0 0-2 0ZM8 6a1 1 0 1 0 2 0 1 1 0 0 0-2 0Z" /></g></symbol><symbol  viewBox="0 0 48 48" id="icon-english"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="4"><rect width="36" height="36" x="6" y="6" rx="3" /><path d="M13 31V17h8m-8 7h7.5M13 31h7.5m5.5 0V19m0 12v-6.5a4.5 4.5 0 0 1 4.5-4.5v0a4.5 4.5 0 0 1 4.5 4.5V31" /></g></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-fail"><circle cx="12" cy="12" r="10" /><path d="m14.5 9.5-5 5m0-5 5 5" /></symbol><symbol  viewBox="0 0 24 24" id="icon-favorite"><path d="M12 20.325q-.35 0-.712-.125t-.638-.4l-1.725-1.575q-2.65-2.425-4.788-4.812T2 8.15Q2 5.8 3.575 4.225T7.5 2.65q1.325 0 2.5.562t2 1.538q.825-.975 2-1.537t2.5-.563q2.35 0 3.925 1.575T22 8.15q0 2.875-2.125 5.275T15.05 18.25l-1.7 1.55q-.275.275-.637.4t-.713.125M11.05 6.75q-.725-1.025-1.55-1.563t-2-.537q-1.5 0-2.5 1t-1 2.5q0 1.3.925 2.763t2.213 2.837q1.287 1.375 2.65 2.575T12 18.3q.85-.775 2.213-1.975t2.65-2.575q1.287-1.375 2.212-2.837T20 8.15q0-1.5-1-2.5t-2.5-1q-1.175 0-2 .538T12.95 6.75q-.175.25-.425.375T12 7.25q-.275 0-.525-.125t-.425-.375m.95 4.725" /></symbol><symbol  viewBox="0 0 248 348" id="icon-finlab"><path d="M145.3 28.8c-7.4 2.7-11.9 6-15.7 11.7-6.2 9.4-7.1 18.9-2.6 29.3 5.5 12.8 21.6 20.8 34.7 17.2 18.4-5.1 28.6-26.2 20.3-42.3-7.2-13.9-23-20.8-36.7-15.9zM104.5 90.5c-4.7 2.5-6.4 4.5-7.6 8.6-1.7 5.4-.4 10.4 3.6 14.4 8.7 8.6 22.9 3.5 24.2-8.8.5-4.9-1.8-10-5.8-13-3.7-2.6-10.6-3.2-14.4-1.2zM114.6 135.7l-2.9.5.7 14.6c.3 8.1 1.1 18.4 1.6 23l.9 8.2-36.7 55.3c-42 63-46.7 70.5-45.7 71.5.3.4 45.4.8 100.1 1 82.3.2 99.4 0 99.4-1.1 0-2.2-11.3-21-45.4-75.7l-32.7-52.5.5-7.5c.4-4.1.9-14.1 1.3-22.1l.6-14.6-3.9-.6c-4.2-.7-33-.7-37.8 0zm32.7 72.3c26.8 42.7 47.7 77.1 47.7 78.6 0 1.6-54.3 2.7-93.3 1.8l-31.6-.7 1.6-3.1c2.6-4.9 47.2-72.7 51-77.4l3.5-4.3 9.1.3 9.2.3 2.8 4.5z" /><path d="M116.3 242.2c-5.4 5.9-21.3 30.3-21.3 32.6 0 .9 9.1 1.2 35.3 1.2 34.7 0 39.7-.3 39.7-2.2 0-2.4-17-25.8-18.8-25.8-.8 0-3.7 2-6.4 4.5-2.8 2.5-5.6 4.5-6.4 4.5-.8 0-5.4-3.8-10.3-8.5-5-4.7-9.2-8.5-9.4-8.5-.2 0-1.3 1-2.4 2.2z" /></symbol><symbol  viewBox="0 0 24 24" id="icon-heart-minus"><path d="M15 14v-2h8v2zm-4 7-3.175-2.85q-1.8-1.625-3.088-2.9t-2.125-2.4q-.837-1.125-1.225-2.175T1 8.475q0-2.35 1.575-3.912T6.5 3q1.3 0 2.475.538T11 5.075q.85-1 2.025-1.537T15.5 3q2.125 0 3.563 1.288T20.85 7.3q-.45-.175-.9-.262t-.875-.088q-2.525 0-4.3 1.763T13 13q0 1.3.525 2.463T15 17.45q-.475.425-1.237 1.088T12.45 19.7z" /></symbol><symbol  viewBox="0 0 24 24" id="icon-info"><path d="M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" /></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-light-mode"><path opacity=".1" d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z" /><path d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0ZM12 5V3M17 7l2-2M19 12h2M17 17l2 2M12 19v2M7 17l-2 2M5 12H3M5 5l2 2" /></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-lineChart"><path d="M3 15v1.8c0 1.12 0 1.68.218 2.108a2 2 0 0 0 .874.874c.427.218.987.218 2.105.218H21M3 15V5m0 10 3.853-3.21.004-.003c.697-.581 1.046-.872 1.425-.99.447-.14.929-.118 1.362.061.367.153.688.474 1.332 1.118l.006.006c.654.654.981.982 1.354 1.133a2 2 0 0 0 1.385.046c.383-.128.733-.434 1.433-1.046L21 7" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" /></symbol><symbol  class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" id="icon-menu"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h8m-8 6h16" /></symbol><symbol  class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" id="icon-notification"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0 1 18 14.158V11a6.002 6.002 0 0 0-4-5.659V5a2 2 0 1 0-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 1 1-6 0v-1m6 0H9" /></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-pass"><circle cx="12" cy="12" r="10" /><path d="m8.5 12.5 2 2 5-5" /></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-pieChart"><path d="M12 3a9 9 0 1 0 9 9m-9-9a9 9 0 0 1 9 9m-9-9v9m9 0h-9m6 6.5L12 12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" /></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-plus"><path d="M8 12h4m0 0h4m-4 0v4m0-4V8m0 13a9 9 0 1 1 0-18 9 9 0 0 1 0 18Z" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" /></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-save"><path d="M17 21H7m10 0h.803c1.118 0 1.677 0 2.104-.218.377-.192.683-.498.875-.874.218-.427.218-.987.218-2.105V9.22c0-.45 0-.675-.048-.889a1.994 1.994 0 0 0-.209-.545c-.106-.19-.256-.355-.55-.682l-2.755-3.062c-.341-.378-.514-.57-.721-.708a1.999 1.999 0 0 0-.61-.271C15.863 3 15.6 3 15.075 3H6.2c-1.12 0-1.68 0-2.108.218a1.999 1.999 0 0 0-.874.874C3 4.52 3 5.08 3 6.2v11.6c0 1.12 0 1.68.218 2.107.192.377.497.683.874.875.427.218.987.218 2.105.218H7m10 0v-3.803c0-1.118 0-1.678-.218-2.105a2.001 2.001 0 0 0-.875-.874C15.48 14 14.92 14 13.8 14h-3.6c-1.12 0-1.68 0-2.108.218a1.999 1.999 0 0 0-.874.874C7 15.52 7 16.08 7 17.2V21m8-14H9" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" /></symbol><symbol class="w-4 h-4 text-gray-500 dark:text-gray-400" aria-hidden="true"  fill="none" viewBox="0 0 20 20" id="icon-search"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m19 19-4-4m0-7A7 7 0 1 1 1 8a7 7 0 0 1 14 0Z" /></symbol><symbol viewBox="-102.4 -102.4 1228.8 1228.8"  fill="currentColor" stroke="currentColor" stroke-width=".5" id="icon-setting"><path d="M600.704 64a32 32 0 0 1 30.464 22.208l35.2 109.376c14.784 7.232 28.928 15.36 42.432 24.512l112.384-24.192a32 32 0 0 1 34.432 15.36L944.32 364.8a32 32 0 0 1-4.032 37.504l-77.12 85.12a357.12 357.12 0 0 1 0 49.024l77.12 85.248a32 32 0 0 1 4.032 37.504l-88.704 153.6a32 32 0 0 1-34.432 15.296L708.8 803.904c-13.44 9.088-27.648 17.28-42.368 24.512l-35.264 109.376A32 32 0 0 1 600.704 960H423.296a32 32 0 0 1-30.464-22.208L357.696 828.48a351.616 351.616 0 0 1-42.56-24.64l-112.32 24.256a32 32 0 0 1-34.432-15.36L79.68 659.2a32 32 0 0 1 4.032-37.504l77.12-85.248a357.12 357.12 0 0 1 0-48.896l-77.12-85.248A32 32 0 0 1 79.68 364.8l88.704-153.6a32 32 0 0 1 34.432-15.296l112.32 24.256c13.568-9.152 27.776-17.408 42.56-24.64l35.2-109.312A32 32 0 0 1 423.232 64H600.64zm-23.424 64H446.72l-36.352 113.088-24.512 11.968a294.113 294.113 0 0 0-34.816 20.096l-22.656 15.36-116.224-25.088-65.28 113.152 79.68 88.192-1.92 27.136a293.12 293.12 0 0 0 0 40.192l1.92 27.136-79.808 88.192 65.344 113.152 116.224-25.024 22.656 15.296a294.113 294.113 0 0 0 34.816 20.096l24.512 11.968L446.72 896h130.688l36.48-113.152 24.448-11.904a288.282 288.282 0 0 0 34.752-20.096l22.592-15.296 116.288 25.024 65.28-113.152-79.744-88.192 1.92-27.136a293.12 293.12 0 0 0 0-40.256l-1.92-27.136 79.808-88.128-65.344-113.152-116.288 24.96-22.592-15.232a287.616 287.616 0 0 0-34.752-20.096l-24.448-11.904L577.344 128zM512 320a192 192 0 1 1 0 384 192 192 0 0 1 0-384zm0 64a128 128 0 1 0 0 256 128 128 0 0 0 0-256z" /></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-shield"><path d="m15 9-4 4-2-2m11-.835c0 6.568-4.968 9.513-7.074 10.466l-.003.002c-.221.1-.332.15-.584.193-.16.028-.518.028-.677 0a2.01 2.01 0 0 1-.588-.195C8.968 19.678 4 16.733 4 10.165V6.2c0-1.12 0-1.68.218-2.108.192-.377.497-.682.874-.874C5.52 3 6.08 3 7.2 3h9.6c1.12 0 1.68 0 2.107.218.377.192.683.497.875.874.218.427.218.987.218 2.105v3.968Z" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" /></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-star-filled"><path d="M9.153 5.408C10.42 3.136 11.053 2 12 2c.947 0 1.58 1.136 2.847 3.408l.328.588c.36.646.54.969.82 1.182.28.213.63.292 1.33.45l.636.144c2.46.557 3.689.835 3.982 1.776.292.94-.546 1.921-2.223 3.882l-.434.507c-.476.557-.715.836-.822 1.18-.107.345-.071.717.001 1.46l.066.677c.253 2.617.38 3.925-.386 4.506-.766.582-1.918.051-4.22-1.009l-.597-.274c-.654-.302-.981-.452-1.328-.452-.347 0-.674.15-1.329.452l-.595.274c-2.303 1.06-3.455 1.59-4.22 1.01-.767-.582-.64-1.89-.387-4.507l.066-.676c.072-.744.108-1.116 0-1.46-.106-.345-.345-.624-.821-1.18l-.434-.508c-1.677-1.96-2.515-2.941-2.223-3.882.293-.941 1.523-1.22 3.983-1.776l.636-.144c.699-.158 1.048-.237 1.329-.45.28-.213.46-.536.82-1.182l.328-.588Z" fill="currentColor" stroke="currentColor" /></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-star"><path d="M9.153 5.408C10.42 3.136 11.053 2 12 2c.947 0 1.58 1.136 2.847 3.408l.328.588c.36.646.54.969.82 1.182.28.213.63.292 1.33.45l.636.144c2.46.557 3.689.835 3.982 1.776.292.94-.546 1.921-2.223 3.882l-.434.507c-.476.557-.715.836-.822 1.18-.107.345-.071.717.001 1.46l.066.677c.253 2.617.38 3.925-.386 4.506-.766.582-1.918.051-4.22-1.009l-.597-.274c-.654-.302-.981-.452-1.328-.452-.347 0-.674.15-1.329.452l-.595.274c-2.303 1.06-3.455 1.59-4.22 1.01-.767-.582-.64-1.89-.387-4.507l.066-.676c.072-.744.108-1.116 0-1.46-.106-.345-.345-.624-.821-1.18l-.434-.508c-1.677-1.96-2.515-2.941-2.223-3.882.293-.941 1.523-1.22 3.983-1.776l.636-.144c.699-.158 1.048-.237 1.329-.45.28-.213.46-.536.82-1.182l.328-.588Z" stroke="currentColor" /></symbol><symbol viewBox="0 0 24 24" fill="none"  id="icon-trophy"><path d="M15 13V9m0 0h-4m4 0-6 6m12-3a9 9 0 1 0-18 0 9 9 0 0 0 18 0Z" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" /></symbol>', t3.insertBefore(e2, t3.lastChild);
+    };
+    "loading" === document.readyState ? document.addEventListener("DOMContentLoaded", HT) : HT();
+}
+
+function WT(t3) {
+    const e2 = t3 - 1;
+    return e2 * e2 * e2 + 1;
+}
+
+function qT(t3, {
+    delay: e2 = 0,
+    duration: i2 = 400,
+    easing: s2 = WT,
+    axis: n2 = "y"
+} = {}) {
+    const r2 = getComputedStyle(t3),
+        o2 = +r2.opacity,
+        a2 = "y" === n2 ? "height" : "width",
+        l2 = parseFloat(r2[a2]),
+        h2 = "y" === n2 ? ["top", "bottom"] : ["left", "right"],
+        c2 = h2.map((t4) => `${t4[0].toUpperCase()}${t4.slice(1)}`),
+        u2 = parseFloat(r2[`padding${c2[0]}`]),
+        d2 = parseFloat(r2[`padding${c2[1]}`]),
+        f2 = parseFloat(r2[`margin${c2[0]}`]),
+        p2 = parseFloat(r2[`margin${c2[1]}`]),
+        m2 = parseFloat(r2[`border${c2[0]}Width`]),
+        g2 = parseFloat(r2[`border${c2[1]}Width`]);
+    return {
+        delay: e2,
+        duration: i2,
+        easing: s2,
+        css: (t4) => `overflow: hidden;opacity: ${Math.min(20 * t4, 1) * o2};${a2}: ${t4 * l2}px;padding-${h2[0]}: ${t4 * u2}px;padding-${h2[1]}: ${t4 * d2}px;margin-${h2[0]}: ${t4 * f2}px;margin-${h2[1]}: ${t4 * p2}px;border-${h2[0]}-width: ${t4 * m2}px;border-${h2[1]}-width: ${t4 * g2}px;`
+    };
+}
+
+function KT(t3, e2, i2) {
+    const s2 = t3.slice();
+    return s2[26] = e2[i2][0], s2[27] = e2[i2][1], s2;
+}
+
+function GT(t3, e2, i2) {
+    const s2 = t3.slice();
+    return s2[11] = e2[i2][0], s2[23] = e2[i2][1], s2;
+}
+
+function YT(t3, e2, i2) {
+    const s2 = t3.slice();
+    return s2[26] = e2[i2][0], s2[27] = e2[i2][1], s2;
+}
+
+function QT(t3, e2, i2) {
+    const s2 = t3.slice();
+    return s2[26] = e2[i2][0], s2[23] = e2[i2][1], s2;
+}
+
+function XT(t3, e2, i2) {
+    const s2 = t3.slice();
+    return s2[34] = e2[i2], s2[12] = i2, s2;
+}
+
+function JT(t3, e2, i2) {
+    const s2 = t3.slice();
+    return s2[36] = e2[i2], s2;
+}
+
+function ZT(t3) {
+    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2 = t3[5] && tS(t3),
+        u2 = ue(t3[14]),
+        d2 = [];
+    for (let e3 = 0; e3 < u2.length; e3 += 1)
+        d2[e3] = eS(JT(t3, u2, e3));
+    return {
+        c() {
+            e2 = P("div"), i2 = P("div"), s2 = P("div"), c2 && c2.c(), n2 = $(), r2 = P("div"), o2 = P("div");
+            for (let t4 = 0; t4 < d2.length; t4 += 1)
+                d2[t4].c();
+            a2 = $(), l2 = P("div"), G(s2, "margin-left", "-4px"), U(s2, "class", "flex items-end flex-1 -mt-2"), U(o2, "role", "tablist"), U(o2, "class", "tabs tabs-boxed bg-base-100"), U(r2, "class", "flex-1 w-full bg-base-100 rounded-lg"), U(l2, "class", "flex-1 text-right text-base-content-200 flex items-center justify-end"), U(i2, "class", "flex gap-4 h-20 items-center"), U(e2, "class", "sticky top-0 z-[21] backdrop-blur-lg");
+        },
+        m(t4, u3) {
+            S(t4, e2, u3), _(e2, i2), _(i2, s2), c2 && c2.m(s2, null), _(i2, n2), _(i2, r2), _(r2, o2);
+            for (let t5 = 0; t5 < d2.length; t5 += 1)
+                d2[t5] && d2[t5].m(o2, null);
+            _(i2, a2), _(i2, l2), h2 = true;
+        },
+        p(t4, e3) {
+            if (t4[5] ? c2 ? (c2.p(t4, e3), 32 & e3[0] && le(c2, 1)) : (c2 = tS(t4), c2.c(), le(c2, 1), c2.m(s2, null)) : c2 && (oe(), he(c2, 1, 1, () => {
+                    c2 = null;
+                }), ae()), 49472 & e3[0]) {
+                let i3;
+                for (u2 = ue(t4[14]), i3 = 0; i3 < u2.length; i3 += 1) {
+                    const s3 = JT(t4, u2, i3);
+                    d2[i3] ? d2[i3].p(s3, e3) : (d2[i3] = eS(s3), d2[i3].c(), d2[i3].m(o2, null));
+                }
+                for (; i3 < d2.length; i3 += 1)
+                    d2[i3].d(1);
+                d2.length = u2.length;
+            }
+        },
+        i(t4) {
+            h2 || (le(c2), h2 = true);
+        },
+        o(t4) {
+            he(c2), h2 = false;
+        },
+        d(t4) {
+            t4 && E(e2), c2 && c2.d(), C(d2, t4);
+        }
+    };
+}
+
+function tS(t3) {
+    let e2, i2, s2, n2, r2;
+    return i2 = new Du({
+        props: {
+            name: "finlab",
+            className: "w-6 h-10",
+            color: "light" === t3[2] || null === t3[2] ? "rgb(31 41 55)" : "rgb(209 213 219)"
+        }
+    }), {
+        c() {
+            e2 = P("div"), me(i2.$$.fragment), s2 = $(), n2 = P("div"), n2.innerHTML = '<span class="text-base-content-300 font-bold">FinLab</span>', U(e2, "class", "w-8 flex justify-center");
+        },
+        m(t4, o2) {
+            S(t4, e2, o2), ge(i2, e2, null), S(t4, s2, o2), S(t4, n2, o2), r2 = true;
+        },
+        p(t4, e3) {
+            const s3 = {};
+            4 & e3[0] && (s3.color = "light" === t4[2] || null === t4[2] ? "rgb(31 41 55)" : "rgb(209 213 219)"), i2.$set(s3);
+        },
+        i(t4) {
+            r2 || (le(i2.$$.fragment, t4), r2 = true);
+        },
+        o(t4) {
+            he(i2.$$.fragment, t4), r2 = false;
+        },
+        d(t4) {
+            t4 && (E(e2), E(s2), E(n2)), ye(i2);
+        }
+    };
+}
+
+function eS(t3) {
+    let e2, i2, s2;
+
+    function n2() {
+        return t3[17](t3[36]);
+    }
+    return {
+        c() {
+            e2 = P("a"), e2.textContent = `${t3[36]}`, U(e2, "role", "tab"), U(e2, "tabindex", "1"), U(e2, "class", "tab"), Y(e2, "tab-active", t3[6] === t3[36]);
+        },
+        m(t4, r2) {
+            S(t4, e2, r2), i2 || (s2 = B(e2, "click", n2), i2 = true);
+        },
+        p(i3, s3) {
+            t3 = i3, 16448 & s3[0] && Y(e2, "tab-active", t3[6] === t3[36]);
+        },
+        d(t4) {
+            t4 && E(e2), i2 = false, s2();
+        }
+    };
+}
+
+function iS(t3) {
+    let e2, i2, s2;
+    return i2 = new Position({
+        props: {
+            reportPosition: t3[4],
+            lang: t3[0]
+        }
+    }), {
+        c() {
+            e2 = P("div"), me(i2.$$.fragment), U(e2, "class", "pb-4");
+        },
+        m(t4, n2) {
+            S(t4, e2, n2), ge(i2, e2, null), s2 = true;
+        },
+        p(t4, e3) {
+            const s3 = {};
+            16 & e3[0] && (s3.reportPosition = t4[4]), 1 & e3[0] && (s3.lang = t4[0]), i2.$set(s3);
+        },
+        i(t4) {
+            s2 || (le(i2.$$.fragment, t4), s2 = true);
+        },
+        o(t4) {
+            he(i2.$$.fragment, t4), s2 = false;
+        },
+        d(t4) {
+            t4 && E(e2), ye(i2);
+        }
+    };
+}
+
+function sS(t3) {
+    let e2, i2, s2 = t3[1] && nS(t3);
+    return {
+        c() {
+            s2 && s2.c(), e2 = z();
+        },
+        m(t4, n2) {
+            s2 && s2.m(t4, n2), S(t4, e2, n2), i2 = true;
+        },
+        p(t4, i3) {
+            t4[1] ? s2 ? (s2.p(t4, i3), 2 & i3[0] && le(s2, 1)) : (s2 = nS(t4), s2.c(), le(s2, 1), s2.m(e2.parentNode, e2)) : s2 && (oe(), he(s2, 1, 1, () => {
+                s2 = null;
+            }), ae());
+        },
+        i(t4) {
+            i2 || (le(s2), i2 = true);
+        },
+        o(t4) {
+            he(s2), i2 = false;
+        },
+        d(t4) {
+            t4 && E(e2), s2 && s2.d(t4);
+        }
+    };
+}
+
+function nS(t3) {
+    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2 = ue(Object.entries(t3[1].metrics).filter(ES)),
+        d2 = [];
+    for (let e3 = 0; e3 < u2.length; e3 += 1)
+        d2[e3] = lS(QT(t3, u2, e3));
+    const f2 = [cS, hS],
+        p2 = [];
+
+    function m2(t4, e3) {
+        return "all" === t4[11] ? 0 : 1;
+    }
+    n2 = m2(t3), r2 = p2[n2] = f2[n2](t3);
+    const g2 = [TS, kS, xS, wS, _S],
+        y2 = [];
+
+    function v2(t4, e3) {
+        return "profitability" === t4[11] ? 0 : "risk" === t4[11] ? 1 : "ratio" === t4[11] ? 2 : "winrate" === t4[11] ? 3 : "liquidity" === t4[11] ? 4 : -1;
+    }
+    return ~(l2 = v2(t3)) && (h2 = y2[l2] = g2[l2](t3)), {
+        c() {
+            e2 = P("div"), i2 = P("div");
+            for (let t4 = 0; t4 < d2.length; t4 += 1)
+                d2[t4].c();
+            s2 = $(), r2.c(), o2 = $(), a2 = P("div"), h2 && h2.c(), U(i2, "class", "items-center justify-center flex overflow-x-auto no-scrollbar divide-x gap-2 -ml-2 -mr-2"), U(a2, "class", "pb-4"), U(e2, "class", "ml-4 md:ml-0");
+        },
+        m(t4, r3) {
+            S(t4, e2, r3), _(e2, i2);
+            for (let t5 = 0; t5 < d2.length; t5 += 1)
+                d2[t5] && d2[t5].m(i2, null);
+            _(e2, s2), p2[n2].m(e2, null), _(e2, o2), _(e2, a2), ~l2 && y2[l2].m(a2, null), c2 = true;
+        },
+        p(t4, s3) {
+            if (40450 & s3[0]) {
+                let e3;
+                for (u2 = ue(Object.entries(t4[1].metrics).filter(ES)), e3 = 0; e3 < u2.length; e3 += 1) {
+                    const n3 = QT(t4, u2, e3);
+                    d2[e3] ? d2[e3].p(n3, s3) : (d2[e3] = lS(n3), d2[e3].c(), d2[e3].m(i2, null));
+                }
+                for (; e3 < d2.length; e3 += 1)
+                    d2[e3].d(1);
+                d2.length = u2.length;
+            }
+            let c3 = n2;
+            n2 = m2(t4), n2 === c3 ? p2[n2].p(t4, s3) : (oe(), he(p2[c3], 1, 1, () => {
+                p2[c3] = null;
+            }), ae(), r2 = p2[n2], r2 ? r2.p(t4, s3) : (r2 = p2[n2] = f2[n2](t4), r2.c()), le(r2, 1), r2.m(e2, o2));
+            let b2 = l2;
+            l2 = v2(t4), l2 === b2 ? ~l2 && y2[l2].p(t4, s3) : (h2 && (oe(), he(y2[b2], 1, 1, () => {
+                y2[b2] = null;
+            }), ae()), ~l2 ? (h2 = y2[l2], h2 ? h2.p(t4, s3) : (h2 = y2[l2] = g2[l2](t4), h2.c()), le(h2, 1), h2.m(a2, null)) : h2 = null);
+        },
+        i(t4) {
+            c2 || (le(r2), le(h2), c2 = true);
+        },
+        o(t4) {
+            he(r2), he(h2), c2 = false;
+        },
+        d(t4) {
+            t4 && E(e2), C(d2, t4), p2[n2].d(), ~l2 && y2[l2].d();
+        }
+    };
+}
+
+function rS(e2) {
+    let i2;
+    return {
+        c() {
+            i2 = P("input"), U(i2, "type", "radio"), i2.readOnly = true, U(i2, "name", "rating-2"), U(i2, "class", "pointer-events-none mask mask-star-2 bg-base-content/10");
+        },
+        m(t3, e3) {
+            S(t3, i2, e3);
+        },
+        p: t,
+        d(t3) {
+            t3 && E(i2);
+        }
+    };
+}
+
+function oS(t3) {
+    let e2, i2;
+    return {
+        c() {
+            e2 = P("input"), U(e2, "type", "radio"), e2.readOnly = true, U(e2, "name", "rating-2"), U(e2, "class", i2 = "pointer-events-none mask mask-star-2 " + (t3[11] == t3[26] ? "bg-white" : "bg-primary"));
+        },
+        m(t4, i3) {
+            S(t4, e2, i3);
+        },
+        p(t4, s2) {
+            2050 & s2[0] && i2 !== (i2 = "pointer-events-none mask mask-star-2 " + (t4[11] == t4[26] ? "bg-white" : "bg-primary")) && U(e2, "class", i2);
+        },
+        d(t4) {
+            t4 && E(e2);
+        }
+    };
+}
+
+function aS(t3) {
+    let e2;
+
+    function i2(t4, e3) {
+        return 0.2 * t4[12] < t4[10][t4[26]] ? oS : rS;
+    }
+    let s2 = i2(t3),
+        n2 = s2(t3);
+    return {
+        c() {
+            n2.c(), e2 = z();
+        },
+        m(t4, i3) {
+            n2.m(t4, i3), S(t4, e2, i3);
+        },
+        p(t4, r2) {
+            s2 === (s2 = i2(t4)) && n2 ? n2.p(t4, r2) : (n2.d(1), n2 = s2(t4), n2 && (n2.c(), n2.m(e2.parentNode, e2)));
+        },
+        d(t4) {
+            t4 && E(e2), n2.d(t4);
+        }
+    };
+}
+
+function lS(t3) {
+    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2, d2 = t3[12](`tabs.${t3[26]}`) + "",
+        f2 = ue(Array.from({
+            length: 5
+        })),
+        p2 = [];
+    for (let e3 = 0; e3 < f2.length; e3 += 1)
+        p2[e3] = aS(XT(t3, f2, e3));
+
+    function m2() {
+        return t3[19](t3[26]);
+    }
+    return {
+        c() {
+            e2 = P("div"), i2 = P("button"), s2 = P("span"), n2 = D(d2), r2 = $(), o2 = P("div"), a2 = P("div");
+            for (let t4 = 0; t4 < p2.length; t4 += 1)
+                p2[t4].c();
+            h2 = $(), U(a2, "class", "rating rating-sm"), U(i2, "class", l2 = "py-2 px-4 ml-2 hover:text-base-content-300 rounded-md " + (t3[11] === t3[26] ? "bg-primary text-white" : "text-base-content-200"));
+        },
+        m(t4, l3) {
+            S(t4, e2, l3), _(e2, i2), _(i2, s2), _(s2, n2), _(i2, r2), _(i2, o2), _(o2, a2);
+            for (let t5 = 0; t5 < p2.length; t5 += 1)
+                p2[t5] && p2[t5].m(a2, null);
+            _(e2, h2), c2 || (u2 = B(i2, "click", m2), c2 = true);
+        },
+        p(e3, s3) {
+            if (t3 = e3, 4098 & s3[0] && d2 !== (d2 = t3[12](`tabs.${t3[26]}`) + "") && H(n2, d2), 3074 & s3[0]) {
+                let e4;
+                for (f2 = ue(Array.from({
+                        length: 5
+                    })), e4 = 0; e4 < f2.length; e4 += 1) {
+                    const i3 = XT(t3, f2, e4);
+                    p2[e4] ? p2[e4].p(i3, s3) : (p2[e4] = aS(i3), p2[e4].c(), p2[e4].m(a2, null));
+                }
+                for (; e4 < p2.length; e4 += 1)
+                    p2[e4].d(1);
+                p2.length = f2.length;
+            }
+            2050 & s3[0] && l2 !== (l2 = "py-2 px-4 ml-2 hover:text-base-content-300 rounded-md " + (t3[11] === t3[26] ? "bg-primary text-white" : "text-base-content-200")) && U(i2, "class", l2);
+        },
+        d(t4) {
+            t4 && E(e2), C(p2, t4), c2 = false, u2();
+        }
+    };
+}
+
+function hS(t3) {
+    let e2, i2, s2, n2, r2 = ue(Object.entries(t3[1].metrics[t3[11]]).splice(0, 6)),
+        o2 = [];
+    for (let e3 = 0; e3 < r2.length; e3 += 1)
+        o2[e3] = pS(KT(t3, r2, e3));
+    const a2 = (t4) => he(o2[t4], 1, 1, () => {
+        o2[t4] = null;
+    });
+    let l2 = null !== t3[9] && mS(t3);
+    return {
+        c() {
+            e2 = P("div"), i2 = P("div");
+            for (let t4 = 0; t4 < o2.length; t4 += 1)
+                o2[t4].c();
+            s2 = $(), l2 && l2.c(), U(i2, "class", "flex overflow-x-auto sm:justify-center divide-x bg-transparent no-scrollbar p-4 min-w-full"), U(e2, "class", "rounded-xl border my-4");
+        },
+        m(t4, r3) {
+            S(t4, e2, r3), _(e2, i2);
+            for (let t5 = 0; t5 < o2.length; t5 += 1)
+                o2[t5] && o2[t5].m(i2, null);
+            _(e2, s2), l2 && l2.m(e2, null), n2 = true;
+        },
+        p(t4, s3) {
+            if (112642 & s3[0]) {
+                let e3;
+                for (r2 = ue(Object.entries(t4[1].metrics[t4[11]]).splice(0, 6)), e3 = 0; e3 < r2.length; e3 += 1) {
+                    const n3 = KT(t4, r2, e3);
+                    o2[e3] ? (o2[e3].p(n3, s3), le(o2[e3], 1)) : (o2[e3] = pS(n3), o2[e3].c(), le(o2[e3], 1), o2[e3].m(i2, null));
+                }
+                for (oe(), e3 = r2.length; e3 < o2.length; e3 += 1)
+                    a2(e3);
+                ae();
+            }
+            null !== t4[9] ? l2 ? (l2.p(t4, s3), 512 & s3[0] && le(l2, 1)) : (l2 = mS(t4), l2.c(), le(l2, 1), l2.m(e2, null)) : l2 && (oe(), he(l2, 1, 1, () => {
+                l2 = null;
+            }), ae());
+        },
+        i(t4) {
+            if (!n2) {
+                for (let t5 = 0; t5 < r2.length; t5 += 1)
+                    le(o2[t5]);
+                le(l2), n2 = true;
+            }
+        },
+        o(t4) {
+            o2 = o2.filter(Boolean);
+            for (let t5 = 0; t5 < o2.length; t5 += 1)
+                he(o2[t5]);
+            he(l2), n2 = false;
+        },
+        d(t4) {
+            t4 && E(e2), C(o2, t4), l2 && l2.d();
+        }
+    };
+}
+
+function cS(t3) {
+    let e2, i2, s2 = ue(Object.entries(t3[1].metrics).filter(CS)),
+        n2 = [];
+    for (let e3 = 0; e3 < s2.length; e3 += 1)
+        n2[e3] = bS(GT(t3, s2, e3));
+    const r2 = (t4) => he(n2[t4], 1, 1, () => {
+        n2[t4] = null;
+    });
+    return {
+        c() {
+            e2 = P("div");
+            for (let t4 = 0; t4 < n2.length; t4 += 1)
+                n2[t4].c();
+            U(e2, "class", "text-base-content-200 grid grid-cols-5 gap-4 p-4 border rounded-xl mt-4");
+        },
+        m(t4, s3) {
+            S(t4, e2, s3);
+            for (let t5 = 0; t5 < n2.length; t5 += 1)
+                n2[t5] && n2[t5].m(e2, null);
+            i2 = true;
+        },
+        p(t4, i3) {
+            if (12290 & i3[0]) {
+                let o2;
+                for (s2 = ue(Object.entries(t4[1].metrics).filter(CS)), o2 = 0; o2 < s2.length; o2 += 1) {
+                    const r3 = GT(t4, s2, o2);
+                    n2[o2] ? (n2[o2].p(r3, i3), le(n2[o2], 1)) : (n2[o2] = bS(r3), n2[o2].c(), le(n2[o2], 1), n2[o2].m(e2, null));
+                }
+                for (oe(), o2 = s2.length; o2 < n2.length; o2 += 1)
+                    r2(o2);
+                ae();
+            }
+        },
+        i(t4) {
+            if (!i2) {
+                for (let t5 = 0; t5 < s2.length; t5 += 1)
+                    le(n2[t5]);
+                i2 = true;
+            }
+        },
+        o(t4) {
+            n2 = n2.filter(Boolean);
+            for (let t5 = 0; t5 < n2.length; t5 += 1)
+                he(n2[t5]);
+            i2 = false;
+        },
+        d(t4) {
+            t4 && E(e2), C(n2, t4);
+        }
+    };
+}
+
+function uS(t3) {
+    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2, d2, f2, p2, m2, g2, y2, v2, b2, w2, x2 = t3[12](`metrics.${t3[11]}.${t3[26]}`) + "",
+        k2 = t3[13].format(t3[26], t3[27]) + "",
+        T2 = t3[13].getUnit(t3[26]) + "";
+    const C2 = [fS, dS],
+        R2 = [];
+
+    function z2(t4, e3) {
+        return 2050 & e3[0] && (n2 = null), null == n2 && (n2 = !!Te[t4[11]][t4[26]](t4[27])), n2 ? 0 : 1;
+    }
+
+    function j2() {
+        return t3[20](t3[26]);
+    }
+    return r2 = z2(t3, [-1, -1]), o2 = R2[r2] = C2[r2](t3), {
+        c() {
+            e2 = P("button"), i2 = P("div"), s2 = P("div"), o2.c(), a2 = $(), l2 = P("div"), h2 = D(x2), c2 = $(), u2 = P("div"), d2 = P("span"), f2 = D(k2), p2 = $(), m2 = P("span"), g2 = D(T2), y2 = $(), U(s2, "class", "flex justify-center w-full"), U(l2, "class", "mt-1 text-base-content-300 text-sm whitespace-no-wrap break-keep whitespace-nowrap overflow-hidden truncate stat-title"), U(d2, "class", "font-bold"), U(m2, "class", "text-sm"), U(u2, "class", "sm:stat-value text-base-content-200 mt-2 whitespace-nowrap"), U(i2, "class", "text-center px-4"), U(e2, "class", "flex-1 border-base-content/10");
+        },
+        m(t4, n3) {
+            S(t4, e2, n3), _(e2, i2), _(i2, s2), R2[r2].m(s2, null), _(i2, a2), _(i2, l2), _(l2, h2), _(i2, c2), _(i2, u2), _(u2, d2), _(d2, f2), _(u2, p2), _(u2, m2), _(m2, g2), _(e2, y2), v2 = true, b2 || (w2 = B(e2, "click", j2), b2 = true);
+        },
+        p(e3, i3) {
+            let n3 = r2;
+            r2 = z2(t3 = e3, i3), r2 === n3 ? R2[r2].p(t3, i3) : (oe(), he(R2[n3], 1, 1, () => {
+                R2[n3] = null;
+            }), ae(), o2 = R2[r2], o2 ? o2.p(t3, i3) : (o2 = R2[r2] = C2[r2](t3), o2.c()), le(o2, 1), o2.m(s2, null)), (!v2 || 6146 & i3[0]) && x2 !== (x2 = t3[12](`metrics.${t3[11]}.${t3[26]}`) + "") && H(h2, x2), (!v2 || 2050 & i3[0]) && k2 !== (k2 = t3[13].format(t3[26], t3[27]) + "") && H(f2, k2), (!v2 || 2050 & i3[0]) && T2 !== (T2 = t3[13].getUnit(t3[26]) + "") && H(g2, T2);
+        },
+        i(t4) {
+            v2 || (le(o2), v2 = true);
+        },
+        o(t4) {
+            he(o2), v2 = false;
+        },
+        d(t4) {
+            t4 && E(e2), R2[r2].d(), b2 = false, w2();
+        }
+    };
+}
+
+function dS(e2) {
+    let i2, s2;
+    return i2 = new Du({
+        props: {
+            name: "fail",
+            className: "w-6 h-6",
+            strokeColor: vu("red")
+        }
+    }), {
+        c() {
+            me(i2.$$.fragment);
+        },
+        m(t3, e3) {
+            ge(i2, t3, e3), s2 = true;
+        },
+        p: t,
+        i(t3) {
+            s2 || (le(i2.$$.fragment, t3), s2 = true);
+        },
+        o(t3) {
+            he(i2.$$.fragment, t3), s2 = false;
+        },
+        d(t3) {
+            ye(i2, t3);
+        }
+    };
+}
+
+function fS(e2) {
+    let i2, s2;
+    return i2 = new Du({
+        props: {
+            name: "pass",
+            className: "w-6 h-6",
+            strokeColor: vu("green")
+        }
+    }), {
+        c() {
+            me(i2.$$.fragment);
+        },
+        m(t3, e3) {
+            ge(i2, t3, e3), s2 = true;
+        },
+        p: t,
+        i(t3) {
+            s2 || (le(i2.$$.fragment, t3), s2 = true);
+        },
+        o(t3) {
+            he(i2.$$.fragment, t3), s2 = false;
+        },
+        d(t3) {
+            ye(i2, t3);
+        }
+    };
+}
+
+function pS(t3) {
+    var _a2;
+    let e2, i2, s2 = ((_a2 = Te[t3[11]]) == null ? void 0 : _a2[t3[26]]) && uS(t3);
+    return {
+        c() {
+            s2 && s2.c(), e2 = z();
+        },
+        m(t4, n2) {
+            s2 && s2.m(t4, n2), S(t4, e2, n2), i2 = true;
+        },
+        p(t4, i3) {
+            var _a3;
+            ((_a3 = Te[t4[11]]) == null ? void 0 : _a3[t4[26]]) ? s2 ? (s2.p(t4, i3), 2050 & i3[0] && le(s2, 1)) : (s2 = uS(t4), s2.c(), le(s2, 1), s2.m(e2.parentNode, e2)): s2 && (oe(), he(s2, 1, 1, () => {
+                s2 = null;
+            }), ae());
+        },
+        i(t4) {
+            i2 || (le(s2), i2 = true);
+        },
+        o(t4) {
+            he(s2), i2 = false;
+        },
+        d(t4) {
+            t4 && E(e2), s2 && s2.d(t4);
+        }
+    };
+}
+
+function mS(i2) {
+    let s2, o2, a2, l2, h2, c2, u2, d2, f2, p2, g2, y2, v2, w2, x2, k2, T2 = i2[12](`metrics.${i2[11]}.${i2[9]}`) + "",
+        C2 = i2[12](`metric.description.${i2[11]}.${i2[9]}`) + "",
+        R2 = i2[12]("metrics.condition") + "",
+        z2 = Te[i2[11]][i2[9]].toString().split("=>")[1] + "";
+    return {
+        c() {
+            s2 = P("div"), o2 = P("div"), a2 = P("h3"), l2 = D(T2), h2 = $(), c2 = P("p"), u2 = D(C2), d2 = $(), f2 = P("h3"), p2 = D(R2), g2 = $(), y2 = P("p"), v2 = D(z2), U(a2, "class", "font-bold text-lg"), U(f2, "class", "font-bold text-lg mt-4"), U(o2, "class", "card-body"), U(s2, "class", "card bg-base-100 shadow-xl text-base-content-300");
+        },
+        m(t3, e2) {
+            S(t3, s2, e2), _(s2, o2), _(o2, a2), _(a2, l2), _(o2, h2), _(o2, c2), _(c2, u2), _(o2, d2), _(o2, f2), _(f2, p2), _(o2, g2), _(o2, y2), _(y2, v2), k2 = true;
+        },
+        p(t3, e2) {
+            (!k2 || 6656 & e2[0]) && T2 !== (T2 = t3[12](`metrics.${t3[11]}.${t3[9]}`) + "") && H(l2, T2), (!k2 || 6656 & e2[0]) && C2 !== (C2 = t3[12](`metric.description.${t3[11]}.${t3[9]}`) + "") && H(u2, C2), (!k2 || 4096 & e2[0]) && R2 !== (R2 = t3[12]("metrics.condition") + "") && H(p2, R2), (!k2 || 2560 & e2[0]) && z2 !== (z2 = Te[t3[11]][t3[9]].toString().split("=>")[1] + "") && H(v2, z2);
+        },
+        i(i3) {
+            k2 || (i3 && Ot(() => {
+                k2 && (x2 && x2.end(1), w2 = function(i4, s3, n2) {
+                    const o3 = {
+                        direction: "in"
+                    };
+                    let a3, l3, h3 = s3(i4, n2, o3),
+                        c3 = false,
+                        u3 = 0;
+
+                    function d3() {
+                        a3 && ut(i4, a3);
+                    }
+
+                    function f3() {
+                        const {
+                            delay: s4 = 0,
+                            duration: n3 = 300,
+                            easing: r2 = e,
+                            tick: o4 = t,
+                            css: f4
+                        } = h3 || ce;
+                        f4 && (a3 = ct(i4, 0, 1, n3, s4, r2, f4, u3++)), o4(0, 1);
+                        const p4 = m() + s4,
+                            g3 = p4 + n3;
+                        l3 && l3.abort(), c3 = true, Ot(() => se(i4, true, "start")), l3 = b((t3) => {
+                            if (c3) {
+                                if (t3 >= g3)
+                                    return o4(1, 0), se(i4, true, "end"), d3(), c3 = false;
+                                if (t3 >= p4) {
+                                    const e2 = r2((t3 - p4) / n3);
+                                    o4(e2, 1 - e2);
+                                }
+                            }
+                            return c3;
+                        });
+                    }
+                    let p3 = false;
+                    return {
+                        start() {
+                            p3 || (p3 = true, ut(i4), r(h3) ? (h3 = h3(o3), ie().then(f3)) : f3());
+                        },
+                        invalidate() {
+                            p3 = false;
+                        },
+                        end() {
+                            c3 && (d3(), c3 = false);
+                        }
+                    };
+                }(s2, qT, {
+                    duration: 300
+                }), w2.start());
+            }), k2 = true);
+        },
+        o(i3) {
+            w2 && w2.invalidate(), i3 && (x2 = function(i4, s3, o3) {
+                const a3 = {
+                    direction: "out"
+                };
+                let l3, h3 = s3(i4, o3, a3),
+                    c3 = true;
+                const u3 = re;
+                let d3;
+
+                function f3() {
+                    const {
+                        delay: s4 = 0,
+                        duration: r2 = 300,
+                        easing: o4 = e,
+                        tick: a4 = t,
+                        css: f4
+                    } = h3 || ce;
+                    f4 && (l3 = ct(i4, 1, 0, r2, s4, o4, f4));
+                    const p3 = m() + s4,
+                        g3 = p3 + r2;
+                    Ot(() => se(i4, false, "start")), "inert" in i4 && (d3 = i4.inert, i4.inert = true), b((t3) => {
+                        if (c3) {
+                            if (t3 >= g3)
+                                return a4(0, 1), se(i4, false, "end"), --u3.r || n(u3.c), false;
+                            if (t3 >= p3) {
+                                const e2 = o4((t3 - p3) / r2);
+                                a4(1 - e2, e2);
+                            }
+                        }
+                        return c3;
+                    });
+                }
+                return u3.r += 1, r(h3) ? ie().then(() => {
+                    h3 = h3(a3), f3();
+                }) : f3(), {
+                    end(t3) {
+                        t3 && "inert" in i4 && (i4.inert = d3), t3 && h3.tick && h3.tick(1, 0), c3 && (l3 && ut(i4, l3), c3 = false);
+                    }
+                };
+            }(s2, qT, {
+                duration: 300
+            })), k2 = false;
+        },
+        d(t3) {
+            t3 && E(s2), t3 && x2 && x2.end();
+        }
+    };
+}
+
+function gS(e2) {
+    let i2, s2;
+    return i2 = new Du({
+        props: {
+            name: "fail",
+            className: "w-6 h-6",
+            strokeColor: vu("red")
+        }
+    }), {
+        c() {
+            me(i2.$$.fragment);
+        },
+        m(t3, e3) {
+            ge(i2, t3, e3), s2 = true;
+        },
+        p: t,
+        i(t3) {
+            s2 || (le(i2.$$.fragment, t3), s2 = true);
+        },
+        o(t3) {
+            he(i2.$$.fragment, t3), s2 = false;
+        },
+        d(t3) {
+            ye(i2, t3);
+        }
+    };
+}
+
+function yS(e2) {
+    let i2, s2;
+    return i2 = new Du({
+        props: {
+            name: "pass",
+            className: "w-6 h-6",
+            strokeColor: vu("green")
+        }
+    }), {
+        c() {
+            me(i2.$$.fragment);
+        },
+        m(t3, e3) {
+            ge(i2, t3, e3), s2 = true;
+        },
+        p: t,
+        i(t3) {
+            s2 || (le(i2.$$.fragment, t3), s2 = true);
+        },
+        o(t3) {
+            he(i2.$$.fragment, t3), s2 = false;
+        },
+        d(t3) {
+            ye(i2, t3);
+        }
+    };
+}
+
+function vS(t3) {
+    let e2, i2, s2, n2, r2, o2, a2, l2, h2, c2, u2, d2, f2, p2, m2, g2, y2 = t3[12](`metrics.${t3[11]}.${t3[26]}`) + "",
+        v2 = t3[13].format(t3[26], t3[27]) + "",
+        b2 = t3[13].getUnit(t3[26]) + "";
+    const w2 = [yS, gS],
+        x2 = [];
+
+    function k2(t4, e3) {
+        return 2 & e3[0] && (s2 = null), null == s2 && (s2 = !!(t4[11] in Te && t4[26] in Te[t4[11]] && Te[t4[11]][t4[26]](t4[27]))), s2 ? 0 : 1;
+    }
+    return n2 = k2(t3, [-1, -1]), r2 = x2[n2] = w2[n2](t3), {
+        c() {
+            e2 = P("div"), i2 = P("div"), r2.c(), o2 = $(), a2 = P("div"), l2 = D(y2), h2 = $(), c2 = P("div"), u2 = P("span"), d2 = D(v2), f2 = P("span"), p2 = D(b2), m2 = $(), U(i2, "class", "flex justify-center w-full"), U(a2, "class", "mt-1 text-base-content-300 text-sm whitespace-no-wrap break-keep whitespace-nowrap overflow-hidden truncate stat-title"), U(u2, "class", "font-bold"), U(f2, "class", "text-sm"), U(c2, "class", "text-2xl text-base-content-200 mt-2"), U(e2, "class", "text-center px-4");
+        },
+        m(t4, s3) {
+            S(t4, e2, s3), _(e2, i2), x2[n2].m(i2, null), _(e2, o2), _(e2, a2), _(a2, l2), _(e2, h2), _(e2, c2), _(c2, u2), _(u2, d2), _(c2, f2), _(f2, p2), _(e2, m2), g2 = true;
+        },
+        p(t4, e3) {
+            let s3 = n2;
+            n2 = k2(t4, e3), n2 === s3 ? x2[n2].p(t4, e3) : (oe(), he(x2[s3], 1, 1, () => {
+                x2[s3] = null;
+            }), ae(), r2 = x2[n2], r2 ? r2.p(t4, e3) : (r2 = x2[n2] = w2[n2](t4), r2.c()), le(r2, 1), r2.m(i2, null)), (!g2 || 4098 & e3[0]) && y2 !== (y2 = t4[12](`metrics.${t4[11]}.${t4[26]}`) + "") && H(l2, y2), (!g2 || 2 & e3[0]) && v2 !== (v2 = t4[13].format(t4[26], t4[27]) + "") && H(d2, v2), (!g2 || 2 & e3[0]) && b2 !== (b2 = t4[13].getUnit(t4[26]) + "") && H(p2, b2);
+        },
+        i(t4) {
+            g2 || (le(r2), g2 = true);
+        },
+        o(t4) {
+            he(r2), g2 = false;
+        },
+        d(t4) {
+            t4 && E(e2), x2[n2].d();
+        }
+    };
+}
+
+function bS(t3) {
+    let e2, i2, s2 = ue(Object.entries(t3[1].metrics[t3[11]]).splice(0, 6)),
+        n2 = [];
+    for (let e3 = 0; e3 < s2.length; e3 += 1)
+        n2[e3] = vS(YT(t3, s2, e3));
+    const r2 = (t4) => he(n2[t4], 1, 1, () => {
+        n2[t4] = null;
+    });
+    return {
+        c() {
+            for (let t4 = 0; t4 < n2.length; t4 += 1)
+                n2[t4].c();
+            e2 = z();
+        },
+        m(t4, s3) {
+            for (let e3 = 0; e3 < n2.length; e3 += 1)
+                n2[e3] && n2[e3].m(t4, s3);
+            S(t4, e2, s3), i2 = true;
+        },
+        p(t4, i3) {
+            if (12290 & i3[0]) {
+                let o2;
+                for (s2 = ue(Object.entries(t4[1].metrics[t4[11]]).splice(0, 6)), o2 = 0; o2 < s2.length; o2 += 1) {
+                    const r3 = YT(t4, s2, o2);
+                    n2[o2] ? (n2[o2].p(r3, i3), le(n2[o2], 1)) : (n2[o2] = vS(r3), n2[o2].c(), le(n2[o2], 1), n2[o2].m(e2.parentNode, e2));
+                }
+                for (oe(), o2 = s2.length; o2 < n2.length; o2 += 1)
+                    r2(o2);
+                ae();
+            }
+        },
+        i(t4) {
+            if (!i2) {
+                for (let t5 = 0; t5 < s2.length; t5 += 1)
+                    le(n2[t5]);
+                i2 = true;
+            }
+        },
+        o(t4) {
+            n2 = n2.filter(Boolean);
+            for (let t5 = 0; t5 < n2.length; t5 += 1)
+                he(n2[t5]);
+            i2 = false;
+        },
+        d(t4) {
+            t4 && E(e2), C(n2, t4);
+        }
+    };
+}
+
+function _S(t3) {
+    let e2, i2;
+    return e2 = new Liquidity({
+        props: {
+            report: t3[1],
+            browser: t3[3],
+            theme: t3[2],
+            lang: t3[0]
+        }
+    }), {
+        c() {
+            me(e2.$$.fragment);
+        },
+        m(t4, s2) {
+            ge(e2, t4, s2), i2 = true;
+        },
+        p(t4, i3) {
+            const s2 = {};
+            2 & i3[0] && (s2.report = t4[1]), 8 & i3[0] && (s2.browser = t4[3]), 4 & i3[0] && (s2.theme = t4[2]), 1 & i3[0] && (s2.lang = t4[0]), e2.$set(s2);
+        },
+        i(t4) {
+            i2 || (le(e2.$$.fragment, t4), i2 = true);
+        },
+        o(t4) {
+            he(e2.$$.fragment, t4), i2 = false;
+        },
+        d(t4) {
+            ye(e2, t4);
+        }
+    };
+}
+
+function wS(t3) {
+    let e2, i2;
+    return e2 = new Winrate({
+        props: {
+            report: t3[1],
+            browser: t3[3],
+            theme: t3[2],
+            lang: t3[0]
+        }
+    }), {
+        c() {
+            me(e2.$$.fragment);
+        },
+        m(t4, s2) {
+            ge(e2, t4, s2), i2 = true;
+        },
+        p(t4, i3) {
+            const s2 = {};
+            2 & i3[0] && (s2.report = t4[1]), 8 & i3[0] && (s2.browser = t4[3]), 4 & i3[0] && (s2.theme = t4[2]), 1 & i3[0] && (s2.lang = t4[0]), e2.$set(s2);
+        },
+        i(t4) {
+            i2 || (le(e2.$$.fragment, t4), i2 = true);
+        },
+        o(t4) {
+            he(e2.$$.fragment, t4), i2 = false;
+        },
+        d(t4) {
+            ye(e2, t4);
+        }
+    };
+}
+
+function xS(t3) {
+    let e2, i2;
+    return e2 = new Ratio({
+        props: {
+            report: t3[1],
+            browser: t3[3],
+            theme: t3[2],
+            lang: t3[0]
+        }
+    }), {
+        c() {
+            me(e2.$$.fragment);
+        },
+        m(t4, s2) {
+            ge(e2, t4, s2), i2 = true;
+        },
+        p(t4, i3) {
+            const s2 = {};
+            2 & i3[0] && (s2.report = t4[1]), 8 & i3[0] && (s2.browser = t4[3]), 4 & i3[0] && (s2.theme = t4[2]), 1 & i3[0] && (s2.lang = t4[0]), e2.$set(s2);
+        },
+        i(t4) {
+            i2 || (le(e2.$$.fragment, t4), i2 = true);
+        },
+        o(t4) {
+            he(e2.$$.fragment, t4), i2 = false;
+        },
+        d(t4) {
+            ye(e2, t4);
+        }
+    };
+}
+
+function kS(t3) {
+    let e2, i2;
+    return e2 = new Risk({
+        props: {
+            report: t3[1],
+            browser: t3[3],
+            theme: t3[2],
+            lang: t3[0]
+        }
+    }), {
+        c() {
+            me(e2.$$.fragment);
+        },
+        m(t4, s2) {
+            ge(e2, t4, s2), i2 = true;
+        },
+        p(t4, i3) {
+            const s2 = {};
+            2 & i3[0] && (s2.report = t4[1]), 8 & i3[0] && (s2.browser = t4[3]), 4 & i3[0] && (s2.theme = t4[2]), 1 & i3[0] && (s2.lang = t4[0]), e2.$set(s2);
+        },
+        i(t4) {
+            i2 || (le(e2.$$.fragment, t4), i2 = true);
+        },
+        o(t4) {
+            he(e2.$$.fragment, t4), i2 = false;
+        },
+        d(t4) {
+            ye(e2, t4);
+        }
+    };
+}
+
+function TS(t3) {
+    let e2, i2;
+    return e2 = new Profitability({
+        props: {
+            report: t3[1],
+            browser: t3[3],
+            theme: t3[2],
+            lang: t3[0]
+        }
+    }), {
+        c() {
+            me(e2.$$.fragment);
+        },
+        m(t4, s2) {
+            ge(e2, t4, s2), i2 = true;
+        },
+        p(t4, i3) {
+            const s2 = {};
+            2 & i3[0] && (s2.report = t4[1]), 8 & i3[0] && (s2.browser = t4[3]), 4 & i3[0] && (s2.theme = t4[2]), 1 & i3[0] && (s2.lang = t4[0]), e2.$set(s2);
+        },
+        i(t4) {
+            i2 || (le(e2.$$.fragment, t4), i2 = true);
+        },
+        o(t4) {
+            he(e2.$$.fragment, t4), i2 = false;
+        },
+        d(t4) {
+            ye(e2, t4);
+        }
+    };
+}
+
+function SS(t3) {
+    let e2, i2, s2, n2, r2, o2, a2, l2 = t3[4] && ZT(t3);
+    const h2 = [sS, iS],
+        c2 = [];
+
+    function u2(t4, e3) {
+        return "分析" === t4[6] ? 0 : 1;
+    }
+    return r2 = u2(t3), o2 = c2[r2] = h2[r2](t3), {
+        c() {
+            e2 = P("div"), l2 && l2.c(), i2 = $(), s2 = P("div"), n2 = $(), o2.c();
+        },
+        m(o3, h3) {
+            S(o3, e2, h3), l2 && l2.m(e2, null), _(e2, i2), _(e2, s2), t3[18](s2), _(e2, n2), c2[r2].m(e2, null), t3[21](e2), a2 = true;
+        },
+        p(t4, s3) {
+            t4[4] ? l2 ? (l2.p(t4, s3), 16 & s3[0] && le(l2, 1)) : (l2 = ZT(t4), l2.c(), le(l2, 1), l2.m(e2, i2)) : l2 && (oe(), he(l2, 1, 1, () => {
+                l2 = null;
+            }), ae());
+            let n3 = r2;
+            r2 = u2(t4), r2 === n3 ? c2[r2].p(t4, s3) : (oe(), he(c2[n3], 1, 1, () => {
+                c2[n3] = null;
+            }), ae(), o2 = c2[r2], o2 ? o2.p(t4, s3) : (o2 = c2[r2] = h2[r2](t4), o2.c()), le(o2, 1), o2.m(e2, null));
+        },
+        i(t4) {
+            a2 || (le(l2), le(o2), a2 = true);
+        },
+        o(t4) {
+            he(l2), he(o2), a2 = false;
+        },
+        d(i3) {
+            i3 && E(e2), l2 && l2.d(), t3[18](null), c2[r2].d(), t3[21](null);
+        }
+    };
+}
+const ES = (t3) => "backtest" !== t3[0],
+    CS = (t3) => "backtest" !== t3[0];
+
+function IS(t3, e2, i2) {
+    let s2, n2, {
+            lang: r2 = "en"
+        } = e2,
+        {
+            report: o2 = null
+        } = e2,
+        {
+            theme: a2 = "light"
+        } = e2,
+        {
+            browser: l2 = true
+        } = e2,
+        {
+            reportPosition: h2 = null
+        } = e2,
+        {
+            webcomponent: c2 = false
+        } = e2;
+    const u2 = new MetricDisplay();
+    let d2, f2, p2 = "position" === localStorage.getItem("strategyAnalyticTab") ? "profitability" : localStorage.getItem("strategyAnalyticTab") || "profitability",
+        m2 = "分析";
+    async function g2() {
+        await Lt(), await new Promise((t5) => setTimeout(t5, 500));
+        let t4 = d2.scrollHeight;
+        window.parent.postMessage({
+            frameHeight: t4,
+            tab: m2 + " " + p2
+        }, "*");
+    }
+    pt(async () => {
+        await g2();
+    });
+    let y2 = null;
+
+    function v2(t4) {
+        i2(9, y2 = y2 === t4 ? null : t4);
+    }
+    return t3.$$set = (t4) => {
+        "lang" in t4 && i2(0, r2 = t4.lang), "report" in t4 && i2(1, o2 = t4.report), "theme" in t4 && i2(2, a2 = t4.theme), "browser" in t4 && i2(3, l2 = t4.browser), "reportPosition" in t4 && i2(4, h2 = t4.reportPosition), "webcomponent" in t4 && i2(5, c2 = t4.webcomponent);
+    }, t3.$$.update = () => {
+        1 & t3.$$.dirty[0] && i2(12, s2 = (t4) => "en" === r2 ? sl(t4) : nl(t4)), 2 & t3.$$.dirty[0] && i2(10, n2 = o2 ? Se(o2.metrics) : {});
+    }, [r2, o2, a2, l2, h2, c2, m2, d2, f2, y2, n2, p2, s2, u2, ["分析", "選股"], g2, v2, (t4) => {
+        i2(6, m2 = t4), void 0 !== window && window.scrollY > f2.offsetTop && window.scrollTo(0, f2.offsetTop), g2();
+    }, function(t4) {
+        xt[t4 ? "unshift" : "push"](() => {
+            f2 = t4, i2(8, f2);
+        });
+    }, (t4) => {
+        i2(9, y2 = null), i2(11, p2 = t4), localStorage.setItem("strategyAnalyticTab", t4), g2();
+    }, (t4) => {
+        v2(t4), g2();
+    }, function(t4) {
+        xt[t4 ? "unshift" : "push"](() => {
+            d2 = t4, i2(7, d2);
+        });
+    }];
+}
+class StrategyAnalytic extends SvelteComponent {
+    constructor(t3) {
+        super(), ve(this, t3, IS, SS, o, {
+            lang: 0,
+            report: 1,
+            theme: 2,
+            browser: 3,
+            reportPosition: 4,
+            webcomponent: 5
+        }, null, [-1, -1]);
+    }
+    get lang() {
+        return this.$$.ctx[0];
+    }
+    set lang(t3) {
+        this.$$set({
+            lang: t3
+        }), te();
+    }
+    get report() {
+        return this.$$.ctx[1];
+    }
+    set report(t3) {
+        this.$$set({
+            report: t3
+        }), te();
+    }
+    get theme() {
+        return this.$$.ctx[2];
+    }
+    set theme(t3) {
+        this.$$set({
+            theme: t3
+        }), te();
+    }
+    get browser() {
+        return this.$$.ctx[3];
+    }
+    set browser(t3) {
+        this.$$set({
+            browser: t3
+        }), te();
+    }
+    get reportPosition() {
+        return this.$$.ctx[4];
+    }
+    set reportPosition(t3) {
+        this.$$set({
+            reportPosition: t3
+        }), te();
+    }
+    get webcomponent() {
+        return this.$$.ctx[5];
+    }
+    set webcomponent(t3) {
+        this.$$set({
+            webcomponent: t3
+        }), te();
+    }
+}
+
+function MS(e2) {
+    let i2, s2;
+    return {
+        c() {
+            i2 = R("svg"), s2 = R("use"), U(s2, "href", e2[3]), U(s2, "fill", e2[0]), U(s2, "stroke", e2[1]), U(i2, "class", e2[2]), U(i2, "aria-hidden", "true");
+        },
+        m(t3, e3) {
+            S(t3, i2, e3), _(i2, s2);
+        },
+        p(t3, [e3]) {
+            8 & e3 && U(s2, "href", t3[3]), 1 & e3 && U(s2, "fill", t3[0]), 2 & e3 && U(s2, "stroke", t3[1]), 4 & e3 && U(i2, "class", t3[2]);
+        },
+        i: t,
+        o: t,
+        d(t3) {
+            t3 && E(i2);
+        }
+    };
+}
+
+function PS(t3, e2, i2) {
+    let s2, {
+            prefix: n2 = "icon"
+        } = e2,
+        {
+            name: r2 = ""
+        } = e2,
+        {
+            color: o2 = "#333"
+        } = e2,
+        {
+            strokeColor: a2 = ""
+        } = e2,
+        {
+            className: l2 = ""
+        } = e2;
+    return t3.$$set = (t4) => {
+        "prefix" in t4 && i2(4, n2 = t4.prefix), "name" in t4 && i2(5, r2 = t4.name), "color" in t4 && i2(0, o2 = t4.color), "strokeColor" in t4 && i2(1, a2 = t4.strokeColor), "className" in t4 && i2(2, l2 = t4.className);
+    }, t3.$$.update = () => {
+        48 & t3.$$.dirty && i2(3, s2 = `#${n2}-${r2}`);
+    }, [o2, a2, l2, s2, n2, r2];
+}
+customElements.define("strategy-analytic", we(StrategyAnalytic, {
+    lang: {},
+    report: {
+        type: "Object",
+        reflect: true
+    },
+    theme: {
+        type: "String",
+        reflect: true
+    },
+    browser: {
+        type: "Boolean",
+        reflect: true
+    },
+    reportPosition: {},
+    webcomponent: {
+        type: "Boolean",
+        reflect: true
+    }
+}, [], [], false));
+class Svgicon2 extends SvelteComponent {
+    constructor(t3) {
+        super(), ve(this, t3, PS, MS, o, {
+            prefix: 4,
+            name: 5,
+            color: 0,
+            strokeColor: 1,
+            className: 2
+        });
+    }
+    get prefix() {
+        return this.$$.ctx[4];
+    }
+    set prefix(t3) {
+        this.$$set({
+            prefix: t3
+        }), te();
+    }
+    get name() {
+        return this.$$.ctx[5];
+    }
+    set name(t3) {
+        this.$$set({
+            name: t3
+        }), te();
+    }
+    get color() {
+        return this.$$.ctx[0];
+    }
+    set color(t3) {
+        this.$$set({
+            color: t3
+        }), te();
+    }
+    get strokeColor() {
+        return this.$$.ctx[1];
+    }
+    set strokeColor(t3) {
+        this.$$set({
+            strokeColor: t3
+        }), te();
+    }
+    get className() {
+        return this.$$.ctx[2];
+    }
+    set className(t3) {
+        this.$$set({
+            className: t3
+        }), te();
+    }
+}
+we(Svgicon2, {
+    prefix: {},
+    name: {},
+    color: {},
+    strokeColor: {},
+    className: {}
+}, [], [], true);
+export {
+    xe as I,
+    Liquidity as L,
+    MetricDisplay as M,
+    Profitability as P,
+    Report as R,
+    Stocks as S,
+    Winrate as W,
+    Ratio as a,
+    Risk as b,
+    Se as c,
+    StrategyAnalytic as d,
+    Svgicon2 as e,
+    ke as o,
+    Te as q
 };
```

## finlab/core/style.css

```diff
@@ -54610,8 +54610,8 @@
 000d5510: 653a 3372 656d 3b6c 696e 652d 6865 6967  e:3rem;line-heig
 000d5520: 6874 3a31 7d7d 406d 6564 6961 2028 6d69  ht:1}}@media (mi
 000d5530: 6e2d 7769 6474 683a 2031 3238 3070 7829  n-width: 1280px)
 000d5540: 7b2e 786c 5c3a 6772 6964 2d63 6f6c 732d  {.xl\:grid-cols-
 000d5550: 347b 6772 6964 2d74 656d 706c 6174 652d  4{grid-template-
 000d5560: 636f 6c75 6d6e 733a 7265 7065 6174 2834  columns:repeat(4
 000d5570: 2c6d 696e 6d61 7828 302c 3166 7229 297d  ,minmax(0,1fr))}
-000d5580: 7d0d 0a                                  }..
+000d5580: 7d0a                                     }.
```

## finlab/ml/__init__.py

 * *Ordering differences only*

```diff
@@ -1,33 +1,33 @@
-import finlab.market_info
-
-
-_market = finlab.market_info.TWMarketInfo()
-
-def set_market(market:finlab.market_info.MarketInfo):
-
-    """
-    Set the stock market for FinLab machine learning model to generate features and labels.
-
-    Args:
-        market (MarketInfo): A MarketInfo object representing the market.
-    """
-
-    global _market
-
-    if isinstance(market, type):
-        _market = market()
-    else:
-        _market = market
-
-def get_market():
-    global _market
-    return _market
-
-def reset_market():
-
-    """
-    Reset the stock market for FinLab machine learning model to the default market, TWMarketInfo.
-    """
-
-    global _market
-    _market = TWMarketInfo()
+import finlab.market_info
+
+
+_market = finlab.market_info.TWMarketInfo()
+
+def set_market(market:finlab.market_info.MarketInfo):
+
+    """
+    Set the stock market for FinLab machine learning model to generate features and labels.
+
+    Args:
+        market (MarketInfo): A MarketInfo object representing the market.
+    """
+
+    global _market
+
+    if isinstance(market, type):
+        _market = market()
+    else:
+        _market = market
+
+def get_market():
+    global _market
+    return _market
+
+def reset_market():
+
+    """
+    Reset the stock market for FinLab machine learning model to the default market, TWMarketInfo.
+    """
+
+    global _market
+    _market = TWMarketInfo()
```

## finlab/ml/alphalens.py

 * *Ordering differences only*

```diff
@@ -1,208 +1,208 @@
-import matplotlib.pyplot as plt
-import numpy as np
-import pandas as pd
-from typing import List
-from alphalens.tears import GridFigure
-
-from alphalens import plotting
-from alphalens import performance as perf
-from alphalens import utils
-import alphalens
-from finlab.ml.feature import combine
-
-# fix error orginal code: http://quantopian.github.io/
-@plotting.customize
-def create_turnover_tear_sheet(factor_data, turnover_periods=None):
-
-    if turnover_periods is None:
-        input_periods = utils.get_forward_returns_columns(
-            factor_data.columns, require_exact_day_multiple=True,
-        ).to_numpy()
-        turnover_periods = utils.timedelta_strings_to_integers(input_periods)
-    else:
-        turnover_periods = utils.timedelta_strings_to_integers(
-            turnover_periods,
-        )
-
-    quantile_factor = factor_data["factor_quantile"]
-
-    quantile_turnover = {
-        p: pd.concat(
-            [
-                perf.quantile_turnover(quantile_factor, q, p)
-                for q in quantile_factor.sort_values().unique().tolist()
-            ],
-            axis=1,
-        )
-        for p in turnover_periods
-    }
-
-    autocorrelation = pd.concat(
-        [
-            perf.factor_rank_autocorrelation(factor_data, period)
-            for period in turnover_periods
-        ],
-        axis=1,
-    )
-
-    plotting.plot_turnover_table(autocorrelation, quantile_turnover)
-
-    fr_cols = len(turnover_periods)
-    columns_wide = 1
-    rows_when_wide = ((fr_cols - 1) // 1) + 1
-    vertical_sections = fr_cols + 3 * rows_when_wide + 2 * fr_cols
-    gf = GridFigure(rows=vertical_sections, cols=columns_wide)
-
-    for period in turnover_periods:
-        if quantile_turnover[period].isnull().all().all():
-            continue
-        plotting.plot_top_bottom_quantile_turnover(
-            quantile_turnover[period], period=period, ax=gf.next_row()
-        )
-
-    for period in autocorrelation:
-        if autocorrelation[period].isnull().all():
-            continue
-        plotting.plot_factor_rank_auto_correlation(
-            autocorrelation[period], period=period, ax=gf.next_row()
-        )
-
-    plt.show()
-    gf.close()
-
-alphalens.tears.create_turnover_tear_sheet = create_turnover_tear_sheet
-
-
-def factor_weights(factor_data,
-                   demeaned=True,
-                   group_adjust=False,
-                   equal_weight=False):
-    """
-    Computes asset weights by factor values and dividing by the sum of their
-    absolute value (achieving gross leverage of 1). Positive factor values will
-    results in positive weights and negative values in negative weights.
-
-    Args:
-        factor_data (pd.DataFrame - MultiIndex):
-            A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),
-            containing the values for a single alpha factor, forward returns for
-            each period, the factor quantile/bin that factor value belongs to, and
-            (optionally) the group the asset belongs to.
-            - See full explanation in utils.get_clean_factor_and_forward_returns
-        demeaned (bool):
-            Should this computation happen on a long short portfolio? if True,
-            weights are computed by demeaning factor values and dividing by the sum
-            of their absolute value (achieving gross leverage of 1). The sum of
-            positive weights will be the same as the negative weights (absolute
-            value), suitable for a dollar neutral long-short portfolio
-        group_adjust (bool):
-            Should this computation happen on a group neutral portfolio? If True,
-            compute group neutral weights: each group will weight the same and
-            if 'demeaned' is enabled the factor values demeaning will occur on the
-            group level.
-        equal_weight (bool, optional):
-            if True the assets will be equal-weighted instead of factor-weighted
-            If demeaned is True then the factor universe will be split in two
-            equal sized groups, top assets with positive weights and bottom assets
-            with negative weights
-
-    Returns:
-        returns : pd.Series
-            Assets weighted by factor value.
-    """
-
-    def to_weights(group, _demeaned, _equal_weight):
-
-        if _equal_weight:
-            group = group.copy()
-
-            if _demeaned:
-                # top assets positive weights, bottom ones negative
-                group = group - group.median()
-
-            negative_mask = group < 0
-            group[negative_mask] = -1.0
-            positive_mask = group > 0
-            group[positive_mask] = 1.0
-
-            if _demeaned:
-                # positive weights must equal negative weights
-                if negative_mask.any():
-                    group[negative_mask] /= negative_mask.sum()
-                if positive_mask.any():
-                    group[positive_mask] /= positive_mask.sum()
-
-        elif _demeaned:
-            group = group - group.mean()
-
-        return group / group.abs().sum()
-
-    grouper = ['date']
-    if group_adjust:
-        grouper.append('group')
-
-    weights = factor_data.groupby(grouper, group_keys=False)['factor'] \
-        .apply(to_weights, demeaned, equal_weight)
-
-    if group_adjust:
-        weights = weights.groupby(level='date', group_keys=False).apply(to_weights, False, False)
-
-    return weights
-
-from alphalens import performance
-performance.factor_weights = factor_weights
-
-
-def create_factor_data(factor:pd.DataFrame, adj_close:pd.DataFrame, 
-                       days:List[int]=[5,10,20, 60]):
-
-    '''create factor data, which contains future return
-
-    Args:
-        factor (pd.DataFrame): factor data where index is datetime and columns is asset id
-        adj_close (pd.DataFrame): adj close where index is datetime and columns is asset id
-        days (List[int]): future return considered
-        
-    Return:
-        Analytic plots and tables
-
-    Examples:
-        ``` py title="股價淨值比分析"
-        import alphalens
-        from finlab import data
-        from finlab.ml.alphalens import create_factor_data
-
-        factor = data.get('price_earning_ratio:股價淨值比')
-        adj_close = data.get('etl:adj_close')
-
-        factor_data = create_factor_data(factor, adj_close)
-
-        alphalens.tears.create_full_tear_sheet(factor_data.dropna(), long_short=False,
-                                               group_neutral=False, by_group=False)
-
-        ```
-
-    '''
-
-    adj_close = adj_close.loc[factor.index[0]:factor.index[-1]]
-    factor = factor.reindex(adj_close.index, method='ffill').loc[factor.index[0]:factor.index[-1]]
-
-    sids = adj_close.columns.intersection(factor.columns)
-    adj_close = adj_close[sids]
-    factor = factor[sids]
-
-    ret = {}
-    ret['factor'] = factor.unstack().values
-    ret['factor_quantile'] = (factor.rank(axis=1, pct=True) // 0.2).unstack().values
-
-    total_index = None
-
-    for d in days:
-        temp = (adj_close.shift(-d-1) / adj_close.shift(-1) - 1).unstack()
-        ret[f"{d}D"] = temp.values
-        total_index = temp.index
-    ret = pd.DataFrame(ret, index=total_index.swaplevel(0, 1))\
-        .replace([-np.inf, np.inf], np.nan)\
-        .dropna()
-    ret.index.names = ['date', 'asset']
-    return ret
+import matplotlib.pyplot as plt
+import numpy as np
+import pandas as pd
+from typing import List
+from alphalens.tears import GridFigure
+
+from alphalens import plotting
+from alphalens import performance as perf
+from alphalens import utils
+import alphalens
+from finlab.ml.feature import combine
+
+# fix error orginal code: http://quantopian.github.io/
+@plotting.customize
+def create_turnover_tear_sheet(factor_data, turnover_periods=None):
+
+    if turnover_periods is None:
+        input_periods = utils.get_forward_returns_columns(
+            factor_data.columns, require_exact_day_multiple=True,
+        ).to_numpy()
+        turnover_periods = utils.timedelta_strings_to_integers(input_periods)
+    else:
+        turnover_periods = utils.timedelta_strings_to_integers(
+            turnover_periods,
+        )
+
+    quantile_factor = factor_data["factor_quantile"]
+
+    quantile_turnover = {
+        p: pd.concat(
+            [
+                perf.quantile_turnover(quantile_factor, q, p)
+                for q in quantile_factor.sort_values().unique().tolist()
+            ],
+            axis=1,
+        )
+        for p in turnover_periods
+    }
+
+    autocorrelation = pd.concat(
+        [
+            perf.factor_rank_autocorrelation(factor_data, period)
+            for period in turnover_periods
+        ],
+        axis=1,
+    )
+
+    plotting.plot_turnover_table(autocorrelation, quantile_turnover)
+
+    fr_cols = len(turnover_periods)
+    columns_wide = 1
+    rows_when_wide = ((fr_cols - 1) // 1) + 1
+    vertical_sections = fr_cols + 3 * rows_when_wide + 2 * fr_cols
+    gf = GridFigure(rows=vertical_sections, cols=columns_wide)
+
+    for period in turnover_periods:
+        if quantile_turnover[period].isnull().all().all():
+            continue
+        plotting.plot_top_bottom_quantile_turnover(
+            quantile_turnover[period], period=period, ax=gf.next_row()
+        )
+
+    for period in autocorrelation:
+        if autocorrelation[period].isnull().all():
+            continue
+        plotting.plot_factor_rank_auto_correlation(
+            autocorrelation[period], period=period, ax=gf.next_row()
+        )
+
+    plt.show()
+    gf.close()
+
+alphalens.tears.create_turnover_tear_sheet = create_turnover_tear_sheet
+
+
+def factor_weights(factor_data,
+                   demeaned=True,
+                   group_adjust=False,
+                   equal_weight=False):
+    """
+    Computes asset weights by factor values and dividing by the sum of their
+    absolute value (achieving gross leverage of 1). Positive factor values will
+    results in positive weights and negative values in negative weights.
+
+    Args:
+        factor_data (pd.DataFrame - MultiIndex):
+            A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),
+            containing the values for a single alpha factor, forward returns for
+            each period, the factor quantile/bin that factor value belongs to, and
+            (optionally) the group the asset belongs to.
+            - See full explanation in utils.get_clean_factor_and_forward_returns
+        demeaned (bool):
+            Should this computation happen on a long short portfolio? if True,
+            weights are computed by demeaning factor values and dividing by the sum
+            of their absolute value (achieving gross leverage of 1). The sum of
+            positive weights will be the same as the negative weights (absolute
+            value), suitable for a dollar neutral long-short portfolio
+        group_adjust (bool):
+            Should this computation happen on a group neutral portfolio? If True,
+            compute group neutral weights: each group will weight the same and
+            if 'demeaned' is enabled the factor values demeaning will occur on the
+            group level.
+        equal_weight (bool, optional):
+            if True the assets will be equal-weighted instead of factor-weighted
+            If demeaned is True then the factor universe will be split in two
+            equal sized groups, top assets with positive weights and bottom assets
+            with negative weights
+
+    Returns:
+        returns : pd.Series
+            Assets weighted by factor value.
+    """
+
+    def to_weights(group, _demeaned, _equal_weight):
+
+        if _equal_weight:
+            group = group.copy()
+
+            if _demeaned:
+                # top assets positive weights, bottom ones negative
+                group = group - group.median()
+
+            negative_mask = group < 0
+            group[negative_mask] = -1.0
+            positive_mask = group > 0
+            group[positive_mask] = 1.0
+
+            if _demeaned:
+                # positive weights must equal negative weights
+                if negative_mask.any():
+                    group[negative_mask] /= negative_mask.sum()
+                if positive_mask.any():
+                    group[positive_mask] /= positive_mask.sum()
+
+        elif _demeaned:
+            group = group - group.mean()
+
+        return group / group.abs().sum()
+
+    grouper = ['date']
+    if group_adjust:
+        grouper.append('group')
+
+    weights = factor_data.groupby(grouper, group_keys=False)['factor'] \
+        .apply(to_weights, demeaned, equal_weight)
+
+    if group_adjust:
+        weights = weights.groupby(level='date', group_keys=False).apply(to_weights, False, False)
+
+    return weights
+
+from alphalens import performance
+performance.factor_weights = factor_weights
+
+
+def create_factor_data(factor:pd.DataFrame, adj_close:pd.DataFrame, 
+                       days:List[int]=[5,10,20, 60]):
+
+    '''create factor data, which contains future return
+
+    Args:
+        factor (pd.DataFrame): factor data where index is datetime and columns is asset id
+        adj_close (pd.DataFrame): adj close where index is datetime and columns is asset id
+        days (List[int]): future return considered
+        
+    Return:
+        Analytic plots and tables
+
+    Examples:
+        ``` py title="股價淨值比分析"
+        import alphalens
+        from finlab import data
+        from finlab.ml.alphalens import create_factor_data
+
+        factor = data.get('price_earning_ratio:股價淨值比')
+        adj_close = data.get('etl:adj_close')
+
+        factor_data = create_factor_data(factor, adj_close)
+
+        alphalens.tears.create_full_tear_sheet(factor_data.dropna(), long_short=False,
+                                               group_neutral=False, by_group=False)
+
+        ```
+
+    '''
+
+    adj_close = adj_close.loc[factor.index[0]:factor.index[-1]]
+    factor = factor.reindex(adj_close.index, method='ffill').loc[factor.index[0]:factor.index[-1]]
+
+    sids = adj_close.columns.intersection(factor.columns)
+    adj_close = adj_close[sids]
+    factor = factor[sids]
+
+    ret = {}
+    ret['factor'] = factor.unstack().values
+    ret['factor_quantile'] = (factor.rank(axis=1, pct=True) // 0.2).unstack().values
+
+    total_index = None
+
+    for d in days:
+        temp = (adj_close.shift(-d-1) / adj_close.shift(-1) - 1).unstack()
+        ret[f"{d}D"] = temp.values
+        total_index = temp.index
+    ret = pd.DataFrame(ret, index=total_index.swaplevel(0, 1))\
+        .replace([-np.inf, np.inf], np.nan)\
+        .dropna()
+    ret.index.names = ['date', 'asset']
+    return ret
```

## finlab/ml/cpcv.py

 * *Ordering differences only*

```diff
@@ -1,142 +1,142 @@
-import datetime
-import pandas as pd
-import numpy as np
-from typing import Union, List, Optional
-from itertools import combinations
-
-
-class CPCV(object):
-
-    def __init__(self, df:Union[pd.DataFrame, pd.Series], 
-                 num_splits:int=6, 
-                 test_size:int=2, 
-                 perge_period:datetime.timedelta=datetime.timedelta(days=3)):
-        
-        self.ref_df = df
-        self.num_splits = num_splits
-        self.test_size = test_size
-        self.perge_period = perge_period
-
-    def train_test_split(self, df:Optional[Union[pd.DataFrame, pd.Series]]=None):
-        return cpcv_train_test_split(df or self.ref_df, 
-                                     num_splits=self.num_splits, 
-                                     test_size=self.test_size, 
-                                     perge_period=self.perge_period)
-    
-    def combine_splits(self, splits:List[Union[pd.DataFrame, pd.Series]]):
-        return cpcv_combine_splits(splits=splits, 
-                                   df=self.ref_df, 
-                                   num_splits=self.num_splits, 
-                                   test_size=self.test_size)
-    
-    
-def get_bin_start_end(df, num_splits):
-
-    ret = []
-    block_size = int(len(df) / num_splits)
-    dt = df.index.get_level_values('datetime')
-    for i in range(num_splits):
-        t_start = dt[i * block_size]
-        t_end = dt[min((i + 1) * block_size, len(dt)-1)]
-        ret.append((t_start, t_end))
-    return ret
-
-def cpcv_train_test_split(df, num_splits=6, test_size=2, perge_period=datetime.timedelta(days=3)):
-    """
-    Performs Combinatorial Purged Cross-Validation (CPCV) on a pandas DataFrame.
-
-    Parameters:
-        df: pandas DataFrame
-        num_splits: Number of CPCV splits to perform (default=6)
-        test_size: Number of splits to use for testing (default=2)
-
-    Returns:
-        Generator that yields tuples of indices for the training and testing sets.
-    """
-    
-    # Get the start and end indices of the bins
-    bin_se = get_bin_start_end(df, num_splits)
-
-    # Create a set of bin indices
-    combs = set(range(num_splits))
-    # Get the datetime index from the DataFrame
-    dt = df.index.get_level_values('datetime')
-
-    # Iterate over combinations of test bin indices
-    for c in combinations(combs, r=test_size):
-        test_bin_ids = set(c)
-        # Calculate the train bin indices by subtracting the test bin indices from the full set
-        train_bin_ids = (combs - test_bin_ids)
-
-        # Initialize lists to store train and test indices
-        train_ids = []
-        test_ids = []
-
-        # Iterate over train bin indices
-        for i in train_bin_ids:
-            # Get the start and end indices for the current train bin
-            s, e = bin_se[i]
-
-            # If the next bin is in the test set, subtract the perged value from the end index
-            if i + 1 in test_bin_ids:
-                e -= perge_period
-
-            # Find the indices of the DataFrame that are within the start and end of the current train bin
-            train_ids.append(np.where((dt >= s) & (dt < e))[0])
-
-        # Iterate over test bin indices
-        for i in test_bin_ids:
-            # Get the start and end indices for the current test bin
-            s, e = bin_se[i]
-            # Find the indices of the DataFrame that are within the start and end of the current test bin
-            test_ids.append(np.where((dt >= s) & (dt < e))[0])
-
-        # Concatenate the train and test indices
-        is_train = np.concatenate(train_ids, axis=0)
-        is_test = np.concatenate(test_ids, axis=0)
-
-        # Yield a tuple of train and test indices
-        yield (is_train, is_test)
-
-def cpcv_combine_splits(splits:List[Union[pd.DataFrame, pd.Series]], df:Union[pd.DataFrame, pd.Series], num_splits=6, test_size=2):
-
-    """
-    Combines a list of time series datasets into a list of combined datasets.
-
-    Parameters:
-    ys: List of pandas DataFrames, each representing a time series dataset.
-
-    Returns:
-    List of pandas DataFrames, each representing a combined time series dataset.
-    """
-    
-    bin_se = get_bin_start_end(df, num_splits)
-
-    bins = {i:[] for i in range(num_splits)}
-    
-    # split dataframe into bins
-    for sp in splits:
-        
-        for i, (s, e) in enumerate(bin_se):
-            if s in sp.index:
-                dt = sp.index.get_level_values('datetime')
-                bins[i].append(sp[(dt >= s) & (dt < e)])
-
-    # check the number of bins
-    path_lengths = set([len(v) for v in bins.values()])
-    if len(path_lengths) != 1:
-        raise Exception("There is a potential bug in combine_cpcv since the lengths of path are not the same")
-    
-    # get path length
-    path_length = list(path_lengths)[0]
-
-    # combine pathes
-    paths = []
-    for p in range(path_length):
-        selected_bins = []
-        for i in range(num_splits):
-            selected_bins.append(bins[i][p])
-        
-        paths.append(pd.concat(selected_bins))
-    
-    return paths
+import datetime
+import pandas as pd
+import numpy as np
+from typing import Union, List, Optional
+from itertools import combinations
+
+
+class CPCV(object):
+
+    def __init__(self, df:Union[pd.DataFrame, pd.Series], 
+                 num_splits:int=6, 
+                 test_size:int=2, 
+                 perge_period:datetime.timedelta=datetime.timedelta(days=3)):
+        
+        self.ref_df = df
+        self.num_splits = num_splits
+        self.test_size = test_size
+        self.perge_period = perge_period
+
+    def train_test_split(self, df:Optional[Union[pd.DataFrame, pd.Series]]=None):
+        return cpcv_train_test_split(df or self.ref_df, 
+                                     num_splits=self.num_splits, 
+                                     test_size=self.test_size, 
+                                     perge_period=self.perge_period)
+    
+    def combine_splits(self, splits:List[Union[pd.DataFrame, pd.Series]]):
+        return cpcv_combine_splits(splits=splits, 
+                                   df=self.ref_df, 
+                                   num_splits=self.num_splits, 
+                                   test_size=self.test_size)
+    
+    
+def get_bin_start_end(df, num_splits):
+
+    ret = []
+    block_size = int(len(df) / num_splits)
+    dt = df.index.get_level_values('datetime')
+    for i in range(num_splits):
+        t_start = dt[i * block_size]
+        t_end = dt[min((i + 1) * block_size, len(dt)-1)]
+        ret.append((t_start, t_end))
+    return ret
+
+def cpcv_train_test_split(df, num_splits=6, test_size=2, perge_period=datetime.timedelta(days=3)):
+    """
+    Performs Combinatorial Purged Cross-Validation (CPCV) on a pandas DataFrame.
+
+    Parameters:
+        df: pandas DataFrame
+        num_splits: Number of CPCV splits to perform (default=6)
+        test_size: Number of splits to use for testing (default=2)
+
+    Returns:
+        Generator that yields tuples of indices for the training and testing sets.
+    """
+    
+    # Get the start and end indices of the bins
+    bin_se = get_bin_start_end(df, num_splits)
+
+    # Create a set of bin indices
+    combs = set(range(num_splits))
+    # Get the datetime index from the DataFrame
+    dt = df.index.get_level_values('datetime')
+
+    # Iterate over combinations of test bin indices
+    for c in combinations(combs, r=test_size):
+        test_bin_ids = set(c)
+        # Calculate the train bin indices by subtracting the test bin indices from the full set
+        train_bin_ids = (combs - test_bin_ids)
+
+        # Initialize lists to store train and test indices
+        train_ids = []
+        test_ids = []
+
+        # Iterate over train bin indices
+        for i in train_bin_ids:
+            # Get the start and end indices for the current train bin
+            s, e = bin_se[i]
+
+            # If the next bin is in the test set, subtract the perged value from the end index
+            if i + 1 in test_bin_ids:
+                e -= perge_period
+
+            # Find the indices of the DataFrame that are within the start and end of the current train bin
+            train_ids.append(np.where((dt >= s) & (dt < e))[0])
+
+        # Iterate over test bin indices
+        for i in test_bin_ids:
+            # Get the start and end indices for the current test bin
+            s, e = bin_se[i]
+            # Find the indices of the DataFrame that are within the start and end of the current test bin
+            test_ids.append(np.where((dt >= s) & (dt < e))[0])
+
+        # Concatenate the train and test indices
+        is_train = np.concatenate(train_ids, axis=0)
+        is_test = np.concatenate(test_ids, axis=0)
+
+        # Yield a tuple of train and test indices
+        yield (is_train, is_test)
+
+def cpcv_combine_splits(splits:List[Union[pd.DataFrame, pd.Series]], df:Union[pd.DataFrame, pd.Series], num_splits=6, test_size=2):
+
+    """
+    Combines a list of time series datasets into a list of combined datasets.
+
+    Parameters:
+    ys: List of pandas DataFrames, each representing a time series dataset.
+
+    Returns:
+    List of pandas DataFrames, each representing a combined time series dataset.
+    """
+    
+    bin_se = get_bin_start_end(df, num_splits)
+
+    bins = {i:[] for i in range(num_splits)}
+    
+    # split dataframe into bins
+    for sp in splits:
+        
+        for i, (s, e) in enumerate(bin_se):
+            if s in sp.index:
+                dt = sp.index.get_level_values('datetime')
+                bins[i].append(sp[(dt >= s) & (dt < e)])
+
+    # check the number of bins
+    path_lengths = set([len(v) for v in bins.values()])
+    if len(path_lengths) != 1:
+        raise Exception("There is a potential bug in combine_cpcv since the lengths of path are not the same")
+    
+    # get path length
+    path_length = list(path_lengths)[0]
+
+    # combine pathes
+    paths = []
+    for p in range(path_length):
+        selected_bins = []
+        for i in range(num_splits):
+            selected_bins.append(bins[i][p])
+        
+        paths.append(pd.concat(selected_bins))
+    
+    return paths
```

## finlab/ml/feature.py

```diff
@@ -1,458 +1,462 @@
-import re
-import gc
-import sys
-import copy
-import random
-import logging
-import traceback
-import numpy as np
-import pandas as pd
-from functools import lru_cache
-from typing import List, Protocol, Dict, Optional, Generator
-
-import talib
-from talib import abstract
-
-from finlab import ml
-from finlab import data
-import finlab.market_info
-from finlab.ml.utils import resampler
-from finlab.dataframe import FinlabDataFrame
-
-
-class IndicatorName():
-  
-    @staticmethod
-    def encode(package_name, func, output, params):
-
-        encoded = package_name + '.' + func + '__' + output + '__'
-        for k, v in params.items():
-          encoded += f'{k}__{v}__'
-
-        return encoded
-    
-    @staticmethod
-    def decode(encoded):
-      
-        tokens = encoded.split('__')
-        
-        func = tokens[0].split('.')[-1]
-        output = tokens[1]
-        params = dict(zip(tokens[2:][::2], tokens[2:][1::2]))
-
-        return func, output, params
-
-
-class TalibIndicatorFactory():
-
-    @staticmethod
-    def set_dynamic_types(f, params):
-
-        ret = {}
-        for k, v in params.items():
-            try:
-                f.set_parameters(**{k:v})
-
-            except Exception as ex:
-                s = str(ex)
-                regex = re.compile(r'expected\s([a-z]*),\s')
-                match = regex.search(s)
-                correct_type = match.group(1)
-                v = {'int':int, 'float': float}[correct_type](v)
-                f.set_parameters(**{k:v})
-
-            ret[k] = v
-
-        return ret
-  
-    def calculate_indicator(self, func, output, params, adj=False, market=None):
-
-        if market is None:
-            print("market is None. set to default")
-            market = ml.get_market()
-      
-        func = func.split('.')[0]
-
-        # get ith output
-        f = getattr(abstract, func)
-        org_params = copy.copy(f.parameters)
-        org_params = self.set_dynamic_types(f, org_params)
-
-        params = self.set_dynamic_types(f, params)
-        f.set_parameters(org_params)
-        target_i = -1
-        for i, o in enumerate(f.output_names):
-            if o == output:
-                target_i = i
-                break
-
-        if target_i == -1:
-            raise Exception("Cannot find output names")
-        
-        # apply talib
-        indicator = data.indicator(func, adj=adj, market=market, **params)
-        f.set_parameters(org_params)
-
-        if isinstance(indicator, tuple):
-            indicator = indicator[target_i]
-
-        # normalize result
-        if func in TalibIndicatorFactory.normalized_funcs():
-            indicator /= market.get_price('close', adj=adj)
-
-        return indicator
-    
-    @staticmethod
-    def all_functions():
-        talib_categories = [
-          'Cycle Indicators', 
-          'Momentum Indicators', 
-          'Overlap Studies', 
-          'Price Transform', 
-          'Statistic Functions', 
-          'Volatility Indicators']
-
-        talib_functions = sum([talib.get_function_groups()[c] for c in talib_categories], [])
-        talib_functions = ['talib.'+f for f in talib_functions if f != 'SAREXT' and f != 'MAVP']
-        return talib_functions
-
-    @staticmethod
-    @lru_cache
-    def normalized_funcs():
-      talib_normalized = talib.get_function_groups()['Overlap Studies']\
-        + talib.get_function_groups()['Price Transform']\
-        + ['APO', 'MACD', 'MACDEXT', 'MACDFIX', 'MOM', 'MINUS_DM', 'PLUS_DM', 'HT_PHASOR']
-      return [t for t in talib_normalized]
-    
-    def generate_feature_names(self, func, lb, ub, n):
-
-        func = func.split('.')[-1]
-
-        if func == 'MAMA':
-            return []
-
-        f = getattr(abstract, func)
-        outputs = f.output_names
-        org_params = f.parameters
-        params_lb = {k:v*lb for k, v in org_params.items()}
-        params_ub = {k:v*ub for k, v in org_params.items()}
-        
-        min_value = {
-          'signalperiod': 2,
-          'timeperiod': 2,
-          'fastperiod': 2,
-          'slowperiod': 2,
-          'timeperiod1': 2, 'timeperiod2': 2,
-          'timeperiod3': 2,
-          'fastk_period': 2, 
-          'fastd_period': 2,
-          'slowk_period': 2,
-          'slowd_period': 2,
-          'vfactor': 0,
-        }
-
-        ret = []
-        for _ in range(n):
-
-          new_params = {}
-          for k, v in org_params.items():
-            rvalue = np.random.random_sample(1)[0] * (params_ub[k] - params_lb[k]) + params_lb[k]
-            rvalue = type(v)(rvalue)
-            new_params[k] = rvalue
-            
-          
-          if 'nbdevup' in new_params:
-            new_params['nbdevup'] = 2.0
-          if 'nbdevdn' in new_params:
-            new_params['nbdevdn'] = 2.0
-          if 'vfactor' in new_params:
-            new_params['vfactor'] = float(random.uniform(0, 1))
-          if 'nbdev' in new_params:
-            new_params['nbdev'] = 2.5
-            
-          for p in new_params:
-            if p in min_value and new_params[p] < min_value[p]:
-              new_params[p] = min_value[p]
-            
-          for o in outputs:
-            ret.append(IndicatorName.encode('talib', func, o, new_params))
-
-        return list(set(ret))
-
-class Factory(Protocol):
-    def __init__(self, market:Optional[finlab.market_info.MarketInfo]) -> None:
-        pass
-
-    def all_functions(self) -> List[str]:
-        return []
-
-    def calculate_indicator(self, func, output, params) -> pd.DataFrame:
-        return pd.DataFrame()
-
- 
-def ta_names(lb:int=1, ub:int=10, n:int=1, factory=None) -> List[str]:
-    """
-    Generate a list of technical indicator feature names.
-
-    Args:
-        lb (int): The lower bound of the multiplier of the default parameter for the technical indicators.
-        ub (int): The upper bound of the multiplier of the default parameter for the technical indicators.
-        n (int): The number of random samples for each technical indicator.
-        factory (IndicatorFactory): A factory object to generate technical indicators.
-            Defaults to TalibIndicatorFactory.
-
-    Returns:
-        List[str]: A list of technical indicator feature names.
-
-    Examples:
-        ```py
-        import finlab.ml.feature as f
-
-
-        # method 1: generate each indicator with random parameters
-        features = f.ta()
-
-        # method 2: generate specific indicator
-        feature_names = ['talib.MACD__macdhist__fastperiod__52__slowperiod__212__signalperiod__75__']
-        features = f.ta(feature_names, resample='W')
-
-        # method 3: generate some indicator
-        feature_names = f.ta_names()
-        features = f.ta(feature_names)
-        ```
-    """
-
-    if factory is None:
-        factory = TalibIndicatorFactory()
-
-    return sum([factory.generate_feature_names(f, lb, ub, n) for f in factory.all_functions()], [])
-
-
-def create_feature(params):
-
-    name, factories, resample, end_time, adj, kwargs = params[:6]
-    market = finlab.market_info.MarketInfoSharedMemory.from_args(*params[6:])
-    func, output, params = IndicatorName.decode(name)
-
-    factory = factories[name.split('.')[0]]
-    try:
-        f = resampler(factory.calculate_indicator(func, output, params, adj=adj, market=market), resample, **kwargs).T.unstack()
-        return name, np.array(f.values)
-
-    except Exception as e:
-        traceback.print_exc(file=sys.stdout)
-        logging.warn(f"Cannot calculate indicator {(func, output, params)}. Skipped")
-        logging.warn(f"Exception occurred: {traceback.format_exc()}")
-    return None
-
-
-def ta(feature_names:Optional[List[str]], 
-       factories=None,
-       resample=None, 
-       start_time=None, 
-       end_time=None, 
-       adj=False,
-       cpu=-1,
-       **kwargs) -> pd.DataFrame:
-    """Calculate technical indicator values for a list of feature names.
-
-    Args:
-        feature_names (Optional[List[str]]): A list of technical indicator feature names. Defaults to None.
-        factories (Optioanl[Dict[str, TalibIndicatorFactory]]): A dictionary of factories to generate technical indicators. Defaults to {"talib": TalibIndicatorFactory()}.
-        resample (Optional[str]): The frequency to resample the data to. Defaults to None.
-        start_time (Optional[str]): The start time of the data. Defaults to None.
-        end_time (Optional[str]): The end time of the data. Defaults to None.
-        **kwargs: Additional keyword arguments to pass to the resampler function.
-
-    Returns:
-        pd.DataFrame: technical indicator feature names and their corresponding values.
-    """
-
-    if factories is None:
-        factories = {'talib':TalibIndicatorFactory()}
-
-    if feature_names is None:
-        feature_names = ta_names()
-
-    if cpu == -1:
-        import multiprocessing
-        cpu = multiprocessing.cpu_count()
-
-    if cpu == 1:
-        market = ml.get_market()
-    else:
-        market = finlab.market_info.MarketInfoSharedMemory(ml.get_market(), adj=adj, start_time=start_time, end_time=end_time)
-
-    test_f = resampler(TalibIndicatorFactory().calculate_indicator("RSI", 'real', {}, adj=adj, market=market), 
-                       resample, **kwargs).T.unstack()
-
-    final_columns = []
-
-    def create_features() -> Generator[np.ndarray, None, None]:
-
-        nonlocal final_columns
-
-        if cpu == 1:
-            for name in feature_names:
-
-                # parallel processing wrapper function
-                # name, values = create_feature((name, factories, resample, end_time, adj, kwargs) + tuple([market.to_args()]))
-
-                # single processing
-                values = resampler(factory.calculate_indicator(func, output, params, adj=adj, market=market), resample, **kwargs).T.unstack()
-                if values is not None:
-                    final_columns.append(name)
-                    yield values
-        else:
-            import multiprocessing
-            with multiprocessing.Pool(processes=cpu) as pool:
-
-                for result in pool.imap_unordered(
-                                            create_feature, 
-                                            [(name, factories, resample, end_time, adj, kwargs) + tuple([market.to_args()])
-                                            for name in feature_names]):
-                    if result is not None:
-                        name, values = result
-                        final_columns.append(name)
-                        yield values
-
-
-    values = np.fromiter(
-            create_features(), 
-            dtype=np.dtype((np.float64, len(test_f))))
-    
-    market.close()
-
-    final_names = set(final_columns)
-    ordered_names = [n for n in feature_names if n in final_names]
-
-    ret = pd.DataFrame(values.T, index=test_f.index, 
-                       columns=final_columns, copy=False)
-    
-    ret.index.names = ['datetime', 'instrument']
-    return ret[ordered_names]
-
-
-
-def combine(features:Dict[str, pd.DataFrame], resample=None, sample_filter=None, **kwargs):
-
-    """The combine function takes a dictionary of features as input and combines them into a single pandas DataFrame. combine 函數接受一個特徵字典作為輸入，並將它們合併成一個 pandas DataFrame。
-
-    Args:
-        features (Dict[str, pd.DataFrame]): a dictionary of features where index is datetime and column is instrument. 一個特徵字典，其中索引為日期時間，欄位為證券代碼。
-        resample (str): Optional argument to resample the data in the features. Default is None. 選擇性的參數，用於重新取樣特徵中的資料。預設為 None。
-        sample_filter (pd.DataFrame): a boolean dictionary where index is date and columns are instrument representing the filter of features.
-        **kwargs: Additional keyword arguments to pass to the resampler function. 傳遞給重新取樣函數 resampler 的其他關鍵字引數。
-
-    Returns:
-        A pandas DataFrame containing all the input features combined. 一個包含所有輸入特徵合併後的 pandas DataFrame。
-
-    Examples:
-        這段程式碼教我們如何使用finlab.ml.feature和finlab.data模組，來合併兩個特徵：RSI和股價淨值比。我們使用f.combine函數來進行合併，其中特徵的名稱是字典的鍵，對應的資料是值。
-        我們從data.indicator('RSI')取得'rsi'特徵，這個函數計算相對強弱指數。我們從data.get('price_earning_ratio:股價淨值比')取得'pb'特徵，這個函數獲取股價淨值比。最後，我們得到一個包含這兩個特徵的DataFrame。
-
-        ``` py
-        from finlab import data
-        import finlab.ml.feature as f
-        import finlab.ml.qlib as q
-
-        features = f.combine({
-            
-            # 用 data.get 簡單產生出技術指標
-            'pb': data.get('price_earning_ratio:股價淨值比'),
-
-            # 用 data.indicator 產生技術指標的特徵
-            'rsi': data.indicator('RSI'),
-
-            # 用 f.ta 枚舉超多種 talib 指標
-            'talib': f.ta(f.ta_names()),
-
-            # 利用 qlib alph158 產生技術指標的特徵(請先執行 q.init(), q.dump() 才能使用)
-            'qlib158': q.alpha('Alpha158')
-
-            })
-
-        features.head()
-        ```
-
-        |    datetime   | instrument |     rsi    |     pb     |
-        |---------------|------------|------------|------------|
-        |   2020-01-01  |    1101    |     0      |     2      |
-        |   2020-01-02  |    1102    |     100    |     3      |
-        |   2020-01-03  |    1108    |     100    |     4      |
-
-    """
-
-    if len(features) == 0:
-        return pd.DataFrame()
-
-    def resampling(df) -> pd.DataFrame:
-        return resampler(df, resample, **kwargs)
-    
-    unstacked = {}
-
-    union_index = None
-    union_columns = None
-    unstacked = {}
-    concats = []
-
-    for name, df in features.items():
-
-        if isinstance(df.index, pd.MultiIndex):
-            concats.append(df)
-        else:
-            if isinstance(df, FinlabDataFrame):
-                df = df.index_str_to_date()
-
-            udf = resampling(df)
-            unstacked[name] = udf
-            if union_index is not None:
-                union_index = union_index.union(udf.index)
-            else:
-                union_index = udf.index
-            if union_columns is not None:
-                union_columns = union_columns.intersection(udf.columns)
-            else:
-                union_columns = udf.columns
-            
-    final_index = None
-    for name, udf in unstacked.items():
-        udf = udf\
-            .reindex(index=union_index, columns=union_columns)\
-            .ffill()\
-            .T\
-            .unstack()
-        unstacked[name] = udf.values
-
-        if final_index is None:
-            final_index = udf.index
-
-    for i, c in enumerate(concats):
-        c.index = c.index.set_names(['datetime', 'instrument'])
-        if union_index is not None:
-            concats[i] = c[c.index.get_level_values('datetime').isin(union_index)]
-
-    if unstacked:
-        unstack_df = pd.DataFrame(unstacked, index=final_index)
-        # unstack_df = unstack_df.swaplevel(0, 1)
-        unstack_df.index = unstack_df.index.set_names(['datetime', 'instrument'])
-        concats.append(unstack_df)
-
-    ret = pd.concat(concats, axis=1)
-    ret.sort_index(inplace=True)
-
-    if sample_filter is not None:
-        if isinstance(sample_filter, FinlabDataFrame):
-            sample_filter = sample_filter.index_str_to_date()
-        usf = resampling(sample_filter)
-
-        if union_index is not None and union_columns is not None:
-            usf = usf.reindex(index=union_index, columns=union_columns)
-
-        usf = usf.ffill()\
-           .T\
-           .unstack()\
-           .reindex(ret.index).fillna(False)
-        ret = ret[usf.values]
-
-    return ret
+import re
+import gc
+import sys
+import copy
+import random
+import logging
+import traceback
+import numpy as np
+import pandas as pd
+from functools import lru_cache
+from typing import List, Protocol, Dict, Optional, Generator
+
+import talib
+from talib import abstract
+
+from finlab import ml
+from finlab import data
+import finlab.market_info
+from finlab.ml.utils import resampler
+from finlab.dataframe import FinlabDataFrame
+
+
+class IndicatorName():
+  
+    @staticmethod
+    def encode(package_name, func, output, params):
+
+        encoded = package_name + '.' + func + '__' + output + '__'
+        for k, v in params.items():
+          encoded += f'{k}__{v}__'
+
+        return encoded
+    
+    @staticmethod
+    def decode(encoded):
+      
+        tokens = encoded.split('__')
+        
+        func = tokens[0].split('.')[-1]
+        output = tokens[1]
+        params = dict(zip(tokens[2:][::2], tokens[2:][1::2]))
+
+        return func, output, params
+
+
+class TalibIndicatorFactory():
+
+    @staticmethod
+    def set_dynamic_types(f, params):
+
+        ret = {}
+        for k, v in params.items():
+            try:
+                f.set_parameters(**{k:v})
+
+            except Exception as ex:
+                s = str(ex)
+                regex = re.compile(r'expected\s([a-z]*),\s')
+                match = regex.search(s)
+                correct_type = match.group(1)
+                v = {'int':int, 'float': float}[correct_type](v)
+                f.set_parameters(**{k:v})
+
+            ret[k] = v
+
+        return ret
+  
+    def calculate_indicator(self, func, output, params, adj=False, market=None):
+
+        if market is None:
+            print("market is None. set to default")
+            market = ml.get_market()
+      
+        func = func.split('.')[0]
+
+        # get ith output
+        f = getattr(abstract, func)
+        org_params = copy.copy(f.parameters)
+        org_params = self.set_dynamic_types(f, org_params)
+
+        params = self.set_dynamic_types(f, params)
+        f.set_parameters(org_params)
+        target_i = -1
+        for i, o in enumerate(f.output_names):
+            if o == output:
+                target_i = i
+                break
+
+        if target_i == -1:
+            raise Exception("Cannot find output names")
+        
+        # apply talib
+        indicator = data.indicator(func, adj=adj, market=market, **params)
+        f.set_parameters(org_params)
+
+        if isinstance(indicator, tuple):
+            indicator = indicator[target_i]
+
+        # normalize result
+        if func in TalibIndicatorFactory.normalized_funcs():
+            indicator /= market.get_price('close', adj=adj)
+
+        return indicator
+    
+    @staticmethod
+    def all_functions():
+        talib_categories = [
+          'Cycle Indicators', 
+          'Momentum Indicators', 
+          'Overlap Studies', 
+          'Price Transform', 
+          'Statistic Functions', 
+          'Volatility Indicators']
+
+        talib_functions = sum([talib.get_function_groups()[c] for c in talib_categories], [])
+        talib_functions = ['talib.'+f for f in talib_functions if f != 'SAREXT' and f != 'MAVP']
+        return talib_functions
+
+    @staticmethod
+    @lru_cache
+    def normalized_funcs():
+      talib_normalized = talib.get_function_groups()['Overlap Studies']\
+        + talib.get_function_groups()['Price Transform']\
+        + ['APO', 'MACD', 'MACDEXT', 'MACDFIX', 'MOM', 'MINUS_DM', 'PLUS_DM', 'HT_PHASOR']
+      return [t for t in talib_normalized]
+    
+    def generate_feature_names(self, func, lb, ub, n):
+
+        func = func.split('.')[-1]
+
+        if func == 'MAMA':
+            return []
+
+        f = getattr(abstract, func)
+        outputs = f.output_names
+        org_params = f.parameters
+        params_lb = {k:v*lb for k, v in org_params.items()}
+        params_ub = {k:v*ub for k, v in org_params.items()}
+        
+        min_value = {
+          'signalperiod': 2,
+          'timeperiod': 2,
+          'fastperiod': 2,
+          'slowperiod': 2,
+          'timeperiod1': 2, 'timeperiod2': 2,
+          'timeperiod3': 2,
+          'fastk_period': 2, 
+          'fastd_period': 2,
+          'slowk_period': 2,
+          'slowd_period': 2,
+          'vfactor': 0,
+        }
+
+        ret = []
+        for _ in range(n):
+
+          new_params = {}
+          for k, v in org_params.items():
+            rvalue = np.random.random_sample(1)[0] * (params_ub[k] - params_lb[k]) + params_lb[k]
+            rvalue = type(v)(rvalue)
+            new_params[k] = rvalue
+            
+          
+          if 'nbdevup' in new_params:
+            new_params['nbdevup'] = 2.0
+          if 'nbdevdn' in new_params:
+            new_params['nbdevdn'] = 2.0
+          if 'vfactor' in new_params:
+            new_params['vfactor'] = float(random.uniform(0, 1))
+          if 'nbdev' in new_params:
+            new_params['nbdev'] = 2.5
+            
+          for p in new_params:
+            if p in min_value and new_params[p] < min_value[p]:
+              new_params[p] = min_value[p]
+            
+          for o in outputs:
+            ret.append(IndicatorName.encode('talib', func, o, new_params))
+
+        return list(set(ret))
+
+class Factory(Protocol):
+    def __init__(self, market:Optional[finlab.market_info.MarketInfo]) -> None:
+        pass
+
+    def all_functions(self) -> List[str]:
+        return []
+
+    def calculate_indicator(self, func, output, params) -> pd.DataFrame:
+        return pd.DataFrame()
+
+ 
+def ta_names(lb:int=1, ub:int=10, n:int=1, factory=None) -> List[str]:
+    """
+    Generate a list of technical indicator feature names.
+
+    Args:
+        lb (int): The lower bound of the multiplier of the default parameter for the technical indicators.
+        ub (int): The upper bound of the multiplier of the default parameter for the technical indicators.
+        n (int): The number of random samples for each technical indicator.
+        factory (IndicatorFactory): A factory object to generate technical indicators.
+            Defaults to TalibIndicatorFactory.
+
+    Returns:
+        List[str]: A list of technical indicator feature names.
+
+    Examples:
+        ```py
+        import finlab.ml.feature as f
+
+
+        # method 1: generate each indicator with random parameters
+        features = f.ta()
+
+        # method 2: generate specific indicator
+        feature_names = ['talib.MACD__macdhist__fastperiod__52__slowperiod__212__signalperiod__75__']
+        features = f.ta(feature_names, resample='W')
+
+        # method 3: generate some indicator
+        feature_names = f.ta_names()
+        features = f.ta(feature_names)
+        ```
+    """
+
+    if factory is None:
+        factory = TalibIndicatorFactory()
+
+    return sum([factory.generate_feature_names(f, lb, ub, n) for f in factory.all_functions()], [])
+
+
+def create_feature(params):
+
+    name, factories, resample, end_time, adj, kwargs = params[:6]
+    market = finlab.market_info.MarketInfoSharedMemory.from_args(*params[6:])
+    func, output, params = IndicatorName.decode(name)
+
+    factory = factories[name.split('.')[0]]
+    try:
+        f = resampler(factory.calculate_indicator(func, output, params, adj=adj, market=market), resample, **kwargs).T.unstack()
+        return name, np.array(f.values)
+
+    except Exception as e:
+        traceback.print_exc(file=sys.stdout)
+        logging.warn(f"Cannot calculate indicator {(func, output, params)}. Skipped")
+        logging.warn(f"Exception occurred: {traceback.format_exc()}")
+    return None
+
+
+def ta(feature_names:Optional[List[str]], 
+       factories=None,
+       resample=None, 
+       start_time=None, 
+       end_time=None, 
+       adj=False,
+       cpu=-1,
+       **kwargs) -> pd.DataFrame:
+    """Calculate technical indicator values for a list of feature names.
+
+    Args:
+        feature_names (Optional[List[str]]): A list of technical indicator feature names. Defaults to None.
+        factories (Optioanl[Dict[str, TalibIndicatorFactory]]): A dictionary of factories to generate technical indicators. Defaults to {"talib": TalibIndicatorFactory()}.
+        resample (Optional[str]): The frequency to resample the data to. Defaults to None.
+        start_time (Optional[str]): The start time of the data. Defaults to None.
+        end_time (Optional[str]): The end time of the data. Defaults to None.
+        **kwargs: Additional keyword arguments to pass to the resampler function.
+
+    Returns:
+        pd.DataFrame: technical indicator feature names and their corresponding values.
+    """
+
+    if factories is None:
+        factories = {'talib':TalibIndicatorFactory()}
+
+    if feature_names is None:
+        feature_names = ta_names()
+
+    if cpu == -1:
+        import multiprocessing
+        cpu = multiprocessing.cpu_count()
+
+    if cpu == 1:
+        market = ml.get_market()
+    else:
+        market = finlab.market_info.MarketInfoSharedMemory(ml.get_market(), adj=adj, start_time=start_time, end_time=end_time)
+
+    test_f = resampler(TalibIndicatorFactory().calculate_indicator("RSI", 'real', {}, adj=adj, market=market), 
+                       resample, **kwargs).T.unstack()
+
+    final_columns = []
+
+    def create_features() -> Generator[np.ndarray, None, None]:
+
+        nonlocal final_columns
+
+        if cpu == 1:
+            for name in feature_names:
+
+                # parallel processing wrapper function
+                # name, values = create_feature((name, factories, resample, end_time, adj, kwargs) + tuple([market.to_args()]))
+
+                # single processing
+                func, output, params = IndicatorName.decode(name)
+
+                factory = factories[name.split('.')[0]]
+                values = resampler(factory.calculate_indicator(func, output, params, adj=adj, market=market), resample, **kwargs).T.unstack()
+                if values is not None:
+                    final_columns.append(name)
+                    yield values
+        else:
+            import multiprocessing
+            with multiprocessing.Pool(processes=cpu) as pool:
+
+                for result in pool.imap_unordered(
+                                            create_feature, 
+                                            [(name, factories, resample, end_time, adj, kwargs) + tuple([market.to_args()])
+                                            for name in feature_names]):
+                    if result is not None:
+                        name, values = result
+                        final_columns.append(name)
+                        yield values
+
+
+    values = np.fromiter(
+            create_features(), 
+            dtype=np.dtype((np.float64, len(test_f))))
+    
+    if cpu != 1:
+        market.close()
+
+    final_names = set(final_columns)
+    ordered_names = [n for n in feature_names if n in final_names]
+
+    ret = pd.DataFrame(values.T, index=test_f.index, 
+                       columns=final_columns, copy=False)
+    
+    ret.index.names = ['datetime', 'instrument']
+    return ret[ordered_names]
+
+
+
+def combine(features:Dict[str, pd.DataFrame], resample=None, sample_filter=None, **kwargs):
+
+    """The combine function takes a dictionary of features as input and combines them into a single pandas DataFrame. combine 函數接受一個特徵字典作為輸入，並將它們合併成一個 pandas DataFrame。
+
+    Args:
+        features (Dict[str, pd.DataFrame]): a dictionary of features where index is datetime and column is instrument. 一個特徵字典，其中索引為日期時間，欄位為證券代碼。
+        resample (str): Optional argument to resample the data in the features. Default is None. 選擇性的參數，用於重新取樣特徵中的資料。預設為 None。
+        sample_filter (pd.DataFrame): a boolean dictionary where index is date and columns are instrument representing the filter of features.
+        **kwargs: Additional keyword arguments to pass to the resampler function. 傳遞給重新取樣函數 resampler 的其他關鍵字引數。
+
+    Returns:
+        A pandas DataFrame containing all the input features combined. 一個包含所有輸入特徵合併後的 pandas DataFrame。
+
+    Examples:
+        這段程式碼教我們如何使用finlab.ml.feature和finlab.data模組，來合併兩個特徵：RSI和股價淨值比。我們使用f.combine函數來進行合併，其中特徵的名稱是字典的鍵，對應的資料是值。
+        我們從data.indicator('RSI')取得'rsi'特徵，這個函數計算相對強弱指數。我們從data.get('price_earning_ratio:股價淨值比')取得'pb'特徵，這個函數獲取股價淨值比。最後，我們得到一個包含這兩個特徵的DataFrame。
+
+        ``` py
+        from finlab import data
+        import finlab.ml.feature as f
+        import finlab.ml.qlib as q
+
+        features = f.combine({
+            
+            # 用 data.get 簡單產生出技術指標
+            'pb': data.get('price_earning_ratio:股價淨值比'),
+
+            # 用 data.indicator 產生技術指標的特徵
+            'rsi': data.indicator('RSI'),
+
+            # 用 f.ta 枚舉超多種 talib 指標
+            'talib': f.ta(f.ta_names()),
+
+            # 利用 qlib alph158 產生技術指標的特徵(請先執行 q.init(), q.dump() 才能使用)
+            'qlib158': q.alpha('Alpha158')
+
+            })
+
+        features.head()
+        ```
+
+        |    datetime   | instrument |     rsi    |     pb     |
+        |---------------|------------|------------|------------|
+        |   2020-01-01  |    1101    |     0      |     2      |
+        |   2020-01-02  |    1102    |     100    |     3      |
+        |   2020-01-03  |    1108    |     100    |     4      |
+
+    """
+
+    if len(features) == 0:
+        return pd.DataFrame()
+
+    def resampling(df) -> pd.DataFrame:
+        return resampler(df, resample, **kwargs)
+    
+    unstacked = {}
+
+    union_index = None
+    union_columns = None
+    unstacked = {}
+    concats = []
+
+    for name, df in features.items():
+
+        if isinstance(df.index, pd.MultiIndex):
+            concats.append(df)
+        else:
+            if isinstance(df, FinlabDataFrame):
+                df = df.index_str_to_date()
+
+            udf = resampling(df)
+            unstacked[name] = udf
+            if union_index is not None:
+                union_index = union_index.union(udf.index)
+            else:
+                union_index = udf.index
+            if union_columns is not None:
+                union_columns = union_columns.intersection(udf.columns)
+            else:
+                union_columns = udf.columns
+            
+    final_index = None
+    for name, udf in unstacked.items():
+        udf = udf\
+            .reindex(index=union_index, columns=union_columns)\
+            .ffill()\
+            .T\
+            .unstack()
+        unstacked[name] = udf.values
+
+        if final_index is None:
+            final_index = udf.index
+
+    for i, c in enumerate(concats):
+        c.index = c.index.set_names(['datetime', 'instrument'])
+        if union_index is not None:
+            concats[i] = c[c.index.get_level_values('datetime').isin(union_index)]
+
+    if unstacked:
+        unstack_df = pd.DataFrame(unstacked, index=final_index)
+        # unstack_df = unstack_df.swaplevel(0, 1)
+        unstack_df.index = unstack_df.index.set_names(['datetime', 'instrument'])
+        concats.append(unstack_df)
+
+    ret = pd.concat(concats, axis=1)
+    ret.sort_index(inplace=True)
+
+    if sample_filter is not None:
+        if isinstance(sample_filter, FinlabDataFrame):
+            sample_filter = sample_filter.index_str_to_date()
+        usf = resampling(sample_filter)
+
+        if union_index is not None and union_columns is not None:
+            usf = usf.reindex(index=union_index, columns=union_columns)
+
+        usf = usf.ffill()\
+           .T\
+           .unstack()\
+           .reindex(ret.index).fillna(False)
+        ret = ret[usf.values]
+
+    return ret
```

## finlab/ml/label.py

 * *Ordering differences only*

```diff
@@ -1,154 +1,154 @@
-import pandas as pd
-from finlab import ml
-from finlab.ml.utils import resampler
-
-
-def align_to_feature(index: pd.Index, df: pd.DataFrame):
-    ret = df.unstack().swaplevel(0, 1).reindex(index)
-    ret.index = ret.index.set_names(['datetime', 'instrument'])
-    return ret
-
-def daytrading_percentage(index: pd.Index, **kwargs):
-    """Calculate the percentage change of market prices over a given period.
-
-    Args:
-        index (pd.Index): A multi-level index of datetime and instrument.
-        resample (Optional[str]): The resample frequency for the output data. Defaults to None.
-        period (int): The number of periods to calculate the percentage change over. Defaults to 1.
-        trade_at_price (str): The price for execution. Defaults to `close`.
-        **kwargs: Additional arguments to be passed to the resampler function.
-
-    Returns:
-        pd.Series: A pd.Series containing the percentage change of stock prices.
-
-    """
-
-    market = ml.get_market()
-    assert market is not None
-
-    adj_close = market.get_price('close', adj=True).shift(-1)
-    adj_open = market.get_price('open', adj=True).shift(-1)
-    uadj_close = resampler(adj_close, 'D', **kwargs)
-    uadj_open = resampler(adj_open, 'D', **kwargs)
-
-    ret = (uadj_close / uadj_open) - 1
-    return align_to_feature(index, ret)
-
-def return_percentage(index: pd.Index, resample=None, period=1, trade_at_price='close', **kwargs):
-
-    """Calculate the percentage change of market prices over a given period.
-
-    Args:
-        index (pd.Index): A multi-level index of datetime and instrument.
-        resample (Optional[str]): The resample frequency for the output data. Defaults to None.
-        period (int): The number of periods to calculate the percentage change over. Defaults to 1.
-        trade_at_price (str): The price for execution. Defaults to `close`.
-        **kwargs: Additional arguments to be passed to the resampler function.
-
-    Returns:
-        pd.Series: A pd.Series containing the percentage change of stock prices.
-
-    """
-
-    market = ml.get_market()
-    assert market is not None
-
-    adj = market.get_price(trade_at_price, adj=True).shift(-1)
-    uadj = resampler(adj, resample, **kwargs)
-    ret = (uadj.shift(-period) / uadj) - 1
-    return align_to_feature(index, ret)
-
-
-def maximum_adverse_excursion(index: pd.Index, period=1, trade_at_price='close'):
-
-    """Calculate the maximum adverse excursion of market prices over a given period.
-
-    Args:
-        index (pd.Index): A multi-level index of datetime and instrument.
-        resample (Optional[str]): The resample frequency for the output data. Defaults to None.
-        period (int): The number of periods to calculate the percentage change over. Defaults to 1.
-        trade_at_price (str): The price for execution. Defaults to `close`.
-        **kwargs: Additional arguments to be passed to the resampler function.
-
-    Returns:
-        pd.Series: A pd.Series containing the percentage change of stock prices.
-
-    """
-
-    market = ml.get_market()
-    assert market is not None
-    adj = market.get_price(trade_at_price, adj=True).shift(-1)
-    ret = adj.shift(-period).rolling(period).min() / adj - 1
-    ret = ret.reindex(index.levels[0], method='ffill')
-    return align_to_feature(index, ret)
-
-
-def maximum_favorable_excursion(index: pd.Index, period=1, trade_at_price='close'):
-
-    """Calculate the maximum favorable excursion of market prices over a given period.
-
-    Args:
-        index (pd.Index): A multi-level index of datetime and instrument.
-        resample (Optional[str]): The resample frequency for the output data. Defaults to None.
-        period (int): The number of periods to calculate the percentage change over. Defaults to 1.
-        trade_at_price (str): The price for execution. Defaults to `close`.
-        **kwargs: Additional arguments to be passed to the resampler function.
-
-    Returns:
-        pd.Series: A pd.Series containing the percentage change of stock prices.
-
-    """
-
-    market = ml.get_market()
-    assert market is not None
-    adj = market.get_price(trade_at_price, adj=True).shift(-1)
-    ret = adj.shift(-period).rolling(period).max() / adj - 1
-    ret = ret.reindex(index.levels[0], method='ffill')
-    return align_to_feature(index, ret)
-
-
-def excess_over_median(index: pd.Index, resample=None, period=1, trade_at_price='close', **kwargs):
-
-    """Calculate the excess over median of market prices over a given period.
-
-    Args:
-        index (pd.Index): A multi-level index of datetime and instrument.
-        resample (Optional[str]): The resample frequency for the output data. Defaults to None.
-        period (int): The number of periods to calculate the percentage change over. Defaults to 1.
-        trade_at_price (str): The price for execution. Defaults to `close`.
-        **kwargs: Additional arguments to be passed to the resampler function.
-
-    Returns:
-        pd.Series: A pd.Series containing the percentage change of stock prices.
-
-    """
-
-    market = ml.get_market()
-    adj = market.get_price(trade_at_price, adj=True).shift(-1)
-    uadj = resampler(adj, resample, **kwargs)
-    ret = (uadj.shift(-period) / uadj) - 1
-    ret -= ret.median(axis=1)
-    return align_to_feature(index, ret)
-
-
-def excess_over_mean(index: pd.Index, resample=None, period=1, trade_at_price='close', **kwargs):
-
-    """Calculate the excess over mean of market prices over a given period.
-
-    Args:
-        index (pd.Index): A multi-level index of datetime and instrument.
-        resample (Optional[str]): The resample frequency for the output data. Defaults to None.
-        period (int): The number of periods to calculate the percentage change over. Defaults to 1.
-        trade_at_price (str): The price for execution. Defaults to `close`.
-        **kwargs: Additional arguments to be passed to the resampler function.
-
-    Returns:
-        pd.Series: A pd.Series containing the percentage change of stock prices.
-
-    """
-    market = ml.get_market()
-    adj = market.get_price(trade_at_price, adj=True).shift(-1)
-    uadj = resampler(adj, resample, **kwargs)
-    ret = (uadj.shift(-period) / uadj) - 1
-    ret -= ret.mean(axis=1)
-    return align_to_feature(index, ret)
+import pandas as pd
+from finlab import ml
+from finlab.ml.utils import resampler
+
+
+def align_to_feature(index: pd.Index, df: pd.DataFrame):
+    ret = df.unstack().swaplevel(0, 1).reindex(index)
+    ret.index = ret.index.set_names(['datetime', 'instrument'])
+    return ret
+
+def daytrading_percentage(index: pd.Index, **kwargs):
+    """Calculate the percentage change of market prices over a given period.
+
+    Args:
+        index (pd.Index): A multi-level index of datetime and instrument.
+        resample (Optional[str]): The resample frequency for the output data. Defaults to None.
+        period (int): The number of periods to calculate the percentage change over. Defaults to 1.
+        trade_at_price (str): The price for execution. Defaults to `close`.
+        **kwargs: Additional arguments to be passed to the resampler function.
+
+    Returns:
+        pd.Series: A pd.Series containing the percentage change of stock prices.
+
+    """
+
+    market = ml.get_market()
+    assert market is not None
+
+    adj_close = market.get_price('close', adj=True).shift(-1)
+    adj_open = market.get_price('open', adj=True).shift(-1)
+    uadj_close = resampler(adj_close, 'D', **kwargs)
+    uadj_open = resampler(adj_open, 'D', **kwargs)
+
+    ret = (uadj_close / uadj_open) - 1
+    return align_to_feature(index, ret)
+
+def return_percentage(index: pd.Index, resample=None, period=1, trade_at_price='close', **kwargs):
+
+    """Calculate the percentage change of market prices over a given period.
+
+    Args:
+        index (pd.Index): A multi-level index of datetime and instrument.
+        resample (Optional[str]): The resample frequency for the output data. Defaults to None.
+        period (int): The number of periods to calculate the percentage change over. Defaults to 1.
+        trade_at_price (str): The price for execution. Defaults to `close`.
+        **kwargs: Additional arguments to be passed to the resampler function.
+
+    Returns:
+        pd.Series: A pd.Series containing the percentage change of stock prices.
+
+    """
+
+    market = ml.get_market()
+    assert market is not None
+
+    adj = market.get_price(trade_at_price, adj=True).shift(-1)
+    uadj = resampler(adj, resample, **kwargs)
+    ret = (uadj.shift(-period) / uadj) - 1
+    return align_to_feature(index, ret)
+
+
+def maximum_adverse_excursion(index: pd.Index, period=1, trade_at_price='close'):
+
+    """Calculate the maximum adverse excursion of market prices over a given period.
+
+    Args:
+        index (pd.Index): A multi-level index of datetime and instrument.
+        resample (Optional[str]): The resample frequency for the output data. Defaults to None.
+        period (int): The number of periods to calculate the percentage change over. Defaults to 1.
+        trade_at_price (str): The price for execution. Defaults to `close`.
+        **kwargs: Additional arguments to be passed to the resampler function.
+
+    Returns:
+        pd.Series: A pd.Series containing the percentage change of stock prices.
+
+    """
+
+    market = ml.get_market()
+    assert market is not None
+    adj = market.get_price(trade_at_price, adj=True).shift(-1)
+    ret = adj.shift(-period).rolling(period).min() / adj - 1
+    ret = ret.reindex(index.levels[0], method='ffill')
+    return align_to_feature(index, ret)
+
+
+def maximum_favorable_excursion(index: pd.Index, period=1, trade_at_price='close'):
+
+    """Calculate the maximum favorable excursion of market prices over a given period.
+
+    Args:
+        index (pd.Index): A multi-level index of datetime and instrument.
+        resample (Optional[str]): The resample frequency for the output data. Defaults to None.
+        period (int): The number of periods to calculate the percentage change over. Defaults to 1.
+        trade_at_price (str): The price for execution. Defaults to `close`.
+        **kwargs: Additional arguments to be passed to the resampler function.
+
+    Returns:
+        pd.Series: A pd.Series containing the percentage change of stock prices.
+
+    """
+
+    market = ml.get_market()
+    assert market is not None
+    adj = market.get_price(trade_at_price, adj=True).shift(-1)
+    ret = adj.shift(-period).rolling(period).max() / adj - 1
+    ret = ret.reindex(index.levels[0], method='ffill')
+    return align_to_feature(index, ret)
+
+
+def excess_over_median(index: pd.Index, resample=None, period=1, trade_at_price='close', **kwargs):
+
+    """Calculate the excess over median of market prices over a given period.
+
+    Args:
+        index (pd.Index): A multi-level index of datetime and instrument.
+        resample (Optional[str]): The resample frequency for the output data. Defaults to None.
+        period (int): The number of periods to calculate the percentage change over. Defaults to 1.
+        trade_at_price (str): The price for execution. Defaults to `close`.
+        **kwargs: Additional arguments to be passed to the resampler function.
+
+    Returns:
+        pd.Series: A pd.Series containing the percentage change of stock prices.
+
+    """
+
+    market = ml.get_market()
+    adj = market.get_price(trade_at_price, adj=True).shift(-1)
+    uadj = resampler(adj, resample, **kwargs)
+    ret = (uadj.shift(-period) / uadj) - 1
+    ret -= ret.median(axis=1)
+    return align_to_feature(index, ret)
+
+
+def excess_over_mean(index: pd.Index, resample=None, period=1, trade_at_price='close', **kwargs):
+
+    """Calculate the excess over mean of market prices over a given period.
+
+    Args:
+        index (pd.Index): A multi-level index of datetime and instrument.
+        resample (Optional[str]): The resample frequency for the output data. Defaults to None.
+        period (int): The number of periods to calculate the percentage change over. Defaults to 1.
+        trade_at_price (str): The price for execution. Defaults to `close`.
+        **kwargs: Additional arguments to be passed to the resampler function.
+
+    Returns:
+        pd.Series: A pd.Series containing the percentage change of stock prices.
+
+    """
+    market = ml.get_market()
+    adj = market.get_price(trade_at_price, adj=True).shift(-1)
+    uadj = resampler(adj, resample, **kwargs)
+    ret = (uadj.shift(-period) / uadj) - 1
+    ret -= ret.mean(axis=1)
+    return align_to_feature(index, ret)
```

## finlab/ml/qlib.py

```diff
@@ -1,773 +1,774 @@
-from finlab import ml
-from finlab.dataframe import FinlabDataFrame
-
-import os
-import abc
-import yaml
-import datetime
-import numpy as np
-import pandas as pd
-from tqdm import tqdm
-import logging as logger
-from pathlib import Path
-from typing import Iterable, List, Union
-from functools import partial
-from concurrent.futures import ProcessPoolExecutor
-
-
-import qlib
-from qlib.data import D
-from qlib.data.dataset import DatasetH
-from qlib.data.dataset.loader import DataLoader
-from qlib.data.dataset.handler import DataHandlerLP
-from qlib.contrib.data.handler import Alpha158, Alpha360
-from qlib.utils import fname_to_code, code_to_fname, init_instance_by_config
-
-
-class DumpDataBase:
-    """
-    Base class for dumping data to Qlib format.
-
-    Args:
-        csv_path (str): The path to the CSV file or directory containing the CSV files.
-        qlib_dir (str): The directory where the Qlib data will be saved.
-        backup_dir (str, optional): The directory where the backup of the Qlib data will be saved. Defaults to None.
-        freq (str, optional): The frequency of the data. Defaults to "day".
-        max_workers (int, optional): The maximum number of workers for parallel processing. Defaults to 16.
-        date_field_name (str, optional): The name of the date field in the CSV file. Defaults to "date".
-        file_suffix (str, optional): The suffix of the CSV file. Defaults to ".csv".
-        symbol_field_name (str, optional): The name of the symbol field in the CSV file. Defaults to "symbol".
-        exclude_fields (str, optional): The fields to exclude from the dumped data. Defaults to "".
-        include_fields (str, optional): The fields to include in the dumped data. Defaults to "".
-        limit_nums (int, optional): The maximum number of CSV files to process. Defaults to None.
-    """
-
-    INSTRUMENTS_START_FIELD = "start_datetime"
-    INSTRUMENTS_END_FIELD = "end_datetime"
-    CALENDARS_DIR_NAME = "calendars"
-    FEATURES_DIR_NAME = "features"
-    INSTRUMENTS_DIR_NAME = "instruments"
-    DUMP_FILE_SUFFIX = ".bin"
-    DAILY_FORMAT = "%Y-%m-%d"
-    HIGH_FREQ_FORMAT = "%Y-%m-%d %H:%M:%S"
-    INSTRUMENTS_SEP = "\t"
-    INSTRUMENTS_FILE_NAME = "all.txt"
-
-    UPDATE_MODE = "update"
-    ALL_MODE = "all"
-
-    def __init__(
-        self,
-        csv_path: str,
-        qlib_dir: str,
-        backup_dir: str = None,
-        freq: str = "day",
-        max_workers: int = 16,
-        date_field_name: str = "date",
-        file_suffix: str = ".csv",
-        symbol_field_name: str = "symbol",
-        exclude_fields: str = "",
-        include_fields: str = "",
-        limit_nums: int = None,
-    ):
-        csv_path = Path(csv_path).expanduser()
-        if isinstance(include_fields, str):
-            include_fields = include_fields.split(",")
-        self._include_fields = tuple(filter(lambda x: len(x) > 0, map(str.strip, include_fields)))
-        self.file_suffix = file_suffix
-        self.symbol_field_name = symbol_field_name
-        self.csv_files = sorted(csv_path.glob(f"*{self.file_suffix}") if csv_path.is_dir() else [csv_path])
-        if limit_nums is not None:
-            self.csv_files = self.csv_files[: int(limit_nums)]
-        self.qlib_dir = Path(qlib_dir).expanduser()
-        self.backup_dir = backup_dir if backup_dir is None else Path(backup_dir).expanduser()
-
-        self.freq = freq
-        self.calendar_format = self.DAILY_FORMAT if self.freq == "day" else self.HIGH_FREQ_FORMAT
-
-        self.works = max_workers
-        self.date_field_name = date_field_name
-
-        self._calendars_dir = self.qlib_dir.joinpath(self.CALENDARS_DIR_NAME)
-        self._features_dir = self.qlib_dir.joinpath(self.FEATURES_DIR_NAME)
-        self._instruments_dir = self.qlib_dir.joinpath(self.INSTRUMENTS_DIR_NAME)
-
-        self._calendars_list = []
-
-        self._mode = self.ALL_MODE
-        self._kwargs = {}
-
-    def _format_datetime(self, datetime_d):
-        datetime_d = pd.Timestamp(datetime_d)
-        return datetime_d.strftime(self.calendar_format)
-
-    def _get_date(
-        self, file_or_df, *, is_begin_end: bool = False, as_set: bool = False
-    ) -> Iterable[pd.Timestamp]:
-        if not isinstance(file_or_df, pd.DataFrame):
-            df = self._get_source_data(file_or_df)
-        else:
-            df = file_or_df
-        if df.empty or self.date_field_name not in df.columns.tolist():
-            _calendars = pd.Series(dtype=np.float32)
-        else:
-            _calendars = df[self.date_field_name]
-
-        if is_begin_end and as_set:
-            return (_calendars.min(), _calendars.max()), set(_calendars)
-        elif is_begin_end:
-            return _calendars.min(), _calendars.max()
-        elif as_set:
-            return set(_calendars)
-        else:
-            return _calendars.tolist()
-
-    def _get_source_data(self, file_path: Path) -> pd.DataFrame:
-        df = pd.read_csv(str(file_path.resolve()), low_memory=False)
-        df[self.date_field_name] = df[self.date_field_name].astype(str).astype(np.datetime64)
-        # df.drop_duplicates([self.date_field_name], inplace=True)
-        return df
-
-    def get_symbol_from_file(self, file_path: Path) -> str:
-        return fname_to_code(file_path.name[: -len(self.file_suffix)].strip().lower())
-
-    def get_dump_fields(self, df_columns: Iterable[str]) -> Iterable[str]:
-        return (self._include_fields)
-
-    @staticmethod
-    def _read_calendars(calendar_path: Path) -> List[pd.Timestamp]:
-        return sorted(
-            map(
-                pd.Timestamp,
-                pd.read_csv(calendar_path, header=None).loc[:, 0].tolist(),
-            )
-        )
-
-    def _read_instruments(self, instrument_path: Path) -> pd.DataFrame:
-        df = pd.read_csv(
-            instrument_path,
-            sep=self.INSTRUMENTS_SEP,
-            names=[
-                self.symbol_field_name,
-                self.INSTRUMENTS_START_FIELD,
-                self.INSTRUMENTS_END_FIELD,
-            ],
-        )
-
-        return df
-
-    def save_calendars(self, calendars_data: list):
-        self._calendars_dir.mkdir(parents=True, exist_ok=True)
-        calendars_path = str(self._calendars_dir.joinpath(f"{self.freq}.txt").expanduser().resolve())
-        result_calendars_list = list(map(lambda x: self._format_datetime(x), calendars_data))
-        np.savetxt(calendars_path, result_calendars_list, fmt="%s", encoding="utf-8")
-
-    def save_instruments(self, instruments_data: Union[list, pd.DataFrame]):
-        self._instruments_dir.mkdir(parents=True, exist_ok=True)
-        instruments_path = str(self._instruments_dir.joinpath(self.INSTRUMENTS_FILE_NAME).resolve())
-        if isinstance(instruments_data, pd.DataFrame):
-            _df_fields = [self.symbol_field_name, self.INSTRUMENTS_START_FIELD, self.INSTRUMENTS_END_FIELD]
-            instruments_data = instruments_data.loc[:, _df_fields]
-            instruments_data[self.symbol_field_name] = instruments_data[self.symbol_field_name].apply(
-                lambda x: fname_to_code(x.lower()).upper()
-            )
-            instruments_data.to_csv(instruments_path, header=False, sep=self.INSTRUMENTS_SEP, index=False)
-        else:
-            np.savetxt(instruments_path, instruments_data, fmt="%s", encoding="utf-8")
-
-    def data_merge_calendar(self, df: pd.DataFrame, calendars_list: List[pd.Timestamp]) -> pd.DataFrame:
-        # calendars
-        calendars_df = pd.DataFrame(data=calendars_list, columns=[self.date_field_name])
-        calendars_df[self.date_field_name] = calendars_df[self.date_field_name].astype('datetime64[ns]')
-        cal_df = calendars_df[
-            (calendars_df[self.date_field_name] >= df[self.date_field_name].min())
-            & (calendars_df[self.date_field_name] <= df[self.date_field_name].max())
-        ]
-        # align index
-        cal_df.set_index(self.date_field_name, inplace=True)
-        df.set_index(self.date_field_name, inplace=True)
-        r_df = df.reindex(cal_df.index)
-        return r_df
-
-    @staticmethod
-    def get_datetime_index(df: pd.DataFrame, calendar_list: List[pd.Timestamp]) -> int:
-        return calendar_list.index(df.index.min())
-
-    def _data_to_bin(self, df: pd.DataFrame, calendar_list: List[pd.Timestamp], features_dir: Path):
-        if df.empty:
-            logger.warning(f"{features_dir.name} data is None or empty")
-            return
-        if not calendar_list:
-            logger.warning("calendar_list is empty")
-            return
-        # align index
-        _df = self.data_merge_calendar(df, calendar_list)
-        if _df.empty:
-            logger.warning(f"{features_dir.name} data is not in calendars")
-            return
-        # used when creating a bin file
-        date_index = self.get_datetime_index(_df, calendar_list)
-        for field in self.get_dump_fields(_df.columns):
-            bin_path = features_dir.joinpath(f"{field.lower()}.{self.freq}{self.DUMP_FILE_SUFFIX}")
-            if field not in _df.columns:
-                continue
-            if bin_path.exists() and self._mode == self.UPDATE_MODE:
-                # update
-                with bin_path.open("ab") as fp:
-                    np.array(_df[field]).astype("<f").tofile(fp)
-            else:
-                # append; self._mode == self.ALL_MODE or not bin_path.exists()
-                np.hstack([date_index, _df[field]]).astype("<f").tofile(str(bin_path.resolve()))
-
-    def _dump_bin(self, file_or_data, calendar_list: List[pd.Timestamp]):
-        if not calendar_list:
-            logger.warning("calendar_list is empty")
-            return
-        if isinstance(file_or_data, pd.DataFrame):
-            if file_or_data.empty:
-                return
-            code = fname_to_code(str(file_or_data.iloc[0][self.symbol_field_name]).lower())
-            df = file_or_data
-        elif isinstance(file_or_data, Path):
-            code = self.get_symbol_from_file(file_or_data)
-            df = self._get_source_data(file_or_data)
-        else:
-            raise ValueError(f"not support {type(file_or_data)}")
-        if df is None or df.empty:
-            logger.warning(f"{code} data is None or empty")
-            return
-
-        # try to remove dup rows or it will cause exception when reindex.
-        df = df.drop_duplicates(self.date_field_name)
-
-        # features save dir
-        features_dir = self._features_dir.joinpath(code_to_fname(code).lower())
-        features_dir.mkdir(parents=True, exist_ok=True)
-        self._data_to_bin(df, calendar_list, features_dir)
-
-    @abc.abstractmethod
-    def dump(self):
-        raise NotImplementedError("dump not implemented!")
-
-    def __call__(self, *args, **kwargs):
-        self.dump()
-
-class DumpDataAll(DumpDataBase):
-    def _get_all_date(self):
-        logger.info("start get all date......")
-        all_datetime = set()
-        date_range_list = []
-        _fun = partial(self._get_date, as_set=True, is_begin_end=True)
-        with tqdm(total=len(self.csv_files)) as p_bar:
-            with ProcessPoolExecutor(max_workers=self.works) as executor:
-                for file_path, ((_begin_time, _end_time), _set_calendars) in zip(
-                    self.csv_files, executor.map(_fun, self.csv_files)
-                ):
-                    all_datetime = all_datetime | _set_calendars
-                    if isinstance(_begin_time, pd.Timestamp) and isinstance(_end_time, pd.Timestamp):
-                        _begin_time = self._format_datetime(_begin_time)
-                        _end_time = self._format_datetime(_end_time)
-                        symbol = self.get_symbol_from_file(file_path)
-                        _inst_fields = [symbol.upper(), _begin_time, _end_time]
-                        date_range_list.append(f"{self.INSTRUMENTS_SEP.join(_inst_fields)}")
-                    p_bar.update()
-        self._kwargs["all_datetime_set"] = all_datetime
-        self._kwargs["date_range_list"] = date_range_list
-        logger.info("end of get all date.\n")
-
-    def _dump_calendars(self):
-        logger.info("start dump calendars......")
-        self._calendars_list = sorted(map(pd.Timestamp, self._kwargs["all_datetime_set"]))
-        self.save_calendars(self._calendars_list)
-        logger.info("end of calendars dump.\n")
-
-    def _dump_instruments(self):
-        logger.info("start dump instruments......")
-        self.save_instruments(self._kwargs["date_range_list"])
-        logger.info("end of instruments dump.\n")
-
-    def _dump_features(self):
-        logger.info("start dump features......")
-        _dump_func = partial(self._dump_bin, calendar_list=self._calendars_list)
-        with tqdm(total=len(self.csv_files)) as p_bar:
-            with ProcessPoolExecutor(max_workers=self.works) as executor:
-                for _ in executor.map(_dump_func, self.csv_files):
-                    p_bar.update()
-
-        logger.info("end of features dump.\n")
-
-    def dump(self):
-        self._get_all_date()
-        self._dump_calendars()
-        self._dump_instruments()
-        self._dump_features()
-
-def get_region(market):
-    return ml.get_market().__class__.__name__.replace('MarketInfo', '').lower()
-
-def dump(freq='day'):
-    """產生Qlib 於台股的資料庫
-    Examples:
-        ```py
-        import qlib
-        import finlab.ml.qlib as q
-
-        q.dump() # generate tw stock database
-        q.init() # initiate tw stock to perform machine leraning tasks (similar to qlib.init)
-
-        import qlib
-        # qlib functions and operations
-        ```
-    """
-    
-    market = ml.get_market()
-    region = get_region(market)
-
-    csv_path = f'~/.qlib/csv_data/{region}_data'
-    qlib_dir = f'~/.qlib/qlib_data/{region}_data'
-    include_fields = "open,close,high,low,volume,factor"
-
-    if not Path(csv_path).expanduser().exists():
-        Path(csv_path).expanduser().mkdir(parents=True)
-    if not Path(qlib_dir).expanduser().exists():
-        Path(qlib_dir).expanduser().mkdir(parents=True)
-
-    c = market.get_price('close', adj=False)
-    ac = market.get_price('close', adj=True)
-    o = market.get_price('open', adj=False)
-    h = market.get_price('high', adj=False)
-    l = market.get_price('low', adj=False)
-    v = market.get_price('volume', adj=False)
-
-    assert c is not None
-    assert ac is not None
-    assert o is not None
-    assert h is not None
-    assert l is not None
-    assert v is not None
-
-    for s in c.columns:
-        pd.DataFrame({
-            'date':c.index.values,
-            'volume': v[s].values,
-            'high': h[s].values,
-            'low': l[s].values,
-            'close': c[s].values,
-            'open': o[s].values,
-            'factor': ac[s].values / c[s].values,
-            'symbol': s
-            }).to_csv(Path(csv_path).expanduser() / f"{s}.csv")
-
-    dumper = DumpDataAll(csv_path, qlib_dir, include_fields=include_fields, freq=freq)
-    dumper()
-
-
-qlib_initialized = False
-
-def init():
-    """Qlib 初始化 (類似於台股版 qlib.init() 但更簡單易用)
-    Examples:
-        ```py
-        import qlib
-        import finlab.ml.qlib as q
-
-        q.dump() # generate tw stock database
-        q.init() # initiate tw stock to perform machine leraning tasks (similar to qlib.init)
-
-        import qlib
-        # qlib functions and operations
-        ```
-    """
-    region = get_region(ml.get_market())
-    try:
-        from qlib import config
-        config._default_region_config[region] = \
-                dict(trade_unit=1000, limit_threshold=0.1, deal_price='close')
-    except:
-        pass
-
-    global qlib_initialized
-
-    if not qlib_initialized:
-        qlib.init(provider_uri=f'~/.qlib/qlib_data/{region}_data', 
-                  region=region)
-        qlib_initialized = True
-
-def alpha(handler='Alpha158', **kwargs):
-
-    """產生 Qlib 的特徵
-    Args:
-        handler (str): 預設為 'alpha158' 也可以設定成 'Alpha360'
-    Examples:
-        ```py
-        import finlab.ml.qlib as q
-        features = q.alpha('Alpha158')
-        ```
-    """
-    init()
-
-    if handler == 'Alpha158':
-        h = Alpha158(instruments=D.instruments(market='all'), **kwargs)
-    elif handler == 'Alpha360':
-        h = Alpha360(instruments=D.instruments(market='all'), **kwargs)
-    else:
-        raise Exception(f"Handler {handler} not supported.")
-
-    alpha = h.fetch(col_set="feature")
-    return alpha
-
-
-
-class CustomDataLoader(DataLoader):
-    def __init__(self, d):
-
-        from finlab.utils import get_tmp_dir
-        tmp_dir = get_tmp_dir()
-        self.data_path = os.path.join(tmp_dir, 'dataset.pickle')
-        d.to_pickle(self.data_path)
-        del d
-        
-    def load(self, instruments, start_time=None, end_time=None) -> pd.DataFrame:
-        d = pd.read_pickle(self.data_path)
-        t = d.index.get_level_values('datetime')
-
-        selected = t.notna()
-        if start_time:
-            selected &= t > start_time
-        if end_time:
-            selected &= t < end_time
-        if instruments:
-            ins = d.index.get_level_values('instrument')
-            selected &= ins.isin(instruments) 
-
-        return d.loc[selected]
-
-
-def make_datasetH(X, y=None, _DEFAULT_LEARN_PROCESSORS=[
-        {"class": "DropnaLabel"},
-        {"class": "CSZScoreNorm", "kwargs": {"fields_group": "label"}},
-    ], train_test_split=(0.7, 0.15, 0.15), segments=None):
-
-    is_train = y is not None
-
-    if is_train:
-
-        if segments is None:
-            tmin = X.index.get_level_values('datetime').min()
-            tmax = X.index.get_level_values('datetime').max()
-            tsplit1 = (tmax - tmin) * train_test_split[0] + tmin
-            tsplit2 = (tmax - tmin) * (train_test_split[0] + train_test_split[1]) + tmin
-            segments = dict(
-                train=(tmin, tsplit1),
-                valid=(tsplit1 + datetime.timedelta(days=1), tsplit2),
-                test=(tsplit2 + datetime.timedelta(days=1), tmax)
-            )
-
-        d = pd.concat([
-            X, 
-            y.to_frame(name='LABEL0')],
-            axis=1, 
-            keys=['feature', 'label']
-            ).sort_index()
-
-        dl = CustomDataLoader(d)
-        return DatasetH(handler=DataHandlerLP(data_loader=dl, learn_processors=_DEFAULT_LEARN_PROCESSORS), segments=segments)
-
-    x = X.copy()
-    x.columns = pd.MultiIndex.from_tuples([('feature', x) for x in x.columns])
-
-    dl = CustomDataLoader(x)
-
-    tmin = x.index.get_level_values('datetime').min()
-    tmax = x.index.get_level_values('datetime').max()
-
-    segments = {
-        'test': (tmin, tmax)
-    }
-    
-    return DatasetH(handler=DataHandlerLP(data_loader=dl), segments=segments)
-    
-
-class WrapperModel():
-
-    def __init__(self, model_config):
-        init()
-        self.config = model_config
-        self.model = None
-        
-    def fit(self, X_train, y_train, segments=None, **fit_params):
-
-        config = self.config
-
-        if 'kwargs' in config and 'd_feat' in config['kwargs']:
-            config['kwargs']['d_feat'] = X_train.shape[1]
-
-        if 'kwargs' in config and 'pt_model_kwargs' in config['kwargs'] and 'input_dim' in config['kwargs']['pt_model_kwargs']:
-            config['kwargs']['pt_model_kwargs']['input_dim'] = X_train.shape[1]
-
-        self.model = init_instance_by_config(self.config)
-        dh = make_datasetH(X_train, y_train, segments=segments)
-        self.model.fit(dh, **fit_params)
-
-    def predict(self, X_test):
-        
-        dh = make_datasetH(X_test, None)
-        return FinlabDataFrame(pd.Series(self.model.predict(dh), index=X_test.index)
-            .reset_index()
-            .pivot(index='datetime', columns='instrument', values=0))
-
-
-def LGBModel():
-    """LGBModel is a wrapper model for LightGBM model.
-    ```py
-    import finlab.ml.qlib as q
-
-    # build X_train, y_train, X_test
-
-    model = q.LGBModel()
-    model.fit(X_train, y_train)
-    y_pred = model.predict(X_test)
-    ```
-    """
-    return  WrapperModel(yaml.safe_load("""
-    class: LGBModel
-    module_path: qlib.contrib.model.gbdt
-    kwargs:
-        loss: mse
-        colsample_bytree: 0.8879
-        learning_rate: 0.2
-        subsample: 0.8789
-        lambda_l1: 205.6999
-        lambda_l2: 580.9768
-        max_depth: 8
-        num_leaves: 210
-        num_threads: 20
-    """))
-
-def XGBModel():
-    """
-    XGBModel is a wrapper model for XGBoost model.
-    ```py
-    import finlab.ml.qlib as q
-
-    # build X_train, y_train, X_test
-
-    model = q.XGBModel()
-    model.fit(X_train, y_train)
-    y_pred = model.predict(X_test)
-    ```
-    """
-    return WrapperModel(yaml.safe_load("""
-class: XGBModel
-module_path: qlib.contrib.model.xgboost
-kwargs:
-    eval_metric: rmse
-    colsample_bytree: 0.8879
-    eta: 0.0421
-    max_depth: 8
-    n_estimators: 647
-    subsample: 0.8789
-    nthread: 20
-"""))
-
-def DEnsmbleModel():
-    """
-    DEnsmbleModel is a wrapper model for Double Ensemble model.
-    ```py
-    import finlab.ml.qlib as q
-
-    # build X_train, y_train, X_test
-
-    model = q.DEnsmbleModel()
-    model.fit(X_train, y_train)
-    y_pred = model.predict(X_test)
-    ```
-    """
-    return WrapperModel(yaml.safe_load("""
-class: DEnsembleModel
-module_path: qlib.contrib.model.double_ensemble
-kwargs:
-    base_model: "gbm"
-    loss: mse
-    num_models: 3
-    enable_sr: True
-    enable_fs: True
-    alpha1: 1
-    alpha2: 1
-    bins_sr: 10
-    bins_fs: 5
-    decay: 0.5
-    sample_ratios:
-        - 0.8
-        - 0.7
-        - 0.6
-        - 0.5
-        - 0.4
-    sub_weights:
-        - 1
-        - 1
-        - 1
-    epochs: 28
-    colsample_bytree: 0.8879
-    learning_rate: 0.0421
-    subsample: 0.8789
-    lambda_l1: 205.6999
-    lambda_l2: 580.9768
-    max_depth: 8
-    num_leaves: 210
-    num_threads: 20
-    verbosity: -1
-"""))
-
-def CatBoostModel():
-    """
-    CatBoostModel is a wrapper model for CatBoost model.
-    ```py
-    import finlab.ml.qlib as q
-
-    # build X_train, y_train, X_test
-
-    model = q.CatBoostModel()
-    model.fit(X_train, y_train)
-    y_pred = model.predict(X_test)
-    ```
-    """
-    return WrapperModel(yaml.safe_load("""
-class: CatBoostModel
-module_path: qlib.contrib.model.catboost_model
-kwargs:
-    loss: RMSE
-    learning_rate: 0.0421
-    subsample: 0.8789
-    max_depth: 6
-    num_leaves: 100
-    thread_count: 20
-    grow_policy: Lossguide
-"""))
-
-def LinearModel():
-    """
-    LinearModel is a wrapper model for Linear model.
-    ```py
-    import finlab.ml.qlib as q
-
-    # build X_train, y_train, X_test
-
-    model = q.LinearModel()
-    model.fit(X_train, y_train)
-    y_pred = model.predict(X_test)
-    ```
-    """
-    return WrapperModel(yaml.safe_load("""
-class: LinearModel
-module_path: qlib.contrib.model.linear
-kwargs:
-    estimator: ols
-"""))
-
-def TabnetModel():
-    """
-    TabnetModel is a wrapper model for Tabnet model.
-    ```py
-    import finlab.ml.qlib as q
-
-    # build X_train, y_train, X_test
-
-    model = q.TabnetModel()
-    model.fit(X_train, y_train)
-    y_pred = model.predict(X_test)
-    ```
-    """
-    return WrapperModel(yaml.safe_load("""
-class: TabnetModel
-module_path: qlib.contrib.model.pytorch_tabnet
-kwargs:
-    d_feat: 8
-    pretrain: False
-    seed: 993
-"""))
-
-def DNNModel():
-    """
-    DNNModel is a wrapper model for Deep Neural Network model.
-    ```py
-    import finlab.ml.qlib as q
-
-    # build X_train, y_train, X_test
-
-    model = q.DNNModel()
-    model.fit(X_train, y_train)
-    y_pred = model.predict(X_test)
-    ```
-    """
-    return WrapperModel(yaml.safe_load("""
-class: DNNModelPytorch
-module_path: qlib.contrib.model.pytorch_nn
-kwargs:
-    loss: mse
-    lr: 0.002
-    optimizer: adam
-    max_steps: 8000
-    batch_size: 8192
-    GPU: 0
-    weight_decay: 0.0002
-    pt_model_kwargs:
-      input_dim: 8
-"""))
-
-def SFMModel():
-    """
-    SFMModel is a wrapper model for SFM.
-    ```py
-    import finlab.ml.qlib as q
-
-    # build X_train, y_train, X_test
-
-    model = q.SFMModel()
-    model.fit(X_train, y_train)
-    y_pred = model.predict(X_test)
-    ```
-    """
-    return WrapperModel(yaml.safe_load("""
-class: SFM
-module_path: qlib.contrib.model.pytorch_sfm
-kwargs:
-    d_feat: 6
-    hidden_size: 64
-    output_dim: 32
-    freq_dim: 25
-    dropout_W: 0.5
-    dropout_U: 0.5
-    n_epochs: 20
-    lr: 0.001
-    batch_size: 1600
-    early_stop: 20
-    eval_steps: 5
-    loss: mse
-    optimizer: adam
-    GPU: 0
-"""))
-
-def get_models():
-    """Return a list of available models.
-    Examples:
-        ```py
-        import finlab.ml.qlib as q
-
-        models = q.get_models()
-        print(models)
-        ```
-        output:
-
-        { 'LGBModel': LGBModel, 'XGBModel': XGBModel, 'DEnsmbleModel': DEnsmbleModel, 'CatBoostModel': CatBoostModel, 'LinearModel': LinearModel, 'TabnetModel': TabnetModel, 'DNNModel': DNNModel, 'SFMModel': SFMModel}
-
-    """
-    return {
-        'LGBModel': LGBModel,
-        'XGBModel': XGBModel,
-        'DEnsmbleModel': DEnsmbleModel,
-        'CatBoostModel': CatBoostModel,
-        'LinearModel': LinearModel,
-        'TabnetModel': TabnetModel,
-        'DNNModel': DNNModel,
+from finlab import ml
+from finlab.dataframe import FinlabDataFrame
+
+import os
+import abc
+import yaml
+import datetime
+import numpy as np
+import pandas as pd
+from tqdm import tqdm
+import logging as logger
+from pathlib import Path
+from typing import Iterable, List, Union
+from functools import partial
+from concurrent.futures import ProcessPoolExecutor
+
+
+import qlib
+from qlib.data import D
+from qlib.data.dataset import DatasetH
+from qlib.data.dataset.loader import DataLoader
+from qlib.data.dataset.handler import DataHandlerLP
+from qlib.contrib.data.handler import Alpha158, Alpha360
+from qlib.utils import fname_to_code, code_to_fname, init_instance_by_config
+
+
+class DumpDataBase:
+    """
+    Base class for dumping data to Qlib format.
+
+    Args:
+        csv_path (str): The path to the CSV file or directory containing the CSV files.
+        qlib_dir (str): The directory where the Qlib data will be saved.
+        backup_dir (str, optional): The directory where the backup of the Qlib data will be saved. Defaults to None.
+        freq (str, optional): The frequency of the data. Defaults to "day".
+        max_workers (int, optional): The maximum number of workers for parallel processing. Defaults to 16.
+        date_field_name (str, optional): The name of the date field in the CSV file. Defaults to "date".
+        file_suffix (str, optional): The suffix of the CSV file. Defaults to ".csv".
+        symbol_field_name (str, optional): The name of the symbol field in the CSV file. Defaults to "symbol".
+        exclude_fields (str, optional): The fields to exclude from the dumped data. Defaults to "".
+        include_fields (str, optional): The fields to include in the dumped data. Defaults to "".
+        limit_nums (int, optional): The maximum number of CSV files to process. Defaults to None.
+    """
+
+    INSTRUMENTS_START_FIELD = "start_datetime"
+    INSTRUMENTS_END_FIELD = "end_datetime"
+    CALENDARS_DIR_NAME = "calendars"
+    FEATURES_DIR_NAME = "features"
+    INSTRUMENTS_DIR_NAME = "instruments"
+    DUMP_FILE_SUFFIX = ".bin"
+    DAILY_FORMAT = "%Y-%m-%d"
+    HIGH_FREQ_FORMAT = "%Y-%m-%d %H:%M:%S"
+    INSTRUMENTS_SEP = "\t"
+    INSTRUMENTS_FILE_NAME = "all.txt"
+
+    UPDATE_MODE = "update"
+    ALL_MODE = "all"
+
+    def __init__(
+        self,
+        csv_path: str,
+        qlib_dir: str,
+        backup_dir: str = None,
+        freq: str = "day",
+        max_workers: int = 16,
+        date_field_name: str = "date",
+        file_suffix: str = ".csv",
+        symbol_field_name: str = "symbol",
+        exclude_fields: str = "",
+        include_fields: str = "",
+        limit_nums: int = None,
+    ):
+        csv_path = Path(csv_path).expanduser()
+        if isinstance(include_fields, str):
+            include_fields = include_fields.split(",")
+        self._include_fields = tuple(filter(lambda x: len(x) > 0, map(str.strip, include_fields)))
+        self.file_suffix = file_suffix
+        self.symbol_field_name = symbol_field_name
+        self.csv_files = sorted(csv_path.glob(f"*{self.file_suffix}") if csv_path.is_dir() else [csv_path])
+        if limit_nums is not None:
+            self.csv_files = self.csv_files[: int(limit_nums)]
+        self.qlib_dir = Path(qlib_dir).expanduser()
+        self.backup_dir = backup_dir if backup_dir is None else Path(backup_dir).expanduser()
+
+        self.freq = freq
+        self.calendar_format = self.DAILY_FORMAT if self.freq == "day" else self.HIGH_FREQ_FORMAT
+
+        self.works = max_workers
+        self.date_field_name = date_field_name
+
+        self._calendars_dir = self.qlib_dir.joinpath(self.CALENDARS_DIR_NAME)
+        self._features_dir = self.qlib_dir.joinpath(self.FEATURES_DIR_NAME)
+        self._instruments_dir = self.qlib_dir.joinpath(self.INSTRUMENTS_DIR_NAME)
+
+        self._calendars_list = []
+
+        self._mode = self.ALL_MODE
+        self._kwargs = {}
+
+    def _format_datetime(self, datetime_d):
+        datetime_d = pd.Timestamp(datetime_d)
+        return datetime_d.strftime(self.calendar_format)
+
+    def _get_date(
+        self, file_or_df, *, is_begin_end: bool = False, as_set: bool = False
+    ) -> Iterable[pd.Timestamp]:
+        if not isinstance(file_or_df, pd.DataFrame):
+            df = self._get_source_data(file_or_df)
+        else:
+            df = file_or_df
+        if df.empty or self.date_field_name not in df.columns.tolist():
+            _calendars = pd.Series(dtype=np.float32)
+        else:
+            _calendars = df[self.date_field_name]
+
+        if is_begin_end and as_set:
+            return (_calendars.min(), _calendars.max()), set(_calendars)
+        elif is_begin_end:
+            return _calendars.min(), _calendars.max()
+        elif as_set:
+            return set(_calendars)
+        else:
+            return _calendars.tolist()
+
+    def _get_source_data(self, file_path: Path) -> pd.DataFrame:
+        df = pd.read_csv(str(file_path.resolve()), low_memory=False)
+        df[self.date_field_name] = df[self.date_field_name].astype(str).astype(np.datetime64)
+        # df.drop_duplicates([self.date_field_name], inplace=True)
+        return df
+
+    def get_symbol_from_file(self, file_path: Path) -> str:
+        return fname_to_code(file_path.name[: -len(self.file_suffix)].strip().lower())
+
+    def get_dump_fields(self, df_columns: Iterable[str]) -> Iterable[str]:
+        return (self._include_fields)
+
+    @staticmethod
+    def _read_calendars(calendar_path: Path) -> List[pd.Timestamp]:
+        return sorted(
+            map(
+                pd.Timestamp,
+                pd.read_csv(calendar_path, header=None).loc[:, 0].tolist(),
+            )
+        )
+
+    def _read_instruments(self, instrument_path: Path) -> pd.DataFrame:
+        df = pd.read_csv(
+            instrument_path,
+            sep=self.INSTRUMENTS_SEP,
+            names=[
+                self.symbol_field_name,
+                self.INSTRUMENTS_START_FIELD,
+                self.INSTRUMENTS_END_FIELD,
+            ],
+        )
+
+        return df
+
+    def save_calendars(self, calendars_data: list):
+        self._calendars_dir.mkdir(parents=True, exist_ok=True)
+        calendars_path = str(self._calendars_dir.joinpath(f"{self.freq}.txt").expanduser().resolve())
+        result_calendars_list = list(map(lambda x: self._format_datetime(x), calendars_data))
+        np.savetxt(calendars_path, result_calendars_list, fmt="%s", encoding="utf-8")
+
+    def save_instruments(self, instruments_data: Union[list, pd.DataFrame]):
+        self._instruments_dir.mkdir(parents=True, exist_ok=True)
+        instruments_path = str(self._instruments_dir.joinpath(self.INSTRUMENTS_FILE_NAME).resolve())
+        if isinstance(instruments_data, pd.DataFrame):
+            _df_fields = [self.symbol_field_name, self.INSTRUMENTS_START_FIELD, self.INSTRUMENTS_END_FIELD]
+            instruments_data = instruments_data.loc[:, _df_fields]
+            instruments_data[self.symbol_field_name] = instruments_data[self.symbol_field_name].apply(
+                lambda x: fname_to_code(x.lower()).upper()
+            )
+            instruments_data.to_csv(instruments_path, header=False, sep=self.INSTRUMENTS_SEP, index=False)
+        else:
+            np.savetxt(instruments_path, instruments_data, fmt="%s", encoding="utf-8")
+
+    def data_merge_calendar(self, df: pd.DataFrame, calendars_list: List[pd.Timestamp]) -> pd.DataFrame:
+        # calendars
+        calendars_df = pd.DataFrame(data=calendars_list, columns=[self.date_field_name])
+        calendars_df[self.date_field_name] = calendars_df[self.date_field_name].astype('datetime64[ns]')
+        cal_df = calendars_df[
+            (calendars_df[self.date_field_name] >= df[self.date_field_name].min())
+            & (calendars_df[self.date_field_name] <= df[self.date_field_name].max())
+        ]
+        # align index
+        cal_df.set_index(self.date_field_name, inplace=True)
+        df.set_index(self.date_field_name, inplace=True)
+        r_df = df.reindex(cal_df.index)
+        return r_df
+
+    @staticmethod
+    def get_datetime_index(df: pd.DataFrame, calendar_list: List[pd.Timestamp]) -> int:
+        return calendar_list.index(df.index.min())
+
+    def _data_to_bin(self, df: pd.DataFrame, calendar_list: List[pd.Timestamp], features_dir: Path):
+        if df.empty:
+            logger.warning(f"{features_dir.name} data is None or empty")
+            return
+        if not calendar_list:
+            logger.warning("calendar_list is empty")
+            return
+        # align index
+        _df = self.data_merge_calendar(df, calendar_list)
+        if _df.empty:
+            logger.warning(f"{features_dir.name} data is not in calendars")
+            return
+        # used when creating a bin file
+        date_index = self.get_datetime_index(_df, calendar_list)
+        for field in self.get_dump_fields(_df.columns):
+            bin_path = features_dir.joinpath(f"{field.lower()}.{self.freq}{self.DUMP_FILE_SUFFIX}")
+            if field not in _df.columns:
+                continue
+            if bin_path.exists() and self._mode == self.UPDATE_MODE:
+                # update
+                with bin_path.open("ab") as fp:
+                    np.array(_df[field]).astype("<f").tofile(fp)
+            else:
+                # append; self._mode == self.ALL_MODE or not bin_path.exists()
+                np.hstack([date_index, _df[field]]).astype("<f").tofile(str(bin_path.resolve()))
+
+    def _dump_bin(self, file_or_data, calendar_list: List[pd.Timestamp]):
+        if not calendar_list:
+            logger.warning("calendar_list is empty")
+            return
+        if isinstance(file_or_data, pd.DataFrame):
+            if file_or_data.empty:
+                return
+            code = fname_to_code(str(file_or_data.iloc[0][self.symbol_field_name]).lower())
+            df = file_or_data
+        elif isinstance(file_or_data, Path):
+            code = self.get_symbol_from_file(file_or_data)
+            df = self._get_source_data(file_or_data)
+        else:
+            raise ValueError(f"not support {type(file_or_data)}")
+        if df is None or df.empty:
+            logger.warning(f"{code} data is None or empty")
+            return
+
+        # try to remove dup rows or it will cause exception when reindex.
+        df = df.drop_duplicates(self.date_field_name)
+
+        # features save dir
+        features_dir = self._features_dir.joinpath(code_to_fname(code).lower())
+        features_dir.mkdir(parents=True, exist_ok=True)
+        self._data_to_bin(df, calendar_list, features_dir)
+
+    @abc.abstractmethod
+    def dump(self):
+        raise NotImplementedError("dump not implemented!")
+
+    def __call__(self, *args, **kwargs):
+        self.dump()
+
+class DumpDataAll(DumpDataBase):
+    def _get_all_date(self):
+        logger.info("start get all date......")
+        all_datetime = set()
+        date_range_list = []
+        _fun = partial(self._get_date, as_set=True, is_begin_end=True)
+        with tqdm(total=len(self.csv_files)) as p_bar:
+            with ProcessPoolExecutor(max_workers=self.works) as executor:
+                for file_path, ((_begin_time, _end_time), _set_calendars) in zip(
+                    self.csv_files, executor.map(_fun, self.csv_files)
+                ):
+                    all_datetime = all_datetime | _set_calendars
+                    if isinstance(_begin_time, pd.Timestamp) and isinstance(_end_time, pd.Timestamp):
+                        _begin_time = self._format_datetime(_begin_time)
+                        _end_time = self._format_datetime(_end_time)
+                        symbol = self.get_symbol_from_file(file_path)
+                        _inst_fields = [symbol.upper(), _begin_time, _end_time]
+                        date_range_list.append(f"{self.INSTRUMENTS_SEP.join(_inst_fields)}")
+                    p_bar.update()
+        self._kwargs["all_datetime_set"] = all_datetime
+        self._kwargs["date_range_list"] = date_range_list
+        logger.info("end of get all date.\n")
+
+    def _dump_calendars(self):
+        logger.info("start dump calendars......")
+        self._calendars_list = sorted(map(pd.Timestamp, self._kwargs["all_datetime_set"]))
+        self.save_calendars(self._calendars_list)
+        logger.info("end of calendars dump.\n")
+
+    def _dump_instruments(self):
+        logger.info("start dump instruments......")
+        self.save_instruments(self._kwargs["date_range_list"])
+        logger.info("end of instruments dump.\n")
+
+    def _dump_features(self):
+        logger.info("start dump features......")
+        _dump_func = partial(self._dump_bin, calendar_list=self._calendars_list)
+        with tqdm(total=len(self.csv_files)) as p_bar:
+            with ProcessPoolExecutor(max_workers=self.works) as executor:
+                for _ in executor.map(_dump_func, self.csv_files):
+                    p_bar.update()
+
+        logger.info("end of features dump.\n")
+
+    def dump(self):
+        self._get_all_date()
+        self._dump_calendars()
+        self._dump_instruments()
+        self._dump_features()
+
+def get_region(market):
+    return ml.get_market().__class__.__name__.replace('MarketInfo', '').lower()
+
+def dump(freq='day'):
+    """產生Qlib 於台股的資料庫
+    Examples:
+        ```py
+        import qlib
+        import finlab.ml.qlib as q
+
+        q.dump() # generate tw stock database
+        q.init() # initiate tw stock to perform machine leraning tasks (similar to qlib.init)
+
+        import qlib
+        # qlib functions and operations
+        ```
+    """
+    
+    market = ml.get_market()
+    region = get_region(market)
+
+    csv_path = f'~/.qlib/csv_data/{region}_data'
+    qlib_dir = f'~/.qlib/qlib_data/{region}_data'
+    include_fields = "open,close,high,low,volume,factor"
+
+    if not Path(csv_path).expanduser().exists():
+        Path(csv_path).expanduser().mkdir(parents=True)
+    if not Path(qlib_dir).expanduser().exists():
+        Path(qlib_dir).expanduser().mkdir(parents=True)
+
+    c = market.get_price('close', adj=False)
+    ac = market.get_price('close', adj=True)
+    o = market.get_price('open', adj=False)
+    h = market.get_price('high', adj=False)
+    l = market.get_price('low', adj=False)
+    v = market.get_price('volume', adj=False)
+
+    assert c is not None
+    assert ac is not None
+    assert o is not None
+    assert h is not None
+    assert l is not None
+    assert v is not None
+
+    for s in c.columns:
+        pd.DataFrame({
+            'date':c.index.values,
+            'volume': v[s].values,
+            'high': h[s].values,
+            'low': l[s].values,
+            'close': c[s].values,
+            'open': o[s].values,
+            'factor': ac[s].values / c[s].values,
+            'symbol': s
+            }).to_csv(Path(csv_path).expanduser() / f"{s}.csv")
+
+    dumper = DumpDataAll(csv_path, qlib_dir, include_fields=include_fields, freq=freq)
+    dumper()
+
+
+qlib_initialized = False
+
+def init():
+    """Qlib 初始化 (類似於台股版 qlib.init() 但更簡單易用)
+    Examples:
+        ```py
+        import qlib
+        import finlab.ml.qlib as q
+
+        q.dump() # generate tw stock database
+        q.init() # initiate tw stock to perform machine leraning tasks (similar to qlib.init)
+
+        import qlib
+        # qlib functions and operations
+        ```
+    """
+    region = get_region(ml.get_market())
+    try:
+        from qlib import config
+        config._default_region_config[region] = \
+                dict(trade_unit=1000, limit_threshold=0.1, deal_price='close')
+    except:
+        pass
+
+    global qlib_initialized
+
+    if not qlib_initialized:
+        qlib.init(provider_uri=f'~/.qlib/qlib_data/{region}_data', 
+                  region=region)
+        qlib_initialized = True
+
+def alpha(handler='Alpha158', **kwargs):
+
+    """產生 Qlib 的特徵
+    Args:
+        handler (str): 預設為 'alpha158' 也可以設定成 'Alpha360'
+    Examples:
+        ```py
+        import finlab.ml.qlib as q
+        features = q.alpha('Alpha158')
+        ```
+    """
+    init()
+
+    if handler == 'Alpha158':
+        h = Alpha158(instruments=D.instruments(market='all'), **kwargs)
+    elif handler == 'Alpha360':
+        h = Alpha360(instruments=D.instruments(market='all'), **kwargs)
+    else:
+        raise Exception(f"Handler {handler} not supported.")
+
+    alpha = h.fetch(col_set="feature")
+    return alpha
+
+
+
+class CustomDataLoader(DataLoader):
+    def __init__(self, d):
+
+        from finlab.utils import get_tmp_dir
+        tmp_dir = get_tmp_dir()
+        self.data_path = os.path.join(tmp_dir, 'dataset.pickle')
+        d.to_pickle(self.data_path)
+        del d
+        
+    def load(self, instruments, start_time=None, end_time=None) -> pd.DataFrame:
+        d = pd.read_pickle(self.data_path)
+        t = d.index.get_level_values('datetime')
+
+        selected = t.notna()
+        if start_time:
+            selected &= t > start_time
+        if end_time:
+            selected &= t < end_time
+        if instruments:
+            ins = d.index.get_level_values('instrument')
+            selected &= ins.isin(instruments) 
+
+        return d.loc[selected]
+
+
+def make_datasetH(X, y=None, _DEFAULT_LEARN_PROCESSORS=[
+        {"class": "CSZScoreNorm", "kwargs": {"fields_group": "label"}},
+        {"class": "DropnaLabel"},
+    ], train_test_split=(0.7, 0.15, 0.15), segments=None):
+
+    is_train = y is not None
+
+    if is_train:
+
+        if segments is None:
+            tmin = X.index.get_level_values('datetime').min()
+            tmax = X.index.get_level_values('datetime').max()
+            tsplit1 = (tmax - tmin) * train_test_split[0] + tmin
+            tsplit2 = (tmax - tmin) * (train_test_split[0] + train_test_split[1]) + tmin
+            segments = dict(
+                train=(tmin, tsplit1),
+                valid=(tsplit1 + datetime.timedelta(days=1), tsplit2),
+                test=(tsplit2 + datetime.timedelta(days=1), tmax)
+            )
+
+        d = pd.concat([
+            X, 
+            y.replace([np.inf, -np.inf], np.nan).to_frame(name='LABEL0')],
+            axis=1, 
+            keys=['feature', 'label']
+            ).sort_index()
+
+        dl = CustomDataLoader(d)        
+        dh = DatasetH(handler=DataHandlerLP(data_loader=dl, learn_processors=_DEFAULT_LEARN_PROCESSORS), segments=segments)
+        return dh
+
+    x = X.copy()
+    x.columns = pd.MultiIndex.from_tuples([('feature', x) for x in x.columns])
+
+    dl = CustomDataLoader(x)
+
+    tmin = x.index.get_level_values('datetime').min()
+    tmax = x.index.get_level_values('datetime').max()
+
+    segments = {
+        'test': (tmin, tmax)
+    }
+    
+    return DatasetH(handler=DataHandlerLP(data_loader=dl), segments=segments)
+
+
+class WrapperModel():
+
+    def __init__(self, model_config):
+        init()
+        self.config = model_config
+        self.model = None
+        
+    def fit(self, X_train, y_train, segments=None, **fit_params):
+
+        config = self.config
+
+        if 'kwargs' in config and 'd_feat' in config['kwargs']:
+            config['kwargs']['d_feat'] = X_train.shape[1]
+
+        if 'kwargs' in config and 'pt_model_kwargs' in config['kwargs'] and 'input_dim' in config['kwargs']['pt_model_kwargs']:
+            config['kwargs']['pt_model_kwargs']['input_dim'] = X_train.shape[1]
+
+        self.model = init_instance_by_config(self.config)
+        dh = make_datasetH(X_train, y_train, segments=segments)
+        self.model.fit(dh, **fit_params)
+
+    def predict(self, X_test):
+        
+        dh = make_datasetH(X_test, None)
+        return FinlabDataFrame(pd.Series(self.model.predict(dh), index=X_test.index)
+            .reset_index()
+            .pivot(index='datetime', columns='instrument', values=0))
+
+
+def LGBModel():
+    """LGBModel is a wrapper model for LightGBM model.
+    ```py
+    import finlab.ml.qlib as q
+
+    # build X_train, y_train, X_test
+
+    model = q.LGBModel()
+    model.fit(X_train, y_train)
+    y_pred = model.predict(X_test)
+    ```
+    """
+    return  WrapperModel(yaml.safe_load("""
+    class: LGBModel
+    module_path: qlib.contrib.model.gbdt
+    kwargs:
+        loss: mse
+        colsample_bytree: 0.8879
+        learning_rate: 0.2
+        subsample: 0.8789
+        lambda_l1: 205.6999
+        lambda_l2: 580.9768
+        max_depth: 8
+        num_leaves: 210
+        num_threads: 20
+    """))
+
+def XGBModel():
+    """
+    XGBModel is a wrapper model for XGBoost model.
+    ```py
+    import finlab.ml.qlib as q
+
+    # build X_train, y_train, X_test
+
+    model = q.XGBModel()
+    model.fit(X_train, y_train)
+    y_pred = model.predict(X_test)
+    ```
+    """
+    return WrapperModel(yaml.safe_load("""
+class: XGBModel
+module_path: qlib.contrib.model.xgboost
+kwargs:
+    eval_metric: rmse
+    colsample_bytree: 0.8879
+    eta: 0.0421
+    max_depth: 8
+    n_estimators: 647
+    subsample: 0.8789
+    nthread: 20
+"""))
+
+def DEnsmbleModel():
+    """
+    DEnsmbleModel is a wrapper model for Double Ensemble model.
+    ```py
+    import finlab.ml.qlib as q
+
+    # build X_train, y_train, X_test
+
+    model = q.DEnsmbleModel()
+    model.fit(X_train, y_train)
+    y_pred = model.predict(X_test)
+    ```
+    """
+    return WrapperModel(yaml.safe_load("""
+class: DEnsembleModel
+module_path: qlib.contrib.model.double_ensemble
+kwargs:
+    base_model: "gbm"
+    loss: mse
+    num_models: 3
+    enable_sr: True
+    enable_fs: True
+    alpha1: 1
+    alpha2: 1
+    bins_sr: 10
+    bins_fs: 5
+    decay: 0.5
+    sample_ratios:
+        - 0.8
+        - 0.7
+        - 0.6
+        - 0.5
+        - 0.4
+    sub_weights:
+        - 1
+        - 1
+        - 1
+    epochs: 28
+    colsample_bytree: 0.8879
+    learning_rate: 0.0421
+    subsample: 0.8789
+    lambda_l1: 205.6999
+    lambda_l2: 580.9768
+    max_depth: 8
+    num_leaves: 210
+    num_threads: 20
+    verbosity: -1
+"""))
+
+def CatBoostModel():
+    """
+    CatBoostModel is a wrapper model for CatBoost model.
+    ```py
+    import finlab.ml.qlib as q
+
+    # build X_train, y_train, X_test
+
+    model = q.CatBoostModel()
+    model.fit(X_train, y_train)
+    y_pred = model.predict(X_test)
+    ```
+    """
+    return WrapperModel(yaml.safe_load("""
+class: CatBoostModel
+module_path: qlib.contrib.model.catboost_model
+kwargs:
+    loss: RMSE
+    learning_rate: 0.0421
+    subsample: 0.8789
+    max_depth: 6
+    num_leaves: 100
+    thread_count: 20
+    grow_policy: Lossguide
+"""))
+
+def LinearModel():
+    """
+    LinearModel is a wrapper model for Linear model.
+    ```py
+    import finlab.ml.qlib as q
+
+    # build X_train, y_train, X_test
+
+    model = q.LinearModel()
+    model.fit(X_train, y_train)
+    y_pred = model.predict(X_test)
+    ```
+    """
+    return WrapperModel(yaml.safe_load("""
+class: LinearModel
+module_path: qlib.contrib.model.linear
+kwargs:
+    estimator: ols
+"""))
+
+def TabnetModel():
+    """
+    TabnetModel is a wrapper model for Tabnet model.
+    ```py
+    import finlab.ml.qlib as q
+
+    # build X_train, y_train, X_test
+
+    model = q.TabnetModel()
+    model.fit(X_train, y_train)
+    y_pred = model.predict(X_test)
+    ```
+    """
+    return WrapperModel(yaml.safe_load("""
+class: TabnetModel
+module_path: qlib.contrib.model.pytorch_tabnet
+kwargs:
+    d_feat: 8
+    pretrain: False
+    seed: 993
+"""))
+
+def DNNModel():
+    """
+    DNNModel is a wrapper model for Deep Neural Network model.
+    ```py
+    import finlab.ml.qlib as q
+
+    # build X_train, y_train, X_test
+
+    model = q.DNNModel()
+    model.fit(X_train, y_train)
+    y_pred = model.predict(X_test)
+    ```
+    """
+    return WrapperModel(yaml.safe_load("""
+class: DNNModelPytorch
+module_path: qlib.contrib.model.pytorch_nn
+kwargs:
+    loss: mse
+    lr: 0.002
+    optimizer: adam
+    max_steps: 8000
+    batch_size: 8192
+    GPU: 0
+    weight_decay: 0.0002
+    pt_model_kwargs:
+      input_dim: 8
+"""))
+
+def SFMModel():
+    """
+    SFMModel is a wrapper model for SFM.
+    ```py
+    import finlab.ml.qlib as q
+
+    # build X_train, y_train, X_test
+
+    model = q.SFMModel()
+    model.fit(X_train, y_train)
+    y_pred = model.predict(X_test)
+    ```
+    """
+    return WrapperModel(yaml.safe_load("""
+class: SFM
+module_path: qlib.contrib.model.pytorch_sfm
+kwargs:
+    d_feat: 6
+    hidden_size: 64
+    output_dim: 32
+    freq_dim: 25
+    dropout_W: 0.5
+    dropout_U: 0.5
+    n_epochs: 20
+    lr: 0.001
+    batch_size: 1600
+    early_stop: 20
+    eval_steps: 5
+    loss: mse
+    optimizer: adam
+    GPU: 0
+"""))
+
+def get_models():
+    """Return a list of available models.
+    Examples:
+        ```py
+        import finlab.ml.qlib as q
+
+        models = q.get_models()
+        print(models)
+        ```
+        output:
+
+        { 'LGBModel': LGBModel, 'XGBModel': XGBModel, 'DEnsmbleModel': DEnsmbleModel, 'CatBoostModel': CatBoostModel, 'LinearModel': LinearModel, 'TabnetModel': TabnetModel, 'DNNModel': DNNModel, 'SFMModel': SFMModel}
+
+    """
+    return {
+        'LGBModel': LGBModel,
+        'XGBModel': XGBModel,
+        'DEnsmbleModel': DEnsmbleModel,
+        'CatBoostModel': CatBoostModel,
+        'LinearModel': LinearModel,
+        'TabnetModel': TabnetModel,
+        'DNNModel': DNNModel,
     }
```

## finlab/ml/utils.py

 * *Ordering differences only*

```diff
@@ -1,89 +1,89 @@
-import pandas as pd
-import numpy as np
-from typing import Union
-from collections.abc import Iterable
-from itertools import combinations
-
-
-def resampler(df, resample, **kwargs) -> pd.DataFrame:
-
-    if resample is None:
-        return df
-    elif isinstance(resample, Iterable) and not isinstance(resample, str):
-        return df.reindex(resample, method='ffill')
-
-    return df.resample(resample, closed='right', label='right', **kwargs).last()
-
-
-
-def cpcv(df, num_splits=6, test_size=2):
-    """
-    Performs Combinatorial Purged Cross-Validation (CPCV) on a pandas DataFrame.
-
-    Parameters:
-        df: pandas DataFrame
-        num_splits: Number of CPCV splits to perform (default=6)
-        test_size: Number of splits to use for testing (default=2)
-
-    Returns:
-        Generator that yields tuples of indices for the training and testing sets.
-    """
-    # Define variables
-    n = num_splits
-    s = test_size
-    block_size = int(len(df) / n)  # Calculate block size based on number of splits
-    combs = set(range(n))  # Set of all possible splits
-    
-    # Loop over all combinations of splits for testing and training
-    for prod in combinations(combs, r=s):
-        # Calculate the indices for the training and testing sets
-        train_idx = sum([np.arange(i*block_size, (i+1)*block_size, 1).tolist() for i in combs - set(prod)], [])
-        test_idx = sum([np.arange(i*block_size, (i+1)*block_size).tolist() for i in prod], [])
-        
-        # Yield a tuple of the training and testing indices
-        yield (train_idx, test_idx)
-
-
-def combine_cpcv(splits: Union[pd.DataFrame, pd.Series]):
-    """
-    Combines a list of time series datasets into a list of combined datasets.
-
-    Parameters:
-    ys: List of pandas DataFrames, each representing a time series dataset.
-
-    Returns:
-    List of pandas DataFrames, each representing a combined time series dataset.
-    """
-    # Initialize dictionaries to store combined time series datasets
-    creturns = {0:[]}
-    init_keys = {0:[]}
-
-    # Loop over each time series dataset
-    for s in splits:
-        # Get the initial index value of the dataset
-        init_key = s.index[0]
-
-        # Search for an existing dataset with the same initial index value
-        found = False
-        for k in init_keys:
-            if init_key not in init_keys[k]:
-                # If no dataset is found, append the current dataset to a new entry
-                init_keys[k].append(init_key)
-                creturns[k].append(s)
-                found = True
-                break
-
-        # If a dataset is found, append the current dataset to the existing entry
-        if not found:
-            new_return_id = len(creturns)
-            init_keys[new_return_id] = [init_key]
-            creturns[new_return_id] = [s]
-
-    # Combine each set of datasets into a single time series dataset
-    ret = []
-    for s in creturns.values():
-        comb_s = pd.concat(s).sort_index()
-        ret.append(comb_s)
-
-    # Return the list of combined time series datasets
-    return ret
+import pandas as pd
+import numpy as np
+from typing import Union
+from collections.abc import Iterable
+from itertools import combinations
+
+
+def resampler(df, resample, **kwargs) -> pd.DataFrame:
+
+    if resample is None:
+        return df
+    elif isinstance(resample, Iterable) and not isinstance(resample, str):
+        return df.reindex(resample, method='ffill')
+
+    return df.resample(resample, closed='right', label='right', **kwargs).last()
+
+
+
+def cpcv(df, num_splits=6, test_size=2):
+    """
+    Performs Combinatorial Purged Cross-Validation (CPCV) on a pandas DataFrame.
+
+    Parameters:
+        df: pandas DataFrame
+        num_splits: Number of CPCV splits to perform (default=6)
+        test_size: Number of splits to use for testing (default=2)
+
+    Returns:
+        Generator that yields tuples of indices for the training and testing sets.
+    """
+    # Define variables
+    n = num_splits
+    s = test_size
+    block_size = int(len(df) / n)  # Calculate block size based on number of splits
+    combs = set(range(n))  # Set of all possible splits
+    
+    # Loop over all combinations of splits for testing and training
+    for prod in combinations(combs, r=s):
+        # Calculate the indices for the training and testing sets
+        train_idx = sum([np.arange(i*block_size, (i+1)*block_size, 1).tolist() for i in combs - set(prod)], [])
+        test_idx = sum([np.arange(i*block_size, (i+1)*block_size).tolist() for i in prod], [])
+        
+        # Yield a tuple of the training and testing indices
+        yield (train_idx, test_idx)
+
+
+def combine_cpcv(splits: Union[pd.DataFrame, pd.Series]):
+    """
+    Combines a list of time series datasets into a list of combined datasets.
+
+    Parameters:
+    ys: List of pandas DataFrames, each representing a time series dataset.
+
+    Returns:
+    List of pandas DataFrames, each representing a combined time series dataset.
+    """
+    # Initialize dictionaries to store combined time series datasets
+    creturns = {0:[]}
+    init_keys = {0:[]}
+
+    # Loop over each time series dataset
+    for s in splits:
+        # Get the initial index value of the dataset
+        init_key = s.index[0]
+
+        # Search for an existing dataset with the same initial index value
+        found = False
+        for k in init_keys:
+            if init_key not in init_keys[k]:
+                # If no dataset is found, append the current dataset to a new entry
+                init_keys[k].append(init_key)
+                creturns[k].append(s)
+                found = True
+                break
+
+        # If a dataset is found, append the current dataset to the existing entry
+        if not found:
+            new_return_id = len(creturns)
+            init_keys[new_return_id] = [init_key]
+            creturns[new_return_id] = [s]
+
+    # Combine each set of datasets into a single time series dataset
+    ret = []
+    for s in creturns.values():
+        comb_s = pd.concat(s).sort_index()
+        ret.append(comb_s)
+
+    # Return the list of combined time series datasets
+    return ret
```

## finlab/online/base_account.py

 * *Ordering differences only*

```diff
@@ -1,269 +1,269 @@
-from abc import ABC, abstractmethod
-from dataclasses import dataclass
-from typing import Any
-
-from concurrent.futures import ThreadPoolExecutor
-from functools import lru_cache
-import pkg_resources
-import pandas as pd
-import numpy as np
-import importlib
-import requests
-import datetime
-import numbers
-import time
-import os
-
-from finlab import logger
-from finlab.online.enums import *
-
-
-@dataclass
-class Order():
-
-    """
-    Order status
-
-    委託單的狀態
-
-    Attributes:
-        order_id (str): 委託單的 id，與券商 API 所提供的 id 一致
-        stock_id (str): 股票代號 ex: '2330'
-        action (Action): 買賣方向，通常為 'BUY' 或是 'SELL'
-        price (numbers.Number): 股票買賣的價格(限價單)
-        quantity (numbers.Number): 委託股票的總數量（張數），允許小數點
-        filled_quantity (numbers.Number): 以成交股票的數量（張數），允許小數點
-        status (OrderStatus): 委託狀態，可以設定為：'NEW', 'PARTIALLY_FILLED', 'FILLED', 'CANCEL'
-        time (datetime.datetime): 委託時間
-        org_order (Any = None): 券商所提供的委託物件格式
-    """
-
-    order_id: str
-    stock_id: str
-    action: Action
-    price: numbers.Number
-    quantity: numbers.Number
-    filled_quantity: numbers.Number
-    status: OrderStatus
-    order_condition: OrderCondition
-    time: datetime.datetime
-    org_order: Any = None
-
-
-@dataclass
-class Stock():
-
-    """
-    Stock
-
-    即時股票資料
-
-    Attributes:
-        stock_id (str): 股票代號
-        open (numbers.Number): 開盤價
-        high (numbers.Number): 最高價
-        low (numbers.Number): 最低價
-        close (numbers.Number): 收盤價
-        bid_price (numbers.Number): 買方第一檔價格
-        bid_volume (numbers.Number): 買方第一檔量
-        ask_price (numbers.Number): 賣方第一檔價格
-        ask_volume (numbers.Number: 賣方第一檔量
-    """
-
-    stock_id: str
-    open: numbers.Number
-    high: numbers.Number
-    low: numbers.Number
-    close: numbers.Number
-    bid_price: numbers.Number
-    bid_volume: numbers.Number
-    ask_price: numbers.Number
-    ask_volume: numbers.Number
-
-    def to_dict(self):
-        return {a: getattr(self, a) for a in Stock.attrs}
-
-
-class Account(ABC):
-    """股票帳戶的 abstract class
-    可以繼承此 Account，來實做券商的帳戶買賣動作，目前已經實做 SinopacAccount (永豐證券) 以及 FugleAccount (玉山富果)，來進行交易。可以用以下方式建構物件並用來交易：
-
-    永豐證券
-    ```py
-    import os
-    from finlab.online.sinopac_account import SinopacAccount
-
-
-    # 舊版請使用
-    # shioaji < 1.0.0 and finlab < 0.3.18
-    os.environ['SHIOAJI_ACCOUNT']= '永豐證券帳號'
-    os.environ['SHIOAJI_PASSWORD']= '永豐證券密碼'
-
-    # 新版請使用
-    # shioaji >= 1.0.0 and finlab >= 0.3.18
-    os.environ['SHIOAJI_API_KEY'] = '永豐證券API_KEY'
-    os.environ['SHIOAJI_SECRET_KEY'] = '永豐證券SECRET_KEY'
-    os.environ['SHIOAJI_CERT_PERSON_ID']= '身份證字號'
-
-    # shioaji
-    os.environ['SHIOAJI_CERT_PATH']= '永豐證券憑證路徑'
-    os.environ['SHIOAJI_CERT_PASSWORD'] = '永豐證券憑證密碼' # 預設與身份證字號
-
-    acc = SinopacAccount()
-    ```
-    玉山富果:
-    ```py
-    from finlab.online.fugle_account import FugleAccount
-    import os
-    os.environ['FUGLE_CONFIG_PATH'] = '玉山富果交易設定檔(config.ini.example)路徑'
-    os.environ['FUGLE_MARKET_API_KEY'] = '玉山富果的行情API Token'
-
-    acc = FugleAccount()
-    ```
-
-    """
-
-    @classmethod
-    def check_version(self):
-
-        m = self.required_module
-        v = self.module_version
-
-        # check module installed
-        if importlib.util.find_spec(m) is None:
-            raise Exception(
-                f"Please install {m} using the following script: pip install {m}=={v}.")
-
-        # check module version
-        present_version = pkg_resources.get_distribution(m).version
-        if present_version > v:
-            logger.warning(
-                f'Current {m}=={present_version} may not be compatable. You could using the following command to install the compatable version: pip install {m}=={v}')
-        
-
-    @abstractmethod
-    def create_order(self, action, stock_id, quantity, price=None, force=False, wait_for_best_price=False):
-        """產生新的委託單
-
-        Args:
-            action (Action): 買賣方向，通常為 'BUY' 或是 'SELL'
-
-            stock_id (str): 股票代號 ex: '2330'
-
-            quantity (numbers.Number): 委託股票的總數量（張數），允許小數點
-
-            price (numbers.Number, optional): 股票買賣的價格(限價單)
-
-            force (bool): 是否用最差之價格（長跌停）強制成交? 當成交量足夠時，可以比較快成交，然而當成交量低時，容易有大的滑價
-
-            wait_for_best_price (bool): 是否用最佳之價格（長跌停），無限時間等待？當今天要出場時，可以開啟等漲停價來購買，當今天要買入時，可以掛跌停價等待買入時機。
-
-        Returns:
-            (str): order id 券商提供的委託單編號
-        """
-        pass
-
-    @abstractmethod
-    def update_order(self, order_id, price=None, quantity=None):
-        """產生新的委託單
-
-        Attributes:
-            order_id (str): 券商所提供的委託單 ID
-            price (numbers.Number, optional): 更新的限價
-            quantity (numbers.Number, optional): 更新的待成交量
-
-        Returns:
-            (None): 無跳出 erorr 代表成功更新委託單
-        """
-        pass
-
-    @abstractmethod
-    def cancel_order(self, order_id):
-        """刪除委託單
-
-        建議使用 刪除委託單此功能前，先使用 update_order() 來更新委託單的狀況！如下
-        ```py
-        acc.update_order()
-        acc.cancel_order('ORDER_ID')
-        ```
-
-        Attributes:
-            order_id (str): 券商所提供的委託單 ID
-
-        Returns:
-            (None): 代表成功更新委託單
-        """
-        pass
-
-    @abstractmethod
-    def get_orders(self):
-        """拿到現在所有委託單
-        
-        Returns:
-            (Dict[str, Order]): 所有委託單 id 與委託單資料
-                !!! example
-                    `{'12345A': Order(order_id='12345A', stock_id='5410',...),...}`
-        """
-        pass
-
-    @abstractmethod
-    def get_stocks(self, stock_ids):
-        """拿到現在股票報價
-
-        Attributes:
-            stock_ids (`list` of `str`): 一次拿取所有股票的報價，ex: ['1101', '2330']
-        
-        Returns:
-            (dict): 報價資料，
-                !!! example
-                    `{'1101': Stock(stock_id='1101', open=31.15, high=31.85, low=31.1, close=31.65, bid_price=31.6, bid_volume=728.0, ask_price=31.65, ask_volume=202)}`
-        """
-        pass
-
-    @abstractmethod
-    def get_position(self):
-        """拿到當前帳戶的股票部位
-
-        Returns:
-            (Position): 當前股票部位
-        """
-        pass
-
-    @abstractmethod
-    def get_total_balance(self):
-        """拿到當前帳戶的股票部位淨值"""
-        pass
-
-    @abstractmethod
-    def get_cash(self):
-        """拿到當前帳戶的現金"""
-        pass
-    
-    @abstractmethod
-    def get_settlement(self):
-        """拿到當前帳戶的結算資料"""
-        pass        
-
-    def sep_odd_lot_order(self):
-        return True
-
-    def get_price(self, stock_ids):
-
-        s = self.get_stocks(stock_ids)
-
-        price = {pname: s[pname].close for pname in s}
-
-        for sid, p in price.items():
-            if p == 0:
-                bid_price = s[sid].bid_price if s[sid].bid_price != 0 else s[sid].ask_price
-                ask_price = s[sid].ask_price if s[sid].ask_price != 0 else s[sid].bid_price
-                price[sid] = (bid_price + ask_price)/2
-
-            if price[sid] == 0:
-                raise Exception(
-                    f"Stock {sid} has no price to reference. Use latest close of previous trading day")
-
-        return price
-
-    def on_trades(self, func):
-        pass
+from abc import ABC, abstractmethod
+from dataclasses import dataclass
+from typing import Any
+
+from concurrent.futures import ThreadPoolExecutor
+from functools import lru_cache
+import pkg_resources
+import pandas as pd
+import numpy as np
+import importlib
+import requests
+import datetime
+import numbers
+import time
+import os
+
+from finlab import logger
+from finlab.online.enums import *
+
+
+@dataclass
+class Order():
+
+    """
+    Order status
+
+    委託單的狀態
+
+    Attributes:
+        order_id (str): 委託單的 id，與券商 API 所提供的 id 一致
+        stock_id (str): 股票代號 ex: '2330'
+        action (Action): 買賣方向，通常為 'BUY' 或是 'SELL'
+        price (numbers.Number): 股票買賣的價格(限價單)
+        quantity (numbers.Number): 委託股票的總數量（張數），允許小數點
+        filled_quantity (numbers.Number): 以成交股票的數量（張數），允許小數點
+        status (OrderStatus): 委託狀態，可以設定為：'NEW', 'PARTIALLY_FILLED', 'FILLED', 'CANCEL'
+        time (datetime.datetime): 委託時間
+        org_order (Any = None): 券商所提供的委託物件格式
+    """
+
+    order_id: str
+    stock_id: str
+    action: Action
+    price: numbers.Number
+    quantity: numbers.Number
+    filled_quantity: numbers.Number
+    status: OrderStatus
+    order_condition: OrderCondition
+    time: datetime.datetime
+    org_order: Any = None
+
+
+@dataclass
+class Stock():
+
+    """
+    Stock
+
+    即時股票資料
+
+    Attributes:
+        stock_id (str): 股票代號
+        open (numbers.Number): 開盤價
+        high (numbers.Number): 最高價
+        low (numbers.Number): 最低價
+        close (numbers.Number): 收盤價
+        bid_price (numbers.Number): 買方第一檔價格
+        bid_volume (numbers.Number): 買方第一檔量
+        ask_price (numbers.Number): 賣方第一檔價格
+        ask_volume (numbers.Number: 賣方第一檔量
+    """
+
+    stock_id: str
+    open: numbers.Number
+    high: numbers.Number
+    low: numbers.Number
+    close: numbers.Number
+    bid_price: numbers.Number
+    bid_volume: numbers.Number
+    ask_price: numbers.Number
+    ask_volume: numbers.Number
+
+    def to_dict(self):
+        return {a: getattr(self, a) for a in Stock.attrs}
+
+
+class Account(ABC):
+    """股票帳戶的 abstract class
+    可以繼承此 Account，來實做券商的帳戶買賣動作，目前已經實做 SinopacAccount (永豐證券) 以及 FugleAccount (玉山富果)，來進行交易。可以用以下方式建構物件並用來交易：
+
+    永豐證券
+    ```py
+    import os
+    from finlab.online.sinopac_account import SinopacAccount
+
+
+    # 舊版請使用
+    # shioaji < 1.0.0 and finlab < 0.3.18
+    os.environ['SHIOAJI_ACCOUNT']= '永豐證券帳號'
+    os.environ['SHIOAJI_PASSWORD']= '永豐證券密碼'
+
+    # 新版請使用
+    # shioaji >= 1.0.0 and finlab >= 0.3.18
+    os.environ['SHIOAJI_API_KEY'] = '永豐證券API_KEY'
+    os.environ['SHIOAJI_SECRET_KEY'] = '永豐證券SECRET_KEY'
+    os.environ['SHIOAJI_CERT_PERSON_ID']= '身份證字號'
+
+    # shioaji
+    os.environ['SHIOAJI_CERT_PATH']= '永豐證券憑證路徑'
+    os.environ['SHIOAJI_CERT_PASSWORD'] = '永豐證券憑證密碼' # 預設與身份證字號
+
+    acc = SinopacAccount()
+    ```
+    玉山富果:
+    ```py
+    from finlab.online.fugle_account import FugleAccount
+    import os
+    os.environ['FUGLE_CONFIG_PATH'] = '玉山富果交易設定檔(config.ini.example)路徑'
+    os.environ['FUGLE_MARKET_API_KEY'] = '玉山富果的行情API Token'
+
+    acc = FugleAccount()
+    ```
+
+    """
+
+    @classmethod
+    def check_version(self):
+
+        m = self.required_module
+        v = self.module_version
+
+        # check module installed
+        if importlib.util.find_spec(m) is None:
+            raise Exception(
+                f"Please install {m} using the following script: pip install {m}=={v}.")
+
+        # check module version
+        present_version = pkg_resources.get_distribution(m).version
+        if present_version > v:
+            logger.warning(
+                f'Current {m}=={present_version} may not be compatable. You could using the following command to install the compatable version: pip install {m}=={v}')
+        
+
+    @abstractmethod
+    def create_order(self, action, stock_id, quantity, price=None, force=False, wait_for_best_price=False):
+        """產生新的委託單
+
+        Args:
+            action (Action): 買賣方向，通常為 'BUY' 或是 'SELL'
+
+            stock_id (str): 股票代號 ex: '2330'
+
+            quantity (numbers.Number): 委託股票的總數量（張數），允許小數點
+
+            price (numbers.Number, optional): 股票買賣的價格(限價單)
+
+            force (bool): 是否用最差之價格（長跌停）強制成交? 當成交量足夠時，可以比較快成交，然而當成交量低時，容易有大的滑價
+
+            wait_for_best_price (bool): 是否用最佳之價格（長跌停），無限時間等待？當今天要出場時，可以開啟等漲停價來購買，當今天要買入時，可以掛跌停價等待買入時機。
+
+        Returns:
+            (str): order id 券商提供的委託單編號
+        """
+        pass
+
+    @abstractmethod
+    def update_order(self, order_id, price=None, quantity=None):
+        """產生新的委託單
+
+        Attributes:
+            order_id (str): 券商所提供的委託單 ID
+            price (numbers.Number, optional): 更新的限價
+            quantity (numbers.Number, optional): 更新的待成交量
+
+        Returns:
+            (None): 無跳出 erorr 代表成功更新委託單
+        """
+        pass
+
+    @abstractmethod
+    def cancel_order(self, order_id):
+        """刪除委託單
+
+        建議使用 刪除委託單此功能前，先使用 update_order() 來更新委託單的狀況！如下
+        ```py
+        acc.update_order()
+        acc.cancel_order('ORDER_ID')
+        ```
+
+        Attributes:
+            order_id (str): 券商所提供的委託單 ID
+
+        Returns:
+            (None): 代表成功更新委託單
+        """
+        pass
+
+    @abstractmethod
+    def get_orders(self):
+        """拿到現在所有委託單
+        
+        Returns:
+            (Dict[str, Order]): 所有委託單 id 與委託單資料
+                !!! example
+                    `{'12345A': Order(order_id='12345A', stock_id='5410',...),...}`
+        """
+        pass
+
+    @abstractmethod
+    def get_stocks(self, stock_ids):
+        """拿到現在股票報價
+
+        Attributes:
+            stock_ids (`list` of `str`): 一次拿取所有股票的報價，ex: ['1101', '2330']
+        
+        Returns:
+            (dict): 報價資料，
+                !!! example
+                    `{'1101': Stock(stock_id='1101', open=31.15, high=31.85, low=31.1, close=31.65, bid_price=31.6, bid_volume=728.0, ask_price=31.65, ask_volume=202)}`
+        """
+        pass
+
+    @abstractmethod
+    def get_position(self):
+        """拿到當前帳戶的股票部位
+
+        Returns:
+            (Position): 當前股票部位
+        """
+        pass
+
+    @abstractmethod
+    def get_total_balance(self):
+        """拿到當前帳戶的股票部位淨值"""
+        pass
+
+    @abstractmethod
+    def get_cash(self):
+        """拿到當前帳戶的現金"""
+        pass
+    
+    @abstractmethod
+    def get_settlement(self):
+        """拿到當前帳戶的結算資料"""
+        pass        
+
+    def sep_odd_lot_order(self):
+        return True
+
+    def get_price(self, stock_ids):
+
+        s = self.get_stocks(stock_ids)
+
+        price = {pname: s[pname].close for pname in s}
+
+        for sid, p in price.items():
+            if p == 0:
+                bid_price = s[sid].bid_price if s[sid].bid_price != 0 else s[sid].ask_price
+                ask_price = s[sid].ask_price if s[sid].ask_price != 0 else s[sid].bid_price
+                price[sid] = (bid_price + ask_price)/2
+
+            if price[sid] == 0:
+                raise Exception(
+                    f"Stock {sid} has no price to reference. Use latest close of previous trading day")
+
+        return price
+
+    def on_trades(self, func):
+        pass
```

## finlab/online/binance_account.py

 * *Ordering differences only*

```diff
@@ -1,404 +1,404 @@
-from binance import client
-from binance.enums import SIDE_BUY, SIDE_SELL, ORDER_TYPE_LIMIT, ORDER_TYPE_MARKET
-
-from finlab.online.base_account import OrderCondition, Account, Action, Order, Stock, OrderStatus
-from finlab.online.order_executor import Position
-import os
-import os
-import sys
-import time
-import math
-import logging
-import datetime
-import traceback
-import pandas as pd
-import cachetools.func
-from typing import Union
-from decimal import Decimal
-
-
-
-def round_step_size(quantity: Union[float, Decimal], step_size: Union[float, Decimal], round_up: bool = False) -> Decimal:
-    """Rounds a given quantity to a specific step size, either rounding up or down.
-
-    :param quantity: required
-    :param step_size: required
-    :param round_up: If True, round up; if False, round down.
-
-    :return: decimal
-    """
-    quantity = Decimal(str(quantity))
-    step_size = Decimal(str(step_size))
-
-    if round_up:
-        rounded_quantity = math.ceil(quantity / step_size) * step_size
-    else:
-        rounded_quantity = math.floor(quantity / step_size) * step_size
-
-    return rounded_quantity.normalize()
-
-def retry(f, n_retry, *args, **argvs):
-  for i in range(1, n_retry + 1):
-    try:
-      return f(*args, **argvs)
-    except Exception as e:
-      exc_type, exc_obj, exc_tb = sys.exc_info()
-      fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)
-      print(traceback.format_exc())
-      print(args, argvs)
-
-      if i != n_retry:
-        time.sleep(30)
-
-class BinanceHelper(object):
-  
-  @staticmethod
-  def get_spot_balance(client):
-
-    spot_account_balance = pd.DataFrame(retry(client.get_account, 3)['balances']).set_index('asset').astype(float)
-    spot_account_balance = spot_account_balance.sum(axis=1)[spot_account_balance.sum(axis=1)!=0]
-    spot_account_balance.index = spot_account_balance.index + 'USDT'
-
-    spot_tickers = BinanceHelper.get_spot_asset_price(client)
-    spot_tickers['USDTUSDT'] = 1
-    spot_tickers = pd.Series(spot_tickers)
-    return (spot_tickers.loc[spot_account_balance.index.intersection(spot_tickers.index)] * spot_account_balance).sum()
-  
-  @staticmethod
-  def get_futures_balance(client):
-    
-    def list_select(list, key, value):
-      ret = [l for l in list if l[key] == value]
-      if len(ret) == 0:
-        return None
-      else:
-        return ret[0]
-      
-    # calculate futures balance
-    futures_position_information = retry(client.futures_position_information, 3)
-    future_account_balance = retry(client.futures_account_balance, 3)
-    futures_position_information = pd.DataFrame(futures_position_information).astype({'entryPrice': 'float', 'positionAmt':'float', 'unRealizedProfit':'float'})
-    futures_total_balance = futures_position_information.unRealizedProfit.sum()+float(list_select(future_account_balance, 'asset', 'USDT')['balance'])\
-      +float(list_select(future_account_balance, 'asset', 'BNB')['balance']) * BinanceHelper.get_futures_asset_price(client)['BNBUSDT']
-
-    return futures_total_balance
-  
-  @staticmethod
-  @cachetools.func.ttl_cache(ttl=60)
-  def get_spot_asset_price(client):
-      all_tickers = retry(client.get_all_tickers, 3)
-      all_ticker_price = {d['symbol']: Decimal(d['price']) for d in all_tickers}
-      return all_ticker_price
-  
-  @staticmethod
-  @cachetools.func.ttl_cache(ttl=60)
-  def get_futures_asset_price(client):
-    all_tickers = retry(client.futures_mark_price, 3)
-    all_ticker_price = {m['symbol']: Decimal(m['markPrice']) for m in all_tickers}
-    return all_ticker_price
-  
-  @staticmethod
-  def get_spot_position(client):
-    # spot balance
-    account = retry(client.get_account, 3)['balances']
-    spot_balance = {obj['asset']:Decimal(obj['free']) + Decimal(obj['locked']) for obj in account if Decimal(obj['free']) != 0}
-    return {k:v for k, v in spot_balance.items()}
-  
-  @staticmethod
-  def get_futures_position(client):
-
-    futures_balance = client.futures_position_information()
-    futures_balance = pd.DataFrame(futures_balance)\
-      .astype({'entryPrice': 'float', 'positionAmt':'float', 'unRealizedProfit':'float'})
-
-    futures_balance = futures_balance.loc[futures_balance.symbol.str[-4:] == 'USDT']
-    futures_balance.index = futures_balance.symbol.str[:-4]
-    futures_balance = futures_balance.positionAmt.to_dict()
-    return {k:v for k, v in futures_balance.items() if v != 0}
-
-
-class BinanceSimpleClient():
-
-  def __init__(self, client):
-    self.client = client
-    
-    futures_exchange_info = retry(client.futures_exchange_info, 3)
-    exchange_info = retry(client.get_exchange_info, 3)
-
-    if futures_exchange_info is None:
-        raise Exception('Cannot connect to binance client.futures_exchange_info')
-    
-    if exchange_info is None:
-        raise Exception('Cannot connect to binance client.exchange_info')
-
-    self.market_info = {
-      'FUTURES': pd.DataFrame(futures_exchange_info['symbols']).set_index('symbol'),
-      'SPOT': pd.DataFrame(exchange_info['symbols']).set_index('symbol'),
-    }
-
-  def round_price(self, symbol, price, round_up=False, market_type='SPOT'):
-    info = self.market_info[market_type]
-    ticksize = Decimal(self.list_select(info.loc[symbol].filters, 'filterType', 'PRICE_FILTER')['tickSize'])
-    #return round(int(price / ticksize) * ticksize, 9)
-    return round_step_size(price, ticksize, round_up=round_up)
-
-  def round_quantity(self, symbol, quantity, round_up=False, market_type='SPOT'):
-
-    info = self.market_info[market_type]
-    symbol_info = self.list_select(info.loc[symbol].filters, 'filterType', 'LOT_SIZE')
-    step_size = Decimal(symbol_info['stepSize'])
-    min_qty = Decimal(symbol_info['minQty'])
-    
-    sign = (quantity < 0) * -2 + 1
-    ret = sign * round_step_size(abs(quantity), step_size, round_up=round_up)
-    # ret = round(sign * (int((quantity-min_qty) / step_size) * step_size + min_qty), 9)
-    
-    if abs(ret) < min_qty:
-      ret = 0
-      
-    return ret
-  
-  @staticmethod
-  def list_select(list, key, value):
-    ret = [l for l in list if l[key] == value]
-    if len(ret) == 0:
-      return None
-    else:
-      return ret[0]
-
-  def pass_min_notional(self, symbol, quantity, market_type, price=None):
-    info = self.market_info[market_type]
-    notional = self.list_select(info.loc[symbol].filters, 'filterType', 'NOTIONAL')
-    min_notional = Decimal(notional.get('minNotional', notional.get('notional', 0)))
-    
-    present_price = price
-    if present_price is None:
-      if market_type == 'SPOT':
-        present_price = BinanceHelper.get_spot_asset_price(self.client)[symbol]
-      elif market_type == 'FUTURES':
-        present_price = BinanceHelper.get_futures_asset_price(self.client)[symbol]
-
-    if abs(quantity) * present_price < min_notional:
-        return False
-    return True
-
-  def create_order(self, symbol, quantity, market_type, price=None, stop_price=None):
-
-    if symbol == 'NBTUSDT':
-      return None
-
-    side = SIDE_BUY if quantity > 0 else SIDE_SELL
-
-    if stop_price is not None:
-        assert price is not None
-
-    ORDER_TYPE_STOP = 'STOP'
-
-    order_type = ORDER_TYPE_STOP if stop_price is not None else \
-        ORDER_TYPE_LIMIT if price is not None else ORDER_TYPE_MARKET
-
-    
-    if price is not None:
-      price = self.round_price(symbol, price, round_up=False, market_type=market_type)
-
-    if stop_price is not None:
-      stop_price = self.round_price(symbol, stop_price, round_up=False, market_type=market_type)
-
-    # recalculate amount according to step size
-    quantity = self.round_quantity(symbol, quantity, round_up=False, market_type=market_type)
-    icebergQty = self.round_quantity(symbol, quantity/Decimal('9.5'), round_up=False, market_type=market_type)
-
-    # check min invest value (notional)
-    
-    pass_notional = self.pass_min_notional(symbol, quantity, market_type=market_type, price=price)
-
-    min_notional_iceberg = 0.05 if symbol[-3:] == 'BTC' else 1000 if symbol[-4:] == 'USDT' else 1000
-
-    use_iceberg = (abs(quantity) * abs(price) > min_notional_iceberg) & (abs(icebergQty)*10 > abs(quantity))
-    
-    params = {
-      'side':side,
-      'type':order_type,
-      'symbol':symbol,
-      'quantity': format(abs(quantity), 'f') if isinstance(quantity, Decimal) else abs(quantity),
-    }
-    
-    if use_iceberg and market_type == 'SPOT' and icebergQty != 0:
-      params['icebergQty'] = format(abs(icebergQty), 'f') if isinstance(icebergQty, Decimal) else abs(icebergQty)
-
-    if market_type == 'FUTURES' and side == SIDE_BUY:
-      params['reduceOnly'] = 'true'
-
-    if price is not None:
-
-      precision = 8
-      price_str = '{:0.0{}f}'.format(price, precision)
-      params['price'] = price_str
-      params['timeInForce'] = 'GTC' #if order_type != ORDER_TYPE_LIMIT else 'GTX'
-
-    if stop_price is not None:
-      params['stopPrice'] = stop_price
-
-    if market_type == 'SPOT':
-      order_func = self.client.create_order
-    elif market_type == 'FUTURES':
-      order_func = self.client.futures_create_order
-    else:
-      raise Exception('market_type not in ["SPOT", "FUTURES"]')
-    
-    if (not pass_notional or quantity == 0) and 'reduceOnly' not in params:
-      return None
-
-    order = retry(order_func, 1, **params)
-
-    return order
-
-
-class BinanceAccount(Account):
-
-    def __init__(self, base_currency='USDT'):
-
-        if 'BINANCE_API_KEY' in os.environ:
-            key = os.environ['BINANCE_API_KEY']
-            secret = os.environ['BINANCE_API_SECRET']
-            self.simple_client = BinanceSimpleClient(client.Client(key, secret))
-        else:
-            self.simple_client = BinanceSimpleClient(client.Client())
-
-        self.threading = None
-        self.base_currency = base_currency
-
-    def create_order(self, action, stock_id, quantity, price=None, odd_lot=False, best_price_limit=False, market_order=False, order_cond=OrderCondition.CASH, extra_bid_pct=0) -> str:
-
-        if quantity <= 0:
-            raise ValueError("quantity should be larger than zero")
-
-        if best_price_limit and market_order:
-            raise ValueError(
-                "The flags best_price_limit and  market_order should not both be True")
-
-        if not market_order:
-            assert price is not None
-
-        if action == Action.SELL:
-            quantity = - abs(quantity)
-
-        # create_order(self, symbol, quantity, market_type, price=None, stop_price=None):
-
-        args = {
-            'symbol': stock_id+self.base_currency,
-            'quantity': quantity,
-            'market_type': 'SPOT',
-        }
-
-        if not market_order:
-            args['price'] = price
-        
-        order = self.simple_client.create_order(**args)
-
-        if not order or not 'orderId' in order:
-            print('client order not success')
-            return ''
-
-        return stock_id + '|' + str(order['orderId'])
-
-    def update_order(self, order_id, price=None, quantity=None):
-
-        stock_id, order_id = order_id.split('|')
-
-        if isinstance(price, int):
-            price = Decimal(price)
-
-        order = self.simple_client.client.get_order(symbol=stock_id, orderId=order_id)
-        self.simple_client.client.cancel_order(symbol=stock_id, orderId=order_id)
-
-        if quantity:
-          quantity = quantity - order['executedQty']
-        else:
-          quantity = (order['executedQty'] - order['origQty']) * ((order['side'] == 'BUY')*2 - 1)
-
-        self.simple_client.create_order(symbol=stock_id, quantity=quantity, price=price, market_type='SPOT')
-        return
-
-    def cancel_order(self, order_id):
-        stock_id, order_id = order_id.split('|')
-
-        try:
-            self.simple_client.client.cancel_order(symbol=stock_id, orderId=order_id)
-        except Exception as e:
-            logging.warning(f"cancel_order: Cannot cancel order {order_id}: {e}")
-
-    def get_orders(self):
-
-        orders = self.simple_client.client.get_open_orders()
-        ret = {}
-        for o in orders:
-            status = OrderStatus.NEW
-            if o['executedQty'] == 0:
-                status = OrderStatus.NEW
-            elif o['origQty'] != o['executedQty']:
-                status = 'Filling'
-                status = OrderStatus.PARTIALLY_FILLED
-            else:
-                status = OrderStatus.FILLED
-
-            if o['status'] == 'CANCELED':
-                status = OrderStatus.CANCEL
-
-            ret[str(o['symbol'])+'|'+str(o['orderId'])] = Order(order_id=o['orderId'], action=o['side'], price=o['price'], 
-                quantity=o['origQty'], filled_quantity=o['executedQty'], status=status, 
-                time=datetime.datetime.fromtimestamp(int(o['time'])/1000), 
-                stock_id=o['symbol'], order_condition=OrderCondition.CASH, org_order=o)
-        return ret
-
-    def get_stocks(self, stock_ids):
-
-        if not stock_ids:
-            return {}
-
-        ret = {}
-
-        all_symbols = set(t['symbol'] for t in self.simple_client.client.get_all_tickers())
-
-        symbols = '["'+ '","'.join([s+self.base_currency for s in stock_ids if s+self.base_currency in all_symbols]) + '"]'
-        tickers = self.simple_client.client.get_ticker(symbols=symbols)
-
-        for t in tickers:
-            asset = t['symbol'].replace(self.base_currency, '')
-            ret[asset] = Stock(stock_id=asset, open=Decimal(t['openPrice']), 
-                               high=Decimal(t['highPrice']), low=Decimal(t['lowPrice']), 
-                close=Decimal(t['lastPrice']), bid_price=Decimal(t['bidPrice']), bid_volume=Decimal(t['bidQty']), 
-                ask_price=Decimal(t['askPrice']), ask_volume=Decimal(t['askQty']))
-            
-        return ret
-
-    def get_position(self):
-        ret = BinanceHelper.get_spot_position(self.simple_client.client)
-        return Position.from_list([
-           {'stock_id': sym, 'quantity': amount, 'order_condition': OrderCondition.CASH} 
-           for sym, amount in ret.items()])
-        
-    def get_total_balance(self):
-        
-        return BinanceHelper.get_spot_balance(self.simple_client.client)
-
-    def support_day_trade_condition(self):
-        return True
-
-    def on_trades(self, func):
-        pass
-    
-    def sep_odd_lot_order(self):
-        return False
-
-    def get_cash(self):
-
-        position = self.get_position()
-        for p in position.position:
-            if p.stock_id == self.base_currency:
-                return p.quantity
-        return 0
-
-    def get_settlement(self):
-        return 0
-      
+from binance import client
+from binance.enums import SIDE_BUY, SIDE_SELL, ORDER_TYPE_LIMIT, ORDER_TYPE_MARKET
+
+from finlab.online.base_account import OrderCondition, Account, Action, Order, Stock, OrderStatus
+from finlab.online.order_executor import Position
+import os
+import os
+import sys
+import time
+import math
+import logging
+import datetime
+import traceback
+import pandas as pd
+import cachetools.func
+from typing import Union
+from decimal import Decimal
+
+
+
+def round_step_size(quantity: Union[float, Decimal], step_size: Union[float, Decimal], round_up: bool = False) -> Decimal:
+    """Rounds a given quantity to a specific step size, either rounding up or down.
+
+    :param quantity: required
+    :param step_size: required
+    :param round_up: If True, round up; if False, round down.
+
+    :return: decimal
+    """
+    quantity = Decimal(str(quantity))
+    step_size = Decimal(str(step_size))
+
+    if round_up:
+        rounded_quantity = math.ceil(quantity / step_size) * step_size
+    else:
+        rounded_quantity = math.floor(quantity / step_size) * step_size
+
+    return rounded_quantity.normalize()
+
+def retry(f, n_retry, *args, **argvs):
+  for i in range(1, n_retry + 1):
+    try:
+      return f(*args, **argvs)
+    except Exception as e:
+      exc_type, exc_obj, exc_tb = sys.exc_info()
+      fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)
+      print(traceback.format_exc())
+      print(args, argvs)
+
+      if i != n_retry:
+        time.sleep(30)
+
+class BinanceHelper(object):
+  
+  @staticmethod
+  def get_spot_balance(client):
+
+    spot_account_balance = pd.DataFrame(retry(client.get_account, 3)['balances']).set_index('asset').astype(float)
+    spot_account_balance = spot_account_balance.sum(axis=1)[spot_account_balance.sum(axis=1)!=0]
+    spot_account_balance.index = spot_account_balance.index + 'USDT'
+
+    spot_tickers = BinanceHelper.get_spot_asset_price(client)
+    spot_tickers['USDTUSDT'] = 1
+    spot_tickers = pd.Series(spot_tickers)
+    return (spot_tickers.loc[spot_account_balance.index.intersection(spot_tickers.index)] * spot_account_balance).sum()
+  
+  @staticmethod
+  def get_futures_balance(client):
+    
+    def list_select(list, key, value):
+      ret = [l for l in list if l[key] == value]
+      if len(ret) == 0:
+        return None
+      else:
+        return ret[0]
+      
+    # calculate futures balance
+    futures_position_information = retry(client.futures_position_information, 3)
+    future_account_balance = retry(client.futures_account_balance, 3)
+    futures_position_information = pd.DataFrame(futures_position_information).astype({'entryPrice': 'float', 'positionAmt':'float', 'unRealizedProfit':'float'})
+    futures_total_balance = futures_position_information.unRealizedProfit.sum()+float(list_select(future_account_balance, 'asset', 'USDT')['balance'])\
+      +float(list_select(future_account_balance, 'asset', 'BNB')['balance']) * BinanceHelper.get_futures_asset_price(client)['BNBUSDT']
+
+    return futures_total_balance
+  
+  @staticmethod
+  @cachetools.func.ttl_cache(ttl=60)
+  def get_spot_asset_price(client):
+      all_tickers = retry(client.get_all_tickers, 3)
+      all_ticker_price = {d['symbol']: Decimal(d['price']) for d in all_tickers}
+      return all_ticker_price
+  
+  @staticmethod
+  @cachetools.func.ttl_cache(ttl=60)
+  def get_futures_asset_price(client):
+    all_tickers = retry(client.futures_mark_price, 3)
+    all_ticker_price = {m['symbol']: Decimal(m['markPrice']) for m in all_tickers}
+    return all_ticker_price
+  
+  @staticmethod
+  def get_spot_position(client):
+    # spot balance
+    account = retry(client.get_account, 3)['balances']
+    spot_balance = {obj['asset']:Decimal(obj['free']) + Decimal(obj['locked']) for obj in account if Decimal(obj['free']) != 0}
+    return {k:v for k, v in spot_balance.items()}
+  
+  @staticmethod
+  def get_futures_position(client):
+
+    futures_balance = client.futures_position_information()
+    futures_balance = pd.DataFrame(futures_balance)\
+      .astype({'entryPrice': 'float', 'positionAmt':'float', 'unRealizedProfit':'float'})
+
+    futures_balance = futures_balance.loc[futures_balance.symbol.str[-4:] == 'USDT']
+    futures_balance.index = futures_balance.symbol.str[:-4]
+    futures_balance = futures_balance.positionAmt.to_dict()
+    return {k:v for k, v in futures_balance.items() if v != 0}
+
+
+class BinanceSimpleClient():
+
+  def __init__(self, client):
+    self.client = client
+    
+    futures_exchange_info = retry(client.futures_exchange_info, 3)
+    exchange_info = retry(client.get_exchange_info, 3)
+
+    if futures_exchange_info is None:
+        raise Exception('Cannot connect to binance client.futures_exchange_info')
+    
+    if exchange_info is None:
+        raise Exception('Cannot connect to binance client.exchange_info')
+
+    self.market_info = {
+      'FUTURES': pd.DataFrame(futures_exchange_info['symbols']).set_index('symbol'),
+      'SPOT': pd.DataFrame(exchange_info['symbols']).set_index('symbol'),
+    }
+
+  def round_price(self, symbol, price, round_up=False, market_type='SPOT'):
+    info = self.market_info[market_type]
+    ticksize = Decimal(self.list_select(info.loc[symbol].filters, 'filterType', 'PRICE_FILTER')['tickSize'])
+    #return round(int(price / ticksize) * ticksize, 9)
+    return round_step_size(price, ticksize, round_up=round_up)
+
+  def round_quantity(self, symbol, quantity, round_up=False, market_type='SPOT'):
+
+    info = self.market_info[market_type]
+    symbol_info = self.list_select(info.loc[symbol].filters, 'filterType', 'LOT_SIZE')
+    step_size = Decimal(symbol_info['stepSize'])
+    min_qty = Decimal(symbol_info['minQty'])
+    
+    sign = (quantity < 0) * -2 + 1
+    ret = sign * round_step_size(abs(quantity), step_size, round_up=round_up)
+    # ret = round(sign * (int((quantity-min_qty) / step_size) * step_size + min_qty), 9)
+    
+    if abs(ret) < min_qty:
+      ret = 0
+      
+    return ret
+  
+  @staticmethod
+  def list_select(list, key, value):
+    ret = [l for l in list if l[key] == value]
+    if len(ret) == 0:
+      return None
+    else:
+      return ret[0]
+
+  def pass_min_notional(self, symbol, quantity, market_type, price=None):
+    info = self.market_info[market_type]
+    notional = self.list_select(info.loc[symbol].filters, 'filterType', 'NOTIONAL')
+    min_notional = Decimal(notional.get('minNotional', notional.get('notional', 0)))
+    
+    present_price = price
+    if present_price is None:
+      if market_type == 'SPOT':
+        present_price = BinanceHelper.get_spot_asset_price(self.client)[symbol]
+      elif market_type == 'FUTURES':
+        present_price = BinanceHelper.get_futures_asset_price(self.client)[symbol]
+
+    if abs(quantity) * present_price < min_notional:
+        return False
+    return True
+
+  def create_order(self, symbol, quantity, market_type, price=None, stop_price=None):
+
+    if symbol == 'NBTUSDT':
+      return None
+
+    side = SIDE_BUY if quantity > 0 else SIDE_SELL
+
+    if stop_price is not None:
+        assert price is not None
+
+    ORDER_TYPE_STOP = 'STOP'
+
+    order_type = ORDER_TYPE_STOP if stop_price is not None else \
+        ORDER_TYPE_LIMIT if price is not None else ORDER_TYPE_MARKET
+
+    
+    if price is not None:
+      price = self.round_price(symbol, price, round_up=False, market_type=market_type)
+
+    if stop_price is not None:
+      stop_price = self.round_price(symbol, stop_price, round_up=False, market_type=market_type)
+
+    # recalculate amount according to step size
+    quantity = self.round_quantity(symbol, quantity, round_up=False, market_type=market_type)
+    icebergQty = self.round_quantity(symbol, quantity/Decimal('9.5'), round_up=False, market_type=market_type)
+
+    # check min invest value (notional)
+    
+    pass_notional = self.pass_min_notional(symbol, quantity, market_type=market_type, price=price)
+
+    min_notional_iceberg = 0.05 if symbol[-3:] == 'BTC' else 1000 if symbol[-4:] == 'USDT' else 1000
+
+    use_iceberg = (abs(quantity) * abs(price) > min_notional_iceberg) & (abs(icebergQty)*10 > abs(quantity))
+    
+    params = {
+      'side':side,
+      'type':order_type,
+      'symbol':symbol,
+      'quantity': format(abs(quantity), 'f') if isinstance(quantity, Decimal) else abs(quantity),
+    }
+    
+    if use_iceberg and market_type == 'SPOT' and icebergQty != 0:
+      params['icebergQty'] = format(abs(icebergQty), 'f') if isinstance(icebergQty, Decimal) else abs(icebergQty)
+
+    if market_type == 'FUTURES' and side == SIDE_BUY:
+      params['reduceOnly'] = 'true'
+
+    if price is not None:
+
+      precision = 8
+      price_str = '{:0.0{}f}'.format(price, precision)
+      params['price'] = price_str
+      params['timeInForce'] = 'GTC' #if order_type != ORDER_TYPE_LIMIT else 'GTX'
+
+    if stop_price is not None:
+      params['stopPrice'] = stop_price
+
+    if market_type == 'SPOT':
+      order_func = self.client.create_order
+    elif market_type == 'FUTURES':
+      order_func = self.client.futures_create_order
+    else:
+      raise Exception('market_type not in ["SPOT", "FUTURES"]')
+    
+    if (not pass_notional or quantity == 0) and 'reduceOnly' not in params:
+      return None
+
+    order = retry(order_func, 1, **params)
+
+    return order
+
+
+class BinanceAccount(Account):
+
+    def __init__(self, base_currency='USDT'):
+
+        if 'BINANCE_API_KEY' in os.environ:
+            key = os.environ['BINANCE_API_KEY']
+            secret = os.environ['BINANCE_API_SECRET']
+            self.simple_client = BinanceSimpleClient(client.Client(key, secret))
+        else:
+            self.simple_client = BinanceSimpleClient(client.Client())
+
+        self.threading = None
+        self.base_currency = base_currency
+
+    def create_order(self, action, stock_id, quantity, price=None, odd_lot=False, best_price_limit=False, market_order=False, order_cond=OrderCondition.CASH, extra_bid_pct=0) -> str:
+
+        if quantity <= 0:
+            raise ValueError("quantity should be larger than zero")
+
+        if best_price_limit and market_order:
+            raise ValueError(
+                "The flags best_price_limit and  market_order should not both be True")
+
+        if not market_order:
+            assert price is not None
+
+        if action == Action.SELL:
+            quantity = - abs(quantity)
+
+        # create_order(self, symbol, quantity, market_type, price=None, stop_price=None):
+
+        args = {
+            'symbol': stock_id+self.base_currency,
+            'quantity': quantity,
+            'market_type': 'SPOT',
+        }
+
+        if not market_order:
+            args['price'] = price
+        
+        order = self.simple_client.create_order(**args)
+
+        if not order or not 'orderId' in order:
+            print('client order not success')
+            return ''
+
+        return stock_id + '|' + str(order['orderId'])
+
+    def update_order(self, order_id, price=None, quantity=None):
+
+        stock_id, order_id = order_id.split('|')
+
+        if isinstance(price, int):
+            price = Decimal(price)
+
+        order = self.simple_client.client.get_order(symbol=stock_id, orderId=order_id)
+        self.simple_client.client.cancel_order(symbol=stock_id, orderId=order_id)
+
+        if quantity:
+          quantity = quantity - order['executedQty']
+        else:
+          quantity = (order['executedQty'] - order['origQty']) * ((order['side'] == 'BUY')*2 - 1)
+
+        self.simple_client.create_order(symbol=stock_id, quantity=quantity, price=price, market_type='SPOT')
+        return
+
+    def cancel_order(self, order_id):
+        stock_id, order_id = order_id.split('|')
+
+        try:
+            self.simple_client.client.cancel_order(symbol=stock_id, orderId=order_id)
+        except Exception as e:
+            logging.warning(f"cancel_order: Cannot cancel order {order_id}: {e}")
+
+    def get_orders(self):
+
+        orders = self.simple_client.client.get_open_orders()
+        ret = {}
+        for o in orders:
+            status = OrderStatus.NEW
+            if o['executedQty'] == 0:
+                status = OrderStatus.NEW
+            elif o['origQty'] != o['executedQty']:
+                status = 'Filling'
+                status = OrderStatus.PARTIALLY_FILLED
+            else:
+                status = OrderStatus.FILLED
+
+            if o['status'] == 'CANCELED':
+                status = OrderStatus.CANCEL
+
+            ret[str(o['symbol'])+'|'+str(o['orderId'])] = Order(order_id=o['orderId'], action=o['side'], price=o['price'], 
+                quantity=o['origQty'], filled_quantity=o['executedQty'], status=status, 
+                time=datetime.datetime.fromtimestamp(int(o['time'])/1000), 
+                stock_id=o['symbol'], order_condition=OrderCondition.CASH, org_order=o)
+        return ret
+
+    def get_stocks(self, stock_ids):
+
+        if not stock_ids:
+            return {}
+
+        ret = {}
+
+        all_symbols = set(t['symbol'] for t in self.simple_client.client.get_all_tickers())
+
+        symbols = '["'+ '","'.join([s+self.base_currency for s in stock_ids if s+self.base_currency in all_symbols]) + '"]'
+        tickers = self.simple_client.client.get_ticker(symbols=symbols)
+
+        for t in tickers:
+            asset = t['symbol'].replace(self.base_currency, '')
+            ret[asset] = Stock(stock_id=asset, open=Decimal(t['openPrice']), 
+                               high=Decimal(t['highPrice']), low=Decimal(t['lowPrice']), 
+                close=Decimal(t['lastPrice']), bid_price=Decimal(t['bidPrice']), bid_volume=Decimal(t['bidQty']), 
+                ask_price=Decimal(t['askPrice']), ask_volume=Decimal(t['askQty']))
+            
+        return ret
+
+    def get_position(self):
+        ret = BinanceHelper.get_spot_position(self.simple_client.client)
+        return Position.from_list([
+           {'stock_id': sym, 'quantity': amount, 'order_condition': OrderCondition.CASH} 
+           for sym, amount in ret.items()])
+        
+    def get_total_balance(self):
+        
+        return BinanceHelper.get_spot_balance(self.simple_client.client)
+
+    def support_day_trade_condition(self):
+        return True
+
+    def on_trades(self, func):
+        pass
+    
+    def sep_odd_lot_order(self):
+        return False
+
+    def get_cash(self):
+
+        position = self.get_position()
+        for p in position.position:
+            if p.stock_id == self.base_currency:
+                return p.quantity
+        return 0
+
+    def get_settlement(self):
+        return 0
+
```

## finlab/online/dashboard.py

 * *Ordering differences only*

```diff
@@ -1,229 +1,229 @@
-from finlab.online.order_executor import Position
-from finlab.online.order_executor import OrderExecutor
-import sched
-import time
-import finlab
-import threading
-import datetime
-import requests
-import pandas as pd
-from typing import List
-
-
-class Dashboard():
-
-    def __init__(self, acc, paper_trade=False, odd_lot=True, trade_in_advance=1800, price_update_period=300, *args, **kwargs):
-        self.acc = acc
-        self.paper_trade = paper_trade
-        self.odd_lot = odd_lot
-        self.thread_callback = None
-        self.thread_balancecheck = None
-        self.position = None
-        self.target_position = None
-        self.trade_in_advance = trade_in_advance
-        self.price_update_period = price_update_period
-
-        self.sched = sched.scheduler(time.time, time.sleep)
-        self.events = []
-        self.thread_sched = threading.Thread(target=self.running_sched)
-        self.thread_sched.start()
-
-        self.thread_update_price = threading.Thread(target=self.update_price)
-        if self.paper_trade:
-            self.thread_update_price.start()
-
-        self.record_txn_event()
-        self.args = args
-        self.kwargs = kwargs
-        self.oe = None
-
-    def running_sched(self):
-        while True:
-            time.sleep(3)
-            self.sched.run(blocking=True)
-
-    def update_price(self):
-        while True:
-            time.sleep(self.price_update_period)
-
-            if self.oe:
-                self.oe.update_order_price()
-
-    def fetch_portfolio(self):
-        url = 'https://asia-east2-fdata-299302.cloudfunctions.net/dashboard_get_portfolio'
-        return requests.post(url, json={'api_token': finlab.get_token()}).json()['msg']
-
-    def set_portfolio(self, allocs):
-        url = 'https://asia-east2-fdata-299302.cloudfunctions.net/dashboard_set_portfolio'
-        # url = 'http://127.0.0.1:8080'
-        return requests.post(url, json={
-            'api_token': finlab.get_token(),
-            'allocs': allocs,
-            }).json()['msg']
-
-    def get_present_qty(self):
-
-        # get present_qty
-        position = self.acc.get_position()
-        acc_position = pd.DataFrame(position.position).groupby(
-            'stock_id').sum() if len(position.position) > 0 else []
-
-        stocks = self.acc.get_stocks(acc_position.index.tolist())
-
-
-        if isinstance(acc_position, list):
-            present_qty = []
-        else:
-            present_qty = [{
-                'symbol': f'{stock_id}.tw_stock',
-                'price': stocks[stock_id].close,
-                'qty': row['quantity']
-            } for stock_id, row in acc_position.iterrows()]
-
-        return present_qty
-
-    def get_target_qty(self, port, sid) -> List:
-
-        if (sid not in port.strategy 
-            or len(port.strategy[sid]) == 0
-            or port.strategy[sid][-1].q is not None):
-            return []
-
-        s = port.strategy[sid][-1]
-
-        alloc = s['al']
-        weight = s['w']
-
-        # get price
-        stocks = self.acc.get_stocks(list(weight.keys()))
-        price = {sid:stock.close for sid, stock in stocks.items()}
-
-        position = Position.from_weight(weight, price=price, fund=alloc, odd_lot=self.odd_lot)
-
-        q = {}
-
-        for p in position.position:
-            q[p['stock_id']] = p['quantity']
-
-        target_qty = []
-
-        for p in position.position:
-            target_qty.append({
-                'symbol': p["stock_id"],
-                'qty': p['quantity'],
-                'strategy_id': sid
-            })
-
-        return target_qty
-
-    def set_qty(self, sid=None):
-        port = self.fetch_portfolio()
-
-        if sid is not None:
-
-            target_qty = self.get_target_qty(port, sid)
-            present_qty = self.get_present_qty() if not self.paper_trade else []
-
-            url = 'https://asia-east2-fdata-299302.cloudfunctions.net/dashboard_set_qty'
-            res = requests.post(url, json={
-                                'target_qty': target_qty, 'present_qty': present_qty,
-                                'api_token': finlab.get_token(), 'pt': self.paper_trade})
-        
-            for t in target_qty:
-                port.s[t['strategy_id']][-1].q[t['symbol']] = t['qty']
-
-        p = self.calc_target_position(port)
-
-        if not self.paper_trade:
-            self.oe = OrderExecutor(p, self.acc)
-            self.oe.create_orders(*self.args, **self.kwargs)
-        else:
-            stocks = self.acc.get_stocks([p['stock_id'].split('.')[0] for p in p.position])
-
-            present_qty = [{
-                'symbol': p['stock_id'],
-                'price': stocks[p['stock_id']].close,
-                'qty': p['quantity']
-            } for p in p.position]
-
-            # upload present and target qty
-            url = 'https://asia-east2-fdata-299302.cloudfunctions.net/dashboard_set_qty'
-            requests.post(url, json={
-                'target_qty': [], 'present_qty': present_qty,
-                'api_token': finlab.get_token(), 'pt': True})
- 
-
-    def set_schedule(self):
-
-        port = self.fetch_portfolio()
-
-        for e in self.events:
-            self.sched.cancel(e)
-        self.events = []
-
-        self.set_qty()
-
-        for sid, strategy in port['s'].items():
-            if strategy and strategy[-1]['q'] is None:
-                rebalance_time = datetime.datetime.fromisoformat(strategy[-1]['tb']) - datetime.timedelta(seconds=self.trade_in_advance)
-                print(time.time(), rebalance_time.timestamp())
-
-                print(strategy[-1]['tb'])
-                print(sid, rebalance_time)
-                secs = int(rebalance_time.timestamp())
-                self.events.append(self.sched.enter(secs, 1, self.set_qty, (sid,)))
-
-
-    def start(self):
-
-        while True:
-            self.set_schedule()
-            time.sleep(60)
-
-                
-    @staticmethod
-    def calc_target_position(port) -> Position:
-
-
-        ret = Position({})
-
-        for sid, strategy in port['s'].items():
-            sqty = {}
-
-            if len(strategy) == 0:
-                pass
-            elif strategy[-1]['q'] is not None:
-                sqty = strategy[-1]['q']
-            elif len(strategy) >= 2 and strategy[-2].q is not None:
-                sqty = strategy[-2]['q']
-
-            ret += Position(sqty)
-
-        return ret
-
-    def record_txn_event(self):
-
-        if self.acc.threading and self.acc.threading.is_alive():
-            return
-
-        def upload_trade(trade):
-
-            url = "https://asia-east2-fdata-299302.cloudfunctions.net/dashboard_add_txn"
-
-            json = {
-                "api_token": finlab.get_token(),
-                "pt": self.paper_trade,
-                "symbol": {
-                    "id": trade.stock_id,
-                    "market": "tw_stock",
-                },
-                "txn": {
-                    "price": trade.price,
-                    "qty": trade.filled_quantity,
-                    "time": trade.time,
-                }
-            }
-            requests.post(url, json=json)
-
-        self.acc.on_trades(upload_trade)
-
+from finlab.online.order_executor import Position
+from finlab.online.order_executor import OrderExecutor
+import sched
+import time
+import finlab
+import threading
+import datetime
+import requests
+import pandas as pd
+from typing import List
+
+
+class Dashboard():
+
+    def __init__(self, acc, paper_trade=False, odd_lot=True, trade_in_advance=1800, price_update_period=300, *args, **kwargs):
+        self.acc = acc
+        self.paper_trade = paper_trade
+        self.odd_lot = odd_lot
+        self.thread_callback = None
+        self.thread_balancecheck = None
+        self.position = None
+        self.target_position = None
+        self.trade_in_advance = trade_in_advance
+        self.price_update_period = price_update_period
+
+        self.sched = sched.scheduler(time.time, time.sleep)
+        self.events = []
+        self.thread_sched = threading.Thread(target=self.running_sched)
+        self.thread_sched.start()
+
+        self.thread_update_price = threading.Thread(target=self.update_price)
+        if self.paper_trade:
+            self.thread_update_price.start()
+
+        self.record_txn_event()
+        self.args = args
+        self.kwargs = kwargs
+        self.oe = None
+
+    def running_sched(self):
+        while True:
+            time.sleep(3)
+            self.sched.run(blocking=True)
+
+    def update_price(self):
+        while True:
+            time.sleep(self.price_update_period)
+
+            if self.oe:
+                self.oe.update_order_price()
+
+    def fetch_portfolio(self):
+        url = 'https://asia-east2-fdata-299302.cloudfunctions.net/dashboard_get_portfolio'
+        return requests.post(url, json={'api_token': finlab.get_token()}).json()['msg']
+
+    def set_portfolio(self, allocs):
+        url = 'https://asia-east2-fdata-299302.cloudfunctions.net/dashboard_set_portfolio'
+        # url = 'http://127.0.0.1:8080'
+        return requests.post(url, json={
+            'api_token': finlab.get_token(),
+            'allocs': allocs,
+            }).json()['msg']
+
+    def get_present_qty(self):
+
+        # get present_qty
+        position = self.acc.get_position()
+        acc_position = pd.DataFrame(position.position).groupby(
+            'stock_id').sum() if len(position.position) > 0 else []
+
+        stocks = self.acc.get_stocks(acc_position.index.tolist())
+
+
+        if isinstance(acc_position, list):
+            present_qty = []
+        else:
+            present_qty = [{
+                'symbol': f'{stock_id}.tw_stock',
+                'price': stocks[stock_id].close,
+                'qty': row['quantity']
+            } for stock_id, row in acc_position.iterrows()]
+
+        return present_qty
+
+    def get_target_qty(self, port, sid) -> List:
+
+        if (sid not in port.strategy 
+            or len(port.strategy[sid]) == 0
+            or port.strategy[sid][-1].q is not None):
+            return []
+
+        s = port.strategy[sid][-1]
+
+        alloc = s['al']
+        weight = s['w']
+
+        # get price
+        stocks = self.acc.get_stocks(list(weight.keys()))
+        price = {sid:stock.close for sid, stock in stocks.items()}
+
+        position = Position.from_weight(weight, price=price, fund=alloc, odd_lot=self.odd_lot)
+
+        q = {}
+
+        for p in position.position:
+            q[p['stock_id']] = p['quantity']
+
+        target_qty = []
+
+        for p in position.position:
+            target_qty.append({
+                'symbol': p["stock_id"],
+                'qty': p['quantity'],
+                'strategy_id': sid
+            })
+
+        return target_qty
+
+    def set_qty(self, sid=None):
+        port = self.fetch_portfolio()
+
+        if sid is not None:
+
+            target_qty = self.get_target_qty(port, sid)
+            present_qty = self.get_present_qty() if not self.paper_trade else []
+
+            url = 'https://asia-east2-fdata-299302.cloudfunctions.net/dashboard_set_qty'
+            res = requests.post(url, json={
+                                'target_qty': target_qty, 'present_qty': present_qty,
+                                'api_token': finlab.get_token(), 'pt': self.paper_trade})
+        
+            for t in target_qty:
+                port.s[t['strategy_id']][-1].q[t['symbol']] = t['qty']
+
+        p = self.calc_target_position(port)
+
+        if not self.paper_trade:
+            self.oe = OrderExecutor(p, self.acc)
+            self.oe.create_orders(*self.args, **self.kwargs)
+        else:
+            stocks = self.acc.get_stocks([p['stock_id'].split('.')[0] for p in p.position])
+
+            present_qty = [{
+                'symbol': p['stock_id'],
+                'price': stocks[p['stock_id']].close,
+                'qty': p['quantity']
+            } for p in p.position]
+
+            # upload present and target qty
+            url = 'https://asia-east2-fdata-299302.cloudfunctions.net/dashboard_set_qty'
+            requests.post(url, json={
+                'target_qty': [], 'present_qty': present_qty,
+                'api_token': finlab.get_token(), 'pt': True})
+ 
+
+    def set_schedule(self):
+
+        port = self.fetch_portfolio()
+
+        for e in self.events:
+            self.sched.cancel(e)
+        self.events = []
+
+        self.set_qty()
+
+        for sid, strategy in port['s'].items():
+            if strategy and strategy[-1]['q'] is None:
+                rebalance_time = datetime.datetime.fromisoformat(strategy[-1]['tb']) - datetime.timedelta(seconds=self.trade_in_advance)
+                print(time.time(), rebalance_time.timestamp())
+
+                print(strategy[-1]['tb'])
+                print(sid, rebalance_time)
+                secs = int(rebalance_time.timestamp())
+                self.events.append(self.sched.enter(secs, 1, self.set_qty, (sid,)))
+
+
+    def start(self):
+
+        while True:
+            self.set_schedule()
+            time.sleep(60)
+
+                
+    @staticmethod
+    def calc_target_position(port) -> Position:
+
+
+        ret = Position({})
+
+        for sid, strategy in port['s'].items():
+            sqty = {}
+
+            if len(strategy) == 0:
+                pass
+            elif strategy[-1]['q'] is not None:
+                sqty = strategy[-1]['q']
+            elif len(strategy) >= 2 and strategy[-2].q is not None:
+                sqty = strategy[-2]['q']
+
+            ret += Position(sqty)
+
+        return ret
+
+    def record_txn_event(self):
+
+        if self.acc.threading and self.acc.threading.is_alive():
+            return
+
+        def upload_trade(trade):
+
+            url = "https://asia-east2-fdata-299302.cloudfunctions.net/dashboard_add_txn"
+
+            json = {
+                "api_token": finlab.get_token(),
+                "pt": self.paper_trade,
+                "symbol": {
+                    "id": trade.stock_id,
+                    "market": "tw_stock",
+                },
+                "txn": {
+                    "price": trade.price,
+                    "qty": trade.filled_quantity,
+                    "time": trade.time,
+                }
+            }
+            requests.post(url, json=json)
+
+        self.acc.on_trades(upload_trade)
+
```

## finlab/online/enums.py

 * *Ordering differences only*

```diff
@@ -1,7 +1,7 @@
-from enum import IntEnum as Enum
-
-OrderStatus = Enum('OrderStatus', 'NEW PARTIALLY_FILLED FILLED CANCEL')
-
-Action = Enum('Action', 'BUY SELL')
-
-OrderCondition = Enum('OrderCondition', 'CASH MARGIN_TRADING SHORT_SELLING DAY_TRADING_LONG DAY_TRADING_SHORT')
+from enum import IntEnum as Enum
+
+OrderStatus = Enum('OrderStatus', 'NEW PARTIALLY_FILLED FILLED CANCEL')
+
+Action = Enum('Action', 'BUY SELL')
+
+OrderCondition = Enum('OrderCondition', 'CASH MARGIN_TRADING SHORT_SELLING DAY_TRADING_LONG DAY_TRADING_SHORT')
```

## finlab/online/fugle_account.py

 * *Ordering differences only*

```diff
@@ -1,377 +1,377 @@
-from configparser import ConfigParser
-from fugle_trade.sdk import SDK
-from fugle_trade.order import OrderObject
-from fugle_trade.constant import Action as fugleAction
-from fugle_trade.constant import (APCode, Trade, PriceFlag, BSFlag, Action)
-
-from finlab.online.base_account import Account, Stock, Order
-from finlab.online.enums import *
-from finlab.online.order_executor import calculate_price_with_extra_bid, Position
-from finlab import data
-
-from threading import Thread
-from decimal import Decimal
-import numpy as np
-import requests
-import datetime
-import logging
-import math
-import copy
-import time
-import os
-
-
-class FugleAccount(Account):
-
-    required_module = 'fugle_trade'
-    module_version = '0.4.0'
-
-    def __init__(self, config_path='./config.ini.example', market_api_key=None):
-
-        self.check_version()
-        self.market = 'tw_stock'
-
-        self.market_api_key = market_api_key
-
-        if 'FUGLE_CONFIG_PATH' in os.environ:
-            config_path = os.environ['FUGLE_CONFIG_PATH']
-
-        if 'FUGLE_MARKET_API_KEY' in os.environ:
-            market_api_key = os.environ['FUGLE_MARKET_API_KEY']
-
-        self.timestamp_for_get_position = datetime.datetime(2021, 1, 1)
-
-        # 讀取設定檔
-        config = ConfigParser()
-        config.read(config_path)
-        # 將設定檔內容寫至 SDK 中，並確認是否已設定密碼
-        if not os.path.isfile(config_path):
-            raise Exception('無法找到 config 檔案')
-
-        sdk = SDK(config)
-        sdk.login()
-        self.sdk = sdk
-
-        self.market_api_key = market_api_key
-
-        self.trades = {}
-        self.thread = None
-
-    def create_order(self, action, stock_id, quantity, price=None, odd_lot=False, best_price_limit=False, market_order=False, order_cond=OrderCondition.CASH):
-
-        if quantity <= 0:
-            raise ValueError("quantity should be larger than zero")
-
-        fugle_action = fugleAction.Buy if action == Action.BUY else fugleAction.Sell
-
-        price_flag = PriceFlag.Limit if price else PriceFlag.Flat
-
-        if market_order:
-            price = None
-            if action == Action.BUY:
-                price_flag = PriceFlag.LimitUp
-            elif action == Action.SELL:
-                price_flag = PriceFlag.LimitDown
-
-        elif best_price_limit:
-            price = None
-            if action == Action.BUY:
-                price_flag = PriceFlag.LimitDown
-            elif action == Action.SELL:
-                price_flag = PriceFlag.LimitUp
-
-
-        order_cond = {
-            OrderCondition.CASH: Trade.Cash,
-            OrderCondition.MARGIN_TRADING: Trade.Margin,
-            OrderCondition.SHORT_SELLING: Trade.Short,
-            # OrderCondition.DAY_TRADING_LONG: Trade.DayTrading,
-            OrderCondition.DAY_TRADING_SHORT: Trade.DayTradingSell,
-        }[order_cond]
-
-        ap_code = APCode.IntradayOdd if odd_lot else APCode.Common
-        now = datetime.datetime.utcnow() + datetime.timedelta(hours=8)
-        if datetime.time(13, 40) < datetime.time(now.hour, now.minute) and datetime.time(now.hour, now.minute) < datetime.time(14, 30) and odd_lot:
-            ap_code = APCode.Odd
-        if datetime.time(14, 00) < datetime.time(now.hour, now.minute) and datetime.time(now.hour, now.minute) < datetime.time(14, 30) and not odd_lot:
-            ap_code = APCode.AfterMarket
-            price_flag = PriceFlag.Limit
-
-        params = dict(
-            buy_sell=fugle_action,
-            stock_no=stock_id,
-            quantity=quantity,
-            ap_code=ap_code,
-            price_flag=price_flag,
-            trade=order_cond,
-            price=price
-        )
-
-        order = OrderObject(**params)
-
-        try:
-            ret = self.sdk.place_order(order)
-        except Exception as e:
-            logging.warning(
-                f"create_order: Cannot create order of {params}: {e}")
-            return
-
-        ord_no = ret['ord_no']
-        if ord_no == '':
-            ord_no = ret['pre_ord_no']
-        self.trades[ord_no] = ret
-        return ord_no
-
-    def update_order(self, order_id, price=None):
-
-        if isinstance(price, int):
-            price = float(price)
-
-        if order_id not in self.trades:
-            self.get_orders()
-
-        if order_id not in self.trades:
-            logging.warning(
-                f"update_order: Order id {order_id} not found, cannot update the price.")
-
-        if price is not None:
-            try:
-                if self.trades[order_id].org_order['ap_code'] == '5':
-                    fugle_order = self.trades[order_id].org_order
-                    action = Action.BUY if fugle_order['buy_sell'] == 'B' else Action.SELL
-                    stock_id = fugle_order['stock_no']
-                    q = fugle_order['org_qty_share'] - \
-                        fugle_order['mat_qty_share'] - \
-                        fugle_order['cel_qty_share']
-
-                    self.cancel_order(order_id)
-                    self.create_order(
-                        action=action, stock_id=stock_id, quantity=q, price=price, odd_lot=True)
-                else:
-                    self.sdk.modify_price(
-                        self.trades[order_id].org_order, price)
-            except ValueError as ve:
-                logging.warning(
-                    f"update_order: Cannot update price of order {order_id}: {ve}")
-
-
-    def cancel_order(self, order_id):
-        if not order_id in self.trades:
-            self.trades = self.get_orders()
-
-        try:
-            self.sdk.cancel_order(self.trades[order_id].org_order)
-        except Exception as e:
-            logging.warning(
-                f"cancel_order: Cannot cancel order {order_id}: {e}")
-
-    def get_orders(self):
-
-
-        success = False
-        fetch_count = 0
-
-        while not success:
-            try:
-                orders = self.sdk.get_order_results()
-                success = True
-            except:
-                logging.warning("get_orders: Cannot get orders, sleep for 1 minute")
-                fetch_count += 1
-                time.sleep(60)
-                if fetch_count > 5:
-                    logging.error("get_orders: Cannot get orders, try 5 times, raise error")
-                    raise Exception("Cannot get orders")
-
-        ret = {}
-        for o in orders:
-            order_id = o['ord_no']
-            if order_id == '':
-                order_id = o['pre_ord_no']
-
-            ret[order_id] = create_finlab_order(o)
-        self.trades = ret
-        return copy.deepcopy(ret)
-
-    def get_stocks(self, stock_ids):
-        ret = {}
-        for s in stock_ids:
-            try:
-                res = requests.get(
-                    f'https://api.fugle.tw/marketdata/v1.0/stock/intraday/quote/{s}',headers={'X-API-KEY': self.market_api_key})
-                json_response = res.json()
-                ret[s] = to_finlab_stock(json_response)
-
-                if math.isnan(ret[s].close):
-                    ret[s].close = json_response['previousClose']
-
-            except Exception as e:
-                logging.warn(f"Fugle API: cannot get stock {s}")
-                logging.warn(e)
-
-        return ret
-
-    def get_position(self):
-        order_condition = {
-            '0': OrderCondition.CASH,
-            '3': OrderCondition.MARGIN_TRADING,
-            '4': OrderCondition.SHORT_SELLING,
-            '9': OrderCondition.DAY_TRADING_LONG,
-            'A': OrderCondition.DAY_TRADING_SHORT,
-        }
-
-        now = datetime.datetime.now()
-
-        total_seconds = (now - self.timestamp_for_get_position).total_seconds()
-
-        if total_seconds < 10:
-            time.sleep(10)
-
-        inv = self.sdk.get_inventories()
-        self.timestamp_for_get_position = now
-
-        ret = []
-        for i in inv:
-
-            # removed: position of stk_dats is not completed
-            # total_qty = sum([int(d['qty']) for d in i['stk_dats']]) / 1000
-            total_qty = Decimal(int(i['qty_l']) +
-                         int(i['qty_bm']) - int(i['qty_sm'])) / 1000
-
-            o = order_condition[i['trade']]
-
-            if total_qty != 0:
-                ret.append({
-                    'stock_id': i['stk_no'],
-                    'quantity': total_qty if o != OrderCondition.SHORT_SELLING else -total_qty,
-                    'order_condition': order_condition[i['trade']]
-                })
-
-        return Position.from_list(ret)
-
-    def get_total_balance(self):
-        # get bank balance
-        bank_balance = self.get_cash()
-
-        # get settlements
-        settlements = self.get_settlement()
-
-        # get position balance
-        account_balance = sum(int(inv['value_mkt'])
-                              for inv in self.sdk.get_inventories())
-        return bank_balance + settlements + account_balance
-    
-    def get_cash(self):
-        return self.sdk.get_balance()['available_balance']
-    
-    def get_settlement(self):
-        tw_now = datetime.datetime.utcnow() + datetime.timedelta(hours=8)
-        settlements = self.sdk.get_settlements()
-        settlements = sum(int(settlement['price']) for settlement in settlements if datetime.datetime.strptime(
-            settlement['c_date'] + ' 10:00', '%Y%m%d %H:%M') > tw_now)
-        return settlements
-
-    def support_day_trade_condition(self):
-        return True
-
-    def on_trades(self, func):
-
-        order_condition = {
-            '0': OrderCondition.CASH,
-            '3': OrderCondition.MARGIN_TRADING,
-            '4': OrderCondition.SHORT_SELLING,
-            '9': OrderCondition.DAY_TRADING_LONG,
-            'A': OrderCondition.DAY_TRADING_SHORT,
-        }
-
-        @self.acc.sdk.on('dealt')
-        def on_dealt(data):
-            if isinstance(data, dict):
-                time = (datetime.datetime.strptime(f"{str((datetime.datetime.utcnow()+datetime.timedelta(hours=8)).date())} {data['mat_time']}", "%Y-%m-%d %H%M%S%f")-datetime.timedelta(
-                    hours=8)).replace(tzinfo=datetime.timezone(datetime.timedelta(hours=8))).isoformat()
-
-                o = Order(order_id=data['ord_no'], stock_id=data['stock_no'],
-                          action='BUY' if data['buy_sell'] == 'B' else 'SELL', price=data['mat_price'],
-                          quantity=data['mat_qty'], filled_quantity=data['mat_qty'],
-                          status='FILLED', order_condition=order_condition[data['trade']],
-                          time=time, org_order=None)
-
-                func(o)
-        self.threading = Thread(target=lambda: self.sdk.connect_websocket())
-
-    def sep_odd_lot_order(self):
-        return True
-
-    def get_price_info(self):
-        ref = data.get('reference_price')
-        return ref.set_index('stock_id').to_dict(orient='index')
-
-
-def create_finlab_order(order):
-    """將 fugle package 的委託單轉換成 finlab 格式"""
-
-    status = OrderStatus.NEW
-    if order['org_qty'] == order['mat_qty']:
-        status = OrderStatus.FILLED
-    elif order['mat_qty'] == 0 and order['celable'] == '1':
-        status = OrderStatus.NEW
-    elif order['org_qty'] > order['mat_qty'] + order['cel_qty'] and order['celable'] == '1' and order['mat_qty'] > 0:
-        status = OrderStatus.PARTIALLY_FILLED
-    elif order['cel_qty'] > 0 or order['err_code'] != '00000000' or order['celable'] == '2':
-        status = OrderStatus.CANCEL
-
-    order_condition = {
-        '0': OrderCondition.CASH,
-        '3': OrderCondition.MARGIN_TRADING,
-        '4': OrderCondition.SHORT_SELLING,
-        '9': OrderCondition.DAY_TRADING_LONG,
-        'A': OrderCondition.DAY_TRADING_SHORT,
-    }[order['trade']]
-
-    filled_quantity = order['mat_qty']
-
-    order_id = order['ord_no']
-    if order_id == '':
-        order_id = order['pre_ord_no']
-
-    return Order(**{
-        'order_id': order_id,
-        'stock_id': order['stock_no'],
-        'action': Action.BUY if order['buy_sell'] == 'B' else Action.SELL,
-        'price': order.get('od_price', order['avg_price']),
-        'quantity': order['org_qty'],
-        'filled_quantity': filled_quantity,
-        'status': status,
-        'order_condition': order_condition,
-        'time': datetime.datetime.strptime(order['ord_date'] + order['ord_time'], '%Y%m%d%H%M%S%f'),
-        'org_order': order
-    })
-
-
-def to_finlab_stock(json_response):
-    """將 fugle 股價行情轉換成 finlab 格式"""
-    r = json_response
-
-    if 'statusCode' in r:
-        raise Exception('Cannot parse fugle quote data' + str(r))
-
-    if 'bids' in r:
-        bids = r['bids']
-        asks = r['asks']
-    else:
-        bids = []
-        asks = []
-
-    has_volume = 'lastTrade' in r
-    return Stock(
-        stock_id=r['symbol'],
-        high=r['highPrice'] if has_volume else np.nan,
-        low=r['lowPrice'] if has_volume else np.nan,
-        close=r['closePrice'] if has_volume else np.nan,
-        open=r['openPrice'] if has_volume else np.nan,
-        bid_price=bids[0]['price'] if bids else np.nan,
-        ask_price=asks[0]['price'] if asks else np.nan,
-        bid_volume=bids[0]['size'] if bids else 0,
-        ask_volume=asks[0]['size'] if asks else 0,
-    )
-
+from configparser import ConfigParser
+from fugle_trade.sdk import SDK
+from fugle_trade.order import OrderObject
+from fugle_trade.constant import Action as fugleAction
+from fugle_trade.constant import (APCode, Trade, PriceFlag, BSFlag, Action)
+
+from finlab.online.base_account import Account, Stock, Order
+from finlab.online.enums import *
+from finlab.online.order_executor import calculate_price_with_extra_bid, Position
+from finlab import data
+
+from threading import Thread
+from decimal import Decimal
+import numpy as np
+import requests
+import datetime
+import logging
+import math
+import copy
+import time
+import os
+
+
+class FugleAccount(Account):
+
+    required_module = 'fugle_trade'
+    module_version = '0.4.0'
+
+    def __init__(self, config_path='./config.ini.example', market_api_key=None):
+
+        self.check_version()
+        self.market = 'tw_stock'
+
+        self.market_api_key = market_api_key
+
+        if 'FUGLE_CONFIG_PATH' in os.environ:
+            config_path = os.environ['FUGLE_CONFIG_PATH']
+
+        if 'FUGLE_MARKET_API_KEY' in os.environ:
+            market_api_key = os.environ['FUGLE_MARKET_API_KEY']
+
+        self.timestamp_for_get_position = datetime.datetime(2021, 1, 1)
+
+        # 讀取設定檔
+        config = ConfigParser()
+        config.read(config_path)
+        # 將設定檔內容寫至 SDK 中，並確認是否已設定密碼
+        if not os.path.isfile(config_path):
+            raise Exception('無法找到 config 檔案')
+
+        sdk = SDK(config)
+        sdk.login()
+        self.sdk = sdk
+
+        self.market_api_key = market_api_key
+
+        self.trades = {}
+        self.thread = None
+
+    def create_order(self, action, stock_id, quantity, price=None, odd_lot=False, best_price_limit=False, market_order=False, order_cond=OrderCondition.CASH):
+
+        if quantity <= 0:
+            raise ValueError("quantity should be larger than zero")
+
+        fugle_action = fugleAction.Buy if action == Action.BUY else fugleAction.Sell
+
+        price_flag = PriceFlag.Limit if price else PriceFlag.Flat
+
+        if market_order:
+            price = None
+            if action == Action.BUY:
+                price_flag = PriceFlag.LimitUp
+            elif action == Action.SELL:
+                price_flag = PriceFlag.LimitDown
+
+        elif best_price_limit:
+            price = None
+            if action == Action.BUY:
+                price_flag = PriceFlag.LimitDown
+            elif action == Action.SELL:
+                price_flag = PriceFlag.LimitUp
+
+
+        order_cond = {
+            OrderCondition.CASH: Trade.Cash,
+            OrderCondition.MARGIN_TRADING: Trade.Margin,
+            OrderCondition.SHORT_SELLING: Trade.Short,
+            # OrderCondition.DAY_TRADING_LONG: Trade.DayTrading,
+            OrderCondition.DAY_TRADING_SHORT: Trade.DayTradingSell,
+        }[order_cond]
+
+        ap_code = APCode.IntradayOdd if odd_lot else APCode.Common
+        now = datetime.datetime.utcnow() + datetime.timedelta(hours=8)
+        if datetime.time(13, 40) < datetime.time(now.hour, now.minute) and datetime.time(now.hour, now.minute) < datetime.time(14, 30) and odd_lot:
+            ap_code = APCode.Odd
+        if datetime.time(14, 00) < datetime.time(now.hour, now.minute) and datetime.time(now.hour, now.minute) < datetime.time(14, 30) and not odd_lot:
+            ap_code = APCode.AfterMarket
+            price_flag = PriceFlag.Limit
+
+        params = dict(
+            buy_sell=fugle_action,
+            stock_no=stock_id,
+            quantity=quantity,
+            ap_code=ap_code,
+            price_flag=price_flag,
+            trade=order_cond,
+            price=price
+        )
+
+        order = OrderObject(**params)
+
+        try:
+            ret = self.sdk.place_order(order)
+        except Exception as e:
+            logging.warning(
+                f"create_order: Cannot create order of {params}: {e}")
+            return
+
+        ord_no = ret['ord_no']
+        if ord_no == '':
+            ord_no = ret['pre_ord_no']
+        self.trades[ord_no] = ret
+        return ord_no
+
+    def update_order(self, order_id, price=None):
+
+        if isinstance(price, int):
+            price = float(price)
+
+        if order_id not in self.trades:
+            self.get_orders()
+
+        if order_id not in self.trades:
+            logging.warning(
+                f"update_order: Order id {order_id} not found, cannot update the price.")
+
+        if price is not None:
+            try:
+                if self.trades[order_id].org_order['ap_code'] == '5':
+                    fugle_order = self.trades[order_id].org_order
+                    action = Action.BUY if fugle_order['buy_sell'] == 'B' else Action.SELL
+                    stock_id = fugle_order['stock_no']
+                    q = fugle_order['org_qty_share'] - \
+                        fugle_order['mat_qty_share'] - \
+                        fugle_order['cel_qty_share']
+
+                    self.cancel_order(order_id)
+                    self.create_order(
+                        action=action, stock_id=stock_id, quantity=q, price=price, odd_lot=True)
+                else:
+                    self.sdk.modify_price(
+                        self.trades[order_id].org_order, price)
+            except ValueError as ve:
+                logging.warning(
+                    f"update_order: Cannot update price of order {order_id}: {ve}")
+
+
+    def cancel_order(self, order_id):
+        if not order_id in self.trades:
+            self.trades = self.get_orders()
+
+        try:
+            self.sdk.cancel_order(self.trades[order_id].org_order)
+        except Exception as e:
+            logging.warning(
+                f"cancel_order: Cannot cancel order {order_id}: {e}")
+
+    def get_orders(self):
+
+
+        success = False
+        fetch_count = 0
+
+        while not success:
+            try:
+                orders = self.sdk.get_order_results()
+                success = True
+            except:
+                logging.warning("get_orders: Cannot get orders, sleep for 1 minute")
+                fetch_count += 1
+                time.sleep(60)
+                if fetch_count > 5:
+                    logging.error("get_orders: Cannot get orders, try 5 times, raise error")
+                    raise Exception("Cannot get orders")
+
+        ret = {}
+        for o in orders:
+            order_id = o['ord_no']
+            if order_id == '':
+                order_id = o['pre_ord_no']
+
+            ret[order_id] = create_finlab_order(o)
+        self.trades = ret
+        return copy.deepcopy(ret)
+
+    def get_stocks(self, stock_ids):
+        ret = {}
+        for s in stock_ids:
+            try:
+                res = requests.get(
+                    f'https://api.fugle.tw/marketdata/v1.0/stock/intraday/quote/{s}',headers={'X-API-KEY': self.market_api_key})
+                json_response = res.json()
+                ret[s] = to_finlab_stock(json_response)
+
+                if math.isnan(ret[s].close):
+                    ret[s].close = json_response['previousClose']
+
+            except Exception as e:
+                logging.warn(f"Fugle API: cannot get stock {s}")
+                logging.warn(e)
+
+        return ret
+
+    def get_position(self):
+        order_condition = {
+            '0': OrderCondition.CASH,
+            '3': OrderCondition.MARGIN_TRADING,
+            '4': OrderCondition.SHORT_SELLING,
+            '9': OrderCondition.DAY_TRADING_LONG,
+            'A': OrderCondition.DAY_TRADING_SHORT,
+        }
+
+        now = datetime.datetime.now()
+
+        total_seconds = (now - self.timestamp_for_get_position).total_seconds()
+
+        if total_seconds < 10:
+            time.sleep(10)
+
+        inv = self.sdk.get_inventories()
+        self.timestamp_for_get_position = now
+
+        ret = []
+        for i in inv:
+
+            # removed: position of stk_dats is not completed
+            # total_qty = sum([int(d['qty']) for d in i['stk_dats']]) / 1000
+            total_qty = Decimal(int(i['qty_l']) +
+                         int(i['qty_bm']) - int(i['qty_sm'])) / 1000
+
+            o = order_condition[i['trade']]
+
+            if total_qty != 0:
+                ret.append({
+                    'stock_id': i['stk_no'],
+                    'quantity': total_qty if o != OrderCondition.SHORT_SELLING else -total_qty,
+                    'order_condition': order_condition[i['trade']]
+                })
+
+        return Position.from_list(ret)
+
+    def get_total_balance(self):
+        # get bank balance
+        bank_balance = self.get_cash()
+
+        # get settlements
+        settlements = self.get_settlement()
+
+        # get position balance
+        account_balance = sum(int(inv['value_mkt'])
+                              for inv in self.sdk.get_inventories())
+        return bank_balance + settlements + account_balance
+    
+    def get_cash(self):
+        return self.sdk.get_balance()['available_balance']
+    
+    def get_settlement(self):
+        tw_now = datetime.datetime.utcnow() + datetime.timedelta(hours=8)
+        settlements = self.sdk.get_settlements()
+        settlements = sum(int(settlement['price']) for settlement in settlements if datetime.datetime.strptime(
+            settlement['c_date'] + ' 10:00', '%Y%m%d %H:%M') > tw_now)
+        return settlements
+
+    def support_day_trade_condition(self):
+        return True
+
+    def on_trades(self, func):
+
+        order_condition = {
+            '0': OrderCondition.CASH,
+            '3': OrderCondition.MARGIN_TRADING,
+            '4': OrderCondition.SHORT_SELLING,
+            '9': OrderCondition.DAY_TRADING_LONG,
+            'A': OrderCondition.DAY_TRADING_SHORT,
+        }
+
+        @self.acc.sdk.on('dealt')
+        def on_dealt(data):
+            if isinstance(data, dict):
+                time = (datetime.datetime.strptime(f"{str((datetime.datetime.utcnow()+datetime.timedelta(hours=8)).date())} {data['mat_time']}", "%Y-%m-%d %H%M%S%f")-datetime.timedelta(
+                    hours=8)).replace(tzinfo=datetime.timezone(datetime.timedelta(hours=8))).isoformat()
+
+                o = Order(order_id=data['ord_no'], stock_id=data['stock_no'],
+                          action='BUY' if data['buy_sell'] == 'B' else 'SELL', price=data['mat_price'],
+                          quantity=data['mat_qty'], filled_quantity=data['mat_qty'],
+                          status='FILLED', order_condition=order_condition[data['trade']],
+                          time=time, org_order=None)
+
+                func(o)
+        self.threading = Thread(target=lambda: self.sdk.connect_websocket())
+
+    def sep_odd_lot_order(self):
+        return True
+
+    def get_price_info(self):
+        ref = data.get('reference_price')
+        return ref.set_index('stock_id').to_dict(orient='index')
+
+
+def create_finlab_order(order):
+    """將 fugle package 的委託單轉換成 finlab 格式"""
+
+    status = OrderStatus.NEW
+    if order['org_qty'] == order['mat_qty']:
+        status = OrderStatus.FILLED
+    elif order['mat_qty'] == 0 and order['celable'] == '1':
+        status = OrderStatus.NEW
+    elif order['org_qty'] > order['mat_qty'] + order['cel_qty'] and order['celable'] == '1' and order['mat_qty'] > 0:
+        status = OrderStatus.PARTIALLY_FILLED
+    elif order['cel_qty'] > 0 or order['err_code'] != '00000000' or order['celable'] == '2':
+        status = OrderStatus.CANCEL
+
+    order_condition = {
+        '0': OrderCondition.CASH,
+        '3': OrderCondition.MARGIN_TRADING,
+        '4': OrderCondition.SHORT_SELLING,
+        '9': OrderCondition.DAY_TRADING_LONG,
+        'A': OrderCondition.DAY_TRADING_SHORT,
+    }[order['trade']]
+
+    filled_quantity = order['mat_qty']
+
+    order_id = order['ord_no']
+    if order_id == '':
+        order_id = order['pre_ord_no']
+
+    return Order(**{
+        'order_id': order_id,
+        'stock_id': order['stock_no'],
+        'action': Action.BUY if order['buy_sell'] == 'B' else Action.SELL,
+        'price': order.get('od_price', order['avg_price']),
+        'quantity': order['org_qty'],
+        'filled_quantity': filled_quantity,
+        'status': status,
+        'order_condition': order_condition,
+        'time': datetime.datetime.strptime(order['ord_date'] + order['ord_time'], '%Y%m%d%H%M%S%f'),
+        'org_order': order
+    })
+
+
+def to_finlab_stock(json_response):
+    """將 fugle 股價行情轉換成 finlab 格式"""
+    r = json_response
+
+    if 'statusCode' in r:
+        raise Exception('Cannot parse fugle quote data' + str(r))
+
+    if 'bids' in r:
+        bids = r['bids']
+        asks = r['asks']
+    else:
+        bids = []
+        asks = []
+
+    has_volume = 'lastTrade' in r
+    return Stock(
+        stock_id=r['symbol'],
+        high=r['highPrice'] if has_volume else np.nan,
+        low=r['lowPrice'] if has_volume else np.nan,
+        close=r['closePrice'] if has_volume else np.nan,
+        open=r['openPrice'] if has_volume else np.nan,
+        bid_price=bids[0]['price'] if bids else np.nan,
+        ask_price=asks[0]['price'] if asks else np.nan,
+        bid_volume=bids[0]['size'] if bids else 0,
+        ask_volume=asks[0]['size'] if asks else 0,
+    )
+
```

## finlab/online/order_executor.py

 * *Ordering differences only*

```diff
@@ -1,708 +1,708 @@
-from finlab.online.utils import greedy_allocation
-from finlab.online.enums import *
-from finlab import data
-from decimal import Decimal
-import pandas as pd
-import requests
-import datetime
-import logging
-import numbers
-import json
-import copy
-import time
-import math
-
-logger = logging.getLogger(__name__)
-
-class Position():
-
-    """使用者可以利用 Position 輕鬆建構股票的部位，並且利用 OrderExecuter 將此部位同步於實際的股票帳戶。
-
-    """
-
-    def __init__(self, stocks, margin_trading=False, short_selling=False, day_trading_long=False, day_trading_short=False):
-        """建構股票部位
-
-        Attributes:
-            stocks (`dict` of `str`:`number.Number`): 股票代號與張數 ex: {'1101': 1} 是指持有一張 1101 台泥，可以接受負數，代表做空。
-            margin_trading (bool): 做多部位是否使用融資
-            short_selling (bool): 做空部位是否使用融券
-            day_trading_long (bool): 做多部位為當沖先做多
-            day_trading_short (bool): 做空部位為當沖先做空
-
-        Examples:
-            設計部位，持有一張和 100 股 1101
-            ```py
-            from finlab.online.order_executor import Position
-
-            Position({'1101': 1.1})
-            ```
-            output
-            ```json
-            [
-                {'stock_id': '1101',
-                 'quantity': 1.1,
-                 'order_condition': <OrderCondition.CASH: 1>
-                }
-            ]
-            ```
-
-            將兩個部位相加
-            ```py
-            from finlab.online.order_executor import Position
-
-            p1 = Position({'1101': 1})
-            p2 = Position({'2330': 1})
-            p1 + p2
-            ```
-            output
-            ```json
-            [
-                {'stock_id': '1101', 'quantity': 1.0, 'order_condition': <OrderCondition.CASH: 1>},
-                {'stock_id': '2330', 'quantity': 1.0, 'order_condition': <OrderCondition.CASH: 1>}
-            ]
-            ```
-        """
-        assert margin_trading + day_trading_long <= 1
-        assert short_selling + day_trading_short <= 1
-
-        long_order_condition = OrderCondition.CASH
-        short_order_condition = OrderCondition.CASH
-
-        if margin_trading:
-            long_order_condition = OrderCondition.MARGIN_TRADING
-        elif day_trading_long:
-            long_order_condition = OrderCondition.DAY_TRADING_LONG
-
-        if short_selling:
-            short_order_condition = OrderCondition.SHORT_SELLING
-        elif day_trading_short:
-            short_order_condition = OrderCondition.DAY_TRADING_SHORT
-
-        self.position = []
-        for s, a in stocks.items():
-            if a != 0:
-                self.position.append(
-                    {'stock_id': s, 'quantity': a, 'order_condition': long_order_condition if a > 0 else short_order_condition})
-
-    @classmethod
-    def from_list(cls, position):
-        """利用 `dict` 建構股票部位
-
-
-        Attributes:
-            position (`list` of `dict`): 股票詳細部位
-              ```py
-              from finlab.online.enums import OrderCondition
-              from finlab.online.order_executor import Position
-
-              Position.from_list(
-              [{
-                  'stock_id': '1101', # 股票代號
-                  'quantity': 1.1, # 張數
-                  'order_condition': OrderCondition.CASH # 現股融資融券、先買後賣
-              }])
-
-              ```
-
-              其中 OrderCondition 除了 `CASH` 外，還有 `MARGIN_TRADING`、`DAY_TRADING_LONG`、`SHORT_SELLING`、`DAY_TRADING_SHORT`。
-
-        """
-        ret = cls({})
-        ret.position = ret._format_quantity(position)
-        return ret
-    
-    def to_list(self):
-        ret = []
-
-        for p in self.position:
-            pp = p.copy()
-            if isinstance(pp['quantity'], Decimal):
-                pp['quantity'] = str(pp['quantity'])
-            ret.append(pp)
-
-        return ret
-
-    @classmethod
-    def from_dict(cls, position):
-
-        logger.warning('This method is renamed and will be deprecated.'
-             ' Please replace `Position.from_dict()` to `Position.from_list().`')
-
-        return cls.from_list(position)
-
-    @classmethod
-    def from_weight(cls, weights, fund, price=None, odd_lot=False, board_lot_size=1000, allocation=greedy_allocation, precision=None, **kwargs):
-        """利用 `weight` 建構股票部位
-
-        Attributes:
-            weights (`dict` of `float`): 股票詳細部位
-            fund (number.Number): 資金大小
-            price (pd.Series or `dict` of `float`): 股票代號對應到的價格，若無則使用最近個交易日的收盤價。
-            odd_lot (bool): 是否考慮零股
-            board_lot_size (int): 一張股票等於幾股
-            precision (int or None): 計算張數時的精度，預設為 None 代表依照 board_lot_size 而定，而 1 代表 0.1 張，2 代表 0.01 張，以此類推。
-            allocation (func): 資產配置演算法選定，預設為預設為`finlab.online.utils.greedy_allocation`（最大資金部屬貪婪法）
-            margin_trading (bool): 做多部位是否使用融資
-            short_selling (bool): 做空部位是否使用融券
-            day_trading_long (bool): 做多部位為當沖先做多
-            day_trading_short (bool): 做空部位為當沖先做空
-
-        Examples:
-              例如，用 100 萬的資金，全部投入，持有 1101 和 2330 各一半：
-              ```py
-              from finlab.online.order_executor import Position
-
-              Position.from_weight({
-                  '1101': 0.5,
-                  '2330': 0.5,
-              }, fund=1000000)
-
-              ```
-              output
-              ```
-              [
-                {'stock_id': '1101', 'quantity': 13, 'order_condition': <OrderCondition.CASH: 1>},
-                {'stock_id': '2330', 'quantity': 1, 'order_condition': <OrderCondition.CASH: 1>}
-              ]
-              ```
-        """
-
-        if precision != None and precision < 0:
-            raise ValueError("The precision parameter is out of the valid range >= 0")
-
-        if price is None:
-            price = data.get('reference_price').set_index('stock_id')['收盤價'].to_dict()
-
-        if isinstance(price, dict):
-            price = pd.Series(price)
-
-        if isinstance(weights, dict):
-            weights = pd.Series(weights)
-
-        if precision is not None and board_lot_size != 1:
-            logger.warning(
-                "The precision parameter is ignored when board_lot_size is not 1.")
-        
-        if precision is None:
-            precision = 0
-
-        if odd_lot:
-            if board_lot_size == 1000:
-                precision = max(3, precision)
-            elif board_lot_size == 100:
-                precision = max(2, precision)
-            elif board_lot_size == 10:
-                precision = max(1, precision)
-            elif board_lot_size == 1:
-                precision = max(0, precision)
-            else:
-                raise ValueError(
-                    "The board_lot_size parameter is out of the valid range 1, 10, 100, 1000")
-
-        multiple = 10**precision
-
-        allocation = greedy_allocation(
-            weights, price*board_lot_size, fund*multiple)[0]
-        
-        for s, q in allocation.items():
-            allocation[s] = Decimal(q) / multiple
-
-        if not odd_lot:
-            for s, q in allocation.items():
-                allocation[s] = round(q)
-
-        return cls(allocation, **kwargs)
-
-    @classmethod
-    def from_report(cls, report, fund, **kwargs):
-        """利用回測完的報告 `finlab.report.Report` 建構股票部位。
-
-        Attributes:
-            report (finlab.report.Report): 回測完的結果報告。
-            fund (int): 希望部屬的資金。
-            price (pd.Series or `dict` of `float`): 股票代號對應到的價格，若無則使用最近個交易日的收盤價。
-            odd_lot (bool): 是否考慮零股。預設為 False，只使用整張操作。
-            board_lot_size (int): 一張股票等於幾股。預設為1000，一張等於1000股。
-            allocation (func): 資產配置演算法選定，預設為`finlab.online.utils.greedy_allocation`（最大資金部屬貪婪法）。
-        !!! example
-            ```py
-            from finlab import backtest
-            from finlab.online.order_executor import Position
-
-            report1 = backtest.sim(...)
-            report2 = backtest.sim(...)
-
-            position1 = Position.from_report(report1, 1000000) # 策略操作金額一百萬
-            position2 = Position.from_report(report2, 1000000) # 策略操作金額一百萬
-
-            total_position = position1 + position2
-            ```
-        """
-
-        # next trading date arrived
-
-        if hasattr(report.market_info, 'market_close_at_timestamp'):
-            next_trading_time = report.market_info.market_close_at_timestamp(report.next_trading_date)
-        else:
-            # tw stock only
-            tz = datetime.timezone(datetime.timedelta(hours=8))
-            next_trading_time = report.next_trading_date.tz_localize(tz) + datetime.timedelta(hours=16)
-
-        now = datetime.datetime.now(tz=datetime.timezone.utc)
-
-        if now >= next_trading_time:
-            w = report.next_weights.copy()
-        else:
-            w = report.weights.copy()
-
-        ###################################
-        # handle stoploss and takeprofit
-        ###################################
-
-        is_sl_tp = report.actions.isin(['sl_', 'tp_','sl', 'tp'])
-
-        if sum(is_sl_tp):
-            exit_stocks = report.actions[is_sl_tp].index.intersection(w.index)
-            w.loc[exit_stocks] = 0
-
-        ######################################################
-        # handle exit now and enter in next trading date
-        ######################################################
-
-        is_exit_enter = report.actions.isin(['sl_enter', 'tp_enter'])
-        if sum(is_exit_enter) and now < next_trading_time:
-            exit_stocks = report.actions[is_exit_enter].index.intersection(w.index)
-            w.loc[exit_stocks] = 0
-
-        # todo: check if w.index is unique and remove this line if possible
-        w = w.groupby(w.index.tolist()).last()
-
-        if 'price' not in kwargs:
-            if hasattr(report.market_info, 'get_reference_price'):
-                price = report.market_info.get_reference_price()
-
-            else:
-                price = report.market_info.get_price('close', adj=False).iloc[-1].to_dict()
-
-            kwargs['price'] = price
-
-        if hasattr(report.market_info, 'get_board_lot_size'):
-            kwargs['board_lot_size'] = report.market_info.get_board_lot_size()
-        
-        # find w.index not in price.keys()
-        # import pdb; pdb.set_trace()
-        for s in w.index.tolist():
-            if s.split(' ')[0] not in kwargs['price'] or kwargs['price'][s.split(' ')[0]] != kwargs['price'][s.split(' ')[0]]:
-                w = w.drop(s)
-                logger.warning(f"Stock {s} is not in price data. It is dropped from the position.")
-
-        return cls.from_weight(w, fund, **kwargs)
-    
-
-    def to_json(self, path):
-        """
-        Converts the position dictionary to a JSON file and saves it to the specified path.
-        
-        Args:
-            path (str): The path where the JSON file will be saved.
-            
-        Returns:
-            None
-        """
-        
-        # Custom JSON Encoder that handles Decimal objects
-        class DecimalEncoder(json.JSONEncoder):
-            def default(self, obj):
-                if isinstance(obj, Decimal):
-                    return str(obj)  # Convert Decimal to string
-                # Let the base class default method raise the TypeError
-                return json.JSONEncoder.default(self, obj)
-            
-        with open(path, 'w') as f:
-            json.dump(self.position, f, cls=DecimalEncoder)
-
-
-    @staticmethod
-    def _format_quantity(position):
-
-        ret = []
-        for p in position:
-            pp = p.copy()
-            if isinstance(pp['quantity'], str):
-                pp['quantity'] = Decimal(pp['quantity'])
-            ret.append(pp)
-        return ret
-            
-    
-    @classmethod
-    def from_json(self, path):
-        """
-        Load a JSON file from the given path and convert it to a list of positions.
-        
-        Args:
-            path (str): The path to the JSON file.
-        
-        Returns:
-            None
-        """
-        
-        with open(path, 'r') as f:
-            ret = json.load(f)
-            ret = self._format_quantity(ret)
-
-        return Position.from_list(ret)
-
-            
-
-    def __add__(self, position):
-        return self.for_each_trading_condition(self.position, position.position, "+")
-
-    def __sub__(self, position):
-        return self.for_each_trading_condition(self.position, position.position, "-")
-
-    def sum_stock_quantity(self, stocks, oc):
-
-        qty = {}
-        for s in stocks:
-            if s['order_condition'] == oc:
-                q = qty.get(s['stock_id'], 0)
-                qty[s['stock_id']] = q + s['quantity']
-
-        return qty
-
-    def for_each_trading_condition(self, p1, p2, operator):
-        ret = []
-        for oc in [OrderCondition.CASH,
-                   OrderCondition.MARGIN_TRADING,
-                   OrderCondition.SHORT_SELLING,
-                   OrderCondition.DAY_TRADING_LONG,
-                   OrderCondition.DAY_TRADING_SHORT]:
-
-            qty1 = self.sum_stock_quantity(p1, oc)
-            qty2 = self.sum_stock_quantity(p2, oc)
-
-            # qty1 = {sobj['stock_id']: sobj['quantity']
-            #         for sobj in p1 if sobj['order_condition'] == oc}
-            # qty2 = {sobj['stock_id']: sobj['quantity']
-            #         for sobj in p2 if sobj['order_condition'] == oc}
-
-            ps = self.op(qty1, qty2, operator)
-            ret += [{'stock_id': sid, 'quantity': qty,
-                'order_condition': oc} for sid, qty in ps.items()]
-
-        return Position.from_list(ret)
-
-    @staticmethod
-    def op(position1, position2, operator):
-        # Create a set of unique keys from both dictionaries
-        keys = set(position1.keys()).union(position2.keys())
-        
-        # Initialize an empty result dictionary
-        result = {}
-        
-        for key in keys:
-            value1 = position1.get(key, 0)
-            value2 = position2.get(key, 0)
-
-            # convert to float if value1 or value2 is float or int
-            if (isinstance(value1, (float, int)) and value1 != 0)\
-                  or (isinstance(value2, (float, int)) and value2 != 0):
-                value1 = float(value1)
-                value2 = float(value2)
-            
-            if operator == "-":
-                result[key] = value1 - value2
-            elif operator == "+":
-                result[key] = value1 + value2
-        
-        # Remove entries with zero values
-        result = {k: v for k, v in result.items() if v != 0}
-        
-        return result
-
-    def fall_back_cash(self):
-        pos = []
-        for p in self.position:
-            pos.append({
-                'stock_id': p['stock_id'],
-                'quantity': p['quantity'],
-                'order_condition': OrderCondition.CASH if p['order_condition'] in [OrderCondition.DAY_TRADING_LONG, OrderCondition.DAY_TRADING_SHORT] else p['order_condition']
-            })
-        self.position = pos
-
-    def __repr__(self):
-        ret = ''
-        for p in self.position:
-            ret += str(p) + '\n'
-        return ret
-
-
-class OrderExecutor():
-
-    def __init__(
-            self, target_position, account):
-        """對比實際帳戶與欲部屬的股票部位，進行同步
-            Arguments:
-                target_position (Position): 想要部屬的股票部位。
-                account (Account): 目前支援永豐與富果帳戶，請參考 Account 來實做。
-        """
-
-        if isinstance(target_position, dict):
-            target_position = Position(target_position)
-
-        self.account = account
-        self.target_position = target_position
-
-    def show_alerting_stocks(self):
-        """產生下單部位是否有警示股，以及相關資訊"""
-
-        present_position = self.account.get_position()
-        new_orders = (self.target_position - present_position).position
-
-        stock_ids = [o['stock_id'] for o in new_orders]
-        quantity = {o['stock_id']: o['quantity'] for o in new_orders}
-
-        res = requests.get('https://www.sinotrade.com.tw/Stock/Stock_3_8_3')
-        dfs = pd.read_html(res.text)
-        credit_sids = dfs[0][dfs[0]['股票代碼'].astype(str).isin(stock_ids)]['股票代碼']
-
-        res = requests.get('https://www.sinotrade.com.tw/Stock/Stock_3_8_1')
-        dfs = pd.read_html(res.text)
-        credit_sids = pd.concat(
-            [credit_sids, dfs[0][dfs[0]['股票代碼'].astype(str).isin(stock_ids)]['股票代碼'].astype(str)])
-        credit_sids.name = None
-
-        if credit_sids.any():
-            close = data.get('price:收盤價').ffill().iloc[-1]
-            for sid in list(credit_sids.values):
-                if quantity[sid] > 0:
-                    total_amount = quantity[sid]*close[sid]*1000*1.1
-                    print(
-                        f"買入 {sid} {quantity[sid]:>5} 張 - 總價約 {total_amount:>15.2f}")
-                else:
-                    total_amount = quantity[sid]*close[sid]*1000*0.9
-                    print(
-                        f"賣出 {sid} {quantity[sid]:>5} 張 - 總價約 {total_amount:>15.2f}")
-
-    def cancel_orders(self):
-        """刪除所有未實現委託單"""
-        orders = self.account.get_orders()
-        for oid, o in orders.items():
-            if o.status == OrderStatus.NEW or o.status == OrderStatus.PARTIALLY_FILLED:
-                self.account.cancel_order(oid)
-
-    def generate_orders(self):
-        """
-        Generate orders based on the difference between target position and present position.
-        
-        Returns:
-        orders (dict): Orders to be executed.
-        """
-
-        target_position = Position.from_list(copy.copy(self.target_position.position))
-
-        if hasattr(self.account, 'base_currency'):
-            base_currency = self.account.base_currency
-            for pp in target_position.position:
-                if pp['stock_id'][-len(base_currency):] == base_currency:
-                    pp['stock_id'] = pp['stock_id'][:-len(base_currency)]
-                else:
-                    raise ValueError(f"Stock ID {pp['stock_id']} does not end with {base_currency}")
-
-        present_position = self.account.get_position()
-        orders = (target_position - present_position).position
-        return orders
-    
-    def execute_orders(self, orders, market_order=False, best_price_limit=False, view_only=False, extra_bid_pct=0):
-        """產生委託單，將部位同步成 self.target_position
-        預設以該商品最後一筆成交價設定為限價來下單
-        
-        Attributes:
-            orders (list): 欲下單的部位，通常是由 `self.generate_orders` 產生。
-            market_order (bool): 以類市價盡量即刻成交：所有買單掛漲停價，所有賣單掛跌停價
-            best_price_limit (bool): 掛芭樂價：所有買單掛跌停價，所有賣單掛漲停價
-            view_only (bool): 預設為 False，會實際下單。若設為 True，不會下單，只會回傳欲執行的委託單資料(dict)
-            extra_bid_pct (float): 以該百分比值乘以價格進行追價下單，如設定為 0.05 時，將以當前價的 +(-)5% 的限價進買入(賣出)，也就是更有機會可以成交，但是成交價格可能不理想；
-                假如設定為 -0.05 時，將以當前價的 -(+)5% 進行買入賣出，也就是限價單將不會立即成交，然而假如成交後，價格比較理想。參數有效範圍為 -0.1 到 0.1 內。
-        """
-
-        if [market_order, best_price_limit, bool(extra_bid_pct)].count(True) > 1:
-            raise ValueError("Only one of 'market_order', 'best_price_limit', or 'extra_bid_pct' can be set.")
-        if extra_bid_pct < -0.1 or extra_bid_pct > 0.1:
-            raise ValueError("The extra_bid_pct parameter is out of the valid range 0 to 0.1")
-
-        self.cancel_orders()
-        stocks = self.account.get_stocks(list({o['stock_id'] for o in orders}))
-
-        pinfo = None
-        if hasattr(self.account, 'get_price_info'):
-            pinfo = self.account.get_price_info()
-
-        # make orders
-        for o in orders:
-
-            if o['quantity'] == 0:
-                continue
-
-            if o['stock_id'] not in stocks:
-                logging.warning(o['stock_id'] + 'not in stocks... skipped!')
-                continue
-
-            stock = stocks[o['stock_id']]
-            action = Action.BUY if o['quantity'] > 0 else Action.SELL
-            price = stock.close if isinstance(stock.close, numbers.Number) else (
-                    stock.bid_price if action == Action.BUY else stock.ask_price
-                    )
-
-            if extra_bid_pct != 0:
-                price = calculate_price_with_extra_bid(price, extra_bid_pct if action == Action.BUY else -extra_bid_pct)
-
-            if pinfo and o['stock_id'] in pinfo:
-                limitup = float(pinfo[o['stock_id']]['漲停價'])
-                limitdn = float(pinfo[o['stock_id']]['跌停價'])
-                price = max(price, limitdn)
-                price = min(price, limitup)
-            else:
-                logger.warning('No price info for stock %s', o['stock_id'])
-
-            if isinstance(price, Decimal):
-                price = format(price, 'f')
-
-            if best_price_limit:
-                price_string = 'LOWEST' if action == Action.BUY else 'HIGHEST'
-            elif market_order:
-                price_string = 'HIGHEST' if action == Action.BUY else 'LOWEST'
-            else:
-                price_string = str(price)
-
-            extra_bid_text = ''
-            if extra_bid_pct > 0:
-                extra_bid_text = f'with extra bid {extra_bid_pct*100}%'
-
-            logger.warning('%-11s %-6s X %-10s @ %-11s %s %s', action, o['stock_id'], abs(o['quantity']), price_string, extra_bid_text, o['order_condition'])
-
-            quantity = abs(o['quantity'])
-            board_lot_quantity = int(abs(quantity // 1))
-            odd_lot_quantity = int(abs(round(1000 * (quantity % 1))))
-
-            if view_only:
-                continue
-
-            if self.account.sep_odd_lot_order():
-                if odd_lot_quantity != 0:
-                    self.account.create_order(action=action,
-                                              stock_id=o['stock_id'],
-                                              quantity=odd_lot_quantity,
-                                              price=price, market_order=market_order,
-                                              order_cond=o['order_condition'],
-                                              odd_lot=True,
-                                              best_price_limit=best_price_limit,
-                                              )
-
-                if board_lot_quantity != 0:
-                    self.account.create_order(action=action,
-                                              stock_id=o['stock_id'],
-                                              quantity=board_lot_quantity,
-                                              price=price, market_order=market_order,
-                                              order_cond=o['order_condition'],
-                                              best_price_limit=best_price_limit,
-                                              )
-            else:
-                self.account.create_order(action=action,
-                                          stock_id=o['stock_id'],
-                                          quantity=quantity,
-                                          price=price, market_order=market_order,
-                                          order_cond=o['order_condition'],
-                                          best_price_limit=best_price_limit,
-                                          )
-                
-        return orders
-        
-
-    def create_orders(self, market_order=False, best_price_limit=False, view_only=False, extra_bid_pct=0):
-        """產生委託單，將部位同步成 self.target_position
-        預設以該商品最後一筆成交價設定為限價來下單
-        
-        Attributes:
-            market_order (bool): 以類市價盡量即刻成交：所有買單掛漲停價，所有賣單掛跌停價
-            best_price_limit (bool): 掛芭樂價：所有買單掛跌停價，所有賣單掛漲停價
-            view_only (bool): 預設為 False，會實際下單。若設為 True，不會下單，只會回傳欲執行的委託單資料(dict)
-            extra_bid_pct (float): 以該百分比值乘以價格進行追價下單，如設定為 0.05 時，將以當前價的 +(-)5% 的限價進買入(賣出)，也就是更有機會可以成交，但是成交價格可能不理想；
-                假如設定為 -0.05 時，將以當前價的 -(+)5% 進行買入賣出，也就是限價單將不會立即成交，然而假如成交後，價格比較理想。參數有效範圍為 -0.1 到 0.1 內。
-        """
-
-        orders = self.generate_orders()
-        return self.execute_orders(orders, market_order, best_price_limit, view_only, extra_bid_pct)
-    
-    
-    def update_order_price(self, extra_bid_pct=0):
-        """更新委託單，將委託單的限價調整成當天最後一筆價格。
-        （讓沒成交的限價單去追價）
-        Attributes:
-            extra_bid_pct (float): 以該百分比值乘以價格進行追價下單，如設定為 0.1 時，將以超出(低於)現價之10%價格下單，以漲停(跌停)價為限。參數有效範圍為 0 到 0.1 內
-            """
-        if extra_bid_pct < -0.1 or extra_bid_pct > 0.1:
-            raise ValueError("The extra_bid_pct parameter is out of the valid range 0 to 0.1")
-        orders = self.account.get_orders()
-        sids = set([o.stock_id for i, o in orders.items()])
-        stocks = self.account.get_stocks(sids)
-
-        pinfo = None
-        if hasattr(self.account, 'get_price_info'):
-            pinfo = self.account.get_price_info()
-
-        for i, o in orders.items():
-            if o.status == OrderStatus.NEW or o.status == OrderStatus.PARTIALLY_FILLED:
-
-                price = stocks[o.stock_id].close
-                if extra_bid_pct > 0:
-
-                    price = calculate_price_with_extra_bid(price, extra_bid_pct if o.action == Action.BUY else -extra_bid_pct)
-
-                if pinfo and o.stock_id in pinfo:
-                    up_limit = float(pinfo[o.stock_id]['漲停價'])
-                    dn_limit = float(pinfo[o.stock_id]['跌停價'])
-                    price = max(price, dn_limit)
-                    price = min(price, up_limit)
-                else:
-                    logger.warning('No price info for stock %s', o.stock_id)
-
-                self.account.update_order(i, price=price)
-                
-
-def calculate_price_with_extra_bid(price, extra_bid_pct):
-
-    if extra_bid_pct == 0:
-        return price
-
-    if extra_bid_pct > 0:
-        result = price * (1 + extra_bid_pct)
-        if result <= 10:
-            result = math.floor(round(result, 3) * 100) / 100
-        elif result <= 50:
-            result = math.floor(result * 20) / 20
-        elif result <= 100:
-            result = math.floor(result * 10) / 10
-        elif result <= 500:
-            result = math.floor(result * 2) / 2
-        elif result <= 1000:
-            result = math.floor(result)
-        else:
-            result = math.floor(result / 5) * 5
-    else:
-        result = price * (1 + extra_bid_pct)
-        if result <= 10:
-            result = math.ceil(round(result, 3) * 100) / 100
-        elif result <= 50:
-            result = math.ceil(result * 20) / 20
-        elif result <= 100:
-            result = math.ceil(result * 10) / 10
-        elif result <= 500:
-            result = math.ceil(result * 2) / 2
-        elif result <= 1000:
-            result = math.ceil(result)
-        else:
-            result = math.ceil(result / 5) * 5
-
+from finlab.online.utils import greedy_allocation
+from finlab.online.enums import *
+from finlab import data
+from decimal import Decimal
+import pandas as pd
+import requests
+import datetime
+import logging
+import numbers
+import json
+import copy
+import time
+import math
+
+logger = logging.getLogger(__name__)
+
+class Position():
+
+    """使用者可以利用 Position 輕鬆建構股票的部位，並且利用 OrderExecuter 將此部位同步於實際的股票帳戶。
+
+    """
+
+    def __init__(self, stocks, margin_trading=False, short_selling=False, day_trading_long=False, day_trading_short=False):
+        """建構股票部位
+
+        Attributes:
+            stocks (`dict` of `str`:`number.Number`): 股票代號與張數 ex: {'1101': 1} 是指持有一張 1101 台泥，可以接受負數，代表做空。
+            margin_trading (bool): 做多部位是否使用融資
+            short_selling (bool): 做空部位是否使用融券
+            day_trading_long (bool): 做多部位為當沖先做多
+            day_trading_short (bool): 做空部位為當沖先做空
+
+        Examples:
+            設計部位，持有一張和 100 股 1101
+            ```py
+            from finlab.online.order_executor import Position
+
+            Position({'1101': 1.1})
+            ```
+            output
+            ```json
+            [
+                {'stock_id': '1101',
+                 'quantity': 1.1,
+                 'order_condition': <OrderCondition.CASH: 1>
+                }
+            ]
+            ```
+
+            將兩個部位相加
+            ```py
+            from finlab.online.order_executor import Position
+
+            p1 = Position({'1101': 1})
+            p2 = Position({'2330': 1})
+            p1 + p2
+            ```
+            output
+            ```json
+            [
+                {'stock_id': '1101', 'quantity': 1.0, 'order_condition': <OrderCondition.CASH: 1>},
+                {'stock_id': '2330', 'quantity': 1.0, 'order_condition': <OrderCondition.CASH: 1>}
+            ]
+            ```
+        """
+        assert margin_trading + day_trading_long <= 1
+        assert short_selling + day_trading_short <= 1
+
+        long_order_condition = OrderCondition.CASH
+        short_order_condition = OrderCondition.CASH
+
+        if margin_trading:
+            long_order_condition = OrderCondition.MARGIN_TRADING
+        elif day_trading_long:
+            long_order_condition = OrderCondition.DAY_TRADING_LONG
+
+        if short_selling:
+            short_order_condition = OrderCondition.SHORT_SELLING
+        elif day_trading_short:
+            short_order_condition = OrderCondition.DAY_TRADING_SHORT
+
+        self.position = []
+        for s, a in stocks.items():
+            if a != 0:
+                self.position.append(
+                    {'stock_id': s, 'quantity': a, 'order_condition': long_order_condition if a > 0 else short_order_condition})
+
+    @classmethod
+    def from_list(cls, position):
+        """利用 `dict` 建構股票部位
+
+
+        Attributes:
+            position (`list` of `dict`): 股票詳細部位
+              ```py
+              from finlab.online.enums import OrderCondition
+              from finlab.online.order_executor import Position
+
+              Position.from_list(
+              [{
+                  'stock_id': '1101', # 股票代號
+                  'quantity': 1.1, # 張數
+                  'order_condition': OrderCondition.CASH # 現股融資融券、先買後賣
+              }])
+
+              ```
+
+              其中 OrderCondition 除了 `CASH` 外，還有 `MARGIN_TRADING`、`DAY_TRADING_LONG`、`SHORT_SELLING`、`DAY_TRADING_SHORT`。
+
+        """
+        ret = cls({})
+        ret.position = ret._format_quantity(position)
+        return ret
+    
+    def to_list(self):
+        ret = []
+
+        for p in self.position:
+            pp = p.copy()
+            if isinstance(pp['quantity'], Decimal):
+                pp['quantity'] = str(pp['quantity'])
+            ret.append(pp)
+
+        return ret
+
+    @classmethod
+    def from_dict(cls, position):
+
+        logger.warning('This method is renamed and will be deprecated.'
+             ' Please replace `Position.from_dict()` to `Position.from_list().`')
+
+        return cls.from_list(position)
+
+    @classmethod
+    def from_weight(cls, weights, fund, price=None, odd_lot=False, board_lot_size=1000, allocation=greedy_allocation, precision=None, **kwargs):
+        """利用 `weight` 建構股票部位
+
+        Attributes:
+            weights (`dict` of `float`): 股票詳細部位
+            fund (number.Number): 資金大小
+            price (pd.Series or `dict` of `float`): 股票代號對應到的價格，若無則使用最近個交易日的收盤價。
+            odd_lot (bool): 是否考慮零股
+            board_lot_size (int): 一張股票等於幾股
+            precision (int or None): 計算張數時的精度，預設為 None 代表依照 board_lot_size 而定，而 1 代表 0.1 張，2 代表 0.01 張，以此類推。
+            allocation (func): 資產配置演算法選定，預設為預設為`finlab.online.utils.greedy_allocation`（最大資金部屬貪婪法）
+            margin_trading (bool): 做多部位是否使用融資
+            short_selling (bool): 做空部位是否使用融券
+            day_trading_long (bool): 做多部位為當沖先做多
+            day_trading_short (bool): 做空部位為當沖先做空
+
+        Examples:
+              例如，用 100 萬的資金，全部投入，持有 1101 和 2330 各一半：
+              ```py
+              from finlab.online.order_executor import Position
+
+              Position.from_weight({
+                  '1101': 0.5,
+                  '2330': 0.5,
+              }, fund=1000000)
+
+              ```
+              output
+              ```
+              [
+                {'stock_id': '1101', 'quantity': 13, 'order_condition': <OrderCondition.CASH: 1>},
+                {'stock_id': '2330', 'quantity': 1, 'order_condition': <OrderCondition.CASH: 1>}
+              ]
+              ```
+        """
+
+        if precision != None and precision < 0:
+            raise ValueError("The precision parameter is out of the valid range >= 0")
+
+        if price is None:
+            price = data.get('reference_price').set_index('stock_id')['收盤價'].to_dict()
+
+        if isinstance(price, dict):
+            price = pd.Series(price)
+
+        if isinstance(weights, dict):
+            weights = pd.Series(weights)
+
+        if precision is not None and board_lot_size != 1:
+            logger.warning(
+                "The precision parameter is ignored when board_lot_size is not 1.")
+        
+        if precision is None:
+            precision = 0
+
+        if odd_lot:
+            if board_lot_size == 1000:
+                precision = max(3, precision)
+            elif board_lot_size == 100:
+                precision = max(2, precision)
+            elif board_lot_size == 10:
+                precision = max(1, precision)
+            elif board_lot_size == 1:
+                precision = max(0, precision)
+            else:
+                raise ValueError(
+                    "The board_lot_size parameter is out of the valid range 1, 10, 100, 1000")
+
+        multiple = 10**precision
+
+        allocation = greedy_allocation(
+            weights, price*board_lot_size, fund*multiple)[0]
+        
+        for s, q in allocation.items():
+            allocation[s] = Decimal(q) / multiple
+
+        if not odd_lot:
+            for s, q in allocation.items():
+                allocation[s] = round(q)
+
+        return cls(allocation, **kwargs)
+
+    @classmethod
+    def from_report(cls, report, fund, **kwargs):
+        """利用回測完的報告 `finlab.report.Report` 建構股票部位。
+
+        Attributes:
+            report (finlab.report.Report): 回測完的結果報告。
+            fund (int): 希望部屬的資金。
+            price (pd.Series or `dict` of `float`): 股票代號對應到的價格，若無則使用最近個交易日的收盤價。
+            odd_lot (bool): 是否考慮零股。預設為 False，只使用整張操作。
+            board_lot_size (int): 一張股票等於幾股。預設為1000，一張等於1000股。
+            allocation (func): 資產配置演算法選定，預設為`finlab.online.utils.greedy_allocation`（最大資金部屬貪婪法）。
+        !!! example
+            ```py
+            from finlab import backtest
+            from finlab.online.order_executor import Position
+
+            report1 = backtest.sim(...)
+            report2 = backtest.sim(...)
+
+            position1 = Position.from_report(report1, 1000000) # 策略操作金額一百萬
+            position2 = Position.from_report(report2, 1000000) # 策略操作金額一百萬
+
+            total_position = position1 + position2
+            ```
+        """
+
+        # next trading date arrived
+
+        if hasattr(report.market_info, 'market_close_at_timestamp'):
+            next_trading_time = report.market_info.market_close_at_timestamp(report.next_trading_date)
+        else:
+            # tw stock only
+            tz = datetime.timezone(datetime.timedelta(hours=8))
+            next_trading_time = report.next_trading_date.tz_localize(tz) + datetime.timedelta(hours=16)
+
+        now = datetime.datetime.now(tz=datetime.timezone.utc)
+
+        if now >= next_trading_time:
+            w = report.next_weights.copy()
+        else:
+            w = report.weights.copy()
+
+        ###################################
+        # handle stoploss and takeprofit
+        ###################################
+
+        is_sl_tp = report.actions.isin(['sl_', 'tp_','sl', 'tp'])
+
+        if sum(is_sl_tp):
+            exit_stocks = report.actions[is_sl_tp].index.intersection(w.index)
+            w.loc[exit_stocks] = 0
+
+        ######################################################
+        # handle exit now and enter in next trading date
+        ######################################################
+
+        is_exit_enter = report.actions.isin(['sl_enter', 'tp_enter'])
+        if sum(is_exit_enter) and now < next_trading_time:
+            exit_stocks = report.actions[is_exit_enter].index.intersection(w.index)
+            w.loc[exit_stocks] = 0
+
+        # todo: check if w.index is unique and remove this line if possible
+        w = w.groupby(w.index.tolist()).last()
+
+        if 'price' not in kwargs:
+            if hasattr(report.market_info, 'get_reference_price'):
+                price = report.market_info.get_reference_price()
+
+            else:
+                price = report.market_info.get_price('close', adj=False).iloc[-1].to_dict()
+
+            kwargs['price'] = price
+
+        if hasattr(report.market_info, 'get_board_lot_size'):
+            kwargs['board_lot_size'] = report.market_info.get_board_lot_size()
+        
+        # find w.index not in price.keys()
+        # import pdb; pdb.set_trace()
+        for s in w.index.tolist():
+            if s.split(' ')[0] not in kwargs['price'] or kwargs['price'][s.split(' ')[0]] != kwargs['price'][s.split(' ')[0]]:
+                w = w.drop(s)
+                logger.warning(f"Stock {s} is not in price data. It is dropped from the position.")
+
+        return cls.from_weight(w, fund, **kwargs)
+    
+
+    def to_json(self, path):
+        """
+        Converts the position dictionary to a JSON file and saves it to the specified path.
+        
+        Args:
+            path (str): The path where the JSON file will be saved.
+            
+        Returns:
+            None
+        """
+        
+        # Custom JSON Encoder that handles Decimal objects
+        class DecimalEncoder(json.JSONEncoder):
+            def default(self, obj):
+                if isinstance(obj, Decimal):
+                    return str(obj)  # Convert Decimal to string
+                # Let the base class default method raise the TypeError
+                return json.JSONEncoder.default(self, obj)
+            
+        with open(path, 'w') as f:
+            json.dump(self.position, f, cls=DecimalEncoder)
+
+
+    @staticmethod
+    def _format_quantity(position):
+
+        ret = []
+        for p in position:
+            pp = p.copy()
+            if isinstance(pp['quantity'], str):
+                pp['quantity'] = Decimal(pp['quantity'])
+            ret.append(pp)
+        return ret
+            
+    
+    @classmethod
+    def from_json(self, path):
+        """
+        Load a JSON file from the given path and convert it to a list of positions.
+        
+        Args:
+            path (str): The path to the JSON file.
+        
+        Returns:
+            None
+        """
+        
+        with open(path, 'r') as f:
+            ret = json.load(f)
+            ret = self._format_quantity(ret)
+
+        return Position.from_list(ret)
+
+            
+
+    def __add__(self, position):
+        return self.for_each_trading_condition(self.position, position.position, "+")
+
+    def __sub__(self, position):
+        return self.for_each_trading_condition(self.position, position.position, "-")
+
+    def sum_stock_quantity(self, stocks, oc):
+
+        qty = {}
+        for s in stocks:
+            if s['order_condition'] == oc:
+                q = qty.get(s['stock_id'], 0)
+                qty[s['stock_id']] = q + s['quantity']
+
+        return qty
+
+    def for_each_trading_condition(self, p1, p2, operator):
+        ret = []
+        for oc in [OrderCondition.CASH,
+                   OrderCondition.MARGIN_TRADING,
+                   OrderCondition.SHORT_SELLING,
+                   OrderCondition.DAY_TRADING_LONG,
+                   OrderCondition.DAY_TRADING_SHORT]:
+
+            qty1 = self.sum_stock_quantity(p1, oc)
+            qty2 = self.sum_stock_quantity(p2, oc)
+
+            # qty1 = {sobj['stock_id']: sobj['quantity']
+            #         for sobj in p1 if sobj['order_condition'] == oc}
+            # qty2 = {sobj['stock_id']: sobj['quantity']
+            #         for sobj in p2 if sobj['order_condition'] == oc}
+
+            ps = self.op(qty1, qty2, operator)
+            ret += [{'stock_id': sid, 'quantity': qty,
+                'order_condition': oc} for sid, qty in ps.items()]
+
+        return Position.from_list(ret)
+
+    @staticmethod
+    def op(position1, position2, operator):
+        # Create a set of unique keys from both dictionaries
+        keys = set(position1.keys()).union(position2.keys())
+        
+        # Initialize an empty result dictionary
+        result = {}
+        
+        for key in keys:
+            value1 = position1.get(key, 0)
+            value2 = position2.get(key, 0)
+
+            # convert to float if value1 or value2 is float or int
+            if (isinstance(value1, (float, int)) and value1 != 0)\
+                  or (isinstance(value2, (float, int)) and value2 != 0):
+                value1 = float(value1)
+                value2 = float(value2)
+            
+            if operator == "-":
+                result[key] = value1 - value2
+            elif operator == "+":
+                result[key] = value1 + value2
+        
+        # Remove entries with zero values
+        result = {k: v for k, v in result.items() if v != 0}
+        
+        return result
+
+    def fall_back_cash(self):
+        pos = []
+        for p in self.position:
+            pos.append({
+                'stock_id': p['stock_id'],
+                'quantity': p['quantity'],
+                'order_condition': OrderCondition.CASH if p['order_condition'] in [OrderCondition.DAY_TRADING_LONG, OrderCondition.DAY_TRADING_SHORT] else p['order_condition']
+            })
+        self.position = pos
+
+    def __repr__(self):
+        ret = ''
+        for p in self.position:
+            ret += str(p) + '\n'
+        return ret
+
+
+class OrderExecutor():
+
+    def __init__(
+            self, target_position, account):
+        """對比實際帳戶與欲部屬的股票部位，進行同步
+            Arguments:
+                target_position (Position): 想要部屬的股票部位。
+                account (Account): 目前支援永豐與富果帳戶，請參考 Account 來實做。
+        """
+
+        if isinstance(target_position, dict):
+            target_position = Position(target_position)
+
+        self.account = account
+        self.target_position = target_position
+
+    def show_alerting_stocks(self):
+        """產生下單部位是否有警示股，以及相關資訊"""
+
+        present_position = self.account.get_position()
+        new_orders = (self.target_position - present_position).position
+
+        stock_ids = [o['stock_id'] for o in new_orders]
+        quantity = {o['stock_id']: o['quantity'] for o in new_orders}
+
+        res = requests.get('https://www.sinotrade.com.tw/Stock/Stock_3_8_3')
+        dfs = pd.read_html(res.text)
+        credit_sids = dfs[0][dfs[0]['股票代碼'].astype(str).isin(stock_ids)]['股票代碼']
+
+        res = requests.get('https://www.sinotrade.com.tw/Stock/Stock_3_8_1')
+        dfs = pd.read_html(res.text)
+        credit_sids = pd.concat(
+            [credit_sids, dfs[0][dfs[0]['股票代碼'].astype(str).isin(stock_ids)]['股票代碼'].astype(str)])
+        credit_sids.name = None
+
+        if credit_sids.any():
+            close = data.get('price:收盤價').ffill().iloc[-1]
+            for sid in list(credit_sids.values):
+                if quantity[sid] > 0:
+                    total_amount = quantity[sid]*close[sid]*1000*1.1
+                    print(
+                        f"買入 {sid} {quantity[sid]:>5} 張 - 總價約 {total_amount:>15.2f}")
+                else:
+                    total_amount = quantity[sid]*close[sid]*1000*0.9
+                    print(
+                        f"賣出 {sid} {quantity[sid]:>5} 張 - 總價約 {total_amount:>15.2f}")
+
+    def cancel_orders(self):
+        """刪除所有未實現委託單"""
+        orders = self.account.get_orders()
+        for oid, o in orders.items():
+            if o.status == OrderStatus.NEW or o.status == OrderStatus.PARTIALLY_FILLED:
+                self.account.cancel_order(oid)
+
+    def generate_orders(self):
+        """
+        Generate orders based on the difference between target position and present position.
+        
+        Returns:
+        orders (dict): Orders to be executed.
+        """
+
+        target_position = Position.from_list(copy.copy(self.target_position.position))
+
+        if hasattr(self.account, 'base_currency'):
+            base_currency = self.account.base_currency
+            for pp in target_position.position:
+                if pp['stock_id'][-len(base_currency):] == base_currency:
+                    pp['stock_id'] = pp['stock_id'][:-len(base_currency)]
+                else:
+                    raise ValueError(f"Stock ID {pp['stock_id']} does not end with {base_currency}")
+
+        present_position = self.account.get_position()
+        orders = (target_position - present_position).position
+        return orders
+    
+    def execute_orders(self, orders, market_order=False, best_price_limit=False, view_only=False, extra_bid_pct=0):
+        """產生委託單，將部位同步成 self.target_position
+        預設以該商品最後一筆成交價設定為限價來下單
+        
+        Attributes:
+            orders (list): 欲下單的部位，通常是由 `self.generate_orders` 產生。
+            market_order (bool): 以類市價盡量即刻成交：所有買單掛漲停價，所有賣單掛跌停價
+            best_price_limit (bool): 掛芭樂價：所有買單掛跌停價，所有賣單掛漲停價
+            view_only (bool): 預設為 False，會實際下單。若設為 True，不會下單，只會回傳欲執行的委託單資料(dict)
+            extra_bid_pct (float): 以該百分比值乘以價格進行追價下單，如設定為 0.05 時，將以當前價的 +(-)5% 的限價進買入(賣出)，也就是更有機會可以成交，但是成交價格可能不理想；
+                假如設定為 -0.05 時，將以當前價的 -(+)5% 進行買入賣出，也就是限價單將不會立即成交，然而假如成交後，價格比較理想。參數有效範圍為 -0.1 到 0.1 內。
+        """
+
+        if [market_order, best_price_limit, bool(extra_bid_pct)].count(True) > 1:
+            raise ValueError("Only one of 'market_order', 'best_price_limit', or 'extra_bid_pct' can be set.")
+        if extra_bid_pct < -0.1 or extra_bid_pct > 0.1:
+            raise ValueError("The extra_bid_pct parameter is out of the valid range 0 to 0.1")
+
+        self.cancel_orders()
+        stocks = self.account.get_stocks(list({o['stock_id'] for o in orders}))
+
+        pinfo = None
+        if hasattr(self.account, 'get_price_info'):
+            pinfo = self.account.get_price_info()
+
+        # make orders
+        for o in orders:
+
+            if o['quantity'] == 0:
+                continue
+
+            if o['stock_id'] not in stocks:
+                logging.warning(o['stock_id'] + 'not in stocks... skipped!')
+                continue
+
+            stock = stocks[o['stock_id']]
+            action = Action.BUY if o['quantity'] > 0 else Action.SELL
+            price = stock.close if isinstance(stock.close, numbers.Number) else (
+                    stock.bid_price if action == Action.BUY else stock.ask_price
+                    )
+
+            if extra_bid_pct != 0:
+                price = calculate_price_with_extra_bid(price, extra_bid_pct if action == Action.BUY else -extra_bid_pct)
+
+            if pinfo and o['stock_id'] in pinfo:
+                limitup = float(pinfo[o['stock_id']]['漲停價'])
+                limitdn = float(pinfo[o['stock_id']]['跌停價'])
+                price = max(price, limitdn)
+                price = min(price, limitup)
+            else:
+                logger.warning('No price info for stock %s', o['stock_id'])
+
+            if isinstance(price, Decimal):
+                price = format(price, 'f')
+
+            if best_price_limit:
+                price_string = 'LOWEST' if action == Action.BUY else 'HIGHEST'
+            elif market_order:
+                price_string = 'HIGHEST' if action == Action.BUY else 'LOWEST'
+            else:
+                price_string = str(price)
+
+            extra_bid_text = ''
+            if extra_bid_pct > 0:
+                extra_bid_text = f'with extra bid {extra_bid_pct*100}%'
+
+            logger.warning('%-11s %-6s X %-10s @ %-11s %s %s', action, o['stock_id'], abs(o['quantity']), price_string, extra_bid_text, o['order_condition'])
+
+            quantity = abs(o['quantity'])
+            board_lot_quantity = int(abs(quantity // 1))
+            odd_lot_quantity = int(abs(round(1000 * (quantity % 1))))
+
+            if view_only:
+                continue
+
+            if self.account.sep_odd_lot_order():
+                if odd_lot_quantity != 0:
+                    self.account.create_order(action=action,
+                                              stock_id=o['stock_id'],
+                                              quantity=odd_lot_quantity,
+                                              price=price, market_order=market_order,
+                                              order_cond=o['order_condition'],
+                                              odd_lot=True,
+                                              best_price_limit=best_price_limit,
+                                              )
+
+                if board_lot_quantity != 0:
+                    self.account.create_order(action=action,
+                                              stock_id=o['stock_id'],
+                                              quantity=board_lot_quantity,
+                                              price=price, market_order=market_order,
+                                              order_cond=o['order_condition'],
+                                              best_price_limit=best_price_limit,
+                                              )
+            else:
+                self.account.create_order(action=action,
+                                          stock_id=o['stock_id'],
+                                          quantity=quantity,
+                                          price=price, market_order=market_order,
+                                          order_cond=o['order_condition'],
+                                          best_price_limit=best_price_limit,
+                                          )
+                
+        return orders
+        
+
+    def create_orders(self, market_order=False, best_price_limit=False, view_only=False, extra_bid_pct=0):
+        """產生委託單，將部位同步成 self.target_position
+        預設以該商品最後一筆成交價設定為限價來下單
+        
+        Attributes:
+            market_order (bool): 以類市價盡量即刻成交：所有買單掛漲停價，所有賣單掛跌停價
+            best_price_limit (bool): 掛芭樂價：所有買單掛跌停價，所有賣單掛漲停價
+            view_only (bool): 預設為 False，會實際下單。若設為 True，不會下單，只會回傳欲執行的委託單資料(dict)
+            extra_bid_pct (float): 以該百分比值乘以價格進行追價下單，如設定為 0.05 時，將以當前價的 +(-)5% 的限價進買入(賣出)，也就是更有機會可以成交，但是成交價格可能不理想；
+                假如設定為 -0.05 時，將以當前價的 -(+)5% 進行買入賣出，也就是限價單將不會立即成交，然而假如成交後，價格比較理想。參數有效範圍為 -0.1 到 0.1 內。
+        """
+
+        orders = self.generate_orders()
+        return self.execute_orders(orders, market_order, best_price_limit, view_only, extra_bid_pct)
+    
+    
+    def update_order_price(self, extra_bid_pct=0):
+        """更新委託單，將委託單的限價調整成當天最後一筆價格。
+        （讓沒成交的限價單去追價）
+        Attributes:
+            extra_bid_pct (float): 以該百分比值乘以價格進行追價下單，如設定為 0.1 時，將以超出(低於)現價之10%價格下單，以漲停(跌停)價為限。參數有效範圍為 0 到 0.1 內
+            """
+        if extra_bid_pct < -0.1 or extra_bid_pct > 0.1:
+            raise ValueError("The extra_bid_pct parameter is out of the valid range 0 to 0.1")
+        orders = self.account.get_orders()
+        sids = set([o.stock_id for i, o in orders.items()])
+        stocks = self.account.get_stocks(sids)
+
+        pinfo = None
+        if hasattr(self.account, 'get_price_info'):
+            pinfo = self.account.get_price_info()
+
+        for i, o in orders.items():
+            if o.status == OrderStatus.NEW or o.status == OrderStatus.PARTIALLY_FILLED:
+
+                price = stocks[o.stock_id].close
+                if extra_bid_pct > 0:
+
+                    price = calculate_price_with_extra_bid(price, extra_bid_pct if o.action == Action.BUY else -extra_bid_pct)
+
+                if pinfo and o.stock_id in pinfo:
+                    up_limit = float(pinfo[o.stock_id]['漲停價'])
+                    dn_limit = float(pinfo[o.stock_id]['跌停價'])
+                    price = max(price, dn_limit)
+                    price = min(price, up_limit)
+                else:
+                    logger.warning('No price info for stock %s', o.stock_id)
+
+                self.account.update_order(i, price=price)
+                
+
+def calculate_price_with_extra_bid(price, extra_bid_pct):
+
+    if extra_bid_pct == 0:
+        return price
+
+    if extra_bid_pct > 0:
+        result = price * (1 + extra_bid_pct)
+        if result <= 10:
+            result = math.floor(round(result, 3) * 100) / 100
+        elif result <= 50:
+            result = math.floor(result * 20) / 20
+        elif result <= 100:
+            result = math.floor(result * 10) / 10
+        elif result <= 500:
+            result = math.floor(result * 2) / 2
+        elif result <= 1000:
+            result = math.floor(result)
+        else:
+            result = math.floor(result / 5) * 5
+    else:
+        result = price * (1 + extra_bid_pct)
+        if result <= 10:
+            result = math.ceil(round(result, 3) * 100) / 100
+        elif result <= 50:
+            result = math.ceil(result * 20) / 20
+        elif result <= 100:
+            result = math.ceil(result * 10) / 10
+        elif result <= 500:
+            result = math.ceil(result * 2) / 2
+        elif result <= 1000:
+            result = math.ceil(result)
+        else:
+            result = math.ceil(result / 5) * 5
+
     return result
```

## finlab/online/panel.py

 * *Ordering differences only*

```diff
@@ -1,340 +1,340 @@
-from finlab import data
-import time
-from finlab.online import enums
-from finlab.online.utils import greedy_allocation
-from finlab.online.order_executor import Position, OrderExecutor
-import copy
-import pandas as pd
-import ipywidgets as widgets
-from IPython.display import display
-from finlab.online import order_executor
-import imp
-imp.reload(order_executor)
-
-
-class StrategySelector(object):
-
-    def __init__(self, strategies):
-        self.out = widgets.Output(layout={'border': '1px solid gray'})
-        self.strategy_out = widgets.Output()
-        self.strategy_allocation = []
-        self.callback = None
-
-        snames = list(strategies.keys())
-        self.dropdown = widgets.Dropdown(
-            description='策略:',
-            options=snames,
-            value=snames[0],
-            disabled=False,
-        )
-        self.allocation = widgets.IntText(value=300000, description='金額:')
-
-        self.add_strategy_btn = widgets.Button(description='新增策略')
-        self.add_strategy_btn.on_click(lambda s: self.add_strategy())
-
-        form = widgets.HBox(
-            [self.dropdown, self.allocation, self.add_strategy_btn])
-        with self.out:
-            display(widgets.VBox(
-                [widgets.HTML('<h2>策略金額</h2>'), form, self.strategy_out]))
-
-    def update_strategy(self):
-
-        boxes = []
-        for i, (s, a) in enumerate(self.strategy_allocation):
-            cancel_btn = widgets.Button(description=f'刪除')
-            cancel_btn.ith = i
-            cancel_btn.on_click(lambda btn: self.cancel_strategy(btn.ith))
-            boxes.append(widgets.HBox(
-                [cancel_btn, widgets.Label(value=f'策略名稱：{s}，部位：{a} 元')]))
-
-        self.strategy_out.clear_output()
-        with self.strategy_out:
-            display(widgets.VBox(boxes))
-
-            if self.strategy_allocation:
-
-                label = widgets.Label(value='開始計算部位：')
-                btn1 = widgets.Button(description='整張')
-                btn2 = widgets.Button(description='含零股')
-                btn1.on_click(lambda btn: self.callback(self, odd_lot=False))
-                btn2.on_click(lambda btn: self.callback(self, odd_lot=True))
-                display(widgets.HBox([label, btn1, btn2]))
-
-    def add_strategy(self):
-        strategy = self.dropdown.value
-        allocation = self.allocation.value
-        self.strategy_allocation.append([strategy, allocation])
-
-        self.update_strategy()
-
-    def cancel_strategy(self, i):
-        self.strategy_allocation = self.strategy_allocation[:i] + \
-            self.strategy_allocation[i+1:]
-
-        self.update_strategy()
-
-    def set_callback(self, callback):
-        self.callback = callback
-
-
-class OrderPanel():
-
-    def __init__(self):
-        self.out = widgets.Output(layout={'border': '1px solid gray'})
-        self.out2 = widgets.Output(layout={'border': '1px solid gray'})
-        self.callback = None
-        self.oe = None
-        self.strategy_stocks = {}
-
-        with self.out:
-            display(widgets.HTML('<h2>確認部位</h2>'))
-
-        with self.out2:
-            display(widgets.HTML('<h2>委託部位</h2>'))
-
-    def set_position(self, *args, **kwargs):
-        self.oe = OrderExecutor(*args, **kwargs)
-        self.display_position(edit=True)
-
-    def set_strategy_stocks(self, strategy_stocks):
-        self.strategy_stocks = strategy_stocks
-
-    def display_position(self, edit=True):
-        target_position = self.oe.target_position
-        current_position = self.oe.account.get_position()
-
-        delta = target_position - current_position
-
-        stocks = self.oe.account.get_stocks(
-            [o['stock_id'] for o in delta.position])
-
-        grid = widgets.GridspecLayout(max(1, len(delta.position)), 5)
-
-        for i, o in enumerate(delta.position):
-            sid = o['stock_id']
-            org_quantity = self.get_quantity(
-                current_position.position, sid, o['order_condition'])
-            target_quantity = self.get_quantity(
-                target_position.position, sid, o['order_condition'])
-            strategies_with_sid = ", ".join(
-                [sname for sname, sids in self.strategy_stocks.items() if sid in sids])
-
-            grid[i, 0] = widgets.Label(value=sid)
-            grid[i, 1] = widgets.Label(value=f'原始張數: {org_quantity}')
-            grid[i, 2] = widgets.HBox([widgets.Label(value=f'目標張數:'), widgets.FloatText(
-                value=target_quantity, layout=widgets.Layout(width='60px'))])
-            grid[i, 3] = widgets.Label(
-                value=str(o['order_condition']).split('.')[-1])
-            grid[i, 4] = widgets.Label(value=strategies_with_sid)
-
-        def update_taget_position(market_order=False):
-            new_target_position = []
-            for i, o in enumerate(delta.position):
-
-                new_target_position.append({
-                    'stock_id': o['stock_id'],
-                    'quantity': grid[i, 2].children[1].value,
-                    'order_condition': o['order_condition'],
-                })
-            self.oe.target_position = Position.from_dict(new_target_position)
-            self.start_creating_order(market_order=market_order)
-
-        btn = widgets.Button(description='限價下單')
-        btn.on_click(lambda btn: update_taget_position(market_order=False))
-        btn2 = widgets.Button(description='市價下單')
-        btn2.on_click(lambda btn: update_taget_position(market_order=True))
-
-        self.out.clear_output()
-        with self.out:
-            display(widgets.HTML('<h2>確認部位</h2>'))
-            display(grid)
-            self.oe.show_alerting_stocks()
-
-            display(widgets.HBox([btn, btn2]))
-
-    @staticmethod
-    def get_quantity(position_list, stock_id, order_condition):
-        for o in position_list:
-            if o['stock_id'] == stock_id and o['order_condition'] == order_condition:
-                return o['quantity']
-        return 0
-
-    def start_creating_order(self, market_order):
-        with self.out:
-            try:
-                self.oe.create_orders(market_order)
-            except Exception as e:
-                print(e)
-                print('錯誤，即時取消所有下單')
-                self.oe.cancel_orders()
-                return
-
-        running = self.display_active_order()
-
-    def display_active_order(self):
-
-        orders = self.oe.account.get_orders()
-
-        active_orders = [o for oid, o in orders.items() if o.status not in [
-            enums.OrderStatus.CANCEL, enums.OrderStatus.FILLED]]
-        active_orders.sort(key=lambda o: o.stock_id)
-
-        def cancel_order_btn_func(btn):
-            self.oe.account.cancel_order(btn.oid)
-            self.display_active_order()
-
-        def update_price_btn_func(btn):
-            order = orders[btn.oid]
-            stock = self.oe.account.get_stocks(
-                [order.stock_id])[order.stock_id]
-            self.oe.account.update_order(btn.oid, price=stock.close)
-            self.display_active_order()
-
-        def buy_at_market_price_btn_func(btn):
-            self.oe.account.cancel_order(btn.oid)
-            order = self.oe.account.get_orders()[btn.oid]
-            new_quantity = (order.quantity - order.filled_quantity)
-            if new_quantity >= 1:
-                self.oe.account.create_order(
-                    order.action, order.stock_id, 1, order_cond=order.order_condition, market_order=True)
-                new_quantity -= 1
-
-            if new_quantity > 0:
-                self.oe.account.create_order(
-                    order.action, order.stock_id, new_quantity, order_cond=order.order_condition)
-
-            self.display_active_order()
-
-        def cancel_all_orders_func():
-            self.oe.cancel_orders()
-            self.display_active_order()
-
-        def update_order_price_func():
-            self.oe.update_order_price()
-            self.display_active_order()
-
-        grid = widgets.GridspecLayout(max(1, len(active_orders)), 1)
-
-        btn_recycle = widgets.Button(description='更新委託')
-        btn_recycle.on_click(lambda btn: self.display_active_order())
-
-        btn_cancel_all = widgets.Button(description='全部刪單')
-        btn_cancel_all.on_click(lambda btn: cancel_all_orders_func())
-
-        btn_update_price_all = widgets.Button(description='全部限價追價')
-        btn_update_price_all.on_click(lambda btn: update_order_price_func())
-
-        btns = widgets.HBox(
-            [btn_recycle, btn_update_price_all, btn_cancel_all])
-
-        for i, order in enumerate(active_orders):
-
-            s = f'股票代號 {order.stock_id}'
-            name_label = widgets.Label(
-                value=s, layout=widgets.Layout(width='300px'))
-            s = f'{str(order.action).split(".")[-1]} {order.filled_quantity} / {order.quantity}'
-
-            if order.price != 0:
-                s += f' @ {order.price}'
-
-            cancel_order_btn = widgets.Button(description='刪單')
-            cancel_order_btn.oid = order.order_id
-            cancel_order_btn.on_click(lambda btn: cancel_order_btn_func(btn))
-
-            limit_order_update_price_btn = widgets.Button(description='限價追價')
-            limit_order_update_price_btn.oid = order.order_id
-            limit_order_update_price_btn.on_click(
-                lambda btn: update_price_btn_func(btn))
-
-            buy_at_market_price_btn = widgets.Button(description='市價買一張')
-            buy_at_market_price_btn.oid = order.order_id
-            buy_at_market_price_btn.on_click(
-                lambda btn: buy_at_market_price_btn_func(btn))
-
-            grid[i, 0] = widgets.HBox([
-                name_label,
-                widgets.Label(value=s, layout=widgets.Layout(width='300px')),
-                widgets.Label(value=f"ID: {order.order_id}",
-                              layout=widgets.Layout(width='300px')),
-                cancel_order_btn,
-                limit_order_update_price_btn,
-                buy_at_market_price_btn
-            ])
-
-        keys = ['stock_id', 'action', 'price', 'quantity',
-                'filled_quantity', 'status', 'order_condition']
-        df = (pd.DataFrame({oid: {k: getattr(order, k) for k in keys} for oid, order in orders.items()}).transpose()
-              .pipe(lambda df: df[df.filled_quantity != 0])
-              )
-
-        self.out2.clear_output()
-        with self.out2:
-            display(btns)
-            display(grid)
-
-            if len(df):
-                display(df)
-
-        return len(active_orders) != 0
-
-
-def order_panel(account):
-    """下單 GUI 介面
-        Arguments:
-            account (Account): 請參考 Account 針對不同券商來建構相對應的操作帳戶
-    """
-
-    strategies = data.get_strategies()
-
-    def calc_position(allocations, odd_lot=False):
-
-        total_position = Position({})
-
-        for (strategy, allocation) in allocations:
-            p = strategies[strategy]['positions']
-            if 'position' in p:
-                p = p['position']
-
-            weights = {pname.split(' ')[0]: pp['next_weight']
-                       for pname, pp in p.items() if isinstance(pp, dict)}
-
-            price = account.get_price([s.split(' ')[0] for s in weights])
-
-            # s = account.get_stocks([s.split(' ')[0] for s in weights])
-            # price = {pname: s[pname].close for pname in weights}
-
-            # for sid, p in price.items():
-            #     if p == 0:
-            #         bid_price = s[sid].bid_price if s[sid].bid_price != 0 else s[sid].ask_price
-            #         ask_price = s[sid].ask_price if s[sid].ask_price != 0 else s[sid].bid_price
-            #         price[sid] = (bid_price + ask_price)/2
-
-            #     if price[sid] == 0:
-            #         raise Exception(
-            #             f"Stock {sid} has no price to reference. Use latest close of previous trading day")
-
-            position = Position.from_weight(
-                weights, allocation, price=price, odd_lot=odd_lot)
-            total_position += position
-
-        return total_position
-
-    ss = StrategySelector(strategies)
-    op = OrderPanel()
-
-    def position_check(strategy_selector,  odd_lot=False):
-        with strategy_selector.strategy_out:
-            pos = calc_position(strategy_selector.strategy_allocation, odd_lot)
-            strategy_stocks = {s: [i.split(' ')[0] for i in strategies[s]['positions'].keys()
-                                   if isinstance(strategies[s]['positions'][i], dict)]
-                               for (s, a) in strategy_selector.strategy_allocation}
-            op.set_strategy_stocks(strategy_stocks)
-            op.set_position(pos, account)
-
-    ss.set_callback(position_check)
-
-    display(ss.out)
-    display(op.out)
-    display(op.out2)
-    return {'strategy_selector': ss, 'order_panel': op}
+from finlab import data
+import time
+from finlab.online import enums
+from finlab.online.utils import greedy_allocation
+from finlab.online.order_executor import Position, OrderExecutor
+import copy
+import pandas as pd
+import ipywidgets as widgets
+from IPython.display import display
+from finlab.online import order_executor
+import imp
+imp.reload(order_executor)
+
+
+class StrategySelector(object):
+
+    def __init__(self, strategies):
+        self.out = widgets.Output(layout={'border': '1px solid gray'})
+        self.strategy_out = widgets.Output()
+        self.strategy_allocation = []
+        self.callback = None
+
+        snames = list(strategies.keys())
+        self.dropdown = widgets.Dropdown(
+            description='策略:',
+            options=snames,
+            value=snames[0],
+            disabled=False,
+        )
+        self.allocation = widgets.IntText(value=300000, description='金額:')
+
+        self.add_strategy_btn = widgets.Button(description='新增策略')
+        self.add_strategy_btn.on_click(lambda s: self.add_strategy())
+
+        form = widgets.HBox(
+            [self.dropdown, self.allocation, self.add_strategy_btn])
+        with self.out:
+            display(widgets.VBox(
+                [widgets.HTML('<h2>策略金額</h2>'), form, self.strategy_out]))
+
+    def update_strategy(self):
+
+        boxes = []
+        for i, (s, a) in enumerate(self.strategy_allocation):
+            cancel_btn = widgets.Button(description=f'刪除')
+            cancel_btn.ith = i
+            cancel_btn.on_click(lambda btn: self.cancel_strategy(btn.ith))
+            boxes.append(widgets.HBox(
+                [cancel_btn, widgets.Label(value=f'策略名稱：{s}，部位：{a} 元')]))
+
+        self.strategy_out.clear_output()
+        with self.strategy_out:
+            display(widgets.VBox(boxes))
+
+            if self.strategy_allocation:
+
+                label = widgets.Label(value='開始計算部位：')
+                btn1 = widgets.Button(description='整張')
+                btn2 = widgets.Button(description='含零股')
+                btn1.on_click(lambda btn: self.callback(self, odd_lot=False))
+                btn2.on_click(lambda btn: self.callback(self, odd_lot=True))
+                display(widgets.HBox([label, btn1, btn2]))
+
+    def add_strategy(self):
+        strategy = self.dropdown.value
+        allocation = self.allocation.value
+        self.strategy_allocation.append([strategy, allocation])
+
+        self.update_strategy()
+
+    def cancel_strategy(self, i):
+        self.strategy_allocation = self.strategy_allocation[:i] + \
+            self.strategy_allocation[i+1:]
+
+        self.update_strategy()
+
+    def set_callback(self, callback):
+        self.callback = callback
+
+
+class OrderPanel():
+
+    def __init__(self):
+        self.out = widgets.Output(layout={'border': '1px solid gray'})
+        self.out2 = widgets.Output(layout={'border': '1px solid gray'})
+        self.callback = None
+        self.oe = None
+        self.strategy_stocks = {}
+
+        with self.out:
+            display(widgets.HTML('<h2>確認部位</h2>'))
+
+        with self.out2:
+            display(widgets.HTML('<h2>委託部位</h2>'))
+
+    def set_position(self, *args, **kwargs):
+        self.oe = OrderExecutor(*args, **kwargs)
+        self.display_position(edit=True)
+
+    def set_strategy_stocks(self, strategy_stocks):
+        self.strategy_stocks = strategy_stocks
+
+    def display_position(self, edit=True):
+        target_position = self.oe.target_position
+        current_position = self.oe.account.get_position()
+
+        delta = target_position - current_position
+
+        stocks = self.oe.account.get_stocks(
+            [o['stock_id'] for o in delta.position])
+
+        grid = widgets.GridspecLayout(max(1, len(delta.position)), 5)
+
+        for i, o in enumerate(delta.position):
+            sid = o['stock_id']
+            org_quantity = self.get_quantity(
+                current_position.position, sid, o['order_condition'])
+            target_quantity = self.get_quantity(
+                target_position.position, sid, o['order_condition'])
+            strategies_with_sid = ", ".join(
+                [sname for sname, sids in self.strategy_stocks.items() if sid in sids])
+
+            grid[i, 0] = widgets.Label(value=sid)
+            grid[i, 1] = widgets.Label(value=f'原始張數: {org_quantity}')
+            grid[i, 2] = widgets.HBox([widgets.Label(value=f'目標張數:'), widgets.FloatText(
+                value=target_quantity, layout=widgets.Layout(width='60px'))])
+            grid[i, 3] = widgets.Label(
+                value=str(o['order_condition']).split('.')[-1])
+            grid[i, 4] = widgets.Label(value=strategies_with_sid)
+
+        def update_taget_position(market_order=False):
+            new_target_position = []
+            for i, o in enumerate(delta.position):
+
+                new_target_position.append({
+                    'stock_id': o['stock_id'],
+                    'quantity': grid[i, 2].children[1].value,
+                    'order_condition': o['order_condition'],
+                })
+            self.oe.target_position = Position.from_dict(new_target_position)
+            self.start_creating_order(market_order=market_order)
+
+        btn = widgets.Button(description='限價下單')
+        btn.on_click(lambda btn: update_taget_position(market_order=False))
+        btn2 = widgets.Button(description='市價下單')
+        btn2.on_click(lambda btn: update_taget_position(market_order=True))
+
+        self.out.clear_output()
+        with self.out:
+            display(widgets.HTML('<h2>確認部位</h2>'))
+            display(grid)
+            self.oe.show_alerting_stocks()
+
+            display(widgets.HBox([btn, btn2]))
+
+    @staticmethod
+    def get_quantity(position_list, stock_id, order_condition):
+        for o in position_list:
+            if o['stock_id'] == stock_id and o['order_condition'] == order_condition:
+                return o['quantity']
+        return 0
+
+    def start_creating_order(self, market_order):
+        with self.out:
+            try:
+                self.oe.create_orders(market_order)
+            except Exception as e:
+                print(e)
+                print('錯誤，即時取消所有下單')
+                self.oe.cancel_orders()
+                return
+
+        running = self.display_active_order()
+
+    def display_active_order(self):
+
+        orders = self.oe.account.get_orders()
+
+        active_orders = [o for oid, o in orders.items() if o.status not in [
+            enums.OrderStatus.CANCEL, enums.OrderStatus.FILLED]]
+        active_orders.sort(key=lambda o: o.stock_id)
+
+        def cancel_order_btn_func(btn):
+            self.oe.account.cancel_order(btn.oid)
+            self.display_active_order()
+
+        def update_price_btn_func(btn):
+            order = orders[btn.oid]
+            stock = self.oe.account.get_stocks(
+                [order.stock_id])[order.stock_id]
+            self.oe.account.update_order(btn.oid, price=stock.close)
+            self.display_active_order()
+
+        def buy_at_market_price_btn_func(btn):
+            self.oe.account.cancel_order(btn.oid)
+            order = self.oe.account.get_orders()[btn.oid]
+            new_quantity = (order.quantity - order.filled_quantity)
+            if new_quantity >= 1:
+                self.oe.account.create_order(
+                    order.action, order.stock_id, 1, order_cond=order.order_condition, market_order=True)
+                new_quantity -= 1
+
+            if new_quantity > 0:
+                self.oe.account.create_order(
+                    order.action, order.stock_id, new_quantity, order_cond=order.order_condition)
+
+            self.display_active_order()
+
+        def cancel_all_orders_func():
+            self.oe.cancel_orders()
+            self.display_active_order()
+
+        def update_order_price_func():
+            self.oe.update_order_price()
+            self.display_active_order()
+
+        grid = widgets.GridspecLayout(max(1, len(active_orders)), 1)
+
+        btn_recycle = widgets.Button(description='更新委託')
+        btn_recycle.on_click(lambda btn: self.display_active_order())
+
+        btn_cancel_all = widgets.Button(description='全部刪單')
+        btn_cancel_all.on_click(lambda btn: cancel_all_orders_func())
+
+        btn_update_price_all = widgets.Button(description='全部限價追價')
+        btn_update_price_all.on_click(lambda btn: update_order_price_func())
+
+        btns = widgets.HBox(
+            [btn_recycle, btn_update_price_all, btn_cancel_all])
+
+        for i, order in enumerate(active_orders):
+
+            s = f'股票代號 {order.stock_id}'
+            name_label = widgets.Label(
+                value=s, layout=widgets.Layout(width='300px'))
+            s = f'{str(order.action).split(".")[-1]} {order.filled_quantity} / {order.quantity}'
+
+            if order.price != 0:
+                s += f' @ {order.price}'
+
+            cancel_order_btn = widgets.Button(description='刪單')
+            cancel_order_btn.oid = order.order_id
+            cancel_order_btn.on_click(lambda btn: cancel_order_btn_func(btn))
+
+            limit_order_update_price_btn = widgets.Button(description='限價追價')
+            limit_order_update_price_btn.oid = order.order_id
+            limit_order_update_price_btn.on_click(
+                lambda btn: update_price_btn_func(btn))
+
+            buy_at_market_price_btn = widgets.Button(description='市價買一張')
+            buy_at_market_price_btn.oid = order.order_id
+            buy_at_market_price_btn.on_click(
+                lambda btn: buy_at_market_price_btn_func(btn))
+
+            grid[i, 0] = widgets.HBox([
+                name_label,
+                widgets.Label(value=s, layout=widgets.Layout(width='300px')),
+                widgets.Label(value=f"ID: {order.order_id}",
+                              layout=widgets.Layout(width='300px')),
+                cancel_order_btn,
+                limit_order_update_price_btn,
+                buy_at_market_price_btn
+            ])
+
+        keys = ['stock_id', 'action', 'price', 'quantity',
+                'filled_quantity', 'status', 'order_condition']
+        df = (pd.DataFrame({oid: {k: getattr(order, k) for k in keys} for oid, order in orders.items()}).transpose()
+              .pipe(lambda df: df[df.filled_quantity != 0])
+              )
+
+        self.out2.clear_output()
+        with self.out2:
+            display(btns)
+            display(grid)
+
+            if len(df):
+                display(df)
+
+        return len(active_orders) != 0
+
+
+def order_panel(account):
+    """下單 GUI 介面
+        Arguments:
+            account (Account): 請參考 Account 針對不同券商來建構相對應的操作帳戶
+    """
+
+    strategies = data.get_strategies()
+
+    def calc_position(allocations, odd_lot=False):
+
+        total_position = Position({})
+
+        for (strategy, allocation) in allocations:
+            p = strategies[strategy]['positions']
+            if 'position' in p:
+                p = p['position']
+
+            weights = {pname.split(' ')[0]: pp['next_weight']
+                       for pname, pp in p.items() if isinstance(pp, dict)}
+
+            price = account.get_price([s.split(' ')[0] for s in weights])
+
+            # s = account.get_stocks([s.split(' ')[0] for s in weights])
+            # price = {pname: s[pname].close for pname in weights}
+
+            # for sid, p in price.items():
+            #     if p == 0:
+            #         bid_price = s[sid].bid_price if s[sid].bid_price != 0 else s[sid].ask_price
+            #         ask_price = s[sid].ask_price if s[sid].ask_price != 0 else s[sid].bid_price
+            #         price[sid] = (bid_price + ask_price)/2
+
+            #     if price[sid] == 0:
+            #         raise Exception(
+            #             f"Stock {sid} has no price to reference. Use latest close of previous trading day")
+
+            position = Position.from_weight(
+                weights, allocation, price=price, odd_lot=odd_lot)
+            total_position += position
+
+        return total_position
+
+    ss = StrategySelector(strategies)
+    op = OrderPanel()
+
+    def position_check(strategy_selector,  odd_lot=False):
+        with strategy_selector.strategy_out:
+            pos = calc_position(strategy_selector.strategy_allocation, odd_lot)
+            strategy_stocks = {s: [i.split(' ')[0] for i in strategies[s]['positions'].keys()
+                                   if isinstance(strategies[s]['positions'][i], dict)]
+                               for (s, a) in strategy_selector.strategy_allocation}
+            op.set_strategy_stocks(strategy_stocks)
+            op.set_position(pos, account)
+
+    ss.set_callback(position_check)
+
+    display(ss.out)
+    display(op.out)
+    display(op.out2)
+    return {'strategy_selector': ss, 'order_panel': op}
```

## finlab/online/sinopac_account.py

 * *Ordering differences only*

```diff
@@ -1,270 +1,270 @@
-import shioaji as sj
-import datetime
-import time
-import os
-import re
-import math
-import logging
-from decimal import Decimal
-
-from finlab.online.base_account import Account, Stock, Order
-from finlab.online.enums import *
-from finlab.online.order_executor import Position
-from finlab import data
-
-pattern = re.compile(r'(?<!^)(?=[A-Z])')
-
-
-class SinopacAccount(Account):
-
-    required_module = 'shioaji'
-    module_version = '1.1.2'
-
-    def __init__(self, api_key=None, secret_key=None, 
-                 certificate_person_id=None, 
-                 certificate_password=None, 
-                 certificate_path=None):
-
-        api_key = api_key or os.environ.get('SHIOAJI_API_KEY')
-        secret_key = secret_key or os.environ.get('SHIOAJI_SECRET_KEY')
-
-        certificate_password = certificate_password or os.environ.get(
-            'SHIOAJI_CERT_PASSWORD')
-        certificate_path = certificate_path or os.environ.get(
-                'SHIOAJI_CERT_PATH')
-        certificate_person_id = certificate_person_id or os.environ.get(
-                'SHIOAJI_CERT_PERSON_ID')
-
-        self.api = sj.Shioaji()
-        self.accounts = self.api.login(api_key, secret_key, fetch_contract=False)
-
-        self.trades = {}
-
-        self.api.activate_ca(
-            ca_path=certificate_path,
-            ca_passwd=certificate_password,
-            person_id=certificate_person_id,
-        )
-
-    def create_order(self, action, stock_id, quantity, price=None, odd_lot=False, market_order=False, best_price_limit=False, order_cond=OrderCondition.CASH):
-
-        # contract = self.api.Contracts.Stocks.get(stock_id)
-        contract = sj.contracts.Contract(security_type='STK', code=stock_id, exchange='TSE')
-        pinfo = self.get_price_info()
-        limitup = float(pinfo[stock_id]['漲停價'])
-        limitdn = float(pinfo[stock_id]['跌停價'])
-        last_close = float(pinfo[stock_id]['收盤價'])
-
-        if stock_id not in pinfo:
-            raise Exception(f"stock {stock_id} not in price info")
-        
-        if quantity <= 0:
-            raise Exception(f"quantity must be positive, got {quantity}")
-
-        if price == None:
-            price = self.api.snapshots([contract])[0].close
-
-        price_type = sj.constant.StockPriceType.LMT
-
-        if market_order:
-            if action == Action.BUY:
-                price = limitup
-            elif action == Action.SELL:
-                price = limitdn
-
-        elif best_price_limit:
-            if action == Action.BUY:
-                price = limitdn
-            elif action == Action.SELL:
-                price = limitup
-
-        if action == Action.BUY:
-            action = 'Buy'
-        elif action == Action.SELL:
-            action = 'Sell'
-
-        daytrade_short = order_cond == OrderCondition.DAY_TRADING_SHORT
-        daytrade_short = True if daytrade_short else False
-
-        order_cond = {
-            OrderCondition.CASH: 'Cash',
-            OrderCondition.MARGIN_TRADING: 'MarginTrading',
-            OrderCondition.SHORT_SELLING: 'ShortSelling',
-            OrderCondition.DAY_TRADING_LONG: 'Cash',
-            OrderCondition.DAY_TRADING_SHORT: 'Cash'
-        }[order_cond]
-
-        order_lot = sj.constant.StockOrderLot.IntradayOdd\
-            if odd_lot else sj.constant.StockOrderLot.Common
-        now = datetime.datetime.utcnow() + datetime.timedelta(hours=8)
-        if datetime.time(13,40) < datetime.time(now.hour,now.minute) and datetime.time(now.hour,now.minute) < datetime.time(14,30) and odd_lot:
-            order_lot = sj.constant.StockOrderLot.Odd
-        if datetime.time(14,00) < datetime.time(now.hour,now.minute) and datetime.time(now.hour,now.minute) < datetime.time(14,30) and not odd_lot:
-            order_lot = sj.constant.StockOrderLot.Fixing
-
-        order = self.api.Order(price=price,
-                               quantity=quantity,
-                               action=action,
-                               price_type=price_type,
-                               order_type=sj.constant.OrderType.ROD,
-                               order_cond=order_cond,
-                               daytrade_short=daytrade_short,
-                               account=self.api.stock_account,
-                               order_lot=order_lot,
-                               custom_field="FiNlAB",
-                               )
-        trade = self.api.place_order(contract, order)
-
-        self.trades[trade.status.id] = trade
-        return trade.status.id
-    
-    def get_price_info(self):
-        ref = data.get('reference_price')
-        return ref.set_index('stock_id').to_dict(orient='index')
-
-    def update_trades(self):
-        self.api.update_status(self.api.stock_account)
-        self.trades = {t.status.id: t for t in self.api.list_trades()}
-
-    def update_order(self, order_id, price):
-        order = self.get_orders()[order_id]
-        trade = self.trades[order_id]
-
-        try:
-            if trade.order.order_lot == 'IntradayOdd':
-                action = order.action
-                stock_id = order.stock_id
-                q = order.quantity - \
-                    order.filled_quantity
-                q *= 1000
-
-                self.cancel_order(order_id)
-                self.create_order(
-                    action=action, stock_id=stock_id, quantity=q, price=price, odd_lot=True)
-            else:
-                self.api.update_order(trade, price=price)
-        except ValueError as ve:
-            logging.warning(
-                f"update_order: Cannot update price of order {order_id}: {ve}")
-
-    def cancel_order(self, order_id):
-        self.update_trades()
-        self.api.cancel_order(self.trades[order_id])
-
-    def get_position(self):
-        position = self.api.list_positions(
-            self.api.stock_account, unit=sj.constant.Unit.Share)
-        order_conditions = {
-            'Cash': OrderCondition.CASH,
-            'MarginTrading': OrderCondition.MARGIN_TRADING,
-            'ShortSelling': OrderCondition.SHORT_SELLING,
-        }
-        return Position.from_list([{
-            'stock_id': p.code,
-            'quantity': Decimal(p.quantity)/1000 if p.direction == 'Buy' else -Decimal(p.quantity)/1000,
-            'order_condition': order_conditions[p.cond]
-        } for p in position])
-
-    def get_orders(self):
-        self.update_trades()
-        return {t.status.id: trade_to_order(t) for name, t in self.trades.items()}
-
-    def get_stocks(self, stock_ids):
-        try:
-            contracts = [sj.contracts.Contract(security_type='STK', code=s, exchange='TSE') for s in stock_ids]
-            snapshots = self.api.snapshots(contracts)
-        except:
-            time.sleep(10)
-            contracts = [sj.contracts.Contract(security_type='STK', code=s, exchange='TSE') for s in stock_ids]
-            snapshots = self.api.snapshots(contracts)
-
-        return {s.code: snapshot_to_stock(s) for s in snapshots}
-
-    def get_total_balance(self):
-        # get bank balance
-        bank_balance = self.get_cash()
-
-        # get settlements
-        settlements = self.get_settlement()
-
-        # get position balance
-        position = self.get_position()
-        if position.position:
-            stocks = self.get_stocks([i['stock_id'] for i in position.position])
-            account_balance = sum(
-                [float(i['quantity']) * stocks[i['stock_id']].close * 1000 for i in position.position])
-        else:
-            account_balance = 0
-        return bank_balance + settlements + account_balance
-    
-    def get_cash(self):
-        return self.api.account_balance().acc_balance
-    
-    def get_settlement(self):
-        tw_now = datetime.datetime.utcnow() + datetime.timedelta(hours=8)
-        settlements = self.api.settlements(self.api.stock_account)
-        return sum(int(settlement.amount) for settlement in settlements if datetime.datetime.combine(settlement.date, datetime.time(10,0)) > tw_now)
-
-
-    def sep_odd_lot_order(self):
-        return True
-
-def trade_to_order(trade):
-    """將 shioaji package 的委託單轉換成 finlab 格式"""
-    if trade.order.action == 'Buy':
-        action = Action.BUY
-    elif trade.order.action == 'Sell':
-        action = Action.SELL
-    else:
-        raise Exception('trader order action should be "Buy" or "Sell"')
-
-    status = {
-            'PendingSubmit': OrderStatus.NEW,
-            'PreSubmitted': OrderStatus.NEW,
-            'Submitted': OrderStatus.NEW,
-            'Failed': OrderStatus.CANCEL,
-            'Cancelled': OrderStatus.CANCEL,
-            'Filled': OrderStatus.FILLED,
-            'Filling': OrderStatus.PARTIALLY_FILLED,
-            'PartFilled': OrderStatus.PARTIALLY_FILLED,
-            }[trade.status.status]
-
-    order_condition = {
-            'Cash': OrderCondition.CASH,
-            'MarginTrading': OrderCondition.MARGIN_TRADING,
-            'ShortSelling': OrderCondition.SHORT_SELLING,
-            }[trade.order.order_cond]
-
-    # calculate quantity
-    # calculate filled quantity
-    quantity = Decimal(trade.order.quantity)
-    filled_quantity = Decimal(trade.status.deal_quantity)
-
-    if trade.order.order_lot == 'IntradayOdd':
-        quantity /= 1000
-        filled_quantity /= 1000
-
-    # calculate order condition
-    if trade.order.daytrade_short == True and order_condition == OrderCondition.CASH:
-        order_condition = OrderCondition.DAY_TRADING_SHORT
-
-    return Order(**{
-        'order_id': trade.status.id,
-        'stock_id': trade.contract.code,
-        'action': action,
-        'price': trade.order.price if trade.status.modified_price == 0 else trade.status.modified_price,
-        'quantity': quantity,
-        'filled_quantity': filled_quantity,
-        'status': status,
-        'order_condition': order_condition,
-        'time': trade.status.order_datetime,
-        'org_order': trade
-        })
-
-
-def snapshot_to_stock(snapshot):
-    """將 shioaji 股價行情轉換成 finlab 格式"""
-    d = snapshot
-    return Stock(stock_id=d.code, open=d.open, high=d.high, low=d.low, close=d.close,
-               bid_price=d.buy_price, ask_price=d.sell_price, bid_volume=d.buy_volume, ask_volume=d.sell_volume)
-
+import shioaji as sj
+import datetime
+import time
+import os
+import re
+import math
+import logging
+from decimal import Decimal
+
+from finlab.online.base_account import Account, Stock, Order
+from finlab.online.enums import *
+from finlab.online.order_executor import Position
+from finlab import data
+
+pattern = re.compile(r'(?<!^)(?=[A-Z])')
+
+
+class SinopacAccount(Account):
+
+    required_module = 'shioaji'
+    module_version = '1.1.2'
+
+    def __init__(self, api_key=None, secret_key=None, 
+                 certificate_person_id=None, 
+                 certificate_password=None, 
+                 certificate_path=None):
+
+        api_key = api_key or os.environ.get('SHIOAJI_API_KEY')
+        secret_key = secret_key or os.environ.get('SHIOAJI_SECRET_KEY')
+
+        certificate_password = certificate_password or os.environ.get(
+            'SHIOAJI_CERT_PASSWORD')
+        certificate_path = certificate_path or os.environ.get(
+                'SHIOAJI_CERT_PATH')
+        certificate_person_id = certificate_person_id or os.environ.get(
+                'SHIOAJI_CERT_PERSON_ID')
+
+        self.api = sj.Shioaji()
+        self.accounts = self.api.login(api_key, secret_key, fetch_contract=False)
+
+        self.trades = {}
+
+        self.api.activate_ca(
+            ca_path=certificate_path,
+            ca_passwd=certificate_password,
+            person_id=certificate_person_id,
+        )
+
+    def create_order(self, action, stock_id, quantity, price=None, odd_lot=False, market_order=False, best_price_limit=False, order_cond=OrderCondition.CASH):
+
+        # contract = self.api.Contracts.Stocks.get(stock_id)
+        contract = sj.contracts.Contract(security_type='STK', code=stock_id, exchange='TSE')
+        pinfo = self.get_price_info()
+        limitup = float(pinfo[stock_id]['漲停價'])
+        limitdn = float(pinfo[stock_id]['跌停價'])
+        last_close = float(pinfo[stock_id]['收盤價'])
+
+        if stock_id not in pinfo:
+            raise Exception(f"stock {stock_id} not in price info")
+        
+        if quantity <= 0:
+            raise Exception(f"quantity must be positive, got {quantity}")
+
+        if price == None:
+            price = self.api.snapshots([contract])[0].close
+
+        price_type = sj.constant.StockPriceType.LMT
+
+        if market_order:
+            if action == Action.BUY:
+                price = limitup
+            elif action == Action.SELL:
+                price = limitdn
+
+        elif best_price_limit:
+            if action == Action.BUY:
+                price = limitdn
+            elif action == Action.SELL:
+                price = limitup
+
+        if action == Action.BUY:
+            action = 'Buy'
+        elif action == Action.SELL:
+            action = 'Sell'
+
+        daytrade_short = order_cond == OrderCondition.DAY_TRADING_SHORT
+        daytrade_short = True if daytrade_short else False
+
+        order_cond = {
+            OrderCondition.CASH: 'Cash',
+            OrderCondition.MARGIN_TRADING: 'MarginTrading',
+            OrderCondition.SHORT_SELLING: 'ShortSelling',
+            OrderCondition.DAY_TRADING_LONG: 'Cash',
+            OrderCondition.DAY_TRADING_SHORT: 'Cash'
+        }[order_cond]
+
+        order_lot = sj.constant.StockOrderLot.IntradayOdd\
+            if odd_lot else sj.constant.StockOrderLot.Common
+        now = datetime.datetime.utcnow() + datetime.timedelta(hours=8)
+        if datetime.time(13,40) < datetime.time(now.hour,now.minute) and datetime.time(now.hour,now.minute) < datetime.time(14,30) and odd_lot:
+            order_lot = sj.constant.StockOrderLot.Odd
+        if datetime.time(14,00) < datetime.time(now.hour,now.minute) and datetime.time(now.hour,now.minute) < datetime.time(14,30) and not odd_lot:
+            order_lot = sj.constant.StockOrderLot.Fixing
+
+        order = self.api.Order(price=price,
+                               quantity=quantity,
+                               action=action,
+                               price_type=price_type,
+                               order_type=sj.constant.OrderType.ROD,
+                               order_cond=order_cond,
+                               daytrade_short=daytrade_short,
+                               account=self.api.stock_account,
+                               order_lot=order_lot,
+                               custom_field="FiNlAB",
+                               )
+        trade = self.api.place_order(contract, order)
+
+        self.trades[trade.status.id] = trade
+        return trade.status.id
+    
+    def get_price_info(self):
+        ref = data.get('reference_price')
+        return ref.set_index('stock_id').to_dict(orient='index')
+
+    def update_trades(self):
+        self.api.update_status(self.api.stock_account)
+        self.trades = {t.status.id: t for t in self.api.list_trades()}
+
+    def update_order(self, order_id, price):
+        order = self.get_orders()[order_id]
+        trade = self.trades[order_id]
+
+        try:
+            if trade.order.order_lot == 'IntradayOdd':
+                action = order.action
+                stock_id = order.stock_id
+                q = order.quantity - \
+                    order.filled_quantity
+                q *= 1000
+
+                self.cancel_order(order_id)
+                self.create_order(
+                    action=action, stock_id=stock_id, quantity=q, price=price, odd_lot=True)
+            else:
+                self.api.update_order(trade, price=price)
+        except ValueError as ve:
+            logging.warning(
+                f"update_order: Cannot update price of order {order_id}: {ve}")
+
+    def cancel_order(self, order_id):
+        self.update_trades()
+        self.api.cancel_order(self.trades[order_id])
+
+    def get_position(self):
+        position = self.api.list_positions(
+            self.api.stock_account, unit=sj.constant.Unit.Share)
+        order_conditions = {
+            'Cash': OrderCondition.CASH,
+            'MarginTrading': OrderCondition.MARGIN_TRADING,
+            'ShortSelling': OrderCondition.SHORT_SELLING,
+        }
+        return Position.from_list([{
+            'stock_id': p.code,
+            'quantity': Decimal(p.quantity)/1000 if p.direction == 'Buy' else -Decimal(p.quantity)/1000,
+            'order_condition': order_conditions[p.cond]
+        } for p in position])
+
+    def get_orders(self):
+        self.update_trades()
+        return {t.status.id: trade_to_order(t) for name, t in self.trades.items()}
+
+    def get_stocks(self, stock_ids):
+        try:
+            contracts = [sj.contracts.Contract(security_type='STK', code=s, exchange='TSE') for s in stock_ids]
+            snapshots = self.api.snapshots(contracts)
+        except:
+            time.sleep(10)
+            contracts = [sj.contracts.Contract(security_type='STK', code=s, exchange='TSE') for s in stock_ids]
+            snapshots = self.api.snapshots(contracts)
+
+        return {s.code: snapshot_to_stock(s) for s in snapshots}
+
+    def get_total_balance(self):
+        # get bank balance
+        bank_balance = self.get_cash()
+
+        # get settlements
+        settlements = self.get_settlement()
+
+        # get position balance
+        position = self.get_position()
+        if position.position:
+            stocks = self.get_stocks([i['stock_id'] for i in position.position])
+            account_balance = sum(
+                [float(i['quantity']) * stocks[i['stock_id']].close * 1000 for i in position.position])
+        else:
+            account_balance = 0
+        return bank_balance + settlements + account_balance
+    
+    def get_cash(self):
+        return self.api.account_balance().acc_balance
+    
+    def get_settlement(self):
+        tw_now = datetime.datetime.utcnow() + datetime.timedelta(hours=8)
+        settlements = self.api.settlements(self.api.stock_account)
+        return sum(int(settlement.amount) for settlement in settlements if datetime.datetime.combine(settlement.date, datetime.time(10,0)) > tw_now)
+
+
+    def sep_odd_lot_order(self):
+        return True
+
+def trade_to_order(trade):
+    """將 shioaji package 的委託單轉換成 finlab 格式"""
+    if trade.order.action == 'Buy':
+        action = Action.BUY
+    elif trade.order.action == 'Sell':
+        action = Action.SELL
+    else:
+        raise Exception('trader order action should be "Buy" or "Sell"')
+
+    status = {
+            'PendingSubmit': OrderStatus.NEW,
+            'PreSubmitted': OrderStatus.NEW,
+            'Submitted': OrderStatus.NEW,
+            'Failed': OrderStatus.CANCEL,
+            'Cancelled': OrderStatus.CANCEL,
+            'Filled': OrderStatus.FILLED,
+            'Filling': OrderStatus.PARTIALLY_FILLED,
+            'PartFilled': OrderStatus.PARTIALLY_FILLED,
+            }[trade.status.status]
+
+    order_condition = {
+            'Cash': OrderCondition.CASH,
+            'MarginTrading': OrderCondition.MARGIN_TRADING,
+            'ShortSelling': OrderCondition.SHORT_SELLING,
+            }[trade.order.order_cond]
+
+    # calculate quantity
+    # calculate filled quantity
+    quantity = Decimal(trade.order.quantity)
+    filled_quantity = Decimal(trade.status.deal_quantity)
+
+    if trade.order.order_lot == 'IntradayOdd':
+        quantity /= 1000
+        filled_quantity /= 1000
+
+    # calculate order condition
+    if trade.order.daytrade_short == True and order_condition == OrderCondition.CASH:
+        order_condition = OrderCondition.DAY_TRADING_SHORT
+
+    return Order(**{
+        'order_id': trade.status.id,
+        'stock_id': trade.contract.code,
+        'action': action,
+        'price': trade.order.price if trade.status.modified_price == 0 else trade.status.modified_price,
+        'quantity': quantity,
+        'filled_quantity': filled_quantity,
+        'status': status,
+        'order_condition': order_condition,
+        'time': trade.status.order_datetime,
+        'org_order': trade
+        })
+
+
+def snapshot_to_stock(snapshot):
+    """將 shioaji 股價行情轉換成 finlab 格式"""
+    d = snapshot
+    return Stock(stock_id=d.code, open=d.open, high=d.high, low=d.low, close=d.close,
+               bid_price=d.buy_price, ask_price=d.sell_price, bid_volume=d.buy_volume, ask_volume=d.sell_volume)
+
```

## finlab/online/utils.py

 * *Ordering differences only*

```diff
@@ -1,142 +1,142 @@
-import numpy as np
-import pandas as pd
-
-def greedy_allocation(weights, latest_prices, total_portfolio_value=10000):
-
-    """
-    original source code: PyPortfolioOpt
-    https://pypi.org/project/pyportfolioopt/
-    """
-
-    weights = pd.Series(weights)
-
-    weights.index = weights.index.to_series().astype(str)\
-            .str.split(' ').str[0]
-    weights = list(weights.items())
-    latest_prices = latest_prices
-
-    if len(weights) == 0:
-        return {}, total_portfolio_value
-
-    """
-    Convert continuous weights into a discrete portfolio allocation
-    using a greedy iterative approach.
-
-    :param reinvest: whether or not to reinvest cash gained from shorting
-    :type reinvest: bool, defaults to False
-    :param verbose: print error analysis?
-    :type verbose: bool, defaults to False
-    :return: the number of shares of each ticker that should be purchased,
-             along with the amount of funds leftover.
-    :rtype: (dict, float)
-    """
-    reinvest = False
-    verbose = False
-    # Sort in descending order of weight
-    weights.sort(key=lambda x: x[1], reverse=True)
-
-    # If portfolio contains shorts
-    if weights[-1][1] < 0:
-        longs = {t: w for t, w in weights if w >= 0}
-        shorts = {t: -w for t, w in weights if w < 0}
-
-        # Make them sum to one
-        long_total_weight = sum(longs.values())
-        short_total_weight = sum(shorts.values())
-        longs = {t: w / long_total_weight for t, w in longs.items()}
-        shorts = {t: w / short_total_weight for t, w in shorts.items()}
-
-        # Construct long-only discrete allocations for each
-        short_val = total_portfolio_value * short_total_weight
-        long_val = total_portfolio_value * long_total_weight
-
-        if verbose:
-            print("\nAllocating long sub-portfolio...")
-        # da1 = DiscreteAllocation(
-        #     longs, latest_prices[longs.keys()], total_portfolio_value=long_val
-        # )
-        long_alloc, long_leftover = greedy_allocation(longs, latest_prices, long_val)
-
-        if verbose:
-            print("\nAllocating short sub-portfolio...")
-        # da2 = DiscreteAllocation(
-        #     shorts,
-        #     latest_prices[shorts.keys()],
-        #     total_portfolio_value=short_val,
-        # )
-        short_alloc, short_leftover = greedy_allocation(shorts, latest_prices, short_val)
-        short_alloc = {t: -w for t, w in short_alloc.items()}
-
-        # Combine and return
-        allocation = long_alloc.copy()
-        allocation.update(short_alloc)
-        allocation = {t:w for t, w in allocation.items() if w != 0}
-
-        return allocation, long_leftover + short_leftover
-
-    # Otherwise, portfolio is long only and we proceed with greedy algo
-    available_funds = total_portfolio_value
-    shares_bought = []
-    buy_prices = []
-
-    # First round
-    for ticker, weight in weights:
-        price = latest_prices[ticker]
-        # Attempt to buy the lower integer number of shares, which could be zero.
-        n_shares = int(weight * total_portfolio_value / price)
-        cost = n_shares * price
-        # As weights are all > 0 (long only) we always round down n_shares
-        # so the cost is always <= simple weighted share of portfolio value,
-        # so we can not run out of funds just here.
-        assert cost <= available_funds, "Unexpectedly insufficient funds."
-        available_funds -= cost
-        shares_bought.append(n_shares)
-        buy_prices.append(price)
-
-    # Second round
-    while available_funds > 0:
-        # Calculate the equivalent continuous weights of the shares that
-        # have already been bought
-        current_weights = np.array(buy_prices) * np.array(shares_bought)
-        wsum = current_weights.sum()
-        if wsum != 0:
-            current_weights = current_weights / wsum
-        ideal_weights = np.array([i[1] for i in weights])
-        deficit = ideal_weights - current_weights
-
-        # Attempt to buy the asset whose current weights deviate the most
-        idx = np.argmax(deficit)
-        ticker, weight = weights[idx]
-        price = latest_prices[ticker]
-
-        # If we can't afford this asset, search for the next highest deficit that we
-        # can purchase.
-        counter = 0
-        while price > available_funds:
-            deficit[idx] = 0  # we can no longer purchase the asset at idx
-            idx = np.argmax(deficit)  # find the next most deviant asset
-
-            # If either of these conditions is met, we break out of both while loops
-            # hence the repeated statement below
-            if deficit[idx] < 0 or counter == 10:
-                break
-
-            ticker, weight = weights[idx]
-            price = latest_prices[ticker]
-            counter += 1
-
-        if deficit[idx] <= 0 or counter == 10:  # pragma: no cover
-            # Dirty solution to break out of both loops
-            break
-
-        # Buy one share at a time
-        shares_bought[idx] += 1
-        available_funds -= price
-
-    allocation = dict(zip([i[0] for i in weights], shares_bought))
-
-    if verbose:
-        print("Funds remaining: {:.2f}".format(available_funds))
-    return allocation, available_funds
-
-
+import numpy as np
+import pandas as pd
+
+def greedy_allocation(weights, latest_prices, total_portfolio_value=10000):
+
+    """
+    original source code: PyPortfolioOpt
+    https://pypi.org/project/pyportfolioopt/
+    """
+
+    weights = pd.Series(weights)
+
+    weights.index = weights.index.to_series().astype(str)\
+            .str.split(' ').str[0]
+    weights = list(weights.items())
+    latest_prices = latest_prices
+
+    if len(weights) == 0:
+        return {}, total_portfolio_value
+
+    """
+    Convert continuous weights into a discrete portfolio allocation
+    using a greedy iterative approach.
+
+    :param reinvest: whether or not to reinvest cash gained from shorting
+    :type reinvest: bool, defaults to False
+    :param verbose: print error analysis?
+    :type verbose: bool, defaults to False
+    :return: the number of shares of each ticker that should be purchased,
+             along with the amount of funds leftover.
+    :rtype: (dict, float)
+    """
+    reinvest = False
+    verbose = False
+    # Sort in descending order of weight
+    weights.sort(key=lambda x: x[1], reverse=True)
+
+    # If portfolio contains shorts
+    if weights[-1][1] < 0:
+        longs = {t: w for t, w in weights if w >= 0}
+        shorts = {t: -w for t, w in weights if w < 0}
+
+        # Make them sum to one
+        long_total_weight = sum(longs.values())
+        short_total_weight = sum(shorts.values())
+        longs = {t: w / long_total_weight for t, w in longs.items()}
+        shorts = {t: w / short_total_weight for t, w in shorts.items()}
+
+        # Construct long-only discrete allocations for each
+        short_val = total_portfolio_value * short_total_weight
+        long_val = total_portfolio_value * long_total_weight
+
+        if verbose:
+            print("\nAllocating long sub-portfolio...")
+        # da1 = DiscreteAllocation(
+        #     longs, latest_prices[longs.keys()], total_portfolio_value=long_val
+        # )
+        long_alloc, long_leftover = greedy_allocation(longs, latest_prices, long_val)
+
+        if verbose:
+            print("\nAllocating short sub-portfolio...")
+        # da2 = DiscreteAllocation(
+        #     shorts,
+        #     latest_prices[shorts.keys()],
+        #     total_portfolio_value=short_val,
+        # )
+        short_alloc, short_leftover = greedy_allocation(shorts, latest_prices, short_val)
+        short_alloc = {t: -w for t, w in short_alloc.items()}
+
+        # Combine and return
+        allocation = long_alloc.copy()
+        allocation.update(short_alloc)
+        allocation = {t:w for t, w in allocation.items() if w != 0}
+
+        return allocation, long_leftover + short_leftover
+
+    # Otherwise, portfolio is long only and we proceed with greedy algo
+    available_funds = total_portfolio_value
+    shares_bought = []
+    buy_prices = []
+
+    # First round
+    for ticker, weight in weights:
+        price = latest_prices[ticker]
+        # Attempt to buy the lower integer number of shares, which could be zero.
+        n_shares = int(weight * total_portfolio_value / price)
+        cost = n_shares * price
+        # As weights are all > 0 (long only) we always round down n_shares
+        # so the cost is always <= simple weighted share of portfolio value,
+        # so we can not run out of funds just here.
+        assert cost <= available_funds, "Unexpectedly insufficient funds."
+        available_funds -= cost
+        shares_bought.append(n_shares)
+        buy_prices.append(price)
+
+    # Second round
+    while available_funds > 0:
+        # Calculate the equivalent continuous weights of the shares that
+        # have already been bought
+        current_weights = np.array(buy_prices) * np.array(shares_bought)
+        wsum = current_weights.sum()
+        if wsum != 0:
+            current_weights = current_weights / wsum
+        ideal_weights = np.array([i[1] for i in weights])
+        deficit = ideal_weights - current_weights
+
+        # Attempt to buy the asset whose current weights deviate the most
+        idx = np.argmax(deficit)
+        ticker, weight = weights[idx]
+        price = latest_prices[ticker]
+
+        # If we can't afford this asset, search for the next highest deficit that we
+        # can purchase.
+        counter = 0
+        while price > available_funds:
+            deficit[idx] = 0  # we can no longer purchase the asset at idx
+            idx = np.argmax(deficit)  # find the next most deviant asset
+
+            # If either of these conditions is met, we break out of both while loops
+            # hence the repeated statement below
+            if deficit[idx] < 0 or counter == 10:
+                break
+
+            ticker, weight = weights[idx]
+            price = latest_prices[ticker]
+            counter += 1
+
+        if deficit[idx] <= 0 or counter == 10:  # pragma: no cover
+            # Dirty solution to break out of both loops
+            break
+
+        # Buy one share at a time
+        shares_bought[idx] += 1
+        available_funds -= price
+
+    allocation = dict(zip([i[0] for i in weights], shares_bought))
+
+    if verbose:
+        print("Funds remaining: {:.2f}".format(available_funds))
+    return allocation, available_funds
+
+
```

## finlab/optimize/combinations.py

 * *Ordering differences only*

```diff
@@ -1,245 +1,245 @@
-from itertools import combinations
-import pandas as pd
-from finlab.backtest import sim
-from finlab.core.report import Report
-from finlab.utils import logger
-from finlab.dataframe import FinlabDataFrame
-
-
-def sim_conditions(conditions, hold_until={}, *args, **kwargs):
-    """取得回測報告集合
-
-    將選股條件排出所有的組合並進行回測，方便找出最好條件的交集結果。
-
-    Args:
-      conditions (dict): 選股條件集合，key 為條件名稱，value 為條件變數，ex:`{'c1':c1, 'c2':c2}`
-      hold_until (dict): 設定[訊號進出場語法糖](https://doc.finlab.tw/reference/dataframe/#finlab.dataframe.FinlabDataFrame.hold_until)參數，預設為不使用。ex:`{'exit':exit, 'stop_loss':0.1}`
-      *args (tuple): `finlab.backtest.sim()` 回測參數設定。
-      **kwargs (dict): `finlab.backtest.sim()` 回測參數設定。
-
-    Returns:
-      (finlab.optimize.combination.ReportCollection):回測數據報告
-
-    Examples:
-        ```py
-        from finlab import data
-        from finlab.backtest import sim
-        from finlab.optimize.combinations import sim_conditions
-
-        close = data.get("price:收盤價")
-        pe = data.get('price_earning_ratio:本益比')
-        rev=data.get('monthly_revenue:當月營收').index_str_to_date()
-        rev_ma3=rev.average(3)
-        rev_ma12=rev.average(12)
-
-        c1 = (close > close.average(20)) & (close > close.average(60))
-        c2 = (close == close.rolling(20).max())
-        c3 = pe < 15
-        c4 = rev_ma3/rev_ma12 > 1.1
-        c5 = rev/rev.shift(1) > 0.9
-        exits = close < close.average(20)
-        conditions = {'c1':c1, 'c2':c2, 'c3':c3, 'c4':c4, 'c5':c5}
-        report_collection = sim_conditions(conditions=conditions, hold_until={'exit':exits, 'stop_loss':0.1}, resample='M', position_limit=0.1, upload=False)
-        # 策略分組指標報告
-        # print(report_collection.stats)
-        report_collection.plot_creturns().show()
-        report_collection.plot_stats('bar').show()
-        report_collection.plot_stats('heatmap')
-        ```
-        視覺化範例
-
-        ex1:
-
-        `report_collection.plot_creturns().show()`
-
-        繪製折線圖指標分群棒狀圖
-
-        ![bar](img/optimize/report_collection_creturns.png)
-
-        ex2:
-
-        `report_collection.plot_stats('bar').show()`
-
-        繪製指標分群棒狀圖
-
-        ![bar](img/optimize/report_collection_stats_bar.png)
-
-        ex3:
-
-        `report_collection.plot_stats('heatmap')`
-
-        繪製指標分級熱力圖，數值越大為排名越前面，avg_score為指標平均分數，分數越高為評價較正向的策略。
-
-        ![heatmap](img/optimize/report_collection_stats_heatmap.png)
-    """
-
-    key_dataset = []
-    conditions.pop('__builtins__', None)
-    new_conditions = {}
-    for k, v in conditions.items():
-        try:
-            v = FinlabDataFrame(v)
-            if isinstance(v.index[0], str):
-                v = v.index_str_to_date()
-            new_conditions[k] = v
-        except:
-            logger.error(f'{k} data formaat must be dataframe.')
-    for i in range(1, len(new_conditions) + 1):
-        key_dataset.extend(list(combinations(new_conditions.keys(), i)))
-    conditions_combinations = [' & '.join(k) for k in key_dataset]
-
-    reports = {}
-    for k in conditions_combinations:
-        if hold_until:
-            position = eval(k, new_conditions).hold_until(**hold_until)
-        else:
-            position = eval(k, new_conditions)
-        try:
-            reports[k] = sim(position, *args, **kwargs)
-        except Exception as error:
-            logger.error(f'{k}:{error}')
-            pass
-
-    return ReportCollection(reports)
-
-
-class ReportCollection:
-    def __init__(self, reports):
-        """回測組合比較報告
-
-        判斷策略組合數據優劣，從策略海中快速找到體質最強的策略。
-        也可以觀察在同條件下的策略疊加更多條件後會有什麼變化？
-        Args:
-          reports (dict): 回測物件集合，ex:`{'strategy1': finlab.backtest.sim(),'strategy2': finlab.backtest.sim()}`
-        """
-        self.reports = reports
-        self.stats = None
-
-    def get_stats(self):
-        """取得策略指標比較表
-
-        指標欄位說明：
-
-        * `'daily_mean'`: 策略年化報酬
-        * `'daily_sharpe'`: 策略年化夏普率
-        * `'daily_sortino'`: 策略年化索提諾比率
-        * `'max_drawdown'`: 策略報酬率最大回撤率(負向)
-        * `'avg_drawdown'`: 策略平均回撤(負向)
-        * `'ytd'`: 今年度策略報酬率
-        * `'win_ratio'`: 每筆交易勝率
-        * `'avg_return'`: 每筆交易平均獲利率
-        * `'avg_mae'`: 每筆交易平均最大不利方向幅度(負向)
-        * `'avg_bmfe'`: 最大不利方向發生前的"每筆交易平均最大有利方向幅度"，若數值越高，越有機會在停損之前操作停利。
-        * `'avg_gmfe'`: 每筆交易平均最大有利方向幅度
-        * `'avg_mdd'`: 每筆交易平均的最大回撤率(負向)
-
-        Returns:
-          (pd.DataFrame): 策略指標比較報表
-        """
-
-        def get_strategy_indicators(report):
-            if isinstance(report, Report):
-                stats = report.get_stats()
-                trades = report.trades
-                strategy_indexes = {n: stats[n] for n in
-                                    ['daily_mean', 'daily_sharpe',
-                                     'daily_sortino', 'max_drawdown',
-                                     'avg_drawdown']}
-                trade_indexes = {'win_ratio': stats['win_ratio']}
-                trade_indexes.update(
-                    {f'avg_{n}': trades[n].mean() for n in ['return', 'mae', 'bmfe', 'gmfe', 'mdd']})
-                strategy_indexes.update(trade_indexes)
-                return strategy_indexes
-
-        # rewrite:
-        # df = pd.DataFrame({k: get_strategy_indicators(v) for k, v in self.reports.items()})
-        # with try except
-            
-        df = {}
-        for k, v in self.reports.items():
-            try:
-                df[k] = get_strategy_indicators(v)
-            except:
-                logger.error(f'{k} get stats error.')
-                
-        df = pd.DataFrame(df)
-
-        self.stats = df
-        return df
-
-    def plot_stats(self, mode='bar', heatmap_sort_by='avg_score', indicators=[]):
-        """策略指標比較報表視覺化
-
-        Args:
-          mode (str): 繪圖模式。`'bar'` - 指標分群棒狀圖。`'heatmap'` - 指標分級熱力圖。
-          heatmap_sort_by (str or list of str): heatmap 降冪排序的決定欄位
-          indicators (list): 要顯示的特定指標欄位，預設為將指標全部顯示
-
-        Returns:
-          (plotly.graph_objects.Figure): 長條圖
-          (pd.DataFrame): 熱力圖
-
-        Examples:
-            ex1:
-
-            繪製指標分群棒狀圖
-
-            ![bar](img/optimize/report_collection_stats_bar.png)
-
-            ex2:
-
-            繪製指標分級熱力圖。
-
-            `'avg_score'`: 各指標加總後的平均分數，分數越高為整體評價較正向的策略。
-
-            預設以avg_score為排序，數值越大為排名越前面，分數越高為整體評價較優的策略。
-
-            ![heatmap](img/optimize/report_collection_stats_heatmap.png)
-        """
-        if self.stats is None:
-            self.get_stats()
-        df = self.stats
-        if len(indicators) > 0:
-            try:
-                df = df.loc[indicators]
-            except KeyError:
-                logger.error(f"Indicators selection must be in {list(df.index)}")
-        if mode == 'bar':
-            import plotly.graph_objects as go
-            items = df.columns
-            fig = go.Figure(data=[go.Bar(x=df.index, y=df[item], name=item, meta=[item],
-                                         hovertemplate="%{meta}<br>%{label}<br>%{y}<extra></extra>") for item in items])
-            # Change the bar mode
-            fig.update_layout(title={'text': 'Backtest combinations stats', 'x': 0.49, 'y': 0.9, 'xanchor': 'center',
-                                     'yanchor': 'top'}, barmode='group')
-            return fig
-
-        elif mode == 'heatmap':
-            return df.rank(pct=True, axis=1).transpose().assign(avg_score=lambda d: d.mean(axis=1)).round(2).mul(
-                100).sort_values(heatmap_sort_by, ascending=False).style.set_caption(
-                "Backtest combinations heatmap").format('{:.1f}%').background_gradient(axis=None, vmin=0, vmax=100,
-                                                                                       cmap="plasma")
-
-    def plot_creturns(self):
-        """繪製策略累積報酬率
-
-        比較策略淨值曲線變化
-
-        Returns:
-          (plotly.graph_objects.Figure): 折線圖
-
-        Examples:
-            ![line](img/optimize/report_collection_creturns.png)
-        """
-        import plotly.graph_objects as go
-
-        fig = go.Figure()
-        reports = self.reports
-        dataset = {k: v for k, v in sorted(reports.items(), key=lambda item: item[1].creturn[-1], reverse=True)}
-        for k, v in dataset.items():
-            series = v.creturn
-            fig.add_trace(go.Scatter(x=series.index, y=series.values, mode='lines', name=k, meta=k,
-                                     hovertemplate="%{meta}<br>Date:%{x}<br>Creturns:%{y}<extra></extra>"))
-        fig.update_layout(title={'text': 'Cumulative returns', 'x': 0.49, 'y': 0.9, 'xanchor': 'center',
-                                 'yanchor': 'top'})
-        return fig
+from itertools import combinations
+import pandas as pd
+from finlab.backtest import sim
+from finlab.core.report import Report
+from finlab.utils import logger
+from finlab.dataframe import FinlabDataFrame
+
+
+def sim_conditions(conditions, hold_until={}, *args, **kwargs):
+    """取得回測報告集合
+
+    將選股條件排出所有的組合並進行回測，方便找出最好條件的交集結果。
+
+    Args:
+      conditions (dict): 選股條件集合，key 為條件名稱，value 為條件變數，ex:`{'c1':c1, 'c2':c2}`
+      hold_until (dict): 設定[訊號進出場語法糖](https://doc.finlab.tw/reference/dataframe/#finlab.dataframe.FinlabDataFrame.hold_until)參數，預設為不使用。ex:`{'exit':exit, 'stop_loss':0.1}`
+      *args (tuple): `finlab.backtest.sim()` 回測參數設定。
+      **kwargs (dict): `finlab.backtest.sim()` 回測參數設定。
+
+    Returns:
+      (finlab.optimize.combination.ReportCollection):回測數據報告
+
+    Examples:
+        ```py
+        from finlab import data
+        from finlab.backtest import sim
+        from finlab.optimize.combinations import sim_conditions
+
+        close = data.get("price:收盤價")
+        pe = data.get('price_earning_ratio:本益比')
+        rev=data.get('monthly_revenue:當月營收').index_str_to_date()
+        rev_ma3=rev.average(3)
+        rev_ma12=rev.average(12)
+
+        c1 = (close > close.average(20)) & (close > close.average(60))
+        c2 = (close == close.rolling(20).max())
+        c3 = pe < 15
+        c4 = rev_ma3/rev_ma12 > 1.1
+        c5 = rev/rev.shift(1) > 0.9
+        exits = close < close.average(20)
+        conditions = {'c1':c1, 'c2':c2, 'c3':c3, 'c4':c4, 'c5':c5}
+        report_collection = sim_conditions(conditions=conditions, hold_until={'exit':exits, 'stop_loss':0.1}, resample='M', position_limit=0.1, upload=False)
+        # 策略分組指標報告
+        # print(report_collection.stats)
+        report_collection.plot_creturns().show()
+        report_collection.plot_stats('bar').show()
+        report_collection.plot_stats('heatmap')
+        ```
+        視覺化範例
+
+        ex1:
+
+        `report_collection.plot_creturns().show()`
+
+        繪製折線圖指標分群棒狀圖
+
+        ![bar](img/optimize/report_collection_creturns.png)
+
+        ex2:
+
+        `report_collection.plot_stats('bar').show()`
+
+        繪製指標分群棒狀圖
+
+        ![bar](img/optimize/report_collection_stats_bar.png)
+
+        ex3:
+
+        `report_collection.plot_stats('heatmap')`
+
+        繪製指標分級熱力圖，數值越大為排名越前面，avg_score為指標平均分數，分數越高為評價較正向的策略。
+
+        ![heatmap](img/optimize/report_collection_stats_heatmap.png)
+    """
+
+    key_dataset = []
+    conditions.pop('__builtins__', None)
+    new_conditions = {}
+    for k, v in conditions.items():
+        try:
+            v = FinlabDataFrame(v)
+            if isinstance(v.index[0], str):
+                v = v.index_str_to_date()
+            new_conditions[k] = v
+        except:
+            logger.error(f'{k} data formaat must be dataframe.')
+    for i in range(1, len(new_conditions) + 1):
+        key_dataset.extend(list(combinations(new_conditions.keys(), i)))
+    conditions_combinations = [' & '.join(k) for k in key_dataset]
+
+    reports = {}
+    for k in conditions_combinations:
+        if hold_until:
+            position = eval(k, new_conditions).hold_until(**hold_until)
+        else:
+            position = eval(k, new_conditions)
+        try:
+            reports[k] = sim(position, *args, **kwargs)
+        except Exception as error:
+            logger.error(f'{k}:{error}')
+            pass
+
+    return ReportCollection(reports)
+
+
+class ReportCollection:
+    def __init__(self, reports):
+        """回測組合比較報告
+
+        判斷策略組合數據優劣，從策略海中快速找到體質最強的策略。
+        也可以觀察在同條件下的策略疊加更多條件後會有什麼變化？
+        Args:
+          reports (dict): 回測物件集合，ex:`{'strategy1': finlab.backtest.sim(),'strategy2': finlab.backtest.sim()}`
+        """
+        self.reports = reports
+        self.stats = None
+
+    def get_stats(self):
+        """取得策略指標比較表
+
+        指標欄位說明：
+
+        * `'daily_mean'`: 策略年化報酬
+        * `'daily_sharpe'`: 策略年化夏普率
+        * `'daily_sortino'`: 策略年化索提諾比率
+        * `'max_drawdown'`: 策略報酬率最大回撤率(負向)
+        * `'avg_drawdown'`: 策略平均回撤(負向)
+        * `'ytd'`: 今年度策略報酬率
+        * `'win_ratio'`: 每筆交易勝率
+        * `'avg_return'`: 每筆交易平均獲利率
+        * `'avg_mae'`: 每筆交易平均最大不利方向幅度(負向)
+        * `'avg_bmfe'`: 最大不利方向發生前的"每筆交易平均最大有利方向幅度"，若數值越高，越有機會在停損之前操作停利。
+        * `'avg_gmfe'`: 每筆交易平均最大有利方向幅度
+        * `'avg_mdd'`: 每筆交易平均的最大回撤率(負向)
+
+        Returns:
+          (pd.DataFrame): 策略指標比較報表
+        """
+
+        def get_strategy_indicators(report):
+            if isinstance(report, Report):
+                stats = report.get_stats()
+                trades = report.trades
+                strategy_indexes = {n: stats[n] for n in
+                                    ['daily_mean', 'daily_sharpe',
+                                     'daily_sortino', 'max_drawdown',
+                                     'avg_drawdown']}
+                trade_indexes = {'win_ratio': stats['win_ratio']}
+                trade_indexes.update(
+                    {f'avg_{n}': trades[n].mean() for n in ['return', 'mae', 'bmfe', 'gmfe', 'mdd']})
+                strategy_indexes.update(trade_indexes)
+                return strategy_indexes
+
+        # rewrite:
+        # df = pd.DataFrame({k: get_strategy_indicators(v) for k, v in self.reports.items()})
+        # with try except
+            
+        df = {}
+        for k, v in self.reports.items():
+            try:
+                df[k] = get_strategy_indicators(v)
+            except:
+                logger.error(f'{k} get stats error.')
+                
+        df = pd.DataFrame(df)
+
+        self.stats = df
+        return df
+
+    def plot_stats(self, mode='bar', heatmap_sort_by='avg_score', indicators=[]):
+        """策略指標比較報表視覺化
+
+        Args:
+          mode (str): 繪圖模式。`'bar'` - 指標分群棒狀圖。`'heatmap'` - 指標分級熱力圖。
+          heatmap_sort_by (str or list of str): heatmap 降冪排序的決定欄位
+          indicators (list): 要顯示的特定指標欄位，預設為將指標全部顯示
+
+        Returns:
+          (plotly.graph_objects.Figure): 長條圖
+          (pd.DataFrame): 熱力圖
+
+        Examples:
+            ex1:
+
+            繪製指標分群棒狀圖
+
+            ![bar](img/optimize/report_collection_stats_bar.png)
+
+            ex2:
+
+            繪製指標分級熱力圖。
+
+            `'avg_score'`: 各指標加總後的平均分數，分數越高為整體評價較正向的策略。
+
+            預設以avg_score為排序，數值越大為排名越前面，分數越高為整體評價較優的策略。
+
+            ![heatmap](img/optimize/report_collection_stats_heatmap.png)
+        """
+        if self.stats is None:
+            self.get_stats()
+        df = self.stats
+        if len(indicators) > 0:
+            try:
+                df = df.loc[indicators]
+            except KeyError:
+                logger.error(f"Indicators selection must be in {list(df.index)}")
+        if mode == 'bar':
+            import plotly.graph_objects as go
+            items = df.columns
+            fig = go.Figure(data=[go.Bar(x=df.index, y=df[item], name=item, meta=[item],
+                                         hovertemplate="%{meta}<br>%{label}<br>%{y}<extra></extra>") for item in items])
+            # Change the bar mode
+            fig.update_layout(title={'text': 'Backtest combinations stats', 'x': 0.49, 'y': 0.9, 'xanchor': 'center',
+                                     'yanchor': 'top'}, barmode='group')
+            return fig
+
+        elif mode == 'heatmap':
+            return df.rank(pct=True, axis=1).transpose().assign(avg_score=lambda d: d.mean(axis=1)).round(2).mul(
+                100).sort_values(heatmap_sort_by, ascending=False).style.set_caption(
+                "Backtest combinations heatmap").format('{:.1f}%').background_gradient(axis=None, vmin=0, vmax=100,
+                                                                                       cmap="plasma")
+
+    def plot_creturns(self):
+        """繪製策略累積報酬率
+
+        比較策略淨值曲線變化
+
+        Returns:
+          (plotly.graph_objects.Figure): 折線圖
+
+        Examples:
+            ![line](img/optimize/report_collection_creturns.png)
+        """
+        import plotly.graph_objects as go
+
+        fig = go.Figure()
+        reports = self.reports
+        dataset = {k: v for k, v in sorted(reports.items(), key=lambda item: item[1].creturn[-1], reverse=True)}
+        for k, v in dataset.items():
+            series = v.creturn
+            fig.add_trace(go.Scatter(x=series.index, y=series.values, mode='lines', name=k, meta=k,
+                                     hovertemplate="%{meta}<br>Date:%{x}<br>Creturns:%{y}<extra></extra>"))
+        fig.update_layout(title={'text': 'Cumulative returns', 'x': 0.49, 'y': 0.9, 'xanchor': 'center',
+                                 'yanchor': 'top'})
+        return fig
```

## finlab/tools/event_study.py

 * *Ordering differences only*

```diff
@@ -1,200 +1,200 @@
-import tqdm
-import numpy as np
-import pandas as pd
-from typing import List, Dict
-import matplotlib.pyplot as plt
-from finlab.dataframe import FinlabDataFrame
-
-def event_study(factor_data, benchmark_adj_close, stock_adj_close, sample_period=(-45, -20), estimation_period=(-5, 20), plot=True):
-    '''Run event study and returns the abnormal returns of each stock on each day.
-
-    Args:
-        factor_data (pd.DataFrame): factor data where index is datetime and columns is asset id
-        benchmark_adj_close (pd.DataFrame): benchmark for CAPM
-        stock_adj_close (pd.DataFrame): stock price for CAPM
-        sample_period ((int, int)): period for fitting CAPM
-        estimation_period ((int, int)): period for calculating alpha (abnormal return)
-        plot (bool): plot the result
-        
-    Return:
-        Abnormal returns of each stock on each day.
-
-    Examples:
-        ``` py title="現金增減資分析"
-        from finlab.tools.event_study import create_factor_data
-        from finlab.tools.event_study import event_study
-
-        factor = data.get('price_earning_ratio:股價淨值比')
-        adj_close = data.get('etl:adj_close')
-        benchmark = data.get('benchmark_return:發行量加權股價報酬指數')
-
-        # create event dataframe
-        dividend_info = data.get('dividend_announcement')
-        v = dividend_info[['stock_id', '除權交易日']].set_index(['stock_id', '除權交易日'])
-        v['value'] = 1
-        event = v[~v.index.duplicated()].reset_index().drop_duplicates(
-            subset=['stock_id', '除權交易日']
-        ).pivot(index='除權交易日', columns='stock_id', values='value').notna()
-
-        # calculate factor_data
-        factor_data = create_factor_data({'pb':factor}, adj_close, event=event)
-
-        r = event_study(factor_data, benchmark, adj_close)
-
-        plt.bar(r.columns, r.mean().values)
-        plt.plot(r.columns, r.mean().cumsum().values)
-        ```
-    '''
-    benchmark_pct = benchmark_adj_close.reindex(stock_adj_close.index, method='ffill').pct_change()
-    stock_pct = stock_adj_close.pct_change()
-
-    def get_period(df, date, sample):
-        i = df.index.get_loc(date)
-        return df.iloc[i+sample[0]: i+sample[1]].values
-
-    ret = []
-
-    for date, sid in tqdm.tqdm(factor_data.index):
-
-        X1, Y1 = get_period(benchmark_pct, date, sample_period)[:,0], \
-            get_period(stock_pct[sid], date, sample_period)
-        X2, Y2 = get_period(benchmark_pct, date, estimation_period)[:,0], \
-            get_period(stock_pct[sid], date, estimation_period)
-
-        # Run CAPM
-        cov_matrix = np.cov(Y1, X1)
-        beta = cov_matrix[0, 1] / cov_matrix[1, 1]
-        AR = np.array(Y2) - beta * X2
-        ret.append(AR)
-
-    ret = pd.DataFrame(ret, columns=range(*estimation_period))
-
-    if plot:
-        plot_event_study(ret)
-    
-    return ret
-
-
-def create_factor_data(factor:pd.DataFrame or Dict[str, pd.DataFrame], adj_close:pd.DataFrame,
-                       days:List[int]=[5,10,20, 60], event:pd.DataFrame or None=None):
-
-    '''create factor data, which contains future return
-
-    Args:
-        factor (pd.DataFrame): factor data where index is datetime and columns is asset id
-        adj_close (pd.DataFrame): adj close where index is datetime and columns is asset id
-        days (List[int]): future return considered
-
-    Return:
-        Analytic plots and tables
-
-    Warning:
-        This function is not identical to `finlab.ml.alphalens.create_factor_data`
-
-    Examples:
-        ``` py title="現金增減資分析"
-        from finlab.tools.event_study import create_factor_data
-        from finlab.tools.event_study import event_study
-
-        factor = data.get('price_earning_ratio:股價淨值比')
-        adj_close = data.get('etl:adj_close')
-        benchmark = data.get('benchmark_return:發行量加權股價報酬指數')
-
-        # create event dataframe
-        dividend_info = data.get('dividend_announcement')
-        v = dividend_info[['stock_id', '除權交易日']].set_index(['stock_id', '除權交易日'])
-        v['value'] = 1
-        event = v[~v.index.duplicated()].reset_index().drop_duplicates(
-            subset=['stock_id', '除權交易日']
-        ).pivot(index='除權交易日', columns='stock_id', values='value').notna()
-
-        # calculate factor_data
-        factor_data = create_factor_data({'pb':factor}, adj_close, event=event)
-
-        r = event_study(factor_data, benchmark, adj_close)
-
-        plt.bar(r.columns, r.mean().values)
-        plt.plot(r.columns, r.mean().cumsum().values)
-        ```
-
-    '''
-
-    factor = {'factor':factor} if isinstance(factor, pd.DataFrame) else factor
-
-    ref = next(iter(factor.values())) if event is None else event
-    ref = ref[~ref.index.isna()]
-
-    sids = adj_close.columns.intersection(ref.columns)
-    dates = adj_close.index.intersection(
-        FinlabDataFrame.to_business_day(ref.index))
-    
-    ret = {}
-    for name, f in factor.items():
-        reashaped_f = f.reindex(dates, method='ffill').reindex(columns=sids)
-        ret[f'{name}_factor'] = reashaped_f.unstack().values
-        ret[f'{name}_factor_quantile'] = (reashaped_f.rank(axis=1, pct=True) // 0.2).unstack().values
-
-    total_index = None
-    for d in days:
-        temp = (adj_close.shift(-d-1) / adj_close.shift(-1) - 1)\
-            .reindex(index=dates, method='ffill').reindex(columns=sids)\
-            .unstack()
-        
-        ret[f"{d}D"] = temp.values
-        total_index = temp.index
-
-    if event is not None:
-        event = event[event.index.notna()]
-        reshaped_event = event.reindex(index=dates, method='ffill').reindex(columns=sids)
-        ret['event'] = reshaped_event.unstack().values
-
-
-    ret = pd.DataFrame(ret, index=total_index.swaplevel(0, 1))\
-        .replace([-np.inf, np.inf], np.nan)\
-        .dropna()
-
-    if 'event' in ret:
-        ret = ret[ret['event'] == True]
-        ret.drop(columns=['event'], inplace=True)
-
-    ret.index.names = ['date', 'asset']
-    return ret
-
-def plot_event_study(returns:pd.DataFrame):
-    """
-    Plot the event study for the given returns.
-
-    Args:
-        returns (pd.DataFrame): A DataFrame containing the returns data.
-
-    Return:
-        ax (matplotlib.axes.Axes): The axes object containing the plot.
-
-    """
-    returns.mul(100).mean().plot.bar(use_index=False, label='Return')
-
-    s = returns.mul(100).cumsum(axis=1).mean()
-    std = returns.mul(100).cumsum(axis=1).std() * 0.1
-
-    ax = s.plot(use_index=False, label='Cumulative Return')
-
-    y1 = s + std
-    y2 = s - std
-
-    # fill between
-    ax.fill_between(range(len(returns.columns)), y1, y2, color='gray', alpha=0.1, label='0.1 std')
-
-    # set labels
-    ax.set_ylabel('Cumulative Return (%)')
-    ax.set_xlabel('Days')
-    ax.set_title('Event Study')
-
-    # set xticks
-    ax.set_xticks(range(len(returns.columns)))
-    ax.set_xticklabels(returns.columns, rotation=45)
-    ax.legend(loc='upper left')
-    
-    # show ax
-    plt.show()
-    
+import tqdm
+import numpy as np
+import pandas as pd
+from typing import List, Dict
+import matplotlib.pyplot as plt
+from finlab.dataframe import FinlabDataFrame
+
+def event_study(factor_data, benchmark_adj_close, stock_adj_close, sample_period=(-45, -20), estimation_period=(-5, 20), plot=True):
+    '''Run event study and returns the abnormal returns of each stock on each day.
+
+    Args:
+        factor_data (pd.DataFrame): factor data where index is datetime and columns is asset id
+        benchmark_adj_close (pd.DataFrame): benchmark for CAPM
+        stock_adj_close (pd.DataFrame): stock price for CAPM
+        sample_period ((int, int)): period for fitting CAPM
+        estimation_period ((int, int)): period for calculating alpha (abnormal return)
+        plot (bool): plot the result
+        
+    Return:
+        Abnormal returns of each stock on each day.
+
+    Examples:
+        ``` py title="現金增減資分析"
+        from finlab.tools.event_study import create_factor_data
+        from finlab.tools.event_study import event_study
+
+        factor = data.get('price_earning_ratio:股價淨值比')
+        adj_close = data.get('etl:adj_close')
+        benchmark = data.get('benchmark_return:發行量加權股價報酬指數')
+
+        # create event dataframe
+        dividend_info = data.get('dividend_announcement')
+        v = dividend_info[['stock_id', '除權交易日']].set_index(['stock_id', '除權交易日'])
+        v['value'] = 1
+        event = v[~v.index.duplicated()].reset_index().drop_duplicates(
+            subset=['stock_id', '除權交易日']
+        ).pivot(index='除權交易日', columns='stock_id', values='value').notna()
+
+        # calculate factor_data
+        factor_data = create_factor_data({'pb':factor}, adj_close, event=event)
+
+        r = event_study(factor_data, benchmark, adj_close)
+
+        plt.bar(r.columns, r.mean().values)
+        plt.plot(r.columns, r.mean().cumsum().values)
+        ```
+    '''
+    benchmark_pct = benchmark_adj_close.reindex(stock_adj_close.index, method='ffill').pct_change()
+    stock_pct = stock_adj_close.pct_change()
+
+    def get_period(df, date, sample):
+        i = df.index.get_loc(date)
+        return df.iloc[i+sample[0]: i+sample[1]].values
+
+    ret = []
+
+    for date, sid in tqdm.tqdm(factor_data.index):
+
+        X1, Y1 = get_period(benchmark_pct, date, sample_period)[:,0], \
+            get_period(stock_pct[sid], date, sample_period)
+        X2, Y2 = get_period(benchmark_pct, date, estimation_period)[:,0], \
+            get_period(stock_pct[sid], date, estimation_period)
+
+        # Run CAPM
+        cov_matrix = np.cov(Y1, X1)
+        beta = cov_matrix[0, 1] / cov_matrix[1, 1]
+        AR = np.array(Y2) - beta * X2
+        ret.append(AR)
+
+    ret = pd.DataFrame(ret, columns=range(*estimation_period))
+
+    if plot:
+        plot_event_study(ret)
+    
+    return ret
+
+
+def create_factor_data(factor:pd.DataFrame or Dict[str, pd.DataFrame], adj_close:pd.DataFrame,
+                       days:List[int]=[5,10,20, 60], event:pd.DataFrame or None=None):
+
+    '''create factor data, which contains future return
+
+    Args:
+        factor (pd.DataFrame): factor data where index is datetime and columns is asset id
+        adj_close (pd.DataFrame): adj close where index is datetime and columns is asset id
+        days (List[int]): future return considered
+
+    Return:
+        Analytic plots and tables
+
+    Warning:
+        This function is not identical to `finlab.ml.alphalens.create_factor_data`
+
+    Examples:
+        ``` py title="現金增減資分析"
+        from finlab.tools.event_study import create_factor_data
+        from finlab.tools.event_study import event_study
+
+        factor = data.get('price_earning_ratio:股價淨值比')
+        adj_close = data.get('etl:adj_close')
+        benchmark = data.get('benchmark_return:發行量加權股價報酬指數')
+
+        # create event dataframe
+        dividend_info = data.get('dividend_announcement')
+        v = dividend_info[['stock_id', '除權交易日']].set_index(['stock_id', '除權交易日'])
+        v['value'] = 1
+        event = v[~v.index.duplicated()].reset_index().drop_duplicates(
+            subset=['stock_id', '除權交易日']
+        ).pivot(index='除權交易日', columns='stock_id', values='value').notna()
+
+        # calculate factor_data
+        factor_data = create_factor_data({'pb':factor}, adj_close, event=event)
+
+        r = event_study(factor_data, benchmark, adj_close)
+
+        plt.bar(r.columns, r.mean().values)
+        plt.plot(r.columns, r.mean().cumsum().values)
+        ```
+
+    '''
+
+    factor = {'factor':factor} if isinstance(factor, pd.DataFrame) else factor
+
+    ref = next(iter(factor.values())) if event is None else event
+    ref = ref[~ref.index.isna()]
+
+    sids = adj_close.columns.intersection(ref.columns)
+    dates = adj_close.index.intersection(
+        FinlabDataFrame.to_business_day(ref.index))
+    
+    ret = {}
+    for name, f in factor.items():
+        reashaped_f = f.reindex(dates, method='ffill').reindex(columns=sids)
+        ret[f'{name}_factor'] = reashaped_f.unstack().values
+        ret[f'{name}_factor_quantile'] = (reashaped_f.rank(axis=1, pct=True) // 0.2).unstack().values
+
+    total_index = None
+    for d in days:
+        temp = (adj_close.shift(-d-1) / adj_close.shift(-1) - 1)\
+            .reindex(index=dates, method='ffill').reindex(columns=sids)\
+            .unstack()
+        
+        ret[f"{d}D"] = temp.values
+        total_index = temp.index
+
+    if event is not None:
+        event = event[event.index.notna()]
+        reshaped_event = event.reindex(index=dates, method='ffill').reindex(columns=sids)
+        ret['event'] = reshaped_event.unstack().values
+
+
+    ret = pd.DataFrame(ret, index=total_index.swaplevel(0, 1))\
+        .replace([-np.inf, np.inf], np.nan)\
+        .dropna()
+
+    if 'event' in ret:
+        ret = ret[ret['event'] == True]
+        ret.drop(columns=['event'], inplace=True)
+
+    ret.index.names = ['date', 'asset']
+    return ret
+
+def plot_event_study(returns:pd.DataFrame):
+    """
+    Plot the event study for the given returns.
+
+    Args:
+        returns (pd.DataFrame): A DataFrame containing the returns data.
+
+    Return:
+        ax (matplotlib.axes.Axes): The axes object containing the plot.
+
+    """
+    returns.mul(100).mean().plot.bar(use_index=False, label='Return')
+
+    s = returns.mul(100).cumsum(axis=1).mean()
+    std = returns.mul(100).cumsum(axis=1).std() * 0.1
+
+    ax = s.plot(use_index=False, label='Cumulative Return')
+
+    y1 = s + std
+    y2 = s - std
+
+    # fill between
+    ax.fill_between(range(len(returns.columns)), y1, y2, color='gray', alpha=0.1, label='0.1 std')
+
+    # set labels
+    ax.set_ylabel('Cumulative Return (%)')
+    ax.set_xlabel('Days')
+    ax.set_title('Event Study')
+
+    # set xticks
+    ax.set_xticks(range(len(returns.columns)))
+    ax.set_xticklabels(returns.columns, rotation=45)
+    ax.legend(loc='upper left')
+    
+    # show ax
+    plt.show()
+    
     return ax
```

## Comparing `finlab-1.1.1.dist-info/LICENSE` & `finlab-1.1.2.dist-info/LICENSE`

 * *Ordering differences only*

 * *Files 7% similar despite different names*

```diff
@@ -1,674 +1,674 @@
-                    GNU GENERAL PUBLIC LICENSE
-                       Version 3, 29 June 2007
-
- Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-                            Preamble
-
-  The GNU General Public License is a free, copyleft license for
-software and other kinds of works.
-
-  The licenses for most software and other practical works are designed
-to take away your freedom to share and change the works.  By contrast,
-the GNU General Public License is intended to guarantee your freedom to
-share and change all versions of a program--to make sure it remains free
-software for all its users.  We, the Free Software Foundation, use the
-GNU General Public License for most of our software; it applies also to
-any other work released this way by its authors.  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-them if you wish), that you receive source code or can get it if you
-want it, that you can change the software or use pieces of it in new
-free programs, and that you know you can do these things.
-
-  To protect your rights, we need to prevent others from denying you
-these rights or asking you to surrender the rights.  Therefore, you have
-certain responsibilities if you distribute copies of the software, or if
-you modify it: responsibilities to respect the freedom of others.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must pass on to the recipients the same
-freedoms that you received.  You must make sure that they, too, receive
-or can get the source code.  And you must show them these terms so they
-know their rights.
-
-  Developers that use the GNU GPL protect your rights with two steps:
-(1) assert copyright on the software, and (2) offer you this License
-giving you legal permission to copy, distribute and/or modify it.
-
-  For the developers' and authors' protection, the GPL clearly explains
-that there is no warranty for this free software.  For both users' and
-authors' sake, the GPL requires that modified versions be marked as
-changed, so that their problems will not be attributed erroneously to
-authors of previous versions.
-
-  Some devices are designed to deny users access to install or run
-modified versions of the software inside them, although the manufacturer
-can do so.  This is fundamentally incompatible with the aim of
-protecting users' freedom to change the software.  The systematic
-pattern of such abuse occurs in the area of products for individuals to
-use, which is precisely where it is most unacceptable.  Therefore, we
-have designed this version of the GPL to prohibit the practice for those
-products.  If such problems arise substantially in other domains, we
-stand ready to extend this provision to those domains in future versions
-of the GPL, as needed to protect the freedom of users.
-
-  Finally, every program is threatened constantly by software patents.
-States should not allow patents to restrict development and use of
-software on general-purpose computers, but in those that do, we wish to
-avoid the special danger that patents applied to a free program could
-make it effectively proprietary.  To prevent this, the GPL assures that
-patents cannot be used to render the program non-free.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-                       TERMS AND CONDITIONS
-
-  0. Definitions.
-
-  "This License" refers to version 3 of the GNU General Public License.
-
-  "Copyright" also means copyright-like laws that apply to other kinds of
-works, such as semiconductor masks.
-
-  "The Program" refers to any copyrightable work licensed under this
-License.  Each licensee is addressed as "you".  "Licensees" and
-"recipients" may be individuals or organizations.
-
-  To "modify" a work means to copy from or adapt all or part of the work
-in a fashion requiring copyright permission, other than the making of an
-exact copy.  The resulting work is called a "modified version" of the
-earlier work or a work "based on" the earlier work.
-
-  A "covered work" means either the unmodified Program or a work based
-on the Program.
-
-  To "propagate" a work means to do anything with it that, without
-permission, would make you directly or secondarily liable for
-infringement under applicable copyright law, except executing it on a
-computer or modifying a private copy.  Propagation includes copying,
-distribution (with or without modification), making available to the
-public, and in some countries other activities as well.
-
-  To "convey" a work means any kind of propagation that enables other
-parties to make or receive copies.  Mere interaction with a user through
-a computer network, with no transfer of a copy, is not conveying.
-
-  An interactive user interface displays "Appropriate Legal Notices"
-to the extent that it includes a convenient and prominently visible
-feature that (1) displays an appropriate copyright notice, and (2)
-tells the user that there is no warranty for the work (except to the
-extent that warranties are provided), that licensees may convey the
-work under this License, and how to view a copy of this License.  If
-the interface presents a list of user commands or options, such as a
-menu, a prominent item in the list meets this criterion.
-
-  1. Source Code.
-
-  The "source code" for a work means the preferred form of the work
-for making modifications to it.  "Object code" means any non-source
-form of a work.
-
-  A "Standard Interface" means an interface that either is an official
-standard defined by a recognized standards body, or, in the case of
-interfaces specified for a particular programming language, one that
-is widely used among developers working in that language.
-
-  The "System Libraries" of an executable work include anything, other
-than the work as a whole, that (a) is included in the normal form of
-packaging a Major Component, but which is not part of that Major
-Component, and (b) serves only to enable use of the work with that
-Major Component, or to implement a Standard Interface for which an
-implementation is available to the public in source code form.  A
-"Major Component", in this context, means a major essential component
-(kernel, window system, and so on) of the specific operating system
-(if any) on which the executable work runs, or a compiler used to
-produce the work, or an object code interpreter used to run it.
-
-  The "Corresponding Source" for a work in object code form means all
-the source code needed to generate, install, and (for an executable
-work) run the object code and to modify the work, including scripts to
-control those activities.  However, it does not include the work's
-System Libraries, or general-purpose tools or generally available free
-programs which are used unmodified in performing those activities but
-which are not part of the work.  For example, Corresponding Source
-includes interface definition files associated with source files for
-the work, and the source code for shared libraries and dynamically
-linked subprograms that the work is specifically designed to require,
-such as by intimate data communication or control flow between those
-subprograms and other parts of the work.
-
-  The Corresponding Source need not include anything that users
-can regenerate automatically from other parts of the Corresponding
-Source.
-
-  The Corresponding Source for a work in source code form is that
-same work.
-
-  2. Basic Permissions.
-
-  All rights granted under this License are granted for the term of
-copyright on the Program, and are irrevocable provided the stated
-conditions are met.  This License explicitly affirms your unlimited
-permission to run the unmodified Program.  The output from running a
-covered work is covered by this License only if the output, given its
-content, constitutes a covered work.  This License acknowledges your
-rights of fair use or other equivalent, as provided by copyright law.
-
-  You may make, run and propagate covered works that you do not
-convey, without conditions so long as your license otherwise remains
-in force.  You may convey covered works to others for the sole purpose
-of having them make modifications exclusively for you, or provide you
-with facilities for running those works, provided that you comply with
-the terms of this License in conveying all material for which you do
-not control copyright.  Those thus making or running the covered works
-for you must do so exclusively on your behalf, under your direction
-and control, on terms that prohibit them from making any copies of
-your copyrighted material outside their relationship with you.
-
-  Conveying under any other circumstances is permitted solely under
-the conditions stated below.  Sublicensing is not allowed; section 10
-makes it unnecessary.
-
-  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
-
-  No covered work shall be deemed part of an effective technological
-measure under any applicable law fulfilling obligations under article
-11 of the WIPO copyright treaty adopted on 20 December 1996, or
-similar laws prohibiting or restricting circumvention of such
-measures.
-
-  When you convey a covered work, you waive any legal power to forbid
-circumvention of technological measures to the extent such circumvention
-is effected by exercising rights under this License with respect to
-the covered work, and you disclaim any intention to limit operation or
-modification of the work as a means of enforcing, against the work's
-users, your or third parties' legal rights to forbid circumvention of
-technological measures.
-
-  4. Conveying Verbatim Copies.
-
-  You may convey verbatim copies of the Program's source code as you
-receive it, in any medium, provided that you conspicuously and
-appropriately publish on each copy an appropriate copyright notice;
-keep intact all notices stating that this License and any
-non-permissive terms added in accord with section 7 apply to the code;
-keep intact all notices of the absence of any warranty; and give all
-recipients a copy of this License along with the Program.
-
-  You may charge any price or no price for each copy that you convey,
-and you may offer support or warranty protection for a fee.
-
-  5. Conveying Modified Source Versions.
-
-  You may convey a work based on the Program, or the modifications to
-produce it from the Program, in the form of source code under the
-terms of section 4, provided that you also meet all of these conditions:
-
-    a) The work must carry prominent notices stating that you modified
-    it, and giving a relevant date.
-
-    b) The work must carry prominent notices stating that it is
-    released under this License and any conditions added under section
-    7.  This requirement modifies the requirement in section 4 to
-    "keep intact all notices".
-
-    c) You must license the entire work, as a whole, under this
-    License to anyone who comes into possession of a copy.  This
-    License will therefore apply, along with any applicable section 7
-    additional terms, to the whole of the work, and all its parts,
-    regardless of how they are packaged.  This License gives no
-    permission to license the work in any other way, but it does not
-    invalidate such permission if you have separately received it.
-
-    d) If the work has interactive user interfaces, each must display
-    Appropriate Legal Notices; however, if the Program has interactive
-    interfaces that do not display Appropriate Legal Notices, your
-    work need not make them do so.
-
-  A compilation of a covered work with other separate and independent
-works, which are not by their nature extensions of the covered work,
-and which are not combined with it such as to form a larger program,
-in or on a volume of a storage or distribution medium, is called an
-"aggregate" if the compilation and its resulting copyright are not
-used to limit the access or legal rights of the compilation's users
-beyond what the individual works permit.  Inclusion of a covered work
-in an aggregate does not cause this License to apply to the other
-parts of the aggregate.
-
-  6. Conveying Non-Source Forms.
-
-  You may convey a covered work in object code form under the terms
-of sections 4 and 5, provided that you also convey the
-machine-readable Corresponding Source under the terms of this License,
-in one of these ways:
-
-    a) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by the
-    Corresponding Source fixed on a durable physical medium
-    customarily used for software interchange.
-
-    b) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by a
-    written offer, valid for at least three years and valid for as
-    long as you offer spare parts or customer support for that product
-    model, to give anyone who possesses the object code either (1) a
-    copy of the Corresponding Source for all the software in the
-    product that is covered by this License, on a durable physical
-    medium customarily used for software interchange, for a price no
-    more than your reasonable cost of physically performing this
-    conveying of source, or (2) access to copy the
-    Corresponding Source from a network server at no charge.
-
-    c) Convey individual copies of the object code with a copy of the
-    written offer to provide the Corresponding Source.  This
-    alternative is allowed only occasionally and noncommercially, and
-    only if you received the object code with such an offer, in accord
-    with subsection 6b.
-
-    d) Convey the object code by offering access from a designated
-    place (gratis or for a charge), and offer equivalent access to the
-    Corresponding Source in the same way through the same place at no
-    further charge.  You need not require recipients to copy the
-    Corresponding Source along with the object code.  If the place to
-    copy the object code is a network server, the Corresponding Source
-    may be on a different server (operated by you or a third party)
-    that supports equivalent copying facilities, provided you maintain
-    clear directions next to the object code saying where to find the
-    Corresponding Source.  Regardless of what server hosts the
-    Corresponding Source, you remain obligated to ensure that it is
-    available for as long as needed to satisfy these requirements.
-
-    e) Convey the object code using peer-to-peer transmission, provided
-    you inform other peers where the object code and Corresponding
-    Source of the work are being offered to the general public at no
-    charge under subsection 6d.
-
-  A separable portion of the object code, whose source code is excluded
-from the Corresponding Source as a System Library, need not be
-included in conveying the object code work.
-
-  A "User Product" is either (1) a "consumer product", which means any
-tangible personal property which is normally used for personal, family,
-or household purposes, or (2) anything designed or sold for incorporation
-into a dwelling.  In determining whether a product is a consumer product,
-doubtful cases shall be resolved in favor of coverage.  For a particular
-product received by a particular user, "normally used" refers to a
-typical or common use of that class of product, regardless of the status
-of the particular user or of the way in which the particular user
-actually uses, or expects or is expected to use, the product.  A product
-is a consumer product regardless of whether the product has substantial
-commercial, industrial or non-consumer uses, unless such uses represent
-the only significant mode of use of the product.
-
-  "Installation Information" for a User Product means any methods,
-procedures, authorization keys, or other information required to install
-and execute modified versions of a covered work in that User Product from
-a modified version of its Corresponding Source.  The information must
-suffice to ensure that the continued functioning of the modified object
-code is in no case prevented or interfered with solely because
-modification has been made.
-
-  If you convey an object code work under this section in, or with, or
-specifically for use in, a User Product, and the conveying occurs as
-part of a transaction in which the right of possession and use of the
-User Product is transferred to the recipient in perpetuity or for a
-fixed term (regardless of how the transaction is characterized), the
-Corresponding Source conveyed under this section must be accompanied
-by the Installation Information.  But this requirement does not apply
-if neither you nor any third party retains the ability to install
-modified object code on the User Product (for example, the work has
-been installed in ROM).
-
-  The requirement to provide Installation Information does not include a
-requirement to continue to provide support service, warranty, or updates
-for a work that has been modified or installed by the recipient, or for
-the User Product in which it has been modified or installed.  Access to a
-network may be denied when the modification itself materially and
-adversely affects the operation of the network or violates the rules and
-protocols for communication across the network.
-
-  Corresponding Source conveyed, and Installation Information provided,
-in accord with this section must be in a format that is publicly
-documented (and with an implementation available to the public in
-source code form), and must require no special password or key for
-unpacking, reading or copying.
-
-  7. Additional Terms.
-
-  "Additional permissions" are terms that supplement the terms of this
-License by making exceptions from one or more of its conditions.
-Additional permissions that are applicable to the entire Program shall
-be treated as though they were included in this License, to the extent
-that they are valid under applicable law.  If additional permissions
-apply only to part of the Program, that part may be used separately
-under those permissions, but the entire Program remains governed by
-this License without regard to the additional permissions.
-
-  When you convey a copy of a covered work, you may at your option
-remove any additional permissions from that copy, or from any part of
-it.  (Additional permissions may be written to require their own
-removal in certain cases when you modify the work.)  You may place
-additional permissions on material, added by you to a covered work,
-for which you have or can give appropriate copyright permission.
-
-  Notwithstanding any other provision of this License, for material you
-add to a covered work, you may (if authorized by the copyright holders of
-that material) supplement the terms of this License with terms:
-
-    a) Disclaiming warranty or limiting liability differently from the
-    terms of sections 15 and 16 of this License; or
-
-    b) Requiring preservation of specified reasonable legal notices or
-    author attributions in that material or in the Appropriate Legal
-    Notices displayed by works containing it; or
-
-    c) Prohibiting misrepresentation of the origin of that material, or
-    requiring that modified versions of such material be marked in
-    reasonable ways as different from the original version; or
-
-    d) Limiting the use for publicity purposes of names of licensors or
-    authors of the material; or
-
-    e) Declining to grant rights under trademark law for use of some
-    trade names, trademarks, or service marks; or
-
-    f) Requiring indemnification of licensors and authors of that
-    material by anyone who conveys the material (or modified versions of
-    it) with contractual assumptions of liability to the recipient, for
-    any liability that these contractual assumptions directly impose on
-    those licensors and authors.
-
-  All other non-permissive additional terms are considered "further
-restrictions" within the meaning of section 10.  If the Program as you
-received it, or any part of it, contains a notice stating that it is
-governed by this License along with a term that is a further
-restriction, you may remove that term.  If a license document contains
-a further restriction but permits relicensing or conveying under this
-License, you may add to a covered work material governed by the terms
-of that license document, provided that the further restriction does
-not survive such relicensing or conveying.
-
-  If you add terms to a covered work in accord with this section, you
-must place, in the relevant source files, a statement of the
-additional terms that apply to those files, or a notice indicating
-where to find the applicable terms.
-
-  Additional terms, permissive or non-permissive, may be stated in the
-form of a separately written license, or stated as exceptions;
-the above requirements apply either way.
-
-  8. Termination.
-
-  You may not propagate or modify a covered work except as expressly
-provided under this License.  Any attempt otherwise to propagate or
-modify it is void, and will automatically terminate your rights under
-this License (including any patent licenses granted under the third
-paragraph of section 11).
-
-  However, if you cease all violation of this License, then your
-license from a particular copyright holder is reinstated (a)
-provisionally, unless and until the copyright holder explicitly and
-finally terminates your license, and (b) permanently, if the copyright
-holder fails to notify you of the violation by some reasonable means
-prior to 60 days after the cessation.
-
-  Moreover, your license from a particular copyright holder is
-reinstated permanently if the copyright holder notifies you of the
-violation by some reasonable means, this is the first time you have
-received notice of violation of this License (for any work) from that
-copyright holder, and you cure the violation prior to 30 days after
-your receipt of the notice.
-
-  Termination of your rights under this section does not terminate the
-licenses of parties who have received copies or rights from you under
-this License.  If your rights have been terminated and not permanently
-reinstated, you do not qualify to receive new licenses for the same
-material under section 10.
-
-  9. Acceptance Not Required for Having Copies.
-
-  You are not required to accept this License in order to receive or
-run a copy of the Program.  Ancillary propagation of a covered work
-occurring solely as a consequence of using peer-to-peer transmission
-to receive a copy likewise does not require acceptance.  However,
-nothing other than this License grants you permission to propagate or
-modify any covered work.  These actions infringe copyright if you do
-not accept this License.  Therefore, by modifying or propagating a
-covered work, you indicate your acceptance of this License to do so.
-
-  10. Automatic Licensing of Downstream Recipients.
-
-  Each time you convey a covered work, the recipient automatically
-receives a license from the original licensors, to run, modify and
-propagate that work, subject to this License.  You are not responsible
-for enforcing compliance by third parties with this License.
-
-  An "entity transaction" is a transaction transferring control of an
-organization, or substantially all assets of one, or subdividing an
-organization, or merging organizations.  If propagation of a covered
-work results from an entity transaction, each party to that
-transaction who receives a copy of the work also receives whatever
-licenses to the work the party's predecessor in interest had or could
-give under the previous paragraph, plus a right to possession of the
-Corresponding Source of the work from the predecessor in interest, if
-the predecessor has it or can get it with reasonable efforts.
-
-  You may not impose any further restrictions on the exercise of the
-rights granted or affirmed under this License.  For example, you may
-not impose a license fee, royalty, or other charge for exercise of
-rights granted under this License, and you may not initiate litigation
-(including a cross-claim or counterclaim in a lawsuit) alleging that
-any patent claim is infringed by making, using, selling, offering for
-sale, or importing the Program or any portion of it.
-
-  11. Patents.
-
-  A "contributor" is a copyright holder who authorizes use under this
-License of the Program or a work on which the Program is based.  The
-work thus licensed is called the contributor's "contributor version".
-
-  A contributor's "essential patent claims" are all patent claims
-owned or controlled by the contributor, whether already acquired or
-hereafter acquired, that would be infringed by some manner, permitted
-by this License, of making, using, or selling its contributor version,
-but do not include claims that would be infringed only as a
-consequence of further modification of the contributor version.  For
-purposes of this definition, "control" includes the right to grant
-patent sublicenses in a manner consistent with the requirements of
-this License.
-
-  Each contributor grants you a non-exclusive, worldwide, royalty-free
-patent license under the contributor's essential patent claims, to
-make, use, sell, offer for sale, import and otherwise run, modify and
-propagate the contents of its contributor version.
-
-  In the following three paragraphs, a "patent license" is any express
-agreement or commitment, however denominated, not to enforce a patent
-(such as an express permission to practice a patent or covenant not to
-sue for patent infringement).  To "grant" such a patent license to a
-party means to make such an agreement or commitment not to enforce a
-patent against the party.
-
-  If you convey a covered work, knowingly relying on a patent license,
-and the Corresponding Source of the work is not available for anyone
-to copy, free of charge and under the terms of this License, through a
-publicly available network server or other readily accessible means,
-then you must either (1) cause the Corresponding Source to be so
-available, or (2) arrange to deprive yourself of the benefit of the
-patent license for this particular work, or (3) arrange, in a manner
-consistent with the requirements of this License, to extend the patent
-license to downstream recipients.  "Knowingly relying" means you have
-actual knowledge that, but for the patent license, your conveying the
-covered work in a country, or your recipient's use of the covered work
-in a country, would infringe one or more identifiable patents in that
-country that you have reason to believe are valid.
-
-  If, pursuant to or in connection with a single transaction or
-arrangement, you convey, or propagate by procuring conveyance of, a
-covered work, and grant a patent license to some of the parties
-receiving the covered work authorizing them to use, propagate, modify
-or convey a specific copy of the covered work, then the patent license
-you grant is automatically extended to all recipients of the covered
-work and works based on it.
-
-  A patent license is "discriminatory" if it does not include within
-the scope of its coverage, prohibits the exercise of, or is
-conditioned on the non-exercise of one or more of the rights that are
-specifically granted under this License.  You may not convey a covered
-work if you are a party to an arrangement with a third party that is
-in the business of distributing software, under which you make payment
-to the third party based on the extent of your activity of conveying
-the work, and under which the third party grants, to any of the
-parties who would receive the covered work from you, a discriminatory
-patent license (a) in connection with copies of the covered work
-conveyed by you (or copies made from those copies), or (b) primarily
-for and in connection with specific products or compilations that
-contain the covered work, unless you entered into that arrangement,
-or that patent license was granted, prior to 28 March 2007.
-
-  Nothing in this License shall be construed as excluding or limiting
-any implied license or other defenses to infringement that may
-otherwise be available to you under applicable patent law.
-
-  12. No Surrender of Others' Freedom.
-
-  If conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot convey a
-covered work so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you may
-not convey it at all.  For example, if you agree to terms that obligate you
-to collect a royalty for further conveying from those to whom you convey
-the Program, the only way you could satisfy both those terms and this
-License would be to refrain entirely from conveying the Program.
-
-  13. Use with the GNU Affero General Public License.
-
-  Notwithstanding any other provision of this License, you have
-permission to link or combine any covered work with a work licensed
-under version 3 of the GNU Affero General Public License into a single
-combined work, and to convey the resulting work.  The terms of this
-License will continue to apply to the part which is the covered work,
-but the special requirements of the GNU Affero General Public License,
-section 13, concerning interaction through a network will apply to the
-combination as such.
-
-  14. Revised Versions of this License.
-
-  The Free Software Foundation may publish revised and/or new versions of
-the GNU General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-  Each version is given a distinguishing version number.  If the
-Program specifies that a certain numbered version of the GNU General
-Public License "or any later version" applies to it, you have the
-option of following the terms and conditions either of that numbered
-version or of any later version published by the Free Software
-Foundation.  If the Program does not specify a version number of the
-GNU General Public License, you may choose any version ever published
-by the Free Software Foundation.
-
-  If the Program specifies that a proxy can decide which future
-versions of the GNU General Public License can be used, that proxy's
-public statement of acceptance of a version permanently authorizes you
-to choose that version for the Program.
-
-  Later license versions may give you additional or different
-permissions.  However, no additional obligations are imposed on any
-author or copyright holder as a result of your choosing to follow a
-later version.
-
-  15. Disclaimer of Warranty.
-
-  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
-APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
-HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
-OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
-THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
-IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
-ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. Limitation of Liability.
-
-  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
-THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
-GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
-USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
-DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
-PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
-EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
-SUCH DAMAGES.
-
-  17. Interpretation of Sections 15 and 16.
-
-  If the disclaimer of warranty and limitation of liability provided
-above cannot be given local legal effect according to their terms,
-reviewing courts shall apply local law that most closely approximates
-an absolute waiver of all civil liability in connection with the
-Program, unless a warranty or assumption of liability accompanies a
-copy of the Program in return for a fee.
-
-                     END OF TERMS AND CONDITIONS
-
-            How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-state the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-
-Also add information on how to contact you by electronic and paper mail.
-
-  If the program does terminal interaction, make it output a short
-notice like this when it starts in an interactive mode:
-
-    <program>  Copyright (C) <year>  <name of author>
-    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, your program's commands
-might be different; for a GUI interface, you would use an "about box".
-
-  You should also get your employer (if you work as a programmer) or school,
-if any, to sign a "copyright disclaimer" for the program, if necessary.
-For more information on this, and how to apply and follow the GNU GPL, see
-<https://www.gnu.org/licenses/>.
-
-  The GNU General Public License does not permit incorporating your program
-into proprietary programs.  If your program is a subroutine library, you
-may consider it more useful to permit linking proprietary applications with
-the library.  If this is what you want to do, use the GNU Lesser General
-Public License instead of this License.  But first, please read
-<https://www.gnu.org/licenses/why-not-lgpl.html>.
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+state the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <https://www.gnu.org/licenses/>.
+
+Also add information on how to contact you by electronic and paper mail.
+
+  If the program does terminal interaction, make it output a short
+notice like this when it starts in an interactive mode:
+
+    <program>  Copyright (C) <year>  <name of author>
+    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, your program's commands
+might be different; for a GUI interface, you would use an "about box".
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU GPL, see
+<https://www.gnu.org/licenses/>.
+
+  The GNU General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library, you
+may consider it more useful to permit linking proprietary applications with
+the library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.  But first, please read
+<https://www.gnu.org/licenses/why-not-lgpl.html>.
```

## Comparing `finlab-1.1.1.dist-info/METADATA` & `finlab-1.1.2.dist-info/METADATA`

 * *Files 11% similar despite different names*

```diff
@@ -1,105 +1,105 @@
-Metadata-Version: 2.1
-Name: finlab
-Version: 1.1.1
-Summary: Analyzing stock has never been easier.
-Author: FinLab
-Author-email: finlab.company@finlab.tw
-Project-URL: 文件教學, https://doc.finlab.tw/getting-start/
-Project-URL: 選股策略, https://ai.finlab.tw/strategies/
-Classifier: Programming Language :: Python :: 3.7
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Classifier: Programming Language :: Python :: 3.11
-Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)
-Classifier: Operating System :: OS Independent
-Requires-Python: >=3.6
-Description-Content-Type: text/markdown
-License-File: LICENSE
-Requires-Dist: requests
-Requires-Dist: numpy >=1.21.6
-Requires-Dist: pandas >=1.5.3
-Requires-Dist: pyarrow >=2.0.0
-Requires-Dist: lz4
-Requires-Dist: Cython
-Requires-Dist: tqdm
-Requires-Dist: jinja2
-
-
-# FinLab
-
-瞬間的閃念之中，揭示過去十年2000支股票的歷史數據，這就是finlab package！不僅如此，它與pandas無縫整合，讓你在策略創建的旅程中，如同進行一場華麗的交響樂演奏。其語法之簡潔，讓你撰寫策略時有如神助。 
-
-你只需要撰寫人類懂得邏輯，而程式會自動融合各種頻率的歷史數據來選股，這不僅是程式設計上的巧思，更是對簡潔的極致追求。當你以為這已經是頂峰，它的詳細回測結果，又將你帶入更深一層的分析維度，每一筆數據都讓你的決策更加精準。 在幾秒鐘之內，2000支股票的回測，這速度，這效率，它不僅是一個 package，這是一個交易者的夢想加速器！這是finlab，一個為熱血操盤手量身打造的回測神器！
-
-## 功能
-* 📊 快速存取龐大資料集：單一指令即可取得2000支股票過去十年的歷史數據。
-* 🐼 Pandas整合：利用熟悉且功能強大的pandas函式庫，輕鬆設計交易策略。
-* 🔍 用戶友好的語法✍️：採用簡潔直觀編碼語法。
-* 🕒 多頻率數據處理：自動整合管理不同時間頻率的歷史數據。
-* 🔬 全面的回測分析：透過詳細的回測報告，獲得深入的洞察。
-* 🚀 高速計算：得益於 Cython 優化的性能，幾秒鐘內即可執行2000支股票的回測。
-* 🤖 機器學習：結合 qlib 研發機器學習策略。
-
-## 相關連結
-* [程式文檔](https://doc.finlab.tw/reference/finlab/)
-* [Jupyter Notebook 範例](https://doc.finlab.tw/tools/guide_for_beginners/)
-* [回測儀表板](https://ai.finlab.tw/strategies)
-
-## 簡易教學
-### 下載資料
-
-輸入以下程式碼，即可下載資料。可以[查詢](https://ai.finlab.tw/database)有哪些歷史資料可以下載。
-
-``` py
-from finlab import data
-
-data.get('price:收盤價')
-```
-
-| date       |   0015 |   0050 |   0051 |   0052 |   0053 |
-|:-----------|-------:|-------:|-------:|-------:|-------:|
-| 2007-04-23 |   9.54 |  57.85 |  32.83 |  38.4  |    nan |
-| 2007-04-24 |   9.54 |  58.1  |  32.99 |  38.65 |    nan |
-| 2007-04-25 |   9.52 |  57.6  |  32.8  |  38.59 |    nan |
-| 2007-04-26 |   9.59 |  57.7  |  32.8  |  38.6  |    nan |
-| 2007-04-27 |   9.55 |  57.5  |  32.72 |  38.4  |    nan |
-
-### 撰寫策略
-
-可以用非常簡單的 `Pandas` 語法來撰寫策略邏輯，以創新高的策略來說，可以用以下的寫法：
-
-``` py
-from finlab import data
-
-close = data.get('price:收盤價')
-
-# 創三百個交易日新高
-position = close >= close.rolling(300).max()
-position
-```
-
-| date                |   0015 |   0050 |   0051 |   0052 |   0053 |
-|:--------------------|-------:|-------:|-------:|-------:|-------:|
-| 2007-04-23 00:00:00 |  False |  False |  False |  False |  False |
-| 2007-04-24 00:00:00 |  False |  False |  False |  False |  False |
-| 2007-04-25 00:00:00 |  False |  False |  False |  False |  False |
-| 2007-04-26 00:00:00 |  False |  False |  False |   True |  False |
-| 2007-04-27 00:00:00 |  False |  False |  False |  False |  False |
-
-這邊的 `position` 是一個 False/True 的查詢表，當數值為 True ，代表該股票在當天有創新高，而數字 False 則代表沒有創新高。由於創新高的股票很少，上面的範例中，只有少數股票的數值會是 True。
-
-假設我們希望每個月底，搜尋上表中數值為 True 的股票並且買入持有一個月，可以用以下的語法：
-
-### 回測績效
-
-``` py
-from finlab import backtest
-
-report = backtest.sim(position, resample='M')
-report.display()
-```
-
-![image](https://i.ibb.co/7kNyvhP/Screen-Shot-2021-07-13-at-11-54-29-PM.png)
-
-
+Metadata-Version: 2.1
+Name: finlab
+Version: 1.1.2
+Summary: Analyzing stock has never been easier.
+Author: FinLab
+Author-email: finlab.company@finlab.tw
+Project-URL: 文件教學, https://doc.finlab.tw/getting-start/
+Project-URL: 選股策略, https://ai.finlab.tw/strategies/
+Classifier: Programming Language :: Python :: 3.7
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)
+Classifier: Operating System :: OS Independent
+Requires-Python: >=3.6
+Description-Content-Type: text/markdown
+License-File: LICENSE
+Requires-Dist: requests
+Requires-Dist: numpy >=1.21.6
+Requires-Dist: pandas >=1.5.3
+Requires-Dist: pyarrow >=2.0.0
+Requires-Dist: lz4
+Requires-Dist: Cython
+Requires-Dist: tqdm
+Requires-Dist: jinja2
+
+
+# FinLab
+
+瞬間的閃念之中，揭示過去十年2000支股票的歷史數據，這就是finlab package！不僅如此，它與pandas無縫整合，讓你在策略創建的旅程中，如同進行一場華麗的交響樂演奏。其語法之簡潔，讓你撰寫策略時有如神助。 
+
+你只需要撰寫人類懂得邏輯，而程式會自動融合各種頻率的歷史數據來選股，這不僅是程式設計上的巧思，更是對簡潔的極致追求。當你以為這已經是頂峰，它的詳細回測結果，又將你帶入更深一層的分析維度，每一筆數據都讓你的決策更加精準。 在幾秒鐘之內，2000支股票的回測，這速度，這效率，它不僅是一個 package，這是一個交易者的夢想加速器！這是finlab，一個為熱血操盤手量身打造的回測神器！
+
+## 功能
+* 📊 快速存取龐大資料集：單一指令即可取得2000支股票過去十年的歷史數據。
+* 🐼 Pandas整合：利用熟悉且功能強大的pandas函式庫，輕鬆設計交易策略。
+* 🔍 用戶友好的語法✍️：採用簡潔直觀編碼語法。
+* 🕒 多頻率數據處理：自動整合管理不同時間頻率的歷史數據。
+* 🔬 全面的回測分析：透過詳細的回測報告，獲得深入的洞察。
+* 🚀 高速計算：得益於 Cython 優化的性能，幾秒鐘內即可執行2000支股票的回測。
+* 🤖 機器學習：結合 qlib 研發機器學習策略。
+
+## 相關連結
+* [程式文檔](https://doc.finlab.tw/reference/finlab/)
+* [Jupyter Notebook 範例](https://doc.finlab.tw/tools/guide_for_beginners/)
+* [回測儀表板](https://ai.finlab.tw/strategies)
+
+## 簡易教學
+### 下載資料
+
+輸入以下程式碼，即可下載資料。可以[查詢](https://ai.finlab.tw/database)有哪些歷史資料可以下載。
+
+``` py
+from finlab import data
+
+data.get('price:收盤價')
+```
+
+| date       |   0015 |   0050 |   0051 |   0052 |   0053 |
+|:-----------|-------:|-------:|-------:|-------:|-------:|
+| 2007-04-23 |   9.54 |  57.85 |  32.83 |  38.4  |    nan |
+| 2007-04-24 |   9.54 |  58.1  |  32.99 |  38.65 |    nan |
+| 2007-04-25 |   9.52 |  57.6  |  32.8  |  38.59 |    nan |
+| 2007-04-26 |   9.59 |  57.7  |  32.8  |  38.6  |    nan |
+| 2007-04-27 |   9.55 |  57.5  |  32.72 |  38.4  |    nan |
+
+### 撰寫策略
+
+可以用非常簡單的 `Pandas` 語法來撰寫策略邏輯，以創新高的策略來說，可以用以下的寫法：
+
+``` py
+from finlab import data
+
+close = data.get('price:收盤價')
+
+# 創三百個交易日新高
+position = close >= close.rolling(300).max()
+position
+```
+
+| date                |   0015 |   0050 |   0051 |   0052 |   0053 |
+|:--------------------|-------:|-------:|-------:|-------:|-------:|
+| 2007-04-23 00:00:00 |  False |  False |  False |  False |  False |
+| 2007-04-24 00:00:00 |  False |  False |  False |  False |  False |
+| 2007-04-25 00:00:00 |  False |  False |  False |  False |  False |
+| 2007-04-26 00:00:00 |  False |  False |  False |   True |  False |
+| 2007-04-27 00:00:00 |  False |  False |  False |  False |  False |
+
+這邊的 `position` 是一個 False/True 的查詢表，當數值為 True ，代表該股票在當天有創新高，而數字 False 則代表沒有創新高。由於創新高的股票很少，上面的範例中，只有少數股票的數值會是 True。
+
+假設我們希望每個月底，搜尋上表中數值為 True 的股票並且買入持有一個月，可以用以下的語法：
+
+### 回測績效
+
+``` py
+from finlab import backtest
+
+report = backtest.sim(position, resample='M')
+report.display()
+```
+
+![image](https://i.ibb.co/7kNyvhP/Screen-Shot-2021-07-13-at-11-54-29-PM.png)
+
+
```

## Comparing `finlab-1.1.1.dist-info/RECORD` & `finlab-1.1.2.dist-info/RECORD`

 * *Files 24% similar despite different names*

```diff
@@ -1,49 +1,50 @@
-finlab/__init__.py,sha256=XIumDQIqwNE836eFab8wad7y9i3y48Ce3eYJA1xL-8I,2605
-finlab/backtest.py,sha256=eTBNtO5ZrqF4L2KiKiC_ZgjYO0Na2PZSp7CyxYezVv4,32555
-finlab/data.py,sha256=0oQKPfJ0mYZzPjTnV4govtNK2WzL12ELKZVipVwkklw,49465
-finlab/dataframe.py,sha256=kDRJ4aF7fMpmDjsDAKjO8EazA_5pc4G4YnsVdqrX0FU,30324
-finlab/ffn_core.py,sha256=wVG8HEyC0UV4oNxRhlUM_qp5nRDoSmmn_kduDyZfRfI,80855
-finlab/market_info.py,sha256=Hp2BPcD10jDlhmtrcBNLz5_9Dq3-1uxMMNOTub6ndsI,17331
-finlab/plot.py,sha256=ruuOqRXe1eViHbYlUCZOh-qChvip69DWafadLa5k010,43954
-finlab/utils.py,sha256=6ujagCnpVPc6c7XRTUD7z3mA5oo72QfvWIBl46MXuaA,6760
-finlab/analysis/__init__.py,sha256=armuzLT4fnTY0hLuMsc524wdWw28ffm3gu-GdNc7tUQ,7772
-finlab/analysis/alphaBetaAnalysis.py,sha256=4QPEJ66t7orMO9RoQMb_mGmdO1ya8fu3sgR-bOHKauY,2380
-finlab/analysis/drawdownAnalysis.py,sha256=B9lhGVwBkwbJCfg8ac0xVk9EoaErB1x0prmz9q7_A7s,1449
-finlab/analysis/inequalityAnalysis.py,sha256=p4to4ddtTCASyspv1a-qZmK8q0wDImHi2lB8luPJJPk,5013
-finlab/analysis/liquidityAnalysis.py,sha256=E3gE38fmWCJ9XY-x9E58UqId-vvWxhjCWo2ZniRPhDU,5692
-finlab/analysis/maeMfeAnalysis.py,sha256=xNdtMAR9YtREB2ykHaekxlZffgAJ2GHQiHnnSfRtX4Y,12357
-finlab/analysis/periodStatsAnalysis.py,sha256=QWwiFsNasYR2ogfhbPqziOVrsM_jhPHHsl5f9x-7P5E,7622
-finlab/core/__init__.py,sha256=frcCV1k9oG9oKj3dpUqdJg1PxRT2RSN_XKdLCPjaYaY,2
-finlab/core/aes.cp39-win_amd64.pyd,sha256=SNrKMeyN3DUbzFVHhmJGBD0Ev-wD0sl0moK0wCF-lOc,216064
-finlab/core/backtest_core.cp39-win_amd64.pyd,sha256=p-DdZoJztMW8n5iDEshVIaf6c8gX5FdqUMagx5ak1lk,165888
-finlab/core/everything.js,sha256=ca81jzxXybk2N0fMfTjHA8LieQ0YBzQ0yWYtuOLDmyU,1125698
-finlab/core/mae_mfe.cp39-win_amd64.pyd,sha256=ItxCWfoYKKjVrDXBGdsIv-SkeNYMJjWYYPQCDSRAcuc,76288
-finlab/core/report.cp39-win_amd64.pyd,sha256=C8OoFa4r8IuXac4KCjO9p7nJelTXv-MmV_7hyunpOm8,414720
-finlab/core/style.css,sha256=lFchdhfAOfDsPjIusTm8mwDssrjMBXka0rsiOKMcGwU,873859
-finlab/core/utils_core.cp39-win_amd64.pyd,sha256=05GccRIpXU0G05ylV0agHYrFs2xl1watmRYg4efdXJ8,32768
-finlab/ml/__init__.py,sha256=9HkCuI3dhG81xe3O_dsCNq03i4JoEVHG6tPHAvsy0Xk,712
-finlab/ml/alphalens.py,sha256=OXEmDgV4UJNnxVPX4ZmnhlU4rRN4acgQHIrMWid_Bo8,7448
-finlab/ml/cpcv.py,sha256=Uua_tfkLTuHltAsCUsTeSKH8Jw-gnU1PJV1ddgQip6s,5160
-finlab/ml/feature.py,sha256=UjthkXXXXssLMK-KUiXSwk7WNWvxxfozhUrl2yG04to,16145
-finlab/ml/label.py,sha256=ZEFOWpYIFmZvBqKDCvF4-37hz6mJ0krsF2FTAi2udqI,6357
-finlab/ml/qlib.py,sha256=l_Wie9I4wg4bINc9j0kwLPwPSBQmISQ7vP02yPp4ZHg,25631
-finlab/ml/utils.py,sha256=UiKIfL69zREH9GrOP_MRQxUA162D9PzHRqXSEj64odI,3131
-finlab/online/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-finlab/online/base_account.py,sha256=pnSNgvMBjeXUEFwJk-Z3jmc-7swg5_v036dkn2JntXA,8475
-finlab/online/binance_account.py,sha256=ua_Yv0Y_HMy5Ip4hqatTy1hcYqEOR7mvIy3m7abLaV4,14777
-finlab/online/dashboard.py,sha256=hhLoQDgytda4xW_wOLb3rlOO_j_W5aILlwjNrKwX2QI,7264
-finlab/online/enums.py,sha256=7X5VmoaffdVDFNiRF-EIeRBtroGmLGEryVlxLmurWro,263
-finlab/online/fugle_account.py,sha256=1LqT1aH1qaVYVHFFXnB1ddoNQdL_mJvKL_Cx5280KOY,13420
-finlab/online/order_executor.py,sha256=loDnkSp5-mtrn8hC-HQgU_bq1TSJS1yAcOaotWB4Wh4,29166
-finlab/online/panel.py,sha256=CxShb6PMOuFLrtPkNipvrAwHMpTUnyQN99w-j29s1rM,13190
-finlab/online/sinopac_account.py,sha256=617Y67O3iVavsuh4pZvwQbNdC5UR34l8twdPbum_OR0,10390
-finlab/online/utils.py,sha256=Yv_wf_icMkmKTOOSNqjK7jIbue53ZhfR--xOyFhftns,5303
-finlab/optimize/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-finlab/optimize/combinations.py,sha256=uBIIP-fHlPA3312joMITwV01nziSrMyZKdYh0h-xYQI,9862
-finlab/tools/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-finlab/tools/event_study.py,sha256=BvsZvxyOs3MbUDtjxLotx3J_8eOkIDooyDSgrK74bwQ,7195
-finlab-1.1.1.dist-info/LICENSE,sha256=IwGE9guuL-ryRPEKi6wFPI_zOhg7zDZbTYuHbSt_SAk,35823
-finlab-1.1.1.dist-info/METADATA,sha256=9Y_E0VQHPAuXY0-0yvyqDfe7gJAkgHBvhWlLwi7440w,4726
-finlab-1.1.1.dist-info/WHEEL,sha256=Z6c-bE0pUM47a70GvqO_SvH_XXU0lm62gEAKtoNJ08A,100
-finlab-1.1.1.dist-info/top_level.txt,sha256=m5gMT8MS1RxoL-WPzxP83LozK_ubRB3AN7d9shpXNIQ,7
-finlab-1.1.1.dist-info/RECORD,,
+finlab/dataframe.py,sha256=bvelLpmQc0k-vMe7Cb-nJHUg7k6Nf3VvE4J1m2WJATE,29536
+finlab/utils.py,sha256=s-LX9B2IgXekHx9PaGsWEp-i8ZfE9idVjDX_Xagw1v4,6521
+finlab/data.py,sha256=8-Iw3EsSFYTTiNgNtju47zTFgsU-Vc6J8U5tk9DAUpM,48175
+finlab/plot.py,sha256=JD8yIu5Bp0rR7oZdVUrXFqv1xkj0jAfAV3pzeVTZ8ng,42864
+finlab/backtest.py,sha256=xRnVRyzt2ndj5xiSFoU2MqF8fxdefGckNvSVYqzs0c0,31789
+finlab/ffn_core.py,sha256=9U1v6_zahqziZJovx-NoeJbtmaTb_xlaSuae6rfPQpE,78494
+finlab/market_info.py,sha256=RtDlvl15oVneCrds_gk0buw7TgK4ERdcfPgNOgqoK7c,16818
+finlab/__init__.py,sha256=arj2gI0K2veLTVWFoP-irWvHbUawJSXMSQQAPZMe2mA,2540
+finlab/core/aes.cpython-310-aarch64-linux-gnu.so,sha256=rD0LzWZmtJ9Sy1ZIa31XuBAsGFuocYGl4Bo93kz2Zxk,2277128
+finlab/core/report.cpython-310-aarch64-linux-gnu.so,sha256=RYolVpnen91zAHd4VxhYoJAxUevhYO9IbDkk0j6rokI,4610016
+finlab/core/backtest_core.cpython-310-aarch64-linux-gnu.so,sha256=Tz8ijYVETPgjf9zkHOYZq5fZXp5wIPmQ8UlsDlTclCA,2779416
+finlab/core/style.css,sha256=Uq4oZnifboZ4Or4RwzmVwnOqw63XtXjRkXZBNCj_3jQ,873858
+finlab/core/utils_core.cpython-310-aarch64-linux-gnu.so,sha256=e2Lza6C2vNaztKeXDEe3SnJsZeScv4zqgRc6uF43pKA,243680
+finlab/core/mae_mfe.cpython-310-aarch64-linux-gnu.so,sha256=fKmWTEyEdsUycwsZOGPXSGm8p1VgkloKR5REKHEiTUg,1070384
+finlab/core/everything.js,sha256=8_eLFw8HrZefRRQMO9uA0fi4Rb7y7-TNMf2jiBX_OpM,1100642
+finlab/core/__init__.py,sha256=AbpHGcgLb-kRsJGnwFEktk7uzpZOCcBY74-YBdrKVGs,1
+finlab/optimize/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+finlab/optimize/combinations.py,sha256=CrodpfTys9B4NBwNGC7M_OLd-g_RSxiSK1WciugfZMk,9617
+finlab/analysis/drawdownAnalysis.py,sha256=v-zy-uRxN5dR1V-ARKAHYHlr_07cOGMDNUlQmRjb3_8,1405
+finlab/analysis/maeMfeAnalysis.py,sha256=Q8qR0fsxiFgmXVRKfaABaMnuL9fZevqdIb0mCJY8LoM,12088
+finlab/analysis/liquidityAnalysis.py,sha256=59y9-akCSma9J6MxDrAdx8f9_f9cQL8p2uAz-Gqddtw,5555
+finlab/analysis/inequalityAnalysis.py,sha256=_R5J350eIYNi7pST3RS_cN4whhgDtdtswOufjdlq3jM,4858
+finlab/analysis/periodStatsAnalysis.py,sha256=m97-GFGr8AvM0HgRGhZOJtpXdSB9M-mqSZv1GMDlzpU,7442
+finlab/analysis/__init__.py,sha256=VrsMjE40Gxq9WKs65ievnvYVRI6KCKsfpoaNy3Flggw,7577
+finlab/analysis/alphaBetaAnalysis.py,sha256=rQ1RrlS2PXLEax3BlJArOvOqLXAex3F_00my16Ebc8k,2306
+finlab/tools/factor_analysis.py,sha256=rOM2CPC32e5S9YSVD0J4g8edXE1OPK80lNAawAWx_k0,994
+finlab/tools/event_study.py,sha256=mLXKUu2f2P5JHbUfZ-aIpIkznj4OVviLflSO4qXycpQ,6996
+finlab/tools/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+finlab/online/sinopac_account.py,sha256=FeVxH1M3kzLbPl4-VZ-CSBPAdMTxxJ_mC2cLxBTghno,10120
+finlab/online/order_executor.py,sha256=eaNmQ2nXbl3WpXV6qy6adfLqR14HIMb4sZpNtFo2N4Y,28459
+finlab/online/base_account.py,sha256=FbGfoljiCYrkGCA0FNvCMktgardxTn-37FD8aHSOKzU,8206
+finlab/online/fugle_account.py,sha256=P8Fo7v1M_cu-uL4Vhwk3XLne7i0HT1ccTSRFB2rkluE,13043
+finlab/online/utils.py,sha256=VM2BkY7t4XYbg2WBWzl-pah68WNzYWlyS_GARAtey1U,5161
+finlab/online/enums.py,sha256=ty-NJQ5IfgRye6n9eKOISLVAYOrBhlf0iNoYaJaJ7ZQ,256
+finlab/online/binance_account.py,sha256=uuFKO8dfdPqxSRFiHKdKVp1S8r51U1gsqVRs7-9pE7A,14373
+finlab/online/panel.py,sha256=FoOw1kLqDJ3WX488F0spgOLw9JaXSvVuxoHg608eD64,12850
+finlab/online/dashboard.py,sha256=dZ3hY-fqJ_jXsGQnRjMO5UQnGeR5llPabFzgY9Oy_XI,7035
+finlab/online/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+finlab/ml/qlib.py,sha256=A0mjGA76zZWF1Y1i8Lirjq6hS3q9gyDP7Jt6cf0sxGo,24914
+finlab/ml/cpcv.py,sha256=qqzvkNOcTbdKOh8nyc0EuJIHfrB9ZeQnH3goqUS2M_8,5018
+finlab/ml/utils.py,sha256=2_vqfkiwBG4zV9JkTjFO9QU956i9eTFHf3yHvH6MJ0M,3042
+finlab/ml/alphalens.py,sha256=j7bP1PWcf35e-ahd0qR7z-B7Ze6KQA8TdHqHYlLTKVo,7240
+finlab/ml/feature.py,sha256=P_4u6CCSsLrqfgaag7jCNlQMI30EakfOB89EDUzH2ek,15831
+finlab/ml/label.py,sha256=8Q8jSNqFTOfSWWSvhW2rdOn49dhAqQK9QFUYbjYpdyY,6203
+finlab/ml/__init__.py,sha256=vpCBfwam89L7dVcWZlySt9OtSRCpBwUotSI531olX18,679
+finlab-1.1.2.dist-info/RECORD,,
+finlab-1.1.2.dist-info/METADATA,sha256=V7SNxzoiIGHEsP5faciZqeDTKjV3gOfoW3AG4PjApfM,4621
+finlab-1.1.2.dist-info/top_level.txt,sha256=m5gMT8MS1RxoL-WPzxP83LozK_ubRB3AN7d9shpXNIQ,7
+finlab-1.1.2.dist-info/WHEEL,sha256=H0QERcJuEKoCcMIutioyRp9n3LaQjdVoB25CT5wQyPk,154
+finlab-1.1.2.dist-info/LICENSE,sha256=OXLcl0T2SZ8Pmy2_dmlvKuetivmyPd5m1q-Gyd-zaYY,35149
```

