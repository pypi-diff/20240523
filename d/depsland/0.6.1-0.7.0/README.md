# Comparing `tmp/depsland-0.6.1-py3-none-any.whl.zip` & `tmp/depsland-0.7.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,76 +1,104 @@
-Zip file size: 5065025 bytes, number of entries: 74
--rw-r--r--  2.0 fat      557 b- defN 80-Jan-01 00:00 depsland/__init__.py
--rw-r--r--  2.0 fat    12835 b- defN 80-Jan-01 00:00 depsland/__main__.py
--rw-r--r--  2.0 fat      342 b- defN 80-Jan-01 00:00 depsland/api/__init__.py
--rw-r--r--  2.0 fat      169 b- defN 80-Jan-01 00:00 depsland/api/dev_api/__init__.py
--rw-r--r--  2.0 fat     1506 b- defN 80-Jan-01 00:00 depsland/api/dev_api/build.py
--rw-r--r--  2.0 fat      107 b- defN 80-Jan-01 00:00 depsland/api/dev_api/index.py
--rw-r--r--  2.0 fat     1916 b- defN 80-Jan-01 00:00 depsland/api/dev_api/init.py
--rw-r--r--  2.0 fat     8412 b- defN 80-Jan-01 00:00 depsland/api/dev_api/offline_build.py
--rw-r--r--  2.0 fat     7713 b- defN 80-Jan-01 00:00 depsland/api/dev_api/publish.py
--rw-r--r--  2.0 fat       38 b- defN 80-Jan-01 00:00 depsland/api/self_api/__init__.py
--rw-r--r--  2.0 fat     3304 b- defN 80-Jan-01 00:00 depsland/api/self_api/upgrade.py
--rw-r--r--  2.0 fat      147 b- defN 80-Jan-01 00:00 depsland/api/user_api/__init__.py
--rw-r--r--  2.0 fat    13500 b- defN 80-Jan-01 00:00 depsland/api/user_api/install.py
--rw-r--r--  2.0 fat      682 b- defN 80-Jan-01 00:00 depsland/api/user_api/uninstall.py
--rw-r--r--  2.0 fat  4522872 b- defN 80-Jan-01 00:00 depsland/chore/build.zip
--rw-r--r--  2.0 fat      397 b- defN 80-Jan-01 00:00 depsland/chore/conf.zip
--rw-r--r--  2.0 fat      107 b- defN 80-Jan-01 00:00 depsland/chore/readme.md
--rw-r--r--  2.0 fat     3140 b- defN 80-Jan-01 00:00 depsland/chore/sidework.zip
--rw-r--r--  2.0 fat     1672 b- defN 80-Jan-01 00:00 depsland/config.py
--rw-r--r--  2.0 fat       61 b- defN 80-Jan-01 00:00 depsland/doctor/__init__.py
--rw-r--r--  2.0 fat     1162 b- defN 80-Jan-01 00:00 depsland/doctor/pypi_index.py
--rw-r--r--  2.0 fat     3648 b- defN 80-Jan-01 00:00 depsland/doctor.py
--rw-r--r--  2.0 fat      948 b- defN 80-Jan-01 00:00 depsland/downloader.py
+Zip file size: 3195617 bytes, number of entries: 102
+-rw-r--r--  2.0 fat     1116 b- defN 80-Jan-01 00:00 depsland/__init__.py
+-rw-r--r--  2.0 fat    12673 b- defN 80-Jan-01 00:00 depsland/__main__.py
+-rw-r--r--  2.0 fat      332 b- defN 80-Jan-01 00:00 depsland/api/__init__.py
+-rw-r--r--  2.0 fat      164 b- defN 80-Jan-01 00:00 depsland/api/dev_api/__init__.py
+-rw-r--r--  2.0 fat      717 b- defN 80-Jan-01 00:00 depsland/api/dev_api/build.py
+-rw-r--r--  2.0 fat      104 b- defN 80-Jan-01 00:00 depsland/api/dev_api/index.py
+-rw-r--r--  2.0 fat     4678 b- defN 80-Jan-01 00:00 depsland/api/dev_api/init.py
+-rw-r--r--  2.0 fat     9211 b- defN 80-Jan-01 00:00 depsland/api/dev_api/offline_build.py
+-rw-r--r--  2.0 fat    10550 b- defN 80-Jan-01 00:00 depsland/api/dev_api/publish.py
+-rw-r--r--  2.0 fat       37 b- defN 80-Jan-01 00:00 depsland/api/self_api/__init__.py
+-rw-r--r--  2.0 fat     3133 b- defN 80-Jan-01 00:00 depsland/api/self_api/upgrade.py
+-rw-r--r--  2.0 fat      168 b- defN 80-Jan-01 00:00 depsland/api/user_api/__init__.py
+-rw-r--r--  2.0 fat    14366 b- defN 80-Jan-01 00:00 depsland/api/user_api/install.py
+-rw-r--r--  2.0 fat     3521 b- defN 80-Jan-01 00:00 depsland/api/user_api/run.py
+-rw-r--r--  2.0 fat      679 b- defN 80-Jan-01 00:00 depsland/api/user_api/uninstall.py
+-rw-r--r--  2.0 fat  1863003 b- defN 80-Jan-01 00:00 depsland/chore/build.zip
+-rw-r--r--  2.0 fat      431 b- defN 80-Jan-01 00:00 depsland/chore/config.zip
+-rw-r--r--  2.0 fat      104 b- defN 80-Jan-01 00:00 depsland/chore/readme.md
+-rw-r--r--  2.0 fat     8482 b- defN 80-Jan-01 00:00 depsland/chore/sidework.zip
+-rw-r--r--  2.0 fat     1614 b- defN 80-Jan-01 00:00 depsland/config.py
+-rw-r--r--  2.0 fat      359 b- defN 80-Jan-01 00:00 depsland/depsolver/__init__.py
+-rw-r--r--  2.0 fat     5558 b- defN 80-Jan-01 00:00 depsland/depsolver/poetry_lock_resolver.py
+-rw-r--r--  2.0 fat     7919 b- defN 80-Jan-01 00:00 depsland/depsolver/poetry_lock_resolver_2.py
+-rw-r--r--  2.0 fat     6628 b- defN 80-Jan-01 00:00 depsland/depsolver/requirements_lock.py
+-rw-r--r--  2.0 fat     3904 b- defN 80-Jan-01 00:00 depsland/depsolver/resolver.py
+-rw-r--r--  2.0 fat      610 b- defN 80-Jan-01 00:00 depsland/depsolver/version_crawler.py
+-rw-r--r--  2.0 fat       60 b- defN 80-Jan-01 00:00 depsland/doctor/__init__.py
+-rw-r--r--  2.0 fat     1125 b- defN 80-Jan-01 00:00 depsland/doctor/pypi_index.py
+-rw-r--r--  2.0 fat     3554 b- defN 80-Jan-01 00:00 depsland/doctor.py
 -rw-r--r--  2.0 fat     2216 b- defN 80-Jan-01 00:00 depsland/launcher.py
--rw-r--r--  2.0 fat      434 b- defN 80-Jan-01 00:00 depsland/manifest/__init__.py
--rw-r--r--  2.0 fat     3073 b- defN 80-Jan-01 00:00 depsland/manifest/appinfo.py
--rw-r--r--  2.0 fat    17097 b- defN 80-Jan-01 00:00 depsland/manifest/manifest.py
--rw-r--r--  2.0 fat     4722 b- defN 80-Jan-01 00:00 depsland/normalization.py
--rw-r--r--  2.0 fat      120 b- defN 80-Jan-01 00:00 depsland/oss/__init__.py
--rw-r--r--  2.0 fat     1223 b- defN 80-Jan-01 00:00 depsland/oss/_base.py
--rw-r--r--  2.0 fat     1861 b- defN 80-Jan-01 00:00 depsland/oss/aliyun_oss.py
--rw-r--r--  2.0 fat      665 b- defN 80-Jan-01 00:00 depsland/oss/fake_oss.py
--rw-r--r--  2.0 fat      922 b- defN 80-Jan-01 00:00 depsland/oss/get_oss.py
--rw-r--r--  2.0 fat     1610 b- defN 80-Jan-01 00:00 depsland/oss/local_oss.py
--rw-r--r--  2.0 fat     8767 b- defN 80-Jan-01 00:00 depsland/paths.py
--rw-r--r--  2.0 fat     9463 b- defN 80-Jan-01 00:00 depsland/pip.py
--rw-r--r--  2.0 fat      104 b- defN 80-Jan-01 00:00 depsland/pypi/__init__.py
--rw-r--r--  2.0 fat     2250 b- defN 80-Jan-01 00:00 depsland/pypi/index.py
--rw-r--r--  2.0 fat    12073 b- defN 80-Jan-01 00:00 depsland/pypi/insight.py
--rw-r--r--  2.0 fat    12838 b- defN 80-Jan-01 00:00 depsland/pypi/pypi.py
--rw-r--r--  2.0 fat     1208 b- defN 80-Jan-01 00:00 depsland/system_info.py
--rw-r--r--  2.0 fat       34 b- defN 80-Jan-01 00:00 depsland/ui/__init__.py
--rw-r--r--  2.0 fat       29 b- defN 80-Jan-01 00:00 depsland/ui/appstore/__init__.py
--rw-r--r--  2.0 fat     7605 b- defN 80-Jan-01 00:00 depsland/ui/appstore/app.py
+-rw-r--r--  2.0 fat      335 b- defN 80-Jan-01 00:00 depsland/manifest/__init__.py
+-rw-r--r--  2.0 fat     3129 b- defN 80-Jan-01 00:00 depsland/manifest/appinfo.py
+-rw-r--r--  2.0 fat    20601 b- defN 80-Jan-01 00:00 depsland/manifest/manifest.py
+-rw-r--r--  2.0 fat     5968 b- defN 80-Jan-01 00:00 depsland/normalization.py
+-rw-r--r--  2.0 fat      117 b- defN 80-Jan-01 00:00 depsland/oss/__init__.py
+-rw-r--r--  2.0 fat     1173 b- defN 80-Jan-01 00:00 depsland/oss/_base.py
+-rw-r--r--  2.0 fat     2011 b- defN 80-Jan-01 00:00 depsland/oss/aliyun_oss.py
+-rw-r--r--  2.0 fat      648 b- defN 80-Jan-01 00:00 depsland/oss/fake_oss.py
+-rw-r--r--  2.0 fat      927 b- defN 80-Jan-01 00:00 depsland/oss/get_oss.py
+-rw-r--r--  2.0 fat     1570 b- defN 80-Jan-01 00:00 depsland/oss/local_oss.py
+-rw-r--r--  2.0 fat    10444 b- defN 80-Jan-01 00:00 depsland/paths.py
+-rw-r--r--  2.0 fat     8119 b- defN 80-Jan-01 00:00 depsland/pip.py
+-rw-r--r--  2.0 fat      144 b- defN 80-Jan-01 00:00 depsland/platform/__init__.py
+-rw-r--r--  2.0 fat      191 b- defN 80-Jan-01 00:00 depsland/platform/launcher/__init__.py
+-rw-r--r--  2.0 fat       31 b- defN 80-Jan-01 00:00 depsland/platform/launcher/make_app/__init__.py
+-rw-r--r--  2.0 fat     1726 b- defN 80-Jan-01 00:00 depsland/platform/launcher/make_app/make_app.py
+-rw-r--r--  2.0 fat      940 b- defN 80-Jan-01 00:00 depsland/platform/launcher/make_app/template/Contents/Info.plist
+-rw-r--r--  2.0 fat      439 b- defN 80-Jan-01 00:00 depsland/platform/launcher/make_app/template/Contents/MacOS/APP_NAME
+-rw-r--r--  2.0 fat     1244 b- defN 80-Jan-01 00:00 depsland/platform/launcher/make_bat.py
+-rw-r--r--  2.0 fat      223 b- defN 80-Jan-01 00:00 depsland/platform/launcher/make_exe/__init__.py
+-rw-r--r--  2.0 fat       98 b- defN 80-Jan-01 00:00 depsland/platform/launcher/make_exe/bat_2_exe_1/__init__.py
+-rw-r--r--  2.0 fat     3020 b- defN 80-Jan-01 00:00 depsland/platform/launcher/make_exe/bat_2_exe_1/main.py
+-rwx---     2.0 fat  1308672 b- defN 80-Jan-01 00:00 depsland/platform/launcher/make_exe/bat_2_exe_1/rcedit.exe
+-rwx---     2.0 fat    65308 b- defN 80-Jan-01 00:00 depsland/platform/launcher/make_exe/bat_2_exe_1/template.exe
+-rwx---     2.0 fat  2480973 b- defN 80-Jan-01 00:00 depsland/platform/launcher/make_exe/bat_2_exe_1/template_static.exe
+-rw-r--r--  2.0 fat       28 b- defN 80-Jan-01 00:00 depsland/platform/launcher/make_exe/bat_2_exe_2/__init__.py
+-rwx---     2.0 fat  1145344 b- defN 80-Jan-01 00:00 depsland/platform/launcher/make_exe/bat_2_exe_2/b2e.exe
+-rw-r--r--  2.0 fat     1622 b- defN 80-Jan-01 00:00 depsland/platform/launcher/make_exe/bat_2_exe_2/main.py
+-rw-r--r--  2.0 fat     1211 b- defN 80-Jan-01 00:00 depsland/platform/launcher/make_exe/make_exe.py
+-rw-r--r--  2.0 fat     3829 b- defN 80-Jan-01 00:00 depsland/platform/launcher/make_exe/readme.zh.md
+-rw-r--r--  2.0 fat     1264 b- defN 80-Jan-01 00:00 depsland/platform/launcher/make_launcher.py
+-rw-r--r--  2.0 fat     1256 b- defN 80-Jan-01 00:00 depsland/platform/launcher/make_shell.py
+-rw-r--r--  2.0 fat     1328 b- defN 80-Jan-01 00:00 depsland/platform/launcher/make_shortcut.py
+-rw-r--r--  2.0 fat     1346 b- defN 80-Jan-01 00:00 depsland/platform/system_info.py
+-rw-r--r--  2.0 fat      122 b- defN 80-Jan-01 00:00 depsland/pypi/__init__.py
+-rw-r--r--  2.0 fat     4698 b- defN 80-Jan-01 00:00 depsland/pypi/index.py
+-rw-r--r--  2.0 fat    10491 b- defN 80-Jan-01 00:00 depsland/pypi/insight.py
+-rw-r--r--  2.0 fat     7788 b- defN 80-Jan-01 00:00 depsland/pypi/pypi.py
+-rw-r--r--  2.0 fat       33 b- defN 80-Jan-01 00:00 depsland/ui/__init__.py
+-rw-r--r--  2.0 fat       28 b- defN 80-Jan-01 00:00 depsland/ui/appstore/__init__.py
+-rw-r--r--  2.0 fat     7376 b- defN 80-Jan-01 00:00 depsland/ui/appstore/app.py
 -rw-r--r--  2.0 fat      395 b- defN 80-Jan-01 00:00 depsland/ui/appstore/qml/Assets/refresh-line.svg
--rw-r--r--  2.0 fat     3226 b- defN 80-Jan-01 00:00 depsland/ui/appstore/qml/Home.qml
+-rw-r--r--  2.0 fat     3110 b- defN 80-Jan-01 00:00 depsland/ui/appstore/qml/Home.qml
 -rw-r--r--  2.0 fat    18664 b- defN 80-Jan-01 00:00 depsland/ui/launcher.ico
 -rw-r--r--  2.0 fat        0 b- defN 80-Jan-01 00:00 depsland/ui/setup_wizard/__init__.py
 -rw-r--r--  2.0 fat        0 b- defN 80-Jan-01 00:00 depsland/ui/setup_wizard/app.py
--rw-r--r--  2.0 fat       76 b- defN 80-Jan-01 00:00 depsland/ui/setup_wizard/qml/Main.qml
--rw-r--r--  2.0 fat      439 b- defN 80-Jan-01 00:00 depsland/utils/__init__.py
--rw-r--r--  2.0 fat     2173 b- defN 80-Jan-01 00:00 depsland/utils/chore.py
--rw-r--r--  2.0 fat      623 b- defN 80-Jan-01 00:00 depsland/utils/gen_exe/__init__.py
--rw-r--r--  2.0 fat      101 b- defN 80-Jan-01 00:00 depsland/utils/gen_exe/b2e_a/__init__.py
--rw-r--r--  2.0 fat     2684 b- defN 80-Jan-01 00:00 depsland/utils/gen_exe/b2e_a/main.py
--rwx---     2.0 fat  1308672 b- defN 80-Jan-01 00:00 depsland/utils/gen_exe/b2e_a/rcedit.exe
--rwx---     2.0 fat    65308 b- defN 80-Jan-01 00:00 depsland/utils/gen_exe/b2e_a/template.exe
--rwx---     2.0 fat  2480973 b- defN 80-Jan-01 00:00 depsland/utils/gen_exe/b2e_a/template_static.exe
--rw-r--r--  2.0 fat       29 b- defN 80-Jan-01 00:00 depsland/utils/gen_exe/b2e_b/__init__.py
--rwx---     2.0 fat  1145344 b- defN 80-Jan-01 00:00 depsland/utils/gen_exe/b2e_b/b2e.exe
--rw-r--r--  2.0 fat     1833 b- defN 80-Jan-01 00:00 depsland/utils/gen_exe/b2e_b/main.py
--rw-r--r--  2.0 fat     3849 b- defN 80-Jan-01 00:00 depsland/utils/gen_exe/readme.zh.md
--rw-r--r--  2.0 fat     1374 b- defN 80-Jan-01 00:00 depsland/utils/gen_exe/shortcut.py
--rw-r--r--  2.0 fat     3601 b- defN 80-Jan-01 00:00 depsland/utils/mklink.py
--rw-r--r--  2.0 fat     3105 b- defN 80-Jan-01 00:00 depsland/utils/verspec.py
--rw-r--r--  2.0 fat     3241 b- defN 80-Jan-01 00:00 depsland/utils/ziptool.py
--rw-r--r--  2.0 fat      102 b- defN 80-Jan-01 00:00 depsland/venv/__init__.py
--rw-r--r--  2.0 fat     2297 b- defN 80-Jan-01 00:00 depsland/venv/create.py
--rw-r--r--  2.0 fat     3153 b- defN 80-Jan-01 00:00 depsland/venv/emerge.py
--rw-r--r--  2.0 fat       55 b- defN 80-Jan-01 00:00 depsland-0.6.1.dist-info/entry_points.txt
--rw-r--r--  2.0 fat     1086 b- defN 80-Jan-01 00:00 depsland-0.6.1.dist-info/LICENSE
--rw-r--r--  2.0 fat      771 b- defN 80-Jan-01 00:00 depsland-0.6.1.dist-info/METADATA
--rw-r--r--  2.0 fat       88 b- defN 80-Jan-01 00:00 depsland-0.6.1.dist-info/WHEEL
-?rw-r--r--  2.0 fat     6259 b- defN 16-Jan-01 00:00 depsland-0.6.1.dist-info/RECORD
-74 files, 9733070 bytes uncompressed, 5055143 bytes compressed:  48.1%
+-rw-r--r--  2.0 fat       69 b- defN 80-Jan-01 00:00 depsland/ui/setup_wizard/qml/Main.qml
+-rw-r--r--  2.0 fat      405 b- defN 80-Jan-01 00:00 depsland/utils/__init__.py
+-rw-r--r--  2.0 fat      350 b- defN 80-Jan-01 00:00 depsland/utils/compat_py38.py
+-rw-r--r--  2.0 fat     3081 b- defN 80-Jan-01 00:00 depsland/utils/fs.py
+-rw-r--r--  2.0 fat     3287 b- defN 80-Jan-01 00:00 depsland/utils/mklink.py
+-rw-r--r--  2.0 fat     3850 b- defN 80-Jan-01 00:00 depsland/utils/ziptool.py
+-rw-r--r--  2.0 fat      233 b- defN 80-Jan-01 00:00 depsland/venv/__init__.py
+-rw-r--r--  2.0 fat     2219 b- defN 80-Jan-01 00:00 depsland/venv/create.py
+-rw-r--r--  2.0 fat     3484 b- defN 80-Jan-01 00:00 depsland/venv/emerge.py
+-rw-r--r--  2.0 fat      228 b- defN 80-Jan-01 00:00 depsland/venv/target_venv/__init__.py
+-rw-r--r--  2.0 fat     4028 b- defN 80-Jan-01 00:00 depsland/venv/target_venv/finder.py
+-rw-r--r--  2.0 fat     1528 b- defN 80-Jan-01 00:00 depsland/venv/target_venv/funcs.py
+-rw-r--r--  2.0 fat    12480 b- defN 80-Jan-01 00:00 depsland/venv/target_venv/indexer.py
+-rw-r--r--  2.0 fat        0 b- defN 80-Jan-01 00:00 depsland/venv/vendor_venv/__init__.py
+-rw-r--r--  2.0 fat     3942 b- defN 80-Jan-01 00:00 depsland/verspec.py
+-rw-r--r--  2.0 fat       65 b- defN 80-Jan-01 00:00 depsland/webui/__init__.py
+-rw-r--r--  2.0 fat     2039 b- defN 80-Jan-01 00:00 depsland/webui/app_st.py
+-rw-r--r--  2.0 fat     3196 b- defN 80-Jan-01 00:00 depsland/webui/bottom_bar.py
+-rw-r--r--  2.0 fat     6492 b- defN 80-Jan-01 00:00 depsland/webui/installed_apps.py
+-rw-r--r--  2.0 fat     4207 b- defN 80-Jan-01 00:00 depsland/webui/progress_bar.py
+-rw-r--r--  2.0 fat      730 b- defN 80-Jan-01 00:00 depsland/webui/settings.py
+-rw-r--r--  2.0 fat       55 b- defN 80-Jan-01 00:00 depsland-0.7.0.dist-info/entry_points.txt
+-rw-r--r--  2.0 fat     1086 b- defN 80-Jan-01 00:00 depsland-0.7.0.dist-info/LICENSE
+-rw-r--r--  2.0 fat     1408 b- defN 80-Jan-01 00:00 depsland-0.7.0.dist-info/METADATA
+-rw-r--r--  2.0 fat       88 b- defN 80-Jan-01 00:00 depsland-0.7.0.dist-info/WHEEL
+?rw-r--r--  2.0 fat     9094 b- defN 16-Jan-01 00:00 depsland-0.7.0.dist-info/RECORD
+102 files, 7162644 bytes uncompressed, 3181103 bytes compressed:  55.6%
```

## zipnote {}

```diff
@@ -33,44 +33,62 @@
 
 Filename: depsland/api/user_api/__init__.py
 Comment: 
 
 Filename: depsland/api/user_api/install.py
 Comment: 
 
+Filename: depsland/api/user_api/run.py
+Comment: 
+
 Filename: depsland/api/user_api/uninstall.py
 Comment: 
 
 Filename: depsland/chore/build.zip
 Comment: 
 
-Filename: depsland/chore/conf.zip
+Filename: depsland/chore/config.zip
 Comment: 
 
 Filename: depsland/chore/readme.md
 Comment: 
 
 Filename: depsland/chore/sidework.zip
 Comment: 
 
 Filename: depsland/config.py
 Comment: 
 
+Filename: depsland/depsolver/__init__.py
+Comment: 
+
+Filename: depsland/depsolver/poetry_lock_resolver.py
+Comment: 
+
+Filename: depsland/depsolver/poetry_lock_resolver_2.py
+Comment: 
+
+Filename: depsland/depsolver/requirements_lock.py
+Comment: 
+
+Filename: depsland/depsolver/resolver.py
+Comment: 
+
+Filename: depsland/depsolver/version_crawler.py
+Comment: 
+
 Filename: depsland/doctor/__init__.py
 Comment: 
 
 Filename: depsland/doctor/pypi_index.py
 Comment: 
 
 Filename: depsland/doctor.py
 Comment: 
 
-Filename: depsland/downloader.py
-Comment: 
-
 Filename: depsland/launcher.py
 Comment: 
 
 Filename: depsland/manifest/__init__.py
 Comment: 
 
 Filename: depsland/manifest/appinfo.py
@@ -102,29 +120,92 @@
 
 Filename: depsland/paths.py
 Comment: 
 
 Filename: depsland/pip.py
 Comment: 
 
+Filename: depsland/platform/__init__.py
+Comment: 
+
+Filename: depsland/platform/launcher/__init__.py
+Comment: 
+
+Filename: depsland/platform/launcher/make_app/__init__.py
+Comment: 
+
+Filename: depsland/platform/launcher/make_app/make_app.py
+Comment: 
+
+Filename: depsland/platform/launcher/make_app/template/Contents/Info.plist
+Comment: 
+
+Filename: depsland/platform/launcher/make_app/template/Contents/MacOS/APP_NAME
+Comment: 
+
+Filename: depsland/platform/launcher/make_bat.py
+Comment: 
+
+Filename: depsland/platform/launcher/make_exe/__init__.py
+Comment: 
+
+Filename: depsland/platform/launcher/make_exe/bat_2_exe_1/__init__.py
+Comment: 
+
+Filename: depsland/platform/launcher/make_exe/bat_2_exe_1/main.py
+Comment: 
+
+Filename: depsland/platform/launcher/make_exe/bat_2_exe_1/rcedit.exe
+Comment: 
+
+Filename: depsland/platform/launcher/make_exe/bat_2_exe_1/template.exe
+Comment: 
+
+Filename: depsland/platform/launcher/make_exe/bat_2_exe_1/template_static.exe
+Comment: 
+
+Filename: depsland/platform/launcher/make_exe/bat_2_exe_2/__init__.py
+Comment: 
+
+Filename: depsland/platform/launcher/make_exe/bat_2_exe_2/b2e.exe
+Comment: 
+
+Filename: depsland/platform/launcher/make_exe/bat_2_exe_2/main.py
+Comment: 
+
+Filename: depsland/platform/launcher/make_exe/make_exe.py
+Comment: 
+
+Filename: depsland/platform/launcher/make_exe/readme.zh.md
+Comment: 
+
+Filename: depsland/platform/launcher/make_launcher.py
+Comment: 
+
+Filename: depsland/platform/launcher/make_shell.py
+Comment: 
+
+Filename: depsland/platform/launcher/make_shortcut.py
+Comment: 
+
+Filename: depsland/platform/system_info.py
+Comment: 
+
 Filename: depsland/pypi/__init__.py
 Comment: 
 
 Filename: depsland/pypi/index.py
 Comment: 
 
 Filename: depsland/pypi/insight.py
 Comment: 
 
 Filename: depsland/pypi/pypi.py
 Comment: 
 
-Filename: depsland/system_info.py
-Comment: 
-
 Filename: depsland/ui/__init__.py
 Comment: 
 
 Filename: depsland/ui/appstore/__init__.py
 Comment: 
 
 Filename: depsland/ui/appstore/app.py
@@ -147,77 +228,80 @@
 
 Filename: depsland/ui/setup_wizard/qml/Main.qml
 Comment: 
 
 Filename: depsland/utils/__init__.py
 Comment: 
 
-Filename: depsland/utils/chore.py
+Filename: depsland/utils/compat_py38.py
+Comment: 
+
+Filename: depsland/utils/fs.py
 Comment: 
 
-Filename: depsland/utils/gen_exe/__init__.py
+Filename: depsland/utils/mklink.py
 Comment: 
 
-Filename: depsland/utils/gen_exe/b2e_a/__init__.py
+Filename: depsland/utils/ziptool.py
 Comment: 
 
-Filename: depsland/utils/gen_exe/b2e_a/main.py
+Filename: depsland/venv/__init__.py
 Comment: 
 
-Filename: depsland/utils/gen_exe/b2e_a/rcedit.exe
+Filename: depsland/venv/create.py
 Comment: 
 
-Filename: depsland/utils/gen_exe/b2e_a/template.exe
+Filename: depsland/venv/emerge.py
 Comment: 
 
-Filename: depsland/utils/gen_exe/b2e_a/template_static.exe
+Filename: depsland/venv/target_venv/__init__.py
 Comment: 
 
-Filename: depsland/utils/gen_exe/b2e_b/__init__.py
+Filename: depsland/venv/target_venv/finder.py
 Comment: 
 
-Filename: depsland/utils/gen_exe/b2e_b/b2e.exe
+Filename: depsland/venv/target_venv/funcs.py
 Comment: 
 
-Filename: depsland/utils/gen_exe/b2e_b/main.py
+Filename: depsland/venv/target_venv/indexer.py
 Comment: 
 
-Filename: depsland/utils/gen_exe/readme.zh.md
+Filename: depsland/venv/vendor_venv/__init__.py
 Comment: 
 
-Filename: depsland/utils/gen_exe/shortcut.py
+Filename: depsland/verspec.py
 Comment: 
 
-Filename: depsland/utils/mklink.py
+Filename: depsland/webui/__init__.py
 Comment: 
 
-Filename: depsland/utils/verspec.py
+Filename: depsland/webui/app_st.py
 Comment: 
 
-Filename: depsland/utils/ziptool.py
+Filename: depsland/webui/bottom_bar.py
 Comment: 
 
-Filename: depsland/venv/__init__.py
+Filename: depsland/webui/installed_apps.py
 Comment: 
 
-Filename: depsland/venv/create.py
+Filename: depsland/webui/progress_bar.py
 Comment: 
 
-Filename: depsland/venv/emerge.py
+Filename: depsland/webui/settings.py
 Comment: 
 
-Filename: depsland-0.6.1.dist-info/entry_points.txt
+Filename: depsland-0.7.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: depsland-0.6.1.dist-info/LICENSE
+Filename: depsland-0.7.0.dist-info/LICENSE
 Comment: 
 
-Filename: depsland-0.6.1.dist-info/METADATA
+Filename: depsland-0.7.0.dist-info/METADATA
 Comment: 
 
-Filename: depsland-0.6.1.dist-info/WHEEL
+Filename: depsland-0.7.0.dist-info/WHEEL
 Comment: 
 
-Filename: depsland-0.6.1.dist-info/RECORD
+Filename: depsland-0.7.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## depsland/__init__.py

```diff
@@ -1,23 +1,36 @@
-if True:
-    import lk_logger
-    lk_logger.setup(quiet=True, show_varnames=True, async_=False)
-
-from . import api
-from . import config
-from . import launcher
-from . import manifest
-from . import paths
-from . import system_info
-from . import utils
-from . import venv
-from .api import init
-from .api import install
-from .api import publish
-from .pip import Pip
-from .pip import pip
-from .pypi import pypi
-from .pypi import rebuild_index as rebuild_pypi_index
-from .utils import bat_2_exe
-
-__version__ = '0.6.1'
-__date__ = '2023-10-07'
+if 1:
+    import os.path
+    import sys
+    _parent_dir = os.path.abspath(f'{__file__}/../..')
+    if sys.base_prefix.startswith(_parent_dir):
+        # we are using an exclusive python interpreter vendored by depsland.
+        # since the interpreter is clean and no third party packages -
+        # installed, we need to locate another place to find the site-packages.
+        assert os.path.exists(x := f'{_parent_dir}/chore/site_packages'), \
+            'see `DEVNOTE.md : search "make site-packages"` for help.'
+        sys.path.append(x)
+
+if 2:
+    import lk_logger
+    lk_logger.setup(quiet=True, show_funcname=False, show_varnames=True)
+
+from . import api
+from . import config
+from . import launcher
+from . import manifest
+from . import paths
+from . import utils
+from . import venv
+from . import verspec
+# from . import webui
+from .api import init
+from .api import install
+from .api import publish
+from .pip import pip
+from .platform import sysinfo
+from .platform.launcher import bat_2_exe
+from .platform.launcher import create_launcher
+from .pypi import pypi
+
+__version__ = '0.7.0'
+__date__ = '2024-05-23'
```

## depsland/__main__.py

```diff
@@ -1,412 +1,438 @@
-import os
-import sys
-import typing as t
-from os.path import exists
-
-from argsense import CommandLineInterface
-from lk_utils import fs
-
-from . import __path__
-from . import __version__
-from . import api
-from . import paths
-from . import system_info as sysinfo
-from .manifest import T
-from .manifest import get_last_installed_version
-
-# fix sys.argv
-if len(sys.argv) > 1 and sys.argv[1].endswith('.exe'):
-    # e.g. ['E:\depsland_app\depsland\__main__.py',
-    #       'E:\depsland_app\depsland.exe', ...]
-    sys.argv.pop(1)
-
-cli = CommandLineInterface('depsland')
-print('depsland [red][dim]v[/]{}[/] [dim]({})[/]'.format(
-    __version__, __path__[0]
-), ':r')
-
-
-@cli.cmd()
-def version() -> None:
-    """
-    show basic information about depsland.
-    """
-    # ref: the rich text (with gradient color) effect is copied from
-    #   likianta/lk-logger project.
-    from lk_logger.control import _blend_text  # noqa
-    from random import choice
-    from . import __date__, __path__, __version__
-    
-    color_pairs_group = (
-        ('#0a87ee', '#9294f0'),  # calm blue -> light blue
-        ('#2d34f1', '#9294f0'),  # ocean blue -> light blue
-        ('#ed3b3b', '#d08bf3'),  # rose red -> violet
-        ('#f38cfd', '#d08bf3'),  # light magenta -> violet
-        ('#f47fa4', '#f49364'),  # cold sandy -> camel tan
-    )
-    
-    color_pair = choice(color_pairs_group)
-    colorful_title = _blend_text(
-        '♥ depsland v{} ♥'.format(__version__), color_pair
-    )
-    print(f'[b]{colorful_title}[/]', ':rs1')
-    
-    print(':rs1', '[cyan]released at [u]{}[/][/]'.format(__date__))
-    print(':rs1', '[magenta]located at [u]{}[/][/]'.format(__path__[0]))
-
-
-@cli.cmd()
-def welcome(confirm_close=False) -> None:
-    """
-    show welcome message and exit.
-    """
-    from lk_logger.console import console
-    from rich.markdown import Markdown
-    from textwrap import dedent
-    from . import __date__
-    from . import __version__
-    
-    console.print(Markdown(dedent('''
-        # Depsland
-
-        Depsland is a python apps manager for non-developer users.
-        
-        - Version: {}
-        - Release date: {}
-        - Author: {}
-        - Official website: {}
-    ''').format(
-        __version__,
-        __date__,
-        'Likianta <likianta@foxmail.com>',
-        'https://github.com/likianta/depsland'
-    )))
-    
-    if confirm_close:
-        input('press enter to close window...')
-
-
-@cli.cmd()
-def launch_gui(_app_token: str = None, _run_at_once: bool = False) -> None:
-    """
-    launch depsland gui.
-    
-    kwargs:
-        _app_token: an appid or a path to a manifest file.
-            if given, the app will launch and instantly install it.
-        _run_at_once:
-            for `true` example, see `./api/dev_api/publish.py : main() : -
-            \\[var] command`
-            for `false` example, see `./api/dev_api/offline_build.py : -
-            _create_updator()`
-    """
-    # import os
-    # os.environ['QT_API'] = 'pyside6_lite'
-    try:
-        import qmlease
-    except ModuleNotFoundError:
-        print('launching GUI failed. you may forget to install qt for python '
-              'library (suggest `pip install pyside6` etc.)', ':v4')
-        return
-    
-    if sysinfo.platform.IS_WINDOWS:
-        _toast_notification('Depsland is launching')
-    
-    if _app_token and os.path.isfile(_app_token):
-        _app_token = fs.abspath(_app_token)
-    # if _run_at_once is None:
-    #     _run_at_once = bool(_app_token)
-    
-    from .ui import launch_app
-    launch_app(_app_token, _run_at_once)
-
-
-# -----------------------------------------------------------------------------
-# ordered by lifecycle
-
-@cli.cmd()
-def init(manifest='.', app_name='', overwrite=False,
-         auto_find_requirements=False) -> None:
-    """
-    create a "manifest.json" file in project directory.
-    
-    kwargs:
-        manifest (-m): if directory of manifest not exists, it will be created.
-        app_name (-n): if not given, will use directory name as app name.
-        auto_find_requirements (-a):
-        overwrite (-w):
-    """
-    api.init(_fix_manifest_param(manifest), app_name, overwrite,
-             auto_find_requirements)
-
-
-@cli.cmd()
-def build(
-    manifest: str = '.',
-    offline: bool = False,
-    gen_exe: bool = True
-) -> None:
-    """
-    build your python application based on manifest file.
-    the build result is stored in "dist" directory.
-    [dim]if "dist" not exists, it will be auto created.[/]
-    
-    kwargs:
-        manifest (-m): a path to the project directory (suggested) or to a -
-            mainfest file.
-            if project directory is given, will search 'manifest.json' file -
-            under this dir.
-            [red dim]╰─ if no such file found, will raise a FileNotFound -
-            error.[/]
-            if a file is given, it must be '.json' type. depsland will treat -
-            its folder as the project directory.
-            [blue dim]╰─ if a file is given, the file name could be custom. -
-            (we suggest using 'manifest.json' as canondical.)[/]
-    """
-    if offline:
-        api.build_offline(_fix_manifest_param(manifest))
-    else:
-        api.build(_fix_manifest_param(manifest), gen_exe)
-
-
-@cli.cmd()
-def publish(manifest='.', full_upload=False) -> None:
-    """
-    publish dist assets to oss.
-    if you configured a local oss server, it will generate assets to -
-    `~/oss/apps/<appid>/<version>` directory.
-    
-    kwargs:
-        full_upload (-f): if true, will upload all assets, ignore the files -
-            which may already exist in oss (they all will be overwritten).
-            this option is useful if you found the oss server not work properly.
-    """
-    api.publish(_fix_manifest_param(manifest), full_upload)
-
-
-@cli.cmd()
-def install(appid: str, upgrade=True, reinstall=False) -> None:
-    """
-    install an app from oss by querying appid.
-    
-    kwargs:
-        upgrade (-u):
-        reinstall (-r):
-    """
-    api.install_by_appid(appid, upgrade, reinstall)
-
-
-@cli.cmd()
-def upgrade(appid: str) -> None:
-    """
-    upgrade an app from oss by querying appid.
-    """
-    api.install_by_appid(appid, upgrade=True, reinstall=False)
-
-
-@cli.cmd()
-def uninstall(appid: str, version: str = None) -> None:
-    """
-    uninstall an application.
-    """
-    if version is None:
-        version = get_last_installed_version(appid)
-    if version is None:
-        print(f'{appid} is already uninstalled.')
-        return
-    api.uninstall(appid, version)
-
-
-# @cli.cmd()
-# def self_upgrade() -> None:
-#     """
-#     upgrade depsland itself.
-#     """
-#     api.self_upgrade()
-
-
-# -----------------------------------------------------------------------------
-
-@cli.cmd()
-def show(appid: str, version: str = None) -> None:
-    """
-    show manifest of an app.
-    """
-    from .manifest import load_manifest
-    if version is None:
-        version = get_last_installed_version(appid)
-    assert version is not None
-    dir_ = '{}/{}/{}'.format(paths.project.apps, appid, version)
-    manifest = load_manifest(f'{dir_}/manifest.pkl')
-    print(manifest, ':l')
-
-
-@cli.cmd()
-def view_manifest(manifest: str = '.') -> None:
-    from .manifest import load_manifest
-    manifest = load_manifest(_fix_manifest_param(manifest))
-    print(manifest, ':l')
-
-
-@cli.cmd(transport_help=True)
-def run(appid: str, *args, _version: str = None, **kwargs) -> None:
-    """
-    a general launcher to start an installed app.
-    """
-    print(sys.argv, ':lv')
-    
-    version = _version or get_last_installed_version(appid)
-    if not version:
-        print(':v4', f'cannot find installed version of {appid}')
-        return
-    
-    import lk_logger
-    import subprocess
-    from argsense import args_2_cargs
-    from .manifest import load_manifest
-    from .manifest import parse_script_info
-    
-    manifest = load_manifest('{}/{}/{}/manifest.pkl'.format(
-        paths.project.apps, appid, version
-    ))
-    assert manifest['version'] == version
-    command = parse_script_info(manifest)
-    os.environ['DEPSLAND'] = paths.project.root
-    os.environ['PYTHONPATH'] = '.;{app_dir};{pkg_dir}'.format(
-        app_dir=manifest['start_directory'],
-        pkg_dir=paths.apps.get_packages(appid, version)
-    )
-    
-    if not manifest['launcher']['show_console']:
-        if sysinfo.platform.IS_WINDOWS:
-            _toast_notification(
-                'Depsland is launching "{}"'.format(manifest['name'])
-            )
-    
-    # print(':v', args, kwargs)
-    lk_logger.unload()
-    try:
-        subprocess.run(
-            (*command, *args_2_cargs(*args, **kwargs)),
-            check=True,
-            cwd=manifest['start_directory'],
-            stderr=subprocess.PIPE,
-            text=True,
-        )
-    except subprocess.CalledProcessError as e:
-        lk_logger.enable()
-        print(':v4f', '\n' + (e.stderr or '').replace('\r', ''))
-        if manifest['launcher']['show_console']:
-            # raise e
-            input('press enter to close window... ')
-        else:
-            _toast_notification(
-                'Exception occurred at "{}"!'.format(manifest['name'])
-            )
-
-
-# -----------------------------------------------------------------------------
-
-@cli.cmd()
-def rebuild_pypi_index(full: bool = False) -> None:
-    """
-    rebuild local pypi index. this may resolve some historical problems caused -
-    by pip network issues.
-    
-    kwargs:
-        full (-f): if a package is downloaded but not installed, will perform -
-            a `pip install` action.
-    """
-    from .doctor import rebuild_pypi_index
-    rebuild_pypi_index(perform_pip_install=full)
-
-
-@cli.cmd()
-def get_package_size(
-        name: str,
-        version: str = None,
-        include_dependencies: bool = False
-) -> None:
-    """
-    kwargs:
-        include_dependencies (-d):
-    """
-    from .pypi import insight
-    insight.measure_package_size(name, version, include_dependencies)
-
-
-# -----------------------------------------------------------------------------
-
-def _check_version(new: T.Manifest, old: T.Manifest) -> bool:
-    from .utils import compare_version
-    return compare_version(new['version'], '>', old['version'])
-
-
-def _fix_manifest_param(manifest: str) -> str:  # return a file path to manifest
-    if os.path.isdir(manifest):
-        out = fs.normpath(f'{manifest}/manifest.json', True)
-    else:
-        out = fs.normpath(manifest, True)
-        assert exists(out), f'path not exists: {out}'
-    # print(':v', out)
-    return out
-
-
-def _get_dir_to_last_installed_version(appid: str) -> t.Optional[str]:
-    if last_ver := get_last_installed_version(appid):
-        dir_ = '{}/{}/{}'.format(paths.project.apps, appid, last_ver)
-        assert exists(dir_), dir_
-        return dir_
-    return None
-
-
-def _get_manifests(appid: str) -> t.Tuple[t.Optional[T.Manifest], T.Manifest]:
-    from .manifest import change_start_directory
-    from .manifest import init_target_tree
-    from .manifest import load_manifest
-    from .oss import get_oss_client
-    from .utils import make_temp_dir
-    
-    temp_dir = make_temp_dir()
-    
-    oss = get_oss_client(appid)
-    oss.download(oss.path.manifest, x := f'{temp_dir}/manifest.pkl')
-    manifest_new = load_manifest(x)
-    change_start_directory(manifest_new, '{}/{}/{}'.format(
-        paths.project.apps,
-        manifest_new['appid'],
-        manifest_new['version']
-    ))
-    init_target_tree(manifest_new)
-    fs.move(x, manifest_new['start_directory'] + '/manifest.pkl')
-    
-    if x := _get_dir_to_last_installed_version(appid):
-        manifest_old = load_manifest(f'{x}/manifest.pkl')
-    else:
-        print('no previous version found, it may be your first time to install '
-              f'{appid}')
-        print('[dim]be noted the first-time installation may consume a long '
-              'time. depsland will try to reduce the consumption in the '
-              'succeeding upgrades/installations.[/]', ':r')
-        manifest_old = None
-    
-    return manifest_old, manifest_new
-
-
-def _run_cli() -> None:
-    """ this function is for poetry to generate script entry point. """
-    cli.run()
-
-
-# windows only
-def _toast_notification(text: str) -> None:
-    from windows_toasts import Toast
-    from windows_toasts import WindowsToaster
-    toaster = WindowsToaster('Depsland Launcher')
-    toast = Toast()
-    toast.text_fields = [text]
-    toaster.show_toast(toast)
-
-
-if __name__ == '__main__':
-    cli.run()
+if __name__ == '__main__':
+    __package__ = 'depsland'
+
+import os
+import sys
+import typing as t
+from os.path import exists
+
+import pyapp_window
+from argsense import CommandLineInterface
+from lk_utils import fs
+from lk_utils import run_cmd_args
+
+from . import __path__
+from . import __version__
+from . import api
+from . import paths
+from .manifest import T
+from .manifest import get_last_installed_version
+from .normalization import check_name_normalized
+
+# fix sys.argv
+if len(sys.argv) > 1 and sys.argv[1].endswith('.exe'):
+    # e.g. ['E:\depsland_app\depsland\__main__.py',
+    #       'E:\depsland_app\depsland.exe', ...]
+    sys.argv.pop(1)
+
+cli = CommandLineInterface('depsland')
+print(
+    'depsland [red][dim]v[/]{}[/] [dim]({})[/]'.format(
+        __version__, __path__[0]
+    ), ':r'
+)
+
+
+@cli.cmd()
+def about() -> None:
+    """
+    show basic information about depsland.
+    """
+    # ref: the rich text (with gradient color) effect is copied from
+    #   likianta/lk-logger project.
+    from random import choice
+    
+    from lk_logger.control import _blend_text  # noqa
+    
+    from . import __date__
+    from . import __path__
+    from . import __version__
+    
+    color_pairs_group = (
+        ('#0a87ee', '#9294f0'),  # calm blue -> light blue
+        ('#2d34f1', '#9294f0'),  # ocean blue -> light blue
+        ('#ed3b3b', '#d08bf3'),  # rose red -> violet
+        ('#f38cfd', '#d08bf3'),  # light magenta -> violet
+        ('#f47fa4', '#f49364'),  # cold sandy -> camel tan
+    )
+    
+    color_pair = choice(color_pairs_group)
+    colorful_title = _blend_text(
+        '♥ depsland v{} ♥'.format(__version__), color_pair
+    )
+    print(f'[b]{colorful_title}[/]', ':rs1')
+    
+    print(':rs1', '[cyan]released at [u]{}[/][/]'.format(__date__))
+    print(':rs1', '[magenta]located at [u]{}[/][/]'.format(__path__[0]))
+
+
+@cli.cmd()
+def self_location() -> None:
+    print('[green b u]{}[/]'.format(fs.xpath('.', True)), ':s1r')
+
+
+@cli.cmd()
+def welcome(confirm_close: bool = False) -> None:
+    """
+    show welcome message and exit.
+    """
+    from rich.markdown import Markdown
+    from textwrap import dedent
+    from . import __date__
+    from . import __version__
+    
+    print(
+        ':r1',
+        Markdown(
+            dedent('''
+            # DEPSLAND
+            
+            Depsland is a python apps manager for non-developer users.
+            
+            - Version: {}
+            - Release date: {}
+            - Author: {}
+            - Official site: {}
+            ''').format(
+                __version__,
+                __date__,
+                'Likianta (likianta@foxmail.com)',
+                'https://github.com/likianta/depsland',
+            )
+        ),
+    )
+    
+    if confirm_close:
+        input('press enter to close window...')
+
+
+@cli.cmd()
+def launch_gui(
+    port: int = 2028,
+    _app_token: str = None,
+    _run_at_once: t.Optional[bool] = False,
+    _native_window: bool = True,
+    _user_call: bool = True,
+) -> None:
+    """
+    launch depsland gui.
+    
+    kwargs:
+        _app_token: an appid or a path to a manifest file.
+            if given, the app will launch and instantly install it.
+        _run_at_once:
+            for `true` example, see `./api/dev_api/publish.py : main() : -
+            \\[var] command`
+            for `false` example, see `./api/dev_api/offline_build.py : -
+            _create_updator()`
+    """
+    # print(_user_call, sys.argv, ':lv')
+    if _user_call:
+        proc = run_cmd_args(
+            (
+                sys.executable, '-m', 'streamlit', 'run',
+                'depsland/__main__.py',
+            ),
+            (
+                '--browser.gatherUsageStats', 'false',
+                '--global.developmentMode', 'false',
+                '--server.headless', 'true',
+                '--server.port', port,
+            ),
+            (
+                '--',
+                'launch-gui',
+                port,
+                _app_token or ':empty',
+                ':true' if _run_at_once else ':false',
+                '--not-user-call',
+            ),
+            blocking=not _native_window,
+            verbose=True,
+        )
+        if _native_window:
+            pyapp_window.launch(
+                'Depsland User Interface',
+                url=f'http://localhost:{port}',
+                copilot_backend=proc,
+                size=(1200, 2000),
+                icon=paths.build.launcher_icon,
+            )
+    else:
+        if _app_token == '""':  # FIXME: should be resolved in argsense library.
+            _app_token = ''
+        if _app_token and os.path.isfile(_app_token):
+            _app_token = fs.abspath(_app_token)
+            if _run_at_once is None:
+                _run_at_once = True
+        from .webui import setup_ui
+        setup_ui(_app_token, _run_at_once)
+    
+    # -------------------------------------------------------------------------
+    
+    # try:
+    #     os.environ['QT_API'] = 'pyside6_lite'
+    #     import pyside6_lite  # noqa
+    # except ModuleNotFoundError:
+    #     print(
+    #         'launching GUI failed. you may forget to install qt for python '
+    #         'library (suggest `pip install pyside6` etc.)',
+    #         ':v4',
+    #     )
+    #     return
+    #
+    # if sysinfo.IS_WINDOWS:
+    #     _toast_notification('Depsland is launching')
+    #
+    # if _app_token and os.path.isfile(_app_token):
+    #     _app_token = fs.abspath(_app_token)
+    # # if _run_at_once is None:
+    # #     _run_at_once = bool(_app_token)
+    #
+    # from .ui import launch_app
+    # launch_app(_app_token, _run_at_once)
+
+
+# -----------------------------------------------------------------------------
+# ordered by lifecycle
+
+
+@cli.cmd()
+def init(
+    target: str = '.',
+    app_name: str = '',
+    force_create: bool = False,
+    **kwargs,
+) -> None:
+    """
+    create a "manifest.json" file in project directory.
+    
+    kwargs:
+        target (-t): target directory.
+        app_name (-n): if not given, will use directory name as app name.
+        force_create (-f):
+    """
+    manifest_file = _get_manifest_path(target, ensure_exists=False)
+    api.init(manifest_file, app_name, force_create, **kwargs)
+
+
+@cli.cmd()
+def build(
+    manifest: str = '.',
+    offline: bool = False,
+    # gen_exe: bool = True,
+    # target_system: str = sysinfo.SYSTEM,
+) -> None:
+    """
+    build your python application based on manifest file.
+    the build result is stored in "dist" directory.
+    [dim i](if "dist" not exists, it will be auto created.)[/]
+    
+    kwargs:
+        manifest (-m): a path to the project directory (suggested) or to a -
+            mainfest file.
+            if project directory is given, will search 'manifest.json' file -
+            under this dir.
+            [red dim]╰─ if no such file found, will raise a FileNotFound -
+            error.[/]
+            if a file is given, it must be '.json' type. depsland will treat -
+            its folder as the project directory.
+            [blue dim]╰─ if a file is given, the file name could be custom. -
+            (we suggest using 'manifest.json' as canondical.)[/]
+    """
+    if offline:
+        api.build_offline(_get_manifest_path(manifest))
+    else:
+        api.build(_get_manifest_path(manifest))
+
+
+@cli.cmd()
+def publish(target='.', full_upload: bool = False) -> None:
+    """
+    publish dist assets to oss.
+    if you configured a local oss server, it will generate assets to -
+    `~/oss/apps/<appid>/<version>` directory.
+    
+    kwargs:
+        target (-t):
+        full_upload (-f): if true, will upload all assets, ignore the files -
+            which may already exist in oss (they all will be overwritten).
+            this option is useful if you found the oss server not work properly.
+    """
+    api.publish(_get_manifest_path(target), full_upload)
+
+
+@cli.cmd()
+def install(appid: str, upgrade: bool = True, reinstall: bool = False) -> None:
+    """
+    install an app from oss by querying appid.
+    
+    kwargs:
+        upgrade (-u):
+        reinstall (-r):
+    """
+    assert check_name_normalized(appid)
+    api.install_by_appid(appid, upgrade, reinstall)
+
+
+@cli.cmd()
+def upgrade(appid: str) -> None:
+    """
+    upgrade an app from oss by querying appid.
+    """
+    api.install_by_appid(appid, upgrade=True, reinstall=False)
+
+
+@cli.cmd()
+def uninstall(appid: str, version: str = None) -> None:
+    """
+    uninstall an application.
+    """
+    if version is None:
+        version = get_last_installed_version(appid)
+    if version is None:
+        print(f'{appid} is already uninstalled.')
+        return
+    api.uninstall(appid, version)
+
+
+# @cli.cmd()
+# def self_upgrade() -> None:
+#     """
+#     upgrade depsland itself.
+#     """
+#     api.self_upgrade()
+
+
+# -----------------------------------------------------------------------------
+
+
+@cli.cmd()
+def show(appid: str, version: str = None) -> None:
+    """
+    show manifest of an app.
+    """
+    from .manifest import load_manifest
+    
+    if version is None:
+        version = get_last_installed_version(appid)
+    assert version is not None
+    dir_ = '{}/{}/{}'.format(paths.project.apps, appid, version)
+    manifest = load_manifest(f'{dir_}/manifest.pkl')
+    print(manifest, ':l')
+
+
+@cli.cmd()
+def view_manifest(manifest: str = '.') -> None:
+    from .manifest import load_manifest
+    
+    manifest = load_manifest(_get_manifest_path(manifest))
+    print(manifest, ':l')
+
+
+cli.add_cmd(api.user_api.run_app, 'run', transport_help=True)
+
+# -----------------------------------------------------------------------------
+
+
+@cli.cmd()
+def rebuild_pypi_index(full: bool = False) -> None:
+    """
+    rebuild local pypi index. this may resolve some historical problems caused -
+    by pip network issues.
+    
+    kwargs:
+        full (-f): if a package is downloaded but not installed, will perform -
+            a `pip install` action.
+    """
+    from .doctor import rebuild_pypi_index
+    rebuild_pypi_index(perform_pip_install=full)
+
+
+@cli.cmd()
+def get_package_size(
+    name: str, version: str = None, include_dependencies: bool = False
+) -> None:
+    """
+    kwargs:
+        include_dependencies (-d):
+    """
+    from .pypi import insight
+    
+    insight.measure_package_size(name, version, include_dependencies)
+
+
+# -----------------------------------------------------------------------------
+
+
+def _check_version(new: T.Manifest, old: T.Manifest) -> bool:
+    from .verspec import compare_version
+    return compare_version(new['version'], '>', old['version'])
+
+
+def _get_dir_to_last_installed_version(appid: str) -> t.Optional[str]:
+    if last_ver := get_last_installed_version(appid):
+        dir_ = '{}/{}/{}'.format(paths.project.apps, appid, last_ver)
+        assert exists(dir_), dir_
+        return dir_
+    return None
+
+
+def _get_manifest_path(target: str, ensure_exists: bool = True) -> str:
+    """ return an abspath to manifest file. """
+    if target.endswith('.json'):
+        out = fs.normpath(target, True)
+    else:
+        assert not os.path.isfile(target)
+        if not os.path.exists(target):
+            os.mkdir(target)
+        out = fs.normpath(f'{target}/manifest.json', True)
+    if ensure_exists:
+        assert exists(out)
+    print(f'manifest file: {out}', ':pv')
+    return out
+
+
+def _get_manifests(appid: str) -> t.Tuple[t.Optional[T.Manifest], T.Manifest]:
+    from .manifest import load_manifest
+    from .oss import get_oss_client
+    from .utils import init_target_tree
+    from .utils import make_temp_dir
+    
+    temp_dir = make_temp_dir()
+    
+    oss = get_oss_client(appid)
+    oss.download(oss.path.manifest, x := f'{temp_dir}/manifest.pkl')
+    manifest_new = load_manifest(x)
+    manifest_new.start_directory = '{}/{}/{}'.format(
+        paths.project.apps, manifest_new['appid'], manifest_new['version']
+    )
+    init_target_tree(manifest_new)
+    fs.move(x, manifest_new['start_directory'] + '/manifest.pkl')
+    
+    if x := _get_dir_to_last_installed_version(appid):
+        manifest_old = load_manifest(f'{x}/manifest.pkl')
+    else:
+        print(
+            'no previous version found, it may be your first time to install '
+            f'{appid}'
+        )
+        print(
+            '[dim]be noted the first-time installation may consume a long '
+            'time. depsland will try to reduce the consumption in the '
+            'succeeding upgrades/installations.[/]',
+            ':r',
+        )
+        manifest_old = None
+    
+    return manifest_old, manifest_new
+
+
+def _run_cli() -> None:
+    """ this function is for poetry to generate script entry point. """
+    cli.run()
+
+
+if __name__ == '__main__':
+    # pox -m depsland launch-gui
+    cli.run()
```

## depsland/api/__init__.py

 * *Ordering differences only*

```diff
@@ -1,10 +1,10 @@
-from .dev_api import build
-from .dev_api import build_offline
-from .dev_api import init
-from .dev_api import publish
-from .dev_api import view_index
-from .self_api import upgrade as self_upgrade
-from .user_api import install
-from .user_api import install_by_appid
-from .user_api import install_local
-from .user_api import uninstall
+from .dev_api import build
+from .dev_api import build_offline
+from .dev_api import init
+from .dev_api import publish
+from .dev_api import view_index
+from .self_api import upgrade as self_upgrade
+from .user_api import install
+from .user_api import install_by_appid
+from .user_api import install_local
+from .user_api import uninstall
```

## depsland/api/dev_api/__init__.py

 * *Ordering differences only*

```diff
@@ -1,5 +1,5 @@
-from .build import build
-from .index import view_index
-from .init import init
-from .offline_build import main as build_offline
-from .publish import main as publish
+from .build import build
+from .index import view_index
+from .init import init
+from .offline_build import main as build_offline
+from .publish import main as publish
```

## depsland/api/dev_api/build.py

```diff
@@ -1,55 +1,29 @@
-from textwrap import dedent
-
-from lk_utils import dumps
 from lk_utils import fs
 
-from ...manifest import T
 from ...manifest import load_manifest
-from ...utils import bat_2_exe
+from ...platform import create_launcher
 
 
-def build(manifest_file: str, gen_exe=True) -> None:
+def build(manifest_file: str) -> None:
     """
     what does this function do:
         - create a dist folder
-        - create a launcher (exe or bat)
-    TODO: is this too simple?
+        - create a launcher (.exe or .sh)
     """
     manifest = load_manifest(manifest_file)
     
     dir_i = manifest['start_directory']
     dir_o = '{}/dist/{}-{}'.format(
         dir_i, manifest['appid'], manifest['version']
     )
     fs.make_dirs(dir_o)
     
-    _create_bat(manifest, f'{dir_o}/launcher.bat')
+    # FIXME
+    create_launcher(manifest, dir_o=dir_o)
     
-    if gen_exe:
-        bat_2_exe(
-            f'{dir_o}/launcher.bat',
-            f'{dir_o}/launcher.exe',
-            icon=manifest['launcher']['icon'],
-            remove_bat=True
+    print(
+        ':t',
+        'build done. see result in "dist/{}-{}"'.format(
+            manifest['appid'], manifest['version']
         )
-    
-    print(':t', 'build done. see result in "dist/{}-{}"'.format(
-        manifest['appid'], manifest['version']
-    ))
-
-
-def _create_bat(manifest: T.Manifest, file: str) -> None:
-    command = dedent('''
-        @echo off
-        set PYTHONPATH={app_dir};{pkg_dir}
-        {py} %*
-    ''').strip().format(
-        app_dir=r'{}\{}\{}'.format(
-            r'%DEPSLAND%\apps', manifest['appid'], manifest['version']
-        ),
-        pkg_dir=r'{}\.venv\{}'.format(
-            r'%DEPSLAND%\apps', manifest['appid']
-        ),
-        py=r'"%DEPSLAND%\python\python.exe"',
     )
-    dumps(command, file)
```

## depsland/api/dev_api/index.py

 * *Ordering differences only*

```diff
@@ -1,3 +1,3 @@
-def view_index(dir_i: str = None) -> None:
-    from ...pypi.insight import overview
-    overview(dir_i)
+def view_index(dir_i: str = None) -> None:
+    from ...pypi.insight import overview
+    overview(dir_i)
```

## depsland/api/dev_api/init.py

```diff
@@ -1,59 +1,146 @@
-import os
-import re
-from os.path import exists
-
-from lk_utils import dumps
-from lk_utils import fs
-from lk_utils import loads
-
-from ...manifest import T
-from ...manifest import init_manifest
-
-
-def init(
-        manifest_file: str = './manifest.json',
-        appname='',
-        overwrite=False,
-        auto_find_requirements=False
-):
-    # init/update parameters
-    filepath = fs.normpath(manifest_file, True)
-    dirpath = fs.parent_path(filepath)
-    dirname = fs.dirname(dirpath)
-    if appname == '':
-        appname = dirname.replace('-', ' ').replace('_', ' ').title()
-    appid = appname.replace(' ', '_').replace('-', '_').lower()
-    print(':v2f2', appname, appid)
-    
-    # check path exists
-    if not exists(dirpath):
-        os.mkdir(dirpath)
-    if exists(filepath):
-        if overwrite:
-            os.remove(filepath)
-        else:
-            r = input(f'target file ({filepath}) already exists, would '
-                      f'you like to overwrite it? (y/n): ')
-            if r == 'y':
-                os.remove(filepath)
-            else:
-                print('[dim]no file creates[/]', ':r')
-                return
-    
-    manifest: T.Manifest = init_manifest(appid, appname)
-    manifest.pop('start_directory')  # noqa
-    manifest['version'] = '0.1.0'
-    manifest['pypi'] = []
-    
-    if auto_find_requirements:
-        if exists(x := f'{dirpath}/requirements.txt'):
-            pattern = re.compile(r'([-\w]+)(.*)')
-            deps = manifest['dependencies']
-            for line in loads(x).splitlines():  # type: str
-                if line and not line.startswith('#'):
-                    name, ver = pattern.search(line).groups()
-                    deps[name] = ver.replace(' ', '')
-            print(deps, ':l')
-    
-    dumps(manifest, x := f'{dirpath}/manifest.json')
-    print(f'see manifest file at \n\t"{x}"')
+import os
+import sys
+import typing as t
+from os.path import exists
+
+from lk_utils import dumps
+from lk_utils import fs
+
+from ...manifest import T as T0
+from ...manifest import init_manifest
+
+
+class T(T0):
+    # ref: T0.Launcher0
+    TargetInfo = t.TypedDict(
+        'TargetInfo',
+        {
+            'target': str,  # relpath
+            'type': t.Literal['executable', 'module', 'package'],
+            'icon': str,  # relpath or empty
+        },
+    )
+
+
+def init(
+    manifest_file: str = './manifest.json',
+    appname: str = '',
+    force_create: bool = False,
+    **kwargs,
+) -> None:
+    # init/update parameters
+    file_o = fs.normpath(manifest_file, True)
+    del manifest_file
+    if exists(file_o):
+        if force_create:
+            os.remove(file_o)
+        else:
+            print(':v3s', 'target already exists! (stop processing)', file_o)
+            return
+    
+    dir_o = fs.parent_path(file_o)
+    if not exists(dir_o):
+        os.mkdir(dir_o)
+    
+    dirname = fs.dirname(dir_o)
+    if appname == '':
+        appname = dirname.replace('-', ' ').replace('_', ' ').title()
+    appid = appname.replace(' ', '_').replace('-', '_').lower()
+    print(':v2f2', appname, appid)
+    
+    manifest = init_user_manifest(dir_o, appname, appid, **kwargs)
+    
+    dumps(manifest, file_o)
+    print(f'see manifest file at \n\t"{file_o}"', ':tv2s')
+
+
+def init_user_manifest(
+    root: str, appname: str, appid: str, version: str = '0.1.0'
+) -> T.UserManifest:
+    manifest = init_manifest(appid, appname).model
+    
+    manifest.pop('start_directory')  # noqa
+    manifest['version'] = version
+    manifest['dependencies'] = 'pyproject.toml'
+    
+    if x := _deduce_target(root, appname, appid):
+        manifest['launcher']['target'] = x['target']
+        manifest['launcher']['type'] = x['type'] or 'module'  # as fallback
+        manifest['launcher']['icon'] = x['icon']
+        
+        manifest['assets'][rel_src_dir := fs.dirpath(x['target'])] = 'all'
+        if x['icon'] and not x['icon'].startswith(rel_src_dir):
+            manifest['assets'][x['icon']] = 'all'
+    else:
+        manifest['launcher']['type'] = 'module'  # as default
+    
+    return manifest
+
+
+def _deduce_target(
+    root: str, appname: str, appid: str
+) -> t.Optional[T.TargetInfo]:
+    def main() -> t.Optional[T.TargetInfo]:
+        for possible_path in (
+            f'{root}/{appid}',
+            f'{root}/src/{appid}',
+            f'{root}/{appid}.py',
+            f'{root}/src/{appid}.py',
+            f'{root}/{appid}.exe',
+            f'{root}/{appid}',
+            f'{root}/src',
+            f'{root}/src/main.py',
+            f'{root}/src/app.py',
+            f'{root}/src/run.py',
+        ):
+            if exists(possible_path):
+                # the fields 'target' and 'type' are required, while 'icon' is \
+                # optional.
+                if t := _possible_type(possible_path):
+                    # noinspection PyTypeChecker
+                    return {
+                        'target': fs.relpath(possible_path, root),  # required
+                        'type': t,  # required
+                        'icon': _possible_launcher_icon() or '',  # optional
+                    }
+        return None
+    
+    def _possible_launcher_icon() -> t.Optional[str]:
+        """
+        find possible launcher icon in follwing positions:
+            - {root}/launcher.{ext}
+            - {root}/build/launcher.{ext}
+        """
+        possible_paths = {
+            'darwin': ('launcher.icns', f'{appid}.icns', f'{appname}.icns'),
+            'linux': ('launcher.png', f'{appid}.png', f'{appname}.png'),
+            'win32': ('launcher.ico', f'{appid}.ico', f'{appname}.ico'),
+        }
+        # prefer the platform-related candidates, then the others for a \
+        # fallback (they can be someway inter-converted then).
+        for _, candidates in sorted(
+            possible_paths.items(),
+            key=lambda x: 0 if x[0] == sys.platform else 1,
+        ):
+            for x in candidates:
+                if exists(y := f'{root}/{x}'):
+                    return y
+                if exists(y := f'{root}/build/{x}'):
+                    return y
+        return None
+    
+    def _possible_type(path: str) -> t.Optional[str]:
+        if os.path.isdir(path):
+            if exists(f'{path}/__init__.py') and exists(f'{path}/__main__.py'):
+                return 'package'
+            else:
+                return None
+        else:
+            if path.endswith('.py'):
+                return 'module'
+            elif path.endswith('.exe'):
+                return 'executable'
+            else:
+                return 'executable'
+    
+    return main()
```

## depsland/api/dev_api/offline_build.py

```diff
@@ -1,265 +1,274 @@
-"""
-directory structure (example):
-    dist/hello_world-0.1.0
-    |- Hello World.exe
-    |= source
-        |= depsland
-        |= apps
-            |= hello_world
-                |= src
-                    |- main.py
-        |= python
-            |- python.exe
-what does "Hello World.exe" do:
-    1. cd to "<curr_dir>/source"
-    2. set environment `PYTHONPATH=.`
-    3. run "python/python.exe -m depsland run hello_world"
-        depsland will find the target's location and launch it.
-"""
-from lk_utils import dumps
-from lk_utils import fs
-from lk_utils.textwrap import dedent
-
-from ... import system_info as sysinfo
-from ...manifest import T
-from ...manifest import compare_manifests
-from ...manifest import dump_manifest
-from ...manifest import init_manifest
-from ...manifest import init_target_tree
-from ...manifest import load_manifest
-from ...paths import project as proj_paths
-from ...utils import bat_2_exe
-
-
-def main(manifest_file: str) -> None:
-    manifest = load_manifest(manifest_file)
-    dir_i = manifest['start_directory']
-    dir_o = '{}/dist/{}-{}'.format(
-        dir_i, manifest['appid'], manifest['version']
-    )
-    _init_dist_tree(manifest, dir_o)
-    _copy_assets(manifest, dir_o)
-    _make_venv(manifest, dir_o)
-    print(':t2sr', 'creating launcher... [yellow dim](this may be slow)[/]')
-    _create_launcher(manifest, dir_o)
-    _create_debug_launcher(manifest, dir_o)
-    _create_updator(manifest, dir_o)
-    print(':t2', 'creating launcher done')
-    print('see result at {}'.format(fs.relpath(dir_o)))
-
-
-def _init_dist_tree(
-    manifest: T.Manifest, dst_dir: str, pypi: str = 'least'
-) -> None:
-    """
-    params:
-        pypi: 'standard', 'least'
-    """
-    root_i = proj_paths.root
-    root_o = dst_dir
-    
-    appid = manifest['appid']
-    version = manifest['version']
-    
-    fs.make_dirs(f'{root_o}')
-    fs.make_dir(f'{root_o}/source')
-    fs.make_dir(f'{root_o}/source/apps')
-    fs.make_dir(f'{root_o}/source/apps/.bin')
-    fs.make_dir(f'{root_o}/source/apps/.venv')
-    fs.make_dir(f'{root_o}/source/apps/.venv/{appid}')
-    fs.make_dir(f'{root_o}/source/apps/.venv/{appid}/{version}')  # TODO
-    fs.make_dir(f'{root_o}/source/apps/{appid}')
-    fs.make_dir(f'{root_o}/source/apps/{appid}/{version}')
-    fs.make_dir(f'{root_o}/source/build')
-    # fs.make_dir(f'{root_o}/source/build/exe')
-    fs.make_dir(f'{root_o}/source/conf')
-    # fs.make_dir(f'{root_o}/source/depsland')
-    fs.make_dir(f'{root_o}/source/dist')
-    fs.make_dir(f'{root_o}/source/docs')
-    fs.make_dir(f'{root_o}/source/oss')
-    fs.make_dir(f'{root_o}/source/oss/apps')
-    fs.make_dir(f'{root_o}/source/oss/test')
-    # fs.make_dir(f'{root_o}/source/pypi')
-    # fs.make_dir(f'{root_o}/source/python')
-    # fs.make_dir(f'{root_o}/source/sidework')
-    fs.make_dir(f'{root_o}/source/temp')
-    fs.make_dir(f'{root_o}/source/temp/.self_upgrade')
-    fs.make_dir(f'{root_o}/source/temp/.unittests')
-    
-    fs.make_link(f'{root_i}/build/exe', f'{root_o}/source/build/exe')
-    fs.make_link(f'{root_i}/depsland', f'{root_o}/source/depsland')
-    fs.make_link(f'{root_i}/python', f'{root_o}/source/python')
-    fs.make_link(f'{root_i}/sidework', f'{root_o}/source/sidework')
-    
-    fs.copy_file(
-        f'{root_i}/.depsland_project',
-        f'{root_o}/source/.depsland_project'
-    )
-    # TEST
-    fs.copy_file(
-        f'{root_i}/tests/conf/depsland.yaml',
-        f'{root_o}/source/conf/depsland.yaml'
-    )
-    
-    if pypi == 'least':
-        fs.make_link(
-            f'{root_i}/chore/custom_pypi/least', f'{root_o}/source/pypi'
-        )
-    else:
-        raise NotImplementedError
-    
-    dumps(
-        version,
-        f'{root_o}/source/apps/{appid}/.inst_history',
-        'plain'
-    )
-    dump_manifest(
-        manifest,
-        f'{root_o}/source/apps/{appid}/{version}/manifest.pkl'
-    )
-
-
-def _copy_assets(manifest: T.Manifest, dst_dir: str) -> None:
-    # from .publish import _copy_assets
-    
-    diff = compare_manifests(
-        new=manifest,
-        old=init_manifest(manifest['appid'], manifest['name'])
-    )
-    
-    root_i = manifest['start_directory']
-    root_o = f'{dst_dir}/source/apps/{manifest["appid"]}/{manifest["version"]}'
-    init_target_tree(manifest, root_o)
-    
-    # info1: T.AssetInfo
-    for action, relpath, (info0, info1) in diff['assets']:
-        assert action == 'append', action
-        
-        print(':i2', relpath)
-        path_i = f'{root_i}/{relpath}'
-        path_o = f'{root_o}/{relpath}'
-        
-        # ref: `.publish._copy_assets : match case`
-        match info1.scheme:
-            case 'all':
-                fs.make_link(path_i, path_o, True)
-            case 'all_dirs':
-                fs.clone_tree(path_i, path_o, True)
-            case 'root':
-                pass
-            case 'top':
-                for dn in fs.find_dir_names(path_i):
-                    fs.make_dir('{}/{}'.format(path_o, dn))
-                for f in fs.find_files(path_i):
-                    file_i = f.path
-                    file_o = '{}/{}'.format(path_o, f.name)
-                    fs.make_link(file_i, file_o)
-            case 'top_files':
-                for f in fs.find_files(path_i):
-                    file_i = f.path
-                    file_o = '{}/{}'.format(path_o, f.name)
-                    fs.make_link(file_i, file_o)
-            case 'top_dirs':
-                for dn in fs.find_dir_names(path_i):
-                    fs.make_dir('{}/{}'.format(path_o, dn))
-
-
-def _make_venv(manifest: T.Manifest, dst_dir: str) -> None:
-    if not manifest['dependencies']: return
-    from ..user_api.install import _install_dependencies  # noqa
-    _install_dependencies(
-        manifest,
-        init_manifest(manifest['appid'], manifest['name']),
-        f'{dst_dir}/source/apps/.venv/{manifest["appid"]}/{manifest["version"]}'
-    )
-
-
-def _create_launcher(manifest: T.Manifest, dst_dir: str) -> None:
-    assert sysinfo.platform.SYSTEM == 'windows', (
-        'not implemented yet', sysinfo.platform.SYSTEM
-    )
-    
-    file_bat = f'{dst_dir}/{manifest["name"]}.bat'
-    file_exe = f'{dst_dir}/{manifest["name"]}.exe'
-    
-    template = dedent(r'''
-        @echo off
-        cd /d %~dp0
-        cd source
-        set PYTHONPATH=.
-        .\python\python.exe -m depsland run {appid} --version {version}
-    ''')
-    
-    dumps(
-        template.format(appid=manifest['appid'], version=manifest['version']),
-        file_bat
-    )
-    
-    bat_2_exe(
-        file_bat, file_exe,
-        icon=manifest['launcher']['icon'],
-        show_console=manifest['launcher']['show_console'],
-        # uac_admin=True,
-        remove_bat=True
-    )
-
-
-# TEST
-def _create_debug_launcher(manifest: T.Manifest, dst_dir: str) -> None:
-    assert sysinfo.platform.SYSTEM == 'windows', (
-        'not implemented yet', sysinfo.platform.SYSTEM
-    )
-    
-    file_bat = f'{dst_dir}/{manifest["name"]} (Debug).bat'
-    file_exe = f'{dst_dir}/{manifest["name"]} (Debug).exe'
-    
-    template = dedent(r'''
-        cd /d %~dp0
-        cd source
-        set PYTHONPATH=.
-        .\python\python.exe -m depsland run {appid} --version {version}
-        pause
-    ''')
-    
-    dumps(
-        template.format(appid=manifest['appid'], version=manifest['version']),
-        file_bat
-    )
-    
-    bat_2_exe(
-        file_bat, file_exe,
-        icon=manifest['launcher']['icon'],
-        show_console=True,
-        # uac_admin=True,
-        remove_bat=True
-    )
-
-
-def _create_updator(manifest: T.Manifest, dst_dir: str) -> None:
-    assert sysinfo.platform.SYSTEM == 'windows', (
-        'not implemented yet', sysinfo.platform.SYSTEM
-    )
-    
-    file_bat = f'{dst_dir}/Check Updates.bat'
-    file_exe = f'{dst_dir}/Check Updates.exe'
-    
-    template = dedent(r'''
-        @echo off
-        cd /d %~dp0
-        cd source
-        set PYTHONPATH=.
-        .\python\python.exe -m depsland launch-gui {appid}
-    ''')
-    
-    dumps(
-        template.format(appid=manifest['appid']),
-        file_bat
-    )
-    
-    bat_2_exe(
-        file_bat, file_exe,
-        icon=manifest['launcher']['icon'],
-        show_console=False,
-        # uac_admin=True,
-        remove_bat=True
-    )
+"""
+directory structure (example):
+    dist/hello_world-0.1.0
+    |- Hello World.exe
+    |= source
+        |= depsland
+        |= apps
+            |= hello_world
+                |= 0.1.0
+                    |= src
+                        |- main.py
+            |= .venv
+                |= hello_world
+                    |= 0.1.0
+        |= python
+            |- python.exe
+what does "Hello World.exe" do:
+    1. cd to `<curr_dir>/source`
+    2. set environment `PYTHONPATH=.`
+    3. run "python/python.exe -m depsland run hello_world"
+        depsland will find the target's location and launch it.
+"""
+from lk_utils import dumps
+from lk_utils import fs
+from lk_utils.textwrap import dedent
+
+from ...manifest import T
+from ...manifest import diff_manifest
+from ...manifest import dump_manifest
+from ...manifest import init_manifest
+from ...manifest import load_manifest
+from ...paths import project as proj_paths
+from ...platform import sysinfo
+from ...platform.launcher import bat_2_exe
+from ...platform.launcher import create_launcher
+from ...pypi import pypi
+from ...utils import init_target_tree
+from ...venv import link_venv
+
+
+def main(manifest_file: str) -> None:
+    manifest = load_manifest(manifest_file)
+    dir_i = manifest['start_directory']
+    dir_o = '{}/dist/{}-{}'.format(
+        dir_i, manifest['appid'], manifest['version']
+    )
+    _init_dist_tree(manifest, dir_o)
+    _copy_assets(manifest, dir_o)
+    _make_venv(manifest, dir_o)
+    _relink_pypi(manifest, dir_o)
+    print(':t2s', 'creating launcher...')
+    _create_launcher(manifest, dir_o)
+    _create_updator(manifest, dir_o)
+    print(':t2', 'creating launcher done')
+    print('see result at {}'.format(fs.relpath(dir_o)))
+
+
+def _init_dist_tree(
+    manifest: T.Manifest, dst_dir: str, pypi: str = 'least'
+) -> None:
+    """
+    params:
+        pypi: 'standard', 'least'
+    """
+    root_i = proj_paths.root
+    root_o = dst_dir
+    
+    appid = manifest['appid']
+    version = manifest['version']
+    
+    fs.make_dirs(f'{root_o}')
+    fs.make_dir(f'{root_o}/source')
+    fs.make_dir(f'{root_o}/source/apps')
+    fs.make_dir(f'{root_o}/source/apps/.bin')
+    fs.make_dir(f'{root_o}/source/apps/.venv')
+    fs.make_dir(f'{root_o}/source/apps/.venv/{appid}')
+    fs.make_dir(f'{root_o}/source/apps/.venv/{appid}/{version}')  # TODO
+    fs.make_dir(f'{root_o}/source/apps/{appid}')
+    fs.make_dir(f'{root_o}/source/apps/{appid}/{version}')
+    fs.make_dir(f'{root_o}/source/build')
+    # fs.make_dir(f'{root_o}/source/build/exe')
+    fs.make_dir(f'{root_o}/source/config')
+    # fs.make_dir(f'{root_o}/source/depsland')
+    fs.make_dir(f'{root_o}/source/dist')
+    fs.make_dir(f'{root_o}/source/docs')
+    fs.make_dir(f'{root_o}/source/oss')
+    fs.make_dir(f'{root_o}/source/oss/apps')
+    fs.make_dir(f'{root_o}/source/oss/test')
+    # fs.make_dir(f'{root_o}/source/pypi')
+    # fs.make_dir(f'{root_o}/source/python')
+    # fs.make_dir(f'{root_o}/source/sidework')
+    fs.make_dir(f'{root_o}/source/temp')
+    fs.make_dir(f'{root_o}/source/temp/.self_upgrade')
+    fs.make_dir(f'{root_o}/source/temp/.unittests')
+    
+    fs.make_link(f'{root_i}/build/exe', f'{root_o}/source/build/exe')
+    fs.make_link(f'{root_i}/depsland', f'{root_o}/source/depsland')
+    fs.make_link(f'{root_i}/python', f'{root_o}/source/python')
+    fs.make_link(f'{root_i}/sidework', f'{root_o}/source/sidework')
+    
+    fs.copy_file(
+        f'{root_i}/.depsland_project',
+        f'{root_o}/source/.depsland_project'
+    )
+    # TEST
+    fs.copy_file(
+        f'{root_i}/tests/config/depsland.yaml',
+        f'{root_o}/source/config/depsland.yaml'
+    )
+    
+    if pypi == 'least':
+        # notice: do not use `fs.make_link` here. we will inflate files in it \
+        # later. see `_relink_pypi`.
+        fs.copy_tree(
+            f'{root_i}/chore/pypi_clean',
+            f'{root_o}/source/pypi'
+        )
+    else:
+        raise NotImplementedError
+    
+    dumps(
+        version,
+        f'{root_o}/source/apps/{appid}/.inst_history',
+        'plain'
+    )
+    dump_manifest(
+        manifest,
+        f'{root_o}/source/apps/{appid}/{version}/manifest.pkl'
+    )
+
+
+def _copy_assets(manifest: T.Manifest, dst_dir: str) -> None:
+    diff = diff_manifest(
+        new=manifest,
+        old=init_manifest(manifest['appid'], manifest['name'])
+    )
+    
+    root_i = manifest['start_directory']
+    root_o = f'{dst_dir}/source/apps/{manifest["appid"]}/{manifest["version"]}'
+    init_target_tree(manifest, root_o)
+    
+    # info1: T.AssetInfo
+    for action, relpath, (info0, info1) in diff['assets']:
+        assert action == 'append', action
+        
+        print(':i2s', relpath)
+        path_i = f'{root_i}/{relpath}'
+        path_o = f'{root_o}/{relpath}'
+        
+        # ref: `.publish._copy_assets : match case`
+        if info1.scheme == 'all':
+            fs.make_link(path_i, path_o, True)
+        elif info1.scheme == 'all_dirs':
+            fs.clone_tree(path_i, path_o, True)
+        elif info1.scheme == 'root':
+            pass
+        elif info1.scheme == 'top':
+            for dn in fs.find_dir_names(path_i):
+                fs.make_dir('{}/{}'.format(path_o, dn))
+            for f in fs.find_files(path_i):
+                file_i = f.path
+                file_o = '{}/{}'.format(path_o, f.name)
+                fs.make_link(file_i, file_o)
+        elif info1.scheme == 'top_files':
+            for f in fs.find_files(path_i):
+                file_i = f.path
+                file_o = '{}/{}'.format(path_o, f.name)
+                fs.make_link(file_i, file_o)
+        elif info1.scheme == 'top_dirs':
+            for dn in fs.find_dir_names(path_i):
+                fs.make_dir('{}/{}'.format(path_o, dn))
+        else:
+            raise Exception(info1.scheme)
+
+
+def _make_venv(manifest: T.Manifest, dst_dir: str) -> None:
+    # TODO: make sure all required packages have been installed and indexed \
+    #   pypi. see also `sidework/prepare_packages.py : preindex`.
+    info: T.PackageInfo
+    for info in manifest['dependencies'].values():
+        if not pypi.exists(id := info['id']):
+            print('add missing package', id, ':v3s')
+            pypi.install_one(
+                id, pypi.download_one(
+                    id, info['appendix'].get('custom_url')
+                )
+            )
+    # assert all(pypi.exists(x['id']) for x in manifest['dependencies'].values())
+    link_venv(
+        (x['id'] for x in manifest['dependencies'].values()),
+        '{}/source/apps/.venv/{}/{}'.format(
+            dst_dir, manifest['appid'], manifest['version']
+        )
+    )
+
+
+def _relink_pypi(manifest: T.Manifest, dst_dir: str) -> None:
+    info: T.PackageInfo
+    for name, info in manifest['dependencies'].items():
+        fs.make_dir(
+            '{}/source/pypi/installed/{}'.format(dst_dir, name)
+        )
+        fs.make_link(
+            pypi.index[info['id']][1],
+            '{}/source/pypi/installed/{}/{}'.format(
+                dst_dir, name, info['version']
+            )
+        )
+    # save index
+    name_2_ids = {
+        k: pypi.index.name_2_ids[k]
+        for k in manifest['dependencies'].keys()
+    }
+    id_2_paths = {
+        v['id']: pypi.index.id_2_paths[v['id']]
+        for v in manifest['dependencies'].values()
+    }
+    dumps(name_2_ids, f'{dst_dir}/source/pypi/index/name_2_ids.pkl')
+    dumps(id_2_paths, f'{dst_dir}/source/pypi/index/id_2_paths.pkl')
+
+
+def _create_launcher(manifest: T.Manifest, dst_dir: str) -> None:
+    create_launcher(manifest, dir_o=dst_dir)
+    if sysinfo.SYSTEM == 'windows':
+        create_launcher(
+            manifest,
+            dir_o=dst_dir,
+            name=manifest['name'] + ' (Debug).exe',
+            debug=True,
+            # keep_bat=True,  # TEST
+            # uac_admin=True,
+        )
+
+
+def _create_updator(manifest: T.Manifest, dst_dir: str) -> None:  # TODO
+    if sysinfo.SYSTEM == 'darwin' or sysinfo.SYSTEM == 'linux':
+        file_sh = f'{dst_dir}/Check Updates.sh'
+        template = dedent('''
+            # cd to current dir
+            # https://stackoverflow.com/a/246128
+            CURR_DIR=$( cd -- "$( dirname -- "${{BASH_SOURCE[0]}}" )" &> \\
+            /dev/null && pwd )
+            cd $CURR_DIR/source
+            
+            export PYTHONPATH=.
+            python/bin/python3 -m depsland launch-gui {appid}
+        ''', join_sep='\\')
+        script = template.format(appid=manifest['appid'])
+        dumps(script, file_sh)
+    
+    elif sysinfo.SYSTEM == 'windows':
+        file_bat = f'{dst_dir}/Check Updates.bat'
+        file_exe = f'{dst_dir}/Check Updates.exe'
+        template = dedent(r'''
+            @echo off
+            cd /d %~dp0
+            cd source
+            set PYTHONPATH=.
+            .\python\python.exe -m depsland launch-gui {appid}
+        ''')
+        script = template.format(appid=manifest['appid'])
+        dumps(script, file_bat)
+        bat_2_exe(
+            file_bat,
+            file_exe,
+            icon=(
+                (x := manifest['launcher']['icon']) and
+                '{}/{}'.format(manifest.start_directory, x) or ''
+            ),
+            show_console=True,
+            # show_console=False,
+            uac_admin=True,
+        )
+        fs.remove_file(file_bat)
```

## depsland/api/dev_api/publish.py

```diff
@@ -1,229 +1,323 @@
-import os
-from textwrap import dedent
-
-from lk_utils import dumps
-from lk_utils import fs
-
-from ... import paths
-from ...manifest import T as T0
-from ...manifest import compare_manifests
-from ...manifest import dump_manifest
-from ...manifest import get_app_info
-from ...manifest import init_manifest
-from ...manifest import load_manifest
-from ...oss import T as T1
-from ...oss import get_oss_server
-from ...utils import bat_2_exe
-from ...utils import compare_version
-from ...utils import make_temp_dir
-from ...utils import ziptool
-
-
-class T:
-    Manifest = T0.Manifest
-    Oss = T1.Oss
-    Path = str
-    Scheme = T0.Scheme1
-
-
-def main(manifest_file: str, full_upload=False) -> None:
-    appinfo = get_app_info(manifest_file)
-    manifest = load_manifest(manifest_file)
-    dist_dir = '{root}/dist/{name}-{ver}'.format(
-        root=manifest['start_directory'],
-        name=manifest['appid'],
-        ver=manifest['version'],
-    )
-    fs.make_dirs(dist_dir)
-    
-    oss = _upload(
-        manifest_new=manifest,
-        manifest_old=(
-            load_manifest('{}/{}/{}/manifest.pkl'.format(
-                paths.project.apps,
-                appinfo['appid'],
-                appinfo['history'][0]
-            )) if not full_upload and appinfo['history'] else
-            init_manifest(
-                appinfo['appid'], appinfo['name']
-            )
-        ),
-        dist_dir=appinfo['dst_dir']
-    )
-    
-    if oss.type_ in ('local', 'fake'):
-        print('pack oss assets to dist dir')
-        dir_o = f'{dist_dir}/.oss'
-        fs.make_dirs(dir_o)
-        fs.make_link(oss.path.root, dir_o, True)
-        
-        print('generate setup script to dist dir')
-        bat_file = f'{dist_dir}/setup.bat'
-        command = dedent(r'''
-            cd /d %~dp0
-            "%DEPSLAND%\depsland-sui.exe" launch-gui manifest.pkl :true
-        ''').strip()
-        dumps(command, bat_file)
-        bat_2_exe(bat_file,
-                  # icon=paths.build.launcher_ico,
-                  icon=manifest['launcher']['icon']
-                       or paths.build.launcher_ico,
-                  show_console=False,
-                  remove_bat=True)
-    
-    appinfo['history'].insert(0, appinfo['version'])
-    dumps(appinfo['history'],
-          paths.apps.get_distribution_history(appinfo['appid']),
-          ftype='plain')
-    
-    dump_manifest(manifest, f'{dist_dir}/manifest.pkl')
-    #   note: this is dumped to `dist_dir`, it is different from another usage
-    #   in `_upload : the bottom lines`. the latter is dumped to
-    #   `appinfo['dst_dir']`, which is pointed to `paths.apps/{appid}/{version}
-    #   /manifest.pkl`.
-    
-    print('publish done. see result at "dist/{}-{}"'.format(
-        manifest['appid'], manifest['version']
-    ), ':t')
-
-
-def _upload(
-        manifest_new: T.Manifest,
-        manifest_old: T.Manifest,
-        dist_dir: str
-) -> T.Oss:
-    # print(':lv', manifest_new, manifest_old)
-    
-    _check_manifest(manifest_new, manifest_old)
-    print('updating manifest: [red]{}[/] -> [green]{}[/]'.format(
-        manifest_old['version'], manifest_new['version']
-    ), ':r')
-    
-    # -------------------------------------------------------------------------
-    
-    root_new = manifest_new['start_directory']
-    root_old = manifest_old['start_directory']  # noqa
-    temp_dir = make_temp_dir()
-    
-    oss = get_oss_server(manifest_new['appid'])
-    print(oss.path)
-    
-    diff = compare_manifests(manifest_new, manifest_old)
-    
-    # -------------------------------------------------------------------------
-    
-    for action, relpath, (info0, info1) in diff['assets']:
-        if action == 'ignore':
-            continue
-        print(
-            ':sri', action, relpath,
-            '[dim]([red]{}[/] -> [green]{}[/])[/]'.format(
-                info0 and info0.uid,
-                info1 and info1.uid,
-            )
-        )
-        
-        if info1 is not None:  # i.e. action != 'delete'
-            source_path = fs.normpath(f'{root_new}/{relpath}')
-            temp_path = _copy_assets(source_path, temp_dir, info1.scheme)
-            zipped_file = _compress(temp_path, temp_path + (
-                '.zip' if info1.type == 'dir' else '.fzip'
-            ))
-        else:
-            zipped_file = ''
-        
-        match action:
-            case 'append':
-                oss.upload(zipped_file, f'{oss.path.assets}/{info1.uid}')
-            case 'update':
-                # delete old, upload new.
-                oss.delete(f'{oss.path.assets}/{info0.uid}')
-                oss.upload(zipped_file, f'{oss.path.assets}/{info1.uid}')
-            case 'delete':
-                oss.delete(f'{oss.path.assets}/{info0.uid}')
-    
-    # for action, (name, verspec) in diff['dependencies']:
-    #     pass
-    
-    for action, (whl_name, whl_file) in diff['pypi']:
-        if action == 'ignore':
-            continue
-        print(':sri', action, '[{}]{}[/]'.format(
-            'green' if action == 'append' else 'red',
-            whl_name
-        ))
-        match action:
-            case 'append':
-                oss.upload(whl_file, f'{oss.path.pypi}/{whl_name}')
-            case 'delete':
-                oss.delete(f'{oss.path.pypi}/{whl_name}')
-    print(':i0s')
-    
-    manifest_new['pypi'] = {k: None for k in manifest_new['pypi'].keys()}
-    dump_manifest(manifest_new, x := f'{dist_dir}/manifest.pkl')
-    oss.upload(x, oss.path.manifest)
-    
-    return oss
-
-
-def _check_manifest(
-        manifest_new: T.Manifest, manifest_old: T.Manifest,
-) -> None:
-    assert manifest_new['appid'] == manifest_old['appid']
-    v_new, v_old = manifest_new['version'], manifest_old['version']
-    assert compare_version(v_new, '>', v_old), (v_new, v_old)
-
-
-# -----------------------------------------------------------------------------
-
-def _compress(path_i: T.Path, file_o: T.Path) -> T.Path:
-    if file_o.endswith('.zip'):
-        ziptool.compress_dir(path_i, file_o)
-    else:  # file_o.endswith('.fzip'):
-        fs.move(path_i, file_o)
-        # ziptool.compress_file(path_i, file_o)
-    return file_o
-
-
-def _copy_assets(
-        path_i: T.Path,
-        root_dir_o: T.Path,
-        scheme: T.Scheme
-) -> T.Path:
-    def safe_make_dir(dirname: str) -> str:
-        sub_temp_dir = make_temp_dir(root_dir_o)
-        os.mkdir(out := '{}/{}'.format(sub_temp_dir, dirname))
-        return out
-    
-    if os.path.isdir(path_i):
-        dir_o = safe_make_dir(os.path.basename(path_i))
-    else:
-        sub_temp_dir = make_temp_dir(root_dir_o)
-        file_o = '{}/{}'.format(sub_temp_dir, os.path.basename(path_i))
-        fs.make_link(path_i, file_o)
-        return file_o
-    
-    match scheme:
-        case 'all':
-            fs.make_link(path_i, dir_o, True)
-        case 'all_dirs':
-            fs.clone_tree(path_i, dir_o, True)
-        case 'root':
-            pass
-        case 'top':
-            for dn in fs.find_dir_names(path_i):
-                os.mkdir('{}/{}'.format(dir_o, dn))
-            for f in fs.find_files(path_i):
-                file_i = f.path
-                file_o = '{}/{}'.format(dir_o, f.name)
-                fs.make_link(file_i, file_o)
-        case 'top_files':
-            for f in fs.find_files(path_i):
-                file_i = f.path
-                file_o = '{}/{}'.format(dir_o, f.name)
-                fs.make_link(file_i, file_o)
-        case 'top_dirs':
-            for dn in fs.find_dir_names(path_i):
-                os.mkdir('{}/{}'.format(dir_o, dn))
-    
-    return dir_o
+import os
+import typing as t
+from textwrap import dedent
+
+from lk_utils import dumps
+from lk_utils import fs
+
+from ... import paths
+from ...manifest import T as T0
+from ...manifest import diff_manifest
+from ...manifest import dump_manifest
+from ...manifest import get_app_info
+from ...manifest import init_manifest
+from ...manifest import load_manifest
+from ...oss import T as T1
+from ...oss import get_oss_server
+from ...platform.launcher import bat_2_exe
+from ...platform.system_info import IS_WINDOWS
+from ...utils import make_temp_dir
+from ...utils import ziptool
+from ...venv.target_venv import get_library_root
+from ...verspec import compare_version
+
+
+class T:
+    AssetInfo = T0.AssetInfo
+    Manifest = T0.Manifest
+    Oss = T1.Oss
+    PackageInfo = T0.PackageInfo
+    Path = str
+    Scheme = T0.Scheme
+
+
+def main(manifest_file: str, full_upload: bool = False) -> None:
+    app_info = get_app_info(manifest_file)
+    manifest = load_manifest(manifest_file)
+    dist_dir = '{root}/dist/{name}-{ver}'.format(
+        root=manifest['start_directory'],
+        name=manifest['appid'],
+        ver=manifest['version'],
+    )
+    fs.make_dirs(dist_dir)
+    
+    oss = _upload(
+        manifest_new=manifest,
+        manifest_old=(
+            load_manifest(
+                '{}/{}/{}/manifest.pkl'.format(
+                    paths.project.apps,
+                    app_info['appid'],
+                    app_info['history'][0],
+                )
+            )
+            if not full_upload and app_info['history']
+            else init_manifest(app_info['appid'], app_info['name'])
+        ),
+    )
+    
+    if oss.type in ('local', 'fake'):
+        print('pack oss assets to dist dir')
+        dir_o = f'{dist_dir}/.oss'
+        # fs.make_dirs(dir_o)
+        fs.make_link(oss.path.root, dir_o, True)
+        
+        # TODO: need to refactor this part.
+        if IS_WINDOWS:
+            print('generate setup script to dist dir')
+            bat_file = f'{dist_dir}/setup.bat'
+            command = dedent(r'''
+                cd /d %~dp0
+                "%DEPSLAND%\depsland-sui.exe" launch-gui manifest.pkl :true
+            ''').strip()
+            dumps(command, bat_file)
+            
+            bat_2_exe(
+                bat_file,
+                fs.replace_ext(bat_file, 'exe'),
+                # icon=paths.build.launcher_icon,
+                icon=(
+                    (x := manifest['launcher']['icon']) and
+                    '{}/{}'.format(manifest.start_directory, x) or
+                    paths.build.launcher_icon
+                ),
+                show_console=False,
+            )
+            fs.remove_file(bat_file)
+        else:
+            print('"setup.exe" is not available on other platforms', ':v3')
+    
+    app_info['history'].insert(0, app_info['version'])
+    dumps(
+        app_info['history'],
+        paths.apps.get_distribution_history(app_info['appid']),
+        type='plain',
+    )
+    
+    print(
+        ':t', 'publish done. see snapshot at "<depsland>/apps/{}/{}"'.format(
+            manifest['appid'], manifest['version']
+        )
+    )
+
+
+def _upload(manifest_new: T.Manifest, manifest_old: T.Manifest) -> T.Oss:
+    # print(':lv', manifest_new, manifest_old)
+    
+    _check_manifest(manifest_new, manifest_old)
+    _print_change(
+        'updating manifest',
+        manifest_old['version'],
+        manifest_new['version'],
+    )
+    
+    # -------------------------------------------------------------------------
+    
+    root_new = manifest_new['start_directory']  # noqa
+    root_old = manifest_old['start_directory']  # noqa
+    temp_dir = make_temp_dir()
+    
+    oss = get_oss_server(manifest_new['appid'])
+    print(oss.path)
+    
+    diff = diff_manifest(manifest_new, manifest_old)
+    
+    # -------------------------------------------------------------------------
+    
+    def upload_assets() -> None:
+        action: T.Scheme
+        info0: t.Optional[T.AssetInfo]
+        info1: t.Optional[T.AssetInfo]
+        
+        for action, relpath, (info0, info1) in diff['assets']:
+            if action == 'ignore':
+                continue
+            
+            _print_change(
+                f'{action=}, {relpath=}',
+                info0 and info0.uid,
+                info1 and info1.uid,
+                True,
+            )
+            
+            if action in ('append', 'update'):
+                zipped_file = _compress_asset(info1, relpath)
+            else:
+                zipped_file = None
+            
+            if action == 'append':
+                oss.upload(zipped_file, f'{oss.path.assets}/{info1.uid}')
+            elif action == 'update':
+                oss.delete(f'{oss.path.assets}/{info0.uid}')
+                oss.upload(zipped_file, f'{oss.path.assets}/{info1.uid}')
+            else:  # action == 'delete'
+                oss.delete(f'{oss.path.assets}/{info0.uid}')
+    
+    # noinspection PyUnusedLocal
+    def upload_dependencies() -> None:
+        # FIXME or DELETE: since depsland v0.7, all deps are hosted in pypi or \
+        #   private website. so this function is not needed.
+        
+        # `depsland.manifest.manifest._diff_dependencies`
+        action: T.Scheme
+        info0: t.Optional[T.PackageInfo]
+        info1: t.Optional[T.PackageInfo]
+        
+        for action, pkg_name, (info0, info1) in diff['dependencies']:
+            if action == 'ignore':
+                continue
+            
+            _print_change(
+                f'{action=}, {pkg_name=}',
+                info0 and info0['version'],
+                info1 and info1['version'],
+                True,
+            )
+            
+            if action in ('append', 'update'):
+                # print(info1['paths'], ':v')
+                zipped_file = _compress_dependency(info1['id'], info1['paths'])
+            else:
+                zipped_file = None
+            
+            if action == 'append':
+                oss.upload(
+                    zipped_file, f'{oss.path.pypi}/{info1["id"]}'
+                )
+            elif action == 'update':
+                oss.delete(f'{oss.path.pypi}/{info0["id"]}')
+                oss.upload(
+                    zipped_file, f'{oss.path.pypi}/{info1["id"]}'
+                )
+            else:  # action == 'delete'
+                oss.delete(f'{oss.path.pypi}/{info0["id"]}')
+    
+    # -------------------------------------------------------------------------
+    
+    def _compress_asset(info: T.AssetInfo, relpath: str) -> T.Path:
+        source_path = fs.normpath(f'{root_new}/{relpath}')
+        temp_path = _copy_assets(source_path, temp_dir, info.scheme)
+        zipped_file = _compress(
+            temp_path, temp_path + ('.zip' if info.type == 'dir' else '.fzip')
+        )
+        return zipped_file
+    
+    _library_root = get_library_root(manifest_new.start_directory)
+    
+    def _compress_dependency(
+        package_id: str, assets: t.Tuple[T.Path, ...]
+    ) -> T.Path:
+        root_i = _library_root
+        root_m = f'{temp_dir}/{package_id}'
+        root_o = temp_dir
+        fs.make_dir(root_m)
+        
+        for relpath_i in assets:
+            abspath_i = f'{root_i}/{relpath_i}'
+            abspath_m = f'{root_m}/{relpath_i}'
+            # # fs.make_link(abspath_i, abspath_m, True)
+            #   FIXME: `fs.make_link` doesn't work for `ziptool.compress_dir`.
+            if os.path.isdir(abspath_i):
+                fs.copy_tree(abspath_i, abspath_m, True)
+            else:
+                fs.copy_file(abspath_i, abspath_m, True)
+        # print(os.listdir(root_m), ':v')
+        
+        abspath_o = f'{root_o}/{package_id}.zip'
+        ziptool.compress_dir(root_m, abspath_o)
+        return abspath_o
+    
+    # -------------------------------------------------------------------------
+    
+    upload_assets()
+    # upload_dependencies()
+    
+    pkl_file = _save_manifest(manifest_new)
+    oss.upload(pkl_file, oss.path.manifest)
+    
+    return oss
+
+
+def _check_manifest(
+    manifest_new: T.Manifest,
+    manifest_old: T.Manifest,
+) -> None:
+    assert manifest_new['appid'] == manifest_old['appid']
+    v_new, v_old = manifest_new['version'], manifest_old['version']
+    assert compare_version(v_new, '>', v_old), (v_new, v_old)
+
+
+def _save_manifest(manifest_new: T.Manifest) -> str:
+    dump_manifest(
+        manifest_new,
+        out := '{}/{}/{}/manifest.pkl'.format(
+            paths.project.apps,
+            manifest_new['appid'],
+            manifest_new['version'],
+        )
+    )
+    return out
+
+
+# -----------------------------------------------------------------------------
+
+
+def _compress(path_i: T.Path, file_o: T.Path) -> T.Path:
+    if file_o.endswith('.zip'):
+        ziptool.compress_dir(path_i, file_o)
+    else:  # file_o.endswith('.fzip'):
+        fs.move(path_i, file_o)
+        # ziptool.compress_file(path_i, file_o)
+    return file_o
+
+
+def _copy_assets(
+    path_i: T.Path, root_dir_o: T.Path, scheme: T.Scheme
+) -> T.Path:
+    def safe_make_dir(dirname: str) -> str:
+        sub_temp_dir = make_temp_dir(root_dir_o)
+        os.mkdir(out := '{}/{}'.format(sub_temp_dir, dirname))
+        return out
+    
+    if os.path.isdir(path_i):
+        dir_o = safe_make_dir(os.path.basename(path_i))
+    else:
+        sub_temp_dir = make_temp_dir(root_dir_o)
+        file_o = '{}/{}'.format(sub_temp_dir, os.path.basename(path_i))
+        fs.make_link(path_i, file_o)
+        return file_o
+    
+    match scheme:
+        case 'all':
+            fs.make_link(path_i, dir_o, True)
+        case 'all_dirs':
+            fs.clone_tree(path_i, dir_o, True)
+        case 'root':
+            pass
+        case 'top':
+            for dn in fs.find_dir_names(path_i):
+                os.mkdir('{}/{}'.format(dir_o, dn))
+            for f in fs.find_files(path_i):
+                file_i = f.path
+                file_o = '{}/{}'.format(dir_o, f.name)
+                fs.make_link(file_i, file_o)
+        case 'top_files':
+            for f in fs.find_files(path_i):
+                file_i = f.path
+                file_o = '{}/{}'.format(dir_o, f.name)
+                fs.make_link(file_i, file_o)
+        case 'top_dirs':
+            for dn in fs.find_dir_names(path_i):
+                os.mkdir('{}/{}'.format(dir_o, dn))
+    
+    return dir_o
+
+
+def _print_change(
+    title: str, old: t.AnyStr, new: t.AnyStr, show_index: bool = False
+) -> None:
+    """ a print info with form of '<title>: <old> -> <new>'. """
+    print(
+        ':psr{}'.format('i2' if show_index else ''),
+        '{}: [dim]([red]{}[/] -> [green]{}[/])[/]'.format(title, old, new),
+    )
```

## depsland/api/self_api/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-from .upgrade import main as upgrade
+from .upgrade import main as upgrade
```

## depsland/api/self_api/upgrade.py

```diff
@@ -1,115 +1,114 @@
-import os
-import typing as t
-
-from lk_utils import fs
-
-from ... import paths
-from ...manifest import T as T0
-from ...manifest import change_start_directory
-from ...manifest import init_target_tree
-from ...manifest import load_manifest
-from ...oss import T as T1
-from ...oss import get_oss_client
-from ...utils import compare_version
-from ...utils import make_temp_dir
-
-
-class T:
-    Manifest = T0.Manifest
-    Oss = T1.Oss
-    CheckUpdatesResult = t.Optional[t.Tuple[Manifest, Manifest]]
-
-
-_is_dev_mode = False
-
-
-def main() -> None:
-    oss = get_oss_client(appid='depsland')
-    
-    if not (x := _get_manifests(oss)):
-        print('no update available')
-        return
-    else:
-        manifest0: T.Manifest
-        manifest1: T.Manifest
-        manifest0, manifest1 = x
-    
-    dir0, dir1 = _init_directories(manifest0, manifest1)
-    temp_dir = make_temp_dir()
-    
-    global _is_dev_mode
-    _is_dev_mode = os.path.islink(paths.project.python)
-    
-    _install_files(manifest1, manifest0, oss, temp_dir)
-    _install_custom_packages(manifest1, manifest0, oss)
-    _install_dependencies(manifest1, dst_dir=paths.python.site_packages)
-    
-    # overwrite files from dir1 to dir0
-    for name in os.listdir(dir1):
-        if name in ('apps', 'pypi', 'python', 'temp'):
-            continue
-        print(':i', name)
-        fs.move(f'{dir1}/{name}', f'{dir0}/{name}', overwrite=True)
-    
-    fs.move(
-        f'{paths.temp.self_upgrade}/manifest.pkl',
-        f'{dir0}/manifest.pkl',
-        True
-    )
-
-
-def _get_manifests(oss) -> T.CheckUpdatesResult:
-    oss.download(
-        oss.path.manifest,
-        latest_manifest_file := f'{paths.temp.self_upgrade}/manifest.pkl'
-    )
-    
-    manifest0 = load_manifest(paths.project.manifest_pkl)
-    manifest1 = load_manifest(latest_manifest_file)
-    print(':v', manifest0['version'], manifest1['version'])
-    
-    if compare_version(manifest0['version'], '<', manifest1['version']):
-        return manifest0, manifest1
-    else:
-        return None
-
-
-def _init_directories(
-        manifest0: T.Manifest, manifest1: T.Manifest
-) -> t.Tuple[str, str]:
-    dir0 = paths.system.depsland
-    dir1 = paths.temp.self_upgrade + '/' + manifest1['version']
-    assert dir0 is not None
-    init_target_tree(manifest1, dir1)  # complete tree of `dir1`
-    change_start_directory(manifest0, dir0)
-    change_start_directory(manifest1, dir1)
-    return dir0, dir1
-
-
-def _install_files(
-        manifest1: T.Manifest,
-        manifest0: T.Manifest,
-        oss: T.Oss,
-        temp_dir: str
-) -> None:
-    from ..user_api.install import _install_files  # noqa
-    _install_files(manifest1, manifest0, oss, temp_dir)
-
-
-def _install_custom_packages(
-        manifest1: T.Manifest,
-        manifest0: T.Manifest,
-        oss: T.Oss
-) -> None:
-    if _is_dev_mode:
-        return
-    from ..user_api.install import _install_custom_packages  # noqa
-    _install_custom_packages(manifest1, manifest0, oss)
-
-
-def _install_dependencies(manifest1: T.Manifest, dst_dir: str) -> None:
-    if _is_dev_mode:
-        return
-    from ...pip import pip
-    for name, vspec in manifest1['dependencies'].items():
-        pip.install(name, vspec, dst_dir=dst_dir)
+import os
+import typing as t
+
+from lk_utils import fs
+
+from ... import paths
+from ...manifest import T as T0
+from ...manifest import load_manifest
+from ...oss import T as T1
+from ...oss import get_oss_client
+from ...utils import init_target_tree
+from ...utils import make_temp_dir
+from ...verspec import compare_version
+
+
+class T:
+    Manifest = T0.Manifest
+    Oss = T1.Oss
+    CheckUpdatesResult = t.Optional[t.Tuple[Manifest, Manifest]]
+
+
+_is_dev_mode = False
+
+
+def main() -> None:
+    oss = get_oss_client(appid='depsland')
+    
+    if not (x := _get_manifests(oss)):
+        print('no update available')
+        return
+    else:
+        manifest0: T.Manifest
+        manifest1: T.Manifest
+        manifest0, manifest1 = x
+    
+    dir0, dir1 = _init_directories(manifest0, manifest1)
+    temp_dir = make_temp_dir()
+    
+    global _is_dev_mode
+    _is_dev_mode = os.path.islink(paths.project.python)
+    
+    _install_files(manifest1, manifest0, oss, temp_dir)
+    _install_custom_packages(manifest1, manifest0, oss)
+    _install_dependencies(manifest1, dst_dir=paths.python.site_packages)
+    
+    # overwrite files from dir1 to dir0
+    for name in os.listdir(dir1):
+        if name in ('apps', 'pypi', 'python', 'temp'):
+            continue
+        print(':i', name)
+        fs.move(f'{dir1}/{name}', f'{dir0}/{name}', overwrite=True)
+    
+    fs.move(
+        f'{paths.temp.self_upgrade}/manifest.pkl',
+        f'{dir0}/manifest.pkl',
+        True
+    )
+
+
+def _get_manifests(oss) -> T.CheckUpdatesResult:
+    oss.download(
+        oss.path.manifest,
+        latest_manifest_file := f'{paths.temp.self_upgrade}/manifest.pkl'
+    )
+    
+    manifest0 = load_manifest(paths.project.manifest_pkl)
+    manifest1 = load_manifest(latest_manifest_file)
+    print(':v', manifest0['version'], manifest1['version'])
+    
+    if compare_version(manifest0['version'], '<', manifest1['version']):
+        return manifest0, manifest1
+    else:
+        return None
+
+
+def _init_directories(
+        manifest0: T.Manifest, manifest1: T.Manifest
+) -> t.Tuple[str, str]:
+    dir0 = paths.system.depsland
+    dir1 = paths.temp.self_upgrade + '/' + manifest1['version']
+    assert dir0 is not None
+    init_target_tree(manifest1, dir1)  # complete tree of `dir1`
+    manifest0['start_directory'] = dir0
+    manifest1['start_directory'] = dir1
+    return dir0, dir1
+
+
+def _install_files(
+        manifest1: T.Manifest,
+        manifest0: T.Manifest,
+        oss: T.Oss,
+        temp_dir: str
+) -> None:
+    from ..user_api.install import _install_files  # noqa
+    _install_files(manifest1, manifest0, oss, temp_dir)
+
+
+def _install_custom_packages(
+        manifest1: T.Manifest,
+        manifest0: T.Manifest,
+        oss: T.Oss
+) -> None:
+    if _is_dev_mode:
+        return
+    from ..user_api.install import _install_custom_packages  # noqa
+    _install_custom_packages(manifest1, manifest0, oss)
+
+
+def _install_dependencies(manifest1: T.Manifest, dst_dir: str) -> None:
+    if _is_dev_mode:
+        return
+    from ...pip import pip
+    for name, vspec in manifest1['dependencies'].items():
+        pip.install(name, vspec, dst_dir=dst_dir)
```

## depsland/api/user_api/__init__.py

```diff
@@ -1,4 +1,5 @@
-from .install import install
-from .install import install_by_appid
-from .install import install_local
-from .uninstall import main as uninstall
+from .install import install
+from .install import install_by_appid
+from .install import install_local
+from .run import run_app
+from .uninstall import main as uninstall
```

## depsland/api/user_api/install.py

```diff
@@ -1,396 +1,424 @@
-import os
-import typing as t
-from collections import defaultdict
-from os.path import exists
-from textwrap import dedent
-
-from lk_utils import dumps
-from lk_utils import fs
-from lk_utils import loads
-
-from ... import paths
-from ...manifest import T as T0
-from ...manifest import change_start_directory
-from ...manifest import compare_manifests
-from ...manifest import dump_manifest
-from ...manifest import get_last_installed_version
-from ...manifest import init_manifest
-from ...manifest import init_target_tree
-from ...manifest import load_manifest
-from ...normalization import normalize_name
-from ...normalization import normalize_version_spec
-from ...oss import T as T1
-from ...oss import get_oss_client
-from ...pypi import pypi
-from ...utils import bat_2_exe
-from ...utils import compare_version
-from ...utils import create_shortcut
-from ...utils import make_temp_dir
-from ...utils import ziptool
-from ...utils.verspec import semver_parse
-
-
-class T:
-    AssetInfo = T0.AssetInfo
-    LauncherInfo = T0.Launcher1
-    Manifest = T0.Manifest1
-    ManifestPypi = t.Dict[str, None]
-    Oss = T1.Oss
-    Path = str
-
-
-# -----------------------------------------------------------------------------
-
-def install_by_appid(
-        appid: str,
-        upgrade: bool = True,
-        reinstall: bool = False,
-) -> None:
-    m1, m0 = _get_manifests(appid)
-    if m0 is None:
-        m0 = init_manifest(appid, m1['name'])
-    install(m1, m0, upgrade, reinstall)
-
-
-def install_local(
-        manifest_file: T.Path,
-        upgrade: bool = True,
-        reinstall: bool = False,
-) -> None:
-    m1 = load_manifest(manifest_file)
-    
-    if exists(d := '{}/.oss'.format(m1['start_directory'])):
-        custom_oss_root = d
-    else:
-        custom_oss_root = None
-    
-    init_target_tree(m1, d := '{}/{}/{}'.format(
-        paths.project.apps, m1['appid'], m1['version']
-    ))
-    change_start_directory(m1, d)
-    
-    appid, name = m1['appid'], m1['name']
-    if x := _get_dir_to_last_installed_version(appid):
-        m0 = load_manifest(f'{x}/manifest.pkl')
-    else:
-        m0 = init_manifest(appid, name)
-    
-    install(m1, m0, upgrade, reinstall, custom_oss_root)
-
-
-def install(
-        manifest_new: T.Manifest,
-        manifest_old: T.Manifest = None,
-        upgrade: bool = True,
-        reinstall: bool = False,
-        custom_oss_root: T.Path = None,
-) -> None:
-    appid = manifest_new['appid']
-    if _check_version(manifest_new, manifest_old):
-        if upgrade:
-            # install first, then uninstall old.
-            _install(manifest_new, manifest_old, custom_oss_root)
-            # TODO: for safety consideration, below is temporarily disabled,
-            #   wait for a future version that supports complete auto-upgrade.
-            # _uninstall(appid, m0['version'],
-            #            remove_venv=False, remove_bin=False)
-        else:
-            print('new version available but not installed. you can use '
-                  '`depsland install -u {appid}` or `depsland upgrade {appid}` '
-                  'to get it.'.format(appid=appid))
-    else:  # TODO
-        if reinstall:
-            from .uninstall import main as _uninstall
-            # assert m0['version'] == m1['version']
-            _uninstall(appid, manifest_old['version'])
-            install_by_appid(appid, upgrade=False, reinstall=False)
-        else:
-            print('current version is up to date. you can use `depsland '
-                  'install -r {appid}` or `depsland reinstall {appid} to force '
-                  'reinstall it.'.format(appid=appid))
-
-
-def _install(
-        manifest_new: T.Manifest,
-        manifest_old: T.Manifest,
-        custom_oss_root: T.Path = None
-) -> None:
-    dir_m = make_temp_dir()
-    
-    if custom_oss_root:
-        print('use local oss server', ':v2')
-        oss = get_oss_client(manifest_new['appid'], server='local')
-        oss.path.root = custom_oss_root
-    else:
-        oss = get_oss_client(manifest_new['appid'])
-    print(oss.path)
-    
-    _install_files(manifest_new, manifest_old, oss, dir_m)
-    _install_custom_packages(manifest_new, manifest_old, oss)
-    _install_dependencies(manifest_new, manifest_old)
-    _create_launcher(manifest_new)
-    
-    _save_history(manifest_new['appid'], manifest_new['version'])
-    _save_manifest(manifest_new)
-
-    print(':rt', '[green]installation done[/]')
-
-
-# -----------------------------------------------------------------------------
-# callees for `install_by_appid`
-
-def _check_update(
-        manifest_new: T.Manifest,
-        manifest_old: T.Manifest,
-) -> bool:
-    return compare_version(
-        manifest_new['version'], '>', manifest_old['version']
-    )
-
-
-def _check_version(new: T.Manifest, old: T.Manifest) -> bool:
-    return compare_version(new['version'], '>', old['version'])
-
-
-def _get_dir_to_last_installed_version(appid: str) -> t.Optional[str]:
-    if last_ver := get_last_installed_version(appid):
-        dir_ = '{}/{}/{}'.format(paths.project.apps, appid, last_ver)
-        assert exists(dir_), dir_
-        return dir_
-    return None
-
-
-def _get_manifests(appid: str) -> t.Tuple[T.Manifest, t.Optional[T.Manifest]]:
-    def download_new() -> T.Manifest:
-        tmp_dir = make_temp_dir()
-        oss = get_oss_client(appid)
-        oss.download(oss.path.manifest, x := f'{tmp_dir}/manifest.pkl')
-        manifest_new = load_manifest(x)
-        change_start_directory(manifest_new, '{}/{}/{}'.format(
-            paths.project.apps,
-            manifest_new['appid'],
-            manifest_new['version']
-        ))
-        init_target_tree(manifest_new)
-        fs.move(x, manifest_new['start_directory'] + '/manifest.pkl')
-        return manifest_new
-    
-    def find_old() -> t.Optional[T.Manifest]:
-        if x := _get_dir_to_last_installed_version(appid):
-            return load_manifest(f'{x}/manifest.pkl')
-        else:
-            print(f'no previous version found, it may be your first time to '
-                  f'install {appid}')
-            print('[dim]be noted the first-time installation may consume a '
-                  'long time. depsland will try to reduce the consumption in '
-                  'the succeeding upgrades/installations.[/]', ':r')
-            return None
-    
-    new, old = download_new(), find_old()
-    return new, old
-
-
-# -----------------------------------------------------------------------------
-# callees for main process.
-
-def _install_files(
-        manifest_new: T.Manifest,
-        manifest_old: T.Manifest,
-        oss: T.Oss,
-        temp_dir: T.Path
-) -> None:
-    root0 = manifest_old['start_directory']
-    root1 = manifest_new['start_directory']
-    
-    diff = compare_manifests(manifest_new, manifest_old)
-    
-    def download_from_oss(i: str, m: str, o: str) -> None:
-        print(fs.relpath(o, root1))
-        oss.download(i, m)
-        ziptool.extract_file(m, o, overwrite=True)
-    
-    def copy_from_old(i: str, o: str, t: str) -> None:
-        # `o` must not be child path of `i`.
-        assert not o.startswith(i + '/')
-        print('{} -> {}'.format(i, fs.relpath(o, root1)))
-        # TODO: shall we use `fs.move` to make it faster?
-        if t == 'file':
-            fs.copy_file(i, o, True)
-        else:
-            fs.copy_tree(i, o, True)
-    
-    for action, relpath, (info0, info1) in diff['assets']:
-        if action == 'ignore':
-            path0 = fs.normpath(f'{root0}/{relpath}')
-            path1 = fs.normpath(f'{root1}/{relpath}')
-            if os.path.exists(path0):
-                copy_from_old(path0, path1, info1.type)
-                continue
-            else:
-                print('turn ignore to append action')
-                action = 'append'
-        
-        if action in ('append', 'update'):
-            path_i = '{}/{}'.format(oss.path.assets, info1.uid)  # an url
-            path_m = fs.normpath('{}/{}.{}'.format(
-                # an intermediate file (zip)
-                temp_dir, info1.uid,
-                'zip' if info1.type == 'dir' else 'fzip'
-            ))
-            path_o = fs.normpath(f'{root1}/{relpath}')  # a file or a directory
-            download_from_oss(path_i, path_m, path_o)
-
-
-def _install_custom_packages(
-        manifest_new: T.Manifest,
-        manifest_old: T.Manifest,
-        oss: T.Oss,
-) -> None:
-    pypi0: T.ManifestPypi = manifest_old['pypi']
-    pypi1: T.ManifestPypi = manifest_new['pypi']
-    downloads_dir = paths.pypi.downloads
-    
-    new_files = []
-    for name in pypi1:
-        if name not in pypi0:
-            if not os.path.exists(f'{downloads_dir}/{name}'):
-                print('download package (whl) from oss', name)
-                oss.download(
-                    f'{oss.path.pypi}/{name}',
-                    dl := f'{downloads_dir}/{name}',
-                )
-                new_files.append(dl)
-    
-    if pypi1 and not new_files:
-        print('no newly custom packages downloaded')
-        # print(':vl', pypi0, pypi1)
-    
-    if new_files:
-        pypi.add_to_indexes(*new_files, download_dependencies=True)
-
-
-def _install_dependencies(
-        manifest_new: T.Manifest,
-        manifest_old: T.Manifest,
-        dst_dir: str = None
-) -> None:
-    if dst_dir is None:
-        dst_dir = paths.apps.make_packages(
-            manifest_new['appid'], manifest_new['version'], clear_exists=True
-        )
-    
-    # else: make sure `dst_dir` does exist.
-    
-    def is_same() -> bool:
-        if manifest_old['version'] == '0.0.0':
-            return False
-        new_deps = set(manifest_new['dependencies'].items())
-        old_deps = set(manifest_old['dependencies'].items())
-        return new_deps == old_deps
-    
-    if is_same():
-        print('fast link venv from old version')
-        src_dir = paths.apps.get_packages(
-            manifest_old['appid'], manifest_old['version']
-        )
-        fs.make_link(src_dir, dst_dir, True)
-        return
-    
-    packages = {}
-    for name, vspec in manifest_new['dependencies'].items():
-        name = normalize_name(name)
-        vspecs = tuple(normalize_version_spec(name, vspec))
-        packages[name] = vspecs
-    if not packages: return
-    print(':vl', packages)
-    
-    name_ids = pypi.install(packages, include_dependencies=True)
-    name_ids = tuple(dict.fromkeys(name_ids))  # deduplicate and remain sequence
-    name_ids = _resolve_conflicting_name_ids(name_ids)
-    pypi.save_index()
-    pypi.linking(sorted(name_ids), dst_dir)
-
-
-def _create_launcher(manifest: T.Manifest) -> None:
-    appid = manifest['appid']
-    appname = manifest['name']
-    version = manifest['version']
-    
-    # bat command
-    command = dedent(r'''
-        @echo off
-        set PYTHONPATH=%DEPSLAND%
-        {py} -m depsland run {appid} --version {version}
-    ''').strip().format(
-        py=r'"%DEPSLAND%\python\python.exe"',
-        appid=appid,
-        version=version,
-    )
-    
-    # bat to exe
-    dumps(command, bat_file := '{apps}/{appid}/{version}/{appid}.bat'.format(
-        apps=paths.project.apps, appid=appid, version=version
-    ))
-    exe_file = bat_2_exe(
-        bat_file,
-        icon=manifest['launcher']['icon'],
-        show_console=manifest['launcher']['show_console'],
-        remove_bat=True
-    )
-    
-    # create shortcuts
-    if manifest['launcher']['cli_tool']:
-        fs.copy_file(exe_file, '{}/{}.exe'.format(
-            paths.apps.bin, appid,
-        ))
-    if manifest['launcher']['desktop']:
-        create_shortcut(
-            file_i=exe_file,
-            file_o='{}/{}.lnk'.format(
-                paths.system.desktop, appname
-            )
-        )
-    if manifest['launcher']['start_menu']:
-        # WARNING: not tested
-        fs.copy_file(exe_file, '{}/{}.exe'.format(
-            paths.system.start_menu, appname
-        ))
-
-
-def _save_history(appid: str, version: str) -> None:
-    file = paths.apps.get_installation_history(appid)
-    if os.path.exists(file):
-        data: list = loads(file).splitlines()
-    else:
-        data = []
-    data.insert(0, version)
-    dumps(data, file)
-
-
-def _save_manifest(manifest: T.Manifest) -> None:
-    file_o = '{}/{}/{}/manifest.pkl'.format(
-        paths.project.apps, manifest['appid'], manifest['version']
-    )
-    dump_manifest(manifest, file_o)
-
-
-# -----------------------------------------------------------------------------
-
-def _resolve_conflicting_name_ids(name_ids: t.Iterable[str]) -> t.Iterable[str]:
-    """
-    if there are multiple versions for one name, for example 'lk_utils-2.4.1'
-    and 'lk_utils-2.5.0', remain the most latest version.
-    FIXME: this may not be a good idea, better to raise an error right once.
-    """
-    name_2_versions = defaultdict(list)
-    for nid in name_ids:
-        a, b = nid.split('-', 1)
-        name_2_versions[a].append(b)
-    if conflicts := {k: v for k, v in name_2_versions.items() if len(v) > 1}:
-        print('found {} conflicting name ids'.format(len(conflicts)),
-              conflicts, ':lv3')
-        for v in conflicts.values():
-            v.sort(key=lambda x: semver_parse(x), reverse=True)
-        return (f'{k}-{v[0]}' for k, v in name_2_versions.items())
-    else:
-        return name_ids
+import os
+import typing as t
+# from concurrent.futures import ThreadPoolExecutor
+from os.path import exists
+
+from lk_utils import Signal
+from lk_utils import dumps
+from lk_utils import fs
+from lk_utils import loads
+
+from ... import paths
+from ...manifest import T as T0
+from ...manifest import diff_manifest
+from ...manifest import dump_manifest
+from ...manifest import get_last_installed_version
+from ...manifest import init_manifest
+from ...manifest import load_manifest
+from ...oss import T as T1
+from ...oss import get_oss_client
+from ...platform import create_launcher
+from ...platform import sysinfo
+from ...platform.launcher import create_desktop_shortcut
+from ...pypi import pypi
+from ...utils import init_target_tree
+from ...utils import make_temp_dir
+from ...utils import ziptool
+from ...verspec import compare_version
+
+
+class T(T0):
+    LauncherInfo = T0.Launcher  # alias
+    Oss = T1.Oss
+    Path = str
+    ProgressStage = t.Literal['assets', 'deps', 'venv', 'cleanup']
+
+
+# Signal[stage, total, current, text]
+#   `total` and `current` are 1-based.
+#   `text`: we currently use lower-case descriptive text. the ui side may need -
+#   to convert it to a more user-friendly format.
+progress_updated = Signal(str, int, int, str)  # used by ui side
+
+
+def install_by_appid(
+    appid: str, upgrade: bool = True, reinstall: bool = False
+) -> None:
+    m1, m0 = _get_manifests(appid)
+    if m0 is None:
+        m0 = init_manifest(appid, m1['name'])
+    install(m1, m0, upgrade, reinstall)
+
+
+def install_local(
+    manifest_file: T.Path, upgrade: bool = True, reinstall: bool = False
+) -> None:
+    m1 = load_manifest(manifest_file)
+    
+    if exists(d := '{}/.oss'.format(m1['start_directory'])):
+        custom_oss_root = d
+    else:
+        custom_oss_root = None
+    
+    init_target_tree(
+        m1,
+        d := '{}/{}/{}'.format(paths.project.apps, m1['appid'], m1['version']),
+    )
+    m1.start_directory = d
+    
+    appid, name = m1['appid'], m1['name']
+    if x := _get_dir_to_last_installed_version(appid):
+        m0 = load_manifest(f'{x}/manifest.pkl')
+    else:
+        m0 = init_manifest(appid, name)
+    
+    install(m1, m0, upgrade, reinstall, custom_oss_root)
+
+
+def install(
+    manifest_new: T.Manifest,
+    manifest_old: T.Manifest = None,
+    upgrade: bool = True,
+    reinstall: bool = False,
+    custom_oss_root: T.Path = None,
+) -> None:
+    """
+    download and install assets from oss & pypi to the target directory of -
+    `manifest_new`.
+    this is an incremental operation. we download only the different parts and -
+    try to reuse existed stuff as much as possible.
+    usually the target directory is `<depsland.paths.apps>/<appid>/<version>`.
+    """
+    appid = manifest_new['appid']
+    if _check_version(manifest_new, manifest_old):
+        if upgrade:
+            # install first, then uninstall old.
+            _install(manifest_new, manifest_old, custom_oss_root)
+            # TODO: for safety consideration, below is temporarily disabled, -
+            #   wait for a future version that supports complete auto-upgrade.
+            # _uninstall(
+            #     appid, m0['version'],
+            #     remove_venv=False, remove_bin=False
+            # )
+        else:
+            print(
+                'new version available but not installed. you can use '
+                '`depsland install -u {appid}` or `depsland upgrade {appid}` '
+                'to get it.'.format(appid=appid)
+            )
+    else:  # TODO
+        if reinstall:
+            from .uninstall import main as _uninstall
+            # assert m0['version'] == m1['version']
+            _uninstall(appid, manifest_old['version'])
+            install_by_appid(appid, upgrade=False, reinstall=False)
+        else:
+            print(
+                'current version is up to date. you can use `depsland '
+                'install -r {appid}` or `depsland reinstall {appid}` to force '
+                'reinstall it.'.format(appid=appid)
+            )
+
+
+def _install(
+    manifest_new: T.Manifest,
+    manifest_old: T.Manifest,
+    custom_oss_root: T.Path = None,
+) -> None:
+    dir_m = make_temp_dir()
+    
+    if custom_oss_root:
+        print('use local oss server', ':v2')
+        oss = get_oss_client(manifest_new['appid'], server='local')
+        oss.path.root = custom_oss_root
+    else:
+        oss = get_oss_client(manifest_new['appid'])
+    print(oss.path)
+    
+    _install_files(manifest_new, manifest_old, oss, dir_m)
+    _install_packages(manifest_new, manifest_old)
+    _create_launchers(manifest_new)
+    
+    _save_history(manifest_new['appid'], manifest_new['version'])
+    _save_manifest(manifest_new)
+    
+    print(':rt', '[green]installation done[/]')
+
+
+# -----------------------------------------------------------------------------
+# callees for `install_by_appid`
+
+
+def _check_update(manifest_new: T.Manifest, manifest_old: T.Manifest) -> bool:
+    return compare_version(
+        manifest_new['version'], '>', manifest_old['version']
+    )
+
+
+def _check_version(new: T.Manifest, old: T.Manifest) -> bool:
+    return compare_version(new['version'], '>', old['version'])
+
+
+def _get_dir_to_last_installed_version(appid: str) -> t.Optional[str]:
+    if last_ver := get_last_installed_version(appid):
+        dir_ = '{}/{}/{}'.format(paths.project.apps, appid, last_ver)
+        assert exists(dir_), dir_
+        return dir_
+    return None
+
+
+def _get_manifests(appid: str) -> t.Tuple[T.Manifest, t.Optional[T.Manifest]]:
+    def download_new() -> T.Manifest:
+        tmp_dir = make_temp_dir()
+        oss = get_oss_client(appid)
+        oss.download(oss.path.manifest, x := f'{tmp_dir}/manifest.pkl')
+        manifest_new = load_manifest(x)
+        manifest_new.start_directory = '{}/{}/{}'.format(
+            paths.project.apps,
+            manifest_new['appid'],
+            manifest_new['version'],
+        )
+        init_target_tree(manifest_new)
+        fs.move(x, manifest_new['start_directory'] + '/manifest.pkl')
+        return manifest_new
+    
+    def find_old() -> t.Optional[T.Manifest]:
+        if x := _get_dir_to_last_installed_version(appid):
+            return load_manifest(f'{x}/manifest.pkl')
+        else:
+            print(
+                'no previous version found, it may be your first time to '
+                f'install "{appid}"'
+            )
+            print(
+                '[dim]be noted the first-time installation may consume a '
+                'long time. depsland will try to reduce the consumption in '
+                'the succeeding upgrades/installations.[/]',
+                ':r',
+            )
+            return None
+    
+    new, old = download_new(), find_old()
+    return new, old
+
+
+# -----------------------------------------------------------------------------
+# callees for main process.
+
+
+def _install_files(
+    manifest_new: T.Manifest,
+    manifest_old: T.Manifest,
+    oss: T.Oss,
+    temp_dir: T.Path,
+) -> None:
+    root0 = manifest_old['start_directory']
+    root1 = manifest_new['start_directory']
+    _root00 = fs.parent(root0)
+    _root10 = fs.parent(root1)
+    
+    def copy_from_old(i: str, o: str, t: str) -> None:
+        # `o` must not be child path of `i`.
+        assert not o.startswith(i + '/')
+        print('{} -> {}'.format(fs.relpath(i, _root00), fs.relpath(o, _root10)))
+        # TODO: shall we use `fs.move` to make it faster?
+        if t == 'file':
+            fs.copy_file(i, o, True)
+        else:
+            fs.copy_tree(i, o, True)
+    
+    def download_from_oss(i: str, m: str, o: str) -> None:
+        print(fs.relpath(o, _root10))
+        oss.download(i, m)
+        ziptool.extract_file(m, o, overwrite=True)
+    
+    total_diff = diff_manifest(manifest_new, manifest_old)
+    assets_diff = tuple(total_diff['assets'])
+    assets_diff_cnt = len(assets_diff)
+    curr_cnt = 0  # 1-based
+    
+    for action, relpath, (info0, info1) in assets_diff:
+        curr_cnt += 1
+        progress_updated.emit(
+            'assets', assets_diff_cnt, curr_cnt,
+            'updating "{}" ({})'.format(relpath, action)
+        )
+        
+        if action == 'ignore':
+            path0 = fs.normpath(f'{root0}/{relpath}')
+            path1 = fs.normpath(f'{root1}/{relpath}')
+            if os.path.exists(path0):
+                copy_from_old(path0, path1, info1.type)
+                continue
+            else:
+                print('turn ignore to append action')
+                action = 'append'
+        
+        if action in ('append', 'update'):
+            path_i = '{}/{}'.format(oss.path.assets, info1.uid)  # an url
+            path_m = fs.normpath(  # an intermediate file (zip)
+                '{}/{}.{}'.format(
+                    temp_dir,
+                    info1.uid,
+                    'zip' if info1.type == 'dir' else 'fzip',
+                )
+            )
+            path_o = fs.normpath(f'{root1}/{relpath}')  # a file or a directory
+            download_from_oss(path_i, path_m, path_o)
+
+
+def _install_packages(
+    manifest_new: T.Manifest, manifest_old: T.Manifest,
+) -> None:
+    if not manifest_new['dependencies']:
+        print('no dependency for this project')
+        return
+    
+    total_diff = diff_manifest(manifest_new, manifest_old)
+    deps_diff = tuple(total_diff['dependencies'])
+    # deps_diff_cnt = len(deps_diff)
+    
+    # curr_cnt = 0
+    package_ids = set()
+    tasks_ignitor = []  # list[T.PackageInfo]
+    
+    action: T.Action
+    info0: T.PackageInfo
+    info1: T.PackageInfo
+    pkg_id: T.PackageId
+    pkg_name: T.PackageName
+    
+    for action, pkg_name, (info0, info1) in deps_diff:
+        # curr_cnt += 1
+        # progress_updated.emit(
+        #     'deps', deps_diff_cnt, curr_cnt,
+        #     'updating "{}" ({})'.format(pkg_name, action)
+        # )
+        if action == 'delete':  # this is handled by oss util.
+            continue
+        pkg_id = info1['id']
+        if action in ('append', 'update'):
+            tasks_ignitor.append(info1)
+        package_ids.add(pkg_id)
+    
+    has_new_packages = bool(tasks_ignitor)
+    if tasks_ignitor:
+        print(len(tasks_ignitor))
+        
+        def download_and_install(info: T.PackageInfo) -> None:
+            if info['id'] in pypi.index.id_2_paths:
+                # this case should always be False in production environment. -
+                # but may be True in development environment.
+                return
+            dl_path = pypi.download_one(
+                info['id'],
+                info['appendix'] and info['appendix'].get('custom_url')
+            )
+            pypi.install_one(info['id'], dl_path)
+        
+        for i, info in enumerate(tasks_ignitor, 1):
+            progress_updated.emit(
+                'deps', len(tasks_ignitor), i,
+                'updating "{}"'.format(info['id'])
+            )
+            download_and_install(info)
+        
+        # FIXME: thread_pool makes pip install stucked, and ctrl+c cannot -
+        #   terminate the process.
+        # we will have IO heavy tasks, so promoting max workers is fine.
+        # http://c.biancheng.net/view/2627.html
+        # https://stackoverflow.com/questions/42541893
+        # thread_pool = ThreadPoolExecutor(max_workers=len(tasks_ignitor))
+        # tasks = [
+        #     thread_pool.submit(download_and_install, info)
+        #     for info in tasks_ignitor
+        # ]
+        # for x in tasks: x.result()
+    
+    progress_updated.emit('cleanup', 2, 1, 'linking venv')
+    venv_dir = paths.apps.make_packages(
+        manifest_new['appid'], manifest_new['version'], clear_exists=True
+    )
+    if has_new_packages:
+        pypi.linking(package_ids, venv_dir)
+    else:
+        def fast_link_venv(dst_dir: T.Path) -> None:
+            print('fast link venv from old version')
+            assert (
+                manifest_old['version'] != '0.0.0'
+            ), 'cannot do fast linking from a void version'
+            src_dir = paths.apps.get_packages(
+                manifest_old['appid'], manifest_old['version']
+            )
+            fs.make_link(src_dir, dst_dir, True)
+        
+        fast_link_venv(venv_dir)
+    
+    pypi.index.save_index()
+
+
+def _create_launchers(manifest: T.Manifest) -> None:
+    print('creating launcher... (this may be slow)')
+    progress_updated.emit('cleanup', 2, 2, 'creating launcher')
+    exe_file = create_launcher(
+        manifest,
+        dir_o='{apps}/{appid}/{version}'.format(
+            apps=paths.project.apps,
+            appid=manifest['appid'],
+            version=manifest['version'],
+        ),
+    )
+    
+    if sysinfo.IS_WINDOWS:
+        launcher: T.LauncherInfo = manifest['launcher']
+        if not launcher['show_console']:
+            # since console-less application is hard to debug if failed at -
+            # startup, we provide a "debug" launcher for user.
+            create_launcher(
+                manifest,
+                dir_o='{apps}/{appid}/{version}'.format(
+                    apps=paths.project.apps,
+                    appid=manifest['appid'],
+                    version=manifest['version'],
+                ),
+                name=manifest['name'] + ' (Debug).exe',
+                debug=True,
+                # keep_bat=False,
+                uac_admin=True,
+            )
+        if launcher['enable_cli']:
+            fs.copy_file(exe_file, '{}/{}.exe'.format(
+                paths.apps.bin, manifest['appid']
+            ))
+        if launcher['add_to_desktop']:
+            create_desktop_shortcut(
+                file_i=exe_file,
+                file_o='{}/{}.lnk'.format(
+                    paths.system.desktop, manifest['name']
+                ),
+            )
+        if launcher['add_to_start_menu']:
+            # WARNING: not tested
+            fs.copy_file(
+                exe_file, '{}/{}.exe'.format(
+                    paths.system.start_menu, manifest['name']
+                )
+            )
+
+
+def _save_history(appid: str, version: str) -> None:
+    file = paths.apps.get_installation_history(appid)
+    if os.path.exists(file):
+        data: list = loads(file).splitlines()
+    else:
+        data = []
+    data.insert(0, version)
+    dumps(data, file)
+    print('new installation is recorded')
+
+
+def _save_manifest(manifest: T.Manifest) -> None:
+    file_o = '{}/{}/{}/manifest.pkl'.format(
+        paths.project.apps, manifest['appid'], manifest['version']
+    )
+    dump_manifest(manifest, file_o)
```

## depsland/api/user_api/uninstall.py

```diff
@@ -1,23 +1,25 @@
-from lk_utils import fs
-
-from ... import paths
-
-
-def main(appid: str, version: str, **kwargs) -> None:
-    try:
-        fs.remove_tree('{}/{}/{}'.format(
-            paths.apps.root, appid, version
-        ))
-        
-        if kwargs.get('remove_venv', True):
-            fs.remove_tree('{}/{}'.format(
-                paths.apps.venv, appid
-            ))
-        
-        if kwargs.get('remove_bin', True):
-            fs.remove_file('{}/{}.exe'.format(
-                paths.apps.bin, appid
-            ))
-    except PermissionError:  # TODO
-        print('failed to remove old version, '
-              'we will try to delete it again next time', ':v4')
+from lk_utils import fs
+
+from ... import paths
+
+
+def main(appid: str, version: str, **kwargs) -> None:
+    try:
+        fs.remove_tree('{}/{}/{}'.format(
+            paths.apps.root, appid, version
+        ))
+        
+        if kwargs.get('remove_venv', True):
+            fs.remove_tree('{}/{}'.format(
+                paths.apps.venv, appid
+            ))
+        
+        if kwargs.get('remove_bin', True):
+            fs.remove_file('{}/{}.exe'.format(
+                paths.apps.bin, appid
+            ))
+    except PermissionError:  # TODO
+        print(
+            'failed to remove old version, '
+            'we will try to delete it again next time', ':v4'
+        )
```

## depsland/chore/build.zip

### zipinfo {}

```diff
@@ -1,47 +1,18 @@
-Zip file size: 4522872 bytes, number of entries: 45
-drwxr-xr-x  2.0 unx        0 b- stor 23-Feb-20 16:56 build/
--rw-r--r--  2.0 unx     2565 b- stor 23-Feb-20 16:56 build/readme.zh.md
--rw-r--r--  2.0 unx     6205 b- stor 23-Feb-20 16:56 build/build.py
--rw-r--r--  2.0 unx     3672 b- stor 23-Feb-20 16:56 build/self_build.py
--rw-r--r--  2.0 unx    10761 b- stor 23-Feb-20 16:56 build/depsland_setup.py
--rw-r--r--  2.0 unx      730 b- stor 23-Feb-20 16:56 build/install_requirements.py
--rw-r--r--  2.0 unx     2215 b- stor 23-Feb-20 16:56 build/backup_project_resources.py
--rw-r--r--  2.0 unx     1437 b- stor 23-Feb-13 11:44 build/setup_wizard/run.py
--rw-r--r--  2.0 unx     3710 b- stor 23-Feb-13 10:47 build/setup_wizard/page1.py
--rw-r--r--  2.0 unx       53 b- stor 23-Jan-05 12:11 build/setup_wizard/requirements.txt
--rw-r--r--  2.0 unx     1672 b- stor 22-Dec-07 18:05 build/setup_wizard/setup_failed_help.md
--rw-r--r--  2.0 unx     1338 b- stor 22-Dec-07 18:05 build/setup_wizard/stylesheet.yaml
--rw-r--r--  2.0 unx     3837 b- stor 23-Feb-13 17:54 build/setup_wizard/bootloader.py
--rw-r--r--  2.0 unx     8908 b- stor 23-Feb-01 16:59 build/setup_wizard/wizard.py
--rw-r--r--  2.0 unx    18664 b- stor 23-Jan-05 12:11 build/setup_wizard/launcher.ico
--rw-r--r--  2.0 unx     5131 b- stor 23-Jan-05 12:11 build/setup_wizard/page2.py
--rw-r--r--  2.0 unx     1278 b- stor 23-Jan-05 12:11 build/setup_wizard/page3.py
--rw-r--r--  2.0 unx     3830 b- stor 22-Dec-07 18:05 build/setup_wizard/qml/Main.qml
--rw-r--r--  2.0 unx     2077 b- stor 22-Dec-07 18:05 build/setup_wizard/qml/Page1.qml
--rw-r--r--  2.0 unx     3463 b- stor 22-Dec-07 18:05 build/setup_wizard/qml/Page2.qml
--rw-r--r--  2.0 unx     4781 b- stor 22-Dec-07 18:05 build/setup_wizard/qml/Page3.qml
--rw-r--r--  2.0 unx    49072 b- stor 22-Dec-07 18:05 build/setup_wizard/qml/Assets/qrcode.svg
--rw-r--r--  2.0 unx  1692965 b- stor 22-Dec-07 18:05 build/setup_wizard/qml/Assets/irregular-circle-anim-dark.gif
--rw-r--r--  2.0 unx     6724 b- stor 23-Feb-01 15:45 build/setup_wizard/__pycache__/page1.cpython-311.pyc
--rw-r--r--  2.0 unx     2507 b- stor 22-Dec-05 19:15 build/setup_wizard/__pycache__/page1.cpython-310.pyc
--rw-r--r--  2.0 unx     1500 b- stor 22-Dec-05 20:03 build/setup_wizard/__pycache__/page3.cpython-310.pyc
--rw-r--r--  2.0 unx     1850 b- stor 23-Feb-01 15:46 build/setup_wizard/__pycache__/page3.cpython-311.pyc
--rw-r--r--  2.0 unx    14138 b- stor 23-Feb-01 15:46 build/setup_wizard/__pycache__/wizard.cpython-311.pyc
--rw-r--r--  2.0 unx     2536 b- stor 22-Dec-05 19:23 build/setup_wizard/__pycache__/wizard.cpython-310.pyc
--rw-r--r--  2.0 unx     3609 b- stor 22-Dec-05 20:03 build/setup_wizard/__pycache__/page2.cpython-310.pyc
--rw-r--r--  2.0 unx     8441 b- stor 23-Feb-01 15:46 build/setup_wizard/__pycache__/page2.cpython-311.pyc
--rw-r--r--  2.0 unx       85 b- stor 23-Feb-13 17:54 build/exe/setup.bat
--rw-r--r--  2.0 unx   123392 b- stor 23-Feb-13 17:54 build/exe/setup.exe
--rw-r--r--  2.0 unx   124928 b- stor 23-Feb-13 17:54 build/exe/desktop.exe
--rw-r--r--  2.0 unx       85 b- stor 23-Feb-13 17:54 build/exe/setup2.bat
--rw-r--r--  2.0 unx       72 b- stor 23-Feb-13 10:47 build/exe/desktop.bat
--rw-r--r--  2.0 unx   985600 b- stor 23-Feb-13 17:54 build/exe/setup2.exe
--rw-r--r--  2.0 unx       82 b- stor 22-Nov-21 10:59 build/exe/depsland.bat
--rw-r--r--  2.0 unx    18664 b- stor 22-Nov-02 10:44 build/exe/launcher.ico
--rw-r--r--  2.0 unx   124928 b- stor 23-Feb-13 17:54 build/exe/depsland.exe
--rw-r--r--  2.0 unx   985600 b- stor 23-Feb-13 10:47 build/exe/setup_patch.exe
--rw-r--r--  2.0 unx      100 b- stor 23-Feb-13 10:47 build/exe/setup_patch.bat
--rw-r--r--  2.0 unx   158830 b- stor 22-Nov-01 10:34 build/.assets/readme.zh/image-20221101004226012.png
--rw-r--r--  2.0 unx    77242 b- stor 22-Nov-01 10:34 build/.assets/readme.zh/image-20221101003716782.png
--rw-r--r--  2.0 unx    47191 b- stor 22-Nov-01 10:34 build/.assets/readme.zh/image-20221031233240689.png
-45 files, 4516468 bytes uncompressed, 4516468 bytes compressed:  0.0%
+Zip file size: 1863003 bytes, number of entries: 16
+drwxrwxrwx  2.0 fat        0 b- stor 24-May-06 16:15 build/
+-rw-rw-rw-  2.0 fat     9435 b- stor 24-May-06 16:15 build/build.py
+-rw-rw-rw-  2.0 fat     5743 b- stor 24-May-06 16:15 build/init.py
+-rw-rw-rw-  2.0 fat    47191 b- stor 22-Oct-31 23:32 build/.assets/readme.zh/image-20221031233240689.png
+-rw-rw-rw-  2.0 fat    77242 b- stor 22-Nov-01 00:37 build/.assets/readme.zh/image-20221101003716782.png
+-rwx---     2.0 fat       99 b- stor 24-May-06 16:14 build/exe/depsland-cli.bat
+-rwx---     2.0 fat   985600 b- stor 24-May-06 16:14 build/exe/depsland-cli.exe
+-rwx---     2.0 fat      115 b- stor 24-May-06 16:14 build/exe/depsland-gui-debug.bat
+-rwx---     2.0 fat   124928 b- stor 24-May-06 16:14 build/exe/depsland-gui-debug.exe
+-rwx---     2.0 fat      119 b- stor 24-May-06 16:14 build/exe/depsland-gui.bat
+-rwx---     2.0 fat   123392 b- stor 24-May-06 16:14 build/exe/depsland-gui.exe
+-rw-rw-rw-  2.0 fat    18664 b- stor 22-Nov-01 21:23 build/exe/launcher.ico
+-rw-rw-rw-  2.0 fat   420542 b- stor 24-Mar-13 16:08 build/icon/launcher.icns
+-rw-rw-rw-  2.0 fat    18664 b- stor 22-Nov-01 21:23 build/icon/launcher.ico
+-rw-rw-rw-  2.0 fat    28787 b- stor 24-Mar-13 16:08 build/icon/launcher.png
+-rw-rw-rw-  2.0 fat      414 b- stor 24-Mar-13 16:08 build/icon/readme.md
+16 files, 1860935 bytes uncompressed, 1860935 bytes compressed:  0.0%
```

### zipnote {}

```diff
@@ -1,136 +1,49 @@
 Filename: build/
 Comment: 
 
-Filename: build/readme.zh.md
-Comment: 
-
 Filename: build/build.py
 Comment: 
 
-Filename: build/self_build.py
-Comment: 
-
-Filename: build/depsland_setup.py
-Comment: 
-
-Filename: build/install_requirements.py
-Comment: 
-
-Filename: build/backup_project_resources.py
-Comment: 
-
-Filename: build/setup_wizard/run.py
-Comment: 
-
-Filename: build/setup_wizard/page1.py
-Comment: 
-
-Filename: build/setup_wizard/requirements.txt
-Comment: 
-
-Filename: build/setup_wizard/setup_failed_help.md
-Comment: 
-
-Filename: build/setup_wizard/stylesheet.yaml
-Comment: 
-
-Filename: build/setup_wizard/bootloader.py
-Comment: 
-
-Filename: build/setup_wizard/wizard.py
-Comment: 
-
-Filename: build/setup_wizard/launcher.ico
-Comment: 
-
-Filename: build/setup_wizard/page2.py
-Comment: 
-
-Filename: build/setup_wizard/page3.py
-Comment: 
-
-Filename: build/setup_wizard/qml/Main.qml
-Comment: 
-
-Filename: build/setup_wizard/qml/Page1.qml
-Comment: 
-
-Filename: build/setup_wizard/qml/Page2.qml
-Comment: 
-
-Filename: build/setup_wizard/qml/Page3.qml
-Comment: 
-
-Filename: build/setup_wizard/qml/Assets/qrcode.svg
-Comment: 
-
-Filename: build/setup_wizard/qml/Assets/irregular-circle-anim-dark.gif
-Comment: 
-
-Filename: build/setup_wizard/__pycache__/page1.cpython-311.pyc
-Comment: 
-
-Filename: build/setup_wizard/__pycache__/page1.cpython-310.pyc
-Comment: 
-
-Filename: build/setup_wizard/__pycache__/page3.cpython-310.pyc
+Filename: build/init.py
 Comment: 
 
-Filename: build/setup_wizard/__pycache__/page3.cpython-311.pyc
-Comment: 
-
-Filename: build/setup_wizard/__pycache__/wizard.cpython-311.pyc
-Comment: 
-
-Filename: build/setup_wizard/__pycache__/wizard.cpython-310.pyc
-Comment: 
-
-Filename: build/setup_wizard/__pycache__/page2.cpython-310.pyc
-Comment: 
-
-Filename: build/setup_wizard/__pycache__/page2.cpython-311.pyc
+Filename: build/.assets/readme.zh/image-20221031233240689.png
 Comment: 
 
-Filename: build/exe/setup.bat
+Filename: build/.assets/readme.zh/image-20221101003716782.png
 Comment: 
 
-Filename: build/exe/setup.exe
+Filename: build/exe/depsland-cli.bat
 Comment: 
 
-Filename: build/exe/desktop.exe
+Filename: build/exe/depsland-cli.exe
 Comment: 
 
-Filename: build/exe/setup2.bat
+Filename: build/exe/depsland-gui-debug.bat
 Comment: 
 
-Filename: build/exe/desktop.bat
+Filename: build/exe/depsland-gui-debug.exe
 Comment: 
 
-Filename: build/exe/setup2.exe
+Filename: build/exe/depsland-gui.bat
 Comment: 
 
-Filename: build/exe/depsland.bat
+Filename: build/exe/depsland-gui.exe
 Comment: 
 
 Filename: build/exe/launcher.ico
 Comment: 
 
-Filename: build/exe/depsland.exe
-Comment: 
-
-Filename: build/exe/setup_patch.exe
+Filename: build/icon/launcher.icns
 Comment: 
 
-Filename: build/exe/setup_patch.bat
+Filename: build/icon/launcher.ico
 Comment: 
 
-Filename: build/.assets/readme.zh/image-20221101004226012.png
+Filename: build/icon/launcher.png
 Comment: 
 
-Filename: build/.assets/readme.zh/image-20221101003716782.png
-Comment: 
-
-Filename: build/.assets/readme.zh/image-20221031233240689.png
+Filename: build/icon/readme.md
 Comment: 
 
 Zip file comment:
```

### build/build.py

```diff
@@ -1,185 +1,292 @@
-"""
-py build/build.py full-build aliyun
-py build/build.py full-build local
-"""
-if 1:
-    import sys
-    from lk_utils import xpath
-    sys.path.insert(0, xpath('..', True))
-
-import os
-from os.path import exists
-
-from argsense import cli
-from lk_utils import fs
-
-from depsland import __version__
-from depsland import bat_2_exe as _b2e
-from depsland import paths
-from depsland.manifest import dump_manifest
-from depsland.manifest import load_manifest
-from depsland.utils import ziptool
-
-print(':v2', f'depsland version: {__version__}')
-
-
-@cli.cmd()
-def full_build(oss_scheme: str, pypi_scheme='full',
-               add_python_path=True) -> None:
-    """
-    generate `dist/depsland-setup-<version>` folder.
-    
-    args:
-        oss_scheme: 'aliyun' or 'local'
-            aliyun: you need to prepare a file named -
-            'conf/depsland_for_dev.yaml', which contains aliyun oss access -
-            & secret keys.
-    kwargs:
-        pypi_scheme (-p): 'full', 'least', 'none'
-            full: link `<proj>/pypi_self` to `<dist>/pypi`.
-            least: init `<dist>/pypi`, and link `<proj>/pypi_self/downloads` -
-                to `<dist>/pypi/downloads`.
-            none: just init `<dist>/pypi`.
-    """
-    root_i = paths.project.root
-    root_o = '{dist}/depsland-setup-{version}'.format(
-        dist=paths.project.dist,
-        version=__version__
-    )
-    assert not exists(root_o)
-    os.mkdir(root_o)
-    
-    # -------------------------------------------------------------------------
-    
-    # make empty dirs
-    os.mkdir(f'{root_o}/apps')
-    os.mkdir(f'{root_o}/apps/.bin')
-    os.mkdir(f'{root_o}/apps/.venv')
-    os.mkdir(f'{root_o}/build')
-    os.mkdir(f'{root_o}/build/exe')
-    os.mkdir(f'{root_o}/conf')
-    # os.mkdir(f'{root_o}/depsland')
-    os.mkdir(f'{root_o}/dist')
-    os.mkdir(f'{root_o}/docs')
-    os.mkdir(f'{root_o}/oss')
-    os.mkdir(f'{root_o}/oss/apps')
-    os.mkdir(f'{root_o}/oss/test')
-    # os.mkdir(f'{root_o}/pypi')
-    # os.mkdir(f'{root_o}/python')
-    # os.mkdir(f'{root_o}/sidework')
-    os.mkdir(f'{root_o}/temp')
-    os.mkdir(f'{root_o}/temp/.self_upgrade')
-    os.mkdir(f'{root_o}/temp/.unittests')
-    
-    # -------------------------------------------------------------------------
-    
-    # copy files
-    fs.copy_file(f'{root_i}/build/exe/depsland.exe',
-                 f'{root_o}/build/exe/depsland.exe')
-    fs.copy_file(f'{root_i}/build/exe/desktop.exe',
-                 f'{root_o}/build/exe/desktop.exe')
-    fs.copy_file(f'{root_i}/build/exe/launcher.ico',
-                 f'{root_o}/build/exe/launcher.ico')
-    fs.copy_file(f'{root_i}/build/exe/setup.exe',
-                 f'{root_o}/setup.exe')
-    fs.copy_tree(f'{root_i}/build/setup_wizard',
-                 f'{root_o}/build/setup_wizard')
-    fs.copy_file(f'{root_i}/build/depsland_setup.py',
-                 f'{root_o}/build/depsland_setup.py')
-    fs.copy_tree(f'{root_i}/conf',
-                 f'{root_o}/conf')
-    fs.copy_tree(f'{root_i}/depsland',
-                 f'{root_o}/depsland')
-    fs.copy_tree(f'{root_i}/sidework',
-                 f'{root_o}/sidework')
-    fs.copy_file(f'{root_i}/.depsland_project',
-                 f'{root_o}/.depsland_project')
-    
-    if oss_scheme == 'aliyun':
-        assert exists(custom := os.getenv('DEPSLAND_CONFIG_PATH'))
-        fs.copy_file(f'{custom}/depsland.yaml',
-                     f'{root_o}/conf/depsland.yaml')
-    else:
-        fs.copy_file(f'{root_i}/conf/depsland.yaml',
-                     f'{root_o}/conf/depsland.yaml')
-    
-    if add_python_path:
-        if pypi_scheme == 'full':
-            fs.make_link(f'{root_i}/python',
-                         f'{root_o}/python')
-        else:
-            assert exists(f'{root_i}/tests/pure_python_standalone')
-            fs.make_link(f'{root_i}/tests/pure_python_standalone',
-                         f'{root_o}/python')
-    
-    if pypi_scheme == 'full':
-        fs.make_link(f'{root_i}/pypi_self',
-                     f'{root_o}/pypi')
-    elif pypi_scheme == 'least':
-        assert exists(f'{root_i}/tests/pure_pypi_index')
-        fs.copy_tree(f'{root_i}/tests/pure_pypi_index',
-                     f'{root_o}/pypi')
-        fs.remove_tree(f'{root_o}/pypi/downloads')
-        fs.make_link(f'{root_i}/pypi_self/downloads',
-                     f'{root_o}/pypi/downloads')
-        fs.remove_tree(f'{root_o}/pypi/installed')
-        fs.make_link(f'{root_i}/pypi_self/installed',
-                     f'{root_o}/pypi/installed')
-    else:
-        assert exists(f'{root_i}/tests/pure_pypi_index')
-        fs.copy_tree(f'{root_i}/tests/pure_pypi_index',
-                     f'{root_o}/pypi')
-    
-    # -------------------------------------------------------------------------
-    
-    # dump manifest
-    dump_manifest(load_manifest(f'{root_i}/manifest.json'),
-                  f'{root_o}/manifest.pkl')
-    
-    # post check
-    if pypi_scheme == 'least':
-        print('overwrite setup.exe')
-        fs.copy_file(f'{root_i}/build/exe/setup2.exe',
-                     f'{root_o}/setup.exe', overwrite=True)
-    if pypi_scheme in ('least', 'none'):
-        print('note: you need to manually remove `python/lib/site-packages/'
-              '<symlinked_names>` before publishing this dist', ':v3')
-    
-    print(':t', 'see result at ' + fs.relpath(root_o))
-
-
-@cli.cmd()
-def bat_2_exe(file_i: str, show_console=True, uac_admin=False):
-    """
-    args:
-        file_i: the file is ".bat" file, which is under ~/build/exe folder.
-        
-    kwargs:
-        show_console (-c):
-        uac_admin (-u):
-    """
-    _b2e(
-        file_i,
-        icon=xpath('exe/launcher.ico'),
-        show_console=show_console,
-        uac_admin=uac_admin
-    )
-
-
-@cli.cmd()
-def build_all_launchers():
-    for f in fs.find_files(xpath('exe'), '.bat'):
-        print(':i', f.name)
-        _b2e(f.path, icon=xpath('exe/launcher.ico'))
-
-
-@cli.cmd()
-def compress_to_zip():
-    dir_i = '{}/{}'.format(paths.project.dist, f'depsland-{__version__}')
-    file_o = '{}/{}'.format(paths.project.dist, f'depsland-{__version__}.zip')
-    ziptool.compress_dir(dir_i, file_o, overwrite=True)
-    print(':t', 'see result at', fs.relpath(file_o))
-
-
-if __name__ == '__main__':
-    cli.run()
+"""
+py build/build.py full-build aliyun
+py build/build.py full-build local
+"""
+import os
+from os.path import exists
+
+from argsense import cli
+from lk_utils import fs
+from lk_utils import loads
+from lk_utils import xpath
+
+os.chdir(xpath('..'))
+os.environ['DEPSLAND_PYPI_ROOT'] = 'chore/pypi_self'
+
+from depsland import __version__
+from depsland import bat_2_exe as _b2e
+from depsland import paths
+from depsland.manifest import dump_manifest
+from depsland.manifest import load_manifest
+from depsland.utils import make_temp_dir
+from depsland.utils import ziptool
+
+print(':v2', f'depsland version: {__version__}')
+
+
+@cli.cmd()
+def self_check() -> bool:
+    ver0 = __version__
+    ver1 = loads('manifest.json')['version']
+    ver2 = loads('pyproject.toml')['tool']['poetry']['version']
+    if not (ver0 == ver1 == ver2):
+        print('version is not consistent', (ver0, ver1, ver2), ':v3')
+        return False
+    return True
+
+
+@cli.cmd()
+def backup_project_resources() -> None:
+    """
+    generate/refresh `depsland/chore/*.zip`.
+    if you find the following folders have been changed, you need to call this -
+    function:
+        - build
+        - config
+        - sidework
+    """
+    compress_dir = ziptool.compress_dir
+    
+    dir_i = paths.project.root
+    dir_m = make_temp_dir()
+    dir_o = paths.project.depsland + '/chore'
+    assert exists(dir_o)
+    
+    def copy_build_dir() -> None:
+        fs.make_dir(f'{dir_m}/build')
+        
+        fs.copy_tree(f'{dir_i}/build/.assets',
+                     f'{dir_m}/build/.assets')
+        fs.copy_tree(f'{dir_i}/build/exe',
+                     f'{dir_m}/build/exe')
+        fs.copy_tree(f'{dir_i}/build/icon',
+                     f'{dir_m}/build/icon')
+        # fs.copy_tree(f'{dir_i}/build/setup_wizard',  # DELETE
+        #              f'{dir_m}/build/setup_wizard')
+        
+        fs.copy_file(f'{dir_i}/build/build.py',
+                     f'{dir_m}/build/build.py')
+        fs.copy_file(f'{dir_i}/build/init.py',
+                     f'{dir_m}/build/init.py')
+        # fs.copy_file(f'{dir_i}/build/depsland_setup.py',  # DELETE
+        #              f'{dir_m}/build/depsland_setup.py')
+        # fs.copy_file(f'{dir_i}/build/readme.zh.md',
+        #              f'{dir_m}/build/readme.zh.md')
+        # fs.copy_file(f'{dir_i}/build/self_build.py',
+        #              f'{dir_m}/build/self_build.py')
+        compress_dir(f'{dir_m}/build',
+                     f'{dir_o}/build.zip', True)
+    
+    def copy_config_dir() -> None:
+        # make sure config/depsland.yaml has configured local oss.
+        assert loads(f'{dir_i}/config/depsland.yaml')['oss']['server'] == 'local'
+        fs.copy_file(f'{dir_i}/config/depsland.yaml', f'{dir_m}/depsland.yaml')
+        compress_dir(f'{dir_m}/depsland.yaml', f'{dir_o}/config.zip', True)
+    
+    def copy_sidework_dir() -> None:
+        fs.make_dir(f'{dir_m}/sidework')
+        for f in fs.find_files(f'{dir_i}/sidework'):
+            i = f.path
+            o = f'{dir_m}/sidework/{f.name}'
+            fs.copy_file(i, o)
+        compress_dir(f'{dir_m}/sidework', f'{dir_o}/sidework.zip', True)
+    
+    copy_build_dir()
+    copy_config_dir()
+    copy_sidework_dir()
+
+
+@cli.cmd()
+def full_build(
+    oss_scheme: str, pypi_scheme: str = 'full', _add_python_path: bool = True
+) -> None:
+    """
+    generate `dist/depsland-setup-<version>` folder.
+    
+    args:
+        oss_scheme: 'aliyun' or 'local'
+            aliyun: you need to prepare a file named -
+            'config/depsland_for_dev.yaml', which contains aliyun oss access -
+            & secret keys.
+    kwargs:
+        pypi_scheme (-p): 'full', 'least', 'blank'
+            full: link `<proj>/pypi` to `<dist>/pypi`.
+                this is used for local test.
+            least: link `<proj>/chore/pypi_self` to `<dist>/pypi`.
+                this should be used only when you want to publish a version. -
+                be careful do not update any content of `<dist>/pypi`.
+            blank: copy `<proj>/chore/pypi_blank` to `<dist>/pypi`.
+    """
+    # checks
+    if not self_check():
+        # print(':v3s', 'please resolve self-check problems first')
+        # exit()
+        pass
+    if oss_scheme == 'aliyun':
+        assert exists(os.getenv('DEPSLAND_CONFIG_ROOT'))
+    
+    root_i = paths.project.root
+    root_o = '{dist}/depsland-setup-{version}'.format(
+        dist=paths.project.dist, version=__version__
+    )
+    assert not exists(root_o)
+    os.mkdir(root_o)
+    
+    # -------------------------------------------------------------------------
+    
+    # make empty dirs
+    os.mkdir(f'{root_o}/apps')
+    os.mkdir(f'{root_o}/apps/.bin')
+    os.mkdir(f'{root_o}/apps/.venv')
+    os.mkdir(f'{root_o}/build')
+    os.mkdir(f'{root_o}/chore')
+    os.mkdir(f'{root_o}/config')
+    # os.mkdir(f'{root_o}/depsland')
+    os.mkdir(f'{root_o}/dist')
+    os.mkdir(f'{root_o}/docs')
+    os.mkdir(f'{root_o}/oss')
+    os.mkdir(f'{root_o}/oss/apps')
+    os.mkdir(f'{root_o}/oss/test')
+    # os.mkdir(f'{root_o}/pypi')
+    # os.mkdir(f'{root_o}/python')
+    # os.mkdir(f'{root_o}/sidework')
+    os.mkdir(f'{root_o}/temp')
+    os.mkdir(f'{root_o}/temp/.self_upgrade')
+    os.mkdir(f'{root_o}/temp/.unittests')
+    
+    # -------------------------------------------------------------------------
+    
+    # copy files and folders
+    fs.make_link(
+        f'{root_i}/build/exe',
+        f'{root_o}/build/exe',
+    )
+    fs.copy_file(
+        f'{root_i}/build/exe/depsland-cli.exe',
+        f'{root_o}/apps/.bin/depsland.exe',
+    )
+    fs.copy_file(
+        f'{root_i}/build/exe/depsland-gui.exe',
+        f'{root_o}/Depsland.exe',
+    )
+    fs.copy_file(
+        f'{root_i}/build/exe/depsland-gui-debug.exe',
+        f'{root_o}/Depsland (Debug).exe',
+    )
+    fs.make_link(
+        f'{root_i}/build/icon',
+        f'{root_o}/build/icon',
+    )
+    # fs.copy_tree(
+    #     f'{root_i}/build/setup_wizard',
+    #     f'{root_o}/build/setup_wizard',
+    # )
+    fs.make_link(
+        f'{root_i}/chore/site_packages',
+        f'{root_o}/chore/site_packages',
+    )
+    fs.copy_tree(
+        f'{root_i}/depsland',
+        f'{root_o}/depsland',
+    )
+    fs.copy_tree(
+        f'{root_i}/sidework',
+        f'{root_o}/sidework',
+    )
+    fs.copy_file(
+        f'{root_i}/.depsland_project',
+        f'{root_o}/.depsland_project',
+    )
+    
+    if oss_scheme == 'aliyun':
+        # assert exists(custom := os.getenv('DEPSLAND_CONFIG_ROOT'))
+        custom = os.getenv('DEPSLAND_CONFIG_ROOT')
+        assert (
+            loads(f'{custom}/depsland.yaml')
+            ['oss']['server'] == 'aliyun'
+        )
+        fs.copy_file(
+            f'{custom}/depsland.yaml',
+            f'{root_o}/config/depsland.yaml',
+        )
+    else:
+        assert (
+            loads(f'{root_i}/config/depsland.yaml')
+            ['oss']['server'] == 'local'
+        )
+        fs.copy_file(
+            f'{root_i}/config/depsland.yaml',
+            f'{root_o}/config/depsland.yaml',
+        )
+    
+    if pypi_scheme == 'full':
+        fs.make_link(f'{root_i}/pypi', f'{root_o}/pypi')
+    elif pypi_scheme == 'least':
+        print(':v3s', 'do not edit "pypi" folder in the dist')
+        fs.make_link(f'{root_i}/chore/pypi_self', f'{root_o}/pypi')
+    else:  # 'blank'
+        fs.copy_tree(f'{root_i}/chore/pypi_blank', f'{root_o}/pypi')
+    
+    if _add_python_path:
+        fs.make_link(f'{root_i}/python', f'{root_o}/python')
+    
+    # -------------------------------------------------------------------------
+    
+    # dump manifest
+    dump_manifest(
+        load_manifest(f'{root_i}/manifest.json'),
+        f'{root_o}/manifest.pkl',
+    )
+    
+    print(':t', 'see result at ' + fs.relpath(root_o))
+
+
+@cli.cmd()
+def bat_2_exe(
+    file_i: str,
+    show_console: bool = True,
+    uac_admin: bool = False
+) -> None:
+    """
+    args:
+        file_i: the file is ".bat" file, which is under ~/build/exe folder.
+    
+    kwargs:
+        show_console (-c):
+        uac_admin (-u):
+    """
+    _b2e(
+        file_bat=file_i,
+        file_exe=fs.replace_ext(file_i, 'exe'),
+        icon=xpath('exe/launcher.ico'),
+        show_console=show_console,
+        uac_admin=uac_admin,
+    )
+
+
+# @cli.cmd()
+# def build_all_launchers():  # FIXME
+#     for f in fs.find_files(xpath('exe'), '.bat'):
+#         print(':i', f.name)
+#         _b2e(f.path, icon=xpath('exe/launcher.ico'))
+
+
+@cli.cmd()
+def compress_to_zip():
+    dir_i = '{}/{}'.format(paths.project.dist, f'depsland-{__version__}')
+    file_o = '{}/{}'.format(paths.project.dist, f'depsland-{__version__}.zip')
+    ziptool.compress_dir(dir_i, file_o, overwrite=True)
+    print(':t', 'see result at', fs.relpath(file_o))
+
+
+if __name__ == '__main__':
+    # pox build/build.py bat-2-exe build/exe/depsland-cli.bat
+    # pox build/build.py bat-2-exe build/exe/depsland-gui.bat -C -u
+    # pox build/build.py bat-2-exe build/exe/depsland-gui-debug.bat -u
+    
+    # pox build/build.py backup-project-resources
+    
+    # pox build/build.py full-build aliyun
+    #   before running this command, you need to set environment variable -
+    #   'DEPSLAND_CONFIG_ROOT' to the path to your custom config folder.
+    cli.run()
```

### Comparing `build/setup_wizard/launcher.ico` & `build/icon/launcher.ico`

 * *Files identical despite different names*

### Comparing `build/exe/setup.exe` & `build/exe/depsland-gui.exe`

 * *Files 1% similar despite different names*

#### objdump

```diff
@@ -40,15 +40,15 @@
 SizeOfHeapCommit	0000000000001000
 LoaderFlags		00000000
 NumberOfRvaAndSizes	00000010
 
 The Data Directory
 Entry 0 0000000000000000 00000000 Export Directory [.edata (or where ever we found it)]
 Entry 1 000000000001b394 000000c8 Import Directory [parts of .idata]
-Entry 2 000000000001e000 00004e60 Resource Directory [.rsrc]
+Entry 2 000000000001e000 00004e78 Resource Directory [.rsrc]
 Entry 3 0000000000016000 0000111c Exception Directory [.pdata]
 Entry 4 0000000000000000 00000000 Security Directory
 Entry 5 0000000000000000 00000000 Base Relocation Directory [.reloc]
 Entry 6 0000000000000000 00000000 Debug Directory
 Entry 7 0000000000000000 00000000 Description Directory
 Entry 8 0000000000000000 00000000 Special Directory
 Entry 9 0000000000000000 00000000 Thread Storage Directory [.tls]
@@ -735,38 +735,38 @@
 030    Name Table: Char: 0, Time: 00000000, Ver: 4/0, Num Names: 0, IDs: 1
 040     Entry: ID: 0x000001, Value: 0x800000a0
 0a0      Language Table: Char: 0, Time: 00000000, Ver: 4/0, Num Names: 0, IDs: 1
 0b0       Entry: ID: 00000000, Value: 0x000130
 130        Leaf: Addr: 0x01e258, Size: 0x0048d2, Codepage: 1252
 018   Entry: ID: 0x00000a, Value: 0x80000048
 048    Name Table: Char: 0, Time: 00000000, Ver: 4/0, Num Names: 3, IDs: 0
-058     Entry: name: [val: 80000190 len 32]: 2FA4C110D319EF67A61A64EC960DAD32, Value: 0x800000b8
+058     Entry: name: [val: 80000190 len 32]: ACFF15F3EE4D196398F4394B8BC601CA, Value: 0x800000b8
 0b8      Language Table: Char: 0, Time: 00000000, Ver: 4/0, Num Names: 0, IDs: 1
 0c8       Entry: ID: 00000000, Value: 0x000140
-140        Leaf: Addr: 0x022b2c, Size: 0x00005d, Codepage: 1252
-060     Entry: name: [val: 800001d2 len 32]: A4272BC043F4054722D5405F05D9D0F6, Value: 0x800000d0
+140        Leaf: Addr: 0x022b2c, Size: 0x000014, Codepage: 1252
+060     Entry: name: [val: 800001d2 len 32]: DF046BB6777187ED70DA05A4FC2182A5, Value: 0x800000d0
 0d0      Language Table: Char: 0, Time: 00000000, Ver: 4/0, Num Names: 0, IDs: 1
 0e0       Entry: ID: 00000000, Value: 0x000150
-150        Leaf: Addr: 0x022b8c, Size: 0x000006, Codepage: 1252
-068     Entry: name: [val: 80000214 len 32]: DEFD7AA2D5ED99B5320050BC6924FCD1, Value: 0x800000e8
+150        Leaf: Addr: 0x022b40, Size: 0x00007b, Codepage: 1252
+068     Entry: name: [val: 80000214 len 32]: E26B63FE5D1A9A333916F30D88F17581, Value: 0x800000e8
 0e8      Language Table: Char: 0, Time: 00000000, Ver: 4/0, Num Names: 0, IDs: 1
 0f8       Entry: ID: 00000000, Value: 0x000160
-160        Leaf: Addr: 0x022b94, Size: 0x000018, Codepage: 1252
+160        Leaf: Addr: 0x022bbc, Size: 0x000006, Codepage: 1252
 020   Entry: ID: 0x00000e, Value: 0x80000070
 070    Name Table: Char: 0, Time: 00000000, Ver: 4/0, Num Names: 0, IDs: 1
 080     Entry: ID: 0x000001, Value: 0x80000100
 100      Language Table: Char: 0, Time: 00000000, Ver: 4/0, Num Names: 0, IDs: 1
 110       Entry: ID: 00000000, Value: 0x000170
-170        Leaf: Addr: 0x022bac, Size: 0x000014, Codepage: 1252
+170        Leaf: Addr: 0x022bc4, Size: 0x000014, Codepage: 1252
 028   Entry: ID: 0x000018, Value: 0x80000088
 088    Name Table: Char: 0, Time: 00000000, Ver: 4/0, Num Names: 0, IDs: 1
 098     Entry: ID: 0x000001, Value: 0x80000118
 118      Language Table: Char: 0, Time: 00000000, Ver: 4/0, Num Names: 0, IDs: 1
 128       Entry: ID: 00000000, Value: 0x000180
-180        Leaf: Addr: 0x022bc0, Size: 0x0002a0, Codepage: 1252
+180        Leaf: Addr: 0x022bd8, Size: 0x0002a0, Codepage: 1252
  String table starts at offset: 0x190
  Resources start at offset: 0x258
 
 Sections:
 Idx Name          Size      VMA               LMA               File off  Algn
   0 .code         00004449  0000000140001000  0000000140001000  00000400  2**2
                   CONTENTS, ALLOC, LOAD, READONLY, CODE
@@ -774,15 +774,15 @@
                   CONTENTS, ALLOC, LOAD, READONLY, CODE
   2 .pdata        0000111c  0000000140016000  0000000140016000  00014200  2**2
                   CONTENTS, ALLOC, LOAD, READONLY, DATA
   3 .rdata        0000214d  0000000140018000  0000000140018000  00015400  2**4
                   CONTENTS, ALLOC, LOAD, READONLY, DATA
   4 .data         00001c00  000000014001b000  000000014001b000  00017600  2**4
                   CONTENTS, ALLOC, LOAD, DATA
-  5 .rsrc         00004e60  000000014001e000  000000014001e000  00019200  2**2
+  5 .rsrc         00004e78  000000014001e000  000000014001e000  00019200  2**2
                   CONTENTS, ALLOC, LOAD, READONLY, DATA
 SYMBOL TABLE:
 no symbols
 
 
 
 Disassembly of section .code:
@@ -29507,21 +29507,18 @@
    14001b31f:	xchg   %eax,%ecx
    14001b320:	xchg   %eax,%ebx
    14001b321:	nop
    14001b322:	xchg   %eax,%edi
    14001b323:	xchg   %eax,%esp
    14001b324:	fwait
    14001b325:	(bad)
-   14001b326:	add    $0x782cf92a,%esp
-   14001b32c:	cltd
-   14001b32d:	adc    %dh,-0x44f7ce79(%rsi)
-   14001b333:	mov    $0xb3,%ch
-   14001b335:	sbb    %ah,%bh
-   14001b337:	loopne 0x14001b2d5
-   14001b339:	push   $0x7f
+   14001b326:	add    $0x7016f92a,%esp
+   14001b32c:	mov    $0xbf1e0653,%esi
+   14001b331:	or     %ebp,0x26951c96(%rsp,%rbp,2)
+   14001b338:	mov    0x7f(%rsi),%esp
    14001b33b:	cmp    %ebp,%edx
    14001b33d:	(bad)
    14001b33e:	add    %al,(%rax)
    14001b340:	(bad)
    14001b341:	(bad)
    14001b342:	(bad)
    14001b343:	incl   (%rax)
@@ -31940,111 +31937,117 @@
    14001e134:	rorb   %cl,0x0(%rax)
    14001e137:	add    %ah,%ah
    14001e139:	add    $0x0,%al
    14001e13b:	add    %al,(%rax)
    14001e13d:	add    %al,(%rax)
    14001e13f:	add    %ch,(%rbx,%rbp,1)
    14001e142:	add    (%rax),%al
-   14001e144:	pop    %rbp
-   14001e145:	add    %al,(%rax)
-   14001e147:	add    %ah,%ah
-   14001e149:	add    $0x0,%al
-   14001e14b:	add    %al,(%rax)
-   14001e14d:	add    %al,(%rax)
-   14001e14f:	add    %cl,0x60002(%rbx,%rbp,1)
+   14001e144:	adc    $0x0,%al
+   14001e146:	add    %al,(%rax)
+   14001e148:	in     $0x4,%al
+   14001e14a:	add    %al,(%rax)
+   14001e14c:	add    %al,(%rax)
+   14001e14e:	add    %al,(%rax)
+   14001e150:	rex sub (%rdx),%eax
+   14001e153:	add    %bh,0x0(%rbx)
    14001e156:	add    %al,(%rax)
    14001e158:	in     $0x4,%al
    14001e15a:	add    %al,(%rax)
    14001e15c:	add    %al,(%rax)
    14001e15e:	add    %al,(%rax)
-   14001e160:	xchg   %eax,%esp
-   14001e161:	sub    (%rdx),%eax
-   14001e163:	add    %bl,(%rax)
+   14001e160:	mov    $0x600022b,%esp
    14001e165:	add    %al,(%rax)
    14001e167:	add    %ah,%ah
    14001e169:	add    $0x0,%al
    14001e16b:	add    %al,(%rax)
    14001e16d:	add    %al,(%rax)
-   14001e16f:	add    %ch,0x140002(%rbx,%rbp,1)
+   14001e16f:	add    %al,%ah
+   14001e171:	sub    (%rdx),%eax
+   14001e173:	add    %dl,(%rax,%rax,1)
    14001e176:	add    %al,(%rax)
    14001e178:	in     $0x4,%al
    14001e17a:	add    %al,(%rax)
    14001e17c:	add    %al,(%rax)
    14001e17e:	add    %al,(%rax)
-   14001e180:	shrb   $0x2,(%rbx)
-   14001e183:	add    %ah,-0x1bfffffe(%rax)
-   14001e189:	add    $0x0,%al
-   14001e18b:	add    %al,(%rax)
+   14001e180:	fsubrs (%rbx)
+   14001e182:	add    (%rax),%al
+   14001e184:	movabs 0x4e4000002,%al
    14001e18d:	add    %al,(%rax)
    14001e18f:	add    %ah,(%rax)
-   14001e191:	add    %dh,(%rdx)
-   14001e193:	add    %al,0x0(%rsi)
-   14001e196:	add    %sil,(%r8,%rax,1)
-   14001e19a:	rex.XB add %sil,(%r9)
-   14001e19d:	add    %dh,(%rcx)
-   14001e19f:	add    %dh,(%rax)
-   14001e1a1:	add    %al,0x33(%rax,%rax,1)
-   14001e1a5:	add    %dh,(%rcx)
-   14001e1a7:	add    %bh,(%rcx)
-   14001e1a9:	add    %al,0x0(%rbp)
-   14001e1ac:	rex.RX add %r14b,(%rsi)
-   14001e1af:	add    %dh,(%rdi)
-   14001e1b1:	add    %al,0x0(%rcx)
-   14001e1b4:	ss add %dh,(%rcx)
-   14001e1b7:	add    %al,0x0(%rcx)
-   14001e1ba:	ss add %dh,(%rax,%rax,1)
-   14001e1be:	add    %r8b,0x0(%r11)
-   14001e1c2:	cmp    %eax,(%rax)
-   14001e1c4:	ss add %dh,(%rax)
-   14001e1c7:	add    %al,0x41(%rax,%rax,1)
-   14001e1cb:	add    %al,0x33(%rax,%rax,1)
-   14001e1cf:	add    %dh,(%rdx)
-   14001e1d1:	add    %ah,(%rax)
-   14001e1d3:	add    %al,0x0(%rcx)
-   14001e1d6:	xor    $0x0,%al
-   14001e1d8:	xor    (%rax),%al
-   14001e1da:	(bad)
-   14001e1db:	add    %dh,(%rdx)
-   14001e1dd:	add    %al,0x0(%rdx)
-   14001e1e0:	rex.XB add %sil,(%r8)
-   14001e1e3:	add    %dh,(%rax,%rax,1)
-   14001e1e6:	xor    (%rax),%eax
-   14001e1e8:	add    %r14b,(%rax,%r8,1)
-   14001e1ec:	xor    %al,(%rax)
-   14001e1ee:	xor    $0x37003400,%eax
-   14001e1f3:	add    %dh,(%rdx)
-   14001e1f5:	add    %dh,(%rdx)
-   14001e1f7:	add    %al,0x35(%rax,%rax,1)
-   14001e1fb:	add    %dh,(%rax,%rax,1)
-   14001e1fe:	xor    %al,(%rax)
-   14001e200:	xor    $0x30004600,%eax
-   14001e205:	add    %dh,0x39004400(%rip)        # 0x17902260b
-   14001e20b:	add    %al,0x30(%rax,%rax,1)
-   14001e20f:	add    %al,0x0(%rsi)
-   14001e212:	ss add %ah,(%rax)
-   14001e215:	add    %al,0x45(%rax,%rax,1)
-   14001e219:	add    %al,0x0(%rsi)
-   14001e21c:	add    %r14b,(%rdi)
-   14001e21f:	add    %al,0x0(%rcx)
-   14001e222:	add    %sil,(%r10)
-   14001e225:	add    %al,0x35(%rax,%rax,1)
-   14001e229:	add    %al,0x0(%rbp)
-   14001e22c:	add    %r15b,(%rcx)
-   14001e22f:	add    %bh,(%rcx)
-   14001e231:	add    %al,0x0(%rdx)
-   14001e234:	xor    $0x32003300,%eax
-   14001e239:	add    %dh,(%rax)
-   14001e23b:	add    %dh,(%rax)
-   14001e23d:	add    %dh,0x42003000(%rip)        # 0x182021243
-   14001e243:	add    %al,0x0(%rbx)
-   14001e246:	ss add %bh,(%rcx)
-   14001e249:	add    %dh,(%rdx)
-   14001e24b:	add    %dh,(%rax,%rax,1)
-   14001e24e:	rex.RX add %r8b,0x0(%rbx)
-   14001e252:	add    %r14b,(%rcx)
+   14001e191:	add    %al,0x0(%rcx)
+   14001e194:	rex.XB add %al,0x0(%r14)
+   14001e198:	rex.RX add %r14b,(%rcx)
+   14001e19b:	add    %dh,0x33004600(%rip)        # 0x1730227a1
+   14001e1a1:	add    %al,0x0(%rbp)
+   14001e1a4:	add    %r14b,(%r8,%rax,1)
+   14001e1a8:	add    %r14b,(%rcx)
+   14001e1ab:	add    %bh,(%rcx)
+   14001e1ad:	add    %dh,(%rsi)
+   14001e1af:	add    %dh,(%rbx)
+   14001e1b1:	add    %bh,(%rcx)
+   14001e1b3:	add    %bh,(%rax)
+   14001e1b5:	add    %al,0x0(%rsi)
+   14001e1b8:	xor    $0x0,%al
+   14001e1ba:	xor    (%rax),%eax
+   14001e1bc:	cmp    %eax,(%rax)
+   14001e1be:	xor    $0x0,%al
+   14001e1c0:	rex.X add %dil,(%rax)
+   14001e1c3:	add    %al,0x0(%rdx)
+   14001e1c6:	rex.XB add %sil,(%r14)
+   14001e1c9:	add    %dh,(%rax)
+   14001e1cb:	add    %dh,(%rcx)
+   14001e1cd:	add    %al,0x0(%rbx)
+   14001e1d0:	add    %spl,(%r8)
+   14001e1d3:	add    %al,0x46(%rax,%rax,1)
+   14001e1d7:	add    %dh,(%rax)
+   14001e1d9:	add    %dh,(%rax,%rax,1)
+   14001e1dc:	ss add %al,0x0(%rdx)
+   14001e1e0:	rex.X add %sil,(%rsi)
+   14001e1e3:	add    %dh,(%rdi)
+   14001e1e5:	add    %dh,(%rdi)
+   14001e1e7:	add    %dh,(%rdi)
+   14001e1e9:	add    %dh,(%rcx)
+   14001e1eb:	add    %bh,(%rax)
+   14001e1ed:	add    %dh,(%rdi)
+   14001e1ef:	add    %al,0x0(%rbp)
+   14001e1f2:	add    %r14b,(%rdi)
+   14001e1f5:	add    %dh,(%rax)
+   14001e1f7:	add    %al,0x41(%rax,%rax,1)
+   14001e1fb:	add    %dh,(%rax)
+   14001e1fd:	add    %dh,0x34004100(%rip)        # 0x174022303
+   14001e203:	add    %al,0x0(%rsi)
+   14001e206:	rex.XB add %sil,(%r10)
+   14001e209:	add    %dh,(%rcx)
+   14001e20b:	add    %bh,(%rax)
+   14001e20d:	add    %dh,(%rdx)
+   14001e20f:	add    %al,0x0(%rcx)
+   14001e212:	xor    $0x45002000,%eax
+   14001e217:	add    %dh,(%rdx)
+   14001e219:	add    %dh,(%rsi)
+   14001e21b:	add    %al,0x0(%rdx)
+   14001e21e:	ss add %dh,(%rbx)
+   14001e221:	add    %al,0x0(%rsi)
+   14001e224:	add    %r14b,0x31004400(%rip)        # 0x17102262b
+   14001e22b:	add    %al,0x0(%rcx)
+   14001e22e:	cmp    %eax,(%rax)
+   14001e230:	add    %sil,(%r11)
+   14001e233:	add    %dh,(%rbx)
+   14001e235:	add    %dh,(%rbx)
+   14001e237:	add    %bh,(%rcx)
+   14001e239:	add    %dh,(%rcx)
+   14001e23b:	add    %dh,(%rsi)
+   14001e23d:	add    %al,0x0(%rsi)
+   14001e240:	xor    (%rax),%eax
+   14001e242:	xor    %al,(%rax)
+   14001e244:	add    %r15b,(%rax)
+   14001e247:	add    %bh,(%rax)
+   14001e249:	add    %al,0x0(%rsi)
+   14001e24c:	xor    %eax,(%rax)
+   14001e24e:	(bad)
+   14001e24f:	add    %dh,0x31003800(%rip)        # 0x171021a55
    14001e255:	add    %al,(%rax)
    14001e257:	add    %cl,0xd474e50(%rcx)
    14001e25d:	or     (%rdx),%bl
    14001e25f:	or     (%rax),%al
    14001e261:	add    %al,(%rax)
    14001e263:	or     $0x52444849,%eax
    14001e268:	add    %al,(%rax)
@@ -39159,313 +39162,321 @@
    140022b22:	rex.WB
    140022b23:	rex.RB
    140022b24:	rex.WRX
    140022b25:	rex.R scas %es:(%rdi),%al
    140022b27:	rex.X (bad)
    140022b29:	(bad)
    140022b2a:	push   %rax
-   140022b2b:	rex.B sub $0x5,%al
-   140022b2e:	(bad)
-   140022b2f:	xchg   %edx,-0x2ba8b854(%rsp,%rax,4)
-   140022b36:	sbbl   $0x33d40ba8,0x41(%rdi)
-   140022b3d:	xchg   %eax,%ebx
-   140022b3e:	mov    $0x10,%al
-   140022b40:	jmp    0x140022bbe
-   140022b42:	adc    %bl,%bl
-   140022b44:	push   $0x23e452c1
-   140022b49:	cmpsb  %es:(%rdi),%ds:(%rsi)
-   140022b4a:	or     $0xda,%al
-   140022b4c:	xor    $0x1b,%al
-   140022b4e:	mov    %ds,(%rdi)
-   140022b50:	std
-   140022b51:	je     0x140022b20
-   140022b53:	sbb    %eax,%eax
-   140022b55:	xchg   %eax,%edi
-   140022b56:	test   %ecx,-0x1efb88cb(%rsi)
-   140022b5c:	rex.B ja 0x140022bb3
-   140022b5f:	popf
-   140022b60:	rclb   $0x55,(%rax)
-   140022b63:	(bad)
-   140022b64:	push   %rcx
-   140022b65:	(bad)
-   140022b66:	fdivs  -0x47(%rcx)
-   140022b69:	jg     0x140022b0a
-   140022b6b:	mov    $0x79,%ah
-   140022b6d:	cmp    $0x507b0cff,%eax
-   140022b72:	mov    %esp,-0x43ba6faa(%rsi)
-   140022b78:	cld
-   140022b79:	rex.RX jo 0x140022b96
-   140022b7c:	imul   $0xffffff86,%esp,%ecx
-   140022b7f:	mov    %esi,(%rcx)
-   140022b81:	in     $0x78,%al
-   140022b83:	pop    %rdi
+   140022b2b:	pop    %r11
+   140022b2d:	cmp    -0x45(%rbp),%bl
+   140022b30:	loopne 0x140022b73
+   140022b32:	pop    %rbp
+   140022b33:	roll   %cl,0x65(%rax)
+   140022b36:	(bad)
+   140022b37:	mov    $0x6e8dfd74,%ebp
+   140022b3c:	jae    0x140022ac0
+   140022b3e:	sbb    %edx,-0x44a2c5a5(%rdi)
+   140022b44:	cld
+   140022b45:	push   %r8
+   140022b47:	lret   $0x263d
+   140022b4a:	pop    %rdi
+   140022b4b:	mov    $0x619b9239,%edi
+   140022b50:	jge    0x140022b1f
+   140022b52:	(bad)
+   140022b53:	ret
+   140022b54:	loop   0x140022bb0
+   140022b56:	insl   (%dx),%es:(%rdi)
+   140022b57:	insl   (%dx),%es:(%rdi)
+   140022b58:	mov    $0x926068b3,%edx
+   140022b5d:	int3
+   140022b5e:	sti
+   140022b5f:	xchg   %eax,%edi
+   140022b60:	(bad)
+   140022b61:	(bad)
+   140022b62:	rex.WRB (bad)
+   140022b64:	jbe    0x140022b0b
+   140022b66:	jmp    0x19b634b2d
+   140022b6b:	(bad)
+   140022b6c:	push   %rcx
+   140022b6d:	lock test %ebp,-0x3e81563d(%rip)        # 0x10180d537
+   140022b74:	lods   %ds:(%rsi),%eax
+   140022b75:	xchg   %bl,0x1c4c6899(%rbx)
+   140022b7b:	fsincos
+   140022b7d:	repz rex.WX shlb $0xf6,0x69(%rdx)
+   140022b83:	outsb  %ds:(%rsi),(%dx)
    140022b84:	(bad)
-   140022b85:	lret   $0xb7d9
-   140022b88:	loope  0x140022bda
-   140022b8a:	rex.B
-   140022b8b:	add    %r8d,(%rcx)
-   140022b8e:	add    %eax,(%rax)
-   140022b90:	add    %al,(%rax)
-   140022b92:	push   %rax
-   140022b93:	rex.B sub $0x5,%al
-   140022b96:	(bad)
-   140022b97:	xchg   %esp,0x4a5cbd84(%rcx)
-   140022b9d:	fimuls 0x21ab535a(%rsi)
-   140022ba3:	mov    $0x77,%cl
-   140022ba5:	mov    $0xa1,%bl
-   140022ba7:	insb   (%dx),%es:(%rdi)
-   140022ba8:	jmp    0x140022c09
-   140022baa:	push   %rax
-   140022bab:	mov    $0x10000,%edi
-   140022bb0:	add    %eax,(%rax)
-   140022bb2:	add    %al,(%rax)
-   140022bb4:	add    %al,(%rax)
-   140022bb6:	add    %eax,(%rax)
-   140022bb8:	and    %al,(%rax)
-   140022bba:	rorb   %cl,0x0(%rax)
-   140022bbd:	add    %al,(%rcx)
-   140022bbf:	add    %bh,(%rdi,%rdi,1)
-   140022bc2:	js     0x140022c31
-   140022bc4:	insb   (%dx),%es:(%rdi)
-   140022bc5:	and    %dh,0x65(%rsi)
-   140022bc8:	jb     0x140022c3d
-   140022bca:	imul   $0x2e31223d,0x6e(%rdi),%ebp
-   140022bd1:	xor    %ah,(%rdx)
-   140022bd3:	and    %ah,0x6e(%rbp)
-   140022bd6:	movsxd 0x64(%rdi),%ebp
-   140022bd9:	imul   $0x5455223d,0x67(%rsi),%ebp
-   140022be0:	rex.RX sub $0x73202238,%eax
-   140022be6:	je     0x140022c49
-   140022be8:	outsb  %ds:(%rsi),(%dx)
-   140022be9:	fs (bad)
-   140022beb:	insb   (%dx),%es:(%rdi)
-   140022bec:	outsl  %ds:(%rsi),(%dx)
-   140022bed:	outsb  %ds:(%rsi),(%dx)
-   140022bee:	gs cmp $0x73657922,%eax
-   140022bf4:	and    (%rdi),%bh
-   140022bf6:	ds and %bh,(%rcx,%riz,2)
-   140022bfa:	jae    0x140022c6f
-   140022bfc:	gs insl (%dx),%es:(%rdi)
-   140022bfe:	(bad)
-   140022c01:	and    %bh,0x6d(%rax)
-   140022c04:	insb   (%dx),%es:(%rdi)
+   140022b85:	sbb    $0x79775849,%eax
+   140022b8a:	jns    0x140022b66
+   140022b8c:	xor    $0x39b416b2,%eax
+   140022b91:	loopne 0x140022b89
+   140022b93:	jbe    0x140022b46
+   140022b95:	sbb    -0x113fc72b(%rax),%edi
+   140022b9b:	sbb    (%rsi,%rbp,1),%esi
+   140022b9e:	lods   %ds:(%rsi),%al
+   140022b9f:	xor    %esi,%ebp
+   140022ba1:	mov    $0x4f4c823d,%esp
+   140022ba6:	fucomi %st(4),%st
+   140022ba8:	(bad)
+   140022ba9:	sarw   %cl,(%rcx)
+   140022bac:	lret   $0x248c
+   140022baf:	cli
+   140022bb0:	adc    $0xab8e8441,%eax
+   140022bb5:	ja     0x140022bea
+   140022bb7:	fisubs 0x1507ba4(%rax)
+   140022bbd:	add    %eax,(%rcx)
+   140022bbf:	add    %al,(%rax)
+   140022bc1:	add    %dl,0x41(%rax)
+   140022bc4:	add    %al,(%rax)
+   140022bc6:	add    %eax,(%rax)
+   140022bc8:	add    %eax,(%rax)
+   140022bca:	add    %al,(%rax)
+   140022bcc:	add    %al,(%rax)
+   140022bce:	add    %eax,(%rax)
+   140022bd0:	and    %al,(%rax)
+   140022bd2:	rorb   %cl,0x0(%rax)
+   140022bd5:	add    %al,(%rcx)
+   140022bd7:	add    %bh,(%rdi,%rdi,1)
+   140022bda:	js     0x140022c49
+   140022bdc:	insb   (%dx),%es:(%rdi)
+   140022bdd:	and    %dh,0x65(%rsi)
+   140022be0:	jb     0x140022c55
+   140022be2:	imul   $0x2e31223d,0x6e(%rdi),%ebp
+   140022be9:	xor    %ah,(%rdx)
+   140022beb:	and    %ah,0x6e(%rbp)
+   140022bee:	movsxd 0x64(%rdi),%ebp
+   140022bf1:	imul   $0x5455223d,0x67(%rsi),%ebp
+   140022bf8:	rex.RX sub $0x73202238,%eax
+   140022bfe:	je     0x140022c61
+   140022c00:	outsb  %ds:(%rsi),(%dx)
+   140022c01:	fs (bad)
+   140022c03:	insb   (%dx),%es:(%rdi)
+   140022c04:	outsl  %ds:(%rsi),(%dx)
    140022c05:	outsb  %ds:(%rsi),(%dx)
-   140022c06:	jae    0x140022c45
-   140022c08:	and    0x72(%rbp),%dh
-   140022c0b:	outsb  %ds:(%rsi),(%dx)
-   140022c0c:	cmp    0x63(%rbx),%dh
-   140022c0f:	push   $0x73616d65
-   140022c14:	sub    $0x7263696d,%eax
-   140022c19:	outsl  %ds:(%rsi),(%dx)
-   140022c1a:	jae    0x140022c8b
-   140022c1c:	data16 je 0x140022c4c
-   140022c1f:	movsxd 0x6d(%rdi),%ebp
-   140022c22:	cmp    0x73(%rcx),%ah
-   140022c25:	insl   (%dx),%es:(%rdi)
-   140022c26:	jbe,pn 0x140022c5a
-   140022c29:	and    (%rax),%ah
-   140022c2b:	insl   (%dx),%es:(%rdi)
-   140022c2c:	(bad)
-   140022c2d:	outsb  %ds:(%rsi),(%dx)
-   140022c2e:	imul   $0x65567473,0x65(%rsi),%esp
-   140022c35:	jb     0x140022caa
-   140022c37:	imul   $0x2e31223d,0x6e(%rdi),%ebp
-   140022c3e:	xor    %ah,(%rdx)
-   140022c40:	ds and %bh,(%rsp,%riz,2)
-   140022c44:	gs jo  0x140022cac
-   140022c47:	outsb  %ds:(%rsi),(%dx)
-   140022c48:	fs outsb %gs:(%rsi),(%dx)
-   140022c4b:	movsxd 0x3e(%rcx),%edi
-   140022c4e:	and    %bh,(%rsp,%riz,2)
-   140022c51:	gs jo  0x140022cb9
-   140022c54:	outsb  %ds:(%rsi),(%dx)
-   140022c55:	fs outsb %gs:(%rsi),(%dx)
-   140022c58:	je     0x140022c9b
-   140022c5a:	jae    0x140022ccf
-   140022c5c:	gs insl (%dx),%es:(%rdi)
-   140022c5e:	(bad)  {%k6}
-   140022c61:	ds and %bh,(%rcx,%riz,2)
-   140022c65:	jae    0x140022cda
-   140022c67:	gs insl (%dx),%es:(%rdi)
-   140022c69:	(bad)  {%k1}
-   140022c6c:	rex.WB
+   140022c06:	gs cmp $0x73657922,%eax
+   140022c0c:	and    (%rdi),%bh
+   140022c0e:	ds and %bh,(%rcx,%riz,2)
+   140022c12:	jae    0x140022c87
+   140022c14:	gs insl (%dx),%es:(%rdi)
+   140022c16:	(bad)
+   140022c19:	and    %bh,0x6d(%rax)
+   140022c1c:	insb   (%dx),%es:(%rdi)
+   140022c1d:	outsb  %ds:(%rsi),(%dx)
+   140022c1e:	jae    0x140022c5d
+   140022c20:	and    0x72(%rbp),%dh
+   140022c23:	outsb  %ds:(%rsi),(%dx)
+   140022c24:	cmp    0x63(%rbx),%dh
+   140022c27:	push   $0x73616d65
+   140022c2c:	sub    $0x7263696d,%eax
+   140022c31:	outsl  %ds:(%rsi),(%dx)
+   140022c32:	jae    0x140022ca3
+   140022c34:	data16 je 0x140022c64
+   140022c37:	movsxd 0x6d(%rdi),%ebp
+   140022c3a:	cmp    0x73(%rcx),%ah
+   140022c3d:	insl   (%dx),%es:(%rdi)
+   140022c3e:	jbe,pn 0x140022c72
+   140022c41:	and    (%rax),%ah
+   140022c43:	insl   (%dx),%es:(%rdi)
+   140022c44:	(bad)
+   140022c45:	outsb  %ds:(%rsi),(%dx)
+   140022c46:	imul   $0x65567473,0x65(%rsi),%esp
+   140022c4d:	jb     0x140022cc2
+   140022c4f:	imul   $0x2e31223d,0x6e(%rdi),%ebp
+   140022c56:	xor    %ah,(%rdx)
+   140022c58:	ds and %bh,(%rsp,%riz,2)
+   140022c5c:	gs jo  0x140022cc4
+   140022c5f:	outsb  %ds:(%rsi),(%dx)
+   140022c60:	fs outsb %gs:(%rsi),(%dx)
+   140022c63:	movsxd 0x3e(%rcx),%edi
+   140022c66:	and    %bh,(%rsp,%riz,2)
+   140022c69:	gs jo  0x140022cd1
+   140022c6c:	outsb  %ds:(%rsi),(%dx)
    140022c6d:	fs outsb %gs:(%rsi),(%dx)
-   140022c70:	je     0x140022cdb
-   140022c72:	je     0x140022ced
-   140022c74:	and    %dh,0x70(%rcx,%rdi,2)
-   140022c78:	gs cmp $0x6e697722,%eax
-   140022c7e:	xor    (%rdx),%esi
-   140022c80:	and    (%rax),%ah
-   140022c82:	outsb  %ds:(%rsi),(%dx)
-   140022c83:	(bad)
-   140022c84:	insl   (%dx),%es:(%rdi)
-   140022c85:	gs cmp $0x63694d22,%eax
-   140022c8b:	jb     0x140022cfc
-   140022c8d:	jae    0x140022cfe
-   140022c8f:	data16 je 0x140022cc0
-   140022c92:	push   %rdi
-   140022c93:	imul   $0x2e73776f,0x64(%rsi),%ebp
-   140022c9a:	rex.XB outsl %ds:(%rsi),(%dx)
+   140022c70:	je     0x140022cb3
+   140022c72:	jae    0x140022ce7
+   140022c74:	gs insl (%dx),%es:(%rdi)
+   140022c76:	(bad)  {%k6}
+   140022c79:	ds and %bh,(%rcx,%riz,2)
+   140022c7d:	jae    0x140022cf2
+   140022c7f:	gs insl (%dx),%es:(%rdi)
+   140022c81:	(bad)  {%k1}
+   140022c84:	rex.WB
+   140022c85:	fs outsb %gs:(%rsi),(%dx)
+   140022c88:	je     0x140022cf3
+   140022c8a:	je     0x140022d05
+   140022c8c:	and    %dh,0x70(%rcx,%rdi,2)
+   140022c90:	gs cmp $0x6e697722,%eax
+   140022c96:	xor    (%rdx),%esi
+   140022c98:	and    (%rax),%ah
+   140022c9a:	outsb  %ds:(%rsi),(%dx)
+   140022c9b:	(bad)
    140022c9c:	insl   (%dx),%es:(%rdi)
-   140022c9d:	insl   (%dx),%es:(%rdi)
-   140022c9e:	outsl  %ds:(%rsi),(%dx)
-   140022c9f:	outsb  %ds:(%rsi),(%dx)
-   140022ca0:	sub    $0x746e6f43,%eax
-   140022ca5:	jb     0x140022d16
-   140022ca7:	insb   (%dx),%es:(%rdi)
-   140022ca8:	jae    0x140022ccc
-   140022caa:	and    %dh,0x65(%rsi)
-   140022cad:	jb     0x140022d22
-   140022caf:	imul   $0x2e36223d,0x6e(%rdi),%ebp
-   140022cb6:	xor    %ch,(%rsi)
-   140022cb8:	xor    %ch,(%rsi)
-   140022cba:	xor    %ah,(%rdx)
-   140022cbc:	and    %dh,0x72(%rax)
-   140022cbf:	outsl  %ds:(%rsi),(%dx)
-   140022cc0:	movsxd 0x73(%rbp),%esp
-   140022cc3:	jae    0x140022d34
-   140022cc5:	jb     0x140022d08
-   140022cc7:	jb     0x140022d2c
-   140022cc9:	push   $0x63657469
-   140022cce:	je     0x140022d45
-   140022cd0:	jb     0x140022d37
-   140022cd2:	cmp    $0x20222a22,%eax
-   140022cd7:	jo     0x140022d4e
-   140022cd9:	(bad)  {%k3}
-   140022cdc:	movsxd 0x65(%rbx),%ecx
-   140022cdf:	jns    0x140022d35
-   140022ce1:	outsl  %ds:(%rsi),(%dx)
-   140022ce2:	imul   $0x3d,0x6e(%rbp),%esp
-   140022ce6:	and    (%rsi),%dh
-   140022ce8:	xor    $0x36623539,%eax
-   140022ced:	xor    $0x31,%al
-   140022cef:	xor    $0x34,%al
-   140022cf1:	movsxd 0x66(%rbx),%esp
-   140022cf4:	xor    %esp,0x22(%rsi,%riz,2)
-   140022cf8:	and    %ch,0x6e(%rcx,%riz,2)
-   140022cfc:	addr32 jne 0x140022d60
-   140022cff:	addr32 gs cmp $0x20222a22,%eax
-   140022d06:	(bad)
-   140022d07:	ds and %bh,(%rdi,%rbp,1)
-   140022d0b:	fs gs jo 0x140022d74
-   140022d0f:	outsb  %ds:(%rsi),(%dx)
-   140022d10:	fs outsb %gs:(%rsi),(%dx)
-   140022d13:	je     0x140022d56
-   140022d15:	jae    0x140022d8a
-   140022d17:	gs insl (%dx),%es:(%rdi)
-   140022d19:	(bad)  {%k6}
-   140022d1c:	ds and %bh,(%rdi,%rbp,1)
-   140022d20:	fs gs jo 0x140022d89
-   140022d24:	outsb  %ds:(%rsi),(%dx)
-   140022d25:	fs outsb %gs:(%rsi),(%dx)
-   140022d28:	movsxd 0x3e(%rcx),%edi
-   140022d2b:	and    %bh,(%rsi,%rsi,2)
-   140022d2e:	xor    (%rdx),%edi
-   140022d30:	je     0x140022da4
-   140022d32:	jne    0x140022da7
-   140022d34:	je     0x140022d7f
-   140022d36:	outsb  %ds:(%rsi),(%dx)
-   140022d37:	outsw  %ds:(%rsi),(%dx)
-   140022d39:	and    %bh,0x6d(%rax)
-   140022d3c:	insb   (%dx),%es:(%rdi)
-   140022d3d:	outsb  %ds:(%rsi),(%dx)
-   140022d3e:	jae    0x140022d7a
-   140022d40:	jbe    0x140022d75
-   140022d42:	cmp    $0x6e727522,%eax
-   140022d47:	cmp    0x63(%rbx),%dh
-   140022d4a:	push   $0x73616d65
-   140022d4f:	sub    $0x7263696d,%eax
-   140022d54:	outsl  %ds:(%rsi),(%dx)
-   140022d55:	jae    0x140022dc6
-   140022d57:	data16 je 0x140022d87
-   140022d5a:	movsxd 0x6d(%rdi),%ebp
-   140022d5d:	cmp    0x73(%rcx),%ah
-   140022d60:	insl   (%dx),%es:(%rdi)
-   140022d61:	jbe,pn 0x140022d97
-   140022d64:	and    (%rsi),%bh
-   140022d66:	and    %bh,(%rsi,%rsi,2)
-   140022d69:	xor    (%rdx),%edi
-   140022d6b:	jae    0x140022dd2
-   140022d6d:	movsxd 0x72(%rbp),%esi
-   140022d70:	imul   $0x33763c20,0x3e(%rcx,%rdi,2),%esi
-   140022d78:	cmp    0x65(%rdx),%dh
-   140022d7b:	jno    0x140022df2
-   140022d7d:	gs jae 0x140022df4
-   140022d80:	gs fs push %rax
-   140022d83:	jb     0x140022dee
-   140022d85:	jbe    0x140022df0
-   140022d87:	insb   (%dx),%es:(%rdi)
-   140022d88:	gs addr32 gs jae 0x140022dcb
-   140022d8d:	and    %bh,(%rcx,%riz,1)
-   140022d90:	sub    $0x656c202d,%eax
-   140022d95:	jbe    0x140022dfc
-   140022d97:	insb   (%dx),%es:(%rdi)
-   140022d98:	and    %ah,0x61(%rbx)
-   140022d9b:	outsb  %ds:(%rsi),(%dx)
-   140022d9c:	and    %ah,0x65(%rdx)
-   140022d9f:	and    %ah,(%rdx)
-   140022da1:	(bad)
-   140022da2:	jae    0x140022ded
-   140022da4:	outsb  %ds:(%rsi),(%dx)
-   140022da5:	jbe    0x140022e16
-   140022da7:	imul   $0x22,0x72(%rbp),%esp
-   140022dab:	sub    $0x20,%al
-   140022dad:	and    0x69(%rax),%ch
-   140022db0:	addr32 push $0x41747365
-   140022db6:	jbe    0x140022e19
-   140022db8:	imul   $0x2c22656c,0x62(%rcx,%riz,2),%ebp
-   140022dc0:	and    %ch,0x72(%rdi)
-   140022dc3:	and    %ah,(%rdx)
-   140022dc5:	jb     0x140022e2c
-   140022dc7:	jno    0x140022e3e
-   140022dc9:	imul   $0x696d6441,0x65(%rdx),%esi
-   140022dd0:	outsb  %ds:(%rsi),(%dx)
-   140022dd1:	imul   $0x6f746172,0x74(%rbx),%esi
-   140022dd8:	jb     0x140022dfc
-   140022dda:	and    %ch,0x3c203e2d(%rip)        # 0x17c226c0d
-   140022de0:	jbe    0x140022e15
-   140022de2:	cmp    0x65(%rdx),%dh
-   140022de5:	jno    0x140022e5c
-   140022de7:	gs jae 0x140022e5e
-   140022dea:	gs fs rex.RB js 0x140022e54
-   140022def:	movsxd 0x74(%rbp),%esi
-   140022df2:	imul   $0x6576654c,0x6e(%rdi),%ebp
-   140022df9:	insb   (%dx),%es:(%rdi)
-   140022dfa:	and    %ch,0x76(%rbp,%riz,2)
-   140022dfe:	gs insb (%dx),%es:(%rdi)
-   140022e00:	cmp    $0x71657222,%eax
-   140022e05:	jne    0x140022e70
-   140022e07:	jb     0x140022e6e
-   140022e09:	rex.B
-   140022e0a:	fs insl (%dx),%es:(%rdi)
-   140022e0c:	imul   $0x61727473,0x69(%rsi),%ebp
-   140022e13:	je     0x140022e84
-   140022e15:	jb     0x140022e39
-   140022e17:	and    %ch,(%rdi)
-   140022e19:	ds and %bh,(%rdi,%rbp,1)
-   140022e1d:	jbe    0x140022e52
-   140022e1f:	cmp    0x65(%rdx),%dh
-   140022e22:	jno    0x140022e99
-   140022e24:	gs jae 0x140022e9b
-   140022e27:	gs fs push %rax
-   140022e2a:	jb     0x140022e95
-   140022e2c:	jbe    0x140022e97
-   140022e2e:	insb   (%dx),%es:(%rdi)
-   140022e2f:	gs addr32 gs jae 0x140022e72
-   140022e34:	and    %bh,(%rdi,%rbp,1)
-   140022e37:	jbe    0x140022e6c
-   140022e39:	cmp    0x65(%rbx),%dh
-   140022e3c:	movsxd 0x72(%rbp),%esi
-   140022e3f:	imul   $0x762f3c20,0x3e(%rcx,%rdi,2),%esi
-   140022e47:	xor    (%rdx),%edi
-   140022e49:	je     0x140022ebd
-   140022e4b:	jne    0x140022ec0
-   140022e4d:	je     0x140022e98
-   140022e4f:	outsb  %ds:(%rsi),(%dx)
-   140022e50:	outsw  %ds:(%rsi),(%dx)
-   140022e52:	ds and %bh,(%rdi,%rbp,1)
-   140022e56:	(bad)
-   140022e57:	jae    0x140022ecc
-   140022e59:	gs insl (%dx),%es:(%rdi)
-   140022e5b:	(bad)  {%k6}
-   140022e5e:	ds
-   140022e5f:	.byte 0x20
+   140022c9d:	gs cmp $0x63694d22,%eax
+   140022ca3:	jb     0x140022d14
+   140022ca5:	jae    0x140022d16
+   140022ca7:	data16 je 0x140022cd8
+   140022caa:	push   %rdi
+   140022cab:	imul   $0x2e73776f,0x64(%rsi),%ebp
+   140022cb2:	rex.XB outsl %ds:(%rsi),(%dx)
+   140022cb4:	insl   (%dx),%es:(%rdi)
+   140022cb5:	insl   (%dx),%es:(%rdi)
+   140022cb6:	outsl  %ds:(%rsi),(%dx)
+   140022cb7:	outsb  %ds:(%rsi),(%dx)
+   140022cb8:	sub    $0x746e6f43,%eax
+   140022cbd:	jb     0x140022d2e
+   140022cbf:	insb   (%dx),%es:(%rdi)
+   140022cc0:	jae    0x140022ce4
+   140022cc2:	and    %dh,0x65(%rsi)
+   140022cc5:	jb     0x140022d3a
+   140022cc7:	imul   $0x2e36223d,0x6e(%rdi),%ebp
+   140022cce:	xor    %ch,(%rsi)
+   140022cd0:	xor    %ch,(%rsi)
+   140022cd2:	xor    %ah,(%rdx)
+   140022cd4:	and    %dh,0x72(%rax)
+   140022cd7:	outsl  %ds:(%rsi),(%dx)
+   140022cd8:	movsxd 0x73(%rbp),%esp
+   140022cdb:	jae    0x140022d4c
+   140022cdd:	jb     0x140022d20
+   140022cdf:	jb     0x140022d44
+   140022ce1:	push   $0x63657469
+   140022ce6:	je     0x140022d5d
+   140022ce8:	jb     0x140022d4f
+   140022cea:	cmp    $0x20222a22,%eax
+   140022cef:	jo     0x140022d66
+   140022cf1:	(bad)  {%k3}
+   140022cf4:	movsxd 0x65(%rbx),%ecx
+   140022cf7:	jns    0x140022d4d
+   140022cf9:	outsl  %ds:(%rsi),(%dx)
+   140022cfa:	imul   $0x3d,0x6e(%rbp),%esp
+   140022cfe:	and    (%rsi),%dh
+   140022d00:	xor    $0x36623539,%eax
+   140022d05:	xor    $0x31,%al
+   140022d07:	xor    $0x34,%al
+   140022d09:	movsxd 0x66(%rbx),%esp
+   140022d0c:	xor    %esp,0x22(%rsi,%riz,2)
+   140022d10:	and    %ch,0x6e(%rcx,%riz,2)
+   140022d14:	addr32 jne 0x140022d78
+   140022d17:	addr32 gs cmp $0x20222a22,%eax
+   140022d1e:	(bad)
+   140022d1f:	ds and %bh,(%rdi,%rbp,1)
+   140022d23:	fs gs jo 0x140022d8c
+   140022d27:	outsb  %ds:(%rsi),(%dx)
+   140022d28:	fs outsb %gs:(%rsi),(%dx)
+   140022d2b:	je     0x140022d6e
+   140022d2d:	jae    0x140022da2
+   140022d2f:	gs insl (%dx),%es:(%rdi)
+   140022d31:	(bad)  {%k6}
+   140022d34:	ds and %bh,(%rdi,%rbp,1)
+   140022d38:	fs gs jo 0x140022da1
+   140022d3c:	outsb  %ds:(%rsi),(%dx)
+   140022d3d:	fs outsb %gs:(%rsi),(%dx)
+   140022d40:	movsxd 0x3e(%rcx),%edi
+   140022d43:	and    %bh,(%rsi,%rsi,2)
+   140022d46:	xor    (%rdx),%edi
+   140022d48:	je     0x140022dbc
+   140022d4a:	jne    0x140022dbf
+   140022d4c:	je     0x140022d97
+   140022d4e:	outsb  %ds:(%rsi),(%dx)
+   140022d4f:	outsw  %ds:(%rsi),(%dx)
+   140022d51:	and    %bh,0x6d(%rax)
+   140022d54:	insb   (%dx),%es:(%rdi)
+   140022d55:	outsb  %ds:(%rsi),(%dx)
+   140022d56:	jae    0x140022d92
+   140022d58:	jbe    0x140022d8d
+   140022d5a:	cmp    $0x6e727522,%eax
+   140022d5f:	cmp    0x63(%rbx),%dh
+   140022d62:	push   $0x73616d65
+   140022d67:	sub    $0x7263696d,%eax
+   140022d6c:	outsl  %ds:(%rsi),(%dx)
+   140022d6d:	jae    0x140022dde
+   140022d6f:	data16 je 0x140022d9f
+   140022d72:	movsxd 0x6d(%rdi),%ebp
+   140022d75:	cmp    0x73(%rcx),%ah
+   140022d78:	insl   (%dx),%es:(%rdi)
+   140022d79:	jbe,pn 0x140022daf
+   140022d7c:	and    (%rsi),%bh
+   140022d7e:	and    %bh,(%rsi,%rsi,2)
+   140022d81:	xor    (%rdx),%edi
+   140022d83:	jae    0x140022dea
+   140022d85:	movsxd 0x72(%rbp),%esi
+   140022d88:	imul   $0x33763c20,0x3e(%rcx,%rdi,2),%esi
+   140022d90:	cmp    0x65(%rdx),%dh
+   140022d93:	jno    0x140022e0a
+   140022d95:	gs jae 0x140022e0c
+   140022d98:	gs fs push %rax
+   140022d9b:	jb     0x140022e06
+   140022d9d:	jbe    0x140022e08
+   140022d9f:	insb   (%dx),%es:(%rdi)
+   140022da0:	gs addr32 gs jae 0x140022de3
+   140022da5:	and    %bh,(%rcx,%riz,1)
+   140022da8:	sub    $0x656c202d,%eax
+   140022dad:	jbe    0x140022e14
+   140022daf:	insb   (%dx),%es:(%rdi)
+   140022db0:	and    %ah,0x61(%rbx)
+   140022db3:	outsb  %ds:(%rsi),(%dx)
+   140022db4:	and    %ah,0x65(%rdx)
+   140022db7:	and    %ah,(%rdx)
+   140022db9:	(bad)
+   140022dba:	jae    0x140022e05
+   140022dbc:	outsb  %ds:(%rsi),(%dx)
+   140022dbd:	jbe    0x140022e2e
+   140022dbf:	imul   $0x22,0x72(%rbp),%esp
+   140022dc3:	sub    $0x20,%al
+   140022dc5:	and    0x69(%rax),%ch
+   140022dc8:	addr32 push $0x41747365
+   140022dce:	jbe    0x140022e31
+   140022dd0:	imul   $0x2c22656c,0x62(%rcx,%riz,2),%ebp
+   140022dd8:	and    %ch,0x72(%rdi)
+   140022ddb:	and    %ah,(%rdx)
+   140022ddd:	jb     0x140022e44
+   140022ddf:	jno    0x140022e56
+   140022de1:	imul   $0x696d6441,0x65(%rdx),%esi
+   140022de8:	outsb  %ds:(%rsi),(%dx)
+   140022de9:	imul   $0x6f746172,0x74(%rbx),%esi
+   140022df0:	jb     0x140022e14
+   140022df2:	and    %ch,0x3c203e2d(%rip)        # 0x17c226c25
+   140022df8:	jbe    0x140022e2d
+   140022dfa:	cmp    0x65(%rdx),%dh
+   140022dfd:	jno    0x140022e74
+   140022dff:	gs jae 0x140022e76
+   140022e02:	gs fs rex.RB js 0x140022e6c
+   140022e07:	movsxd 0x74(%rbp),%esi
+   140022e0a:	imul   $0x6576654c,0x6e(%rdi),%ebp
+   140022e11:	insb   (%dx),%es:(%rdi)
+   140022e12:	and    %ch,0x76(%rbp,%riz,2)
+   140022e16:	gs insb (%dx),%es:(%rdi)
+   140022e18:	cmp    $0x71657222,%eax
+   140022e1d:	jne    0x140022e88
+   140022e1f:	jb     0x140022e86
+   140022e21:	rex.B
+   140022e22:	fs insl (%dx),%es:(%rdi)
+   140022e24:	imul   $0x61727473,0x69(%rsi),%ebp
+   140022e2b:	je     0x140022e9c
+   140022e2d:	jb     0x140022e51
+   140022e2f:	and    %ch,(%rdi)
+   140022e31:	ds and %bh,(%rdi,%rbp,1)
+   140022e35:	jbe    0x140022e6a
+   140022e37:	cmp    0x65(%rdx),%dh
+   140022e3a:	jno    0x140022eb1
+   140022e3c:	gs jae 0x140022eb3
+   140022e3f:	gs fs push %rax
+   140022e42:	jb     0x140022ead
+   140022e44:	jbe    0x140022eaf
+   140022e46:	insb   (%dx),%es:(%rdi)
+   140022e47:	gs addr32 gs jae 0x140022e8a
+   140022e4c:	and    %bh,(%rdi,%rbp,1)
+   140022e4f:	jbe    0x140022e84
+   140022e51:	cmp    0x65(%rbx),%dh
+   140022e54:	movsxd 0x72(%rbp),%esi
+   140022e57:	imul   $0x762f3c20,0x3e(%rcx,%rdi,2),%esi
+   140022e5f:	xor    (%rdx),%edi
+   140022e61:	je     0x140022ed5
+   140022e63:	jne    0x140022ed8
+   140022e65:	je     0x140022eb0
+   140022e67:	outsb  %ds:(%rsi),(%dx)
+   140022e68:	outsw  %ds:(%rsi),(%dx)
+   140022e6a:	ds and %bh,(%rdi,%rbp,1)
+   140022e6e:	(bad)
+   140022e6f:	jae    0x140022ee4
+   140022e71:	gs insl (%dx),%es:(%rdi)
+   140022e73:	(bad)  {%k6}
+   140022e76:	ds
+   140022e77:	.byte 0x20
```

### Comparing `build/exe/desktop.exe` & `build/exe/depsland-gui-debug.exe`

 * *Files 1% similar despite different names*

#### objdump

```diff
@@ -40,15 +40,15 @@
 SizeOfHeapCommit	0000000000001000
 LoaderFlags		00000000
 NumberOfRvaAndSizes	00000010
 
 The Data Directory
 Entry 0 0000000000000000 00000000 Export Directory [.edata (or where ever we found it)]
 Entry 1 000000000001b384 000000b4 Import Directory [parts of .idata]
-Entry 2 000000000001e000 00004e54 Resource Directory [.rsrc]
+Entry 2 000000000001e000 00004e7c Resource Directory [.rsrc]
 Entry 3 0000000000016000 00001164 Exception Directory [.pdata]
 Entry 4 0000000000000000 00000000 Security Directory
 Entry 5 0000000000000000 00000000 Base Relocation Directory [.reloc]
 Entry 6 0000000000000000 00000000 Debug Directory
 Entry 7 0000000000000000 00000000 Description Directory
 Entry 8 0000000000000000 00000000 Special Directory
 Entry 9 0000000000000000 00000000 Thread Storage Directory [.tls]
@@ -742,38 +742,38 @@
 030    Name Table: Char: 0, Time: 00000000, Ver: 4/0, Num Names: 0, IDs: 1
 040     Entry: ID: 0x000001, Value: 0x800000a0
 0a0      Language Table: Char: 0, Time: 00000000, Ver: 4/0, Num Names: 0, IDs: 1
 0b0       Entry: ID: 00000000, Value: 0x000130
 130        Leaf: Addr: 0x01e258, Size: 0x0048d2, Codepage: 1252
 018   Entry: ID: 0x00000a, Value: 0x80000048
 048    Name Table: Char: 0, Time: 00000000, Ver: 4/0, Num Names: 3, IDs: 0
-058     Entry: name: [val: 80000190 len 32]: 565CEC64F2627FB9A588B0F30D7C4A2A, Value: 0x800000b8
+058     Entry: name: [val: 80000190 len 32]: E54234F4D7D61A49D396444CD264DD34, Value: 0x800000b8
 0b8      Language Table: Char: 0, Time: 00000000, Ver: 4/0, Num Names: 0, IDs: 1
 0c8       Entry: ID: 00000000, Value: 0x000140
-140        Leaf: Addr: 0x022b2c, Size: 0x00004f, Codepage: 1252
-060     Entry: name: [val: 800001d2 len 32]: 68D91FF40F8D2E17F94E65B0562607CA, Value: 0x800000d0
+140        Leaf: Addr: 0x022b2c, Size: 0x000077, Codepage: 1252
+060     Entry: name: [val: 800001d2 len 32]: F6F335B79DA7CD4B609C868051AB31CB, Value: 0x800000d0
 0d0      Language Table: Char: 0, Time: 00000000, Ver: 4/0, Num Names: 0, IDs: 1
 0e0       Entry: ID: 00000000, Value: 0x000150
-150        Leaf: Addr: 0x022b7c, Size: 0x000006, Codepage: 1252
-068     Entry: name: [val: 80000214 len 32]: FC51912F4D631F0C90464587AA9F498B, Value: 0x800000e8
+150        Leaf: Addr: 0x022ba4, Size: 0x00001a, Codepage: 1252
+068     Entry: name: [val: 80000214 len 32]: FAB0190B41B33168E69DDA53B74F2D1E, Value: 0x800000e8
 0e8      Language Table: Char: 0, Time: 00000000, Ver: 4/0, Num Names: 0, IDs: 1
 0f8       Entry: ID: 00000000, Value: 0x000160
-160        Leaf: Addr: 0x022b84, Size: 0x00001c, Codepage: 1252
+160        Leaf: Addr: 0x022bc0, Size: 0x000006, Codepage: 1252
 020   Entry: ID: 0x00000e, Value: 0x80000070
 070    Name Table: Char: 0, Time: 00000000, Ver: 4/0, Num Names: 0, IDs: 1
 080     Entry: ID: 0x000001, Value: 0x80000100
 100      Language Table: Char: 0, Time: 00000000, Ver: 4/0, Num Names: 0, IDs: 1
 110       Entry: ID: 00000000, Value: 0x000170
-170        Leaf: Addr: 0x022ba0, Size: 0x000014, Codepage: 1252
+170        Leaf: Addr: 0x022bc8, Size: 0x000014, Codepage: 1252
 028   Entry: ID: 0x000018, Value: 0x80000088
 088    Name Table: Char: 0, Time: 00000000, Ver: 4/0, Num Names: 0, IDs: 1
 098     Entry: ID: 0x000001, Value: 0x80000118
 118      Language Table: Char: 0, Time: 00000000, Ver: 4/0, Num Names: 0, IDs: 1
 128       Entry: ID: 00000000, Value: 0x000180
-180        Leaf: Addr: 0x022bb4, Size: 0x0002a0, Codepage: 1252
+180        Leaf: Addr: 0x022bdc, Size: 0x0002a0, Codepage: 1252
  String table starts at offset: 0x190
  Resources start at offset: 0x258
 
 Sections:
 Idx Name          Size      VMA               LMA               File off  Algn
   0 .code         00004480  0000000140001000  0000000140001000  00000400  2**2
                   CONTENTS, ALLOC, LOAD, READONLY, CODE
@@ -781,15 +781,15 @@
                   CONTENTS, ALLOC, LOAD, READONLY, CODE
   2 .pdata        00001164  0000000140016000  0000000140016000  00014800  2**2
                   CONTENTS, ALLOC, LOAD, READONLY, DATA
   3 .rdata        0000218d  0000000140018000  0000000140018000  00015a00  2**4
                   CONTENTS, ALLOC, LOAD, READONLY, DATA
   4 .data         00001c00  000000014001b000  000000014001b000  00017c00  2**4
                   CONTENTS, ALLOC, LOAD, DATA
-  5 .rsrc         00004e54  000000014001e000  000000014001e000  00019800  2**2
+  5 .rsrc         00004e7c  000000014001e000  000000014001e000  00019800  2**2
                   CONTENTS, ALLOC, LOAD, READONLY, DATA
 SYMBOL TABLE:
 no symbols
 
 
 
 Disassembly of section .code:
@@ -29999,25 +29999,22 @@
    14001b317:	xchg   %eax,%ecx
    14001b318:	xchg   %eax,%ebx
    14001b319:	nop
    14001b31a:	xchg   %eax,%edi
    14001b31b:	xchg   %eax,%esp
    14001b31c:	fwait
    14001b31d:	(bad)
-   14001b31e:	add    $0x350cf92a,%esp
-   14001b324:	pop    %rsi
-   14001b325:	andps  (%rbx),%xmm3
-   14001b328:	jmp    0x14001b39d
-   14001b32a:	xor    %esp,%edx
-   14001b32c:	rclb   $0xcf,0x22(%rsi)
-   14001b330:	out    %eax,(%dx)
-   14001b331:	and    $0x7f,%al
-   14001b333:	cmp    %ebp,%edx
-   14001b335:	(bad)
-   14001b336:	add    %al,(%rax)
+   14001b31e:	add    $0x9acaf92a,%esp
+   14001b324:	ss es loop 0x14001b2e7
+   14001b328:	rex.WX
+   14001b329:	rex.XB push %r13
+   14001b32b:	xor    %edi,0x2b(%rbx)
+   14001b32e:	data16 jne 0x14001b32b
+   14001b331:	and    0x3b(%rdi),%edi
+   14001b334:	{rex2 0x6} add %r8b,(%rax)
    14001b338:	(bad)
    14001b339:	(bad)
    14001b33a:	(bad)
    14001b33b:	incl   (%rax)
    14001b33d:	adc    %al,(%rax)
    14001b33f:	add    %al,0x0(%rax)
 	...
@@ -32496,113 +32493,121 @@
    14001e134:	rorb   %cl,0x0(%rax)
    14001e137:	add    %ah,%ah
    14001e139:	add    $0x0,%al
    14001e13b:	add    %al,(%rax)
    14001e13d:	add    %al,(%rax)
    14001e13f:	add    %ch,(%rbx,%rbp,1)
    14001e142:	add    (%rax),%al
-   14001e144:	rex.WRXB add %r8b,(%r8)
-   14001e147:	add    %ah,%ah
-   14001e149:	add    $0x0,%al
-   14001e14b:	add    %al,(%rax)
-   14001e14d:	add    %al,(%rax)
-   14001e14f:	add    %bh,0x2(%rbx,%rbp,1)
-   14001e153:	add    %al,(%rsi)
+   14001e144:	ja     0x14001e146
+   14001e146:	add    %al,(%rax)
+   14001e148:	in     $0x4,%al
+   14001e14a:	add    %al,(%rax)
+   14001e14c:	add    %al,(%rax)
+   14001e14e:	add    %al,(%rax)
+   14001e150:	movsb  %ds:(%rsi),%es:(%rdi)
+   14001e151:	sub    (%rdx),%eax
+   14001e153:	add    %bl,(%rdx)
    14001e155:	add    %al,(%rax)
    14001e157:	add    %ah,%ah
    14001e159:	add    $0x0,%al
    14001e15b:	add    %al,(%rax)
    14001e15d:	add    %al,(%rax)
-   14001e15f:	add    %al,0x1c0002(%rbx,%rbp,1)
-   14001e166:	add    %al,(%rax)
-   14001e168:	in     $0x4,%al
-   14001e16a:	add    %al,(%rax)
-   14001e16c:	add    %al,(%rax)
-   14001e16e:	add    %al,(%rax)
-   14001e170:	movabs 0xe40000001400022b,%al
-   14001e179:	add    $0x0,%al
-   14001e17b:	add    %al,(%rax)
-   14001e17d:	add    %al,(%rax)
-   14001e17f:	add    %dh,0x2a00002(%rbx,%rbp,1)
-   14001e186:	add    %al,(%rax)
-   14001e188:	in     $0x4,%al
-   14001e18a:	add    %al,(%rax)
-   14001e18c:	add    %al,(%rax)
-   14001e18e:	add    %al,(%rax)
-   14001e190:	and    %al,(%rax)
-   14001e192:	xor    $0x35003600,%eax
-   14001e197:	add    %al,0x0(%rbx)
-   14001e19a:	add    %r8b,0x0(%r11)
-   14001e19e:	ss add %dh,(%rax,%rax,1)
-   14001e1a2:	rex.RX add %r14b,(%rdx)
-   14001e1a5:	add    %dh,(%rsi)
-   14001e1a7:	add    %dh,(%rdx)
-   14001e1a9:	add    %dh,(%rdi)
-   14001e1ab:	add    %al,0x0(%rsi)
-   14001e1ae:	rex.X add %dil,(%rcx)
-   14001e1b1:	add    %al,0x0(%rcx)
-   14001e1b4:	xor    $0x38003800,%eax
-   14001e1b9:	add    %al,0x0(%rdx)
-   14001e1bc:	xor    %al,(%rax)
-   14001e1be:	rex.RX add %r14b,(%rbx)
-   14001e1c1:	add    %dh,(%rax)
-   14001e1c3:	add    %al,0x37(%rax,%rax,1)
-   14001e1c7:	add    %al,0x0(%rbx)
-   14001e1ca:	xor    $0x0,%al
-   14001e1cc:	add    %sil,(%r10)
-   14001e1cf:	add    %al,0x0(%rcx)
+   14001e15f:	add    %al,%al
+   14001e161:	sub    (%rdx),%eax
+   14001e163:	add    %al,(%rsi)
+   14001e165:	add    %al,(%rax)
+   14001e167:	add    %ah,%ah
+   14001e169:	add    $0x0,%al
+   14001e16b:	add    %al,(%rax)
+   14001e16d:	add    %al,(%rax)
+   14001e16f:	add    %cl,%al
+   14001e171:	sub    (%rdx),%eax
+   14001e173:	add    %dl,(%rax,%rax,1)
+   14001e176:	add    %al,(%rax)
+   14001e178:	in     $0x4,%al
+   14001e17a:	add    %al,(%rax)
+   14001e17c:	add    %al,(%rax)
+   14001e17e:	add    %al,(%rax)
+   14001e180:	fsubrl (%rbx)
+   14001e182:	add    (%rax),%al
+   14001e184:	movabs 0x4e4000002,%al
+   14001e18d:	add    %al,(%rax)
+   14001e18f:	add    %ah,(%rax)
+   14001e191:	add    %al,0x0(%rbp)
+   14001e194:	xor    $0x32003400,%eax
+   14001e199:	add    %dh,(%rbx)
+   14001e19b:	add    %dh,(%rax,%rax,1)
+   14001e19e:	add    %r14b,(%rax,%r8,1)
+   14001e1a2:	add    %r14b,(%rdi)
+   14001e1a5:	add    %al,0x36(%rax,%rax,1)
+   14001e1a9:	add    %dh,(%rcx)
+   14001e1ab:	add    %al,0x0(%rcx)
+   14001e1ae:	xor    $0x0,%al
+   14001e1b0:	cmp    %eax,(%rax)
+   14001e1b2:	add    %r14b,(%rbx)
+   14001e1b5:	add    %bh,(%rcx)
+   14001e1b7:	add    %dh,(%rsi)
+   14001e1b9:	add    %dh,(%rax,%rax,1)
+   14001e1bc:	xor    $0x0,%al
+   14001e1be:	xor    $0x0,%al
+   14001e1c0:	add    %al,0x32(%r8,%r8,1)
+   14001e1c5:	add    %dh,(%rsi)
+   14001e1c7:	add    %dh,(%rax,%rax,1)
+   14001e1ca:	add    %r8b,0x33(%rax,%rax,1)
+   14001e1cf:	add    %dh,(%rax,%rax,1)
    14001e1d2:	and    %al,(%rax)
-   14001e1d4:	ss add %bh,(%rax)
-   14001e1d7:	add    %al,0x39(%rax,%rax,1)
-   14001e1db:	add    %dh,(%rcx)
-   14001e1dd:	add    %al,0x0(%rsi)
-   14001e1e0:	add    %r14b,(%rax,%r8,1)
-   14001e1e4:	xor    %al,(%rax)
-   14001e1e6:	rex.RX add %r15b,(%rax)
-   14001e1e9:	add    %al,0x32(%rax,%rax,1)
-   14001e1ed:	add    %al,0x0(%rbp)
-   14001e1f0:	xor    %eax,(%rax)
-   14001e1f2:	(bad)
-   14001e1f3:	add    %al,0x0(%rsi)
-   14001e1f6:	cmp    %eax,(%rax)
-   14001e1f8:	xor    $0x0,%al
-   14001e1fa:	add    %r14b,(%r14)
-   14001e1fd:	add    %dh,0x30004200(%rip)        # 0x170022403
-   14001e203:	add    %dh,0x32003600(%rip)        # 0x172021809
-   14001e209:	add    %dh,(%rsi)
-   14001e20b:	add    %dh,(%rax)
-   14001e20d:	add    %dh,(%rdi)
-   14001e20f:	add    %al,0x0(%rbx)
-   14001e212:	add    %spl,(%r8)
-   14001e215:	add    %al,0x0(%rsi)
-   14001e218:	rex.XB add %sil,0x39003100(%rip)        # 0x17902131f
-   14001e21f:	add    %dh,(%rcx)
-   14001e221:	add    %dh,(%rdx)
-   14001e223:	add    %al,0x0(%rsi)
+   14001e1d4:	rex.RX add %r14b,(%rsi)
+   14001e1d7:	add    %al,0x0(%rsi)
+   14001e1da:	xor    (%rax),%eax
+   14001e1dc:	xor    (%rax),%eax
+   14001e1de:	xor    $0x37004200,%eax
+   14001e1e3:	add    %bh,(%rcx)
+   14001e1e5:	add    %al,0x41(%rax,%rax,1)
+   14001e1e9:	add    %dh,(%rdi)
+   14001e1eb:	add    %al,0x0(%rbx)
+   14001e1ee:	add    %r14b,(%rax,%rax,1)
+   14001e1f2:	rex.X add %sil,(%rsi)
+   14001e1f5:	add    %dh,(%rax)
+   14001e1f7:	add    %bh,(%rcx)
+   14001e1f9:	add    %al,0x0(%rbx)
+   14001e1fc:	cmp    %al,(%rax)
+   14001e1fe:	ss add %bh,(%rax)
+   14001e201:	add    %dh,(%rax)
+   14001e203:	add    %dh,0x41003100(%rip)        # 0x181021309
+   14001e209:	add    %al,0x0(%rdx)
+   14001e20c:	xor    (%rax),%eax
+   14001e20e:	xor    %eax,(%rax)
+   14001e210:	rex.XB add %al,0x0(%r10)
+   14001e214:	and    %al,(%rax)
+   14001e216:	rex.RX add %r8b,0x0(%rcx)
+   14001e21a:	rex.X add %sil,(%rax)
+   14001e21d:	add    %dh,(%rcx)
+   14001e21f:	add    %bh,(%rcx)
+   14001e221:	add    %dh,(%rax)
+   14001e223:	add    %al,0x0(%rdx)
    14001e226:	xor    $0x0,%al
-   14001e228:	add    %r14b,(%rsi)
-   14001e22b:	add    %dh,(%rbx)
-   14001e22d:	add    %dh,(%rcx)
-   14001e22f:	add    %al,0x0(%rsi)
-   14001e232:	xor    %al,(%rax)
-   14001e234:	rex.XB add %dil,(%r9)
-   14001e237:	add    %dh,(%rax)
-   14001e239:	add    %dh,(%rax,%rax,1)
-   14001e23c:	ss add %dh,(%rax,%rax,1)
-   14001e240:	xor    $0x37003800,%eax
-   14001e245:	add    %al,0x0(%rcx)
-   14001e248:	add    %dil,(%r9)
-   14001e24b:	add    %al,0x0(%rsi)
-   14001e24e:	xor    $0x0,%al
-   14001e250:	cmp    %eax,(%rax)
-   14001e252:	cmp    %al,(%rax)
-   14001e254:	rex.X add %al,(%rax)
-   14001e257:	add    %cl,0xd474e50(%rcx)
-   14001e25d:	or     (%rdx),%bl
-   14001e25f:	or     (%rax),%al
+   14001e228:	xor    %eax,(%rax)
+   14001e22a:	rex.X add %sil,(%rbx)
+   14001e22d:	add    %dh,(%rbx)
+   14001e22f:	add    %dh,(%rcx)
+   14001e231:	add    %dh,(%rsi)
+   14001e233:	add    %bh,(%rax)
+   14001e235:	add    %al,0x0(%rbp)
+   14001e238:	ss add %bh,(%rcx)
+   14001e23b:	add    %al,0x44(%rax,%rax,1)
+   14001e23f:	add    %al,0x0(%rcx)
+   14001e242:	xor    $0x42003300,%eax
+   14001e247:	add    %dh,(%rdi)
+   14001e249:	add    %dh,(%rax,%rax,1)
+   14001e24c:	rex.RX add %r14b,(%rdx)
+   14001e24f:	add    %al,0x31(%rax,%rax,1)
+   14001e253:	add    %al,0x0(%rbp)
+   14001e256:	add    %al,(%rax)
+   14001e258:	mov    %edx,0x4e(%rax)
+   14001e25b:	rex.RXB or $0xa1a0a,%eax
    14001e261:	add    %al,(%rax)
    14001e263:	or     $0x52444849,%eax
    14001e268:	add    %al,(%rax)
    14001e26a:	add    %eax,(%rax)
    14001e26c:	add    %al,(%rax)
    14001e26e:	add    %eax,(%rax)
    14001e270:	or     %al,(%rsi)
@@ -39713,302 +39718,326 @@
    140022b22:	rex.WB
    140022b23:	rex.RB
    140022b24:	rex.WRX
    140022b25:	rex.R scas %es:(%rdi),%al
    140022b27:	rex.X (bad)
    140022b29:	(bad)
    140022b2a:	push   %rax
-   140022b2b:	rex.B sub $0x61,%al
-   140022b2e:	fcomps -0x6d(%rax)
-   140022b31:	(bad)
-   140022b32:	fbld   (%rbx)
-   140022b34:	hlt
-   140022b35:	scas   %es:(%rdi),%al
-   140022b36:	ffree  %st(3)
-   140022b38:	rex.B lods %ds:(%rsi),%al
-   140022b3a:	rex.R movabs 0x29b8193cc0e201e,%al
-   140022b44:	sub    %dl,(%rdx)
-   140022b46:	(bad)
-   140022b48:	test   $0x1ff2dd30,%eax
-   140022b4d:	(bad)
-   140022b4e:	push   %rax
-   140022b4f:	rex.WX int1
-   140022b51:	mov    $0xf5f4652a,%ebx
-   140022b56:	sahf
-   140022b57:	test   %ecx,-0x7635199e(%rip)        # 0xc9cd11bf
-   140022b5d:	fsin
-   140022b5f:	xor    -0x55(%rcx),%dh
-   140022b62:	sbb    %bh,0x5c4c6c3a(%rbx)
-   140022b68:	(bad)
-   140022b69:	sarb   %cl,0x64188ca5(%rdi)
-   140022b6f:	pop    %rdi
-   140022b70:	pcmpgtb (%rbx,%rsi,2),%mm3
-   140022b74:	add    %ah,(%rdi)
-   140022b76:	mov    $0x10d22914,%edi
-   140022b7b:	push   %rax
-   140022b7c:	add    %eax,(%rcx)
-   140022b7e:	add    %eax,(%rax)
-   140022b80:	add    %al,(%rax)
-   140022b82:	push   %rax
-   140022b83:	rex.B sub $0x61,%al
-   140022b86:	fcomps -0x6a(%rax)
-   140022b89:	adc    $0xe3e4678e,%eax
-   140022b8e:	mov    -0x6cf744b9(%rbx),%dl
-   140022b94:	cmp    %ch,0x49(%rbp)
-   140022b97:	rclb   $0x5f,0x5056e4d1(%rbx)
-   140022b9e:	(bad)
-   140022b9f:	push   %rcx
-   140022ba0:	add    %al,(%rax)
-   140022ba2:	add    %eax,(%rax)
-   140022ba4:	add    %eax,(%rax)
-   140022ba6:	add    %al,(%rax)
-   140022ba8:	add    %al,(%rax)
-   140022baa:	add    %eax,(%rax)
-   140022bac:	and    %al,(%rax)
-   140022bae:	rorb   %cl,0x0(%rax)
-   140022bb1:	add    %al,(%rcx)
-   140022bb3:	add    %bh,(%rdi,%rdi,1)
-   140022bb6:	js     0x140022c25
-   140022bb8:	insb   (%dx),%es:(%rdi)
-   140022bb9:	and    %dh,0x65(%rsi)
-   140022bbc:	jb     0x140022c31
-   140022bbe:	imul   $0x2e31223d,0x6e(%rdi),%ebp
-   140022bc5:	xor    %ah,(%rdx)
-   140022bc7:	and    %ah,0x6e(%rbp)
-   140022bca:	movsxd 0x64(%rdi),%ebp
-   140022bcd:	imul   $0x5455223d,0x67(%rsi),%ebp
-   140022bd4:	rex.RX sub $0x73202238,%eax
-   140022bda:	je     0x140022c3d
-   140022bdc:	outsb  %ds:(%rsi),(%dx)
-   140022bdd:	fs (bad)
-   140022bdf:	insb   (%dx),%es:(%rdi)
-   140022be0:	outsl  %ds:(%rsi),(%dx)
-   140022be1:	outsb  %ds:(%rsi),(%dx)
-   140022be2:	gs cmp $0x73657922,%eax
-   140022be8:	and    (%rdi),%bh
-   140022bea:	ds and %bh,(%rcx,%riz,2)
-   140022bee:	jae    0x140022c63
-   140022bf0:	gs insl (%dx),%es:(%rdi)
-   140022bf2:	(bad)
-   140022bf5:	and    %bh,0x6d(%rax)
-   140022bf8:	insb   (%dx),%es:(%rdi)
-   140022bf9:	outsb  %ds:(%rsi),(%dx)
-   140022bfa:	jae    0x140022c39
-   140022bfc:	and    0x72(%rbp),%dh
-   140022bff:	outsb  %ds:(%rsi),(%dx)
-   140022c00:	cmp    0x63(%rbx),%dh
-   140022c03:	push   $0x73616d65
-   140022c08:	sub    $0x7263696d,%eax
-   140022c0d:	outsl  %ds:(%rsi),(%dx)
-   140022c0e:	jae    0x140022c7f
-   140022c10:	data16 je 0x140022c40
-   140022c13:	movsxd 0x6d(%rdi),%ebp
-   140022c16:	cmp    0x73(%rcx),%ah
-   140022c19:	insl   (%dx),%es:(%rdi)
-   140022c1a:	jbe,pn 0x140022c4e
-   140022c1d:	and    (%rax),%ah
-   140022c1f:	insl   (%dx),%es:(%rdi)
-   140022c20:	(bad)
+   140022b2b:	cmp    %ecx,-0x2750503d(%r11)
+   140022b32:	cmp    0x59(%rax),%ah
+   140022b35:	xor    %bl,0x2(%rsi)
+   140022b38:	movl   $0xcf09b71,0x17c3fae1(%rip)        # 0x157c62623
+   140022b42:	jae    0x140022ba3
+   140022b44:	lret
+   140022b45:	rex.XB leave
+   140022b47:	sub    %edx,(%rsi)
+   140022b49:	jmp    0x140022b50
+   140022b4b:	jb,pn  0x140022b0b
+   140022b4e:	movsl  %ds:(%rsi),%es:(%rdi)
+   140022b4f:	repz pop %rdx
+   140022b51:	push   $0x740a4e64
+   140022b56:	jo     0x140022b7f
+   140022b58:	pop    %rdi
+   140022b59:	movabs 0x5a7456abdab2fa2a,%eax
+   140022b62:	(bad)
+   140022b65:	in     (%dx),%eax
+   140022b66:	fs rex.WB ror $0x77,%r9b
+   140022b6b:	outsl  %ds:(%rsi),(%dx)
+   140022b6c:	fldl   (%rdi)
+   140022b6e:	(bad)
+   140022b6f:	iret
+   140022b70:	(bad)
+   140022b71:	or     %edi,%fs:(%rsi)
+   140022b74:	ret
+   140022b75:	push   %rbp
+   140022b76:	(bad)
+   140022b77:	(bad)
+   140022b78:	fisubrl (%rbx)
+   140022b7a:	mov    %ecx,%ebx
+   140022b7c:	jae    0x140022b08
+   140022b7e:	(bad)
+   140022b7f:	jo     0x140022b0a
+   140022b81:	mov    $0x68916f9,%esp
+   140022b86:	sub    %ebp,(%rdx)
+   140022b88:	push   %rcx
+   140022b89:	pop    %rax
+   140022b8a:	cmpsl  %es:(%rdi),%ds:(%rsi)
+   140022b8b:	(bad)
+   140022b91:	movsl  %ds:(%rsi),%es:(%rdi)
+   140022b92:	negl   0x46587280(%rdx)
+   140022b98:	push   %rbx
+   140022b99:	sub    (%rdi),%edx
+   140022b9b:	cmp    (%rcx),%al
+   140022b9d:	fnstenv 0x79298768(%rbx)
+   140022ba3:	push   %rax
+   140022ba4:	cmp    %ecx,-0x2855503d(%rbx)
+   140022baa:	push   $0x4
+   140022bac:	push   %rcx
+   140022bad:	outsl  %ds:(%rsi),(%dx)
+   140022bae:	(bad)
+   140022baf:	sbb    $0x90,%al
+   140022bb1:	adc    $0xa6,%al
+   140022bb3:	fwait
+   140022bb4:	popf
+   140022bb5:	sbb    %ah,-0x27(%rdx)
+   140022bb8:	lret
+   140022bb9:	ss or  %esi,-0x1b(%rbp)
+   140022bbd:	jns    0x140022c0f
+   140022bbf:	add    %eax,(%r9)
+   140022bc2:	add    %eax,(%rax)
+   140022bc4:	add    %al,(%rax)
+   140022bc6:	push   %rax
+   140022bc7:	add    %al,(%r8)
+   140022bca:	add    %eax,(%rax)
+   140022bcc:	add    %eax,(%rax)
+   140022bce:	add    %al,(%rax)
+   140022bd0:	add    %al,(%rax)
+   140022bd2:	add    %eax,(%rax)
+   140022bd4:	and    %al,(%rax)
+   140022bd6:	rorb   %cl,0x0(%rax)
+   140022bd9:	add    %al,(%rcx)
+   140022bdb:	add    %bh,(%rdi,%rdi,1)
+   140022bde:	js     0x140022c4d
+   140022be0:	insb   (%dx),%es:(%rdi)
+   140022be1:	and    %dh,0x65(%rsi)
+   140022be4:	jb     0x140022c59
+   140022be6:	imul   $0x2e31223d,0x6e(%rdi),%ebp
+   140022bed:	xor    %ah,(%rdx)
+   140022bef:	and    %ah,0x6e(%rbp)
+   140022bf2:	movsxd 0x64(%rdi),%ebp
+   140022bf5:	imul   $0x5455223d,0x67(%rsi),%ebp
+   140022bfc:	rex.RX sub $0x73202238,%eax
+   140022c02:	je     0x140022c65
+   140022c04:	outsb  %ds:(%rsi),(%dx)
+   140022c05:	fs (bad)
+   140022c07:	insb   (%dx),%es:(%rdi)
+   140022c08:	outsl  %ds:(%rsi),(%dx)
+   140022c09:	outsb  %ds:(%rsi),(%dx)
+   140022c0a:	gs cmp $0x73657922,%eax
+   140022c10:	and    (%rdi),%bh
+   140022c12:	ds and %bh,(%rcx,%riz,2)
+   140022c16:	jae    0x140022c8b
+   140022c18:	gs insl (%dx),%es:(%rdi)
+   140022c1a:	(bad)
+   140022c1d:	and    %bh,0x6d(%rax)
+   140022c20:	insb   (%dx),%es:(%rdi)
    140022c21:	outsb  %ds:(%rsi),(%dx)
-   140022c22:	imul   $0x65567473,0x65(%rsi),%esp
-   140022c29:	jb     0x140022c9e
-   140022c2b:	imul   $0x2e31223d,0x6e(%rdi),%ebp
-   140022c32:	xor    %ah,(%rdx)
-   140022c34:	ds and %bh,(%rsp,%riz,2)
-   140022c38:	gs jo  0x140022ca0
-   140022c3b:	outsb  %ds:(%rsi),(%dx)
-   140022c3c:	fs outsb %gs:(%rsi),(%dx)
-   140022c3f:	movsxd 0x3e(%rcx),%edi
-   140022c42:	and    %bh,(%rsp,%riz,2)
-   140022c45:	gs jo  0x140022cad
-   140022c48:	outsb  %ds:(%rsi),(%dx)
-   140022c49:	fs outsb %gs:(%rsi),(%dx)
-   140022c4c:	je     0x140022c8f
-   140022c4e:	jae    0x140022cc3
-   140022c50:	gs insl (%dx),%es:(%rdi)
-   140022c52:	(bad)  {%k6}
-   140022c55:	ds and %bh,(%rcx,%riz,2)
-   140022c59:	jae    0x140022cce
-   140022c5b:	gs insl (%dx),%es:(%rdi)
-   140022c5d:	(bad)  {%k1}
-   140022c60:	rex.WB
-   140022c61:	fs outsb %gs:(%rsi),(%dx)
-   140022c64:	je     0x140022ccf
-   140022c66:	je     0x140022ce1
-   140022c68:	and    %dh,0x70(%rcx,%rdi,2)
-   140022c6c:	gs cmp $0x6e697722,%eax
-   140022c72:	xor    (%rdx),%esi
-   140022c74:	and    (%rax),%ah
-   140022c76:	outsb  %ds:(%rsi),(%dx)
-   140022c77:	(bad)
-   140022c78:	insl   (%dx),%es:(%rdi)
-   140022c79:	gs cmp $0x63694d22,%eax
-   140022c7f:	jb     0x140022cf0
-   140022c81:	jae    0x140022cf2
-   140022c83:	data16 je 0x140022cb4
-   140022c86:	push   %rdi
-   140022c87:	imul   $0x2e73776f,0x64(%rsi),%ebp
-   140022c8e:	rex.XB outsl %ds:(%rsi),(%dx)
-   140022c90:	insl   (%dx),%es:(%rdi)
-   140022c91:	insl   (%dx),%es:(%rdi)
-   140022c92:	outsl  %ds:(%rsi),(%dx)
-   140022c93:	outsb  %ds:(%rsi),(%dx)
-   140022c94:	sub    $0x746e6f43,%eax
-   140022c99:	jb     0x140022d0a
-   140022c9b:	insb   (%dx),%es:(%rdi)
-   140022c9c:	jae    0x140022cc0
-   140022c9e:	and    %dh,0x65(%rsi)
-   140022ca1:	jb     0x140022d16
-   140022ca3:	imul   $0x2e36223d,0x6e(%rdi),%ebp
-   140022caa:	xor    %ch,(%rsi)
-   140022cac:	xor    %ch,(%rsi)
-   140022cae:	xor    %ah,(%rdx)
-   140022cb0:	and    %dh,0x72(%rax)
-   140022cb3:	outsl  %ds:(%rsi),(%dx)
-   140022cb4:	movsxd 0x73(%rbp),%esp
-   140022cb7:	jae    0x140022d28
-   140022cb9:	jb     0x140022cfc
-   140022cbb:	jb     0x140022d20
-   140022cbd:	push   $0x63657469
-   140022cc2:	je     0x140022d39
-   140022cc4:	jb     0x140022d2b
-   140022cc6:	cmp    $0x20222a22,%eax
-   140022ccb:	jo     0x140022d42
-   140022ccd:	(bad)  {%k3}
-   140022cd0:	movsxd 0x65(%rbx),%ecx
-   140022cd3:	jns    0x140022d29
-   140022cd5:	outsl  %ds:(%rsi),(%dx)
-   140022cd6:	imul   $0x3d,0x6e(%rbp),%esp
-   140022cda:	and    (%rsi),%dh
-   140022cdc:	xor    $0x36623539,%eax
-   140022ce1:	xor    $0x31,%al
-   140022ce3:	xor    $0x34,%al
-   140022ce5:	movsxd 0x66(%rbx),%esp
-   140022ce8:	xor    %esp,0x22(%rsi,%riz,2)
-   140022cec:	and    %ch,0x6e(%rcx,%riz,2)
-   140022cf0:	addr32 jne 0x140022d54
-   140022cf3:	addr32 gs cmp $0x20222a22,%eax
-   140022cfa:	(bad)
-   140022cfb:	ds and %bh,(%rdi,%rbp,1)
-   140022cff:	fs gs jo 0x140022d68
-   140022d03:	outsb  %ds:(%rsi),(%dx)
-   140022d04:	fs outsb %gs:(%rsi),(%dx)
-   140022d07:	je     0x140022d4a
-   140022d09:	jae    0x140022d7e
-   140022d0b:	gs insl (%dx),%es:(%rdi)
-   140022d0d:	(bad)  {%k6}
-   140022d10:	ds and %bh,(%rdi,%rbp,1)
-   140022d14:	fs gs jo 0x140022d7d
-   140022d18:	outsb  %ds:(%rsi),(%dx)
-   140022d19:	fs outsb %gs:(%rsi),(%dx)
-   140022d1c:	movsxd 0x3e(%rcx),%edi
-   140022d1f:	and    %bh,(%rsi,%rsi,2)
-   140022d22:	xor    (%rdx),%edi
-   140022d24:	je     0x140022d98
-   140022d26:	jne    0x140022d9b
-   140022d28:	je     0x140022d73
-   140022d2a:	outsb  %ds:(%rsi),(%dx)
-   140022d2b:	outsw  %ds:(%rsi),(%dx)
-   140022d2d:	and    %bh,0x6d(%rax)
-   140022d30:	insb   (%dx),%es:(%rdi)
-   140022d31:	outsb  %ds:(%rsi),(%dx)
-   140022d32:	jae    0x140022d6e
-   140022d34:	jbe    0x140022d69
-   140022d36:	cmp    $0x6e727522,%eax
-   140022d3b:	cmp    0x63(%rbx),%dh
-   140022d3e:	push   $0x73616d65
-   140022d43:	sub    $0x7263696d,%eax
-   140022d48:	outsl  %ds:(%rsi),(%dx)
-   140022d49:	jae    0x140022dba
-   140022d4b:	data16 je 0x140022d7b
-   140022d4e:	movsxd 0x6d(%rdi),%ebp
-   140022d51:	cmp    0x73(%rcx),%ah
-   140022d54:	insl   (%dx),%es:(%rdi)
-   140022d55:	jbe,pn 0x140022d8b
-   140022d58:	and    (%rsi),%bh
-   140022d5a:	and    %bh,(%rsi,%rsi,2)
-   140022d5d:	xor    (%rdx),%edi
-   140022d5f:	jae    0x140022dc6
-   140022d61:	movsxd 0x72(%rbp),%esi
-   140022d64:	imul   $0x33763c20,0x3e(%rcx,%rdi,2),%esi
-   140022d6c:	cmp    0x65(%rdx),%dh
-   140022d6f:	jno    0x140022de6
-   140022d71:	gs jae 0x140022de8
-   140022d74:	gs fs push %rax
-   140022d77:	jb     0x140022de2
-   140022d79:	jbe    0x140022de4
-   140022d7b:	insb   (%dx),%es:(%rdi)
-   140022d7c:	gs addr32 gs jae 0x140022dbf
-   140022d81:	and    %bh,(%rcx,%riz,1)
-   140022d84:	sub    $0x656c202d,%eax
-   140022d89:	jbe    0x140022df0
-   140022d8b:	insb   (%dx),%es:(%rdi)
-   140022d8c:	and    %ah,0x61(%rbx)
-   140022d8f:	outsb  %ds:(%rsi),(%dx)
-   140022d90:	and    %ah,0x65(%rdx)
-   140022d93:	and    %ah,(%rdx)
-   140022d95:	(bad)
-   140022d96:	jae    0x140022de1
-   140022d98:	outsb  %ds:(%rsi),(%dx)
-   140022d99:	jbe    0x140022e0a
-   140022d9b:	imul   $0x22,0x72(%rbp),%esp
-   140022d9f:	sub    $0x20,%al
-   140022da1:	and    0x69(%rax),%ch
-   140022da4:	addr32 push $0x41747365
-   140022daa:	jbe    0x140022e0d
-   140022dac:	imul   $0x2c22656c,0x62(%rcx,%riz,2),%ebp
-   140022db4:	and    %ch,0x72(%rdi)
-   140022db7:	and    %ah,(%rdx)
-   140022db9:	jb     0x140022e20
-   140022dbb:	jno    0x140022e32
-   140022dbd:	imul   $0x696d6441,0x65(%rdx),%esi
-   140022dc4:	outsb  %ds:(%rsi),(%dx)
-   140022dc5:	imul   $0x6f746172,0x74(%rbx),%esi
-   140022dcc:	jb     0x140022df0
-   140022dce:	and    %ch,0x3c203e2d(%rip)        # 0x17c226c01
-   140022dd4:	jbe    0x140022e09
-   140022dd6:	cmp    0x65(%rdx),%dh
-   140022dd9:	jno    0x140022e50
-   140022ddb:	gs jae 0x140022e52
-   140022dde:	gs fs rex.RB js 0x140022e48
-   140022de3:	movsxd 0x74(%rbp),%esi
-   140022de6:	imul   $0x6576654c,0x6e(%rdi),%ebp
-   140022ded:	insb   (%dx),%es:(%rdi)
-   140022dee:	and    %ch,0x76(%rbp,%riz,2)
-   140022df2:	gs insb (%dx),%es:(%rdi)
-   140022df4:	cmp    $0x71657222,%eax
-   140022df9:	jne    0x140022e64
-   140022dfb:	jb     0x140022e62
-   140022dfd:	rex.B
-   140022dfe:	fs insl (%dx),%es:(%rdi)
-   140022e00:	imul   $0x61727473,0x69(%rsi),%ebp
-   140022e07:	je     0x140022e78
-   140022e09:	jb     0x140022e2d
-   140022e0b:	and    %ch,(%rdi)
-   140022e0d:	ds and %bh,(%rdi,%rbp,1)
-   140022e11:	jbe    0x140022e46
-   140022e13:	cmp    0x65(%rdx),%dh
-   140022e16:	jno    0x140022e8d
-   140022e18:	gs jae 0x140022e8f
-   140022e1b:	gs fs push %rax
-   140022e1e:	jb     0x140022e89
-   140022e20:	jbe    0x140022e8b
-   140022e22:	insb   (%dx),%es:(%rdi)
-   140022e23:	gs addr32 gs jae 0x140022e66
-   140022e28:	and    %bh,(%rdi,%rbp,1)
-   140022e2b:	jbe    0x140022e60
-   140022e2d:	cmp    0x65(%rbx),%dh
-   140022e30:	movsxd 0x72(%rbp),%esi
-   140022e33:	imul   $0x762f3c20,0x3e(%rcx,%rdi,2),%esi
-   140022e3b:	xor    (%rdx),%edi
-   140022e3d:	je     0x140022eb1
-   140022e3f:	jne    0x140022eb4
-   140022e41:	je     0x140022e8c
-   140022e43:	outsb  %ds:(%rsi),(%dx)
-   140022e44:	outsw  %ds:(%rsi),(%dx)
-   140022e46:	ds and %bh,(%rdi,%rbp,1)
-   140022e4a:	(bad)
-   140022e4b:	jae    0x140022ec0
-   140022e4d:	gs insl (%dx),%es:(%rdi)
-   140022e4f:	(bad)  {%k6}
-   140022e52:	ds
-   140022e53:	.byte 0x20
+   140022c22:	jae    0x140022c61
+   140022c24:	and    0x72(%rbp),%dh
+   140022c27:	outsb  %ds:(%rsi),(%dx)
+   140022c28:	cmp    0x63(%rbx),%dh
+   140022c2b:	push   $0x73616d65
+   140022c30:	sub    $0x7263696d,%eax
+   140022c35:	outsl  %ds:(%rsi),(%dx)
+   140022c36:	jae    0x140022ca7
+   140022c38:	data16 je 0x140022c68
+   140022c3b:	movsxd 0x6d(%rdi),%ebp
+   140022c3e:	cmp    0x73(%rcx),%ah
+   140022c41:	insl   (%dx),%es:(%rdi)
+   140022c42:	jbe,pn 0x140022c76
+   140022c45:	and    (%rax),%ah
+   140022c47:	insl   (%dx),%es:(%rdi)
+   140022c48:	(bad)
+   140022c49:	outsb  %ds:(%rsi),(%dx)
+   140022c4a:	imul   $0x65567473,0x65(%rsi),%esp
+   140022c51:	jb     0x140022cc6
+   140022c53:	imul   $0x2e31223d,0x6e(%rdi),%ebp
+   140022c5a:	xor    %ah,(%rdx)
+   140022c5c:	ds and %bh,(%rsp,%riz,2)
+   140022c60:	gs jo  0x140022cc8
+   140022c63:	outsb  %ds:(%rsi),(%dx)
+   140022c64:	fs outsb %gs:(%rsi),(%dx)
+   140022c67:	movsxd 0x3e(%rcx),%edi
+   140022c6a:	and    %bh,(%rsp,%riz,2)
+   140022c6d:	gs jo  0x140022cd5
+   140022c70:	outsb  %ds:(%rsi),(%dx)
+   140022c71:	fs outsb %gs:(%rsi),(%dx)
+   140022c74:	je     0x140022cb7
+   140022c76:	jae    0x140022ceb
+   140022c78:	gs insl (%dx),%es:(%rdi)
+   140022c7a:	(bad)  {%k6}
+   140022c7d:	ds and %bh,(%rcx,%riz,2)
+   140022c81:	jae    0x140022cf6
+   140022c83:	gs insl (%dx),%es:(%rdi)
+   140022c85:	(bad)  {%k1}
+   140022c88:	rex.WB
+   140022c89:	fs outsb %gs:(%rsi),(%dx)
+   140022c8c:	je     0x140022cf7
+   140022c8e:	je     0x140022d09
+   140022c90:	and    %dh,0x70(%rcx,%rdi,2)
+   140022c94:	gs cmp $0x6e697722,%eax
+   140022c9a:	xor    (%rdx),%esi
+   140022c9c:	and    (%rax),%ah
+   140022c9e:	outsb  %ds:(%rsi),(%dx)
+   140022c9f:	(bad)
+   140022ca0:	insl   (%dx),%es:(%rdi)
+   140022ca1:	gs cmp $0x63694d22,%eax
+   140022ca7:	jb     0x140022d18
+   140022ca9:	jae    0x140022d1a
+   140022cab:	data16 je 0x140022cdc
+   140022cae:	push   %rdi
+   140022caf:	imul   $0x2e73776f,0x64(%rsi),%ebp
+   140022cb6:	rex.XB outsl %ds:(%rsi),(%dx)
+   140022cb8:	insl   (%dx),%es:(%rdi)
+   140022cb9:	insl   (%dx),%es:(%rdi)
+   140022cba:	outsl  %ds:(%rsi),(%dx)
+   140022cbb:	outsb  %ds:(%rsi),(%dx)
+   140022cbc:	sub    $0x746e6f43,%eax
+   140022cc1:	jb     0x140022d32
+   140022cc3:	insb   (%dx),%es:(%rdi)
+   140022cc4:	jae    0x140022ce8
+   140022cc6:	and    %dh,0x65(%rsi)
+   140022cc9:	jb     0x140022d3e
+   140022ccb:	imul   $0x2e36223d,0x6e(%rdi),%ebp
+   140022cd2:	xor    %ch,(%rsi)
+   140022cd4:	xor    %ch,(%rsi)
+   140022cd6:	xor    %ah,(%rdx)
+   140022cd8:	and    %dh,0x72(%rax)
+   140022cdb:	outsl  %ds:(%rsi),(%dx)
+   140022cdc:	movsxd 0x73(%rbp),%esp
+   140022cdf:	jae    0x140022d50
+   140022ce1:	jb     0x140022d24
+   140022ce3:	jb     0x140022d48
+   140022ce5:	push   $0x63657469
+   140022cea:	je     0x140022d61
+   140022cec:	jb     0x140022d53
+   140022cee:	cmp    $0x20222a22,%eax
+   140022cf3:	jo     0x140022d6a
+   140022cf5:	(bad)  {%k3}
+   140022cf8:	movsxd 0x65(%rbx),%ecx
+   140022cfb:	jns    0x140022d51
+   140022cfd:	outsl  %ds:(%rsi),(%dx)
+   140022cfe:	imul   $0x3d,0x6e(%rbp),%esp
+   140022d02:	and    (%rsi),%dh
+   140022d04:	xor    $0x36623539,%eax
+   140022d09:	xor    $0x31,%al
+   140022d0b:	xor    $0x34,%al
+   140022d0d:	movsxd 0x66(%rbx),%esp
+   140022d10:	xor    %esp,0x22(%rsi,%riz,2)
+   140022d14:	and    %ch,0x6e(%rcx,%riz,2)
+   140022d18:	addr32 jne 0x140022d7c
+   140022d1b:	addr32 gs cmp $0x20222a22,%eax
+   140022d22:	(bad)
+   140022d23:	ds and %bh,(%rdi,%rbp,1)
+   140022d27:	fs gs jo 0x140022d90
+   140022d2b:	outsb  %ds:(%rsi),(%dx)
+   140022d2c:	fs outsb %gs:(%rsi),(%dx)
+   140022d2f:	je     0x140022d72
+   140022d31:	jae    0x140022da6
+   140022d33:	gs insl (%dx),%es:(%rdi)
+   140022d35:	(bad)  {%k6}
+   140022d38:	ds and %bh,(%rdi,%rbp,1)
+   140022d3c:	fs gs jo 0x140022da5
+   140022d40:	outsb  %ds:(%rsi),(%dx)
+   140022d41:	fs outsb %gs:(%rsi),(%dx)
+   140022d44:	movsxd 0x3e(%rcx),%edi
+   140022d47:	and    %bh,(%rsi,%rsi,2)
+   140022d4a:	xor    (%rdx),%edi
+   140022d4c:	je     0x140022dc0
+   140022d4e:	jne    0x140022dc3
+   140022d50:	je     0x140022d9b
+   140022d52:	outsb  %ds:(%rsi),(%dx)
+   140022d53:	outsw  %ds:(%rsi),(%dx)
+   140022d55:	and    %bh,0x6d(%rax)
+   140022d58:	insb   (%dx),%es:(%rdi)
+   140022d59:	outsb  %ds:(%rsi),(%dx)
+   140022d5a:	jae    0x140022d96
+   140022d5c:	jbe    0x140022d91
+   140022d5e:	cmp    $0x6e727522,%eax
+   140022d63:	cmp    0x63(%rbx),%dh
+   140022d66:	push   $0x73616d65
+   140022d6b:	sub    $0x7263696d,%eax
+   140022d70:	outsl  %ds:(%rsi),(%dx)
+   140022d71:	jae    0x140022de2
+   140022d73:	data16 je 0x140022da3
+   140022d76:	movsxd 0x6d(%rdi),%ebp
+   140022d79:	cmp    0x73(%rcx),%ah
+   140022d7c:	insl   (%dx),%es:(%rdi)
+   140022d7d:	jbe,pn 0x140022db3
+   140022d80:	and    (%rsi),%bh
+   140022d82:	and    %bh,(%rsi,%rsi,2)
+   140022d85:	xor    (%rdx),%edi
+   140022d87:	jae    0x140022dee
+   140022d89:	movsxd 0x72(%rbp),%esi
+   140022d8c:	imul   $0x33763c20,0x3e(%rcx,%rdi,2),%esi
+   140022d94:	cmp    0x65(%rdx),%dh
+   140022d97:	jno    0x140022e0e
+   140022d99:	gs jae 0x140022e10
+   140022d9c:	gs fs push %rax
+   140022d9f:	jb     0x140022e0a
+   140022da1:	jbe    0x140022e0c
+   140022da3:	insb   (%dx),%es:(%rdi)
+   140022da4:	gs addr32 gs jae 0x140022de7
+   140022da9:	and    %bh,(%rcx,%riz,1)
+   140022dac:	sub    $0x656c202d,%eax
+   140022db1:	jbe    0x140022e18
+   140022db3:	insb   (%dx),%es:(%rdi)
+   140022db4:	and    %ah,0x61(%rbx)
+   140022db7:	outsb  %ds:(%rsi),(%dx)
+   140022db8:	and    %ah,0x65(%rdx)
+   140022dbb:	and    %ah,(%rdx)
+   140022dbd:	(bad)
+   140022dbe:	jae    0x140022e09
+   140022dc0:	outsb  %ds:(%rsi),(%dx)
+   140022dc1:	jbe    0x140022e32
+   140022dc3:	imul   $0x22,0x72(%rbp),%esp
+   140022dc7:	sub    $0x20,%al
+   140022dc9:	and    0x69(%rax),%ch
+   140022dcc:	addr32 push $0x41747365
+   140022dd2:	jbe    0x140022e35
+   140022dd4:	imul   $0x2c22656c,0x62(%rcx,%riz,2),%ebp
+   140022ddc:	and    %ch,0x72(%rdi)
+   140022ddf:	and    %ah,(%rdx)
+   140022de1:	jb     0x140022e48
+   140022de3:	jno    0x140022e5a
+   140022de5:	imul   $0x696d6441,0x65(%rdx),%esi
+   140022dec:	outsb  %ds:(%rsi),(%dx)
+   140022ded:	imul   $0x6f746172,0x74(%rbx),%esi
+   140022df4:	jb     0x140022e18
+   140022df6:	and    %ch,0x3c203e2d(%rip)        # 0x17c226c29
+   140022dfc:	jbe    0x140022e31
+   140022dfe:	cmp    0x65(%rdx),%dh
+   140022e01:	jno    0x140022e78
+   140022e03:	gs jae 0x140022e7a
+   140022e06:	gs fs rex.RB js 0x140022e70
+   140022e0b:	movsxd 0x74(%rbp),%esi
+   140022e0e:	imul   $0x6576654c,0x6e(%rdi),%ebp
+   140022e15:	insb   (%dx),%es:(%rdi)
+   140022e16:	and    %ch,0x76(%rbp,%riz,2)
+   140022e1a:	gs insb (%dx),%es:(%rdi)
+   140022e1c:	cmp    $0x71657222,%eax
+   140022e21:	jne    0x140022e8c
+   140022e23:	jb     0x140022e8a
+   140022e25:	rex.B
+   140022e26:	fs insl (%dx),%es:(%rdi)
+   140022e28:	imul   $0x61727473,0x69(%rsi),%ebp
+   140022e2f:	je     0x140022ea0
+   140022e31:	jb     0x140022e55
+   140022e33:	and    %ch,(%rdi)
+   140022e35:	ds and %bh,(%rdi,%rbp,1)
+   140022e39:	jbe    0x140022e6e
+   140022e3b:	cmp    0x65(%rdx),%dh
+   140022e3e:	jno    0x140022eb5
+   140022e40:	gs jae 0x140022eb7
+   140022e43:	gs fs push %rax
+   140022e46:	jb     0x140022eb1
+   140022e48:	jbe    0x140022eb3
+   140022e4a:	insb   (%dx),%es:(%rdi)
+   140022e4b:	gs addr32 gs jae 0x140022e8e
+   140022e50:	and    %bh,(%rdi,%rbp,1)
+   140022e53:	jbe    0x140022e88
+   140022e55:	cmp    0x65(%rbx),%dh
+   140022e58:	movsxd 0x72(%rbp),%esi
+   140022e5b:	imul   $0x762f3c20,0x3e(%rcx,%rdi,2),%esi
+   140022e63:	xor    (%rdx),%edi
+   140022e65:	je     0x140022ed9
+   140022e67:	jne    0x140022edc
+   140022e69:	je     0x140022eb4
+   140022e6b:	outsb  %ds:(%rsi),(%dx)
+   140022e6c:	outsw  %ds:(%rsi),(%dx)
+   140022e6e:	ds and %bh,(%rdi,%rbp,1)
+   140022e72:	(bad)
+   140022e73:	jae    0x140022ee8
+   140022e75:	gs insl (%dx),%es:(%rdi)
+   140022e77:	(bad)  {%k6}
+   140022e7a:	ds
+   140022e7b:	.byte 0x20
```

### Comparing `build/exe/setup2.exe` & `build/exe/depsland-cli.exe`

 * *Command `'objdump --all-headers --disassemble-all --line-numbers --no-show-raw-insn {}'` failed with exit code 1. Standard output:*

 * *    objdump: /tmp/diffoscope_01x1tll6_/tmpjtiwa5pg_ZipContainer/setup2.exe: file format not recognized*

 * *Files 0% similar despite different names*

```diff
@@ -46587,21 +46587,21 @@
 000b5fa0: 1000 0000 0000 0000 0800 0000 0000 0000  ................
 000b5fb0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
 000b5fc0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
 000b5fd0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
 000b5fe0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
 000b5ff0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
 000b6000: 2e5c 007b 4558 455f 4449 527d 0020 2200  .\.{EXE_DIR}. ".
-000b6010: 2200 2000 0000 0000 6364 202f 6420 7b45  ". .....cd /d {E
-000b6020: 5845 5f44 4952 7d20 2626 2073 6574 2050  XE_DIR} && set P
-000b6030: 5954 484f 4e50 4154 483d 2e20 2626 202e  YTHONPATH=. && .
-000b6040: 5c70 7974 686f 6e5c 7079 7468 6f6e 2e65  \python\python.e
-000b6050: 7865 202d 4220 6275 696c 642f 7365 7475  xe -B build/setu
-000b6060: 705f 7769 7a61 7264 2f62 6f6f 746c 6f61  p_wizard/bootloa
-000b6070: 6465 722e 7079 0000 0000 0000 0000 0000  der.py..........
+000b6010: 2200 2000 0000 0000 4065 6368 6f20 6f66  ". .....@echo of
+000b6020: 6620 2626 2073 6574 2050 5954 484f 4e50  f && set PYTHONP
+000b6030: 4154 483d 2544 4550 534c 414e 4425 2026  ATH=%DEPSLAND% &
+000b6040: 2620 7365 7420 5059 5448 4f4e 5554 4638  & set PYTHONUTF8
+000b6050: 3d31 2026 2620 2225 4445 5053 4c41 4e44  =1 && "%DEPSLAND
+000b6060: 255c 7079 7468 6f6e 5c70 7974 686f 6e2e  %\python\python.
+000b6070: 6578 6522 202d 6d20 6465 7073 6c61 6e64  exe" -m depsland
 000b6080: 0000 0000 0000 0000 0000 0000 0000 0000  ................
 000b6090: 0000 0000 0000 0000 0000 0000 0000 0000  ................
 000b60a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
 000b60b0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
 000b60c0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
 000b60d0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
 000b60e0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
```

## depsland/chore/readme.md

 * *Ordering differences only*

```diff
@@ -1,3 +1,3 @@
-Init generation or refresh assets in this directory:
-
-Please run `py build/backup_project_resources.py`
+Init generation or refresh assets in this directory:
+
+Please run `py build/backup_project_resources.py`
```

## depsland/chore/sidework.zip

### zipinfo {}

```diff
@@ -1,7 +1,11 @@
-Zip file size: 3140 bytes, number of entries: 5
-drwxr-xr-x  2.0 unx        0 b- stor 23-Feb-20 16:56 sidework/
--rw-r--r--  2.0 unx     1857 b- stor 23-Feb-20 16:56 sidework/img_2_ico.py
--rw-r--r--  2.0 unx      140 b- stor 23-Feb-20 16:56 sidework/index_viewer.py
--rw-r--r--  2.0 unx      361 b- stor 23-Feb-20 16:56 sidework/cleaner.py
--rw-r--r--  2.0 unx      170 b- stor 23-Feb-20 16:56 sidework/view_manifest_pickle.py
-5 files, 2528 bytes uncompressed, 2528 bytes compressed:  0.0%
+Zip file size: 8482 bytes, number of entries: 9
+drwxrwxrwx  2.0 fat        0 b- stor 24-May-06 16:15 sidework/
+-rw-rw-rw-  2.0 fat      363 b- stor 24-May-06 16:15 sidework/bat_2_exe.py
+-rw-rw-rw-  2.0 fat      361 b- stor 24-May-06 16:15 sidework/cleaner.py
+-rw-rw-rw-  2.0 fat     2997 b- stor 24-May-06 16:15 sidework/image_converter.py
+-rw-rw-rw-  2.0 fat      345 b- stor 24-May-06 16:15 sidework/manifest_viewer.py
+-rw-rw-rw-  2.0 fat     2025 b- stor 24-May-06 16:15 sidework/prepare_packages.py
+-rw-rw-rw-  2.0 fat      884 b- stor 24-May-06 16:15 sidework/pypi_index.py
+-rw-rw-rw-  2.0 fat      217 b- stor 24-May-06 16:15 sidework/venv_maker.py
+-rw-rw-rw-  2.0 fat      170 b- stor 24-May-06 16:15 sidework/view_manifest_pickle.py
+9 files, 7362 bytes uncompressed, 7362 bytes compressed:  0.0%
```

### zipnote {}

```diff
@@ -1,16 +1,28 @@
 Filename: sidework/
 Comment: 
 
-Filename: sidework/img_2_ico.py
+Filename: sidework/bat_2_exe.py
 Comment: 
 
-Filename: sidework/index_viewer.py
+Filename: sidework/cleaner.py
 Comment: 
 
-Filename: sidework/cleaner.py
+Filename: sidework/image_converter.py
+Comment: 
+
+Filename: sidework/manifest_viewer.py
+Comment: 
+
+Filename: sidework/prepare_packages.py
+Comment: 
+
+Filename: sidework/pypi_index.py
+Comment: 
+
+Filename: sidework/venv_maker.py
 Comment: 
 
 Filename: sidework/view_manifest_pickle.py
 Comment: 
 
 Zip file comment:
```

## depsland/config.py

```diff
@@ -1,62 +1,62 @@
-import typing as t
-
-from conflore import Conflore
-from lk_utils import loads
-
-from . import paths
-
-__all__ = ['app_settings', 'auto_saved', 'controls']
-
-
-class T:
-    # noinspection PyTypedDict
-    AppSettings = t.TypedDict('AppSettings', {
-        'oss' : t.TypedDict('Oss', {
-            'server': t.Literal['aliyun', 'local', 'fake'],
-            'config': t.Union[
-                t.TypedDict('AliyunOssConfig', {
-                    'user_role'    : str,
-                    'access_key'   : str,
-                    'access_secret': str,
-                    'endpoint'     : str,
-                    'bucket_name'  : str,
-                }),
-                t.TypedDict('LocalOssConfig', {
-                    'symlinks': bool,
-                }),
-                t.TypedDict('FakeOssConfig', {
-                    'symlinks': bool,
-                }),
-            ]
-        }),
-        'pip' : t.TypedDict('Pip', {
-            'index_url': str,
-            'quiet'    : bool,
-        }),
-        'pypi': t.TypedDict('PyPI', {
-            'update_interval': int,
-        }),
-    })
-    
-    # noinspection PyTypedDict
-    AutoSaved = t.Union[
-        Conflore,
-        t.TypedDict('AutoSaved', {
-            'appstore': t.TypedDict('AppStore', {
-                'last_input': str
-            })
-        })
-    ]
-
-
-class GlobalControls:  # TODO: no usage yet.
-    debug_mode = False
-    ignore_old_manifest = False
-
-
-app_settings: T.AppSettings = loads(paths.conf.depsland)
-controls = GlobalControls()
-auto_saved: T.AutoSaved = Conflore(
-    paths.conf.auto_saved,
-    {'appstore': {'last_input': ''}},
-)
+import typing as t
+
+from conflore import Conflore
+from lk_utils import loads
+
+from . import paths
+
+__all__ = ['app_settings', 'auto_saved', 'controls']
+
+
+class T:
+    # noinspection PyTypedDict
+    AppSettings = t.TypedDict('AppSettings', {
+        'oss' : t.TypedDict('Oss', {
+            'server': t.Literal['aliyun', 'local', 'fake'],
+            'config': t.Union[
+                t.TypedDict('AliyunOssConfig', {
+                    'user_role'    : str,
+                    'access_key'   : str,
+                    'access_secret': str,
+                    'endpoint'     : str,
+                    'bucket_name'  : str,
+                }),
+                t.TypedDict('LocalOssConfig', {
+                    'symlinks': bool,
+                }),
+                t.TypedDict('FakeOssConfig', {
+                    'symlinks': bool,
+                }),
+            ]
+        }),
+        'pip' : t.TypedDict('Pip', {
+            'index_url': str,
+            'quiet'    : bool,
+        }),
+        'pypi': t.TypedDict('PyPI', {
+            'update_interval': int,
+        }),
+    })
+    
+    # noinspection PyTypedDict
+    AutoSaved = t.Union[
+        Conflore,
+        t.TypedDict('AutoSaved', {
+            'appstore': t.TypedDict('AppStore', {
+                'last_input': str
+            })
+        })
+    ]
+
+
+class GlobalControls:  # TODO: no usage yet.
+    debug_mode = False
+    ignore_old_manifest = False
+
+
+app_settings: T.AppSettings = loads(paths.config.depsland)
+controls = GlobalControls()
+auto_saved: T.AutoSaved = Conflore(
+    paths.config.auto_saved,
+    {'appstore': {'last_input': ''}},
+)
```

## depsland/doctor/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-from .pypi_index import rebuild_index as rebuild_pypi_index
+from .pypi_index import rebuild_index as rebuild_pypi_index
```

## depsland/doctor/pypi_index.py

 * *Ordering differences only*

```diff
@@ -1,37 +1,37 @@
-from lk_logger.console import con_print
-from lk_utils import fs
-from rich.table import Table
-
-from ..paths import pypi as pypi_paths
-from ..pypi import insight
-from ..utils import verspec
-
-
-def rebuild_index(perform_pip_install: bool = False) -> None:
-    insight.rebuild_index(perform_pip_install)
-    table = MyTable()
-    for f in fs.find_files(pypi_paths.downloads):
-        if f.name != '.gitkeep':
-            ver = verspec.get_verspec_from_filename(f.name)
-            table.update(f.name, ver.name, ver.version)
-    table.render()
-    print(':t')
-
-
-class MyTable:
-    
-    def __init__(self):
-        self.table = Table()
-        self.table.add_column('index')
-        self.table.add_column('filename')
-        self.table.add_column('name', style='green')
-        self.table.add_column('version', style='cyan')
-        self._table_index = 0
-    
-    def update(self, filename: str, pakgname: str, version: str) -> None:
-        self._table_index += 1
-        self.table.add_row(str(self._table_index), filename, pakgname, version)
-    
-    def render(self) -> None:
-        print(':f2')
-        con_print(self.table)
+from lk_logger.console import con_print
+from lk_utils import fs
+from rich.table import Table
+
+from ..paths import pypi as pypi_paths
+from ..pypi import insight
+from ..utils import verspec
+
+
+def rebuild_index(perform_pip_install: bool = False) -> None:
+    insight.rebuild_index(perform_pip_install)
+    table = MyTable()
+    for f in fs.find_files(pypi_paths.downloads):
+        if f.name != '.gitkeep':
+            ver = verspec.get_verspec_from_filename(f.name)
+            table.update(f.name, ver.name, ver.version)
+    table.render()
+    print(':t')
+
+
+class MyTable:
+    
+    def __init__(self):
+        self.table = Table()
+        self.table.add_column('index')
+        self.table.add_column('filename')
+        self.table.add_column('name', style='green')
+        self.table.add_column('version', style='cyan')
+        self._table_index = 0
+    
+    def update(self, filename: str, pakgname: str, version: str) -> None:
+        self._table_index += 1
+        self.table.add_row(str(self._table_index), filename, pakgname, version)
+    
+    def render(self) -> None:
+        print(':f2')
+        con_print(self.table)
```

## depsland/doctor.py

 * *Ordering differences only*

```diff
@@ -1,94 +1,94 @@
-# NOTE: do not encrypt this file when packaging depsland.
-import sys
-
-from os import path as ospath
-from sys import path as syspath
-
-__all__ = ['setup_env']
-
-_curr_dir = ospath.dirname(__file__)
-_lib_dir = ospath.abspath(f'{_curr_dir}/../../lib')
-_build_dir = ospath.abspath(f'{_curr_dir}/../../build')
-
-
-def add_pyportable_runtime():
-    """ Add `~/lib/pyportable_runtime` to sys.path
-     
-    Tree like:
-        |= src
-           |= depsland
-              |- __init__.py
-              |- doctor.py          # 1. here we located
-              |~ ...
-        |= lib                      # 2. add this dir to sys.path
-           |= pyportable_runtime    # 3. then this package is importable
-    """
-    if ospath.exists(_lib_dir):
-        syspath.append(_lib_dir)
-    else:
-        raise ModuleNotFoundError
-
-
-def setup_env():
-    add_pyportable_runtime()
-    
-    try:
-        # noinspection PyUnresolvedReferences
-        import pyportable_runtime
-    except Exception as e:
-        print('''
-            Package `pyportable_runtime` is not available to use. Depsland 
-            engine has been terminated.
-            
-            Here's the message shows recent errors:
-                {error}
-            
-            You can try the following steps to fix this problem:
-            
-            - I'm using Windows 7 (32-bit)
-                - The error shows 'DLL load failed...'
-                    - Go to '{depsland}/windows_patch/windows-7-sp1-32bit' dir
-                    - Setup 'KB2999226-x86.msu' and 'KB3063858-x86.msu'
-                    - Restart your computer
-                    - Retry to setup this program
-                - The error shows 'api-ms-core-... is misssing'
-                    - Go to '{depsland}/windows_patch/windows-7-sp1-32bit' dir
-                    - Setup 'KB2999226-x86.msu'
-                    - Retry to setup this program (no need to restart computer)
-                
-            - I'm using Windows 7 (64-bit)
-                - The error shows 'DLL load failed...'
-                    - Go to '{depsland}/windows_patch/windows-7-sp1-64bit' dir
-                    - Setup 'KB2999226-x64.msu' and 'KB3063858-x64.msu'
-                    - Restart your computer
-                    - Retry to setup this program
-                - The error shows 'api-ms-core-... is misssing'
-                    - Go to '{depsland}/windows_patch/windows-7-sp1-64bit' dir
-                    - Setup 'KB2999226-x64.msu'
-                    - Retry to setup this program (no need to restart computer)
-            
-            - I'm using Windows 8 (32-bit)
-                - Go to '{depsland}/windows_patch/windows-8-32bit' dir
-                - Setup 'vcredist-2015-x86.exe'
-                - Retry to setup this program (no need to restart computer)
-                
-            - I'm using Windows 8 (64-bit)
-                - Go to '{depsland}/windows_patch/windows-8-64bit' dir
-                - Setup 'vcredist-2015-x64.exe'
-                - Retry to setup this program (no need to restart computer)
-                
-            - I have other problem
-                Please contact the supplier or depsland project owner (mail to
-                likianta@foxmail.com) for more help.
-            
-        '''.format(
-            error=e,
-            depsland=_build_dir.replace('\\', '/'))
-        )
-        
-        input('Press enter to terminate progress... ')
-        
-        sys.exit()
-    else:
-        print('[Pass] Your computer is ready to setup depsland or '
-              'depsland-based programs!')
+# NOTE: do not encrypt this file when packaging depsland.
+import sys
+
+from os import path as ospath
+from sys import path as syspath
+
+__all__ = ['setup_env']
+
+_curr_dir = ospath.dirname(__file__)
+_lib_dir = ospath.abspath(f'{_curr_dir}/../../lib')
+_build_dir = ospath.abspath(f'{_curr_dir}/../../build')
+
+
+def add_pyportable_runtime():
+    """ Add `~/lib/pyportable_runtime` to sys.path
+     
+    Tree like:
+        |= src
+           |= depsland
+              |- __init__.py
+              |- doctor.py          # 1. here we located
+              |~ ...
+        |= lib                      # 2. add this dir to sys.path
+           |= pyportable_runtime    # 3. then this package is importable
+    """
+    if ospath.exists(_lib_dir):
+        syspath.append(_lib_dir)
+    else:
+        raise ModuleNotFoundError
+
+
+def setup_env():
+    add_pyportable_runtime()
+    
+    try:
+        # noinspection PyUnresolvedReferences
+        import pyportable_runtime
+    except Exception as e:
+        print('''
+            Package `pyportable_runtime` is not available to use. Depsland 
+            engine has been terminated.
+            
+            Here's the message shows recent errors:
+                {error}
+            
+            You can try the following steps to fix this problem:
+            
+            - I'm using Windows 7 (32-bit)
+                - The error shows 'DLL load failed...'
+                    - Go to '{depsland}/windows_patch/windows-7-sp1-32bit' dir
+                    - Setup 'KB2999226-x86.msu' and 'KB3063858-x86.msu'
+                    - Restart your computer
+                    - Retry to setup this program
+                - The error shows 'api-ms-core-... is misssing'
+                    - Go to '{depsland}/windows_patch/windows-7-sp1-32bit' dir
+                    - Setup 'KB2999226-x86.msu'
+                    - Retry to setup this program (no need to restart computer)
+                
+            - I'm using Windows 7 (64-bit)
+                - The error shows 'DLL load failed...'
+                    - Go to '{depsland}/windows_patch/windows-7-sp1-64bit' dir
+                    - Setup 'KB2999226-x64.msu' and 'KB3063858-x64.msu'
+                    - Restart your computer
+                    - Retry to setup this program
+                - The error shows 'api-ms-core-... is misssing'
+                    - Go to '{depsland}/windows_patch/windows-7-sp1-64bit' dir
+                    - Setup 'KB2999226-x64.msu'
+                    - Retry to setup this program (no need to restart computer)
+            
+            - I'm using Windows 8 (32-bit)
+                - Go to '{depsland}/windows_patch/windows-8-32bit' dir
+                - Setup 'vcredist-2015-x86.exe'
+                - Retry to setup this program (no need to restart computer)
+                
+            - I'm using Windows 8 (64-bit)
+                - Go to '{depsland}/windows_patch/windows-8-64bit' dir
+                - Setup 'vcredist-2015-x64.exe'
+                - Retry to setup this program (no need to restart computer)
+                
+            - I have other problem
+                Please contact the supplier or depsland project owner (mail to
+                likianta@foxmail.com) for more help.
+            
+        '''.format(
+            error=e,
+            depsland=_build_dir.replace('\\', '/'))
+        )
+        
+        input('Press enter to terminate progress... ')
+        
+        sys.exit()
+    else:
+        print('[Pass] Your computer is ready to setup depsland or '
+              'depsland-based programs!')
```

## depsland/manifest/__init__.py

```diff
@@ -1,11 +1,9 @@
-from .appinfo import T
-from .appinfo import get_app_info
-from .appinfo import get_last_installed_version
-from .appinfo import get_last_released_version
-from .appinfo import parse_script_info
-from .manifest import change_start_directory
-from .manifest import compare_manifests
-from .manifest import dump_manifest
-from .manifest import init_manifest
-from .manifest import init_target_tree
-from .manifest import load_manifest
+from .appinfo import T
+from .appinfo import get_app_info
+from .appinfo import get_last_installed_version
+from .appinfo import get_last_released_version
+from .appinfo import parse_script_info
+from .manifest import diff_manifest
+from .manifest import dump_manifest
+from .manifest import init_manifest
+from .manifest import load_manifest
```

## depsland/manifest/appinfo.py

```diff
@@ -1,98 +1,110 @@
-import os
-import shlex  # a built-in library that splits command line args
-import typing as t
-from os.path import exists
-
-from lk_utils import fs
-from lk_utils import loads
-from lk_utils.read_and_write import ropen
-
-from .manifest import T as T0
-from .manifest import dump_manifest
-from .manifest import load_manifest
-from .. import paths
-
-
-class T(T0):
-    Appinfo = t.TypedDict('Appinfo', {
-        'appid'  : str,
-        'name'   : str,
-        'version': str,
-        'src_dir': str,  # abspath
-        'dst_dir': str,  # abspath
-        'history': t.List[str],  # list[str version]
-    })
-    Manifest = T0.Manifest1
-
-
-def get_app_info(manifest_file: str) -> T.Appinfo:
-    data_i: T.Manifest = load_manifest(manifest_file)
-    data_o: T.Appinfo = {
-        'appid'  : data_i['appid'],
-        'name'   : data_i['name'],
-        'version': data_i['version'],
-        'src_dir': fs.dirpath(manifest_file),
-        'dst_dir': '{}/{}/{}'.format(
-            paths.project.apps,
-            data_i['appid'],
-            data_i['version']
-        ),
-        'history': [],
-    }
-    
-    if not exists(d := data_o['dst_dir']): os.makedirs(d)
-    dump_manifest(data_i, f'{d}/manifest.json')
-    
-    # update history
-    history_file = paths.apps.get_distribution_history(data_o['appid'])
-    if exists(history_file):
-        data_o['history'] = loads(history_file, ftype='plain').splitlines()
-    else:
-        print('no history found, it would be the first release',
-              data_o['name'], data_o['version'], ':v2')
-        # dumps('', history_file, ftype='plain')
-    
-    return data_o
-
-
-def get_last_installed_version(appid: str) -> t.Optional[str]:
-    file = paths.apps.get_installation_history(appid)
-    if not exists(file): return None
-    return _quick_read_line(file)
-
-
-def get_last_released_version(appid: str) -> t.Optional[str]:
-    file = paths.apps.get_distribution_history(appid)
-    if not exists(file): return None
-    return _quick_read_line(file)
-
-
-def parse_script_info(manifest: T.Manifest) -> t.Tuple[str, ...]:
-    appid = manifest['appid']
-    version = manifest['version']
-    script = manifest['launcher']['script']
-    #   either script is a '.py' file, or a (relpath) directory containing
-    #   '__main__.py'.
-    
-    py = paths.python.python  # interpreter path
-    script, args = (script + ' ').split(' ', 1)
-    # normalize `script`
-    if script.endswith('.py'):
-        script = (fs.normpath('{app_dir}/{relpath}'.format(
-            app_dir=f'{paths.project.apps}/{appid}/{version}',
-            relpath=script
-        )),)
-    else:
-        script = ('-m', script)
-    # normalize `args`
-    args = shlex.split(args)
-    #   https://stackoverflow.com/questions/197233/how-to-parse-a-command-line
-    #   -with-regular-expressions
-    
-    return py, *script, *args
-
-
-def _quick_read_line(text_file: str) -> str:
-    with ropen(text_file) as f:
-        for line in f:  # just read the first line
-            return line.strip()
+import os
+import typing as t
+from os.path import exists
+
+from lk_utils import fs
+from lk_utils import load
+
+from .manifest import Manifest
+from .manifest import T as T0
+from .manifest import dump_manifest
+from .manifest import load_manifest
+from .. import paths
+
+
+class T(T0):
+    Appinfo = t.TypedDict(
+        'Appinfo',
+        {
+            'appid'  : str,
+            'name'   : str,
+            'version': str,
+            'src_dir': str,  # abspath
+            'dst_dir': str,  # abspath
+            'history': t.List[str],  # list[str version]
+        },
+    )
+    Launcher = T0.Launcher1
+    Manifest = t.cast(t.Union[T0.Manifest1, Manifest], Manifest)
+    # Manifest = Manifest
+    
+    # extra ports for external use
+    Scheme = T0.Scheme1
+    UserManifest = T0.Manifest0
+
+
+def get_app_info(manifest_file: str) -> T.Appinfo:
+    data_i: T.Manifest = load_manifest(manifest_file)
+    data_o: T.Appinfo = {
+        'appid'  : data_i['appid'],
+        'name'   : data_i['name'],
+        'version': data_i['version'],
+        'src_dir': fs.dirpath(manifest_file),
+        'dst_dir': '{}/{}/{}'.format(
+            paths.project.apps, data_i['appid'], data_i['version']
+        ),
+        'history': [],
+    }
+    
+    if not exists(d := data_o['dst_dir']):
+        os.makedirs(d)
+    dump_manifest(data_i, f'{d}/manifest.json')
+    
+    # update history
+    history_file = paths.apps.get_distribution_history(data_o['appid'])
+    if exists(history_file):
+        data_o['history'] = load(history_file, 'plain').splitlines()
+    else:
+        print(
+            'no history found, it would be the first release',
+            data_o['name'],
+            data_o['version'],
+            ':v2',
+        )
+        # dumps('', history_file, type='plain')
+    
+    return data_o
+
+
+def get_last_installed_version(appid: str) -> t.Optional[str]:
+    file = paths.apps.get_installation_history(appid)
+    if not exists(file): return None
+    return _quick_read_line(file)
+
+
+def get_last_released_version(appid: str) -> t.Optional[str]:
+    file = paths.apps.get_distribution_history(appid)
+    if not exists(file): return None
+    return _quick_read_line(file)
+
+
+def parse_script_info(
+    manifest: T.Manifest,
+) -> t.Tuple[t.Tuple[str, ...], t.Tuple[str, ...], t.Dict[str, t.Any]]:
+    launcher: T.Launcher = manifest['launcher']
+    
+    cwd = manifest['start_directory']
+    src = launcher['target']  # a relpath or a package name
+    
+    command: t.Tuple[str, ...]
+    args: t.Tuple[str, ...]
+    kwargs: t.Dict[str, t.Any]
+    
+    if launcher['type'] == 'executable':
+        command = (f'{cwd}/{src}',)
+    elif launcher['type'] == 'module':
+        command = (paths.python.python, f'{cwd}/{src}')
+    elif launcher['type'] == 'package':
+        command = (paths.python.python, '-m', src)
+    else:
+        raise ValueError(launcher)
+    args = tuple(launcher['args'])
+    kwargs = launcher['kwargs']
+    
+    return command, args, kwargs
+
+
+def _quick_read_line(text_file: str) -> str:
+    with open(text_file, 'r', encoding='utf-8') as f:
+        for line in f:  # just read the first line
+            return line.strip()
```

## depsland/manifest/manifest.py

```diff
@@ -1,516 +1,613 @@
-import os
-import typing as t
-from collections import namedtuple
-from os.path import exists
-from textwrap import dedent
-from time import sleep
-
-from lk_utils import dumps
-from lk_utils import fs
-from lk_utils import loads
-
-from ..utils import get_content_hash
-from ..utils import get_file_hash
-from ..utils import get_updated_time
-
-__all__ = [
-    'T',
-    'change_start_directory',
-    'compare_manifests',
-    'dump_manifest',
-    'init_manifest',
-    'init_target_tree',
-    'load_manifest'
-]
-
-
-# noinspection PyTypedDict
-class T:
-    _AbsPath = _RelPath = _AnyPath = str
-    #   the _RelPath is relative to manifest file's location.
-    
-    Scheme0 = t.Literal[
-        'root', 'all', 'all_dirs',
-        'top', 'top_files', 'top_dirs', ''
-    ]
-    #   empty str means 'all'
-    Scheme1 = t.Literal[
-        'root', 'all', 'all_dirs',
-        'top', 'top_files', 'top_dirs'
-    ]
-    
-    Assets0 = t.Dict[_AnyPath, Scheme0]
-    #   anypath: abspath or relpath, '/' or '\\' both allowed.
-    #   scheme: scheme or empty string. if empty string, it means 'all'.
-    Assets1 = t.Dict[
-        _RelPath,
-        AssetInfo := t.NamedTuple('AssetInfo', (
-            ('type', t.Literal['file', 'dir']),
-            ('scheme', Scheme1),
-            ('utime', int),  # updated time
-            ('hash', str),  # if type is dir, the hash is empty
-            ('uid', str),  # the uid will be used as key to filename in oss.
-        ))
-    ]
-    
-    Dependencies0 = t.Dict[str, str]  # dict[name, verspec]
-    Dependencies1 = Dependencies0
-    
-    PyPI0 = t.List[_AnyPath]  # list[anypath_to_python_wheel]
-    PyPI1 = t.Dict[str, str]  # dict[filename, abspath]
-    
-    Launcher0 = t.TypedDict('Launcher0', {
-        'script'      : str,
-        'icon'        : str,
-        #   the origin icon could be: empty, a relpath, or an abspath.
-        #   when it is loaded to program, it converts to an abspath.
-        #   when it is dumped to a file, it converts to a relpath.
-        'cli_tool'    : bool,
-        'desktop'     : bool,
-        'start_menu'  : bool,
-        'show_console': bool,
-    })
-    Launcher1 = Launcher0
-    
-    # -------------------------------------------------------------------------
-    
-    # Manifest0
-    #   this is a json-compatible dict. it is either made by user or dumped by
-    #   `def dump_manifest` function (when caller passes a '.json' file param
-    #   to it).
-    Manifest0 = t.TypedDict('Manifest0', {
-        'appid'           : str,
-        'name'            : str,
-        'version'         : str,
-        'assets'          : Assets0,
-        'dependencies'    : Dependencies0,
-        'pypi'            : PyPI0,
-        'launcher'        : Launcher0,
-        'depsland_version': str,
-    }, total=False)
-    
-    # Manifest1
-    #   this is main data structure for program to use. it is loaded from a
-    #   '.pkl' file, or parsed from a '.json' file (i.e. Manifest0 data).
-    #   the differences between ~0 and ~1 are:
-    #       1. ~1 has a unified path form.
-    #       2. ~1 has an extra key 'start_directory'.
-    #       3. ~1's assets values are `namedtuple: AssetInfo`.
-    Manifest1 = t.TypedDict('Manifest1', {
-        'appid'           : str,
-        'name'            : str,
-        'version'         : str,
-        'start_directory' : _AbsPath,
-        'assets'          : Assets1,
-        'dependencies'    : Dependencies1,
-        'pypi'            : PyPI1,
-        'launcher'        : Launcher1,
-        'depsland_version': str,
-    })
-    
-    ManifestFile = str  # a '.json' or '.pkl' file
-    
-    # -------------------------------------------------------------------------
-    
-    Action = t.Literal['append', 'update', 'delete', 'ignore']
-    
-    AssetsDiff = t.Iterator[
-        t.Tuple[
-            Action,
-            _RelPath,
-            t.Tuple[t.Optional[AssetInfo], t.Optional[AssetInfo]]
-            #   tuple[old_info, new_info]
-        ]
-    ]
-    
-    DependenciesDiff = t.Iterator[
-        t.Tuple[
-            Action,
-            t.Tuple[str, str]  # tuple[name, verspec]
-        ]
-    ]
-    
-    PyPIDiff = t.Iterator[
-        t.Tuple[
-            Action,
-            t.Tuple[str, t.Optional[str]]  # tuple[filename, filepath]
-        ]
-    ]
-    
-    ManifestDiff = t.TypedDict('ManifestDiff', {
-        'assets'      : AssetsDiff,
-        'dependencies': DependenciesDiff,
-        'pypi'        : PyPIDiff,
-    })
-
-
-AssetInfo = namedtuple('AssetInfo', (
-    'type', 'scheme', 'utime', 'hash', 'uid'
-))
-
-
-# -----------------------------------------------------------------------------
-
-def init_manifest(appid: str, appname: str) -> T.Manifest1:
-    from .. import __version__
-    return {
-        'appid'           : appid,
-        'name'            : appname,
-        'version'         : '0.0.0',
-        'start_directory' : '',
-        'assets'          : {},
-        'dependencies'    : {},
-        'pypi'            : {},
-        'launcher'        : {
-            'script'      : '',
-            'icon'        : '',
-            'cli_tool'    : False,
-            'desktop'     : True,
-            'start_menu'  : False,
-            'show_console': True,
-        },
-        'depsland_version': __version__,
-    }
-
-
-def load_manifest(manifest_file: T.ManifestFile) -> T.Manifest1:
-    from .. import __version__
-    
-    manifest_file = fs.normpath(manifest_file, force_abspath=True)
-    manifest_dir = fs.parent_path(manifest_file)
-    
-    data_i: t.Union[T.Manifest0, T.Manifest1] = loads(manifest_file)
-    data_o: T.Manifest1 = {}
-    
-    if manifest_file.endswith('.pkl'):
-        data_o = data_i  # noqa
-        data_o['start_directory'] = manifest_dir
-        if data_o['launcher']['icon']:
-            # fix icon path (from relpath to abspath)
-            data_o['launcher']['icon'] = fs.normpath(
-                '{}/{}'.format(manifest_dir, data_o['launcher']['icon'])
-            )
-        return data_o
-    
-    # -------------------------------------------------------------------------
-    
-    # assert required keys
-    required_keys = ('appid', 'name', 'version', 'assets')
-    assert all(x in data_i for x in required_keys), (
-        'the required keys are not complete',
-        required_keys, tuple(data_i.keys())
-    )
-    
-    data_o.update({
-        'appid'           : data_i['appid'],
-        'name'            : data_i['name'],
-        'version'         : data_i['version'],
-        'start_directory' : manifest_dir,
-        'assets'          : _update_assets(
-            data_i.get('assets'), manifest_dir),
-        'dependencies'    : _update_dependencies(
-            data_i.get('dependencies', {})),
-        'pypi'            : _update_pypi(
-            data_i.get('pypi', []), manifest_dir),
-        'launcher'        : _update_launcher(
-            data_i.get('launcher', {}), manifest_dir),
-        'depsland_version': data_i.get('depsland_version', __version__),
-    })
-    
-    _check_manifest(data_o)
-    return data_o
-
-
-def change_start_directory(manifest: T.Manifest1, new_dir: str) -> None:
-    r"""
-    if you want to change manifest['start_directory'], you should use this
-    function instead of changing it directly.
-    
-    tip: for IDE refactoring, you can search
-    `manifest\w*\['start_directory'\] = ` to find all misused occurrences.
-    """
-    old_dir = manifest['start_directory']
-    manifest['start_directory'] = new_dir
-    if manifest['launcher']['icon']:
-        manifest['launcher']['icon'] = '{}/{}'.format(
-            new_dir, fs.relpath(manifest['launcher']['icon'], old_dir)
-        )
-
-
-def _check_manifest(manifest: T.Manifest1) -> None:
-    assert manifest['assets'], 'field `assets` cannot be empty!'
-    assert all(not x.startswith('../') for x in manifest['assets']), (
-        'manifest should be put at the root of project, and there shall be no '
-        '"../" in your assets keys.'
-    )
-    
-    launcher: T.Launcher1 = manifest['launcher']
-    
-    # check script
-    script = launcher['script']
-    assert script, 'field `script` cannot be empty!'
-    assert not script.startswith('../'), (
-        'manifest should be put at the root of project, and there shall be no '
-        '"../" in your script path.', script
-    )
-    script_path = '{}/{}'.format(
-        manifest['start_directory'], script.split(' ', 1)[0]
-    )
-    assert exists(script_path), (
-        'the script is not found, you may check: 1. do not use abspath in '
-        'script; 2. the path should exist.'
-    )
-    assert script_path.endswith('.py') or (
-            os.path.isdir(script_path)
-            and exists(f'{script_path}/__init__.py')
-    ), (
-        'either the script should be a ".py" file, or be a directory that '
-        'includes "__init__.py" file.'
-    )
-    
-    # check icon
-    icon = launcher['icon']
-    if icon:
-        assert os.path.isabs(icon)
-        
-        assert icon.endswith('.ico'), (
-            'make sure the icon file is ".ico" format. if you have another '
-            'file type, please use a online converter (for example '
-            'https://findicons.com/convert) to get one.'
-        )
-        
-        icon_relpath = fs.relpath(icon, manifest['start_directory'])
-        try:
-            assert icon_relpath.startswith(
-                tuple(manifest['assets'].keys())
-            )
-        except AssertionError:
-            if '' in manifest['assets']:
-                pass
-            else:
-                print(dedent('''
-                    the launcher icon is not added to your assets list.
-                    you may stop current progress right now, and re-check your
-                    manifest file.
-                    (if you confirm that the icon is added, it may be a bug
-                    from depsland.)
-                '''), ':v3')
-                sleep(1)
-        
-        # TODO: check icon size and give suggestions (the icon is suggested
-        #  128x128 or above.)
-    
-    if launcher['start_menu']:
-        print(':v3', 'start_menu is not tested yet. this is an experimental '
-                     'feature.')
-
-
-def _update_assets(assets0: T.Assets0, manifest_dir: str) -> T.Assets1:
-    def generate_hash() -> str:
-        # nonlocal: abspath, ftype (file_type)
-        # generate: fhash (file_hash)
-        if ftype == 'file':
-            return get_file_hash(abspath)
-        return ''
-    
-    def generate_utime() -> int:
-        # nonlocal: abspath, scheme
-        # generate: utime (updated_time)
-        if scheme in ('root', 'top', 'top_files', 'top_dirs'):
-            return get_updated_time(abspath, recursive=False)
-        else:
-            return get_updated_time(abspath, recursive=True)
-    
-    def generate_uid() -> str:
-        # nonlocal: ftype, relpath
-        # generate: uid (hash_of_relpath)
-        return get_content_hash(f'{ftype}:{relpath}')
-    
-    out = {}
-    for path, scheme in assets0.items():
-        if scheme == '':
-            scheme = 'all'
-        if os.path.isabs(path):
-            abspath = fs.normpath(path)
-            relpath = fs.relpath(path, manifest_dir)
-        else:
-            abspath = fs.normpath(f'{manifest_dir}/{path}')
-            relpath = fs.normpath(path)
-        if not exists(abspath):
-            raise FileNotFoundError(path)
-        # minor fix relpath
-        if relpath == '.':
-            # `fs.relpath` may return '.', we need to convert it to ''.
-            relpath = ''
-        out[relpath] = AssetInfo(
-            type=(ftype := 'file' if os.path.isfile(abspath) else 'dir'),
-            scheme=scheme,
-            utime=generate_utime(),
-            hash=generate_hash(),
-            uid=generate_uid(),
-        )
-    return out  # noqa
-
-
-def _update_dependencies(deps0: T.Dependencies0) -> T.Dependencies1:
-    # just return as is.
-    return deps0
-
-
-def _update_pypi(pypi0: T.PyPI0, manifest_dir: str) -> T.PyPI1:
-    out = {}
-    for path in pypi0:
-        if os.path.isabs(path):
-            abspath = fs.normpath(path)
-        else:
-            abspath = fs.normpath(f'{manifest_dir}/{path}')
-        out[fs.filename(abspath)] = abspath
-    return out
-
-
-def _update_launcher(
-        launcher0: T.Launcher0,
-        start_directory: str
-) -> T.Launcher1:
-    out = {
-        'script'      : '',
-        'icon'        : '',
-        'cli_tool'    : False,
-        'desktop'     : False,
-        'start_menu'  : False,
-        'show_console': True,
-    }
-    out.update(launcher0)  # noqa
-    if out['icon']:
-        if os.path.isabs(out['icon']):
-            out['icon'] = fs.normpath(out['icon'])
-        else:
-            out['icon'] = fs.normpath(f'{start_directory}/{out["icon"]}')
-    return out
-
-
-# -----------------------------------------------------------------------------
-
-def dump_manifest(manifest: T.Manifest1, file_o: T.ManifestFile) -> None:
-    manifest_i = manifest
-    manifest_o: T.Manifest1 = manifest_i.copy()
-    
-    if manifest_i['launcher']['icon']:
-        manifest_o['launcher'] = manifest_i['launcher'].copy()
-        manifest_o['launcher']['icon'] = fs.relpath(
-            manifest_o['launcher']['icon'],
-            manifest_o['start_directory']
-        )
-    if file_o.endswith('.json'):
-        manifest_o['assets'] = _plainify_assets(manifest_i['assets'])  # noqa
-    
-    manifest_o['start_directory'] = fs.parent_path(file_o)
-    dumps(manifest_o, file_o)
-
-
-def _plainify_assets(assets1: T.Assets1) -> T.Assets0:
-    out = {}
-    for path, info in assets1.items():
-        out[path] = info.scheme
-    return out
-
-
-# -----------------------------------------------------------------------------
-# more
-
-def init_target_tree(manifest: T.Manifest1, root_dir: str = None) -> None:
-    if not root_dir:
-        root_dir = manifest['start_directory']
-    print('init making tree', root_dir)
-    paths_to_be_created = set()
-    for k, v in manifest['assets'].items():
-        abspath = fs.normpath(f'{root_dir}/{k}')
-        if v.type == 'dir':
-            paths_to_be_created.add(abspath)
-        else:
-            paths_to_be_created.add(fs.parent_path(abspath))
-    paths_to_be_created = sorted(paths_to_be_created)
-    print(':l', paths_to_be_created)
-    [os.makedirs(x, exist_ok=True) for x in paths_to_be_created]
-
-
-def compare_manifests(new: T.Manifest1, old: T.Manifest1) -> T.ManifestDiff:
-    return {
-        'assets'      : _compare_assets(
-            new['assets'], old['assets']
-        ),
-        'dependencies': _compare_dependencies(
-            new['dependencies'], old['dependencies']
-        ),
-        'pypi'        : _compare_pypi(
-            new['pypi'], old['pypi']
-        ),
-    }
-
-
-def _compare_assets(
-        new: T.Assets1, old: T.Assets1
-) -> T.AssetsDiff:
-    def is_same(new: T.AssetInfo, old: T.AssetInfo) -> bool:
-        """
-        comparing assets is considered based on a variety of factors:
-            - scheme
-            - type
-            - hash
-            - utime
-        """
-        if new.scheme == old.scheme == 'root':
-            return True
-        if new.scheme != old.scheme:
-            return False
-        if new.type != old.type:
-            return False
-        if new.hash == old.hash != '':
-            return True
-        if new.utime == old.utime:
-            return True
-        return False
-    
-    for key0, info0 in old.items():
-        if key0 not in new:
-            yield 'delete', key0, (info0, None)
-    
-    for key1, info1 in new.items():
-        if key1 not in old:
-            yield 'append', key1, (None, info1)
-            continue
-        info0 = old[key1]
-        if not is_same(info1, info0):
-            yield 'update', key1, (info0, info1)
-        else:
-            yield 'ignore', key1, (info0, info1)
-
-
-def _compare_dependencies(
-        new: T.Dependencies1, old: T.Dependencies1
-) -> T.DependenciesDiff:
-    for name0, verspec0 in old.items():
-        if name0 not in new:
-            yield 'delete', (name0, verspec0)
-    for name1, verspec1 in new.items():
-        if name1 not in old:
-            yield 'append', (name1, verspec1)
-            continue
-        verspec0 = old[name1]
-        if verspec1 != verspec0:
-            yield 'update', (name1, verspec1)
-        else:
-            yield 'ignore', (name1, verspec1)
-
-
-def _compare_pypi(
-        new: T.PyPI1, old: T.PyPI1
-) -> T.PyPIDiff:
-    for name0, _ in old.items():  # the old.values() are all None.
-        if name0 not in new:
-            yield 'delete', (name0, None)
-    for name1, path1 in new.items():  # path1 is a local abspath to a whl file.
-        if name1 not in old:
-            yield 'append', (name1, path1)
-        else:
-            yield 'ignore', (name1, path1)
+import os
+import typing as t
+from collections import namedtuple
+from os.path import exists
+from textwrap import dedent
+from time import sleep
+
+from lk_utils import dumps
+from lk_utils import fs
+from lk_utils import loads
+
+from .. import normalization as norm
+from ..depsolver import T as T0
+from ..depsolver import resolve_dependencies
+from ..utils import get_content_hash
+from ..utils import get_file_hash
+from ..utils import get_updated_time
+
+
+# noinspection PyTypedDict
+class T(T0):
+    AbsPath = RelPath = AnyPath = str
+    #   the RelPath is relative to manifest file's location.
+    
+    Scheme0 = t.Literal[
+        'root', 'all', 'all_dirs', 'top', 'top_files', 'top_dirs',  # fmt:skip
+        ''  # empty str means 'all'  # fmt:skip
+    ]
+    Scheme1 = t.Literal[
+        'root', 'all', 'all_dirs', 'top', 'top_files', 'top_dirs'
+    ]
+    
+    Assets0 = t.Dict[AnyPath, Scheme0]
+    #   anypath: abspath or relpath, '/' or '\\' both allowed.
+    #   scheme: scheme or empty string. if empty string, it means 'all'.
+    Assets1 = t.Dict[
+        RelPath,
+        AssetInfo := t.NamedTuple(
+            'AssetInfo',
+            (
+                ('type', t.Literal['file', 'dir']),
+                ('scheme', Scheme1),
+                ('utime', int),  # updated time
+                ('hash', str),  # if type is dir, the hash is empty
+                ('uid', str),  # the uid will be used as key to filename in oss.
+            ),
+        ),
+    ]
+    
+    Dependencies0 = t.Union[
+        # 1. no dependency
+        None,
+        # 2. a file path, usually 'pyproject.toml', 'requirements.txt', etc.
+        str,
+        # 3. a list of packages. e.g. ['requests', 'numpy>=1.26', ...]
+        t.List[str],
+        # 4. packages with more detailed definitions. e.g.
+        #   {
+        #       'numpy': [
+        #           {'version': '1.26.2', 'platform': 'linux'},
+        #           {'version': '*', 'platform': '!=linux'},
+        #       ], ...
+        #   }
+        t.Dict[str, t.Union[str, dict, list]],
+    ]
+    Dependencies1 = T0.Packages
+    
+    Launcher0 = t.TypedDict(
+        'Launcher0',
+        {
+            'target'           : AnyPath,
+            'type'             : t.Literal['executable', 'module', 'package'],
+            'icon'             : AnyPath,
+            #   the origin icon could be: empty, a relpath, or an abspath.
+            'args'             : t.List[t.Any],
+            'kwargs'           : t.Dict[str, t.Any],
+            'enable_cli'       : bool,
+            'add_to_desktop'   : bool,
+            'add_to_start_menu': bool,
+            'show_console'     : bool,
+        },
+    )
+    Launcher1 = Launcher0
+    #   same with Launcher0 but 'target' and 'icon' are RelPath.
+    #   FIXME: why we use relpath?
+    
+    # -------------------------------------------------------------------------
+    
+    # Manifest0: original manifest
+    #   this is a json-compatible dict. it is either made by user or dumped by \
+    #   `dump_manifest` function (when caller passes a '.json' file param to \
+    #   it).
+    Manifest0 = t.TypedDict(
+        'Manifest0',
+        {
+            'appid'           : str,
+            'name'            : str,
+            'version'         : str,
+            'assets'          : Assets0,
+            'dependencies'    : Dependencies0,
+            'launcher'        : Launcher0,
+            'depsland_version': str,
+        },
+        total=False,
+    )
+    
+    # Manifest1: standard manifest
+    #   this is core and unified data structure for program to use. it is \
+    #   loaded from a '.pkl' file, or parsed from a '.json' file by \
+    #   `Manifest.load_from_file`.
+    #   the differences between Manifest0 and Manifest1 are:
+    #       1. ~1 has an unified path form (all must be abspath).
+    #       2. ~1 has an extra key 'start_directory'.
+    #       3. ~1's assets values are `namedtuple AssetInfo`.
+    Manifest1 = t.TypedDict(
+        'Manifest1',
+        {
+            'appid'           : str,
+            'name'            : str,
+            'version'         : str,
+            'start_directory' : AbsPath,
+            'assets'          : Assets1,
+            'dependencies'    : Dependencies1,
+            'launcher'        : Launcher1,
+            'depsland_version': str,
+        },
+    )
+    
+    # -------------------------------------------------------------------------
+    
+    Action = t.Literal['append', 'update', 'delete', 'ignore']
+    
+    AssetsDiff = t.Iterator[
+        t.Tuple[
+            Action,
+            RelPath,
+            t.Tuple[
+                t.Optional[AssetInfo],
+                t.Optional[AssetInfo],
+            ],
+        ]
+    ]
+    
+    DependenciesDiff = t.Iterator[
+        t.Tuple[
+            Action,
+            T0.PackageName,
+            t.Tuple[
+                t.Optional[T0.PackageInfo],
+                t.Optional[T0.PackageInfo],
+            ],
+        ]
+    ]
+    
+    # see `depsland.api.dev_api.publish._upload`
+    ManifestDiff = t.TypedDict(
+        'ManifestDiff',
+        {
+            'assets'      : AssetsDiff,
+            'dependencies': DependenciesDiff,
+        },
+    )
+
+
+# -----------------------------------------------------------------------------
+
+
+def init_manifest(appid: str, appname: str) -> 'Manifest':
+    return Manifest.init(appid, appname)
+
+
+def load_manifest(file: T.AnyPath) -> 'Manifest':
+    return Manifest.load_from_file(file)
+
+
+def dump_manifest(manifest: 'Manifest', file: T.AnyPath) -> None:
+    assert isinstance(manifest, Manifest)
+    manifest.dump_to_file(file)
+
+
+def diff_manifest(new: 'Manifest', old: 'Manifest') -> T.ManifestDiff:
+    return {
+        'assets'      : _diff_assets(
+            new.model['assets'],
+            old.model['assets'],
+        ),
+        'dependencies': _diff_dependencies(
+            new['dependencies'],
+            old['dependencies'],
+        )
+    }
+
+
+# -----------------------------------------------------------------------------
+
+
+AssetInfo = namedtuple('AssetInfo', ('type', 'scheme', 'utime', 'hash', 'uid'))
+
+
+class Manifest:
+    _file: T.AbsPath
+    _manifest: T.Manifest1
+    _start_directory: T.AbsPath
+    
+    @classmethod
+    def init(cls, appid: str, appname: str) -> 'Manifest':
+        from .. import __version__
+        
+        self = Manifest()
+        
+        self._file = ''
+        self._start_directory = ''
+        
+        self._manifest = {
+            'appid'           : appid,
+            'name'            : appname,
+            'version'         : '0.0.0',
+            'start_directory' : '',
+            'assets'          : {},
+            'dependencies'    : {},
+            'launcher'        : {
+                'target'           : '',
+                'type'             : '',
+                'icon'             : '',
+                'args'             : [],
+                'kwargs'           : {},
+                'enable_cli'       : False,
+                'add_to_desktop'   : True,
+                'add_to_start_menu': False,
+                'show_console'     : True,
+            },
+            'depsland_version': __version__,
+        }
+        
+        return self
+    
+    @classmethod
+    def load_from_file(cls, file: T.AnyPath) -> 'Manifest':
+        """
+        args:
+            file: a '.json' or a '.pkl' file.
+        """
+        from .. import __version__
+        
+        self = Manifest()
+        self._file = fs.abspath(file)
+        self._start_directory = fs.parent(self._file)
+        
+        data0: t.Union[T.Manifest0, T.Manifest1]
+        data1: T.Manifest1
+        
+        if self._file.endswith('.pkl'):
+            data0: T.Manifest1 = loads(self._file)
+            data1 = data0
+            data1['start_directory'] = self._start_directory
+        else:
+            assert self._file.endswith('.json')
+            data0: T.Manifest0 = loads(self._file)
+            
+            self._precheck_manifest(data0)
+            data1 = {
+                'appid'           : data0['appid'],
+                'name'            : data0['name'],
+                'version'         : data0['version'],
+                'start_directory' : self._start_directory,
+                'assets'          : self._update_assets(
+                    data0.get('assets', {}), self._start_directory
+                ),
+                'dependencies'    : self._update_dependencies(
+                    data0.get('dependencies', 'requirements.lock'),
+                ),
+                'launcher'        : self._update_launcher(
+                    data0.get('launcher', {}), self._start_directory
+                ),
+                'depsland_version': data0.get(
+                    'depsland_version', __version__
+                ),
+            }
+            self._postcheck_manifest(data1)
+        
+        self._manifest = data1
+        return self
+    
+    def dump_to_file(self, file: T.AnyPath = None) -> None:
+        if file is None:
+            file = self._file
+        
+        data1: T.Manifest1 = self._manifest
+        data0: T.Manifest0 = self._manifest.copy()
+        
+        if file.endswith('.pkl'):
+            data0['start_directory'] = fs.parent_path(fs.abspath(file))  # noqa
+            #   or set to ''?
+        else:
+            data0.pop('start_directory')
+            data0['assets'] = self._plainify_assets(data1['assets'])
+        
+        dumps(data0, file)
+    
+    # -------------------------------------------------------------------------
+    
+    @property
+    def model(self) -> T.Manifest1:
+        return self._manifest
+    
+    @property
+    def start_directory(self) -> T.AbsPath:
+        return self._start_directory
+    
+    @start_directory.setter
+    def start_directory(self, path: T.AnyPath) -> None:
+        path = fs.abspath(path)
+        self._start_directory = path
+    
+    def __getitem__(self, item: str) -> t.Any:
+        if item == 'start_directory':
+            return self._start_directory
+        return self._manifest[item]  # noqa
+    
+    def __setitem__(self, key: str, value: t.Any) -> None:
+        if key == 'start_directory':
+            self.start_directory = value
+        else:
+            raise Exception('cannot modify top field of manifest!', key, value)
+    
+    # -------------------------------------------------------------------------
+    
+    @staticmethod
+    def _precheck_manifest(manifest: T.Manifest0) -> None:
+        # assert required keys
+        required_keys = ('appid', 'name', 'version', 'assets')
+        assert all(x in manifest for x in required_keys), (
+            'the required keys are not complete',
+            required_keys,
+            tuple(manifest.keys()),
+        )
+        
+        assert norm.check_name_normalized(manifest['appid']), (
+            'the appid should be lowercase and only contains alphanumber and '
+            'underscore.'
+        )
+        
+        assert manifest['assets'], 'field `assets` cannot be empty!'
+        assert all(not x.startswith('../') for x in manifest['assets']), (
+            'manifest should be put at the root of project, and there shall be '
+            'no "../" in your assets keys.'
+        )
+        
+        launcher: T.Launcher1 = manifest['launcher']
+        target = launcher['target']
+        assert target, 'field `launcher.target` cannot be empty!'
+        assert not target.startswith('../'), (
+            (
+                'manifest should be put at the root of project, and there '
+                'shall be no "../*" in your script path.'
+            ),
+            target,
+        )
+        
+        # TODO: currently we don't support auto deduce launcher type.
+        assert launcher['type'], (
+            'you must set `launcher.type` apparently. depsland does not '
+            'support auto deducing it yet.'
+        )
+        assert launcher['type'] in ('executable', 'module', 'package')
+    
+    @staticmethod
+    def _postcheck_manifest(manifest: T.Manifest1) -> None:
+        launcher: T.Launcher1 = manifest['launcher']
+        
+        # check script
+        target_path = '{}/{}'.format(
+            manifest['start_directory'], launcher['target']
+        )
+        target_type = launcher['type']
+        try:
+            if target_type == 'module':
+                assert target_path.endswith('.py')
+                assert exists(target_path)
+            elif target_type == 'package':
+                assert os.path.isdir(target_path)
+                assert exists('{}/__init__.py'.format(target_path))
+                assert exists('{}/__main__.py'.format(target_path))
+            else:
+                assert exists(target_path)
+        except AssertionError as e:
+            raise Exception(
+                'the target is not found in your file system', target_path
+            ) from e
+        
+        # check icon
+        if launcher['icon']:
+            icon_path = '{}/{}'.format(
+                manifest['start_directory'], launcher['icon']
+            )
+            assert exists(icon_path)
+            
+            assert icon_path.endswith('.ico'), (
+                'make sure the icon file is ".ico" format. if you have other '
+                'file type, please use a online converter (for example '
+                'https://findicons.com/convert) to get one.'
+            )
+            
+            icon_relpath = fs.relpath(icon_path, manifest['start_directory'])
+            try:
+                assert icon_relpath.startswith(tuple(manifest['assets'].keys()))
+            except AssertionError:
+                if '' in manifest['assets']:
+                    pass
+                else:
+                    print(
+                        dedent('''
+                            the launcher icon is not added to your assets list.
+                            you may stop current progress right now, and
+                            re-check your manifest file.
+                            (if you confirm that the icon is added, it may be a
+                            bug from depsland.)
+                        '''),
+                        ':v3',
+                    )
+                    sleep(1)
+            
+            # TODO: check icon size and give suggestions (the icon is suggested
+            #  128x128 or above.)
+        
+        if kwargs := launcher['kwargs']:
+            assert all(' ' not in k for k in kwargs)
+            # TODO: shall we check `'-' not in k`?
+        
+        if launcher['add_to_start_menu']:
+            print(
+                ':v3',
+                '`launcher.add_to_start_menu` is not tested yet. this is an '
+                'experimental feature.',
+            )
+    
+    # -------------------------------------------------------------------------
+    
+    @staticmethod
+    def _update_assets(
+        assets0: T.Assets0, start_directory: T.AbsPath
+    ) -> T.Assets1:
+        def generate_hash() -> str:
+            # nonlocal: abspath, ftype (file_type)
+            # generate: fhash (file_hash)
+            if ftype == 'file':
+                return get_file_hash(abspath)
+            return ''
+        
+        def generate_utime() -> int:
+            # nonlocal: abspath, scheme
+            # generate: utime (updated_time)
+            if scheme in ('root', 'top', 'top_files', 'top_dirs'):
+                return get_updated_time(abspath, recursive=False)
+            else:
+                return get_updated_time(abspath, recursive=True)
+        
+        def generate_uid() -> str:
+            # nonlocal: ftype, relpath
+            # generate: uid (hash_of_relpath)
+            return get_content_hash(f'{ftype}:{relpath}')
+        
+        out = {}
+        for path, scheme in assets0.items():
+            if scheme == '':
+                scheme = 'all'
+            if os.path.isabs(path):
+                abspath = fs.normpath(path)
+                relpath = fs.relpath(path, start_directory)
+            else:
+                abspath = fs.normpath(f'{start_directory}/{path}')
+                relpath = fs.normpath(path)
+            if not exists(abspath):
+                raise FileNotFoundError(
+                    'please check the path you defined in manifest does exist',
+                    path
+                )
+            # minor fix relpath
+            if relpath == '.':
+                # `fs.relpath` may return '.', we need to convert it to ''.
+                relpath = ''
+            out[relpath] = AssetInfo(
+                type=(ftype := 'file' if os.path.isfile(abspath) else 'dir'),
+                scheme=scheme,
+                utime=generate_utime(),
+                hash=generate_hash(),
+                uid=generate_uid(),
+            )
+        return out  # noqa
+    
+    def _update_dependencies(self, deps0: T.Dependencies0) -> T.Dependencies1:
+        return resolve_dependencies(deps0, self._start_directory)
+    
+    @staticmethod
+    def _update_launcher(
+        launcher0: T.Launcher0, start_directory: T.AbsPath
+    ) -> T.Launcher1:
+        out: T.Launcher1 = {
+            'target'           : '',
+            'type'             : '',  # noqa
+            'icon'             : '',
+            'args'             : [],
+            'kwargs'           : {},
+            'enable_cli'       : False,
+            'add_to_desktop'   : False,
+            'add_to_start_menu': False,
+            'show_console'     : True,
+        }
+        out.update(launcher0)  # noqa
+        
+        # noinspection PyTypedDict
+        def normalize_paths() -> None:
+            for k in ('target', 'icon'):
+                if v := out[k]:
+                    if os.path.isabs(v):
+                        out[k] = fs.relpath(v, start_directory)
+                    else:
+                        out[k] = fs.normpath(v)
+        
+        # noinspection PyUnusedLocal,PyTypedDict
+        def deduce_type() -> None:
+            if out['target'].endswith('.py'):
+                out['type'] = 'module'
+            elif out['target'] and (
+                d := os.path.isdir(
+                    '{}/{}'.format(start_directory, out['target'])
+                )
+            ):
+                if exists(
+                    '{}/__init__.py'.format(d)
+                ) and exists(
+                    '{}/__main__.py'.format(d)
+                ):  # noqa
+                    out['type'] = 'package'
+                else:
+                    out['type'] = 'executable'
+            else:
+                raise Exception(
+                    'cannot deduce the launcher type!', out['target']
+                )
+        
+        normalize_paths()
+        if not out['type']:
+            deduce_type()
+        return out
+    
+    # -------------------------------------------------------------------------
+    
+    @staticmethod
+    def _plainify_assets(assets1: T.Assets1) -> T.Assets0:
+        out = {}
+        for path, info in assets1.items():
+            out[path] = info.scheme
+        return out
+
+
+# -----------------------------------------------------------------------------
+
+
+def _diff_assets(new: T.Assets1, old: T.Assets1) -> T.AssetsDiff:
+    def is_same(new: T.AssetInfo, old: T.AssetInfo) -> bool:
+        """
+        comparing assets is considered based on a variety of factors:
+            - scheme
+            - type
+            - hash
+            - utime
+        """
+        if new.scheme == old.scheme == 'root':
+            return True
+        if new.scheme != old.scheme:
+            return False
+        if new.type != old.type:
+            return False
+        if new.hash == old.hash != '':
+            return True
+        if new.utime == old.utime:
+            return True
+        return False
+    
+    for key0, info0 in old.items():
+        if key0 not in new:
+            yield 'delete', key0, (info0, None)
+    
+    for key1, info1 in new.items():
+        if key1 not in old:
+            yield 'append', key1, (None, info1)
+            continue
+        info0 = old[key1]
+        if not is_same(info1, info0):
+            yield 'update', key1, (info0, info1)
+        else:
+            yield 'ignore', key1, (info0, info1)
+
+
+def _diff_dependencies(new: T.Packages, old: T.Packages) -> T.DependenciesDiff:
+    info0: T.PackageInfo
+    info1: T.PackageInfo
+    
+    for name0, info0 in old.items():
+        if name0 not in new:
+            yield 'delete', name0, (info0, None)
+            continue
+        
+        name1, info1 = name0, new[name0]
+        if info1['version'] != info0['version']:
+            yield 'update', name1, (info0, info1)
+        else:
+            yield 'ignore', name0, (info0, info1)
+    
+    for name1, info1 in new.items():
+        if name1 not in old:
+            yield 'append', name1, (None, info1)
```

## depsland/normalization.py

```diff
@@ -1,146 +1,192 @@
-import re
-import typing as t
-from dataclasses import dataclass
-
-
-class T:
-    RawName = str  # e.g. 'lk-logger', 'PySide6', etc.
-    RawVersionSpec = str  # e.g. '>=5.4.6a0'
-    
-    Name = str  # e.g. 'lk_logger', 'pyside6', etc.
-    Version = str  # a semantic version.
-    #   it could be empty, means 'any version'.
-    #   there is no such thing like: '0.0.0', 'latest', 'any', '*', because
-    #   they are not semantic versions.
-    VersionSpec = t.ForwardRef('VersionSpec')
-
-
-@dataclass
-class VersionSpec:
-    # https://pip.pypa.io/en/stable/cli/pip_install/#requirement-specifiers
-    name: T.Name  # e.g. 'lk_logger'
-    version: T.Version
-    comparator: str  # '>=', '>', '==', '<', '<=', '!=', '~=', ''
-    
-    # def __init__(self, name: T.Name, version: T.Version, comparator: str):
-    #     if version == '0.0.0':
-    #         assert comparator in ('>=', '==', '')
-    #         version = ''
-    #         comparator = ''
-    #     self.name = name
-    #     self.version = version
-    #     self.comparator = comparator
-    
-    def __str__(self):
-        return self.full_spec
-    
-    def __repr__(self):
-        return f'VersionSpec[{self.full_spec}]'
-    
-    @property
-    def spec(self) -> str:  # e.g. '>=5.4.6a0'
-        return f'{self.comparator}{self.version}'
-    
-    @property
-    def full_spec(self) -> str:  # e.g. 'lk_logger>=5.4.6a0'
-        return f'{self.name}{self.comparator}{self.version}'
-
-
-def filename_2_name_version(filename: str) -> t.Tuple[T.Name, T.Version]:
-    """
-    examples:
-        'PyYAML-6.0-cp310-cp310-macosx_10_9_x86_64.whl' -> ('pyyaml', '6.0')
-        'lk-logger-4.0.7.tar.gz' -> ('lk_logger', '4.0.7')
-        'aliyun-python-sdk-2.2.0.zip' -> ('aliyun_python_sdk', '2.2.0')
-    """
-    for ext in ('.whl', '.tar.gz', '.zip'):
-        if filename.endswith(ext):
-            filename = filename.removesuffix(ext)
-            break
-    else:
-        raise ValueError(filename)
-    # assert ext
-    if ext == '.whl':
-        a, b, _ = filename.split('-', 2)
-    else:
-        a, b = filename.rsplit('-', 1)
-    a = normalize_name(a)
-    return a, b
-
-
-def normalize_name(raw_name: T.RawName) -> T.Name:
-    """
-    e.g. 'lk-logger' -> 'lk_logger'
-         'PySide6' -> 'pyside6'
-    """
-    return raw_name.strip().lower().replace('-', '_')
-
-
-def normalize_version_spec(
-        name: T.Name, raw_verspec: T.RawVersionSpec
-) -> t.Iterator[T.VersionSpec]:
-    """
-    e.g.
-        '4.5.3'         ->  <spec of '==4.5.3'>
-        '>=4.5.0'       ->  <spec of '>=4.5.0'>
-        '>=4.5,<5.0'    ->  <spec of '>=4.5.0,<5.0.0'>
-        '==4.*'         ->  <spec of '>=4.0,<5.0'>
-        '==4.3.*'       ->  <spec of '>=4.3.0,<4.4.0'>
-        'latest'        ->  <spec of ''>
-        'any'           ->  <spec of ''>
-        '*'             ->  <spec of ''>
-    """
-    if not raw_verspec:
-        yield VersionSpec(name, '', '')
-        return
-    
-    from .utils.verspec import semver_parse
-    
-    pattern_to_split_comp_and_ver = re.compile(r'([<>=!~]*)(.+)')
-    
-    for part in raw_verspec.split(','):
-        comp, ver = pattern_to_split_comp_and_ver.search(part).groups()
-        if comp == '':
-            comp = '=='
-        
-        if ver in ('latest', 'any', '*'):
-            assert comp == '=='
-            yield VersionSpec(
-                name=name,
-                version='',
-                comparator='',
-            )
-        
-        elif '*' not in ver:
-            yield VersionSpec(
-                name=name,
-                version=ver,
-                comparator=comp,
-            )
-        
-        else:
-            assert comp in ('>=', '==')
-            assert (m := re.search(r'((?:\d\.)+)\*$', ver)), \
-                'the asterisk symbol could only be in minor or patch position'
-            minor_or_patch = 'minor' if m.group(1).count('.') == 1 else 'patch'
-            bottom_ver = semver_parse(ver)
-            bumped_ver = (bottom_ver.bump_major() if minor_or_patch == 'minor'
-                          else bottom_ver.bump_minor())
-            yield VersionSpec(
-                name=name,
-                version=str(bottom_ver),
-                comparator='>='
-            )
-            yield VersionSpec(
-                name=name,
-                version=str(bumped_ver),
-                comparator='<'
-            )
-
-
-# DELETE: no usage
-def split_name_and_verspec(text: str) -> t.Tuple[T.RawName, T.RawVersionSpec]:
-    text = text.replace(' ', '')
-    pattern = re.compile(r'([-\w]+)(.*)')
-    raw_name, verspec = pattern.match(text).groups()
-    return raw_name, verspec
+import re
+import typing as t
+from dataclasses import dataclass
+
+
+class T:
+    RawName = str  # e.g. 'lk-logger', 'PySide6', etc.
+    RawVersionSpec = str  # e.g. '>=5.4.6a0'
+    
+    Name = str  # e.g. 'lk_logger', 'pyside6', etc.
+    Version = str  # a semantic version.
+    #   it could be empty, means 'any version'.
+    #   there is no such thing like: '0.0.0', 'latest', 'any', '*', because \
+    #   they are not semantic versions.
+    VersionSpec = t.ForwardRef('VersionSpec')
+
+
+@dataclass
+class VersionSpec:
+    # https://pip.pypa.io/en/stable/cli/pip_install/#requirement-specifiers
+    name: T.Name  # e.g. 'lk_logger'
+    version: T.Version
+    comparator: str  # '>=', '>', '==', '<', '<=', '!=', '~=', ''
+    
+    # def __init__(self, name: T.Name, version: T.Version, comparator: str):
+    #     if version == '0.0.0':
+    #         assert comparator in ('>=', '==', '')
+    #         version = ''
+    #         comparator = ''
+    #     self.name = name
+    #     self.version = version
+    #     self.comparator = comparator
+    
+    def __str__(self):
+        return self.full_spec
+    
+    def __repr__(self):
+        return f'VersionSpec[{self.full_spec}]'
+    
+    @property
+    def spec(self) -> str:  # e.g. '>=5.4.6a0'
+        return f'{self.comparator}{self.version}'
+    
+    @property
+    def full_spec(self) -> str:  # e.g. 'lk_logger>=5.4.6a0'
+        return f'{self.name}{self.comparator}{self.version}'
+
+
+def check_name_normalized(name: str) -> bool:
+    return name == normalize_name(name)
+
+
+def normalize_anyname(raw: str) -> t.Tuple[T.Name, t.Tuple[T.VersionSpec, ...]]:
+    """
+    examples:
+        'PySide6' -> ('pyside6', ())
+        'PySide6 >=6.0.4, <6.1' -> (
+            'pyside6',
+            (<spec of '>=6.0.4'>, <spec of '<6.1.0'>)
+        )
+    """
+    a, b = re.search(r'([^ <>=!~]+)(.*)', raw.replace(' ', '')).groups()
+    name = normalize_name(a)
+    if b:
+        return name, tuple(normalize_verspecs(name, b))
+    else:
+        # return name, (VersionSpec(name, '', ''),)
+        return name, ()
+
+
+def normalize_name(raw_name: T.RawName) -> T.Name:
+    """
+    examples:
+        'PySide6'           -> 'pyside6'
+        'PyYAML'            -> 'pyyaml'
+        'lk-logger'         -> 'lk_logger'
+        'jaraco.classes'    -> 'jaraco_classes'
+            https://pypi.tuna.tsinghua.edu.cn/simple/jaraco-classes/
+    """
+    return raw_name.lower().replace('-', '_').replace('.', '_')
+
+
+# def normalize_name_and_verspecs(raw_name: str) -> t.Tuple[
+#     T.Name, t.Iterator[T.VersionSpec]
+# ]:
+#     """
+#     examples:
+#         'PySide6 >=6.0.4, <6.1' -> (
+#             'pyside6',
+#             (<spec of '>=6.0.4'>, <spec of '<6.1.0'>)
+#         )
+#     """
+#     a, b = re.search(r'([^ <>=!~]+)(.+)', raw_name.replace(' ', '')).groups()
+#     name = normalize_name(a)
+#     verspecs = normalize_verspecs(name, b)
+#     return name, verspecs
+
+
+def normalize_verspecs(
+    name: T.Name, raw_verspec: T.RawVersionSpec
+) -> t.Iterator[T.VersionSpec]:
+    """
+    e.g.
+        '4.5.3'         ->  <spec of '==4.5.3'>
+        '>=4.5.0'       ->  <spec of '>=4.5.0'>
+        '>=4.5,<5.0'    ->  <spec of '>=4.5.0,<5.0.0'>
+        '==4.*'         ->  <spec of '>=4.0,<5.0'>
+        '==4.3.*'       ->  <spec of '>=4.3.0,<4.4.0'>
+        'latest'        ->  <spec of ''>
+        'any'           ->  <spec of ''>
+        '*'             ->  <spec of ''>
+    """
+    if not raw_verspec:
+        yield VersionSpec(name, '', '')
+        return
+    
+    from .verspec import semver_parse
+    
+    pattern_to_split_comp_and_ver = re.compile(r'([<>=!~]*)(.+)')
+    
+    for part in raw_verspec.split(','):
+        comp, ver = pattern_to_split_comp_and_ver.search(part).groups()
+        if comp == '':
+            comp = '=='
+        
+        if ver in ('latest', 'any', '*'):
+            assert comp == '=='
+            yield VersionSpec(
+                name=name,
+                version='',
+                comparator='',
+            )
+        
+        elif '*' not in ver:
+            yield VersionSpec(
+                name=name,
+                version=ver,
+                comparator=comp,
+            )
+        
+        else:
+            assert comp in ('>=', '==')
+            assert (
+                m := re.search(r'((?:\d\.)+)\*$', ver)
+            ), 'the asterisk symbol could only be in minor or patch position'
+            minor_or_patch = 'minor' if m.group(1).count('.') == 1 else 'patch'
+            bottom_ver = semver_parse(ver)
+            bumped_ver = (
+                bottom_ver.bump_major()
+                if minor_or_patch == 'minor'
+                else bottom_ver.bump_minor()
+            )
+            yield VersionSpec(
+                name=name, version=str(bottom_ver), comparator='>='
+            )
+            yield VersionSpec(
+                name=name, version=str(bumped_ver), comparator='<'
+            )
+
+
+def split_dirname_of_dist_info(dirname: str) -> t.Tuple[T.Name, T.Version]:
+    # e.g. 'qmlease-3.1.0a15.dist-info' -> ('qmlease', '3.1.0a15')
+    from .utils.compat_py38 import remove_suffix
+    
+    dirname = remove_suffix(dirname, '.dist-info')
+    name, version = dirname.split('-')
+    name = normalize_name(name)
+    return name, version
+
+
+def split_filename_of_package(filename: str) -> t.Tuple[T.Name, T.Version]:
+    """
+    examples:
+        'PyYAML-6.0-cp310-cp310-macosx_10_9_x86_64.whl' -> ('pyyaml', '6.0')
+        'lk-logger-4.0.7.tar.gz' -> ('lk_logger', '4.0.7')
+        'aliyun-python-sdk-2.2.0.zip' -> ('aliyun_python_sdk', '2.2.0')
+    """
+    from .utils.compat_py38 import remove_suffix
+    
+    for ext in ('.whl', '.tar.gz', '.zip'):
+        if filename.endswith(ext):
+            filename = remove_suffix(filename, ext)
+            break
+    else:
+        raise ValueError(filename)
+    # assert ext
+    if ext == '.whl':
+        a, b, _ = filename.split('-', 2)
+    else:
+        a, b = filename.rsplit('-', 1)
+    a = normalize_name(a)
+    return a, b
```

## depsland/oss/__init__.py

 * *Ordering differences only*

```diff
@@ -1,3 +1,3 @@
-from .get_oss import T
-from .get_oss import get_oss as get_oss_server
-from .get_oss import get_oss as get_oss_client
+from .get_oss import T
+from .get_oss import get_oss as get_oss_server
+from .get_oss import get_oss as get_oss_client
```

## depsland/oss/_base.py

```diff
@@ -1,49 +1,49 @@
-class BaseOss:
-    type_ = 'base'
-    path: 'BaseOssPath'
-    
-    def upload(self, file: str, link: str) -> None:
-        """
-        warning: if target exists, will overwrite.
-        """
-        raise NotImplementedError
-    
-    def download(self, link: str, file: str) -> None:
-        raise NotImplementedError
-    
-    def delete(self, link: str) -> None:
-        raise NotImplementedError
-
-    @staticmethod
-    def _update_progress(
-            description: str,
-            bytes_consumed: int, total_bytes: int
-    ) -> None:
-        print('{}: {:.2%}'.format(
-            description,
-            bytes_consumed / total_bytes
-        ), end='\r')
-
-
-class BaseOssPath:
-    appid: str
-    root: str
-    
-    def __init__(self, appid: str):
-        self.appid = appid
-        # `self.root` needs to be implemented in subclasses
-    
-    def __str__(self):
-        return f'oss:/depsland/apps/{self.appid}'
-    
-    @property
-    def manifest(self) -> str:
-        return f'{self.root}/manifest.pkl'
-    
-    @property
-    def assets(self) -> str:
-        return f'{self.root}/assets'
-    
-    @property
-    def pypi(self) -> str:
-        return f'{self.root}/pypi'
+class BaseOss:
+    type = 'base'
+    path: 'BaseOssPath'
+    
+    def upload(self, file: str, link: str) -> None:
+        """
+        warning: if target exists, will overwrite.
+        """
+        raise NotImplementedError
+    
+    def download(self, link: str, file: str) -> None:
+        raise NotImplementedError
+    
+    def delete(self, link: str) -> None:
+        raise NotImplementedError
+
+    @staticmethod
+    def _update_progress(
+            description: str,
+            bytes_consumed: int, total_bytes: int
+    ) -> None:
+        print('{}: {:.2%}'.format(
+            description,
+            bytes_consumed / total_bytes
+        ), end='\r')
+
+
+class BaseOssPath:
+    appid: str
+    root: str
+    
+    def __init__(self, appid: str):
+        self.appid = appid
+        # `self.root` needs to be implemented in subclasses
+    
+    def __str__(self):
+        return f'oss:/depsland/apps/{self.appid}'
+    
+    @property
+    def manifest(self) -> str:
+        return f'{self.root}/manifest.pkl'
+    
+    @property
+    def assets(self) -> str:
+        return f'{self.root}/assets'
+    
+    @property
+    def pypi(self) -> str:
+        return f'{self.root}/pypi'
```

## depsland/oss/aliyun_oss.py

```diff
@@ -1,58 +1,66 @@
-from functools import partial
-from os.path import basename
-
-from oss2 import Auth
-from oss2 import Bucket
-
-from ._base import BaseOss
-from ._base import BaseOssPath
-
-
-class AliyunOss(BaseOss):
-    type_ = 'aliyun'
-    
-    def __init__(self, appid: str,
-                 access_key: str, access_secret: str,
-                 endpoint: str, bucket_name: str, **_):
-        self.path = AliyunOssPath(appid)
-        self._auth = Auth(access_key, access_secret)
-        self._bucket = Bucket(self._auth, endpoint, bucket_name)
-    
-    @property
-    def bucket(self):
-        return self._bucket
-    
-    def make_link(self, key: str, expires=3600) -> str:
-        """ make link for sharing. """
-        return self._bucket.sign_url('GET', key, expires)
-    
-    def upload(self, file: str, link: str) -> None:
-        name = basename(file)
-        # noinspection PyUnusedLocal
-        resp = self._bucket.put_object_from_file(
-            link, file, progress_callback=partial(
-                self._update_progress, f'uploading {name}'
-            )
-        )
-        print(':rpt', f'upload done [cyan]({name})[/]')
-    
-    def download(self, link: str, file: str) -> None:
-        name = basename(file)
-        # noinspection PyUnusedLocal
-        resp = self._bucket.get_object_to_file(
-            link, file, progress_callback=partial(
-                self._update_progress, f'downloading {name}'
-            )
-        )
-        print(':rpt', f'download done [cyan]({name})[/]')
-    
-    def delete(self, link: str) -> None:
-        name = basename(link)
-        self._bucket.delete_object(link)
-        print(':rpt', f'[dim]delete done [cyan]({name})[/][/]')
-
-
-class AliyunOssPath(BaseOssPath):
-    def __init__(self, appid: str):
-        super().__init__(appid)
-        self.root = f'apps/{appid}'
+from functools import partial
+from os.path import basename
+
+from ._base import BaseOss
+from ._base import BaseOssPath
+
+
+class AliyunOss(BaseOss):
+    type = 'aliyun'
+    
+    def __init__(
+        self,
+        appid: str,
+        access_key: str,
+        secret_key: str,
+        bucket_name: str,
+        endpoint: str,
+        **_
+    ):
+        # TODO: we are going to remove `oss2` dependency, instead, use \
+        #   `requests`.
+        #   oss2 requires pycryptodome, which has many problems in \
+        #   distributions.
+        from oss2 import Auth, Bucket
+        self.path = AliyunOssPath(appid)
+        self._auth = Auth(access_key, secret_key)
+        self._bucket = Bucket(self._auth, endpoint, bucket_name)
+    
+    @property
+    def bucket(self):
+        return self._bucket
+    
+    def make_link(self, key: str, expires=3600) -> str:
+        """ make link for sharing. """
+        return self._bucket.sign_url('GET', key, expires)
+    
+    def upload(self, file: str, link: str) -> None:
+        name = basename(file)
+        # noinspection PyUnusedLocal
+        resp = self._bucket.put_object_from_file(
+            link, file, progress_callback=partial(
+                self._update_progress, f'uploading {name}'
+            )
+        )
+        print(':rpt2', f'upload done [cyan]({name})[/]')
+    
+    def download(self, link: str, file: str) -> None:
+        name = basename(file)
+        # noinspection PyUnusedLocal
+        resp = self._bucket.get_object_to_file(
+            link, file, progress_callback=partial(
+                self._update_progress, f'downloading {name}'
+            )
+        )
+        print(':rpt2', f'download done [cyan]({name})[/]')
+    
+    def delete(self, link: str) -> None:
+        name = basename(link)
+        self._bucket.delete_object(link)
+        print(':rpt2', f'[dim]delete done [cyan]({name})[/][/]')
+
+
+class AliyunOssPath(BaseOssPath):
+    def __init__(self, appid: str):
+        super().__init__(appid)
+        self.root = f'apps/{appid}'
```

## depsland/oss/fake_oss.py

```diff
@@ -1,24 +1,24 @@
-from lk_utils import fs
-
-from .local_oss import LocalOss
-from .local_oss import LocalOssPath
-from .. import paths
-
-
-class FakeOss(LocalOss):
-    type_ = 'fake'
-    
-    # noinspection PyMissingConstructor
-    def __init__(self, appid: str, symlinks=False, **_):
-        self.path = FakeOssPath(appid)
-        self._symlinks = symlinks
-
-
-class FakeOssPath(LocalOssPath):
-    # noinspection PyMissingConstructor
-    def __init__(self, appid: str):
-        self.appid = appid
-        self.root = f'{paths.oss.test}/{appid}'
-        fs.make_dir(f'{self.root}')
-        fs.make_dir(f'{self.root}/assets')
-        fs.make_dir(f'{self.root}/pypi')
+from lk_utils import fs
+
+from .local_oss import LocalOss
+from .local_oss import LocalOssPath
+from .. import paths
+
+
+class FakeOss(LocalOss):
+    type = 'fake'
+    
+    # noinspection PyMissingConstructor
+    def __init__(self, appid: str, symlinks: bool = False, **_):
+        self.path = FakeOssPath(appid)
+        self._symlinks = symlinks
+
+
+class FakeOssPath(LocalOssPath):
+    # noinspection PyMissingConstructor
+    def __init__(self, appid: str):
+        self.appid = appid
+        self.root = f'{paths.oss.test}/{appid}'
+        fs.make_dir(f'{self.root}')
+        fs.make_dir(f'{self.root}/assets')
+        fs.make_dir(f'{self.root}/pypi')
```

## depsland/oss/get_oss.py

```diff
@@ -1,29 +1,31 @@
-import typing as t
-
-from .aliyun_oss import AliyunOss
-from .fake_oss import FakeOss
-from .local_oss import LocalOss
-from .. import config
-
-# ref: `..paths > Config > __init__ > the 'redirect' feature`
-#      `..config > T > AppSettings > AliyunOssConfig`
-oss_config = config.app_settings['oss']
-
-
-class T:
-    Oss = t.Union[AliyunOss, LocalOss, FakeOss]
-
-
-def get_oss(appid: str, server: str = oss_config['server']) -> T.Oss:
-    match server:
-        case 'aliyun':
-            config = oss_config['config']
-            assert all(config.values()), (
-                'the oss config is not filled. you may contact the author '
-                '(likianta <likianta@foxmail.com>) to get the access key.'
-            )
-            return AliyunOss(appid=appid, **config)
-        case 'local':
-            return LocalOss(appid=appid)
-        case 'fake':
-            return FakeOss(appid=appid)
+import typing as t
+
+from .aliyun_oss import AliyunOss
+from .fake_oss import FakeOss
+from .local_oss import LocalOss
+from .. import config
+
+# ref:
+#   `..paths : Config : __init__ : the 'redirect' feature`
+#   `..config : T : AppSettings : AliyunOssConfig`
+oss_config = config.app_settings['oss']
+
+
+class T:
+    Oss = t.Union[AliyunOss, LocalOss, FakeOss]
+
+
+def get_oss(appid: str, server: str = oss_config['server']) -> T.Oss:
+    if server == 'aliyun':
+        config = oss_config['config']
+        assert all(config.values()), (
+            'the oss config is not filled. you may contact the author '
+            '(likianta <likianta@foxmail.com>) to get the access key.'
+        )
+        return AliyunOss(appid=appid, **config)
+    elif server == 'local':
+        return LocalOss(appid=appid)
+    elif server == 'fake':
+        return FakeOss(appid=appid)
+    else:
+        raise Exception(f'unknown oss server: {server}')
```

## depsland/oss/local_oss.py

```diff
@@ -1,50 +1,50 @@
-import os
-
-from lk_utils import fs
-
-from ._base import BaseOss
-from ._base import BaseOssPath
-from .. import paths
-
-
-class LocalOss(BaseOss):
-    type_ = 'local'
-    
-    def __init__(self, appid: str, symlinks=False, **_):
-        self.path = LocalOssPath(appid)
-        self._symlinks = symlinks  # warning: this is experimental feature.
-        # self._copy = fs.make_link if symlinks else fs.copy_file
-    
-    def upload(self, file: str, link: str) -> None:
-        # the link is a local path from `self.path`.
-        name = fs.filename(file)
-        if self._symlinks:
-            fs.make_link(file, link, True)
-        else:
-            fs.copy_file(file, link, True)
-        print(':trp', f'upload done [cyan]({name})[/]')
-    
-    def download(self, link: str, file: str) -> None:
-        name = fs.filename(file)
-        if self._symlinks:
-            if os.path.realpath(link) == os.path.realpath(file):
-                pass
-            else:
-                fs.make_link(link, file, True)
-        else:
-            fs.copy_file(link, file, True)
-        print(':trp', f'download done [cyan]({name})[/]')
-    
-    def delete(self, link: str) -> None:
-        name = fs.filename(link)
-        fs.remove_file(link)
-        print(':trp', f'[dim]delete done [cyan]({name})[/][/]')
-
-
-class LocalOssPath(BaseOssPath):
-    def __init__(self, appid: str):
-        super().__init__(appid)
-        self.root = f'{paths.oss.apps}/{appid}'
-        fs.make_dir(f'{self.root}')
-        fs.make_dir(f'{self.root}/assets')
-        fs.make_dir(f'{self.root}/pypi')
+import os
+
+from lk_utils import fs
+
+from ._base import BaseOss
+from ._base import BaseOssPath
+from .. import paths
+
+
+class LocalOss(BaseOss):
+    type = 'local'
+    
+    def __init__(self, appid: str, symlinks: bool = False, **_):
+        self.path = LocalOssPath(appid)
+        self._symlinks = symlinks  # warning: this is experimental feature.
+        # self._copy = fs.make_link if symlinks else fs.copy_file
+    
+    def upload(self, file: str, link: str) -> None:
+        # the link is a local path from `self.path`.
+        name = fs.filename(file)
+        if self._symlinks:
+            fs.make_link(file, link, True)
+        else:
+            fs.copy_file(file, link, True)
+        print(':t2rp', f'upload done [cyan]({name})[/]')
+    
+    def download(self, link: str, file: str) -> None:
+        name = fs.filename(file)
+        if self._symlinks:
+            if os.path.realpath(link) == os.path.realpath(file):
+                pass
+            else:
+                fs.make_link(link, file, True)
+        else:
+            fs.copy_file(link, file, True)
+        print(':t2rp', f'download done [cyan]({name})[/]')
+    
+    def delete(self, link: str) -> None:
+        name = fs.filename(link)
+        fs.remove_file(link)
+        print(':t2rp', f'[dim]delete done [cyan]({name})[/][/]')
+
+
+class LocalOssPath(BaseOssPath):
+    def __init__(self, appid: str):
+        super().__init__(appid)
+        self.root = f'{paths.oss.apps}/{appid}'
+        fs.make_dir(f'{self.root}')
+        fs.make_dir(f'{self.root}/assets')
+        fs.make_dir(f'{self.root}/pypi')
```

## depsland/paths.py

```diff
@@ -1,260 +1,295 @@
-"""
-ref: ~/docs/project-structure.md
-
-environment variables:
-    DEPSLAND_CONFIG_PATH: redirect config root.
-    DEPSLAND_PYPI_PATH: redirect pypi root.
-"""
-import os
-import sys
-from collections import defaultdict
-from os.path import exists
-
-from lk_utils import dumps
-from lk_utils import fs
-
-__all__ = [
-    'apps',
-    'build',
-    'conf',
-    'oss',
-    'project',
-    'pypi',
-    'python',
-    'system',
-    'temp',
-]
-
-_env = {
-    'CONF_ROOT': os.getenv('DEPSLAND_CONFIG_PATH'),
-    'PYPI_ROOT': os.getenv('DEPSLAND_PYPI_PATH'),
-}
-
-
-class System:
-    
-    def __init__(self):
-        self.is_windows = os.name == 'nt'
-        if self.is_windows:
-            self.depsland = os.getenv('DEPSLAND')  # note it may be None
-            self.desktop = fs.normpath(os.environ['USERPROFILE'] + '/Desktop')
-            self.home = fs.normpath(os.environ['USERPROFILE'])
-            self.local_app_data = fs.normpath(os.environ['LOCALAPPDATA'])
-            self.start_menu = fs.normpath(
-                os.environ['APPDATA']
-                + '/Microsoft/Windows/Start Menu/Programs'
-            )
-            self.temp = fs.normpath(os.environ['TEMP'])
-        else:
-            pass  # TODO
-
-
-class Project:
-    
-    def __init__(self):
-        if exists(fs.xpath('../.depsland_project')):
-            self.root = fs.xpath('..', force_abspath=True)
-            self.is_project_mode = True
-        else:
-            self.root = fs.xpath('.project', True)
-            self.is_project_mode = False
-            if not exists(self.root):
-                print(':v2', 'first time run depsland, init a virtual '
-                             'project root...')
-                self._init_project_root(self.root)
-        
-        self.apps = f'{self.root}/apps'
-        self.build = f'{self.root}/build'
-        self.conf = f'{self.root}/conf'
-        self.depsland = f'{self.root}/depsland'
-        self.dist = f'{self.root}/dist'
-        self.manifest_json = f'{self.root}/manifest.json'
-        self.manifest_pkl = f'{self.root}/manifest.pkl'
-        self.oss = f'{self.root}/oss'
-        self.project = f'{self.root}'
-        self.pypi = f'{self.root}/pypi'
-        self.python = f'{self.root}/python'
-        self.temp = f'{self.root}/temp'
-    
-    @staticmethod
-    def _init_project_root(root: str):
-        """
-        related: build/backup_project_resources.py
-        """
-        os.mkdir(f'{root}')
-        os.mkdir(f'{root}/apps')
-        os.mkdir(f'{root}/apps/.bin')
-        os.mkdir(f'{root}/apps/.venv')
-        # os.mkdir(f'{root}/build')  # later
-        # os.mkdir(f'{root}/conf')  # later
-        os.mkdir(f'{root}/dist')
-        os.mkdir(f'{root}/oss')
-        os.mkdir(f'{root}/oss/apps')
-        os.mkdir(f'{root}/oss/test')
-        os.mkdir(f'{root}/pypi')
-        os.mkdir(f'{root}/pypi/cache')
-        os.mkdir(f'{root}/pypi/downloads')
-        os.mkdir(f'{root}/pypi/index')
-        os.mkdir(f'{root}/pypi/installed')
-        # os.mkdir(f'{root}/python')  # later
-        # os.mkdir(f'{root}/sidework')  # later
-        os.mkdir(f'{root}/temp')
-        os.mkdir(f'{root}/temp/.self_upgrade')
-        os.mkdir(f'{root}/temp/.unittests')
-        os.mkdir(f'{root}/unittests')
-        
-        # make link
-        fs.make_link(sys.base_exec_prefix, f'{root}/python')
-        
-        # unzip files
-        from .utils.ziptool import extract_file
-        extract_file(fs.xpath('chore/build.zip'), f'{root}/build')
-        extract_file(fs.xpath('chore/conf.zip'), f'{root}/conf')
-        extract_file(fs.xpath('chore/sidework.zip'), f'{root}/sidework')
-        
-        # init files
-        dumps(defaultdict(list), f'{root}/pypi/index/dependencies.pkl')
-        dumps(defaultdict(list), f'{root}/pypi/index/name_2_versions.pkl')
-        dumps({}, f'{root}/pypi/index/name_id_2_paths.pkl')
-        dumps({}, f'{root}/pypi/index/updates.pkl')
-
-
-# -----------------------------------------------------------------------------
-
-class Apps:
-    
-    def __init__(self):
-        self.root = f'{project.root}/apps'
-        self.bin = f'{self.root}/.bin'
-        self.venv = f'{self.root}/.venv'
-        self._distribution_history = f'{self.root}/{{appid}}/.dist_history'
-        self._installation_history = f'{self.root}/{{appid}}/.inst_history'
-        self._venv_packages = f'{self.root}/.venv/{{appid}}/{{version}}'
-        ''' the difference between `_distribution_history` and
-            `_installation_history`:
-            when developer builds or publishes a new version of an app, the
-            dist history will be updated, the inst doesn't.
-            when user installs a new version of an app, the vice versa.
-            this avoids that if a developer plays himself as role of an user,
-            published and installed the same app on the same machine, the
-            incremental-update scheme reported "target version exists" error.
-        '''
-    
-    def get_distribution_history(self, appid: str) -> str:
-        return self._distribution_history.format(appid=appid)
-    
-    def get_installation_history(self, appid: str) -> str:
-        return self._installation_history.format(appid=appid)
-    
-    def get_packages(self, appid: str, version: str) -> str:
-        return self._venv_packages.format(appid=appid, version=version)
-    
-    def make_packages(self, appid: str, version: str,
-                      clear_exists=False) -> str:
-        """
-        create or clear a folder for venv packages.
-        """
-        packages = self._venv_packages.format(appid=appid, version=version)
-        if exists(d := fs.dirpath(packages)):
-            if exists(packages):
-                if clear_exists:
-                    fs.remove_tree(packages)
-                    os.mkdir(packages)
-            else:
-                os.mkdir(packages)
-        else:
-            os.mkdir(d)
-            os.mkdir(packages)
-        return packages
-
-
-class Build:
-    
-    def __init__(self):
-        self.root = f'{project.root}/build'
-        self.launcher_ico = f'{self.root}/exe/launcher.ico'
-
-
-class Conf:
-    
-    def __init__(self):
-        if x := _env['CONF_ROOT']:
-            print(':r', f'[yellow dim]relocate config root to {x}[/]')
-            self.root = x
-        else:
-            self.root = f'{project.root}/conf'
-        
-        self.auto_saved = f'{self.root}/auto_saved.pkl'
-        self.depsland = f'{self.root}/depsland.yaml'
-        # self.oss_client = f'{self.root}/oss_client.yaml'
-        # self.oss_server = f'{self.root}/oss_server.yaml'
-
-
-class Oss:  # note: this is a local dir that mimics OSS structure.
-    
-    def __init__(self):
-        self.root = f'{project.root}/oss'
-        self.apps = f'{self.root}/apps'
-        self.test = f'{self.root}/test'
-
-
-class PyPI:
-    
-    def __init__(self):
-        if x := _env['PYPI_ROOT']:
-            print(':r', f'[yellow dim]relocate pypi root to {x}[/]')
-            self.root = x
-        else:
-            self.root = f'{project.root}/pypi'
-        
-        self.cache = f'{self.root}/cache'
-        self.downloads = f'{self.root}/downloads'
-        self.index = f'{self.root}/index'
-        self.installed = f'{self.root}/installed'
-        
-        self.dependencies = f'{self.root}/index/dependencies.pkl'
-        self.name_2_versions = f'{self.root}/index/name_2_versions.pkl'
-        self.name_id_2_paths = f'{self.root}/index/name_id_2_paths.pkl'
-        self.updates = f'{self.root}/index/updates.pkl'
-        
-        assert exists(self.dependencies)
-        assert exists(self.name_2_versions)
-        assert exists(self.name_id_2_paths)
-        assert exists(self.updates)
-
-
-class Python:
-    
-    def __init__(self):
-        if project.is_project_mode:
-            self.root = f'{project.root}/python'
-        else:
-            self.root = sys.base_exec_prefix
-        if system.is_windows:
-            self.pip = f'{self.root}/Scripts/pip.exe'
-            self.python = f'{self.root}/python.exe'
-            self.site_packages = f'{self.root}/Lib/site-packages'
-        else:
-            self.pip = f'{self.root}/bin/pip'
-            self.python = f'{self.root}/bin/python3.10'
-            self.site_packages = f'{self.root}/lib/python3.10/site-packages'
-
-
-class Temp:
-    
-    def __init__(self):
-        self.root = f'{project.root}/temp'
-        self.self_upgrade = f'{self.root}/.self_upgrade'
-        self.unittests = f'{self.root}/.unittests'
-
-
-system = System()
-project = Project()
-
-apps = Apps()
-build = Build()
-conf = Conf()
-oss = Oss()
-pypi = PyPI()
-python = Python()
-temp = Temp()
+"""
+ref: ~/docs/project-structure.md
+"""
+import os
+import sys
+from os.path import exists
+
+from lk_utils import dumps
+from lk_utils import fs
+
+__all__ = [
+    'apps',
+    'build',
+    'config',
+    'oss',
+    'project',
+    'pypi',
+    'python',
+    'system',
+    'temp',
+]
+
+
+class _Env:
+    CONFIG_ROOT = os.getenv('DEPSLAND_CONFIG_ROOT')
+    PYPI_ROOT = os.getenv('DEPSLAND_PYPI_ROOT')
+    PYTHON_STANDALONE = os.getenv('DEPSLAND_PYTHON_STANDALONE', '1')
+
+
+class System:
+    def __init__(self) -> None:
+        self.is_windows = os.name == 'nt'
+        if self.is_windows:
+            self.depsland = os.getenv('DEPSLAND')  # note this may be None
+            self.desktop = fs.normpath(os.environ['USERPROFILE'] + '/Desktop')
+            self.home = fs.normpath(os.environ['USERPROFILE'])
+            self.local_app_data = fs.normpath(os.environ['LOCALAPPDATA'])
+            self.start_menu = fs.normpath(
+                os.environ['APPDATA'] + '/Microsoft/Windows/Start Menu/Programs'
+            )
+            self.temp = fs.normpath(os.environ['TEMP'])
+        else:
+            pass  # TODO
+
+
+class Project:
+    def __init__(self) -> None:
+        if exists(fs.xpath('../.depsland_project')):
+            self.root = fs.xpath('..', force_abspath=True)
+            self.is_project_mode = True
+        else:
+            self.root = fs.xpath('.project', True)
+            self.is_project_mode = False
+            if not exists(self.root):
+                print(
+                    ':v2',
+                    'first time run depsland, init a virtual project root...',
+                )
+                self._init_project_root(self.root)
+        
+        self.apps = f'{self.root}/apps'
+        self.build = f'{self.root}/build'
+        self.config = f'{self.root}/config'
+        self.depsland = f'{self.root}/depsland'
+        self.dist = f'{self.root}/dist'
+        self.manifest_json = f'{self.root}/manifest.json'
+        self.manifest_pkl = f'{self.root}/manifest.pkl'
+        self.oss = f'{self.root}/oss'
+        self.project = f'{self.root}'
+        self.pypi = f'{self.root}/pypi'
+        self.python = f'{self.root}/python'
+        self.temp = f'{self.root}/temp'
+    
+    @staticmethod
+    def _init_project_root(root: str) -> None:
+        """
+        see: `build/build.py:backup_project_resources`
+        """
+        os.mkdir(f'{root}')
+        os.mkdir(f'{root}/apps')
+        os.mkdir(f'{root}/apps/.bin')
+        os.mkdir(f'{root}/apps/.venv')
+        # os.mkdir(f'{root}/build')  # later
+        # os.mkdir(f'{root}/config')  # later
+        os.mkdir(f'{root}/dist')
+        os.mkdir(f'{root}/oss')
+        os.mkdir(f'{root}/oss/apps')
+        os.mkdir(f'{root}/oss/test')
+        os.mkdir(f'{root}/pypi')
+        os.mkdir(f'{root}/pypi/cache')
+        os.mkdir(f'{root}/pypi/downloads')
+        os.mkdir(f'{root}/pypi/index')
+        os.mkdir(f'{root}/pypi/index/snapdep')
+        os.mkdir(f'{root}/pypi/installed')
+        # os.mkdir(f'{root}/python')  # later
+        # os.mkdir(f'{root}/sidework')  # later
+        os.mkdir(f'{root}/temp')
+        os.mkdir(f'{root}/temp/.self_upgrade')
+        os.mkdir(f'{root}/temp/.unittests')
+        # os.mkdir(f'{root}/unittests')
+        
+        # make link
+        fs.make_link(sys.base_exec_prefix, f'{root}/python')
+        
+        # unzip files
+        from .utils.ziptool import extract_file
+        
+        extract_file(fs.xpath('chore/build.zip'), f'{root}/build')
+        extract_file(fs.xpath('chore/config.zip'), f'{root}/config')
+        extract_file(fs.xpath('chore/sidework.zip'), f'{root}/sidework')
+        
+        # init files
+        dumps({}, f'{root}/pypi/index/id_2_paths.json')
+        dumps({}, f'{root}/pypi/index/name_2_vers.json')
+
+
+# -----------------------------------------------------------------------------
+
+
+class Apps:
+    def __init__(self) -> None:
+        self.root = f'{project.root}/apps'
+        self.bin = f'{self.root}/.bin'
+        self.venv = f'{self.root}/.venv'
+        self._distribution_history = f'{self.root}/{{appid}}/.dist_history'
+        self._installation_history = f'{self.root}/{{appid}}/.inst_history'
+        self._venv_packages = f'{self.root}/.venv/{{appid}}/{{version}}'
+        ''' the difference between `_distribution_history` and
+            `_installation_history`:
+            when developer builds or publishes a new version of an app, the
+            dist history will be updated, the inst doesn't.
+            when user installs a new version of an app, the vice versa.
+            this avoids that if a developer plays himself as role of an user,
+            published and installed the same app on the same machine, the
+            incremental-update scheme reported "target version exists" error.
+        '''
+    
+    def get_distribution_history(self, appid: str) -> str:
+        return self._distribution_history.format(appid=appid)
+    
+    def get_installation_history(self, appid: str) -> str:
+        return self._installation_history.format(appid=appid)
+    
+    def get_packages(self, appid: str, version: str) -> str:
+        return self._venv_packages.format(appid=appid, version=version)
+    
+    def make_packages(
+        self, appid: str, version: str, clear_exists: bool = False
+    ) -> str:
+        """
+        create or clear a folder for venv packages.
+        """
+        packages = self._venv_packages.format(appid=appid, version=version)
+        if exists(d := fs.dirpath(packages)):
+            if exists(packages):
+                if clear_exists:
+                    fs.remove_tree(packages)
+                    os.mkdir(packages)
+            else:
+                os.mkdir(packages)
+        else:
+            os.mkdir(d)
+            os.mkdir(packages)
+        return packages
+
+
+class Build:
+    def __init__(self) -> None:
+        self.root = f'{project.root}/build'
+        self.icon = f'{self.root}/icon'  # the folder
+        if sys.platform == 'darwin':
+            self.launcher_icon = f'{self.root}/icon/launcher.icns'
+        elif sys.platform == 'linux':
+            self.launcher_icon = f'{self.root}/icon/launcher.png'
+        elif sys.platform == 'win32':
+            self.launcher_icon = f'{self.root}/icon/launcher.ico'
+        else:
+            raise Exception(sys.platform)
+
+
+class Config:
+    """
+    redirect config:
+        there are two ways to redirect config root:
+            1. the dynamic way:
+                by setting environment variable `DEPSLAND_CONFIG_ROOT`
+            2. the static way:
+                put a file '.redirect' in `config` folder. the file content is \
+                a relative or absolute path points to the new config root.
+        the dynamic is prior to the static.
+    """
+    
+    def __init__(self) -> None:
+        if x := _Env.CONFIG_ROOT:
+            self.root = fs.abspath(x)
+            print(':r', f'[yellow dim]relocate config root to {self.root}[/]')
+        elif exists(f'{project.root}/config/.redirect'):
+            with open(f'{project.root}/config/.redirect', 'r') as f:
+                x = f.read().strip()
+                if os.path.isabs(x):
+                    self.root = fs.normpath(x)
+                else:  # e.g. '../tests/config'
+                    self.root = fs.normpath(f'{project.root}/config/{x}')
+            print(':r', f'[yellow dim]relocate config root to {self.root}[/]')
+        else:
+            self.root = f'{project.root}/config'
+        
+        self.auto_saved = f'{self.root}/auto_saved.pkl'
+        self.depsland = f'{self.root}/depsland.yaml'
+        # self.oss_client = f'{self.root}/oss_client.yaml'
+        # self.oss_server = f'{self.root}/oss_server.yaml'
+
+
+class Oss:  # note: this is a local dir that mimics OSS structure.
+    def __init__(self) -> None:
+        self.root = f'{project.root}/oss'
+        self.apps = f'{self.root}/apps'
+        self.test = f'{self.root}/test'
+
+
+class PyPI:
+    """
+    to redirect pypi root, use environment variable 'DEPSLAND_PYPI_ROOT'.
+    see also: `build/init.py`
+    """
+    
+    def __init__(self) -> None:
+        if x := _Env.PYPI_ROOT:
+            print(':r', f'[yellow dim]relocate pypi root to "{x}"[/]')
+            self.root = fs.abspath(x)
+        else:
+            self.root = f'{project.root}/pypi'
+        self.is_symlink = fs.islink(self.root)
+        self.real_root = (
+            fs.normpath(os.path.realpath(self.root))
+            if self.is_symlink else self.root
+        )
+        
+        self.cache = f'{self.root}/cache'
+        self.downloads = f'{self.root}/downloads'
+        self.index = f'{self.root}/index'
+        self.installed = f'{self.root}/installed'
+        
+        self.id_2_paths = f'{self.index}/id_2_paths.json'
+        self.name_2_vers = f'{self.index}/name_2_vers.json'
+        self.snapdep = f'{self.index}/snapdep'
+
+
+class Python:
+    def __init__(self) -> None:
+        if project.is_project_mode and _Env.PYTHON_STANDALONE == '1':
+            self.root = f'{project.root}/python'
+            assert len(os.listdir(self.root)) > 3, (
+                'cannot find standalone python interpreter. \n'
+                'if you want to setup one, please follow the instruction of '
+                '`{}/python/README.zh.md`; \n'
+                'if you do not want to setup, you can set the environment '
+                'variable `DEPSLAND_PYTHON_STANDALONE` to "0"'.format(
+                    project.root
+                )
+            )
+        else:
+            self.root = fs.normpath(sys.base_exec_prefix)
+        if system.is_windows:
+            self.pip = f'{self.root}/Scripts/pip.exe'
+            self.python = f'{self.root}/python.exe'
+            self.site_packages = f'{self.root}/Lib/site-packages'
+        else:
+            self.pip = f'{self.root}/bin/pip'
+            self.python = f'{self.root}/bin/python3'
+            if self.root.startswith(f'{project.root}/python'):
+                self.site_packages = f'{self.root}/lib/python3.11/site-packages'
+            else:
+                self.site_packages = '{}/lib/python{}.{}/site-packages'.format(
+                    self.root, *sys.version_info[:2]
+                )
+
+
+class Temp:
+    def __init__(self) -> None:
+        self.root = f'{project.root}/temp'
+        self.self_upgrade = f'{self.root}/.self_upgrade'
+        self.unittests = f'{self.root}/.unittests'
+
+
+system = System()
+project = Project()
+
+apps = Apps()
+build = Build()
+config = Config()
+oss = Oss()
+pypi = PyPI()
+python = Python()
+temp = Temp()
```

## depsland/pip.py

```diff
@@ -1,275 +1,246 @@
-"""
-a wrapper for pip command.
-"""
-import re
-import typing as t
-from contextlib import contextmanager
-from multiprocessing import Pool
-
-from lk_utils.filesniff import normpath
-from lk_utils.subproc import compose_cmd
-from lk_utils.subproc import run_cmd_args
-from yaml import safe_load as yaml_safe_load
-
-from . import paths
-from .config import app_settings
-
-
-class T:
-    PipExecute = t.Tuple[str, ...]  # e.g. ('python3', '-m', 'pip')
-    Pool = t.Optional[Pool]
-    PopenArgs = t.Iterable[str]
-
-
-class Pip:
-    _multi_proc: T.Pool
-    _pip_exec: T.PipExecute
-    _template: 'CommandTemplate'
-    
-    def __init__(
-            self,
-            pip_exec: T.PipExecute,
-            pip_conf=app_settings['pip'],
-            local=paths.pypi.downloads,
-    ):
-        self._multi_proc = None
-        self._pip_exec = pip_exec
-        self._template = CommandTemplate(pip_exec, local, **pip_conf)
-    
-    def update_pip_options(self, **options) -> None:
-        # noinspection PyArgumentList
-        self._template = CommandTemplate(self._pip_exec, **options)
-    
-    @contextmanager
-    def multi_processing(self) -> t.Iterator[None]:
-        self.enable_multi_processing()
-        yield
-        self.join_multi_processing()
-    
-    def enable_multi_processing(self) -> None:
-        assert self._multi_proc is None
-        # self._multi_proc = Pool()  # FIXME: temporarily disabled
-    
-    def join_multi_processing(self) -> None:
-        if self._multi_proc:
-            self._multi_proc.close()
-            self._multi_proc.join()
-            self._multi_proc = None
-        print(':t', 'all processes joined.')
-    
-    def run(self, *args: t.Union[str, t.Tuple[str, ...]]) -> str:
-        args = compose_cmd(*args)
-        return self._run(*self._pip_exec, *args)
-    
-    @staticmethod
-    def _run(*args: str) -> str:
-        """
-        both print and return the command line output.
-        """
-        print(':r', '[magenta dim]{}[/]'
-              .format(' '.join(args).replace('[', '\\[')))
-        return run_cmd_args(*args, verbose=True, ignore_error=False)
-    
-    # -------------------------------------------------------------------------
-    
-    def test(self) -> None:
-        self._run(*self._pip_exec, '--version')
-    
-    def pip_version(self) -> str:
-        r = self._run(*self._pip_exec, '--version')
-        return r.split(' ', 2)[1]
-        #   ['pip', '22.3', 'from ...'] -> '22.3'
-    
-    def download(
-            self, name: str, version='',
-            dest=paths.pypi.downloads, no_deps=False
-    ) -> str:
-        if self._multi_proc:
-            self._multi_proc.apply_async(
-                self._run,
-                self._template.pip_download(name, version, dest, no_deps)
-            )
-            return ''
-        return self._run(
-            *self._template.pip_download(name, version, dest, no_deps)
-        )
-    
-    def download_r(self, file: str, dest=paths.pypi.downloads) -> str:
-        return self._run(*self._template.pip_download_r(file, dest))
-    
-    def install(
-            self, name: str, version='',
-            dest=paths.pypi.installed, no_deps=False
-    ) -> str:
-        if self._multi_proc:
-            self._multi_proc.apply_async(
-                self._run,
-                self._template.pip_install(name, version, dest, no_deps)
-            )
-            return ''
-        return self._run(
-            *self._template.pip_install(name, version, dest, no_deps)
-        )
-    
-    def install_r(self, file: str, dest=paths.pypi.installed) -> str:
-        return self._run(*self._template.pip_install_r(file, dest))
-    
-    # -------------------------------------------------------------------------
-    
-    def show_dependencies(self, name: str) -> t.List[str]:
-        resp = self._run(*self._template.pip_show(name))
-        #   it can be considered as a YAML string.
-        data: dict = yaml_safe_load(resp)
-        if data['Requires']:
-            return data['Requires'].split(', ')
-            #   e.g. {'Requires': 'xlrd, lk-logger, xlsxwriter', ...} ->
-            #       ['xlrd', 'lk-logger', 'xlsxwriter']
-        else:
-            return []
-    
-    def show_locations(self, name: str) -> t.Set[str]:
-        resp = self._run(*self._template.pip_show_f(name))
-        r''' e.g.
-            Name: lk-logger
-            Version: 3.6.3
-            Summary: Advanced logger with source code lineno indicator.
-            Home-page:
-            Author: Likianta
-            Author-email: likianta@foxmail.com
-            License: MIT
-            Location: e:\programs\python\python39\lib\site-packages
-            Requires:
-            Required-by: pyportable-installer, lk-utils, lk-qtquick-scaffold
-            Files:
-              lk_logger-3.6.3.dist-info\INSTALLER
-              lk_logger-3.6.3.dist-info\METADATA
-              lk_logger-3.6.3.dist-info\RECORD
-              lk_logger-3.6.3.dist-info\REQUESTED
-              lk_logger-3.6.3.dist-info\WHEEL
-              lk_logger\__init__.py
-              lk_logger\__pycache__\__init__.cpython-39.pyc
-              lk_logger\__pycache__\lk_logger.cpython-39.pyc
-              lk_logger\lk_logger.py
-        '''
-        resp = resp.replace('  ', '  - ')
-        data: dict = yaml_safe_load(resp)
-        #   {'Name': 'lk-logger', ... 'Files': [...]}
-        
-        # analyse files root dirs
-        out = set()
-        for f in data['Files'].split('\n'):
-            if f == '':
-                continue
-            if f.startswith('.'):
-                #   e.g. '..\..\Scripts\vba_extract.py'
-                assert f.startswith('..\\..\\Scripts\\')
-                out.add('../../Scripts/{}'.format(
-                    normpath(f[14:]).split('/', 1)[0]
-                ))
-            else:
-                out.add(normpath(f).split('/', 1)[0])
-        return out
-
-
-class CommandTemplate:
-    
-    def __init__(
-            self,
-            pip_cmd: T.PipExecute,
-            local_dir: str = paths.pypi.downloads,
-            cache_dir: str = paths.pypi.cache,
-            *,
-            index_url: str = 'https://pypi.python.org/simple/',
-            local_first: bool = False,  # TODO
-            offline: bool = False,
-            quiet: bool = False,
-            **_,
-    ):
-        # extend parameters
-        if offline:
-            host = ''
-            local_first = True
-        else:
-            assert index_url
-            host = re.search(r'https?://([^/]+)', index_url).group(1)
-        # if local_first:
-        #     url_indexes = (local_dir, index_url)
-        # else:
-        #     url_indexes = (index_url, local_dir)
-        
-        self._pip = pip_cmd
-        
-        self._pip_options = tuple(compose_cmd(
-            f'--cache-dir', cache_dir,
-            f'--disable-pip-version-check',
-            f'--no-python-version-warning',
-            f'--quiet' if quiet else '',
-            ('--trusted-host', host)
-        ))
-        self._pip_options_2 = tuple(compose_cmd(
-            f'--disable-pip-version-check',
-            f'--quiet' if quiet else '',
-        ))
-        
-        self._pip_download_options = tuple(compose_cmd(
-            f'--no-index' if offline else '',
-            # f'--only-binary=:all:',
-            ('--find-links', local_dir),
-            ('--index-url', index_url),
-            # ('--index-url', url_indexes[0]),
-            # ('--extra-index-url', url_indexes[1]),
-        ))
-        self._pip_install_options = (
-            *self._pip_download_options,
-            '--no-warn-script-location',
-        )
-    
-    # -------------------------------------------------------------------------
-    
-    def pip_download(
-            self, name: str, version='', dest='', no_deps=False
-    ) -> T.PopenArgs:
-        return compose_cmd(
-            *self._pip, 'download', f'{name}{version.replace(" ", "")}',
-            ('-d', dest), ('--no-deps' if no_deps else ''),
-            *self._pip_options, *self._pip_download_options
-        )
-    
-    def pip_download_r(self, file: str, dest: str = '') -> T.PopenArgs:
-        return compose_cmd(
-            *self._pip, 'download', '-r', file, ('-d', dest),
-            *self._pip_options, *self._pip_download_options
-        )
-    
-    def pip_install(
-            self, name: str, version='', dest='', no_deps=False
-    ) -> T.PopenArgs:
-        return compose_cmd(
-            *self._pip, 'install', f'{name}{version.replace(" ", "")}',
-            ('-t', dest), ('--no-deps' if no_deps else ''),
-            *self._pip_options, *self._pip_install_options
-        )
-    
-    def pip_install_r(self, file: str, dest: str = '') -> T.PopenArgs:
-        return compose_cmd(
-            *self._pip, 'install', '-r', file, ('-t', dest),
-            *self._pip_options, *self._pip_install_options
-        )
-    
-    def pip_show(self, name: str) -> T.PopenArgs:
-        return compose_cmd(
-            *self._pip, 'show', name,
-            *self._pip_options_2
-        )
-    
-    def pip_show_f(self, name: str) -> T.PopenArgs:
-        return compose_cmd(
-            *self._pip, 'show', name, '-f',
-            *self._pip_options_2
-        )
-
-
-pip = Pip(
-    pip_exec=(paths.python.python, '-m', 'pip'),
-    local=paths.pypi.downloads,
-)
+"""
+a wrapper for pip command.
+"""
+import re
+import sys
+import typing as t
+
+from lk_utils.filesniff import normpath
+from lk_utils.subproc import compose_cmd
+from lk_utils.subproc import run_cmd_args
+from yaml import safe_load as yaml_safe_load
+
+from . import paths
+from .config import app_settings
+
+
+class T:
+    PipExecute = t.Tuple[str, ...]  # e.g. ('python3', '-m', 'pip')
+    PopenArgs = t.Iterable[str]
+
+
+class Pip:
+    _pip_exec: T.PipExecute
+    _template: 'CommandTemplate'
+    
+    def __init__(
+        self,
+        pip_exec: T.PipExecute = (sys.executable, '-m', 'pip'),
+        pip_conf: dict = app_settings['pip'],
+        local: str = paths.pypi.downloads,
+    ):
+        self._pip_exec = pip_exec
+        self._template = CommandTemplate(pip_exec, local, **pip_conf)
+    
+    def update_pip_options(self, **options) -> None:
+        # noinspection PyArgumentList
+        self._template = CommandTemplate(self._pip_exec, **options)
+    
+    def run(self, *args: t.Union[str, t.Tuple[str, ...]]) -> str:
+        args = compose_cmd(*args)
+        return self._run(*self._pip_exec, *args)
+    
+    @staticmethod
+    def _run(*args: str) -> str:
+        """
+        both print and return the command line output.
+        """
+        return run_cmd_args(*args, verbose=True, ignore_error=False)
+    
+    # -------------------------------------------------------------------------
+    
+    def test(self) -> None:
+        self._run(*self._pip_exec, '--version')
+    
+    def pip_version(self) -> str:
+        r = self._run(*self._pip_exec, '--version')
+        return r.split(' ', 2)[1]
+        #   ['pip', '22.3', 'from ...'] -> '22.3'
+    
+    def download(
+        self,
+        name: str,
+        version: str = '',
+        destination: str = paths.pypi.downloads,
+        no_dependency: bool = False,
+        custom_args: t.Sequence[str] = (),
+    ) -> str:
+        return self._run(
+            *self._template.pip_download(
+                name, version, destination, no_dependency
+            ),
+            *(custom_args and compose_cmd(*custom_args))
+        )
+    
+    def download_r(self, file: str, dest: str = paths.pypi.downloads) -> str:
+        return self._run(*self._template.pip_download_r(file, dest))
+    
+    def install(
+        self, name: str, version='',
+        dest=paths.pypi.installed, no_deps=False
+    ) -> str:
+        return self._run(
+            *self._template.pip_install(name, version, dest, no_deps)
+        )
+    
+    def install_r(self, file: str, dest=paths.pypi.installed) -> str:
+        return self._run(*self._template.pip_install_r(file, dest))
+    
+    # -------------------------------------------------------------------------
+    
+    def show_dependencies(self, name: str) -> t.List[str]:
+        resp = self._run(*self._template.pip_show(name))
+        #   it can be considered as a YAML string.
+        data: dict = yaml_safe_load(resp)
+        if data['Requires']:
+            return data['Requires'].split(', ')
+            #   e.g. {'Requires': 'xlrd, lk-logger, xlsxwriter', ...} ->
+            #       ['xlrd', 'lk-logger', 'xlsxwriter']
+        else:
+            return []
+    
+    def show_locations(self, name: str) -> t.Set[str]:
+        resp = self._run(*self._template.pip_show_f(name))
+        r''' e.g.
+            Name: lk-logger
+            Version: 3.6.3
+            Summary: Advanced logger with source code lineno indicator.
+            Home-page:
+            Author: Likianta
+            Author-email: likianta@foxmail.com
+            License: MIT
+            Location: e:\programs\python\python39\lib\site-packages
+            Requires:
+            Required-by: pyportable-installer, lk-utils, lk-qtquick-scaffold
+            Files:
+              lk_logger-3.6.3.dist-info\INSTALLER
+              lk_logger-3.6.3.dist-info\METADATA
+              lk_logger-3.6.3.dist-info\RECORD
+              lk_logger-3.6.3.dist-info\REQUESTED
+              lk_logger-3.6.3.dist-info\WHEEL
+              lk_logger\__init__.py
+              lk_logger\__pycache__\__init__.cpython-39.pyc
+              lk_logger\__pycache__\lk_logger.cpython-39.pyc
+              lk_logger\lk_logger.py
+        '''
+        resp = resp.replace('  ', '  - ')
+        data: dict = yaml_safe_load(resp)
+        #   {'Name': 'lk-logger', ... 'Files': [...]}
+        
+        # analyse files root dirs
+        out = set()
+        for f in data['Files'].split('\n'):
+            if f == '':
+                continue
+            if f.startswith('.'):
+                #   e.g. '..\..\Scripts\vba_extract.py'
+                assert f.startswith('..\\..\\Scripts\\')
+                out.add('../../Scripts/{}'.format(
+                    normpath(f[14:]).split('/', 1)[0]
+                ))
+            else:
+                out.add(normpath(f).split('/', 1)[0])
+        return out
+
+
+class CommandTemplate:
+    
+    def __init__(
+        self,
+        pip_cmd: T.PipExecute,
+        local_dir: str = paths.pypi.downloads,
+        cache_dir: str = paths.pypi.cache,
+        *,
+        index_url: str = 'https://pypi.python.org/simple/',
+        # local_first: bool = False,  # TODO
+        offline: bool = False,
+        quiet: bool = False,
+        **_,
+    ):
+        # extend parameters
+        if offline:
+            host = ''
+        else:
+            assert index_url
+            host = re.search(r'https?://([^/]+)', index_url).group(1)
+        # if local_first:
+        #     url_indexes = (local_dir, index_url)
+        # else:
+        #     url_indexes = (index_url, local_dir)
+        
+        self._pip = pip_cmd
+        
+        self._pip_options = tuple(compose_cmd(
+            f'--cache-dir', cache_dir,
+            f'--disable-pip-version-check',
+            f'--no-python-version-warning',
+            f'--quiet' if quiet else '',
+            ('--trusted-host', host)
+        ))
+        self._pip_options_2 = tuple(compose_cmd(
+            f'--disable-pip-version-check',
+            f'--quiet' if quiet else '',
+        ))
+        
+        self._pip_download_options = tuple(compose_cmd(
+            f'--no-index' if offline else '',
+            # f'--only-binary=:all:',
+            ('--find-links', local_dir),
+            ('--index-url', index_url),
+            # ('--index-url', url_indexes[0]),
+            # ('--extra-index-url', url_indexes[1]),
+        ))
+        self._pip_install_options = (
+            *self._pip_download_options,
+            '--no-warn-script-location',
+        )
+    
+    # -------------------------------------------------------------------------
+    
+    def pip_download(
+        self, name: str, version='', dest='', no_deps=False
+    ) -> T.PopenArgs:
+        return compose_cmd(
+            *self._pip, 'download', f'{name}{version.replace(" ", "")}',
+            ('-d', dest), ('--no-deps' if no_deps else ''),
+            *self._pip_options, *self._pip_download_options
+        )
+    
+    def pip_download_r(self, file: str, dest: str = '') -> T.PopenArgs:
+        return compose_cmd(
+            *self._pip, 'download', '-r', file, ('-d', dest),
+            *self._pip_options, *self._pip_download_options
+        )
+    
+    def pip_install(
+        self, name: str, version='', dest='', no_deps=False
+    ) -> T.PopenArgs:
+        return compose_cmd(
+            *self._pip, 'install', f'{name}{version.replace(" ", "")}',
+            ('-t', dest), ('--no-deps' if no_deps else ''),
+            *self._pip_options, *self._pip_install_options
+        )
+    
+    def pip_install_r(self, file: str, dest: str = '') -> T.PopenArgs:
+        return compose_cmd(
+            *self._pip, 'install', '-r', file, ('-t', dest),
+            *self._pip_options, *self._pip_install_options
+        )
+    
+    def pip_show(self, name: str) -> T.PopenArgs:
+        return compose_cmd(
+            *self._pip, 'show', name,
+            *self._pip_options_2
+        )
+    
+    def pip_show_f(self, name: str) -> T.PopenArgs:
+        return compose_cmd(
+            *self._pip, 'show', name, '-f',
+            *self._pip_options_2
+        )
+
+
+pip = Pip(
+    pip_exec=(paths.python.python, '-m', 'pip'),
+    local=paths.pypi.downloads,
+)
```

## depsland/pypi/__init__.py

```diff
@@ -1,4 +1,4 @@
-from . import insight
-from .insight import rebuild_index
-from .pypi import T
-from .pypi import pypi
+from . import insight
+from .insight import rebuild_index as rebuild_pypi_index
+from .pypi import T
+from .pypi import pypi
```

## depsland/pypi/index.py

```diff
@@ -1,62 +1,129 @@
-import typing as t
-from collections import defaultdict
-
-from lk_utils import dumps
-from lk_utils import loads
-
-from ..normalization import T as T0
-from ..paths import pypi as pypi_paths
-
-
-class T:
-    Name = T0.Name
-    NameId = str  # f'{Name}-{FixedVersion}'
-    Path = str
-    Version = T0.Version
-    
-    # indexes
-    Dependencies = t.Dict[NameId, t.TypedDict('Dependencies', {
-        'resolved'  : t.List[NameId],
-        'unresolved': t.Dict[Name, t.Tuple[T0.VersionSpec, ...]],
-        #   see also `./insight.py : def _analyse_metadata_1()`
-    })]
-    Name2Versions = t.Dict[Name, t.List[Version]]
-    #   t.List[...]: a sorted versions list, from new to old.
-    NameId2Paths = t.Dict[Version, t.Tuple[Path, Path]]
-    #   t.List[...]: tuple[downloaded_path, installed_path]
-    #       notice: the paths are relative to `paths.pypi.root`
-    #       why do we use relative paths?
-    #       based on the experience of debugging depsland (in project mode),
-    #       the abspath is not convenience for symbolic links.
-    Updates = t.Dict[Name, int]
-
-
-class Index:
-    name_2_versions: T.Name2Versions
-    name_id_2_paths: T.NameId2Paths
-    dependencies: T.Dependencies
-    updates: T.Updates
-    # # update_freq = 60 * 60 * 24 * 7  # one week
-    update_freq = -1
-    
-    def __init__(self):
-        self._load_index()
-        # atexit.register(self.save_index)
-    
-    def _load_index(self) -> None:
-        self.name_2_versions = loads(pypi_paths.name_2_versions)
-        self.name_id_2_paths = loads(pypi_paths.name_id_2_paths)
-        self.dependencies = defaultdict(self._dependency_item_gen)
-        #   note: do not use lambda here, because it will be pickled.
-        self.dependencies.update(loads(pypi_paths.dependencies))
-        self.updates = loads(pypi_paths.updates)
-    
-    @staticmethod
-    def _dependency_item_gen() -> dict:
-        return {'resolved': [], 'unresolved': {}}
-    
-    def save_index(self) -> None:
-        dumps(self.name_2_versions, pypi_paths.name_2_versions)
-        dumps(self.name_id_2_paths, pypi_paths.name_id_2_paths)
-        dumps(self.dependencies, pypi_paths.dependencies)
-        dumps(self.updates, pypi_paths.updates)
+import atexit
+import typing as t
+from collections import defaultdict
+
+from lk_utils import dumps
+from lk_utils import fs
+from lk_utils import loads
+
+from ..depsolver import T as T0
+from ..normalization import split_filename_of_package
+from ..paths import pypi as pypi_paths
+from ..verspec import sort_versions
+
+_root = pypi_paths.root
+
+
+class T(T0):
+    AbsPath = RelPath = str
+    #   relative to `paths.pypi.root`
+    Id2Paths = t.Dict[T0.PackageId, t.Tuple[RelPath, RelPath]]
+    #   {package_id: (download_path, install_path), ...}
+    Name2Versions = t.Dict[T0.PackageName, t.List[T0.ExactVersion]]
+    #   versions are sorted in descending order (from new to old).
+
+
+class Index:
+    id_2_paths: T.Id2Paths
+    name_2_vers: T.Name2Versions
+    _changed: t.Set[T.PackageName]
+    _stash_downloads: t.Dict[T0.PackageId, T.AbsPath]
+    
+    def __init__(self) -> None:
+        self.load_index()
+        self._changed = set()
+        self._stash_downloads = {}
+        atexit.register(self.save_index)
+    
+    # def __contains__(self, item: t.Union[T.PackageName, T.PackageId]) -> bool:
+    #     return item in self.name_2_ids or item in self.id_2_paths
+    
+    # def __contains__(self, item: T.PackageId) -> bool:
+    #     return item in self.id_2_paths
+    
+    def __getitem__(self, id: T.PackageId) -> t.Tuple[T.AbsPath, T.AbsPath]:
+        a, b = self.id_2_paths[id]
+        return f'{_root}/{a}', f'{_root}/{b}'
+    
+    def has_name(self, item: T.PackageName) -> bool:
+        return item in self.name_2_vers
+    
+    def has_id(self, item: T.PackageId) -> bool:
+        return item in self.id_2_paths
+    
+    def load_index(self) -> None:
+        """
+        the initial files were generated by `build/self_build.py:init_pypi_index`
+        """
+        self.id_2_paths = loads(pypi_paths.id_2_paths)
+        # self.id_2_paths = {
+        #   k: tuple(v) for k, v in loads(pypi_paths.id_2_paths).items()}
+        self.name_2_vers = defaultdict(list)
+        self.name_2_vers.update(loads(pypi_paths.name_2_vers))
+    
+    def add_to_index(self, path: T.AbsPath, type: int) -> None:
+        if type == 0:
+            name, ver = split_filename_of_package(fs.basename(path))
+            # print('stash download', f'{name}-{ver}', ':vp')
+            self._stash_downloads[f'{name}-{ver}'] = path
+        else:
+            _, name, ver = path.rsplit('/', 2)
+            try:
+                # print('retrieve download', f'{name}-{ver}', ':vp')
+                dl_path = self._stash_downloads.pop(f'{name}-{ver}')
+            except KeyError:
+                print(f'{name}-{ver}', self._stash_downloads, ':lv4')
+                exit(1)
+            self.update_index(f'{name}-{ver}', dl_path, path)
+    
+    def update_index(
+        self,
+        pkg_id: T.PackageId,
+        dl_path: T.AbsPath,
+        ins_path: T.AbsPath,
+        force: bool = False,
+    ) -> None:
+        if pkg_id in self.id_2_paths and not force:
+            return
+        assert (
+            dl_path.lower().startswith(pypi_paths.downloads.lower())
+            #   why use `lower`: the `internal_path` was from pip downloading \
+            #   process. in windows its case is not stable.
+            #   for examples:
+            #       'c:\myname\projects\depsland\pypi\...'
+            #       'C:\MyName\projects\depsland\pypi\...'
+            and fs.isfile(dl_path)
+        )
+        assert (
+            ins_path.startswith(pypi_paths.installed)
+            #   we no need to use `lower` here because the `internal_path` was \
+            #   generated by `self.get_install_path`, which is stable.
+            and fs.isdir(ins_path)
+        )
+        self.id_2_paths[pkg_id] = (
+            fs.relpath(dl_path, _root),
+            fs.relpath(ins_path, _root),
+        )
+        name, ver = pkg_id.split('-', 1)
+        self.name_2_vers[name].append(ver)
+        self._changed.add(name)
+    
+    def save_index(self) -> None:
+        if self._stash_downloads:
+            print(self._stash_downloads, ':lv3')
+            print(
+                'there were {} packages downloaded but not installed'
+                .format(len(self._stash_downloads)),
+                'you can use `sidework/pypi_index.py:rebuild` to fix the '
+                'indexes',
+                ':v3'
+            )
+        if self._changed:
+            for name in self._changed:
+                print('refresh versions stack', name, ':i2vs')
+                vers = self.name_2_vers[name]
+                sort_versions(vers, reverse=True)
+            dumps(self.id_2_paths, pypi_paths.id_2_paths)
+            dumps(self.name_2_vers, pypi_paths.name_2_vers)
+            self._changed.clear()
+            print('saved pypi indexes')
```

## depsland/pypi/insight.py

```diff
@@ -1,334 +1,305 @@
-import os
-import re
-import typing as t
-from collections import defaultdict
-
-from lk_utils import dumps
-from lk_utils import fs
-from lk_utils import loads
-from lk_utils.read_and_write import ropen
-
-from .pypi import T as T0
-from .pypi import pypi
-from .. import normalization as norm
-from ..paths import pypi as pypi_paths
-from ..pip import pip
-from ..utils import get_updated_time
-from ..utils import verspec
-
-
-class T(T0):
-    PackagesSize = t.NamedTuple('PackagesSize', (
-        ('downloaded', t.Dict[str, int]),
-        ('installed', t.Dict[str, int]),
-    ))
-
-
-def overview(dir_i: str = None) -> None:
-    if dir_i:
-        print(loads(f'{dir_i}/name_2_versions.pkl'), ':ls')
-        print(loads(f'{dir_i}/name_id_2_paths.pkl'), ':ls')
-        print(loads(f'{dir_i}/dependencies.pkl'), ':ls')
-        print(loads(f'{dir_i}/updates.pkl'), ':ls')
-    else:
-        print(pypi.name_2_versions, ':l')
-        print(pypi.name_id_2_paths, ':l')
-        print(pypi.dependencies, ':l')
-        print(pypi.updates, ':l')
-
-
-def rebuild_index(perform_pip_install: bool = False) -> None:
-    name_2_versions: T.Name2Versions = defaultdict(list)
-    name_id_2_paths: T.NameId2Paths = {}
-    dependencies: T.Dependencies
-    updates: T.Updates = {}
-    
-    def update_name_2_versions() -> None:
-        name_2_versions[ver.name].append(ver.version)
-    
-    def update_name_id_2_paths() -> None:
-        name_id = f'{ver.name}-{ver.version}'
-        downloaded_path = f.path
-        installed_path = '{}/{}/{}'.format(
-            pypi_paths.installed, ver.name, ver.version
-        )
-        name_id_2_paths[name_id] = (
-            fs.relpath(downloaded_path, pypi_paths.root),
-            fs.relpath(installed_path, pypi_paths.root),
-        )
-        if not os.path.exists(installed_path) and perform_pip_install:
-            fs.make_dirs(installed_path)
-            pip.run(
-                'install', downloaded_path,
-                '--no-deps', '--no-index',
-                ('-t', installed_path),
-                ('--find-links', pypi_paths.downloads),
-            )
-    
-    def update_updates() -> None:
-        name = ver.name
-        utime = get_updated_time(f.path)
-        if name not in updates:
-            updates[name] = utime
-        elif utime > updates[name]:
-            updates[name] = utime
-    
-    # -------------------------------------------------------------------------
-    
-    with pip.multi_processing():
-        for f in fs.find_files(pypi_paths.downloads):
-            if f.name.startswith('.'):  # '.gitkeep', '.DS_Store', etc.
-                continue
-            ver = verspec.get_verspec_from_filename(f.name)
-            update_name_2_versions()
-            update_name_id_2_paths()
-            update_updates()
-    
-    # noinspection PyTypeChecker
-    for v in name_2_versions.values():
-        v.sort(key=lambda x: verspec.semver_parse(x), reverse=True)
-        #   make version list sorted in descending order.
-    # print(':l', name_2_versions)
-    
-    # rebuild `dependencies`. this should be called after complete updating
-    # `name_id_2_paths`.
-    dependencies = _rebuild_dependencies(name_2_versions)
-    
-    dumps(name_2_versions, pypi_paths.name_2_versions)
-    dumps(name_id_2_paths, pypi_paths.name_id_2_paths)
-    dumps(dependencies, pypi_paths.dependencies)
-    dumps(updates, pypi_paths.updates)
-
-
-def _rebuild_dependencies(
-        name_2_versions: T.Name2Versions,
-        recursive=True
-) -> T.Dependencies:
-    dependencies: T.Dependencies = {}
-    root = pypi_paths.installed
-    
-    for d0 in fs.find_dirs(root):
-        name = d0.name
-        
-        for d1 in fs.find_dirs(d0.path):
-            version = d1.name
-            name_id = f'{name}-{version}'
-            node = dependencies[name_id] = {'resolved': [], 'unresolved': {}}
-            
-            for d2 in fs.find_dirs(d1.path):
-                if d2.name.endswith('.dist-info'):
-                    if os.path.exists(x := f'{d2.path}/METADATA'):
-                        for (a, b), is_name_id in _analyse_metadata_1(
-                                x, name_2_versions):
-                            if is_name_id:
-                                node['resolved'].append(f'{a}-{b}')
-                            else:
-                                node['unresolved'][a] = tuple(
-                                    norm.normalize_version_spec(a, b)
-                                )
-                    else:
-                        raise FileNotFoundError(d2.path)  # TODO: for debug
-    
-    print(':l', 'origin dependency tree', dependencies)
-    
-    if recursive:
-        def flatten_resolved_dependencies(
-                name_id: T.NameId,
-                collect: t.Set[T.NameId],
-                indent=0,
-        ) -> t.Set[T.NameId]:
-            print('{}{}'.format(' ' * indent, name_id), ':vs')
-            for nid in dependencies[name_id]['resolved']:
-                if nid not in collect:
-                    collect.add(nid)
-                    flatten_resolved_dependencies(nid, collect, indent + 2)
-                else:
-                    print('{}{}'.format(' ' * (indent + 2), nid), ':vs')
-                    if dependencies[nid]['resolved'] \
-                            or dependencies[nid]['unresolved']:
-                        print('{}...'.format(' ' * (indent + 4)), ':vs')
-            return collect
-        
-        def flatten_unresolved_dependencies(
-                name_id: T.NameId,
-                collect: t.Dict[T.Name, t.Dict[str, norm.VersionSpec]],
-                indent=0,
-        ) -> t.Dict[T.Name, T.VersionSpecs]:
-            for name, specs in dependencies[name_id]['unresolved'].items():
-                if name not in collect:
-                    print('{}<{}>'.format(' ' * indent, name), ':vs')
-                    collect[name] = {str(x): x for x in specs}
-                else:  # merge `specs` into `collect[name]`.
-                    for s in specs:
-                        if str(s) not in collect[name]:
-                            collect[name][str(s)] = s
-            for nid in dependencies[name_id]['resolved']:
-                flatten_unresolved_dependencies(nid, collect, indent + 2)
-            return {k: tuple(v.values()) for k, v in collect.items()}
-        
-        old_dependencies: T.Dependencies = dependencies
-        new_dependencies: T.Dependencies = {}
-        for name_id in old_dependencies:
-            new_dependencies[name_id] = {
-                'resolved'  : flatten_resolved_dependencies(name_id, set()),
-                'unresolved': flatten_unresolved_dependencies(name_id, {}),
-            }
-        print(
-            'recursively find dependencies',
-            'the flatten dependencies have inflated from {} to {}'.format(
-                sum(
-                    len(x['resolved']) + len(x['unresolved'])
-                    for x in old_dependencies.values()
-                ),
-                sum(
-                    len(x['resolved']) + len(x['unresolved'])
-                    for x in new_dependencies.values()
-                ),
-            ), ':v2'
-        )
-        dependencies = new_dependencies
-    
-    return dependencies
-
-
-def _analyse_metadata_1(
-        file: T.Path,
-        name_2_versions: T.Name2Versions
-) -> t.Iterator[t.Tuple[t.Tuple[str, str], bool]]:
-    """
-    analyse 'METADATA' file.
-    yields: iter[tuple[result, is_resolved]]
-        result: tuple[str, str]
-            if `is_resolved` is True, result is a `tuple[name, version]`.
-            if `is_resolved` is False, result is a `tuple[name, raw_verspec]`.
-    """
-    pattern = re.compile(r'([-\w]+)(?: \(([^)]+)\))?')
-    
-    #                      ^~~~~~~1      ^~~~~~2
-    #   e.g. 'argsense (>=0.4.2,<0.5.0)' -> ('argsense', '>=0.4.2,<0.5.0')
-    
-    def walk() -> t.Iterator[str]:
-        with ropen(file) as f:
-            flag = 0
-            head = 'Requires-Dist: '
-            for line in f:
-                if not line:
-                    break
-                if flag == 0:
-                    if line.startswith(head):
-                        flag = 1
-                    else:
-                        continue
-                else:
-                    if not line.startswith(head):
-                        break
-                # assert flag == 1
-                yield line[len(head):]
-    
-    for line in walk():
-        if ';' in line:
-            # e.g. 'Requires-Dist: toml; extra == "ext"'
-            continue
-        try:
-            raw_name, raw_verspec = pattern.match(line).groups()
-        except AttributeError as e:
-            print(':lv4', file, line, e)
-            raise e
-        name = norm.normalize_name(raw_name)
-        verspecs = norm.normalize_version_spec(name, raw_verspec or '')
-        proper_version = verspec.find_proper_version(
-            *verspecs,
-            candidates=name_2_versions[name]
-        )
-        if proper_version:
-            yield (name, proper_version), True
-        else:
-            print('cannot find a proper version from local index. you may '
-                  'download it manually later', file, name, raw_verspec, ':v3')
-            yield (name, raw_verspec), False
-
-
-# noinspection PyUnusedLocal
-def _analyse_metadata_2(
-        file: str,
-        name_2_versions: T.Name2Versions
-) -> t.Iterator[T.NameId]:
-    """ analyse 'metadata.json' file. """
-    raise NotImplementedError
-
-
-# -----------------------------------------------------------------------------
-
-def measure_package_size(
-        name: str,
-        version: str = None,
-        include_dependencies=True
-) -> T.PackagesSize:
-    assert name in pypi.name_2_versions
-    if version is None:
-        version = pypi.name_2_versions[name][0]
-    print('measuring package size', name, version)
-    
-    downloaded_size = 0
-    installed_size = 0
-    simple_count = 0
-    out = T.PackagesSize(downloaded={}, installed={})
-    
-    calculated = set()
-    
-    def recurse_measure(name_id: str, indent: int):
-        nonlocal downloaded_size, installed_size, simple_count
-        
-        simple_count += 1
-        print('[dim]\\[{:>02d}][/]{}|- [cyan]{}[/]'.format(
-            simple_count, '   ' * indent, name_id
-        ), ':r')
-        if name_id in calculated:
-            return
-        calculated.add(name_id)
-        
-        downloaded_path, installed_path = pypi.name_id_2_paths[name_id]
-        #   the downloaded_path is a file.
-        #   the installed_path is a directory.
-        #   both are relative paths. be noted to convert them to absolute.
-        
-        downloaded_path, installed_path = (
-            f'{pypi_paths.root}/{downloaded_path}',
-            f'{pypi_paths.root}/{installed_path}'
-        )
-        
-        size1 = _get_file_size(downloaded_path)
-        size2 = _get_folder_size(installed_path)
-        downloaded_size += size1
-        installed_size += size2
-        out.downloaded[name_id] = size1
-        out.installed[name_id] = size2
-        
-        if include_dependencies:
-            for nid in pypi.dependencies[name_id]:
-                recurse_measure(nid, indent + 1)
-    
-    recurse_measure(f'{name}-{version}', 0)
-    
-    print('downloaded size:', _pretty_size(downloaded_size), ':v2')
-    print('installed size:', _pretty_size(installed_size), ':v2')
-    return out
-
-
-def _get_file_size(file: str) -> int:
-    return os.path.getsize(file)
-
-
-def _get_folder_size(folder: str) -> int:
-    return sum(os.path.getsize(x) for x in fs.findall_file_paths(folder))
-
-
-def _pretty_size(size: int) -> str:
-    if size < 1024:
-        return f'{size}B'
-    elif size < 1024 ** 2:
-        return f'{size / 1024:.2f}KB'
-    elif size < 1024 ** 3:
-        return f'{size / 1024 ** 2:.2f}MB'
-    else:
-        return f'{size / 1024 ** 3:.2f}GB'
+import os
+import re
+import sys
+import typing as t
+from collections import defaultdict
+
+from lk_utils import dumps
+from lk_utils import fs
+from lk_utils import loads
+
+from .index import T as T0
+from .pypi import pypi
+from .. import normalization as norm
+from .. import verspec
+from ..paths import pypi as pypi_paths
+
+
+class T(T0):
+    # DELETE
+    Dependencies = dict
+    Name = str
+    NameId = str
+    Path = str
+    
+    PackagesSize = t.NamedTuple('PackagesSize', (
+        ('downloaded', t.Dict[str, int]),
+        ('installed', t.Dict[str, int]),
+    ))
+
+
+def overview(custom_dir: str = None) -> None:
+    if custom_dir:
+        print(loads(f'{custom_dir}/id_2_paths.pkl'), ':ls')
+        print(loads(f'{custom_dir}/name_2_ids.pkl'), ':ls')
+    else:
+        print(pypi.index.id_2_paths, ':l')
+        print(pypi.index.name_2_ids, ':l')
+
+
+def rebuild_index(perform_pip_install: bool = False) -> None:
+    id_2_paths: T.Id2Paths = {}
+    name_2_vers: T.Name2Versions = defaultdict(list)
+    
+    for f in fs.find_files(pypi_paths.downloads):
+        if f.name.startswith('.'):  # '.gitkeep', '.DS_Store', etc.
+            continue
+        name, ver = norm.split_filename_of_package(f.name)
+        name_2_vers[name].append(ver)
+        id = f'{name}-{ver}'
+        
+        # download path and install path
+        down_path = f.path
+        inst_path = '{}/{}/{}'.format(pypi_paths.installed, name, ver)
+        if not fs.exists(inst_path):
+            if perform_pip_install:
+                pypi.install_one(id, down_path, False)
+            else:
+                print('package not installed', id, down_path, inst_path, ':lv4')
+                sys.exit(1)
+        assert fs.exists(inst_path)
+        id_2_paths[id] = (
+            fs.relpath(down_path, pypi_paths.root),
+            fs.relpath(inst_path, pypi_paths.root),
+        )
+        print('id indexed', id, ':is')
+    
+    for vers in name_2_vers.values():
+        verspec.sort_versions(vers, reverse=True)
+    
+    dumps(id_2_paths, pypi_paths.id_2_paths)
+    dumps(name_2_vers, pypi_paths.name_2_vers)
+
+
+def _rebuild_dependencies(
+    name_2_versions: T.Name2Versions,
+    recursive: bool = True
+) -> T.Dependencies:
+    dependencies: T.Dependencies = {}
+    root = pypi_paths.installed
+    
+    for d0 in fs.find_dirs(root):
+        name = d0.name
+        
+        for d1 in fs.find_dirs(d0.path):
+            version = d1.name
+            name_id = f'{name}-{version}'
+            node = dependencies[name_id] = {'resolved': [], 'unresolved': {}}
+            
+            for d2 in fs.find_dirs(d1.path):
+                if d2.name.endswith('.dist-info'):
+                    if os.path.exists(x := f'{d2.path}/METADATA'):
+                        for (a, b), is_name_id in analyze_metadata(
+                            x, name_2_versions
+                        ):
+                            if is_name_id:
+                                node['resolved'].append(f'{a}-{b}')
+                            else:
+                                node['unresolved'][a] = tuple(
+                                    norm.normalize_verspecs(a, b)
+                                )
+                    else:
+                        raise FileNotFoundError(d2.path)  # TODO: for debug
+    
+    print(':l', 'origin dependency tree', dependencies)
+    
+    if recursive:
+        def flatten_resolved_dependencies(
+            name_id: T.NameId,
+            collect: t.Set[T.NameId],
+            indent=0,
+        ) -> t.Set[T.NameId]:
+            print('{}{}'.format(' ' * indent, name_id), ':vs')
+            for nid in dependencies[name_id]['resolved']:
+                if nid not in collect:
+                    collect.add(nid)
+                    flatten_resolved_dependencies(nid, collect, indent + 2)
+                else:
+                    print('{}{}'.format(' ' * (indent + 2), nid), ':vs')
+                    if (
+                        dependencies[nid]['resolved'] or
+                        dependencies[nid]['unresolved']
+                    ):
+                        print('{}...'.format(' ' * (indent + 4)), ':vs')
+            return collect
+        
+        def flatten_unresolved_dependencies(
+            name_id: T.NameId,
+            collect: t.Dict[T.Name, t.Dict[str, norm.VersionSpec]],
+            indent: int = 0,
+        ) -> t.Dict[T.Name, t.Tuple[norm.VersionSpec, ...]]:
+            for name, specs in dependencies[name_id]['unresolved'].items():
+                if name not in collect:
+                    print('{}<{}>'.format(' ' * indent, name), ':vs')
+                    collect[name] = {str(x): x for x in specs}
+                else:  # merge `specs` into `collect[name]`.
+                    for s in specs:
+                        if str(s) not in collect[name]:
+                            collect[name][str(s)] = s
+            for nid in dependencies[name_id]['resolved']:
+                flatten_unresolved_dependencies(nid, collect, indent + 2)
+            return {k: tuple(v.values()) for k, v in collect.items()}  # noqa
+        
+        old_dependencies: T.Dependencies = dependencies
+        new_dependencies: T.Dependencies = {}
+        for name_id in old_dependencies:
+            new_dependencies[name_id] = {
+                'resolved'  : flatten_resolved_dependencies(name_id, set()),
+                'unresolved': flatten_unresolved_dependencies(name_id, {}),
+            }
+        print(
+            'recursively find dependencies',
+            'the flatten dependencies have inflated from {} to {}'.format(
+                sum(
+                    len(x['resolved']) + len(x['unresolved'])
+                    for x in old_dependencies.values()
+                ),
+                sum(
+                    len(x['resolved']) + len(x['unresolved'])
+                    for x in new_dependencies.values()
+                ),
+            ), ':v2'
+        )
+        dependencies = new_dependencies
+    
+    return dependencies
+
+
+def analyze_metadata(
+    file: T.Path, name_2_versions: dict  # FIXME
+) -> t.Iterator[t.Tuple[t.Tuple[str, str], bool]]:
+    """
+    analyse 'METADATA' file.
+    yields: iter[tuple[result, is_resolved]]
+        result: tuple[str, str]
+            if `is_resolved` is True, result is a `tuple[name, version]`.
+            if `is_resolved` is False, result is a `tuple[name, raw_verspec]`.
+    """
+    pattern = re.compile(r'([-\w]+)(?: \(([^)]+)\))?')
+    #                      ~~~~~~~1      ~~~~~~2
+    #   e.g. 'argsense (>=0.4.2,<0.5.0)' -> ('argsense', '>=0.4.2,<0.5.0')
+    
+    def walk() -> t.Iterator[str]:
+        with open(file, 'r', encoding='utf-8') as f:
+            flag = 0
+            head = 'Requires-Dist: '
+            for line in f:
+                if not line:
+                    break
+                if flag == 0:
+                    if line.startswith(head):
+                        flag = 1
+                    else:
+                        continue
+                else:
+                    if not line.startswith(head):
+                        break
+                # assert flag == 1
+                yield line[len(head):]
+    
+    for line in walk():
+        if ';' in line:
+            # e.g. 'Requires-Dist: toml; extra == "ext"'
+            continue
+        try:
+            raw_name, raw_verspec = pattern.match(line).groups()
+        except AttributeError as e:
+            print(':lv4', file, line, e)
+            raise e
+        name = norm.normalize_name(raw_name)
+        verspecs = norm.normalize_verspecs(name, raw_verspec or '')
+        proper_version = verspec.find_proper_version(
+            tuple(verspecs), candidates=name_2_versions[name]
+        )
+        if proper_version:
+            yield (name, proper_version), True
+        else:
+            print('cannot find a proper version from local index. you may '
+                  'download it manually later', file, name, raw_verspec, ':v3')
+            yield (name, raw_verspec), False
+
+
+# noinspection PyUnusedLocal
+def analyze_metadata_2(
+    file: str,
+    name_2_versions: dict  # FIXME
+) -> t.Iterator[T.PackageId]:
+    """ analyse 'metadata.json' file. """
+    raise NotImplementedError
+
+
+# -----------------------------------------------------------------------------
+
+def measure_package_size(
+    name: str,
+    version: str = None,
+    include_dependencies=True
+) -> T.PackagesSize:
+    assert name in pypi.name_2_versions
+    if version is None:
+        version = pypi.name_2_versions[name][0]
+    print('measuring package size', name, version)
+    
+    downloaded_size = 0
+    installed_size = 0
+    simple_count = 0
+    out = T.PackagesSize(downloaded={}, installed={})
+    
+    calculated = set()
+    
+    def recurse_measure(name_id: str, indent: int):
+        nonlocal downloaded_size, installed_size, simple_count
+        
+        simple_count += 1
+        print('[dim]\\[{:>02d}][/]{}|- [cyan]{}[/]'.format(
+            simple_count, '   ' * indent, name_id
+        ), ':r')
+        if name_id in calculated:
+            return
+        calculated.add(name_id)
+        
+        downloaded_path, installed_path = pypi.name_id_2_paths[name_id]
+        #   the downloaded_path is a file.
+        #   the installed_path is a directory.
+        #   both are relative paths. be noted to convert them to absolute.
+        
+        downloaded_path, installed_path = (
+            f'{pypi_paths.root}/{downloaded_path}',
+            f'{pypi_paths.root}/{installed_path}'
+        )
+        
+        size1 = _get_file_size(downloaded_path)
+        size2 = _get_folder_size(installed_path)
+        downloaded_size += size1
+        installed_size += size2
+        out.downloaded[name_id] = size1
+        out.installed[name_id] = size2
+        
+        if include_dependencies:
+            for nid in pypi.dependencies[name_id]:
+                recurse_measure(nid, indent + 1)
+    
+    recurse_measure(f'{name}-{version}', 0)
+    
+    print('downloaded size:', _pretty_size(downloaded_size), ':v2')
+    print('installed size:', _pretty_size(installed_size), ':v2')
+    return out
+
+
+def _get_file_size(file: str) -> int:
+    return os.path.getsize(file)
+
+
+def _get_folder_size(folder: str) -> int:
+    return sum(os.path.getsize(x) for x in fs.findall_file_paths(folder))
+
+
+def _pretty_size(size: int) -> str:
+    if size < 1024:
+        return f'{size}B'
+    elif size < 1024 ** 2:
+        return f'{size / 1024:.2f}KB'
+    elif size < 1024 ** 3:
+        return f'{size / 1024 ** 2:.2f}MB'
+    else:
+        return f'{size / 1024 ** 3:.2f}GB'
```

## depsland/pypi/pypi.py

```diff
@@ -1,321 +1,205 @@
-import os
-import re
-import typing as t
-
-from lk_utils import fs
-
-from .index import Index
-from .index import T as T0
-from .. import normalization as norm
-from ..paths import pypi as pypi_paths
-from ..pip import Pip
-from ..pip import pip as _default_pip
-from ..utils import get_updated_time
-from ..utils import verspec
-from ..venv import link_venv
-
-__all__ = ['T', 'pypi']
-
-
-class T(T0):
-    Pip = Pip
-    VersionSpecs = t.Iterable[norm.VersionSpec]
-    Packages = t.Dict[T0.Name, VersionSpecs]
-
-
-class LocalPyPI(Index):
-    pip: T.Pip
-    
-    def __init__(self, pip=_default_pip):
-        super().__init__()
-        self.pip = pip
-    
-    # -------------------------------------------------------------------------
-    # main methods
-    
-    def download(
-            self,
-            packages: T.Packages,
-            include_dependencies=False,
-            _check_local_existed_versions=True,
-    ) -> t.Iterator[t.Tuple[T.Name, T.Version, T.Path]]:
-        
-        def get_downloaded_path(name_id: str) -> T.Path:
-            return '{}/{}'.format(
-                pypi_paths.root, self.name_id_2_paths[name_id][0]
-            )
-        
-        for name, specs in packages.items():
-            if _check_local_existed_versions:
-                if name in self.name_2_versions:
-                    proper_existed_version = verspec.find_proper_version(
-                        *specs, candidates=self.name_2_versions[name]
-                    )
-                    if proper_existed_version:
-                        name_id = f'{name}-{proper_existed_version}'
-                        filepath = get_downloaded_path(name_id)
-                        print(':v', 'found package from local', name_id)
-                        yield name, proper_existed_version, filepath
-                        
-                        if include_dependencies:
-                            for nid in self.dependencies[name_id]['resolved']:
-                                a, b = nid.split('-', 1)
-                                yield a, b, get_downloaded_path(nid)
-                            if x := self.dependencies[name_id]['unresolved']:
-                                yield from self._download_unresolved_part(x)
-                        continue
-                    else:
-                        print('cannot find proper version in local index, '
-                              'will fallback to default pip download', name)
-            
-            # start downloading
-            print('download package via pip', name)
-            dependencies: t.List[T.NameId] = []  # the resolved part
-            source_name = name
-            source_name_id = ''
-            # del name  # variable `name` is not used below.
-            for filepath, is_new in self._download(
-                    source_name, specs, include_dependencies
-            ):
-                filename = fs.filename(filepath)
-                # extract name and version info from filename.
-                name, version = norm.filename_2_name_version(filename)
-                name_id = f'{name}-{version}'
-                print(':v', 'downloaded package via pip', name_id)
-                
-                if is_new:
-                    # FIXME: insert to a proper position.
-                    self.name_2_versions[name].insert(0, version)
-                if name_id not in self.name_id_2_paths:
-                    # if is_new: the name_id definitely not in ...;
-                    # if not is_new: it is sometimes possible that not in
-                    #   self.name_id_2_paths. e.g. when external caller has
-                    #   downloaded some packages via custom pypi site.
-                    self.name_id_2_paths[name_id] = (
-                        fs.relpath(filepath, pypi_paths.root),
-                        fs.relpath('{}/{}/{}'.format(
-                            pypi_paths.installed, name, version
-                        ), pypi_paths.root)
-                    )
-                    print(':v', 'make dir', f'{pypi_paths.installed}/{name}')
-                    fs.make_dir(f'{pypi_paths.installed}/{name}')
-                yield name, version, filepath
-                # else:
-                #     assert version in self.name_2_versions[name]
-                #     assert name_id in self.version_2_path
-                
-                if name == source_name:
-                    source_name_id = name_id
-                else:
-                    dependencies.append(name_id)
-            assert source_name_id
-            self.dependencies[source_name_id]['resolved'].extend(dependencies)
-    
-    def install(self, packages: T.Packages, include_dependencies=False) \
-            -> t.Iterator[T.NameId]:
-        """
-        yield note:
-            1. the yielded name_ids may duplicate.
-            2. the yielded sequence may be useful (for example to deal with the
-                conflict of dependencies). so don't use `set()` to remove
-                duplicates, use `list(dict.fromkeys())` instead.
-                (ref: https://www.w3schools.com/python/python_howto_remove
-                _duplicates.asp)
-        """
-        
-        def get_installed_path(name_id: str) -> t.Tuple[T.Path, bool]:
-            path = '{}/{}'.format(
-                pypi_paths.root, self.name_id_2_paths[name_id][1]
-            )
-            return path, os.path.exists(path)
-        
-        with self.pip.multi_processing():
-            for name, version, downloaded_path in self.download(
-                    packages, include_dependencies
-            ):
-                name_id = f'{name}-{version}'
-                installed_path, exist = get_installed_path(name_id)
-                if not exist:
-                    print(':v', 'make dir', installed_path)
-                    fs.make_dir(installed_path)
-                    self.pip.run(
-                        'install', downloaded_path,
-                        '--no-deps', '--no-index',
-                        ('-t', installed_path),
-                        ('--find-links', pypi_paths.downloads),
-                    )
-                yield name_id
-    
-    @staticmethod
-    def linking(name_ids: t.Iterable[T.NameId], dst_dir: T.Path) -> None:
-        print(':d', f'linking environment packages to {dst_dir}')
-        print(':l', name_ids)
-        link_venv(name_ids, dst_dir)
-    
-    # -------------------------------------------------------------------------
-    # side methods
-    
-    def add_to_indexes(
-            self,
-            *downloaded_package_files: str,
-            download_dependencies=False
-    ) -> None:
-        name_ids = []
-        with self.pip.multi_processing():
-            for f in downloaded_package_files:
-                name_ids.append(
-                    self.add_to_index(
-                        f,
-                        _indexing_dependencies=False,
-                        _download_dependencies=False,
-                    )
-                )
-        
-        # post indexing dependencies
-        for nid in name_ids:
-            self._indexing_dependencies(nid)
-        
-        # post download dependencies
-        if download_dependencies:
-            for nid in name_ids:
-                if x := self.dependencies[nid]['unresolved']:
-                    print(f'predownload dependencies for {nid}')
-                    # just exhaust the generator
-                    for _ in self._download_unresolved_part(x): pass
-    
-    def add_to_index(
-            self,
-            downloaded_package_file: str,
-            _indexing_dependencies=True,
-            _download_dependencies=True,
-    ) -> T.NameId:
-        filename = fs.filename(downloaded_package_file)
-        name, version = norm.filename_2_name_version(filename)
-        name_id = f'{name}-{version}'
-        
-        path0 = fs.normpath(downloaded_package_file, True)
-        path1 = '{}/{}'.format(pypi_paths.downloads, filename)
-        path2 = '{}/{}/{}'.format(pypi_paths.installed, name, version)
-        
-        def fill_local_dirs() -> None:
-            if path0 != path1:
-                fs.copy_file(path0, path1)
-            if not os.path.exists(path2):
-                print(':v', f'perform local pip install on {name_id}')
-                fs.make_dirs(path2)
-                self.pip.run(
-                    'install', path1, ('-t', path2),
-                    '--no-deps', '--no-index',
-                )
-        
-        def indexing() -> None:
-            self.name_2_versions[name].insert(0, version)
-            
-            self.name_id_2_paths[name_id] = (
-                fs.relpath(path1, pypi_paths.root),
-                fs.relpath(path2, pypi_paths.root),
-            )
-            
-            if _indexing_dependencies:
-                self._indexing_dependencies(name_id)
-            
-            if name not in self.updates:
-                self.updates[name] = get_updated_time(path0)
-            elif (x := get_updated_time(path0)) > self.updates[name]:
-                self.updates[name] = x
-        
-        if name_id not in self.name_id_2_paths:
-            fill_local_dirs()
-            indexing()
-        # else: assert name_id in all indexes...
-        
-        if _download_dependencies:
-            if x := self.dependencies[name_id]['unresolved']:
-                print(f'predownload dependencies for {name_id}')
-                for _ in self._download_unresolved_part(x): pass
-        
-        return name_id
-    
-    # -------------------------------------------------------------------------
-    # general
-    
-    def exists(self, name_or_id: t.Union[T.Name, T.NameId]) -> bool:
-        if '-' not in name_or_id or name_or_id.endswith('-'):
-            name = name_or_id.rstrip('-')
-            return name in self.name_2_versions
-        else:
-            name_id = name_or_id
-            return name_id in self.name_id_2_paths
-    
-    @staticmethod
-    def split(name_id: T.NameId) -> t.Tuple[T.Name, T.Version]:
-        return name_id.split('-', 1)  # noqa
-    
-    def _download(
-            self, name: T.Name, specs: T.VersionSpecs,
-            include_dependencies=False,
-    ) -> t.Iterator[t.Tuple[T.Path, bool]]:
-        """
-        return: iter[tuple[abspath_of_whl_or_tar_file, is_new_file]]
-        """
-        response = self.pip.download(
-            name=name,
-            version=','.join(x.spec for x in specs),
-            dest=pypi_paths.downloads,
-            no_deps=not include_dependencies,
-        )
-        ''' e.g. 1:
-                Looking in indexes: https://pypi.tuna.tsinghua.edu.cn/simple
-                ...
-                  Saved <abspath>
-            e.g. 2:
-                Looking in indexes: https://pypi.tuna.tsinghua.edu.cn/simple
-                ...
-                  File was already downloaded <abspath>
-        '''
-        pattern1 = re.compile(r'(?<=File was already downloaded ).+')
-        pattern2 = re.compile(r'(?<=Saved ).+')
-        for m in pattern1.finditer(response):
-            yield m.group(), False
-        for m in pattern2.finditer(response):
-            yield m.group(), True
-    
-    def _download_unresolved_part(
-            self, packages: T.Packages, clear_then=True,
-    ) -> t.Iterator[t.Tuple[T.Name, T.Version, T.Path]]:
-        yield from self.download(
-            packages,
-            include_dependencies=True,
-            _check_local_existed_versions=False,
-        )
-        if clear_then:
-            packages.clear()
-    
-    def _find_dependencies(self, name_id: str) -> t.Iterator[T.NameId]:
-        from .insight import _analyse_metadata_1
-        dir0 = '{}/{}'.format(
-            pypi_paths.root,
-            self.name_id_2_paths[name_id][1]
-        )
-        for name in os.listdir(dir0):
-            if name.endswith('.dist-info'):
-                dir1 = f'{dir0}/{name}'
-                if os.path.exists(x := f'{dir1}/METADATA'):
-                    yield from _analyse_metadata_1(x, self.name_2_versions)
-                break
-        else:
-            raise Exception(f'cannot find dist-info for {name_id}')
-    
-    def _indexing_dependencies(self, name_id: T.NameId) -> None:
-        for (a, b), is_name_id in self._find_dependencies(name_id):
-            if is_name_id:
-                name, ver = a, b
-                self.dependencies[name_id]['resolved'].append(f'{name}-{ver}')
-            else:
-                name, verspecs_str = a, b
-                self.dependencies[name_id]['unresolved'][name] = tuple(
-                    norm.normalize_version_spec(name, verspecs_str)
-                )
-
-
-pypi = LocalPyPI()
+import re
+import typing as t
+
+from lk_utils import fs
+
+from .index import Index
+from .index import T as T0
+from .. import normalization as norm
+from ..paths import pypi as pypi_paths
+from ..pip import Pip
+from ..pip import pip as _default_pip
+from ..venv import link_venv
+
+__all__ = ['LocalPyPI', 'T', 'pypi']
+
+
+class T(T0):
+    IsNew = bool
+    Path = str
+    VersionSpecs = t.Iterable[norm.VersionSpec]
+
+
+class LocalPyPI:
+    index: Index
+    pip: Pip
+    
+    def __init__(self, pip: Pip = _default_pip) -> None:
+        self.index = Index()
+        self.pip = pip
+        self.update_index = self.index.update_index
+    
+    # -------------------------------------------------------------------------
+    # main methods
+    
+    def download_one(
+        self,
+        pkg_id: T.PackageId,
+        custom_url: str = None,
+        _auto_save_index: bool = True
+    ) -> T.Path:
+        if custom_url:
+            assert pkg_id in custom_url, (pkg_id, custom_url)
+            resp = self.pip.run(
+                ('download', custom_url),
+                ('--no-deps', '--no-index'),
+                ('-d', pypi_paths.downloads),
+            )
+        else:
+            name, ver = self.split(pkg_id)
+            resp = self.pip.download(
+                name, f'=={ver}',
+                no_dependency=True,
+            )
+        for path, _ in self._parse_pip_download_response(resp):
+            if pypi_paths.is_symlink:  # workaround
+                # print(pkg_id, path, ':v')
+                if not path.lower().startswith(pypi_paths.downloads.lower()):
+                    print('fix downloaded path (redirect to symlink)',
+                          pkg_id, ':v3')
+                    assert path.lower().startswith(
+                        pypi_paths.real_root.lower() + '/downloads')
+                    path = '{}/{}'.format(
+                        pypi_paths.downloads, fs.basename(path))
+                    assert fs.exists(path), path
+            if _auto_save_index:
+                self.index.add_to_index(path, 0)
+            return path
+    
+    def install_one(
+        self,
+        pkg_id: T.PackageId,
+        path: T.Path,
+        _auto_save_index: bool = True
+    ) -> T.Path:
+        assert path.endswith(('.tar.gz', '.whl', '.zip')), path
+        src_path = path
+        dst_path = self.get_install_path(pkg_id)
+        if not fs.exists(dst_path):
+            fs.make_dirs(dst_path)
+        try:
+            # https://github.com/pypa/pip/issues/12050
+            self.pip.run('install', src_path, '--no-deps', '-t', dst_path)
+        except Exception as e:
+            fs.remove_tree(dst_path)
+            raise e
+        if _auto_save_index:
+            self.index.add_to_index(dst_path, 1)
+        return dst_path
+    
+    def download_all(
+        self, requirements_file: str, _auto_save_index: bool = True
+    ) -> t.Iterator[t.Tuple[T.Path, T.IsNew]]:
+        resp = self.pip.download_r(requirements_file)
+        for path, isnew in self._parse_pip_download_response(resp):
+            if _auto_save_index:
+                self.index.add_to_index(path, 0)
+                yield path, isnew
+    
+    def install_all(
+        self,
+        downloaded_files: t.Iterable[T.Path],
+        _auto_save_index: bool = True,
+        # _skip_existed: bool = True
+    ) -> t.Iterator[t.Tuple[T.PackageId, T.Path, T.IsNew]]:
+        for src_path in downloaded_files:
+            src_name = fs.basename(src_path)
+            name, version = norm.split_filename_of_package(src_name)
+            pkg_id = f'{name}-{version}'
+            print(pkg_id, ':i2v2s')
+            dst_path = self.get_install_path(pkg_id)
+            if fs.exists(dst_path):
+                yield pkg_id, dst_path, False
+            else:
+                yield pkg_id, self.install_one(pkg_id, src_path, False), True
+            if _auto_save_index:
+                self.index.add_to_index(dst_path, 1)
+    
+    @staticmethod
+    def linking(
+        pkg_ids: t.Iterable[T.PackageId], dst_dir: T.Path, **_kwargs
+    ) -> None:
+        print(':d', f'linking required packages to "{dst_dir}"')
+        # print(':l', pkg_ids)
+        link_venv(pkg_ids, dst_dir, **_kwargs)
+        
+    # -------------------------------------------------------------------------
+    # general
+    
+    # def exists(self, name_or_id: t.Union[T.PackageName, T.PackageId]) -> bool:
+    #     return (name_or_id.rstrip('-')) in self.index
+    
+    def exists(self, package_id: T.PackageId) -> bool:
+        return package_id in self.index
+    
+    def get_download_path(self, pkg_id: T.PackageId) -> T.Path:
+        # FIXME: not a general way
+        return self.index[pkg_id][0]
+    
+    def get_install_path(self, pkg_id: T.PackageId) -> T.Path:
+        return '{}/{}/{}'.format(pypi_paths.installed, *self.split(pkg_id))
+    
+    @staticmethod
+    def split(pkg_id: T.PackageId) -> t.Tuple[T.PackageName, T.ExactVersion]:
+        return pkg_id.split('-', 1)  # noqa
+    
+    # def _find_dependencies(self, pkg_id: str) -> t.Iterator[T.PackageId]:
+    #     from .insight import analyze_metadata
+    #     dir0 = self.index[pkg_id][1]
+    #     for name in os.listdir(dir0):
+    #         if name.endswith('.dist-info'):
+    #             dir1 = f'{dir0}/{name}'
+    #             if os.path.exists(x := f'{dir1}/METADATA'):
+    #                 yield from analyze_metadata(x, self.name_2_versions)
+    #             break
+    #     else:
+    #         raise Exception(f'cannot find dist-info for {pkg_id}')
+    
+    @staticmethod
+    def _parse_pip_download_response(
+        resp: str
+    ) -> t.Iterator[t.Tuple[T.Path, bool]]:
+        """
+        yields: ((abspath, is_newly_downloaded), ...)
+            abspath: normalized with regular slashes ('/').
+                warning:
+                    the letter case maybe varied in windows.
+                    if target directory is symlinked, the response will be -
+                    redirected to real source.
+            is_newly_downloaded: false means got from cache which is alraedy -
+            downloaded.
+        
+        how do we extract the downloaded file path from the raw response?
+            the raw response from `pip download` command. something like:
+                1.
+                    Collecting lk-utils==2.6.0b9
+                      Downloading <some_url> (16 kB)
+                    Saved <some_relpath_or_abspath_dir>/lk_utils-2.6.0b9-py3-
+                    none-any.whl
+                    Successfully downloaded lk-utils
+                2.
+                    Collecting lk-utils==2.6.0b9
+                      File was already downloaded <abspath>/lk_utils-2.6.0-py3-
+                      none-any.whl
+                    Successfully downloaded lk-utils
+                3.
+                    Looking in indexes: https://pypi.tuna.tsinghua.edu.cn/simple
+                    Collecting argsense
+                      Using cached https://pypi.tuna.tsinghua.edu.cn/packages -
+                      /5f/e4/e6eb339f09106a3fd0947cec58275bd5b00c78367db6acf39 -
+                      b49a7393fa0/argsense-0.5.2-py3-none-any.whl (26 kB)
+                    Saved <some_relpath_or_abspath_dir>/argsense-0.5.2-py3 -
+                    -none-any.whl
+                    Successfully downloaded argsense
+                    [notice] A new release of pip is available: 23.2 -> 23.2.1
+                    [notice] To update, run: pip install --upgrade pip
+            we can use regex to parse the line which starts with 'Saved ...' -
+            or 'File was already downloaded ...'.
+        """
+        for p in re.compile(r'File was already downloaded (.+)').findall(resp):
+            yield fs.abspath(p), False
+        for p in re.compile(r'Saved (.+)').findall(resp):
+            yield fs.abspath(p), True
+
+
+pypi = LocalPyPI()
```

## depsland/ui/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-from .appstore import launch_app
+from .appstore import launch_app
```

## depsland/ui/appstore/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-from .app import launch_app
+from .app import launch_app
```

## depsland/ui/appstore/app.py

 * *Ordering differences only*

```diff
@@ -1,229 +1,229 @@
-import os.path
-import typing as t
-from time import sleep
-from traceback import format_exception
-from typing import cast
-
-from lk_utils import new_thread
-from lk_utils import xpath
-from lk_utils.filesniff import filename
-from lk_utils.subproc import ThreadWorker
-from qmlease import AutoProp
-from qmlease import QObject
-from qmlease import app
-from qmlease import bind_signal
-from qmlease import pyassets
-from qmlease import signal
-from qmlease import slot
-
-
-class T:
-    AppToken = t.Optional[str]
-
-
-def launch_app(default: T.AppToken = None, run_at_once: bool = False) -> None:
-    """
-    args:
-        default: an appid or a path to a manifest file.
-            if not given, the app will start normally.
-        run_at_once: if true and default is set, will run app installation \
-            immediately when UI is shown.
-    """
-    pyassets.set_root(xpath('qml/Assets'))
-    app.set_app_icon(xpath('../launcher.ico'))
-    app.register(Home(default, run_at_once))
-    app.run(xpath('qml/Home.qml'))
-
-
-class Home(QObject):
-    running = cast(bool, AutoProp(False))
-    _default: T.AppToken
-    _info_item: QObject
-    _info_updated = signal(str)  # this is for sub-thread to emit.
-    _installation_done = signal(bool)
-    _installing_thread: t.Optional[ThreadWorker] = None
-    _startup_run: bool
-    
-    def __init__(self, app_token: T.AppToken = None, run_at_once: bool = False):
-        super().__init__()
-        self._default = app_token
-        self._startup_run = run_at_once
-    
-    @slot(result=str)
-    def get_app_version(self) -> str:
-        from ... import __version__
-        return f'v{__version__}'
-    
-    @slot(object, object, object, object, object)
-    def init_view(
-            self,
-            input_bar: QObject,
-            install_btn: QObject,
-            stop_btn: QObject,
-            info: QObject,
-            drop_area: QObject,
-    ) -> None:
-        from ...config import auto_saved
-        input_bar['text'] = (
-            self._default or auto_saved['appstore']['last_input']
-        )
-        auto_saved.bind('appstore.last_input', lambda: input_bar['text'])
-        app.on_exit_register(auto_saved.save)
-        
-        self._info_item = info
-        self._info_item['text'] = _default_text = _gray(
-            'Input an appid to install. '
-            'For example: "hello_world".'
-        )
-        
-        def bind_events():
-            
-            @bind_signal(input_bar.submit)
-            def _(text: str) -> None:
-                self._install(text)
-            
-            @bind_signal(install_btn.clicked)
-            def _() -> None:
-                self._install(input_bar['text'])
-            
-            @bind_signal(stop_btn.clicked)
-            def _() -> None:
-                if self._installing_thread.kill():
-                    self._stop_timer()
-                    self._transient_info(
-                        _red('User force stopped.'),
-                        _default_text
-                    )
-                else:
-                    self._transient_info(
-                        _red('Failed to stop the task! If you want to manually '
-                             'stop it, please shutdown the window and restart '
-                             'it.'),
-                        duration=10
-                    )
-            
-            @bind_signal(drop_area.fileDropped)
-            def _(path: str) -> None:
-                if path.endswith(('.pkl', '.yaml', '.yml', '.json')):
-                    if filename(path, suffix=False) == 'manifest':
-                        input_bar['text'] = path
-            
-            # -----------------------------------------------------------------
-            
-            @bind_signal(self.running_changed)
-            def _(running: bool) -> None:
-                install_btn['text'] = 'Install' if not running \
-                    else 'Installing...'
-                stop_btn['width'] = 100 if running else 0
-            
-            @bind_signal(self._info_updated)
-            def _(text: str) -> None:
-                self._info_item['text'] = text
-            
-            @bind_signal(self._installation_done)
-            def _(success: bool) -> None:
-                # self._installing_thread.join()
-                self._stop_timer()
-                if success:
-                    self._transient_info(
-                        _green('Installation done.'),
-                        _default_text
-                    )
-                else:
-                    self._transient_info(
-                        _red('Installation failed. '
-                             'See console output for details.'),
-                        _default_text,
-                        duration=5
-                    )
-        
-        bind_events()
-        
-        if self._startup_run:
-            self._install(self._default)
-    
-    def _install(self, app_token: T.AppToken) -> None:
-        # check ability
-        if self.running:
-            self._transient_info(_yellow('Task is already running!'))
-            return
-        if not app_token:
-            self._transient_info(_red('Appid cannot be empty!'))
-            return
-        
-        if os.path.isabs(app_token):
-            from ...manifest import load_manifest
-            m = load_manifest(app_token)
-            appid = m['appid']
-            is_local = True
-        else:
-            appid = app_token
-            is_local = False
-        
-        @new_thread()
-        def install(text: str, is_local=False) -> None:
-            if is_local:
-                print('detected manifest file. use local install')
-                from ...api.user_api import install_local as install
-            else:
-                from ...api.user_api import install_by_appid as install
-            try:
-                install(text)
-                self._installation_done.emit(True)
-            except Exception as e:
-                print(''.join(format_exception(e)), ':v4')
-                self._installation_done.emit(False)
-        
-        self._start_timer(appid)
-        install(app_token, is_local)
-    
-    @new_thread()
-    def _start_timer(self, appid: str) -> None:
-        print(':t0s')  # reset timer
-        time_sec = 0
-        self.running = True
-        while True:
-            sleep(1)
-            time_sec += 1
-            if self.running:
-                self._info_updated.emit(
-                    f'Installing {appid}... (time elapsed: {time_sec}s)'
-                )
-            else:
-                break
-    
-    def _stop_timer(self) -> None:
-        self.running = False
-    
-    @new_thread()
-    def _transient_info(
-            self,
-            text: str,
-            restore: str = None,
-            duration: float = 3.0
-    ) -> None:
-        """
-        do not set text directly, because sub thread cannot do this. use signal
-        to emit info change.
-        """
-        if restore is None:
-            restore = self._info_item['text']
-        self._info_updated.emit(text)
-        sleep(duration)
-        self._info_updated.emit(restore)
-
-
-def _gray(text: str) -> str:
-    return f'<font color="gray">{text}</font>'
-
-
-def _red(text: str) -> str:
-    return f'<font color="red">{text}</font>'
-
-
-def _green(text: str) -> str:
-    return f'<font color="green">{text}</font>'
-
-
-def _yellow(text: str) -> str:
-    return f'<font color="yellow">{text}</font>'
+import os.path
+import typing as t
+from time import sleep
+from traceback import format_exception
+from typing import cast
+
+from lk_utils import new_thread
+from lk_utils import xpath
+from lk_utils.filesniff import filename
+from lk_utils.subproc import ThreadWorker
+from qmlease import AutoProp
+from qmlease import QObject
+from qmlease import app
+from qmlease import bind_signal
+from qmlease import pyassets
+from qmlease import signal
+from qmlease import slot
+
+
+class T:
+    AppToken = t.Optional[str]
+
+
+def launch_app(default: T.AppToken = None, run_at_once: bool = False) -> None:
+    """
+    args:
+        default: an appid or a path to a manifest file.
+            if not given, the app will start normally.
+        run_at_once: if true and default is set, will run app installation \
+            immediately when UI is shown.
+    """
+    pyassets.set_root(xpath('qml/Assets'))
+    app.set_app_icon(xpath('../launcher.ico'))
+    app.register(Home(default, run_at_once))
+    app.run(xpath('qml/Home.qml'))
+
+
+class Home(QObject):
+    running = cast(bool, AutoProp(False))
+    _default: T.AppToken
+    _info_item: QObject
+    _info_updated = signal(str)  # this is for sub-thread to emit.
+    _installation_done = signal(bool)
+    _installing_thread: t.Optional[ThreadWorker] = None
+    _startup_run: bool
+    
+    def __init__(self, app_token: T.AppToken = None, run_at_once: bool = False):
+        super().__init__()
+        self._default = app_token
+        self._startup_run = run_at_once
+    
+    @slot(result=str)
+    def get_app_version(self) -> str:
+        from ... import __version__
+        return f'v{__version__}'
+    
+    @slot(object, object, object, object, object)
+    def init_view(
+            self,
+            input_bar: QObject,
+            install_btn: QObject,
+            stop_btn: QObject,
+            info: QObject,
+            drop_area: QObject,
+    ) -> None:
+        from ...config import auto_saved
+        input_bar['text'] = (
+            self._default or auto_saved['appstore']['last_input']
+        )
+        auto_saved.bind('appstore.last_input', lambda: input_bar['text'])
+        app.on_exit_register(auto_saved.save)
+        
+        self._info_item = info
+        self._info_item['text'] = _default_text = _gray(
+            'Input an appid to install. '
+            'For example: "hello_world".'
+        )
+        
+        def bind_events():
+            
+            @bind_signal(input_bar.submit)
+            def _(text: str) -> None:
+                self._install(text)
+            
+            @bind_signal(install_btn.clicked)
+            def _() -> None:
+                self._install(input_bar['text'])
+            
+            @bind_signal(stop_btn.clicked)
+            def _() -> None:
+                if self._installing_thread.kill():
+                    self._stop_timer()
+                    self._transient_info(
+                        _red('User force stopped.'),
+                        _default_text
+                    )
+                else:
+                    self._transient_info(
+                        _red('Failed to stop the task! If you want to manually '
+                             'stop it, please shutdown the window and restart '
+                             'it.'),
+                        duration=10
+                    )
+            
+            @bind_signal(drop_area.fileDropped)
+            def _(path: str) -> None:
+                if path.endswith(('.pkl', '.yaml', '.yml', '.json')):
+                    if filename(path, suffix=False) == 'manifest':
+                        input_bar['text'] = path
+            
+            # -----------------------------------------------------------------
+            
+            @bind_signal(self.running_changed)
+            def _(running: bool) -> None:
+                install_btn['text'] = 'Install' if not running \
+                    else 'Installing...'
+                stop_btn['width'] = 100 if running else 0
+            
+            @bind_signal(self._info_updated)
+            def _(text: str) -> None:
+                self._info_item['text'] = text
+            
+            @bind_signal(self._installation_done)
+            def _(success: bool) -> None:
+                # self._installing_thread.join()
+                self._stop_timer()
+                if success:
+                    self._transient_info(
+                        _green('Installation done.'),
+                        _default_text
+                    )
+                else:
+                    self._transient_info(
+                        _red('Installation failed. '
+                             'See console output for details.'),
+                        _default_text,
+                        duration=5
+                    )
+        
+        bind_events()
+        
+        if self._startup_run:
+            self._install(self._default)
+    
+    def _install(self, app_token: T.AppToken) -> None:
+        # check ability
+        if self.running:
+            self._transient_info(_yellow('Task is already running!'))
+            return
+        if not app_token:
+            self._transient_info(_red('Appid cannot be empty!'))
+            return
+        
+        if os.path.isabs(app_token):
+            from ...manifest import load_manifest
+            m = load_manifest(app_token)
+            appid = m['appid']
+            is_local = True
+        else:
+            appid = app_token
+            is_local = False
+        
+        @new_thread()
+        def install(text: str, is_local=False) -> None:
+            if is_local:
+                print('detected manifest file. use local install')
+                from ...api.user_api import install_local as install
+            else:
+                from ...api.user_api import install_by_appid as install
+            try:
+                install(text)
+                self._installation_done.emit(True)
+            except Exception as e:
+                print(''.join(format_exception(e)), ':v4')
+                self._installation_done.emit(False)
+        
+        self._start_timer(appid)
+        install(app_token, is_local)
+    
+    @new_thread()
+    def _start_timer(self, appid: str) -> None:
+        print(':t0s')  # reset timer
+        time_sec = 0
+        self.running = True
+        while True:
+            sleep(1)
+            time_sec += 1
+            if self.running:
+                self._info_updated.emit(
+                    f'Installing {appid}... (time elapsed: {time_sec}s)'
+                )
+            else:
+                break
+    
+    def _stop_timer(self) -> None:
+        self.running = False
+    
+    @new_thread()
+    def _transient_info(
+            self,
+            text: str,
+            restore: str = None,
+            duration: float = 3.0
+    ) -> None:
+        """
+        do not set text directly, because sub thread cannot do this. use signal
+        to emit info change.
+        """
+        if restore is None:
+            restore = self._info_item['text']
+        self._info_updated.emit(text)
+        sleep(duration)
+        self._info_updated.emit(restore)
+
+
+def _gray(text: str) -> str:
+    return f'<font color="gray">{text}</font>'
+
+
+def _red(text: str) -> str:
+    return f'<font color="red">{text}</font>'
+
+
+def _green(text: str) -> str:
+    return f'<font color="green">{text}</font>'
+
+
+def _yellow(text: str) -> str:
+    return f'<font color="yellow">{text}</font>'
```

## depsland/ui/appstore/qml/Home.qml

 * *Ordering differences only*

```diff
@@ -1,116 +1,116 @@
-import QtQml
-import QtQuick
-import LKWidgets
-
-LKWindow {
-    id: root
-    title: 'Depsland Appstore ' + py.home.get_app_version()
-    width: 400
-    height: 24 + _main_column.height + 24
-//    height: childrenRect.height
-
-    LKColumn {
-        id: _main_column
-        anchors {
-            left: parent.left
-            right: parent.right
-            verticalCenter: parent.verticalCenter
-            margins: 24
-        }
-        height: childrenRect.height
-        alignment: 'hfill'
-        spacing: 8
-
-        LKInput {
-            id: _input
-            height: 24
-            showClearButton: true
-        }
-
-        Item {
-            id: _buttons
-            height: 24
-
-            LKButton {
-                id: _stop_btn
-                anchors {
-                    right: parent.right
-                    top: parent.top
-                    bottom: parent.bottom
-                }
-                width: 0
-                text: 'Stop'
-
-                Behavior on width {
-                    NumberAnimation {
-                        duration: 100
-                    }
-                }
-            }
-
-            LKButton {
-                id: _install_btn
-                anchors {
-                    left: parent.left
-                    right: _stop_btn.left
-                    top: parent.top
-                    bottom: parent.bottom
-                    rightMargin: _stop_btn.width > 0 ? 8 : 0
-                }
-                text: 'Install'
-
-                LKIcon {
-                    id: _refresh_icon
-                    anchors {
-                        left: parent.left
-                        verticalCenter: parent.verticalCenter
-                        leftMargin: 12
-                    }
-                    opacity: _refresh_anim.running ? 1 : 0
-                    size: 14
-                    source: pyassets.src('refresh-line.svg')
-    //                color: pycolor.text_hint
-
-                    Behavior on opacity {
-                        NumberAnimation {
-                            duration: 500
-                        }
-                    }
-
-                    RotationAnimator on rotation {
-                        id: _refresh_anim
-                        alwaysRunToEnd: true
-                        from: 0
-                        to: 360
-                        duration: 1000
-                        loops: Animation.Infinite
-                        running: _install_btn.text == 'Installing...'
-                    }
-
-//                    Component.onCompleted: {
-//                        _install_btn.clicked.connect(() => {
-//                            _refresh_anim.running = !_refresh_anim.running
-//                        })
-//                    }
-                }
-            }
-        }
-
-        LKText {
-            id: _info
-            leftPadding: 4
-            color: pycolor.text_secondary
-        }
-    }
-
-    LKFileDrop {
-        id: _drop_area
-        anchors { fill: parent }
-    }
-
-    Component.onCompleted: {
-        py.home.init_view(
-            _input, _install_btn, _stop_btn, _info, _drop_area
-        )
-    }
-}
+import QtQml
+import QtQuick
+import LKWidgets
+
+LKWindow {
+    id: root
+    title: 'Depsland Appstore ' + py.home.get_app_version()
+    width: 400
+    height: 24 + _main_column.height + 24
+//    height: childrenRect.height
+
+    LKColumn {
+        id: _main_column
+        anchors {
+            left: parent.left
+            right: parent.right
+            verticalCenter: parent.verticalCenter
+            margins: 24
+        }
+        height: childrenRect.height
+        alignment: 'hfill'
+        spacing: 8
+
+        LKInput {
+            id: _input
+            height: 24
+            showClearButton: true
+        }
+
+        Item {
+            id: _buttons
+            height: 24
+
+            LKButton {
+                id: _stop_btn
+                anchors {
+                    right: parent.right
+                    top: parent.top
+                    bottom: parent.bottom
+                }
+                width: 0
+                text: 'Stop'
+
+                Behavior on width {
+                    NumberAnimation {
+                        duration: 100
+                    }
+                }
+            }
+
+            LKButton {
+                id: _install_btn
+                anchors {
+                    left: parent.left
+                    right: _stop_btn.left
+                    top: parent.top
+                    bottom: parent.bottom
+                    rightMargin: _stop_btn.width > 0 ? 8 : 0
+                }
+                text: 'Install'
+
+                LKIcon {
+                    id: _refresh_icon
+                    anchors {
+                        left: parent.left
+                        verticalCenter: parent.verticalCenter
+                        leftMargin: 12
+                    }
+                    opacity: _refresh_anim.running ? 1 : 0
+                    size: 14
+                    source: pyassets.src('refresh-line.svg')
+    //                color: pycolor.text_hint
+
+                    Behavior on opacity {
+                        NumberAnimation {
+                            duration: 500
+                        }
+                    }
+
+                    RotationAnimator on rotation {
+                        id: _refresh_anim
+                        alwaysRunToEnd: true
+                        from: 0
+                        to: 360
+                        duration: 1000
+                        loops: Animation.Infinite
+                        running: _install_btn.text == 'Installing...'
+                    }
+
+//                    Component.onCompleted: {
+//                        _install_btn.clicked.connect(() => {
+//                            _refresh_anim.running = !_refresh_anim.running
+//                        })
+//                    }
+                }
+            }
+        }
+
+        LKText {
+            id: _info
+            leftPadding: 4
+            color: pycolor.text_secondary
+        }
+    }
+
+    LKFileDrop {
+        id: _drop_area
+        anchors { fill: parent }
+    }
+
+    Component.onCompleted: {
+        py.home.init_view(
+            _input, _install_btn, _stop_btn, _info, _drop_area
+        )
+    }
+}
```

## depsland/ui/setup_wizard/qml/Main.qml

 * *Ordering differences only*

```diff
@@ -1,7 +1,7 @@
-import QtQuick 2.15
-import LKWidgets 1.0
-
-LKWindow {
-    id: root
-}
-
+import QtQuick 2.15
+import LKWidgets 1.0
+
+LKWindow {
+    id: root
+}
+
```

## depsland/utils/__init__.py

```diff
@@ -1,14 +1,13 @@
-from . import gen_exe
-from . import verspec
-from . import ziptool
-from .gen_exe import bat_2_exe
-from .gen_exe import create_shortcut
-from .chore import make_temp_dir
-from .chore import get_content_hash
-from .chore import get_file_hash
-from .chore import get_updated_time
-from .mklink import mergelink
-from .mklink import mergelinks
-from .mklink import mklink
-from .mklink import mklinks
-from .verspec import compare_version
+from . import compat_py38
+from . import ziptool
+from .compat_py38 import remove_suffix
+from .compat_py38 import substitute_suffix
+from .fs import make_temp_dir
+from .fs import get_content_hash
+from .fs import get_file_hash
+from .fs import get_updated_time
+from .fs import init_target_tree
+from .mklink import mergelink
+from .mklink import mergelinks
+from .mklink import mklink
+from .mklink import mklinks
```

## depsland/utils/mklink.py

```diff
@@ -1,113 +1,107 @@
-import os
-import typing as t
-
-from os.path import exists
-from pathlib import Path
-
-
-def mklink(src: str, dst: str, force=False) -> str:
-    """
-    references:
-        common method to create symlink:
-            https://csatlas.com/python-create-symlink/
-    """
-    assert exists(src), f'source path does not exist: {src}'
-    if force is True and exists(dst):
-        return dst
-    if force is False and exists(dst):
-        raise FileExistsError(f'destination path already exists: {dst}')
-    Path(dst).symlink_to(src)
-    return dst
-
-
-def mklinks(src_dir: str, dst_dir: str,
-            names: t.Optional[t.List[str]] = None,
-            force=False) -> t.List[str]:
-    out = []
-    for n in (names or os.listdir(src_dir)):
-        out.append(mklink(f'{src_dir}/{n}', f'{dst_dir}/{n}', force=force))
-    return out
-
-
-def mergelink(src_dir: str, dst_dir: str, new_dir: str,
-              overwrite: bool = None) -> str:
-    src_names = os.listdir(src_dir)
-    dst_names = os.listdir(dst_dir)
-    
-    for sn in src_names:
-        sub_src_path = f'{src_dir}/{sn}'
-        sub_dst_path = f'{dst_dir}/{sn}'
-        sub_new_path = f'{new_dir}/{sn}'
-        if sn in dst_names:
-            if os.path.isdir(sub_src_path):
-                os.mkdir(sub_new_path)
-                mergelink(
-                    sub_src_path, sub_dst_path, sub_new_path,
-                    overwrite
-                )
-            else:
-                match overwrite:
-                    case None:
-                        mklink(sub_dst_path, sub_new_path)
-                    case True:
-                        mklink(sub_src_path, sub_new_path)
-                    case False:
-                        raise FileExistsError(sub_dst_path)
-        else:
-            mklink(sub_src_path, sub_new_path)
-    
-    new_names = os.listdir(new_dir)
-    for n in dst_names:
-        sub_dst_path = f'{dst_dir}/{n}'
-        sub_new_path = f'{new_dir}/{n}'
-        assert exists(sub_dst_path), (
-            n,
-            n in os.listdir(dst_dir),
-            sub_dst_path
-        )
-        if n not in new_names:
-            mklink(sub_dst_path, sub_new_path)
-    
-    return new_dir
-
-
-def mergelinks(src_dir: str, dst_dir: str,
-               overwrite: bool = None) -> t.List[str]:
-    out = []
-    dst_names = os.listdir(dst_dir)
-    
-    for n in os.listdir(src_dir):
-        src_path = f'{src_dir}/{n}'
-        dst_path = f'{dst_dir}/{n}'
-        
-        if n in dst_names:
-            if os.path.isdir(src_path):
-                print(':v', f'merging "{n}" ({src_dir} -> {dst_dir})')
-                
-                temp = dst_path
-                while exists(temp):
-                    temp += '_bak'
-                else:
-                    os.rename(dst_path, temp)
-                new_path = dst_path
-                dst_path = temp
-                if not exists(new_path):
-                    os.mkdir(new_path)
-                # os.makedirs(new_path, exist_ok=True)
-                
-                mergelink(src_path, dst_path, new_path, overwrite)
-            else:
-                match overwrite:
-                    case None:
-                        pass
-                    case True:
-                        os.remove(dst_path)
-                        mklink(src_path, dst_path)
-                    case False:
-                        raise FileExistsError(dst_path)
-        else:
-            mklink(src_path, dst_path, force=False)
-        
-        out.append(dst_path)
-    
-    return out
+import os
+import typing as t
+from os.path import exists
+from pathlib import Path
+
+
+def mklink(src: str, dst: str, force=False) -> str:
+    """
+    references:
+        common method to create symlink:
+            https://csatlas.com/python-create-symlink/
+    """
+    assert exists(src), f'source path does not exist: {src}'
+    if force is True and exists(dst): return dst
+    if force is False and exists(dst):
+        raise FileExistsError(f'destination path already exists: {dst}')
+    Path(dst).symlink_to(src)
+    return dst
+
+
+def mklinks(
+    src_dir: str,
+    dst_dir: str,
+    names: t.Optional[t.List[str]] = None,
+    force=False,
+) -> t.List[str]:
+    out = []
+    for n in names or os.listdir(src_dir):
+        out.append(mklink(f'{src_dir}/{n}', f'{dst_dir}/{n}', force=force))
+    return out
+
+
+def mergelink(
+    src_dir: str, dst_dir: str, new_dir: str, overwrite: bool = None
+) -> str:
+    src_names = os.listdir(src_dir)
+    dst_names = os.listdir(dst_dir)
+    
+    for sn in src_names:
+        sub_src_path = f'{src_dir}/{sn}'
+        sub_dst_path = f'{dst_dir}/{sn}'
+        sub_new_path = f'{new_dir}/{sn}'
+        if sn in dst_names:
+            if os.path.isdir(sub_src_path):
+                os.mkdir(sub_new_path)
+                mergelink(sub_src_path, sub_dst_path, sub_new_path, overwrite)
+            else:
+                if overwrite is None:
+                    mklink(sub_dst_path, sub_new_path)
+                elif overwrite is True:
+                    mklink(sub_src_path, sub_new_path)
+                else:  # False
+                    raise FileExistsError(sub_dst_path)
+        else:
+            mklink(sub_src_path, sub_new_path)
+    
+    new_names = os.listdir(new_dir)
+    for n in dst_names:
+        sub_dst_path = f'{dst_dir}/{n}'
+        sub_new_path = f'{new_dir}/{n}'
+        assert exists(sub_dst_path), (n, n in os.listdir(dst_dir), sub_dst_path)
+        if n not in new_names:
+            mklink(sub_dst_path, sub_new_path)
+    
+    return new_dir
+
+
+def mergelinks(
+    src_dir: str, dst_dir: str, overwrite: bool = None
+) -> t.List[str]:
+    out = []
+    dst_names = os.listdir(dst_dir)
+    
+    for n in os.listdir(src_dir):
+        src_path = f'{src_dir}/{n}'
+        dst_path = f'{dst_dir}/{n}'
+        
+        if n in dst_names:
+            if os.path.isdir(src_path):
+                print(':v', f'merging "{n}" ({src_dir} -> {dst_dir})')
+                
+                temp = dst_path
+                while exists(temp):
+                    temp += '_bak'
+                else:
+                    os.rename(dst_path, temp)
+                new_path = dst_path
+                dst_path = temp
+                if not exists(new_path):
+                    os.mkdir(new_path)
+                # os.makedirs(new_path, exist_ok=True)
+                
+                mergelink(src_path, dst_path, new_path, overwrite)
+            else:
+                if overwrite is None:
+                    pass
+                elif overwrite is True:
+                    os.remove(dst_path)
+                    mklink(src_path, dst_path)
+                else:  # False
+                    raise FileExistsError(dst_path)
+        else:
+            mklink(src_path, dst_path, force=False)
+        
+        out.append(dst_path)
+    
+    return out
```

## depsland/utils/ziptool.py

```diff
@@ -1,99 +1,119 @@
-import os
-import shutil
-from zipfile import ZipFile
-
-
-def compress_dir(dir_i: str, file_o: str, overwrite: bool = None) -> str:
-    """
-    ref: https://likianta.blog.csdn.net/article/details/126710855
-    """
-    if os.path.exists(file_o):
-        _overwrite(file_o, overwrite)
-    
-    # if dir_i.endswith('/.'):
-    #     dir_i = dir_i[:-2]
-    dir_i_parent = os.path.dirname(dir_i)
-    with ZipFile(file_o, 'w') as z:
-        z.write(dir_i, arcname=os.path.basename(dir_i))
-        for root, dirs, files in os.walk(dir_i):
-            for fn in files:
-                z.write(
-                    fp := os.path.join(root, fn),
-                    arcname=os.path.relpath(fp, dir_i_parent),
-                )
-    
-    return file_o
-
-
-def compress_file(file_i: str, file_o: str, overwrite: bool = None) -> str:
-    if os.path.exists(file_o):
-        _overwrite(file_o, overwrite)
-    
-    if file_o.endswith('.fzip'):  # trick: just rename file_i to file_o
-        shutil.copyfile(file_i, file_o)
-        return file_o
-    
-    with ZipFile(file_o, 'w') as z:
-        z.write(file_i, arcname=os.path.basename(file_i))
-    return file_o
-
-
-def extract_file(file_i: str, path_o: str, overwrite: bool = None) -> str:
-    if os.path.exists(path_o):
-        _overwrite(path_o, overwrite)
-        
-    if file_i.endswith('.fzip'):
-        file_o = path_o
-        shutil.copyfile(file_i, file_o)
-        return file_o
-    else:
-        dir_o = path_o
-        # if dir_o.endswith('/.'):
-        #     dir_o = dir_o[:-2]
-    
-    dirname_o = os.path.basename(os.path.abspath(dir_o))
-    with ZipFile(file_i, 'r') as z:
-        z.extractall(dir_o)
-    
-    dlist = tuple(x for x in os.listdir(dir_o)
-                  if x not in ('.DS_Store', '__MACOSX'))
-    if len(dlist) == 1:
-        x = dlist[0]
-        if os.path.isdir(f'{dir_o}/{x}'):
-            # print(os.listdir(f'{dir_o}/{x}'), ':v')
-            if x == dirname_o:
-                print(f'move up sub folder [cyan]({x})[/] to be parent',
-                      ':vspr')
-                dir_m = f'{dir_o}_tmp'
-                assert not os.path.exists(dir_m)
-                os.rename(dir_o, dir_m)
-                shutil.move(f'{dir_m}/{x}', dir_o)
-                shutil.rmtree(dir_m)
-            else:
-                print(f'notice there is only one folder [magenta]({x})[/] in '
-                      f'this folder: [yellow]{dir_o}[/]. '
-                      f'[dim](we don\'t move up it because its name is not '
-                      f'same with parent.)[/]', ':r')
-    return dir_o
-
-
-def _overwrite(src: str, scheme: bool | None) -> None:
-    """
-    args:
-        scheme:
-            True: overwrite
-            False: not overwrite, and raise an FileExistsError
-            None: not overwrite, no error (skip)
-    """
-    match scheme:
-        case None:  # skip
-            return
-        case True:  # overwrite
-            if os.path.isfile(src):
-                os.remove(src)
-            elif os.path.islink(src):
-                os.unlink(src)
-            else:
-                shutil.rmtree(src)
-        case False:  # raise error
-            raise FileExistsError(src)
+import os
+import shutil
+import typing as t
+from zipfile import ZipFile
+
+_IS_WINDOWS = os.name == 'nt'
+
+
+def compress_dir(dir_i: str, file_o: str, overwrite: bool = None) -> str:
+    """
+    ref: https://likianta.blog.csdn.net/article/details/126710855
+    """
+    if os.path.exists(file_o):
+        if not _overwrite(file_o, overwrite):
+            return file_o
+    # if dir_i.endswith('/.'):
+    #     dir_i = dir_i[:-2]
+    dir_i_parent = os.path.dirname(dir_i)
+    with ZipFile(file_o, 'w') as z:
+        z.write(dir_i, arcname=os.path.basename(dir_i))
+        for root, dirs, files in os.walk(dir_i):
+            for fn in files:
+                z.write(
+                    fp := os.path.join(root, fn),
+                    arcname=os.path.relpath(fp, dir_i_parent),
+                )
+    return file_o
+
+
+def compress_file(file_i: str, file_o: str, overwrite: bool = None) -> str:
+    if os.path.exists(file_o):
+        if not _overwrite(file_o, overwrite):
+            return file_o
+    if file_o.endswith('.fzip'):  # trick: just rename file_i to file_o
+        shutil.copyfile(file_i, file_o)
+        return file_o
+    with ZipFile(file_o, 'w') as z:
+        z.write(file_i, arcname=os.path.basename(file_i))
+    return file_o
+
+
+def extract_file(file_i: str, path_o: str, overwrite: bool = None) -> str:
+    if os.path.exists(path_o):
+        if not _overwrite(path_o, overwrite):
+            return path_o
+    
+    if file_i.endswith('.fzip'):
+        file_o = path_o
+        shutil.copyfile(file_i, file_o)
+        return file_o
+    else:
+        dir_o = path_o
+        # if dir_o.endswith('/.'):
+        #     dir_o = dir_o[:-2]
+    
+    dirname_o = os.path.basename(os.path.abspath(dir_o))
+    with ZipFile(file_i, 'r') as z:
+        if _IS_WINDOWS:
+            # avoid path limit error in windows.
+            # ref: docs/devnote/issues-summary-202401.zh.md
+            z.extractall('\\\\?\\' + dir_o.replace('/', '\\'))
+        else:
+            z.extractall(dir_o)
+    
+    dlist = tuple(
+        x for x in os.listdir(dir_o) if x not in ('.DS_Store', '__MACOSX')
+    )
+    if len(dlist) == 1:
+        x = dlist[0]
+        if os.path.isdir(f'{dir_o}/{x}'):
+            # print(os.listdir(f'{dir_o}/{x}'), ':v')
+            if x == dirname_o:
+                print(
+                    f'move up sub folder [cyan]({x})[/] to be'
+                    ' parent',
+                    ':vspr',
+                )
+                dir_m = f'{dir_o}_tmp'
+                assert not os.path.exists(dir_m)
+                os.rename(dir_o, dir_m)
+                shutil.move(f'{dir_m}/{x}', dir_o)
+                shutil.rmtree(dir_m)
+            else:
+                print(
+                    f'notice there is only one folder [magenta]({x})[/] in '
+                    f'this folder: [yellow]{dir_o}[/]. '
+                    '[dim](we don\'t move up it because its name is not same '
+                    'with its parent.)[/]',
+                    ':r',
+                )
+    return dir_o
+
+
+def _overwrite(src: str, scheme: t.Optional[bool]) -> bool:
+    """
+    args:
+        scheme:
+            True: overwrite
+            False: no overwrite, and raise an FileExistsError
+            None: no overwrite, no error (skip)
+    returns:
+        True tells the caller that we DID overwrite.
+        False tells the caller that we CANNOT overwrite.
+        the caller should check this value and care about what to do next.
+        usually, the caller will go on its work if it True, or return directly \
+        if it False.
+    """
+    if scheme is None:
+        return False
+    if scheme is True:
+        if os.path.isfile(src):
+            os.remove(src)
+        elif os.path.islink(src):
+            os.unlink(src)
+        else:
+            shutil.rmtree(src)
+        return True
+    if scheme is False:
+        raise FileExistsError(src)
```

## depsland/venv/__init__.py

```diff
@@ -1,3 +1,8 @@
-from .create import create_from_file
-from .create import create_venv
-from .emerge import link_venv
+from . import target_venv
+from . import vendor_venv
+
+# -----------------------------------------------------------------------------
+
+from .create import create_from_file
+from .create import create_venv
+from .emerge import link_venv
```

## depsland/venv/create.py

```diff
@@ -1,66 +1,66 @@
-import re
-import typing as t
-from collections import defaultdict
-
-from lk_utils import fs
-from lk_utils import loads
-
-from ..normalization import normalize_name
-from ..normalization import normalize_version_spec
-from ..utils.verspec import semver_parse
-
-
-def create_from_file(dst_dir: str, requirements_file: str) -> None:
-    create_venv(dst_dir, _load_requirements(requirements_file))
-
-
-def _load_requirements(file: str) -> t.Iterator[t.Tuple[str, str]]:
-    pattern = re.compile(r'([-\w]+)(.*)')
-    for line in loads(file).splitlines():
-        line = line.strip()
-        if line and not line.startswith('#'):
-            name, ver = pattern.search(line).groups()
-            ver = ver.replace(' ', '')
-            yield name, ver
-
-
-def create_venv(
-        dst_dir: str,
-        requirements: t.Iterable[t.Tuple[str, str]]
-) -> None:
-    from ..pypi import pypi
-    
-    fs.make_dir(dst_dir)
-    
-    packages = {}
-    for raw_name, raw_vspec in requirements:
-        name = normalize_name(raw_name)
-        vspecs = tuple(normalize_version_spec(name, raw_vspec))
-        packages[name] = vspecs
-    print(':vl', packages)
-    
-    name_ids = pypi.install(packages, include_dependencies=True)
-    name_ids = tuple(dict.fromkeys(name_ids))  # deduplicate and remain sequence
-    name_ids = _resolve_conflicting_name_ids(name_ids)
-    pypi.save_index()
-    pypi.linking(sorted(name_ids), dst_dir)
-
-
-def _resolve_conflicting_name_ids(name_ids: t.Iterable[str]) -> t.Iterable[str]:
-    """
-    if there are multiple versions for one name, for example 'lk_utils-2.4.1'
-    and 'lk_utils-2.5.0', remain the most latest version.
-    FIXME: this may not be a good idea, better to raise an error right once.
-    """
-    name_2_versions = defaultdict(list)
-    for nid in name_ids:
-        a, b = nid.split('-', 1)
-        name_2_versions[a].append(b)
-    if conflicts := {k: v for k, v in name_2_versions.items() if len(v) > 1}:
-        print('found {} conflicting name ids'.format(len(conflicts)),
-              conflicts, ':lv3')
-        for v in conflicts.values():
-            v.sort(key=lambda x: semver_parse(x), reverse=True)
-        return (f'{k}-{v[0]}' for k, v in name_2_versions.items())
-    else:
-        return name_ids
+import re
+import typing as t
+from collections import defaultdict
+
+from lk_utils import fs
+from lk_utils import loads
+
+from ..normalization import normalize_name
+from ..normalization import normalize_verspecs
+from ..verspec import semver_parse
+
+
+def create_from_file(dst_dir: str, requirements_file: str) -> None:
+    create_venv(dst_dir, _load_requirements(requirements_file))
+
+
+def _load_requirements(file: str) -> t.Iterator[t.Tuple[str, str]]:
+    pattern = re.compile(r'([-\w]+)(.*)')
+    for line in loads(file).splitlines():
+        line = line.strip()
+        if line and not line.startswith('#'):
+            name, ver = pattern.search(line).groups()
+            ver = ver.replace(' ', '')
+            yield name, ver
+
+
+def create_venv(
+        dst_dir: str,
+        requirements: t.Iterable[t.Tuple[str, str]]
+) -> None:
+    from ..pypi import pypi
+    
+    fs.make_dir(dst_dir)
+    
+    packages = {}
+    for raw_name, raw_vspec in requirements:
+        name = normalize_name(raw_name)
+        vspecs = tuple(normalize_verspecs(name, raw_vspec))
+        packages[name] = vspecs
+    print(':vl', packages)
+    
+    name_ids = pypi.install(packages, include_dependencies=True)
+    name_ids = tuple(dict.fromkeys(name_ids))  # deduplicate and remain sequence
+    name_ids = _resolve_conflicting_name_ids(name_ids)
+    pypi.save_indexes()
+    pypi.linking(sorted(name_ids), dst_dir)
+
+
+def _resolve_conflicting_name_ids(name_ids: t.Iterable[str]) -> t.Iterable[str]:
+    """
+    if there are multiple versions for one name, for example 'lk_utils-2.4.1'
+    and 'lk_utils-2.5.0', remain the most latest version.
+    FIXME: this may not be a good idea, better to raise an error right once.
+    """
+    name_2_versions = defaultdict(list)
+    for nid in name_ids:
+        a, b = nid.split('-', 1)
+        name_2_versions[a].append(b)
+    if conflicts := {k: v for k, v in name_2_versions.items() if len(v) > 1}:
+        print('found {} conflicting name ids'.format(len(conflicts)),
+              conflicts, ':lv3')
+        for v in conflicts.values():
+            v.sort(key=lambda x: semver_parse(x), reverse=True)
+        return (f'{k}-{v[0]}' for k, v in name_2_versions.items())
+    else:
+        return name_ids
```

## depsland/venv/emerge.py

```diff
@@ -1,98 +1,114 @@
-import os
-import typing as t
-from collections import defaultdict
-
-from lk_utils import fs
-
-from .. import paths
-
-
-class T:
-    NameId = str
-    NameIds = t.Sequence[NameId]
-    AbsPath = str
-    RelPath = str
-    Ownership = t.Dict[RelPath, NameId]
-
-
-def link_venv(
-        name_ids: T.NameIds,
-        venv_dir: T.AbsPath,
-        overwrite: bool = None
-) -> None:
-    dirname_2_name_ids = defaultdict(list)
-    for nid in name_ids:
-        dir_ = _name_id_2_path(nid)
-        for dname in os.listdir(dir_):
-            if dname == '__pycache__':
-                continue
-            dirname_2_name_ids[dname].append(nid)
-    
-    ownership: T.Ownership = {}
-    for dname, name_ids in dirname_2_name_ids.items():
-        if len(name_ids) == 1:
-            ownership[dname] = name_ids[0]
-        else:
-            ownership.update(_distribute_ownerships(dname, name_ids))
-    
-    _init_dirs(venv_dir, ownership.keys())
-    for relpath, name_id in sorted(
-            ownership.items(), key=lambda x: x[1]  # sort by name_id.
-    ):
-        print(name_id, relpath, ':vs')
-        fs.make_link(
-            '{}/{}'.format(_name_id_2_path(name_id), relpath),
-            '{}/{}'.format(venv_dir, relpath),
-            overwrite=overwrite
-        )
-
-
-def _distribute_ownerships(
-        relpath: T.RelPath, candidates: T.NameIds
-) -> T.Ownership:
-    """
-    docs: docs/dev-notes/merge-links-algorithm.md
-    """
-    file_asset_2_name_ids = defaultdict(list)
-    dir_asset_2_name_ids = defaultdict(list)
-    relpath_2_name_id = {}
-    
-    for nid in candidates:
-        dir_ = '{}/{}'.format(_name_id_2_path(nid), relpath)
-        for asset in fs.find_dirs(dir_):
-            if asset.name == '__pycache__':
-                continue
-            dir_asset_2_name_ids[asset.name].append(nid)
-        for asset in fs.find_files(dir_):
-            file_asset_2_name_ids[asset.name].append(nid)
-    
-    for name, name_ids in file_asset_2_name_ids.items():
-        if len(name_ids) > 1:
-            print('multiple owners for a file (will choose the first one)',
-                  name, name_ids, ':v3')
-        relpath_2_name_id[f'{relpath}/{name}'] = name_ids[0]
-    
-    for name, name_ids in dir_asset_2_name_ids.items():
-        if len(name_ids) > 1:
-            print('[yellow dim]multiple owners for a dir (will merge them)[/]',
-                  name, name_ids, ':rv')
-            relpath_2_name_id.update(
-                _distribute_ownerships(f'{relpath}/{name}', name_ids)
-            )
-        else:
-            relpath_2_name_id[f'{relpath}/{name}'] = name_ids[0]
-    
-    return relpath_2_name_id
-
-
-def _init_dirs(root_dir: T.AbsPath, paths: t.Iterable[T.RelPath]) -> None:
-    dirs_to_be_created = set(fs.parent_path(x) for x in paths)
-    dirs_to_be_created.remove('.')
-    for relpath in sorted(dirs_to_be_created):
-        abspath = f'{root_dir}/{relpath}'
-        fs.make_dirs(abspath)
-
-
-def _name_id_2_path(name_id: T.NameId) -> T.AbsPath:
-    name, ver = name_id.split('-', 1)
-    return '{}/{}/{}'.format(paths.pypi.installed, name, ver)
+import os
+import typing as t
+from collections import defaultdict
+
+# from lk_utils import Signal
+from lk_utils import fs
+
+from .. import paths
+
+
+class T:
+    AbsPath = str
+    RelPath = str
+    PackageId = str
+    
+    Ownership = t.Dict[RelPath, PackageId]
+    PackageIds = t.Iterable[PackageId]
+
+
+def link_venv(
+    pkg_ids: T.PackageIds,
+    venv_dir: T.AbsPath,
+    overwrite: bool = None,
+    # _signal: Signal[int] = None
+) -> None:
+    dirname_2_name_ids = defaultdict(list)
+    for pid in pkg_ids:
+        dir_ = _name_id_2_path(pid)
+        # print(pid, dir_, len(os.listdir(dir_)), ':v')
+        for dname in os.listdir(dir_):
+            if dname == '__pycache__':
+                continue
+            dirname_2_name_ids[dname].append(pid)
+    if not dirname_2_name_ids:
+        print('no package to link to venv', ':p')
+        fs.make_dirs(venv_dir)
+        return
+    
+    ownership: T.Ownership = {}
+    for dname, pkg_ids in dirname_2_name_ids.items():
+        if len(pkg_ids) == 1:
+            ownership[dname] = pkg_ids[0]
+        else:
+            ownership.update(_divide_ownerships(dname, pkg_ids))
+    
+    _init_dirs(venv_dir, ownership.keys())
+    for relpath, name_id in sorted(
+        ownership.items(), key=lambda x: x[1]  # sort by name_id.
+    ):
+        print(name_id, relpath, ':vs')
+        fs.make_link(
+            '{}/{}'.format(_name_id_2_path(name_id), relpath),
+            '{}/{}'.format(venv_dir, relpath),
+            overwrite=overwrite,
+        )
+
+
+def _divide_ownerships(
+    relpath: T.RelPath, candidates: T.PackageIds
+) -> T.Ownership:
+    """
+    docs: docs/devnote/merge-links-algorithm.zh.md
+    """
+    file_asset_2_name_ids = defaultdict(list)
+    dir_asset_2_name_ids = defaultdict(list)
+    relpath_2_name_id = {}
+    
+    for pid in candidates:
+        dir_ = '{}/{}'.format(_name_id_2_path(pid), relpath)
+        for asset in fs.find_dirs(dir_):
+            if asset.name == '__pycache__':
+                continue
+            dir_asset_2_name_ids[asset.name].append(pid)
+        for asset in fs.find_files(dir_):
+            file_asset_2_name_ids[asset.name].append(pid)
+    
+    for name, name_ids in file_asset_2_name_ids.items():
+        if len(name_ids) > 1:
+            print(
+                'multiple owners claimed for one file '
+                '(will choose the first one)',
+                name, name_ids, ':v3',
+            )
+        relpath_2_name_id[f'{relpath}/{name}'] = name_ids[0]
+    
+    for name, name_ids in dir_asset_2_name_ids.items():
+        if len(name_ids) > 1:
+            print(
+                '[yellow dim]multiple owners claimed for one dir '
+                '(will merge them)[/]',
+                name, name_ids, ':rv',
+            )
+            relpath_2_name_id.update(
+                _divide_ownerships(f'{relpath}/{name}', name_ids)
+            )
+        else:
+            relpath_2_name_id[f'{relpath}/{name}'] = name_ids[0]
+    
+    return relpath_2_name_id
+
+
+def _init_dirs(root_dir: T.AbsPath, paths: t.Iterable[T.RelPath]) -> None:
+    dirs_to_be_created = set(fs.parent_path(x) for x in paths)
+    print(dirs_to_be_created, ':lv')
+    if '.' in dirs_to_be_created:
+        dirs_to_be_created.remove('.')
+    for relpath in sorted(dirs_to_be_created):
+        abspath = f'{root_dir}/{relpath}'
+        fs.make_dirs(abspath)
+
+
+def _name_id_2_path(name_id: T.PackageId) -> T.AbsPath:
+    name, ver = name_id.split('-', 1)
+    return '{}/{}/{}'.format(paths.pypi.installed, name, ver)
```

## Comparing `depsland/utils/gen_exe/b2e_a/rcedit.exe` & `depsland/platform/launcher/make_exe/bat_2_exe_1/rcedit.exe`

 * *Files identical despite different names*

## Comparing `depsland/utils/gen_exe/b2e_a/template.exe` & `depsland/platform/launcher/make_exe/bat_2_exe_1/template.exe`

 * *Files identical despite different names*

## Comparing `depsland/utils/gen_exe/b2e_a/template_static.exe` & `depsland/platform/launcher/make_exe/bat_2_exe_1/template_static.exe`

 * *Files identical despite different names*

## Comparing `depsland/utils/gen_exe/b2e_b/b2e.exe` & `depsland/platform/launcher/make_exe/bat_2_exe_2/b2e.exe`

 * *Files identical despite different names*

## Comparing `depsland/utils/gen_exe/b2e_b/main.py` & `depsland/platform/launcher/make_exe/bat_2_exe_2/main.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,73 +1,70 @@
-import os
-from os.path import exists
-from subprocess import call
-
-from lk_utils import xpath
-from lk_utils.subproc import compose_cmd
-from lk_utils.time_utils import timeout_gen
-
-_is_windows = os.name == 'nt'
-_b2e_exe = xpath('b2e.exe')
-
-
-def bat_2_exe(
-        file_i: str,
-        file_o: str = '',
-        icon: str = '',
-        show_console: bool = True,
-        uac_admin: bool = False,
-        remove_bat: bool = False,
-) -> str:
-    # validate platform
-    if not _is_windows:
-        raise Exception('the b2e function can only run on Windows')
-    
-    # validate parameters
-    assert file_i.endswith('.bat')
-    if file_o:
-        assert file_o.endswith('.exe')
-    else:
-        file_o = file_i.removesuffix('.bat') + '.exe'
-    if icon:
-        assert icon.endswith('.ico')
-        assert os.path.exists(icon)
-    
-    _bat_2_exe(file_i, file_o, icon, show_console, uac_admin, remove_bat)
-    
-    return file_o
-
-
-# @new_thread(daemon=False)
-def _bat_2_exe(
-        file_bat: str,
-        file_exe: str,
-        icon: str = '',
-        show_console: bool = True,
-        uac_admin: bool = False,
-        remove_bat: bool = False,
-) -> None:
-    """
-    ./b2e.exe -h
-    """
-    if exists(file_exe):
-        os.remove(file_exe)
-    
-    call(compose_cmd(
-        _b2e_exe,
-        ('-bat', file_bat),
-        ('-save', file_exe),
-        ('-icon', icon),
-        ('-invisible' if not show_console else ''),
-        ('-admin' if uac_admin else ''),
-        ('-overwrite', '-x64')
-    ))
-    
-    # wait exe generated
-    for i in timeout_gen(5, 0.1):
-        if i > 10 and i % 10 == 0:
-            print(':v', 'waiting for converting bat to exe...')
-        if exists(file_exe):
-            break
-    
-    if remove_bat:
-        os.remove(file_bat)
+import os
+from os.path import exists
+from subprocess import call
+
+from lk_utils import wait
+from lk_utils import xpath
+from lk_utils.subproc import compose_cmd
+
+from .....utils.compat_py38 import substitute_suffix
+
+_is_windows = os.name == 'nt'
+_b2e_exe = xpath('b2e.exe')
+
+
+def bat_2_exe(
+    file_i: str,
+    file_o: str = '',
+    icon: str = '',
+    show_console: bool = True,
+    uac_admin: bool = False,
+) -> str:
+    # validate platform
+    if not _is_windows:
+        raise Exception('the b2e function can only run on Windows')
+    
+    # validate parameters
+    assert file_i.endswith('.bat')
+    if file_o:
+        assert file_o.endswith('.exe')
+    else:
+        file_o = substitute_suffix(file_i, '.bat', '.exe')
+    if icon:
+        assert icon.endswith('.ico')
+        assert os.path.exists(icon)
+    
+    _bat_2_exe(file_i, file_o, icon, show_console, uac_admin)
+    
+    return file_o
+
+
+# @new_thread(daemon=False)
+def _bat_2_exe(
+    file_bat: str,
+    file_exe: str,
+    icon: str = '',
+    show_console: bool = True,
+    uac_admin: bool = False,
+) -> None:
+    """
+    ./b2e.exe -h
+    """
+    if exists(file_exe):
+        os.remove(file_exe)
+    
+    call(compose_cmd(
+        _b2e_exe,
+        ('-bat', file_bat),
+        ('-save', file_exe),
+        ('-icon', icon),
+        ('-invisible' if not show_console else ''),
+        ('-admin' if uac_admin else ''),
+        ('-overwrite', '-x64')
+    ))
+    
+    # wait exe generated
+    for i in wait(5, 0.1):
+        if i > 10 and i % 10 == 0:
+            print(':v', 'waiting for converting bat to exe...')
+        if exists(file_exe):
+            break
```

## Comparing `depsland/utils/gen_exe/readme.zh.md` & `depsland/platform/launcher/make_exe/readme.zh.md`

 * *Files 22% similar despite different names*

```diff
@@ -1,119 +1,119 @@
-# gen_exe 说明
-
-本目录包含了两个子包: `b2e_a` 和 `b2e_b`. 这里的 a 和 b 是按照时间顺序命名的, 没有其他特殊含义.
-
-下面我会分别说明 a 和 b 包的功能和特点.
-
-## b2e_a
-
-### 来源
-
-该包使用了以下开源项目/工具:
-
-- [gen-exe](https://pypi.org/project/gen-exe/): 用于将 bat 文件转换为 exe 文件.
-- [rcedit](https://github.com/electron/rcedit): 用于修改 exe 文件的属性, 例如替换图标, 添加管理员执行权限等.
-
-### 使用
-
-用法 1:
-
-```py
-from gen_exe.b2e_a import bat_2_exe, add_icon_to_exe, elevate_privilege
-bat_2_exe('test.bat', 'test.exe')
-add_icon_to_exe('test.exe', 'test.ico')
-# elevate_privilege('test.exe')
-```
-
-用法 2:
-
-```py
-# 2 和 1 的功能基本相同, 但是写法更紧凑, 推荐使用 2.
-from gen_exe.b2e_a import bat_2_exe
-bat_2_exe(
-    file_i='test.bat',
-    file_o='test.exe',
-    icon='test.ico',
-    show_console=True,
-    # uac_admin=True,
-    remove_bat=False,  # remove bat if exe generation succeeds.
-)
-```
-
-### 为什么写这个包
-
-为什么不直接用 gen-exe (gen-exe 的缺点):
-
-1. 依赖了 pywin32, 体积有点大, 而且仅能在 windows 下安装 (但我需要在多个系统上工作).
-2. 依赖了 click, 但本项目用不到 (本项目用的是另一个命令行工具).
-3. 我只用到了一部分函数, 所以想把它的方法提炼并简化一下.
-
-为什么使用 rcedit:
-
-1. ~~它可以提升执行权限, 这样在客户机上能够正常使用 depsland 的功能.~~
-2. 它非常小, 只有 1.2mb, 我想把它打包进 depsland 的 whl 文件中.
-
-但注意, rcedit 是一个 exe 文件, 仅能在 windows 下使用.
-
-TODO: 我正在考虑通过 poetry 配置, 分开生成 windows 和 macos 的安装包 (rcedit 文件只会在 windows 平台出现), 以适当减少 macos 的安装体积.
-
-### 注意事项
-
-最近发现使用 rcedit 提升管理员权限会失败, 并且会造成电脑内存压力瞬间暴涨. 因此不再推荐使用本包的 `elevate_privilege` 函数. (我在代码中将它改成了强行触发报错.)
-
-### 参考
-
-- https://stackoverflow.com/questions/1022449/how-to-change-an-executables-properties-windows
-- https://www.zhihu.com/question/27895048
-
-## b2e_b
-
-### 来源
-
-1. https://github.com/tokyoneon/B2E
-2. 谷歌搜索 "bat 2 exe converter", 我找到一个下载链接: https://bat-to-exe-converter-x64.en.softonic.com/
-
-解压后, 有如下目录:
-
-```
-downloads
-|= bat-2-exe-converter
-   |= Examples
-   |= Portable
-      |- Bat_To_Exe_Converter_(x64).exe
-      |- ...
-   |- Bat_To_Exe_Converter_(Setup).exe
-   |- Important-Notice.txt
-```
-
-我拷贝了 `bat-2-exe-converter/Portable/Bat_To_Exe_Converter_(x64).exe` 并重命名为 "b2e.exe", 放在了 `b2e_b` 目录下.
-
-### 使用
-
-...
-
-## 二者对比
-
-- b2e_a
-    - 优点
-        - 速度快
-        - 简单易用
-    - 缺点
-        - 如果设置不显示控制台, 但是启动时会有一个窗口一闪而过, 非常影响体验
-        - 无法提升执行权限
-        - 需要 template.exe 和 rcedit.exe 两个工具
-- b2e_b
-    - 优点
-        - 稳定
-        - 可设置参数丰富
-        - 支持提升执行权限
-    - 缺点
-        - 速度慢 (大约 2 到 5 秒)
-        - 设置图标似乎有问题, 有时候会设置失败, 有时候图标仅支持中等大小, 在大缩略图视图下会看着较小
-
-目前我们的方案是, 除了 `~/build/exe/*.bat` 会用到 b2e_b 外, 其他情况 (主要指在客户端) 用的是 b2e_a.
-
-用到 b2e_b 的情景, 一般是不考虑生成速度, 确保能够提权, 或不显示窗口.
-
-用到 b2e_a 的情景, 对速度敏感, 且一般要求显示控制台窗口.
-
-备注: 推荐多用 b2e_b, 未来可能会移除 b2e_a!
+# make_exe 说明
+
+本目录包含了两个子包: `bat_2_exe_1` 和 `bat_2_exe_2`. 这里末尾的 1 和 2 是按照时间顺序命名的, 没有其他特殊含义.
+
+下面我会分别说明 1 和 2 包的功能和特点.
+
+## bat_2_exe_1
+
+### 来源
+
+该包使用了以下开源项目/工具:
+
+- [gen-exe](https://pypi.org/project/gen-exe/): 用于将 bat 文件转换为 exe 文件.
+- [rcedit](https://github.com/electron/rcedit): 用于修改 exe 文件的属性, 例如替换图标, 添加管理员执行权限等.
+
+### 使用
+
+用法 1:
+
+```py
+from gen_exe.bat_2_exe_1 import bat_2_exe, add_icon_to_exe, elevate_privilege
+bat_2_exe('test.bat', 'test.exe')
+add_icon_to_exe('test.exe', 'test.ico')
+# elevate_privilege('test.exe')
+```
+
+用法 2:
+
+```py
+# 2 和 1 的功能基本相同, 但是写法更紧凑, 推荐使用 2.
+from gen_exe.bat_2_exe_1 import bat_2_exe
+bat_2_exe(
+    file_i='test.bat',
+    file_o='test.exe',
+    icon='test.ico',
+    show_console=True,
+    # uac_admin=True,
+    remove_bat=False,  # remove bat if exe generation succeeds.
+)
+```
+
+### 为什么写这个包
+
+为什么不直接用 gen-exe? -- gen-exe 的缺点:
+
+1. 依赖了 pywin32, 体积有点大, 而且仅能在 windows 下安装 (但我需要在多个系统上工作).
+2. 依赖了 click, 但本项目用不到 (本项目用的是另一个命令行工具).
+3. 我只用到了一部分函数, 所以想把它的方法提炼并简化一下.
+
+为什么使用 rcedit:
+
+1. ~~它可以提升执行权限, 这样在客户机上能够正常使用 depsland 的功能.~~
+2. 它非常小, 只有 1.2mb, 我想把它打包进 depsland 的 whl 文件中.
+
+但注意, rcedit 是一个 exe 文件, 仅能在 windows 下使用.
+
+TODO: 我正在考虑通过 poetry 配置, 分开生成 windows 和 macos 的安装包 (rcedit 文件只会在 windows 平台出现), 以适当减少 macos 的安装体积.
+
+### 注意事项
+
+最近发现使用 rcedit 提升管理员权限会失败, 并且会造成电脑内存压力瞬间暴涨. 因此不再推荐使用本包的 `elevate_privilege` 函数. (我在代码中将它改成了强行触发报错.)
+
+### 参考
+
+- https://stackoverflow.com/questions/1022449/how-to-change-an-executables-properties-windows
+- https://www.zhihu.com/question/27895048
+
+## bat_2_exe_2
+
+### 来源
+
+1. https://github.com/tokyoneon/B2E
+2. 谷歌搜索 "bat 2 exe converter", 我找到一个下载链接: https://bat-to-exe-converter-x64.en.softonic.com/
+
+解压后, 有如下目录:
+
+```
+downloads
+|= bat-2-exe-converter
+   |= Examples
+   |= Portable
+      |- Bat_To_Exe_Converter_(x64).exe
+      |- ...
+   |- Bat_To_Exe_Converter_(Setup).exe
+   |- Important-Notice.txt
+```
+
+我拷贝了 `bat-2-exe-converter/Portable/Bat_To_Exe_Converter_(x64).exe` 并重命名为 "b2e.exe", 放在了 `bat_2_exe_2` 目录下.
+
+### 使用
+
+...
+
+## 二者对比
+
+- bat_2_exe_1
+    - 优点
+        - 速度快
+        - 简单易用
+    - 缺点
+        - 如果设置不显示控制台, 但是启动时会有一个窗口一闪而过, 非常影响体验
+        - 无法提升执行权限
+        - 需要 template.exe 和 rcedit.exe 两个工具
+- bat_2_exe_2
+    - 优点
+        - 稳定
+        - 可设置参数丰富
+        - 支持提升执行权限
+    - 缺点
+        - 速度慢 (大约 2 到 5 秒)
+        - 设置图标似乎有问题, 有时候会设置失败, 有时候图标仅支持中等大小, 在大缩略图视图下会看着较小
+
+目前我们的方案是, 除了 `~/build/exe/*.bat` 会用到 bat_2_exe_2 外, 其他情况 (主要指在客户端) 用的是 bat_2_exe_1.
+
+用到 bat_2_exe_2 的情景, 一般是不考虑生成速度, 确保能够提权, 或不显示窗口.
+
+用到 bat_2_exe_1 的情景, 对速度敏感, 且一般要求显示控制台窗口.
+
+备注: 推荐多用 bat_2_exe_2, 未来可能会移除 bat_2_exe_1!
```

## Comparing `depsland/utils/gen_exe/shortcut.py` & `depsland/platform/launcher/make_shortcut.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,44 +1,44 @@
-import os
-from textwrap import dedent
-
-from lk_utils import dumps
-from lk_utils import run_cmd_args
-
-from ..chore import make_temp_dir
-
-
-def create_shortcut(file_i: str, file_o: str = None) -> None:
-    """
-    use batch script to create shortcut, no pywin32 required.
-
-    args:
-        file_o: if not given, will create a shortcut in the same folder as
-            `file_i`, with the same base name.
-
-    https://superuser.com/questions/455364/how-to-create-a-shortcut-using-a
-    -batch-script
-    https://www.blog.pythonlibrary.org/2010/01/23/using-python-to-create
-    -shortcuts/
-    """
-    assert os.path.exists(file_i) and not file_i.endswith('.lnk')
-    if not file_o:
-        file_o = os.path.splitext(os.path.basename(file_i))[0] + '.lnk'
-    else:
-        assert file_o.endswith('.lnk')
-    if os.path.exists(file_o):
-        os.remove(file_o)
-    
-    vbs = make_temp_dir() + '/shortcut_gen.vbs'
-    command = dedent('''
-        Set objWS = WScript.CreateObject("WScript.Shell")
-        lnkFile = "{file_o}"
-        Set objLink = objWS.CreateShortcut(lnkFile)
-        objLink.TargetPath = "{file_i}"
-        objLink.Save
-    ''').format(
-        file_i=file_i.replace('/', '\\'),
-        file_o=file_o.replace('/', '\\'),
-    )
-    dumps(command, vbs, ftype='plain')
-    
-    run_cmd_args('cscript', '/nologo', vbs)
+import os
+from textwrap import dedent
+
+from lk_utils import dumps
+from lk_utils import run_cmd_args
+
+from ...utils import make_temp_dir
+
+
+def make_shortcut(file_i: str, file_o: str = None) -> None:
+    """
+    use batch script to create shortcut, no pywin32 required.
+
+    args:
+        file_o: if not given, will create a shortcut in the same folder as
+            `file_i`, with the same base name.
+
+    https://superuser.com/questions/455364/how-to-create-a-shortcut-using-a
+    -batch-script
+    https://www.blog.pythonlibrary.org/2010/01/23/using-python-to-create
+    -shortcuts/
+    """
+    assert os.path.exists(file_i) and not file_i.endswith('.lnk')
+    if not file_o:
+        file_o = os.path.splitext(os.path.basename(file_i))[0] + '.lnk'
+    else:
+        assert file_o.endswith('.lnk')
+    if os.path.exists(file_o):
+        os.remove(file_o)
+    
+    vbs = make_temp_dir() + '/shortcut_gen.vbs'
+    command = dedent('''
+        Set objWS = WScript.CreateObject("WScript.Shell")
+        lnkFile = "{file_o}"
+        Set objLink = objWS.CreateShortcut(lnkFile)
+        objLink.TargetPath = "{file_i}"
+        objLink.Save
+    ''').format(
+        file_i=file_i.replace('/', '\\'),
+        file_o=file_o.replace('/', '\\'),
+    )
+    dumps(command, vbs, type='plain')
+    
+    run_cmd_args('cscript', '/nologo', vbs)
```

## Comparing `depsland-0.6.1.dist-info/LICENSE` & `depsland-0.7.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `depsland-0.6.1.dist-info/METADATA` & `depsland-0.7.0.dist-info/METADATA`

 * *Files 27% similar despite different names*

```diff
@@ -1,23 +1,34 @@
 Metadata-Version: 2.1
 Name: depsland
-Version: 0.6.1
-Summary: 
+Version: 0.7.0
+Summary: User oriented dependency management and application distribution tool.
 Home-page: https://github.com/likianta/depsland
 License: MIT
 Author: Likianta
 Author-email: likianta@foxmail.com
-Requires-Python: >=3.10,<4.0
+Requires-Python: >=3.8,<4.0
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
-Requires-Dist: argsense (>=0.5.3,<0.6.0)
+Classifier: Programming Language :: Python :: 3.12
+Requires-Dist: argsense (>=0.5.7,<0.6.0)
 Requires-Dist: conflore (>=0.2.0,<0.3.0)
-Requires-Dist: lk-logger (>=5.6.3,<6.0.0)
-Requires-Dist: lk-utils (>=2.7.0,<3.0.0)
-Requires-Dist: oss2
-Requires-Dist: pyyaml
-Requires-Dist: qmlease (>=3.0.3,<4.0.0)
-Requires-Dist: rich
-Requires-Dist: semver (>=3.0.0dev4,<4.0.0)
-Requires-Dist: windows-toasts ; sys_platform == "win32"
+Requires-Dist: lk-logger (>=5.7.4,<6.0.0)
+Requires-Dist: lk-utils (>=2.10.0,<3.0.0)
+Requires-Dist: numpy (>=1.26.0,<2.0.0) ; python_version >= "3.9"
+Requires-Dist: oss2 (>=2.18.3,<3.0.0)
+Requires-Dist: pandas (>=2.2.2,<3.0.0) ; python_version >= "3.9"
+Requires-Dist: pip (>=24.0.0,<25.0.0)
+Requires-Dist: pipgrip (>=0.10.13,<0.11.0)
+Requires-Dist: poetry (>=1.8.0,<2.0.0)
+Requires-Dist: psutil (>=5.9.8,<6.0.0)
+Requires-Dist: pyapp-window (>=1.0.0,<2.0.0)
+Requires-Dist: pyyaml (>=6.0.0,<7.0.0)
+Requires-Dist: rich (>=13.7.0,<14.0.0)
+Requires-Dist: semver (>=3.0.2,<4.0.0)
+Requires-Dist: streamlit (>=1.34.0,<2.0.0) ; python_full_version != "3.9.7"
+Requires-Dist: streamlit-extras
+Requires-Dist: toml
```

